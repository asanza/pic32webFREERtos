Disassembly Listing for Pic32Web
Generated From:
C:/Users/Diego/Documents/GitHub/pic32webFREERtos/Pic32Web.X/dist/default/debug/Pic32Web.X.debug.elf
31.10.2013 21:14:47

---  src/tcpip/HTTPPrint.h  -----------------------------------------------------------------------------
9D0108C4  27BDFFE8   ADDIU SP, SP, -24
9D0108C8  AFBF0014   SW RA, 20(SP)
9D0108CC  AFBE0010   SW S8, 16(SP)
9D0108D0  03A0F021   ADDU S8, SP, ZERO
9D0108D4  AFC40018   SW A0, 24(S8)
9D0108D8  8FC20018   LW V0, 24(S8)
9D0108DC  2C420030   SLTIU V0, V0, 48
9D0108E0  10400116   BEQ V0, ZERO, 0x9D010D3C
9D0108E4  00000000   NOP
9D0108E8  8FC20018   LW V0, 24(S8)
9D0108EC  00021880   SLL V1, V0, 2
9D0108F0  3C029D01   LUI V0, -25343
9D0108F4  24420908   ADDIU V0, V0, 2312
9D0108F8  00621021   ADDU V0, V1, V0
9D0108FC  8C420000   LW V0, 0(V0)
9D010900  00400008   JR V0
9D010904  00000000   NOP
9D0109C8  3C029D03   LUI V0, -25341
9D0109CC  24420F8C   ADDIU V0, V0, 3980
9D0109D0  00402021   ADDU A0, V0, ZERO
9D0109D4  0F405022   JAL HTTPIncFile
9D0109D8  00000000   NOP
9D0109DC  0B40435E   J 0x9D010D78
9D0109E0  00000000   NOP
9D0109E4  0F4059B3   JAL HTTPPrint_hellomsg
9D0109E8  00000000   NOP
9D0109EC  0B40435E   J 0x9D010D78
9D0109F0  00000000   NOP
9D0109F4  3C029D03   LUI V0, -25341
9D0109F8  24420F98   ADDIU V0, V0, 3992
9D0109FC  00402021   ADDU A0, V0, ZERO
9D010A00  0F405022   JAL HTTPIncFile
9D010A04  00000000   NOP
9D010A08  0B40435E   J 0x9D010D78
9D010A0C  00000000   NOP
9D010A10  0F4059E1   JAL HTTPPrint_cookiename
9D010A14  00000000   NOP
9D010A18  0B40435E   J 0x9D010D78
9D010A1C  00000000   NOP
9D010A20  0F404364   JAL HTTPPrint_
9D010A24  00000000   NOP
9D010A28  0B40435E   J 0x9D010D78
9D010A2C  00000000   NOP
9D010A30  0F4057FC   JAL HTTPPrint_builddate
9D010A34  00000000   NOP
9D010A38  0B40435E   J 0x9D010D78
9D010A3C  00000000   NOP
9D010A40  00002021   ADDU A0, ZERO, ZERO
9D010A44  0F405891   JAL HTTPPrint_led
9D010A48  00000000   NOP
9D010A4C  0B40435E   J 0x9D010D78
9D010A50  00000000   NOP
9D010A54  24040001   ADDIU A0, ZERO, 1
9D010A58  0F405891   JAL HTTPPrint_led
9D010A5C  00000000   NOP
9D010A60  0B40435E   J 0x9D010D78
9D010A64  00000000   NOP
9D010A68  24040002   ADDIU A0, ZERO, 2
9D010A6C  0F405891   JAL HTTPPrint_led
9D010A70  00000000   NOP
9D010A74  0B40435E   J 0x9D010D78
9D010A78  00000000   NOP
9D010A7C  0F405990   JAL HTTPPrint_lcdtext
9D010A80  00000000   NOP
9D010A84  0B40435E   J 0x9D010D78
9D010A88  00000000   NOP
9D010A8C  24040001   ADDIU A0, ZERO, 1
9D010A90  24050001   ADDIU A1, ZERO, 1
9D010A94  0F4058FC   JAL HTTPPrint_ledSelected
9D010A98  00000000   NOP
9D010A9C  0B40435E   J 0x9D010D78
9D010AA0  00000000   NOP
9D010AA4  24040001   ADDIU A0, ZERO, 1
9D010AA8  00002821   ADDU A1, ZERO, ZERO
9D010AAC  0F4058FC   JAL HTTPPrint_ledSelected
9D010AB0  00000000   NOP
9D010AB4  0B40435E   J 0x9D010D78
9D010AB8  00000000   NOP
9D010ABC  24040002   ADDIU A0, ZERO, 2
9D010AC0  24050001   ADDIU A1, ZERO, 1
9D010AC4  0F4058FC   JAL HTTPPrint_ledSelected
9D010AC8  00000000   NOP
9D010ACC  0B40435E   J 0x9D010D78
9D010AD0  00000000   NOP
9D010AD4  24040002   ADDIU A0, ZERO, 2
9D010AD8  00002821   ADDU A1, ZERO, ZERO
9D010ADC  0F4058FC   JAL HTTPPrint_ledSelected
9D010AE0  00000000   NOP
9D010AE4  0B40435E   J 0x9D010D78
9D010AE8  00000000   NOP
9D010AEC  0F40582B   JAL HTTPPrint_version
9D010AF0  00000000   NOP
9D010AF4  0B40435E   J 0x9D010D78
9D010AF8  00000000   NOP
9D010AFC  00002021   ADDU A0, ZERO, ZERO
9D010B00  0F405843   JAL HTTPPrint_btn
9D010B04  00000000   NOP
9D010B08  0B40435E   J 0x9D010D78
9D010B0C  00000000   NOP
9D010B10  24040001   ADDIU A0, ZERO, 1
9D010B14  0F405843   JAL HTTPPrint_btn
9D010B18  00000000   NOP
9D010B1C  0B40435E   J 0x9D010D78
9D010B20  00000000   NOP
9D010B24  24040002   ADDIU A0, ZERO, 2
9D010B28  0F405843   JAL HTTPPrint_btn
9D010B2C  00000000   NOP
9D010B30  0B40435E   J 0x9D010D78
9D010B34  00000000   NOP
9D010B38  0F405970   JAL HTTPPrint_pot
9D010B3C  00000000   NOP
9D010B40  0B40435E   J 0x9D010D78
9D010B44  00000000   NOP
9D010B48  0F405A11   JAL HTTPPrint_uploadedmd5
9D010B4C  00000000   NOP
9D010B50  0B40435E   J 0x9D010D78
9D010B54  00000000   NOP
9D010B58  0F405C7F   JAL HTTPPrint_snmp_en
9D010B5C  00000000   NOP
9D010B60  0B40435E   J 0x9D010D78
9D010B64  00000000   NOP
9D010B68  00002021   ADDU A0, ZERO, ZERO
9D010B6C  0F405BCF   JAL HTTPPrint_read_comm
9D010B70  00000000   NOP
9D010B74  0B40435E   J 0x9D010D78
9D010B78  00000000   NOP
9D010B7C  24040001   ADDIU A0, ZERO, 1
9D010B80  0F405BCF   JAL HTTPPrint_read_comm
9D010B84  00000000   NOP
9D010B88  0B40435E   J 0x9D010D78
9D010B8C  00000000   NOP
9D010B90  24040002   ADDIU A0, ZERO, 2
9D010B94  0F405BCF   JAL HTTPPrint_read_comm
9D010B98  00000000   NOP
9D010B9C  0B40435E   J 0x9D010D78
9D010BA0  00000000   NOP
9D010BA4  00002021   ADDU A0, ZERO, ZERO
9D010BA8  0F405BD9   JAL HTTPPrint_write_comm
9D010BAC  00000000   NOP
9D010BB0  0B40435E   J 0x9D010D78
9D010BB4  00000000   NOP
9D010BB8  24040001   ADDIU A0, ZERO, 1
9D010BBC  0F405BD9   JAL HTTPPrint_write_comm
9D010BC0  00000000   NOP
9D010BC4  0B40435E   J 0x9D010D78
9D010BC8  00000000   NOP
9D010BCC  24040002   ADDIU A0, ZERO, 2
9D010BD0  0F405BD9   JAL HTTPPrint_write_comm
9D010BD4  00000000   NOP
9D010BD8  0B40435E   J 0x9D010D78
9D010BDC  00000000   NOP
9D010BE0  0F405CC3   JAL HTTPPrint_status_fail
9D010BE4  00000000   NOP
9D010BE8  0B40435E   J 0x9D010D78
9D010BEC  00000000   NOP
9D010BF0  0F405B6C   JAL HTTPPrint_config_mac
9D010BF4  00000000   NOP
9D010BF8  0B40435E   J 0x9D010D78
9D010BFC  00000000   NOP
9D010C00  0F405AD8   JAL HTTPPrint_config_hostname
9D010C04  00000000   NOP
9D010C08  0B40435E   J 0x9D010D78
9D010C0C  00000000   NOP
9D010C10  0F405AEE   JAL HTTPPrint_config_dhcpchecked
9D010C14  00000000   NOP
9D010C18  0B40435E   J 0x9D010D78
9D010C1C  00000000   NOP
9D010C20  0F405B0D   JAL HTTPPrint_config_ip
9D010C24  00000000   NOP
9D010C28  0B40435E   J 0x9D010D78
9D010C2C  00000000   NOP
9D010C30  0F405B20   JAL HTTPPrint_config_gw
9D010C34  00000000   NOP
9D010C38  0B40435E   J 0x9D010D78
9D010C3C  00000000   NOP
9D010C40  0F405B33   JAL HTTPPrint_config_subnet
9D010C44  00000000   NOP
9D010C48  0B40435E   J 0x9D010D78
9D010C4C  00000000   NOP
9D010C50  0F405B46   JAL HTTPPrint_config_dns1
9D010C54  00000000   NOP
9D010C58  0B40435E   J 0x9D010D78
9D010C5C  00000000   NOP
9D010C60  0F405B59   JAL HTTPPrint_config_dns2
9D010C64  00000000   NOP
9D010C68  0B40435E   J 0x9D010D78
9D010C6C  00000000   NOP
9D010C70  0F405BE3   JAL HTTPPrint_reboot
9D010C74  00000000   NOP
9D010C78  0B40435E   J 0x9D010D78
9D010C7C  00000000   NOP
9D010C80  0F405BE9   JAL HTTPPrint_rebootaddr
9D010C84  00000000   NOP
9D010C88  0B40435E   J 0x9D010D78
9D010C8C  00000000   NOP
9D010C90  0F405C97   JAL HTTPPrint_status_ok
9D010C94  00000000   NOP
9D010C98  0B40435E   J 0x9D010D78
9D010C9C  00000000   NOP
9D010CA0  0F405C67   JAL HTTPPrint_smtps_en
9D010CA4  00000000   NOP
9D010CA8  0B40435E   J 0x9D010D78
9D010CAC  00000000   NOP
9D010CB0  0F405C21   JAL HTTPPrint_ddns_status
9D010CB4  00000000   NOP
9D010CB8  0B40435E   J 0x9D010D78
9D010CBC  00000000   NOP
9D010CC0  0F405C39   JAL HTTPPrint_ddns_status_msg
9D010CC4  00000000   NOP
9D010CC8  0B40435E   J 0x9D010D78
9D010CCC  00000000   NOP
9D010CD0  00002021   ADDU A0, ZERO, ZERO
9D010CD4  0F405C17   JAL HTTPPrint_ddns_service
9D010CD8  00000000   NOP
9D010CDC  0B40435E   J 0x9D010D78
9D010CE0  00000000   NOP
9D010CE4  24040001   ADDIU A0, ZERO, 1
9D010CE8  0F405C17   JAL HTTPPrint_ddns_service
9D010CEC  00000000   NOP
9D010CF0  0B40435E   J 0x9D010D78
9D010CF4  00000000   NOP
9D010CF8  24040002   ADDIU A0, ZERO, 2
9D010CFC  0F405C17   JAL HTTPPrint_ddns_service
9D010D00  00000000   NOP
9D010D04  0B40435E   J 0x9D010D78
9D010D08  00000000   NOP
9D010D0C  0F405BFF   JAL HTTPPrint_ddns_user
9D010D10  00000000   NOP
9D010D14  0B40435E   J 0x9D010D78
9D010D18  00000000   NOP
9D010D1C  0F405C07   JAL HTTPPrint_ddns_pass
9D010D20  00000000   NOP
9D010D24  0B40435E   J 0x9D010D78
9D010D28  00000000   NOP
9D010D2C  0F405C0F   JAL HTTPPrint_ddns_host
9D010D30  00000000   NOP
9D010D34  0B40435E   J 0x9D010D78
9D010D38  00000000   NOP
9D010D3C  938281E8   LBU V0, -32280(GP)
9D010D40  00401821   ADDU V1, V0, ZERO
9D010D44  3C02A000   LUI V0, -24576
9D010D48  000318C0   SLL V1, V1, 3
9D010D4C  24420600   ADDIU V0, V0, 1536
9D010D50  00621021   ADDU V0, V1, V0
9D010D54  90420004   LBU V0, 4(V0)
9D010D58  00401821   ADDU V1, V0, ZERO
9D010D5C  3C029D03   LUI V0, -25341
9D010D60  24420FA4   ADDIU V0, V0, 4004
9D010D64  00602021   ADDU A0, V1, ZERO
9D010D68  00402821   ADDU A1, V0, ZERO
9D010D6C  24060004   ADDIU A2, ZERO, 4
9D010D70  0F4004E1   JAL TCPPutArray
9D010D74  00000000   NOP
9D010D78  03C0E821   ADDU SP, S8, ZERO
9D010D7C  8FBF0014   LW RA, 20(SP)
9D010D80  8FBE0010   LW S8, 16(SP)
9D010D84  27BD0018   ADDIU SP, SP, 24
9D010D88  03E00008   JR RA
9D010D8C  00000000   NOP
9D010D90  27BDFFE8   ADDIU SP, SP, -24
9D010D94  AFBF0014   SW RA, 20(SP)
9D010D98  AFBE0010   SW S8, 16(SP)
9D010D9C  03A0F021   ADDU S8, SP, ZERO
9D010DA0  938281E8   LBU V0, -32280(GP)
9D010DA4  00401821   ADDU V1, V0, ZERO
9D010DA8  3C02A000   LUI V0, -24576
9D010DAC  000318C0   SLL V1, V1, 3
9D010DB0  24420600   ADDIU V0, V0, 1536
9D010DB4  00621021   ADDU V0, V1, V0
9D010DB8  90420004   LBU V0, 4(V0)
9D010DBC  00402021   ADDU A0, V0, ZERO
9D010DC0  2405007E   ADDIU A1, ZERO, 126
9D010DC4  0F40040C   JAL TCPPut
9D010DC8  00000000   NOP
9D010DCC  03C0E821   ADDU SP, S8, ZERO
9D010DD0  8FBF0014   LW RA, 20(SP)
9D010DD4  8FBE0010   LW S8, 16(SP)
9D010DD8  27BD0018   ADDIU SP, SP, 24
9D010DDC  03E00008   JR RA
9D010DE0  00000000   NOP
---  c:/program files (x86)/microchip/xc32/v1.21/pic32mx/include/peripheral/system.h  -------------------
1:                   /********************************************************************
2:                   
3:                   	System Library Interface Definition
4:                   	
5:                   	Summary:
6:                   		This file contains the interface definition for the System
7:                   		peripheral library.
8:                   		
9:                   	Description:
10:                  		This library provides functions for configuring the peripheral
11:                  		clock, cache settings, and wait states.  For details on the
12:                  		register and bit settings used by these functions, refer to the
13:                  		PIC32 Family Reference Manual.
14:                  
15:                  
16:                   ********************************************************************/
17:                  //DOM-IGNORE-BEGIN
18:                  /********************************************************************
19:                   * FileName:		System.h
20:                   * Dependencies:
21:                   * Processor:		PIC32
22:                   * Hardware:		N/A
23:                   * Assembler:		N/A
24:                   * Linker:		    N/A
25:                   * Company:		    Microchip Technology Inc.
26:                   *
27:                   * Software License Agreement:
28:                   * The software supplied herewith by Microchip Technology Incorporated
29:                   * (the ?Company?) for its PICmicro® Microcontroller is intended and
30:                   * supplied to you, the Company?s customer, for use solely and
31:                   * exclusively on Microchip PICmicro Microcontroller products. The
32:                   * software is owned by the Company and/or its supplier, and is
33:                   * protected under applicable copyright laws. All rights are reserved.
34:                   * Any use in violation of the foregoing restrictions may subject the
35:                   * user to criminal sanctions under applicable laws, as well as to
36:                   * civil liability for the breach of the terms and conditions of this
37:                   * license.
38:                   *
39:                   * THIS SOFTWARE IS PROVIDED IN AN ?AS IS? CONDITION. NO WARRANTIES,
40:                   * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
41:                   * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
42:                   * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
43:                   * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
44:                   * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
45:                   *
46:                   * $Id: CoreTimer.h,v 1.2 2006/11/03 15:07:21 C12923 Exp $
47:                   * $Name:  $
48:                   ********************************************************************/
49:                  //DOM-IGNORE-END
50:                   
51:                   
52:                  #ifndef _SYSTEM_HEADER_FILE
53:                  #define _SYSTEM_HEADER_FILE
54:                  
55:                  #include <xc.h>
56:                  #include <peripheral/int.h>
57:                  #include <peripheral/pcache.h>
58:                  #include <peripheral/osc.h>
59:                  #include <peripheral/dma.h>
60:                  #include <peripheral/bmx.h>
61:                  #include <peripheral/lock.h>
62:                  #ifdef __cplusplus
63:                  extern "C"
64:                    {
65:                  #endif
66:                  #define FLASH_SPEED_HZ          30000000 //Max Flash speed
67:                  #define PB_BUS_MAX_FREQ_HZ      80000000 //Max Peripheral bus speed
68:                  
69:                  /*********************************************************************
70:                   * SYSTEMConfig Flags
71:                   *********************************************************************/
72:                  #define SYS_CFG_WAIT_STATES     0x00000001 //SYSTEMConfig wait states
73:                  #define SYS_CFG_PB_BUS          0x00000002 //SYSTEMConfig pb bus
74:                  #define SYS_CFG_PCACHE          0x00000004 //SYSTEMConfig cache
75:                  #define SYS_CFG_ALL             0xFFFFFFFF //SYSTEMConfig All
76:                  
77:                  /*********************************************************************
78:                   Function:       
79:                  	unsigned int SYSTEMConfigPB(unsigned int sys_clock)
80:                   
81:                   Description:
82:                  	The function sets the PB divider to the optimum value.
83:                   
84:                   PreCondition:    
85:                  	None
86:                   
87:                   Parameters:           
88:                  	sys_clock - system clock in Hz
89:                   
90:                   Returns:          
91:                  	the PB clock frequency in Hz
92:                   
93:                   Side Effects:
94:                  	The PB clock may be changed
95:                  	
96:                   Overview:	    
97:                  	The function sets the PB divider to the optimum value.
98:                   
99:                   Remarks:            
100:                 	The interrupts are disabled briefly, the DMA is suspended and the system is unlocked while performing the operation.
101:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
102:                  
103:                  Example:
104:                 	<code>
105:                 	SYSTEMConfigPB(72000000);
106:                 	</code>
107:                  ********************************************************************/
108:                 extern inline unsigned int __attribute__((always_inline)) SYSTEMConfigPB(unsigned int sys_clock)
109:                 {
110:                     unsigned int pb_div;
111:                     unsigned int pb_clock;
112:                 
113:                     pb_clock = sys_clock;
9D0309A8  8FC20018   LW V0, 24(S8)
9D0309AC  AFC2001C   SW V0, 28(S8)
114:                 
115:                     if(sys_clock > PB_BUS_MAX_FREQ_HZ)
9D0309B0  8FC30018   LW V1, 24(S8)
9D0309B4  3C0204C4   LUI V0, 1220
9D0309B8  3442B401   ORI V0, V0, -19455
9D0309BC  0062102B   SLTU V0, V1, V0
9D0309C0  14400008   BNE V0, ZERO, 0x9D0309E4
9D0309C4  00000000   NOP
116:                     {
117:                         pb_div=OSC_PB_DIV_2;
9D0309C8  3C020008   LUI V0, 8
9D0309CC  AFC20020   SW V0, 32(S8)
118:                         pb_clock >>= 1;
9D0309D0  8FC2001C   LW V0, 28(S8)
9D0309D4  00021042   SRL V0, V0, 1
9D0309D8  AFC2001C   SW V0, 28(S8)
9D0309DC  0B40C27A   J 0x9D0309E8
9D0309E0  00000000   NOP
119:                     }
120:                     else
121:                     {
122:                         pb_div=OSC_PB_DIV_1;
9D0309E4  AFC00020   SW ZERO, 32(S8)
9D0309E8  8FC20020   LW V0, 32(S8)
9D0309EC  AFC20024   SW V0, 36(S8)
123:                     }
124:                 
125:                     OSCSetPBDIV(pb_div);
126:                 
127:                     return pb_clock;
9D030B30  8FC2001C   LW V0, 28(S8)
128:                 }
129:                 
130:                 
131:                 /*********************************************************************
132:                   Function:        
133:                 	void SYSTEMConfigWaitStates(unsigned int sys_clock)
134:                  
135:                   Description:
136:                 	The function sets the Flash Wait states to the optimum value.
137:                  
138:                   PreCondition:    
139:                 	None
140:                  
141:                   Parameters:           
142:                 	sys_clock - system clock in Hz
143:                  
144:                   Returns:          
145:                 	None
146:                  
147:                   Side Effects:    
148:                 	The Wait States may be changed  
149:                  
150:                   Remarks:         
151:                 	The interrupts are disabled briefly, the DMA is suspended and the system is unlocked while performing the operation.
152:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
153:                  
154:                   Example:
155:                 	<code>
156:                 	SYSTEMConfigWaitStates(72000000);
157:                 	</code>
158:                  ********************************************************************/
159:                 extern inline void __attribute__((always_inline)) SYSTEMConfigWaitStates(unsigned int sys_clock)
160:                 {
161:                 #ifdef _PCACHE
162:                     unsigned int wait_states;
163:                     unsigned int int_status;
164:                 #endif
165:                 
166:                 #ifdef _PCACHE
167:                     wait_states = 0;
168:                 
169:                     while(sys_clock > FLASH_SPEED_HZ)
170:                     {
171:                         wait_states++;
172:                         sys_clock -= FLASH_SPEED_HZ;
173:                     }
174:                 
175:                     int_status=INTDisableInterrupts();
176:                     mCheConfigure(wait_states);
177:                     INTRestoreInterrupts(int_status);
178:                 
179:                 #endif
180:                 }
181:                 
182:                 /*********************************************************************
183:                   Function:        
184:                 		unsigned int SYSTEMConfigWaitStatesAndPB(unsigned int sys_clock)
185:                   
186:                   Description:
187:                 	The function sets the PB divider and the Flash Wait states to the optimum value.
188:                  
189:                   PreCondition:    
190:                 	None
191:                  
192:                   Parameters:           
193:                 	sys_clock - system clock in Hz
194:                  
195:                   Returns:          
196:                 	the PB clock frequency in Hz
197:                  
198:                   Side Effects:    
199:                 	The PB clock and wait states may be changed
200:                 
201:                   Remarks:            
202:                 	The interrupts are disabled briefly, the DMA is suspended and the system is unlocked while performing the operation.
203:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
204:                  
205:                   Example:
206:                 	<code>
207:                 	SYSTEMConfigWaitStatesAndPB(72000000);
208:                 	</code>
209:                  ********************************************************************/
210:                 extern inline unsigned int __attribute__((always_inline)) SYSTEMConfigWaitStatesAndPB(unsigned int sys_clock)
211:                 {
212:                 #ifdef _PCACHE
213:                     unsigned int wait_states;
214:                 #endif
215:                     unsigned int pb_clock;
216:                     unsigned int int_status;
217:                 
218:                     pb_clock = SYSTEMConfigPB(sys_clock);
9D030B34  AFC2003C   SW V0, 60(S8)
219:                 
220:                 
221:                     // set the flash wait states based on 1 wait state
222:                     // for every 20 MHz
223:                 #ifdef _PCACHE
224:                     wait_states = 0;
9D030B38  AFC00040   SW ZERO, 64(S8)
9D030B3C  0B40C2D9   J 0x9D030B64
9D030B40  00000000   NOP
225:                 
226:                     while(sys_clock > FLASH_SPEED_HZ)
9D030B64  8FC30014   LW V1, 20(S8)
9D030B68  3C0201C9   LUI V0, 457
9D030B6C  3442C381   ORI V0, V0, -15487
9D030B70  0062102B   SLTU V0, V1, V0
9D030B74  1040FFF3   BEQ V0, ZERO, 0x9D030B44
9D030B78  00000000   NOP
227:                     {
228:                         wait_states++;
9D030B44  8FC20040   LW V0, 64(S8)
9D030B48  24420001   ADDIU V0, V0, 1
9D030B4C  AFC20040   SW V0, 64(S8)
229:                         sys_clock -= FLASH_SPEED_HZ;
9D030B50  8FC30014   LW V1, 20(S8)
9D030B54  3C02FE36   LUI V0, -458
9D030B58  34423C80   ORI V0, V0, 15488
9D030B5C  00621021   ADDU V0, V1, V0
9D030B60  AFC20014   SW V0, 20(S8)
230:                     }
231:                 
232:                     int_status=INTDisableInterrupts();
9D030B7C  0F40D89C   JAL INTDisableInterrupts
9D030B80  00000000   NOP
9D030B84  AFC20044   SW V0, 68(S8)
233:                     mCheConfigure(wait_states);
9D030B88  3C02BF88   LUI V0, -16504
9D030B8C  8FC30040   LW V1, 64(S8)
9D030B90  AC434000   SW V1, 16384(V0)
234:                     INTRestoreInterrupts(int_status);
9D030B94  8FC40044   LW A0, 68(S8)
9D030B98  0F40D874   JAL INTRestoreInterrupts
9D030B9C  00000000   NOP
235:                 
236:                 #endif
237:                 
238:                     return pb_clock;
9D030BA0  8FC2003C   LW V0, 60(S8)
239:                 }
240:                 /*********************************************************************
241:                   Function:       
242:                 	unsigned int SYSTEMConfigPerformance(unsigned int sys_clock)
243:                  
244:                   Description:
245:                 	The function sets the PB divider, the Flash Wait states and the DRM wait states to the optimum value.
246:                     It also enables the cacheability for the K0 segment.
247:                 	
248:                   PreCondition:    
249:                 	None
250:                  
251:                   Parameters:           
252:                 	sys_clock - system clock in Hz
253:                  
254:                   Output:          
255:                 	the PB clock frequency in Hz
256:                  
257:                   Side Effects:    
258:                 	Sets the PB and Flash Wait states
259:                  	
260:                   Remarks:            
261:                 	The interrupts are disabled briefly, the DMA is suspended and the system is unlocked while performing the operation.
262:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
263:                  
264:                   Example:
265:                 	<code>
266:                 	SYSTEMConfigPerformance(72000000);
267:                 	</code>
268:                  ********************************************************************/
269:                 extern inline unsigned int __attribute__((always_inline)) SYSTEMConfigPerformance(unsigned int sys_clock)
270:                 {
271:                     // set up the wait states
272:                     unsigned int pb_clk;
273:                 #ifdef _PCACHE
274:                     unsigned int cache_status;
275:                 #endif
276:                     unsigned int int_status;
277:                 
278:                     pb_clk = SYSTEMConfigWaitStatesAndPB(sys_clock);
9D030BA4  AFC20048   SW V0, 72(S8)
279:                 
280:                     int_status=INTDisableInterrupts();
9D030BA8  0F40D89C   JAL INTDisableInterrupts
9D030BAC  00000000   NOP
9D030BB0  AFC2004C   SW V0, 76(S8)
281:                 
282:                     mBMXDisableDRMWaitState();
9D030BB4  3C02BF88   LUI V0, -16504
9D030BB8  24030040   ADDIU V1, ZERO, 64
9D030BBC  AC432004   SW V1, 8196(V0)
283:                 
284:                 #ifdef _PCACHE
285:                     cache_status = mCheGetCon();
9D030BC0  3C02BF88   LUI V0, -16504
9D030BC4  8C424000   LW V0, 16384(V0)
9D030BC8  AFC20050   SW V0, 80(S8)
286:                     cache_status |= CHE_CONF_PF_ALL;
9D030BCC  8FC20050   LW V0, 80(S8)
9D030BD0  34420030   ORI V0, V0, 48
9D030BD4  AFC20050   SW V0, 80(S8)
287:                     mCheConfigure(cache_status);
9D030BD8  3C02BF88   LUI V0, -16504
9D030BDC  8FC30050   LW V1, 80(S8)
9D030BE0  AC434000   SW V1, 16384(V0)
288:                     CheKseg0CacheOn();
9D030BE4  0F40D887   JAL CheKseg0CacheOn
9D030BE8  00000000   NOP
289:                 #endif
290:                 
291:                     INTRestoreInterrupts(int_status);
9D030BEC  8FC4004C   LW A0, 76(S8)
9D030BF0  0F40D874   JAL INTRestoreInterrupts
9D030BF4  00000000   NOP
292:                 
293:                     return pb_clk;
9D030BF8  3C020008   LUI V0, 8
9D030BFC  AFC20054   SW V0, 84(S8)
294:                 
295:                 }
296:                 /*********************************************************************
297:                   Function:       
298:                 	unsigned int SYSTEMConfig(unsigned int sys_clock, unsigned int flags)
299:                  
300:                   Description:
301:                 	The function sets the PB divider, the Flash Wait states or the DRM wait states to the optimum value, 
302:                 	based on the flags selected and on the frequency of the system clock.
303:                     It also enables the cacheability for the K0 segment.
304:                 				   
305:                   PreCondition:    
306:                 	None
307:                  
308:                   Parameters:           
309:                 	sys_clock - system clock frequency in Hz
310:                     flags -
311:                 		*    SYS_CFG_WAIT_STATES  - configure the flash wait states from the system clock
312:                         *    SYS_CFG_PB_BUS       - configure the PB bus from the system clock
313:                         *    SYS_CFG_PCACHE      - configure the pCache (if used)
314:                         *    SYS_CFG_ALL          - configure all based on system clock
315:                  
316:                   Returns:          
317:                 	the PB clock frequency in Hz
318:                  
319:                   Side Effects:    
320:                 	Could change the wait state, pb clock and turn on the pre-fetch buffer and cache. Sets the RAM
321:                     wait state to 0.
322:                   
323:                  
324:                   Remarks:
325:                 	The interrupts are disabled shortly, the DMA is suspended and the system is unlocked while performing the operation.
326:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
327:                  
328:                   Example:
329:                 	<code>
330:                 	SYSTEMConfig(72000000, SYS_CFG_ALL);
331:                 	</code>
332:                  ********************************************************************/
333:                 extern inline unsigned int __attribute__((always_inline)) SYSTEMConfig(unsigned int sys_clock, unsigned int flags)
334:                 {
335:                     unsigned int pb_clk;
336:                     unsigned int int_status;
337:                 #ifdef _PCACHE
338:                     unsigned int cache_status;
339:                 #endif
340:                 
341:                     int_status=INTDisableInterrupts();
342:                 
343:                     mBMXDisableDRMWaitState();
344:                 
345:                     if(flags & SYS_CFG_WAIT_STATES)
346:                     {
347:                         SYSTEMConfigWaitStates(sys_clock);
348:                     }
349:                 
350:                     if(flags & SYS_CFG_PB_BUS)
351:                     {
352:                         SYSTEMConfigPB(sys_clock);
353:                     }
354:                 
355:                 
356:                 #ifdef _PCACHE
357:                     if(flags & SYS_CFG_PCACHE)
358:                     {
359:                         cache_status = mCheGetCon();
360:                         cache_status |= CHE_CONF_PF_ALL;
361:                         mCheConfigure(cache_status);
362:                         CheKseg0CacheOn();
363:                     }
364:                 #endif
365:                 
366:                     pb_clk = sys_clock;
367:                     pb_clk >>= OSCCONbits.PBDIV;
368:                 
369:                     INTRestoreInterrupts(int_status);
370:                 
371:                     return pb_clk;
372:                 
373:                 }
374:                 #ifdef __cplusplus
375:                   }
376:                 #endif
377:                 #endif
378:                 
---  c:/program files (x86)/microchip/xc32/v1.21/pic32mx/include/peripheral/osc.h  ----------------------
1:                   /*********************************************************************
2:                    *
3:                    *                  OSC API definitions
4:                    *
5:                    *********************************************************************
6:                    * FileName:        OSC.h
7:                    * Dependencies:
8:                    * Processor:       PIC32
9:                    *
10:                   *
11:                   * Compiler:        MPLAB XC32
12:                   *                  MPLAB IDE
13:                   * Company:         Microchip Technology Inc.
14:                   *
15:                   * Software License Agreement
16:                   *
17:                   * The software supplied herewith by Microchip Technology Incorporated
18:                   * (the ?Company?) for its PIC Microcontroller is intended
19:                   * and supplied to you, the Company?s customer, for use solely and
20:                   * exclusively on Microchip PIC Microcontroller products.
21:                   * The software is owned by the Company and/or its supplier, and is
22:                   * protected under applicable copyright laws. All rights are reserved.
23:                   * Any use in violation of the foregoing restrictions may subject the
24:                   * user to criminal sanctions under applicable laws, as well as to
25:                   * civil liability for the breach of the terms and conditions of this
26:                   * license.
27:                   *
28:                   * THIS SOFTWARE IS PROVIDED IN AN ?AS IS? CONDITION. NO WARRANTIES,
29:                   * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
30:                   * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
31:                   * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
32:                   * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
33:                   * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
34:                   *
35:                   *
36:                   * $Id: OSC.h,v 1.6 2006/10/13 21:24:31 C12532 Exp $
37:                   * $Name:  $
38:                   ********************************************************************/
39:                  
40:                  #ifndef OSC_H_
41:                  #define OSC_H_
42:                  
43:                  #include <xc.h>
44:                  #include <peripheral/lock.h>
45:                  
46:                  #define _OSC_
47:                  
48:                  /*********************************************************************
49:                   * Function:        OSCConfig(unsigned long int source, unsigned long int mult, unsigned long int post, unsigned long int div)
50:                   *
51:                   * Description:	    Sets Osc options and clock source
52:                   *
53:                   * PreCondition:    Interrupts must be disabled and DMA suspended or disabled
54:                   *
55:                   * Inputs:	    	Clock source, PLL multiplier, PLL postscaler, FRC divisor - see below
56:                   *
57:                   * Output:          None
58:                   *
59:                   * Example:	    	OSCConfig( OSC_POSC, OSC_PLL_MULT_24, OSC_PLL_POST_256, OSC_FRC_POST_64 )
60:                   *
61:                   * Note:	    	Forces cpu clock source to FRC(no divisor, no PLL), configures new clock
62:                   * 		     		source and then switches to the new clock source
63:                   *
64:                   *		    		Unused parameters are set to zero/default values.
65:                   ********************************************************************/
66:                  void OSCConfig(unsigned long int source, unsigned long int mult, unsigned long int post, unsigned long int div);
67:                  
68:                  	/******************************************************************************
69:                  	 * Available options for source parameter
70:                  	 *****************************************************************************/
71:                  		// CPU Oscillator modes - values are mutually exclusive
72:                  		#define OSC_FRC_DIV 	(7 << _OSCCON_NOSC_POSITION)
73:                  		#define OSC_FRC_DIV16 	(6 << _OSCCON_NOSC_POSITION)
74:                  		#define OSC_LPRC        (5 << _OSCCON_NOSC_POSITION)
75:                  		#define OSC_SOSC        (4 << _OSCCON_NOSC_POSITION)
76:                  		#define OSC_POSC_PLL 	(3 << _OSCCON_NOSC_POSITION)
77:                  		#define OSC_POSC        (2 << _OSCCON_NOSC_POSITION)
78:                  		#define OSC_FRC_PLL 	(1 << _OSCCON_NOSC_POSITION)
79:                  		#define OSC_FRC         (0 << _OSCCON_NOSC_POSITION)
80:                  
81:                  	/******************************************************************************
82:                  	 * Available options for mult parameter
83:                  	 *****************************************************************************/
84:                  		// CPU PLL multiplier values - values are mutually exclusive
85:                  		#define OSC_PLL_MULT_24 (7 << _OSCCON_PLLMULT_POSITION)
86:                  		#define OSC_PLL_MULT_21 (6 << _OSCCON_PLLMULT_POSITION)
87:                  		#define OSC_PLL_MULT_20 (5 << _OSCCON_PLLMULT_POSITION)
88:                  		#define OSC_PLL_MULT_19 (4 << _OSCCON_PLLMULT_POSITION)
89:                  		#define OSC_PLL_MULT_18 (3 << _OSCCON_PLLMULT_POSITION)
90:                  		#define OSC_PLL_MULT_17 (2 << _OSCCON_PLLMULT_POSITION)
91:                  		#define OSC_PLL_MULT_16 (1 << _OSCCON_PLLMULT_POSITION)
92:                  		#define OSC_PLL_MULT_15 (0 << _OSCCON_PLLMULT_POSITION)
93:                  
94:                  	/******************************************************************************
95:                  	 * Available options for post parameter
96:                  	 *****************************************************************************/
97:                  		// CPU PLL output divisor values - values are mutuallye exclusive
98:                  		#define OSC_PLL_POST_256 (7 << _OSCCON_PLLODIV_POSITION)
99:                  		#define OSC_PLL_POST_64  (6 << _OSCCON_PLLODIV_POSITION)
100:                 		#define OSC_PLL_POST_32  (5 << _OSCCON_PLLODIV_POSITION)
101:                 		#define OSC_PLL_POST_16  (4 << _OSCCON_PLLODIV_POSITION)
102:                 		#define OSC_PLL_POST_8   (3 << _OSCCON_PLLODIV_POSITION)
103:                 		#define OSC_PLL_POST_4   (2 << _OSCCON_PLLODIV_POSITION)
104:                 		#define OSC_PLL_POST_2   (1 << _OSCCON_PLLODIV_POSITION)
105:                 		#define OSC_PLL_POST_1   (0 << _OSCCON_PLLODIV_POSITION)
106:                 
107:                 	/******************************************************************************
108:                 	 * Available options for div parameter
109:                 	 *****************************************************************************/
110:                 		// CPU FRC output divisor values - values are mutually exclusive
111:                 		#define OSC_FRC_POST_256 (7 << _OSCCON_FRCDIV_POSITION)
112:                 		#define OSC_FRC_POST_64  (6 << _OSCCON_FRCDIV_POSITION)
113:                 		#define OSC_FRC_POST_32  (5 << _OSCCON_FRCDIV_POSITION)
114:                 		#define OSC_FRC_POST_16  (4 << _OSCCON_FRCDIV_POSITION)
115:                 		#define OSC_FRC_POST_8   (3 << _OSCCON_FRCDIV_POSITION)
116:                 		#define OSC_FRC_POST_4   (2 << _OSCCON_FRCDIV_POSITION)
117:                 		#define OSC_FRC_POST_2   (1 << _OSCCON_FRCDIV_POSITION)
118:                 		#define OSC_FRC_POST_1   (0 << _OSCCON_FRCDIV_POSITION)
119:                 	/***********************************
120:                 	 * End parameter values
121:                 	 ************************************/
122:                 
123:                 #if (((__PIC32_FEATURE_SET__ >= 100) && (__PIC32_FEATURE_SET__ <= 299)) || \
124:                     (__PIC32_FEATURE_SET__ == 330) || (__PIC32_FEATURE_SET__ == 350) || (__PIC32_FEATURE_SET__ == 370) || (__PIC32_FEATURE_SET__ == 430) || (__PIC32_FEATURE_SET__ == 450) || (__PIC32_FEATURE_SET__ == 470))
125:                 	
126:                 		// Reference Oscillator Source Select bits - values are mutually exclusive
127:                 	#define OSC_REFOCON_REFCLKI	 	(7 << _REFOCON_ROSEL_POSITION )
128:                 	#define OSC_REFOCON_SYSPLL 		(7 << _REFOCON_ROSEL_POSITION )
129:                 	#define OSC_REFOCON_USBPLL 		(6 << _REFOCON_ROSEL_POSITION )
130:                 	#define OSC_REFOCON_SOSC        (5 << _REFOCON_ROSEL_POSITION )
131:                 	#define OSC_REFOCON_LPRC        (4 << _REFOCON_ROSEL_POSITION )
132:                 	#define OSC_REFOCON_FRC 		(3 << _REFOCON_ROSEL_POSITION )
133:                 	#define OSC_REFOCON_POSC        (2 << _REFOCON_ROSEL_POSITION )
134:                 	#define OSC_REFOCON_PBCLK 		(1 << _REFOCON_ROSEL_POSITION )
135:                 	#define OSC_REFOCON_SYSCLK      (0 << _REFOCON_ROSEL_POSITION )
136:                 		
137:                 	typedef enum
138:                 	{		
139:                 		OSC_REFOCON_RLSPEN		=(1 << _REFOCON_RSLP_POSITION )	,
140:                 		OSC_REFOCON_OE			=(1 << _REFOCON_OE_POSITION ),
141:                 		OSC_REFOCON_SIDLEN		=(1 << _REFOCON_SIDL_POSITION ),
142:                 		OSC_REFOCON_ON			=(1 << _REFOCON_ON_POSITION )
143:                 	} OSCREFConfigFlags;
144:                 	
145:                 	void OSCREFConfig(unsigned long int source, OSCREFConfigFlags config, unsigned long int div);
146:                 	 
147:                 
148:                 	#define mOSCREFOTRIMSet(trim) 		(REFOTRIM = (trim << _REFOTRIM_ROTRIM_POSITION))
149:                 
150:                 #endif
151:                 
152:                 	 
153:                 	 
154:                 	 
155:                 /*********************************************************************
156:                  * Function:    OSCSetPBDIV(unsigned int oscPbDiv)
157:                  *
158:                  * Description:	Configures peripheral bus divisor
159:                  *
160:                  * PreCondition: oscPbDiv one of the OSC_PB_DIV_X valid values
161:                  *
162:                  * Inputs:    oscPbDiv - desired PB divider
163:                  *
164:                  * Output:      None
165:                  *
166:                  * Example:   OSCSetPBDIV(  OSC_PB_DIV_8 )
167:                  *
168:                  ********************************************************************/
169:                 extern inline void __attribute__((always_inline)) OSCSetPBDIV(unsigned int oscPbDiv)
170:                 {
171:                 	unsigned int dma_status;
172:                 	unsigned int int_status;
173:                 	__OSCCONbits_t oscBits;
174:                 
175:                 	mSYSTEMUnlock(int_status, dma_status);
9D0309F0  0F40D89C   JAL INTDisableInterrupts
9D0309F4  00000000   NOP
9D0309F8  AFC20028   SW V0, 40(S8)
9D030A40  AFC20030   SW V0, 48(S8)
9D030A44  3C02BF81   LUI V0, -16511
9D030A48  AC40F230   SW ZERO, -3536(V0)
9D030A4C  3C02BF81   LUI V0, -16511
9D030A50  3C03AA99   LUI V1, -21863
9D030A54  34636655   ORI V1, V1, 26197
9D030A58  AC43F230   SW V1, -3536(V0)
9D030A5C  3C02BF81   LUI V0, -16511
9D030A60  3C035566   LUI V1, 21862
9D030A64  346399AA   ORI V1, V1, -26198
9D030A68  AC43F230   SW V1, -3536(V0)
9D030C00  0F40D89C   JAL INTDisableInterrupts
9D030C04  00000000   NOP
9D030C08  AFC20058   SW V0, 88(S8)
9D030C50  AFC20060   SW V0, 96(S8)
9D030C54  3C02BF81   LUI V0, -16511
9D030C58  AC40F230   SW ZERO, -3536(V0)
9D030C5C  3C02BF81   LUI V0, -16511
9D030C60  3C03AA99   LUI V1, -21863
9D030C64  34636655   ORI V1, V1, 26197
9D030C68  AC43F230   SW V1, -3536(V0)
9D030C6C  3C02BF81   LUI V0, -16511
9D030C70  3C035566   LUI V1, 21862
9D030C74  346399AA   ORI V1, V1, -26198
9D030C78  AC43F230   SW V1, -3536(V0)
176:                 	
177:                 	oscBits.w=OSCCON;		// read to be in sync. flush any pending write
9D030A6C  3C02BF81   LUI V0, -16511
9D030A70  8C42F000   LW V0, -4096(V0)
9D030A74  AFC20070   SW V0, 112(S8)
9D030C7C  3C02BF81   LUI V0, -16511
9D030C80  8C42F000   LW V0, -4096(V0)
9D030C84  AFC2006C   SW V0, 108(S8)
178:                 	oscBits.PBDIV=0;
9D030A78  8FC20070   LW V0, 112(S8)
9D030A7C  7C02A4C4   INS V0, ZERO, 19, 2
9D030A80  AFC20070   SW V0, 112(S8)
9D030C88  8FC2006C   LW V0, 108(S8)
9D030C8C  7C02A4C4   INS V0, ZERO, 19, 2
9D030C90  AFC2006C   SW V0, 108(S8)
179:                 	oscBits.w|=oscPbDiv;	
9D030A84  8FC30070   LW V1, 112(S8)
9D030A88  8FC20024   LW V0, 36(S8)
9D030A8C  00621025   OR V0, V1, V0
9D030A90  AFC20070   SW V0, 112(S8)
9D030C94  8FC3006C   LW V1, 108(S8)
9D030C98  8FC20054   LW V0, 84(S8)
9D030C9C  00621025   OR V0, V1, V0
9D030CA0  AFC2006C   SW V0, 108(S8)
180:                 	OSCCON=oscBits.w;		// write back
9D030A94  8FC30070   LW V1, 112(S8)
9D030A98  3C02BF81   LUI V0, -16511
9D030A9C  AC43F000   SW V1, -4096(V0)
9D030CA4  8FC3006C   LW V1, 108(S8)
9D030CA8  3C02BF81   LUI V0, -16511
9D030CAC  AC43F000   SW V1, -4096(V0)
181:                 	oscBits.w=OSCCON;		// make sure the write occurred before returning from this function
9D030AA0  3C02BF81   LUI V0, -16511
9D030AA4  8C42F000   LW V0, -4096(V0)
9D030AA8  AFC20070   SW V0, 112(S8)
9D030CB0  3C02BF81   LUI V0, -16511
9D030CB4  8C42F000   LW V0, -4096(V0)
9D030CB8  AFC2006C   SW V0, 108(S8)
182:                 	
183:                 	mSYSTEMLock(int_status, dma_status);
9D030AAC  3C02BF81   LUI V0, -16511
9D030AB0  3C033333   LUI V1, 13107
9D030AB4  34633333   ORI V1, V1, 13107
9D030AB8  AC43F230   SW V1, -3536(V0)
9D030ABC  8FC20030   LW V0, 48(S8)
9D030AC0  AFC20034   SW V0, 52(S8)
9D030B24  8FC40028   LW A0, 40(S8)
9D030B28  0F40D874   JAL INTRestoreInterrupts
9D030B2C  00000000   NOP
9D030CBC  3C02BF81   LUI V0, -16511
9D030CC0  3C033333   LUI V1, 13107
9D030CC4  34633333   ORI V1, V1, 13107
9D030CC8  AC43F230   SW V1, -3536(V0)
9D030CCC  8FC20060   LW V0, 96(S8)
9D030CD0  AFC20064   SW V0, 100(S8)
9D030D34  8FC40058   LW A0, 88(S8)
9D030D38  0F40D874   JAL INTRestoreInterrupts
9D030D3C  00000000   NOP
184:                 }
185:                 
186:                 #define		mOSCSetPBDIV		OSCSetPBDIV		// backward compatibility
187:                 
188:                 
189:                 
190:                 	/******************************************************************************
191:                 	 * Available options for config parameter
192:                 	 *****************************************************************************/
193:                 		// CPU Peripheral Bus divisor values - values are mutually exclusive
194:                 		#define OSC_PB_DIV_8    (3 << _OSCCON_PBDIV_POSITION)
195:                 		#define OSC_PB_DIV_4    (2 << _OSCCON_PBDIV_POSITION)
196:                 		#define OSC_PB_DIV_2    (1 << _OSCCON_PBDIV_POSITION)
197:                 		#define OSC_PB_DIV_1    (0 << _OSCCON_PBDIV_POSITION)
198:                 	/***********************************
199:                 	 * End config parameter values
200:                 	 ************************************/
201:                 
202:                 
203:                 /*********************************************************************
204:                  * Function:    mOSCGetPBDIV()
205:                  *
206:                  * Description:	Reads peripheral bus divisor
207:                  *
208:                  * PreCondition:None
209:                  *
210:                  * Inputs:	  	None
211:                  *
212:                  * Output:      None
213:                  *
214:                  * Example:	  	mOSCGetPBDIV()
215:                  *
216:                  ********************************************************************/
217:                 #define mOSCGetPBDIV() (OSCCONbits.PBDIV)
218:                 
219:                 
220:                 /*********************************************************************
221:                  * Function:    mOSCClockFailStatus()
222:                  *
223:                  * Description:	Returns Clock Fail status. 1 = clock fail, 0 = no clock fail
224:                  *
225:                  * PreCondition: None
226:                  *
227:                  * Inputs:	  	None
228:                  *
229:                  * Output:      None
230:                  *
231:                  * Example:	  	mOSCClockFailStatus()
232:                  *
233:                  ********************************************************************/
234:                 #define mOSCClockFailStatus (OSCCONbits.CF)
235:                 
236:                 
237:                 /*********************************************************************
238:                  * Function:      	mOSCEnableSOSC()
239:                  *
240:                  * Description:	  	Enables the LPRC
241:                  *
242:                  * PreCondition:    Interrupts must be disabled and DMA suspended or disabled
243:                  *
244:                  * Inputs:	  		None
245:                  *
246:                  * Output:        	None
247:                  *
248:                  * Example:	  		mOSCEnableSOSC()
249:                  *
250:                  ********************************************************************/
251:                 #define mOSCEnableSOSC() mSysUnlockOpLock(OSCCONSET = _OSCCON_SOSCEN_MASK)
252:                 
253:                 
254:                 /*********************************************************************
255:                  * Function:      	mOSCDisableSOSC(config)
256:                  *
257:                  * Description:	  	Disables SOSC
258:                  *
259:                  * PreCondition:    Interrupts must be disabled and DMA suspended or disabled
260:                  *
261:                  * Inputs:	  		None
262:                  *
263:                  * Output:        	None
264:                  *
265:                  * Example:	  		mOSCDisableSOSC()
266:                  *
267:                  ********************************************************************/
268:                 #define mOSCDisableSOSC() mSysUnlockOpLock(OSCCONCLR = _OSCCON_SOSCEN_MASK)
269:                 
270:                 
271:                 
272:                 #endif
---  c:/program files (x86)/microchip/xc32/v1.21/pic32mx/include/peripheral/dma_3xx_4xx.h  --------------
1:                   /*********************************************************************
2:                    *
3:                    *                  DMA API definitions
4:                    *
5:                    *********************************************************************
6:                    * FileName:        Dma.h
7:                    * Dependencies:	xc.h
8:                    * 					int.h
9:                    *
10:                   * Processor:       PIC32
11:                   *
12:                   * Compiler:        MPLAB XC32
13:                   *                  MPLAB IDE
14:                   * Company:         Microchip Technology Inc.
15:                   *
16:                   * Software License Agreement
17:                   *
18:                   * The software supplied herewith by Microchip Technology Incorporated
19:                   * (the ?Company?) for its PIC32/PIC24F Microcontroller is intended
20:                   * and supplied to you, the Company?s customer, for use solely and
21:                   * exclusively on Microchip PIC32/PIC24F Microcontroller products.
22:                   * The software is owned by the Company and/or its supplier, and is
23:                   * protected under applicable copyright laws. All rights are reserved.
24:                   * Any use in violation of the foregoing restrictions may subject the
25:                   * user to criminal sanctions under applicable laws, as well as to
26:                   * civil liability for the breach of the terms and conditions of this
27:                   * license.
28:                   *
29:                   * THIS SOFTWARE IS PROVIDED IN AN ?AS IS? CONDITION. NO WARRANTIES,
30:                   * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
31:                   * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
32:                   * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
33:                   * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
34:                   * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
35:                   *
36:                   *
37:                   * $Id: Dma.h,v 1.9 2007/01/17 21:35:46 C12878 Exp $
38:                   * $Name:  $
39:                   *
40:                   ********************************************************************/
41:                  
42:                  #ifndef _DMA_H_
43:                  #define _DMA_H_
44:                  
45:                  #include <xc.h>
46:                  
47:                  
48:                  // DMA definitions
49:                  
50:                  #ifdef _DMAC0
51:                  	#define _DMA_CHANNELS		// DMA channels exist
52:                  
53:                  
54:                  // existent DMA channels
55:                  	typedef enum
56:                  	{
57:                  		DMA_CHANNEL0,
58:                  	#ifdef _DMAC1
59:                  		DMA_CHANNEL1,
60:                  	#ifdef _DMAC2
61:                  		DMA_CHANNEL2,
62:                  	#ifdef _DMAC3
63:                  		DMA_CHANNEL3,
64:                  	#ifdef _DMAC4
65:                  		DMA_CHANNEL4,
66:                  	#ifdef _DMAC5
67:                  		DMA_CHANNEL5,
68:                  	#ifdef _DMAC6
69:                  		DMA_CHANNEL6,
70:                  	#ifdef _DMAC7
71:                  		DMA_CHANNEL7,
72:                  	#endif	// _DMAC7
73:                  	#endif	// _DMAC6
74:                  	#endif	// _DMAC5
75:                  	#endif	// _DMAC4
76:                  	#endif	// _DMAC3
77:                  	#endif	// _DMAC2
78:                  	#endif	// _DMAC1
79:                  		//	add/remove DMA channel as needed here
80:                  
81:                  		DMA_CHANNELS	// number of current available channels
82:                  	}DmaChannel;
83:                  
84:                  
85:                  	// Relative Dma channels priority, between each other
86:                  	typedef enum
87:                  	{
88:                  		DMA_CHN_PRI0,
89:                  		DMA_CHN_PRI1,
90:                  		DMA_CHN_PRI2,
91:                  		DMA_CHN_PRI3
92:                  	}DmaChannelPri;
93:                  
94:                  
95:                  
96:                  	// high level definitions for the API functions
97:                  
98:                  	typedef enum
99:                  	{
100:                 		DMA_OPEN_DEFAULT = 0,                                   // DMA default operation
101:                 		DMA_OPEN_AUTO	= _DCH0CON_CHAEN_MASK,					// DMA channel is auto enabled
102:                 		DMA_OPEN_CHAIN_LOW  = (_DCH0CON_CHCHN_MASK|_DCH0CON_CHCHNS_MASK),	// DMA channel is chained to lower channel
103:                 		DMA_OPEN_CHAIN_HI  = (_DCH0CON_CHCHN_MASK),				// DMA channel is chained to higher channel
104:                 		DMA_OPEN_DET_EN = _DCH0CON_CHAED_MASK,					// events detection enabled while channel off
105:                 		DMA_OPEN_ENABLE = _DCH0CON_CHEN_MASK,					// DMA channel is enabled after open
106:                 		DMA_OPEN_MATCH	= 0x80000000,                           // DMA channel stops on match
107:                 	}DmaOpenFlags;	// flags for the channel open
108:                 
109:                 
110:                 	typedef enum
111:                 	{
112:                 		DMA_EV_ERR =			0x1,		// address error event
113:                 		DMA_EV_ABORT = 			0x2,		// transfer abort event
114:                 		DMA_EV_CELL_DONE =		0x4,		// cell transfer complete event
115:                 		DMA_EV_BLOCK_DONE =		0x8,		// block transfer complete event
116:                 		DMA_EV_DST_HALF =		0x10,		// destination half event
117:                 		DMA_EV_DST_FULL =		0x20,		// destination full event
118:                 		DMA_EV_SRC_HALF =		0x40,		// source half event
119:                 		DMA_EV_SRC_FULL =		0x80,		// source full event
120:                 
121:                 		DMA_EV_ALL_EVNTS=		(DMA_EV_ERR|DMA_EV_ABORT|DMA_EV_CELL_DONE|DMA_EV_BLOCK_DONE|DMA_EV_DST_HALF|
122:                 									DMA_EV_DST_FULL|DMA_EV_SRC_HALF|DMA_EV_SRC_FULL)				// all available events
123:                 	}DmaEvFlags;	// flags for controlling the DMA channel events; Bit fields from the processor header file.
124:                 
125:                 
126:                 	typedef enum
127:                 	{
128:                 		DMA_TXFER_OK,			// the transfer was performed successfully
129:                 		DMA_TXFER_ADD_ERR,		// address error while performing the transfer
130:                 		DMA_TXFER_ABORT,		// the DMA transfer was aborted
131:                 		DMA_TXFER_BC_ERR,		// block complete not set after the DMA transfer performed
132:                 		DMA_TXFER_CC_ERR,		// cell complete not set after the DMA transfer performed
133:                 		DMA_TXFER_TMO			// DMA transfer timeout
134:                 	}DmaTxferRes;		// DMA transfer result
135:                 
136:                 	typedef enum
137:                 	{
138:                 		DMA_WAIT_NOT,		// don't wait for the transfer to complete, return immediately
139:                 		DMA_WAIT_CELL,		// wait for the cell transfer to complete, than return
140:                 		DMA_WAIT_BLOCK		// wait for the block transfer to complete, than return
141:                 	}DmaWaitMode;		// DMA transfer wait mode
142:                 
143:                 
144:                 	/*********************************************************************
145:                 	 * Function:        void DmaChnOpen(DmaChannel chn, DmaChannelPri chPri, DmaOpenFlags oFlags)
146:                 	 *
147:                 	 * PreCondition:    chPri  - valid channel priority, 0-3
148:                 	 *
149:                 	 * Input:           chn    - channel to be configured in the DMA controller
150:                 	 *                  chPri  - the priority given to the channel, 0-3
151:                 	 *                  oFlags - orred flags specifying the open mode:
152:                 	 *                           DMA_OPEN_DEFAULT: DMA default operation mode
153:                 	 *                           DMA_OPEN_AUTO:	DMA channel is auto enabled
154:                 	 *                           DMA_OPEN_CHAIN_LOW: DMA channel is chained to lower channel
155:                 	 *                           DMA_OPEN_CHAIN_HI: DMA channel is chained to higher channel
156:                 	 *                           DMA_OPEN_DET_EN: events detection enabled while channel off
157:                 	 *                           DMA_OPEN_ENABLE: DMA channel is enabled when opened
158:                 	 *                           DMA_OPEN_MATCH:	DMA channel stops on match
159:                 	 *
160:                 	 *
161:                 	 *
162:                 	 * Output:          None
163:                 	 *
164:                 	 * Side Effects:    None
165:                 	 *
166:                 	 * Overview:        The function opens and configures the selected DMA channel using the supplied user flags and priority.
167:                 	 *
168:                 	 * Note:            - This is a high level access function that doesn't give access to all the settings possible for a DMA channel.
169:                 	 *                  Use the low level functions to address special settings.
170:                 	 *                  - The channel is turned off, the pending interrupts are cleared, interrupts are disabled.
171:                 	 *                  After that the channel is configured.
172:                 	 *                  - After calling this function, the channel should be enabled using DmaChnEnable(chn) call
173:                 	 *                  if DMA_OPEN_ENABLE flag was not specified.
174:                 	 *                  - If the CRC is attached to the submitted channel, the CRC append mode will be turned off.
175:                 	 *                  This way, the transfer will occur correctly together with CRC calculation.
176:                 	 *                  - The start and abort Irqs will be disabled and the channel event enable flags are disabled.
177:                 	 *                  User has to call event channel functions to enable the event flags if needed.
178:                 	 *
179:                 	 * Example:         DmaChnOpen(DMA_CHANNEL2, DMA_CHN_PRI2, DMA_OPEN_AUTO|DMA_OPEN_MATCH|DMA_OPEN_ENABLE);
180:                 	 ********************************************************************/
181:                 	 void			DmaChnOpen(DmaChannel chn, DmaChannelPri chPri, DmaOpenFlags oFlags);
182:                 
183:                 	/*********************************************************************
184:                 	 * Function:        void DmaChnEnable(DmaChannel chn)
185:                 	 *
186:                 	 * PreCondition:    None
187:                 	 *
188:                 	 * Input:			chn		- channel to be enabled
189:                 	 *
190:                 	 * Output:          None
191:                 	 *
192:                 	 * Side Effects:    None
193:                 	 *
194:                 	 * Overview:		The function enables a previously configured DMA channel.
195:                 	 *
196:                 	 * Note:            DmaChnOpen()/DmaChnConfigure() should have been called before.
197:                 	 *
198:                 	 * Example:			DmaChnEnable(DMA_CHANNEL2);
199:                 	 ********************************************************************/
200:                 	 void			DmaChnEnable(DmaChannel chn);
201:                 
202:                 	/*********************************************************************
203:                 	 * Function:        void DmaChnDisable(DmaChannel chn)
204:                 	 *
205:                 	 * PreCondition:    None
206:                 	 *
207:                 	 * Input:			chn		- selected channel in the DMA controller
208:                 	 *
209:                 	 * Output:          None
210:                 	 *
211:                 	 * Side Effects:    None
212:                 	 *
213:                 	 * Overview:		The function disables a DMA channel. The channel operation stops.
214:                 	 *
215:                 	 * Note:            None.
216:                 	 *
217:                 	 * Example:			DmaChnDisable(DMA_CHANNEL2);
218:                 	 ********************************************************************/
219:                 	 void			DmaChnDisable(DmaChannel chn);
220:                 
221:                 	/*********************************************************************
222:                 	 * Function:        void DmaChnSetTxfer(DmaChannel chn, const void* vSrcAdd, void* vDstAdd, int srcSize, int dstSize, int cellSize)
223:                 	 *
224:                 	 * PreCondition:    chn		- valid DMA channel
225:                 	 * 				- vSrcAdd, vDstAdd	- valid pointers
226:                 	 *                              - 0 < srcSize <= DmaGetMaxTxferSize()
227:                 	 *                              - 0 < dstSize <= DmaGetMaxTxferSize()
228:                 	 *                              - 0 < cellSize <= DmaGetMaxTxferSize()
229:                 	 *
230:                 	 * Input:			chn			- DMA channel number
231:                 	 * 								- vSrcAdd: source of the DMA transfer
232:                 	 * 								- vDstAdd: destination of the DMA transfer
233:                 	 * 								- srcSize: source buffer size, 1 to DmaGetMaxTxferSize() bytes, wrapped arround
234:                 	 * 								- dstSize: destination buffer size, 1 to DmaGetMaxTxferSize() bytes, wrapped around
235:                 	 * 								- cellSize: cell transfer size, 1 to DmaGetMaxTxferSize() bytes.
236:                 	 *
237:                 	 * Output:          None
238:                 	 *
239:                 	 * Side Effects:    None
240:                 	 *
241:                 	 * Overview:		The function sets the transfer characteristics for a DMA channel transfer:
242:                 	 * 					the source and the destination addresses.
243:                 	 * 					the source and destination lengths
244:                 	 * 					and the number of bytes	transferred per event.
245:                 	 *
246:                 	 * Note:			The function clears the existing DMA channel event flags.
247:                 	 *
248:                 	 * Example:			DmaChnSetTxfer(DMA_CHANNEL2, &U2RXREG, dstBuff, 1, 200, 1);
249:                 	 ********************************************************************/
250:                 	 void			DmaChnSetTxfer(DmaChannel chn, const void* vSrcAdd, void* vDstAdd, int srcSize, int dstSize, int cellSize);
251:                 
252:                 
253:                 	/*********************************************************************
254:                 	 * Function:        void DmaChnSetSrcAdd(DmaChannel chn, const void* vSrcAdd)
255:                 	 *
256:                 	 * PreCondition:    chn		- valid DMA channel
257:                 	 *
258:                 	 * Input:           chn		- DMA channel number
259:                 	 * 				- vSrcAdd: source (virtual) of the DMA transfer
260:                 	 * Output:          None
261:                 	 *
262:                 	 * Side Effects:    None
263:                 	 *
264:                 	 * Overview:        The function is a helper to set directly the transfer source address.
265:                 	 *
266:                 	 * Note:            None.
267:                 	 *
268:                 	 * Example:         DmaChnSetSrcAdd(DMA_CHANNEL2, srcBuff+sizeof(srcBuff));
269:                 	 ********************************************************************/
270:                 	 void			DmaChnSetSrcAdd(DmaChannel chn, const void* vSrcAdd);
271:                 
272:                 	/*********************************************************************
273:                 	 * Function:        void DmaChnSetDstAdd(DmaChannel chn, void* vDstAdd)
274:                 	 *
275:                 	 * PreCondition:    chn		- valid DMA channel
276:                 	 *
277:                 	 * Input:			chn			- DMA channel number
278:                 	 * 								- vDstAdd: destination (virtual) of the DMA transfer
279:                 	 * Output:          None
280:                 	 *
281:                 	 * Side Effects:    None
282:                 	 *
283:                 	 * Overview:		The function is a helper to set directly the transfer destination address.
284:                 	 *
285:                 	 * Note:            None
286:                 	 *
287:                 	 * Example:         DmaChnSetDstAdd(DMA_CHANNEL2, dstBuff+sizeof(dstBuff));
288:                 	 ********************************************************************/
289:                 	 void			DmaChnSetDstAdd(DmaChannel chn, void* vDstAdd);
290:                 
291:                 	/*********************************************************************
292:                 	 * Function:        void DmaChnSetMatchPattern(DmaChannel chn, int pattern)
293:                 	 *
294:                 	 * PreCondition:    chn	- valid DMA channel
295:                 	 *
296:                 	 * Input:			chn		- DMA channel number
297:                 	 * 					pattern	-  the match pattern
298:                 	 *
299:                 	 * Output:          None
300:                 	 *
301:                 	 * Side Effects:    None
302:                 	 *
303:                 	 * Overview:		The function sets the curent match pattern for the selected DMA channel.
304:                 	 *
305:                 	 * Note:            None.
306:                 	 *
307:                 	 * Example:			DmaChnSetMatchPattern(DMA_CHANNEL2, '\r');
308:                 	 ********************************************************************/
309:                 	 void			DmaChnSetMatchPattern(DmaChannel chn, int pattern);
310:                 
311:                 	/*********************************************************************
312:                 	 * Function:        int DmaChnGetMatchPattern(DmaChannel chn)
313:                 	 *
314:                 	 * PreCondition:    chn	- valid DMA channel
315:                 	 *
316:                 	 * Input:			chn		- DMA channel number
317:                 	 *
318:                 	 * Output:          The channel match pattern.
319:                 	 *
320:                 	 * Side Effects:    None
321:                 	 *
322:                 	 * Overview:		The function retrieves the curent match pattern for the selected DMA channel.
323:                 	 *
324:                 	 * Note:            None.
325:                 	 *
326:                 	 * Example:			int pattern=DmaChnGetMatchPattern(DMA_CHANNEL2);
327:                 	 ********************************************************************/
328:                 	 int			DmaChnGetMatchPattern(DmaChannel chn);
329:                 
330:                 	/*********************************************************************
331:                 	 * Function:        DmaTxferRes DmaChnStartTxfer(DmaChannel chn, DmaWaitMode wMode, unsigned long retries)
332:                 	 *
333:                 	 * PreCondition:    chn	- valid DMA channel
334:                 	 *
335:                 	 * Input:			chn		- DMA channel number
336:                 	 * 					wMode	- if DMA_WAIT_NOT, return immediately
337:                 	 * 							- if DMA_WAIT_CELL, return after the cell transfer complete
338:                 	 * 							- if DMA_WAIT_BLOCK, return after the whole transfer is done
339:                 	 * 					retries	- retry counter: if transfer not complete after so many retries, return with tmo.
340:                 	 * 								If 0, wait forever.
341:                 	 *
342:                 	 * Output:          DMA_TXFER_OK if not waiting for the transfer completion or if the transfer ended normally,
343:                 	 * 					an DmaTxferRes error code  otherwise
344:                 	 *
345:                 	 * Side Effects:    None
346:                 	 *
347:                 	 * Overview:		The function initiates (forces) a DMA transfer for the selected DMA channel.
348:                 	 * 					The DMA channel is enabled.
349:                 	 * 					If waiting for the transfer completion needed (user doesn't use an ISR to catch
350:                 	 * 					this event) the function will periodically query the DMA controller for the
351:                 	 * 					transfer completion status.
352:                      * 					If DMA_WAIT_BLOCK is specified and multiple cell transfers are needed to complete
353:                      * 					the block transfer than the function will re-force the transfer for each cell.
354:                 	 *
355:                 	 * Note:            This function can not ne used when the DMA channel is triggerred
356:                      *                  by hardware interrupt requests.
357:                      *                  This is because the transfers are software forced, theere is no
358:                      *                  wait for the occurrence of the hardware trigger. 
359:                 	 *
360:                 	 * Example:         DmaChnStartTxfer(DMA_CHANNEL2, DMA_WAIT_BLOCK, 0);
361:                 	 ********************************************************************/
362:                 	 DmaTxferRes DmaChnStartTxfer(DmaChannel chn, DmaWaitMode wMode, unsigned long retries);
363:                 
364:                 	/*********************************************************************
365:                 	 * Function:        void DmaChnForceTxfer(DmaChannel chn)
366:                 	 *
367:                 	 * PreCondition:    chn	- valid DMA channel
368:                 	 *
369:                 	 * Input:			chn		- DMA channel number
370:                 	 *
371:                 	 * Output:          None
372:                 	 *
373:                 	 * Side Effects:    None
374:                 	 *
375:                 	 * Overview:		The function forces a DMA transfer to occur for the selected DMA channel.
376:                 	 *
377:                 	 * Note:            None.
378:                 	 *
379:                 	 * Example:			DmaChnForceTxfer(DMA_CHANNEL2);
380:                 	 ********************************************************************/
381:                 	 void			DmaChnForceTxfer(DmaChannel chn);
382:                 
383:                 	/*********************************************************************
384:                 	 * Function:        void DmaChnAbortTxfer(DmaChannel chn)
385:                 	 *
386:                 	 * PreCondition:    chn	- valid DMA channel
387:                 	 *
388:                 	 * Input:			chn		- DMA channel number
389:                 	 *
390:                 	 * Output:          None
391:                 	 *
392:                 	 * Side Effects:    None
393:                 	 *
394:                 	 * Overview:		The function aborts a current undergoing DMA transfer for the selected DMA channel.
395:                 	 *
396:                 	 * Note:            None.
397:                 	 *
398:                 	 * Example:			DmaChnAbortTxfer(DMA_CHANNEL2);
399:                 	 ********************************************************************/
400:                 	 void			DmaChnAbortTxfer(DmaChannel chn);
401:                 
402:                 	// High level channel event and interrupt control functions
403:                 
404:                 	/*********************************************************************
405:                 	 * Function:        void DmaChnSetEvEnableFlags(DmaChannel chn, DmaEvFlags eFlags)
406:                 	 *
407:                 	 * PreCondition:    chn	- valid DMA channel
408:                 	 *
409:                 	 * Input:			chn		- DMA channel number
410:                 	 * 					eFlags	- event flags with the following significance:
411:                 	 * 								- DMA_EV_ERR: address error event
412:                 	 * 								- DMA_EV_ABORT: transfer abort event
413:                 	 * 								- DMA_EV_CELL_DONE: cell transfer complete event
414:                 	 * 								- DMA_EV_BLOCK_DONE: block transfer complete event
415:                 	 * 								- DMA_EV_DST_HALF: destination half event
416:                 	 * 								- DMA_EV_DST_FULL: destination full event
417:                 	 * 								- DMA_EV_SRC_HALF: source half event
418:                 	 * 								- DMA_EV_SRC_FULL: source full event
419:                 	 * 								- DMA_EV_ALL_EVNTS: all of the above flags
420:                 	 *
421:                 	 * Output:          None
422:                 	 *
423:                 	 * Side Effects:    None
424:                 	 *
425:                 	 * Overview:		The function sets the event enable flags for the selected DMA channel.
426:                 	 * 					Multiple flags can be orr-ed together. Any flag that is set in the eFlags will be
427:                 	 * 					enabled for the selected channel, the other channel event flags won't be touched.
428:                 	 *
429:                 	 * Note:            None.
430:                 	 *
431:                 	 * Example:			DmaChnSetEvEnableFlags(DMA_CHANNEL2, DMA_EV_ERR|DMA_EV_ABORT|DMA_EV_BLOCK_DONE|DMA_EV_SRC_FULL);
432:                 	 ********************************************************************/
433:                 	 void			DmaChnSetEvEnableFlags(DmaChannel chn, DmaEvFlags eFlags);
434:                 
435:                 	/*********************************************************************
436:                 	 * Function:        void DmaChnClrEvEnableFlags(DmaChannel chn, DmaEvFlags eFlags)
437:                 	 *
438:                 	 * PreCondition:    chn	- valid DMA channel
439:                 	 *
440:                 	 * Input:			chn		- DMA channel number
441:                 	 * 					eFlags	- event flags with the following significance:
442:                 	 * 								- DMA_EV_ERR: address error event
443:                 	 * 								- DMA_EV_ABORT: transfer abort event
444:                 	 * 								- DMA_EV_CELL_DONE: cell transfer complete event
445:                 	 * 								- DMA_EV_BLOCK_DONE: block transfer complete event
446:                 	 * 								- DMA_EV_DST_HALF: destination half event
447:                 	 * 								- DMA_EV_DST_FULL: destination full event
448:                 	 * 								- DMA_EV_SRC_HALF: source half event
449:                 	 * 								- DMA_EV_SRC_FULL: source full event
450:                 	 * 								- DMA_EV_ALL_EVNTS: all of the above flags
451:                 	 *
452:                 	 * Output:          None
453:                 	 *
454:                 	 * Side Effects:    None
455:                 	 *
456:                 	 * Overview:		The function clears the event enable flags for the selected DMA channel.
457:                 	 * 					Multiple flags can be orr-ed together. Any flag that is set in the eFlags will be
458:                 	 * 					disabled for the selected channel, the other channel event flags won't be touched.
459:                 	 *
460:                 	 * Note:            None.
461:                 	 *
462:                 	 * Example:			DmaChnClrEvEnableFlags(DMA_CHANNEL2, DMA_EV_ERR|DMA_EV_ABORT|DMA_EV_BLOCK_DONE|DMA_EV_SRC_FULL);
463:                 	 ********************************************************************/
464:                 	 void			DmaChnClrEvEnableFlags(DmaChannel chn, DmaEvFlags eFlags);
465:                 
466:                 	/*********************************************************************
467:                 	 * Function:        void DmaChnWriteEvEnableFlags(DmaChannel chn, DmaEvFlags eFlags)
468:                 	 *
469:                 	 * PreCondition:    chn	- valid DMA channel
470:                 	 *
471:                 	 * Input:			chn		- DMA channel number
472:                 	 * 					eFlags	- event flags with the following significance:
473:                 	 * 								- DMA_EV_ERR: address error event
474:                 	 * 								- DMA_EV_ABORT: transfer abort event
475:                 	 * 								- DMA_EV_CELL_DONE: cell transfer complete event
476:                 	 * 								- DMA_EV_BLOCK_DONE: block transfer complete event
477:                 	 * 								- DMA_EV_DST_HALF: destination half event
478:                 	 * 								- DMA_EV_DST_FULL: destination full event
479:                 	 * 								- DMA_EV_SRC_HALF: source half event
480:                 	 * 								- DMA_EV_SRC_FULL: source full event
481:                 	 * 								- DMA_EV_ALL_EVNTS: all of the above flags
482:                 	 *
483:                 	 * Output:          None
484:                 	 *
485:                 	 * Side Effects:    None
486:                 	 *
487:                 	 * Overview:		The function sets the event enable flags for the selected DMA channel.
488:                 	 * 					The channel event flags are forced to the eFlags value.
489:                 	 *
490:                 	 * Note:            None.
491:                 	 *
492:                 	 * Example:			DmaChnWriteEvEnableFlags(DMA_CHANNEL2, DMA_EV_ALL_EVNTS);
493:                 	 ********************************************************************/
494:                 	 void			DmaChnWriteEvEnableFlags(DmaChannel chn, DmaEvFlags eFlags);
495:                 
496:                 	/*********************************************************************
497:                 	 * Function:        DmaEvFlags DmaChnGetEvEnableFlags(DmaChannel chn)
498:                 	 *
499:                 	 * PreCondition:    chn	- valid DMA channel
500:                 	 *
501:                 	 * Input:			chn		- DMA channel number
502:                 	 *
503:                 	 * Output:          - event flags with the following significance:
504:                 	 * 						- DMA_EV_ERR: address error event
505:                 	 * 						- DMA_EV_ABORT: transfer abort event
506:                 	 * 						- DMA_EV_CELL_DONE: cell transfer complete event
507:                 	 * 						- DMA_EV_BLOCK_DONE: block transfer complete event
508:                 	 * 						- DMA_EV_DST_HALF: destination half event
509:                 	 * 						- DMA_EV_DST_FULL: destination full event
510:                 	 * 						- DMA_EV_SRC_HALF: source half event
511:                 	 * 						- DMA_EV_SRC_FULL: source full event
512:                 	 *						- DMA_EV_ALL_EVNTS: all of the above flags
513:                 	 *
514:                 	 * Side Effects:    None
515:                 	 *
516:                 	 * Overview:		The function returns the event enabled flags for the selected DMA channel.
517:                 	 *
518:                 	 * Note:            None.
519:                 	 *
520:                 	 * Example:			DmaEvFlags enabledFlags=DmaChnGetEvEnableFlags(DMA_CHANNEL2);
521:                 	 ********************************************************************/
522:                 	 DmaEvFlags	DmaChnGetEvEnableFlags(DmaChannel chn);
523:                 
524:                 	/*********************************************************************
525:                 	 * Function:        void DmaChnClrEvFlags(DmaChannel chn, DmaEvFlags eFlags)
526:                 	 *
527:                 	 * PreCondition:    chn	- valid DMA channel
528:                 	 *
529:                 	 * Input:			chn		- DMA channel number
530:                 	 * 					eFlags	- event flags with the following significance:
531:                 	 * 								- DMA_EV_ERR: address error event
532:                 	 * 								- DMA_EV_ABORT: transfer abort event
533:                 	 * 								- DMA_EV_CELL_DONE: cell transfer complete event
534:                 	 * 								- DMA_EV_BLOCK_DONE: block transfer complete event
535:                 	 * 								- DMA_EV_DST_HALF: destination half event
536:                 	 * 								- DMA_EV_DST_FULL: destination full event
537:                 	 * 								- DMA_EV_SRC_HALF: source half event
538:                 	 * 								- DMA_EV_SRC_FULL: source full event
539:                 	 * 								- DMA_EV_ALL_EVNTS: all of the above flags
540:                 	 *
541:                 	 * Output:          None
542:                 	 *
543:                 	 * Side Effects:    None
544:                 	 *
545:                 	 * Overview:		The function clears the event flags for the selected DMA channel.
546:                 	 * 					Multiple flags can be orr-ed together. Any flag that is set in the eFlags will be
547:                 	 * 					cleared for the selected channel, the other channel event flags won't be touched.
548:                 	 *
549:                 	 * Note:            None.
550:                 	 *
551:                 	 * Example:			DmaChnClrEvFlags(DMA_CHANNEL2, DMA_EV_ALL_EVNTS);
552:                 	 ********************************************************************/
553:                 	 void			DmaChnClrEvFlags(DmaChannel chn, DmaEvFlags eFlags);
554:                 
555:                 	/*********************************************************************
556:                 	 * Function:        DmaEvFlags DmaChnGetEvFlags(DmaChannel chn)
557:                 	 *
558:                 	 * PreCondition:    chn	- valid DMA channel
559:                 	 *
560:                 	 * Input:			chn		- DMA channel number
561:                 	 *
562:                 	 * Output:          event flags with the following significance:
563:                 	 * 						- DMA_EV_ERR: address error event
564:                 	 * 						- DMA_EV_ABORT: transfer abort event
565:                 	 * 						- DMA_EV_CELL_DONE: cell transfer complete event
566:                 	 * 						- DMA_EV_BLOCK_DONE: block transfer complete event
567:                 	 * 						- DMA_EV_DST_HALF: destination half event
568:                 	 * 						- DMA_EV_DST_FULL: destination full event
569:                 	 * 						- DMA_EV_SRC_HALF: source half event
570:                 	 * 						- DMA_EV_SRC_FULL: source full event
571:                 	 * 						- DMA_EV_ALL_EVNTS: all of the above flags
572:                 	 *
573:                 	 * Side Effects:    None
574:                 	 *
575:                 	 * Overview:		The function returns the event flags for the selected DMA channel.
576:                 	 *
577:                 	 * Note:            None.
578:                 	 *
579:                 	 * Example:			DmaEvFlags intSetFlags=DmaChnGetEvFlags(DMA_CHANNEL2);
580:                 	 ********************************************************************/
581:                 	 DmaEvFlags	DmaChnGetEvFlags(DmaChannel chn);
582:                 
583:                 
584:                 	// high level helpers for fast strcpy/memcpy transfers
585:                 
586:                 	/*********************************************************************
587:                 	 * Function:        DmaTxferRes DmaChnMemcpy(void* s1, const void* s2, int n, DmaChannel chn, DmaChannelPri chPri)
588:                 	 *
589:                 	 * PreCondition:    chn		- a valid DMA channel
590:                 	 * 					s1, s2	- valid memory pointers
591:                 	 * 					n>0, n<=DmaGetMaxTxferSize()
592:                 	 *
593:                 	 * Input:			s1		- destination pointer
594:                 	 * 					s2		- source pointer
595:                 	 * 					n		- number of bytes to transfer
596:                 	 * 					chn		- the DMA channel to perform the transfer
597:                 	 * 					chPri	- the desired channel priority
598:                 	 *
599:                 	 * Output:          DMA_TXFER_OK if the transfer ended normally,
600:                 	 * 					an DmaTxferRes error code  otherwise
601:                 	 *
602:                 	 * Side Effects:    None
603:                 	 *
604:                 	 * Overview:		The function configures a DMA channel for a fast memory transfer.
605:                 	 * 			Then it copies one block of memory from source to destination.
606:                 	 *
607:                 	 *
608:                 	 * Note:            - If the CRC is attached to the submitted channel, the CRC append mode will be turned off.
609:                 	 * 						This way, the transfer will occur correctly together with CRC calculation.
610:                 	 * 					- The start and abort Irqs will be disabled and the channel event enable flags are disabled.
611:                 	 * 					- Multiple channels could be opened to perform fast memory transfers, if necessary.
612:                 	 * 					- The function clears the suspend state and resumes the operation of the DMA controller.
613:                 	 *
614:                  	 * Example:		res=DmaChnMemcpy(pDst, pSrc, buffSz, DMA_CHANNEL2, DMA_CHN_PRI3);
615:                  	 ********************************************************************/
616:                 	 DmaTxferRes	DmaChnMemcpy(void* s1, const void* s2, int n, DmaChannel chn, DmaChannelPri chPri);
617:                 
618:                 	/*********************************************************************
619:                 	 * Function:        DmaTxferRes DmaChnStrcpy(char* s1, const char* s2, DmaChannel chn, DmaChannelPri chPri)
620:                 	 *
621:                 	 * PreCondition:    chn		- a valid DMA channel
622:                 	 * 					s1, s2	- valid memory pointers
623:                 	 *
624:                 	 * Input:			s1		- destination pointer
625:                 	 * 					s2		- source pointer
626:                 	 * 					chn		- the DMA channel to perform the transfer
627:                 	 * 					chPri	- the desired channel priority
628:                 	 *
629:                 	 * Output:          DMA_TXFER_OK if the transfer ended normally,
630:                 	 * 					an DmaTxferRes error code  otherwise
631:                 	 *
632:                 	 * Side Effects:    None
633:                 	 *
634:                 	 * Overview:		The function configures a DMA channel for a fast memory transfer.
635:                 	 * 			Then it copies one zero terminated string from source to destination.
636:                 	 *
637:                 	 *
638:                 	 * Note:            - If the CRC is attached to the submitted channel, the CRC append mode will be turned off.
639:                 	 *				This way, the transfer will occur correctly together with CRC calculation.
640:                 	 *			- The start and abort Irqs will be disabled and the channel event enable flags are disabled.
641:                 	 *			- Multiple channels could be opened to perform fast memory transfers, if necessary.
642:                 	 * 			- The function clears the suspend state and resumes the operation of the DMA controller.
643:                 	 *
644:                 	 *
645:                  	 * Example:		res=DmaChnStrcpy(str1, str2, DMA_CHANNEL2, DMA_CHN_PRI3);
646:                 	 *********************************************************************/
647:                 	 DmaTxferRes	DmaChnStrcpy(char* s1, const char* s2, DmaChannel chn, DmaChannelPri chPri);
648:                 
649:                 	/*********************************************************************
650:                 	 * Function:        DmaTxferRes DmaChnStrncpy(char* s1, const char* s2, int n, DmaChannel chn, DmaChannelPri chPri)
651:                 	 *
652:                 	 * PreCondition:    chn		- a valid DMA channel
653:                 	 * 				- s1, s2	- valid memory pointers
654:                 	 *                              - 0 < n <= DmaGetMaxTxferSize()
655:                 	 *
656:                 	 * Input:			s1		- destination pointer
657:                 	 * 					s2		- source pointer
658:                 	 * 					n	- max number of bytes to transfer
659:                 	 * 					chn		- the DMA channel to perform the transfer
660:                 	 * 					chPri	- the desired channel priority
661:                 	 *
662:                 	 * Output:          DMA_TXFER_OK if the transfer ended normally,
663:                 	 * 					an DmaTxferRes error code  otherwise
664:                 	 *
665:                 	 * Side Effects:    None
666:                 	 *
667:                 	 * Overview:		The function configures a DMA channel for a fast memory transfer.
668:                 	 * 			Then it copies one zero terminated string from source to destination.
669:                 	 * 			It copies no more than n characters from s2.
670:                 	 *
671:                 	 *
672:                 	 * Note:            - If the CRC is attached to the submitted channel, the CRC append mode will be turned off.
673:                 	 *				This way, the transfer will occur correctly together with CRC calculation.
674:                 	 *			- The start and abort Irqs will be disabled and the channel event enable flags are disabled.
675:                 	 *			- Multiple channels could be opened to perform fast memory transfers, if necessary.
676:                 	 * 			- The function clears the suspend state and resumes the operation of the DMA controller.
677:                 	 *
678:                 	 *
679:                  	 * Example:		res=DmaChnStrncpy(str1, str2, MAX_STR_LEN, DMA_CHANNEL2, DMA_CHN_PRI3);
680:                 	 ********************************************************************/
681:                 	 DmaTxferRes DmaChnStrncpy(char* s1, const char* s2, int n, DmaChannel chn, DmaChannelPri chPri);
682:                 
683:                 	/*********************************************************************
684:                 	 * Function:        DmaTxferRes DmaChnMemCrc(void* d, const void* s, int n, DmaChannel chn, DmaChannelPri chPri)
685:                 	 *
686:                 	 * PreCondition:    chn		- a valid DMA channel
687:                 	 * 					d, s		- valid memory pointer
688:                 	 * 					n>0, n<=DmaGetMaxTxferSize()
689:                 	 *
690:                 	 * Input:			d		- address where to deposit the result
691:                 	 * 					s		- source buffer pointer
692:                 	 * 					n		- number of bytes in the pointer
693:                 	 * 					chn		- the DMA channel to use
694:                 	 * 					chPri	- the desired channel priority
695:                 	 *
696:                 	 * Output:          DMA_TXFER_OK if the transfer ended normally,
697:                 	 * 					an DmaTxferRes error code  otherwise
698:                 	 *
699:                 	 * Side Effects:    None
700:                 	 *
701:                 	 * Overview:		The function is a helper that calculates the CRC of a memory block.
702:                 	 * 			The function configures the DMA channel for a fast memory transfer and calculates the CRC.
703:                 	 *
704:                 	 *
705:                 	 * Note:            - The CRC generator must have been previously configured using mCrcConfigure()
706:                 	 * 					- No transfer is done, just the CRC is calculated.
707:                 	 *			- The start and abort Irqs will be disabled and the channel event enable flags are disabled.
708:                 	 * 			- The function clears the suspend state and resumes the operation of the DMA controller.
709:                 	 *
710:                 	 * Example:		int myCrc; DmaChnMemCrc(&myCrc, srcBuff, sizeof(srcBuff), DMA_CHANNEL2, DMA_CHN_PRI3);
711:                 	 ********************************************************************/
712:                 	 DmaTxferRes	DmaChnMemCrc(void* d, const void* s, int n, DmaChannel chn, DmaChannelPri chPri);
713:                 
714:                 
715:                 	// High level CRC functions
716:                 
717:                 	/*********************************************************************
718:                 	 * Function:        void DmaCrcConfigure(unsigned int polynomial, int pLen, unsigned int seed)
719:                 	 *
720:                 	 * PreCondition:    pLen		- valid polynomial length within 1-16
721:                 	 *
722:                 	 * Input:			polynomial	- the layout of the CRC generator
723:                 	 * 					pLen		- the length of the CRC generator polynomial
724:                 	 * 					seed		- the initial seed of the CRC generator
725:                 	 *
726:                 	 * Output:          None
727:                 	 *
728:                 	 * Side Effects:    None
729:                 	 *
730:                 	 * Overview:		The function configures the CRC module by setting the parameters that define the generator polynomial:
731:                 	 * 					- the length of the CRC generator polynomial, pLen;
732:                 	 * 					- the function sets the layout of the shift stages that take place in the CRC generation.
733:                 	 * 						Setting a bit to 1 enables the XOR input from the MSb (pLen bit) to the selected stage in the shift register.
734:                 	 * 						If bit is cleared, the selected shift stage gets data directly from the previous stage in the shift register.
735:                 	 * 						Note that in a proper CRC polynomial, both the most significant bit (MSb) and least significant bit(LSb)
736:                 	 * 						are always a '1'. Considering the generator polynomial: X^16+X^15+X^2+1, the value to be written as
737:                 	 * 						feedback should be 0x8005, or 0x8004, but not 0x018005;
738:                 	 *					- the function sets the seed of the CRC generator. This is the initial data present in the
739:                 	 * 						CRC shift register before the CRC calculation begins. A good initial value is usually 0xffffffff.
740:                 	 *
741:                 	 * Note:            - Bit 0 of the generator polynomial is always XOR'ed.
742:                 	 * 					- When the append mode is set, the attached DMA channel has to have destination size <=4.
743:                 	 * 						Upon the transfer completion the calculated CRC is stored at the destination address.
744:                 	 * 					- When append mode is cleared, the DMA transfer occurs normally, and the CRC value is available using
745:                 	 * 						the CrcResult() function.
746:                 	 * 					- The CRC module should be configured before enabled.
747:                 	 *
748:                 	 * Example:			DmaCrcConfigure(0x8005, 16, 0xffff);
749:                 	 ********************************************************************/
750:                 	extern __inline__ void __attribute__((always_inline)) DmaCrcConfigure(unsigned int polynomial, int pLen, unsigned int seed)
751:                 	{
752:                 		DCRCCONCLR=_DCRCCON_PLEN_MASK;
753:                 		DCRCCONSET=(pLen-1)<<_DCRCCON_PLEN_POSITION;
754:                 		DCRCDATA=seed;
755:                 		DCRCXOR=polynomial;
756:                 	}
757:                 
758:                 	/*********************************************************************
759:                 	 * Function:        void CrcAttachChannel(DmaChannel chn, int appendMode)
760:                 	 *
761:                 	 * PreCondition:    chn		- valid DMA channel
762:                 	 *
763:                 	 * Input:			chn			- the DMA channel to be attached to the CRC generator module.
764:                 	 * 					appendMode	- if TRUE the data passed to the CRC generator is not transferred to destination
765:                 	 * 									but it's written to the destination address when the block transfer is complete.
766:                 	 * 								- if FALSE the data is transferred normally while the CRC is calculated. The CRC will
767:                 	 * 									be available using the CrcResult function.
768:                 	 *
769:                 	 * Output:          None
770:                 	 *
771:                 	 * Side Effects:    None
772:                 	 *
773:                 	 * Overview:		The function attaches the CRC module to an DMA channel and enables the CRC generator.
774:                 	 * 					From now on, all the DMA traffic is directed to the CRC generator. Once the DMA block transfer
775:                 	 * 					is complete, the CRC result is available both at the DMA destination address and in the CRC data register.
776:                 	 *
777:                 	 * Note:            None
778:                 	 *
779:                 	 * Example:			CrcAttachChannel(0, TRUE);
780:                 	 ********************************************************************/
781:                 	 void			CrcAttachChannel(DmaChannel chn, int appendMode);
782:                 
783:                 	/*********************************************************************
784:                 	 * Function:        unsigned int CrcResult(void)
785:                 	 *
786:                 	 * PreCondition:    None
787:                 	 *
788:                 	 * Input:			None
789:                 	 *
790:                 	 * Output:          the current value of the CRC generator.
791:                 	 *
792:                 	 * Side Effects:    None
793:                 	 *
794:                 	 * Overview:		The function returns the calculated CRC value.
795:                 	 *
796:                 	 * Note:            The function returns the valid CRC result by masking out the unused MSbits in the CRC register.
797:                 	 * 					Use CrcGetValue() to get the full CRC register value.
798:                 	 *
799:                 	 * Example:			int myCrc=CrcResult();
800:                 	 ********************************************************************/
801:                 	 unsigned int		CrcResult(void);
802:                 
803:                 
804:                 /*********************  end of high level functions ****************************************/
805:                 
806:                 	// low level definitions for the API functions
807:                 
808:                 
809:                 	typedef struct
810:                 	{
811:                 		union
812:                 		{
813:                 			struct
814:                 			{
815:                 				unsigned int chn:	3;		// last active DMA channel
816:                 				unsigned int rdOp:	1;		// last DMA operation, read if 1, write if 0
817:                 			};
818:                 			unsigned int	w;						// word access
819:                 		}lastAccess;
820:                 		void*	lastAddress;		// most recent DMA address
821:                 	}DmaStatus;			// DMA controller status
822:                 #if(defined(__32MX330F064H__)||\
823:                     defined(__32MX330F064L__)||\
824:                     defined(__32MX350F128H__)||\
825:                     defined(__32MX350F128L__)||\
826:                     defined(__32MX350F256H__)||\
827:                     defined(__32MX350F256L__)||\
828:                 	defined(__32MX370F512H__)||\
829:                 	defined(__32MX370F512L__)||\
830:                     defined(__32MX430F064H__)||\
831:                     defined(__32MX430F064L__)||\
832:                     defined(__32MX450F128H__)||\
833:                     defined(__32MX450F128L__)||\
834:                     defined(__32MX450F256H__)||\
835:                     defined(__32MX450F256L__)||\
836:                 	defined(__32MX470F512L__)||\
837:                 	defined(__32MX470F512L__))
838:                 typedef enum
839:                 	{
840:                 		DMA_GFLG_SUSPEND =	_DMACON_SUSPEND_MASK,	// suspend DMA controller operation
841:                 		DMA_GFLG_ON =		_DMACON_ON_MASK,		// DMA module enabled/desabled
842:                 		//
843:                 		DMA_GFLG_ALL_FLAGS=	DMA_GFLG_SUSPEND|DMA_GFLG_ON		// all flags
844:                 	}DmaGlblFlags;	// flags for controlling global DMA controller behavior. From processor header file.
845:                 #else
846:                 	typedef enum
847:                 	{
848:                 		DMA_GFLG_SUSPEND =	_DMACON_SUSPEND_MASK,	// suspend DMA controller operation
849:                 		DMA_GFLG_SIDL =		_DMACON_SIDL_MASK,		// DMA controller sleep/active in idle mode
850:                 		DMA_GFLG_ON =		_DMACON_ON_MASK,		// DMA module enabled/desabled
851:                 		//
852:                 		DMA_GFLG_ALL_FLAGS=	DMA_GFLG_SUSPEND|DMA_GFLG_SIDL|DMA_GFLG_ON		// all flags
853:                 	}DmaGlblFlags;	// flags for controlling global DMA controller behavior. From processor header file.
854:                 
855:                 #endif
856:                 
857:                 
858:                 	typedef enum
859:                 	{
860:                 		DMA_EV_ABORT_IRQ_EN =		_DCH0ECON_AIRQEN_MASK,
861:                 		DMA_EV_START_IRQ_EN =		_DCH0ECON_SIRQEN_MASK,
862:                         // use DMA_EV_START_IRQ() and DMA_EV_ABORT_IRQ() below for selecting
863:                         // the start and abort IRQ signals
864:                 		DMA_EV_MATCH_EN =			_DCH0ECON_PATEN_MASK,
865:                 
866:                 
867:                         // compiler use only field
868:                         _DMA_EV_MAX_MASK =     _DCH0ECON_CHAIRQ_MASK,
869:                 	}DmaEvCtrlFlags;	// DMA channel event control fields accessibile as flags
870:                 	// also part of DmaEvCtrlFlags:
871:                 	#define	DMA_EV_START_IRQ(irq)	(DMA_EV_START_IRQ_EN | ((irq)<<_DCH0ECON_CHSIRQ_POSITION))	// NOTE: irq has to be a symbol from the processor header file
872:                 	#define	DMA_EV_ABORT_IRQ(irq)	(DMA_EV_ABORT_IRQ_EN | ((irq)<<_DCH0ECON_CHAIRQ_POSITION))	// NOTE: irq has to be a symbol from the processor header file
873:                 
874:                 	// DMA channel event control as a structure:
875:                 	#define	DmaEvCtrl	__DCH0ECONbits_t
876:                 
877:                 
878:                 
879:                 
880:                 	typedef enum
881:                 	{
882:                 		DMA_CTL_AUTO_EN =		_DCH0CON_CHAEN_MASK,
883:                 		DMA_CTL_CHAIN_EN =		_DCH0CON_CHCHN_MASK,
884:                 		DMA_CTL_DET_EN =		_DCH0CON_CHAED_MASK,
885:                 		DMA_CTL_CHN_EN =		_DCH0CON_CHEN_MASK,
886:                 		DMA_CTL_CHAIN_DIR =		_DCH0CON_CHCHNS_MASK,
887:                         // use the DMA_CTL_PRI() below for selecting the DMA
888:                         // channel priority
889:                 	}DmaChnCtrlFlags;	// controlling the DMA channel with flags
890:                 	// also part of DmaChnCtrlFlags:
891:                 	#define	DMA_CTL_PRI(pri)	((pri)&_DCH0CON_CHPRI_MASK) // DMA Control channel priority
892:                 
893:                 	// DMA channel control as a structure:
894:                 	#define	DmaChnCtrl  	__DCH0CONbits_t
895:                 
896:                 	typedef struct
897:                 	{
898:                 		void*	vSrcAdd;		// source of the DMA transfer, virtual
899:                 		void*	vDstAdd;		// destination of the DMA transfer, virtual
900:                 		int	srcSize;		// source buffer size, 1 to DmaGetMaxTxferSize() bytes. Wrapped around.
901:                 		int	dstSize;		// destination buffer size, 1 to DmaGetMaxTxferSize() bytes. Wrapped around.
902:                 		int	cellSize;		// no of bytes txferred per event, 1 to DmaGetMaxTxferSize().
903:                 	}DmaTxferCtrl;		// transfer setting: the transfer source, destination addresses and size, cell size
904:                 
905:                 
906:                 	/********************** low level DMA channel functions *******************************/
907:                 
908:                 
909:                 
910:                 	// Global DMA controller functions
911:                 
912:                 
913:                 	/*********************************************************************
914:                 	 * Function:        void DmaEnable(int enable)
915:                 	 *
916:                 	 * PreCondition:    None
917:                 	 *
918:                 	 * Input:           enable - boolean to enable/disable the DMA controller
919:                 	 *
920:                 	 * Output:          None
921:                 	 *
922:                 	 * Side Effects:    None
923:                 	 *
924:                 	 * Overview:       The function enables/disables the DMA controller.
925:                 	 *
926:                 	 * Note:           None.
927:                 	 *
928:                 	 * Example:        DmaEnable(1);
929:                 	 ********************************************************************/
930:                 	extern __inline__ void __attribute__((always_inline)) DmaEnable(int enable)
931:                 	{
932:                 		if(enable)
933:                 		{
934:                 			DMACONSET=_DMACON_ON_MASK;
935:                 		}
936:                 		else
937:                 		{
938:                 			DMACONCLR=_DMACON_ON_MASK;
939:                 			while(DMACONbits.ON);		// wait to take effect
940:                 		}
941:                 	}
942:                 
943:                 	/*********************************************************************
944:                 	 * Function:        void DmaReset(void)
945:                 	 *
946:                 	 * PreCondition:    None
947:                 	 *
948:                 	 * Input:		None
949:                 	 *
950:                 	 * Output:          None
951:                 	 *
952:                 	 * Side Effects:    None
953:                 	 *
954:                 	 * Overview:        The function resets the DMA controller.
955:                 	 *
956:                 	 * Note:            None.
957:                 	 *
958:                 	 * Example:        DmaReset();
959:                 	 ********************************************************************/
960:                 	#define            DmaReset()	DmaEnable(0)
961:                 
962:                 	/*********************************************************************
963:                 	 * Function:        int DmaSuspend(void)
964:                 	 *
965:                 	 * PreCondition:    None
966:                 	 *
967:                 	 * Input:		None
968:                 	 *
969:                 	 * Output:          true if the DMA was previously suspended, false otherwise
970:                 	 *
971:                 	 *
972:                 	 * Side Effects:    None
973:                 	 *
974:                 	 * Overview:        The function suspends the DMA controller.
975:                 	 *
976:                 	 * Note:            After the execution of this function the DMA operation is supposed to be suspended.
977:                 	 *                  I.e. the function has to wait for the suspension to take place!
978:                 	 *
979:                 	 * Example:			int susp=DmaSuspend();
980:                 	 ********************************************************************/
981:                     extern __inline__ int __attribute__((always_inline)) DmaSuspend(void)
982:                 	{
983:                 		int suspSt;
984:                 		if(!(suspSt=DMACONbits.SUSPEND))
9D0309FC  3C02BF88   LUI V0, -16504
9D030A00  8C423000   LW V0, 12288(V0)
9D030A04  7C420300   EXT V0, V0, 12, 1
9D030A08  304200FF   ANDI V0, V0, 255
9D030A0C  AFC2002C   SW V0, 44(S8)
9D030A10  8FC2002C   LW V0, 44(S8)
9D030A14  14400009   BNE V0, ZERO, 0x9D030A3C
9D030A18  00000000   NOP
9D030AD0  3C02BF88   LUI V0, -16504
9D030AD4  8C423000   LW V0, 12288(V0)
9D030AD8  7C420300   EXT V0, V0, 12, 1
9D030ADC  304200FF   ANDI V0, V0, 255
9D030AE0  AFC20038   SW V0, 56(S8)
9D030AE4  8FC20038   LW V0, 56(S8)
9D030AE8  1440000E   BNE V0, ZERO, 0x9D030B24
9D030AEC  00000000   NOP
9D030C0C  3C02BF88   LUI V0, -16504
9D030C10  8C423000   LW V0, 12288(V0)
9D030C14  7C420300   EXT V0, V0, 12, 1
9D030C18  304200FF   ANDI V0, V0, 255
9D030C1C  AFC2005C   SW V0, 92(S8)
9D030C20  8FC2005C   LW V0, 92(S8)
9D030C24  14400009   BNE V0, ZERO, 0x9D030C4C
9D030C28  00000000   NOP
9D030CE0  3C02BF88   LUI V0, -16504
9D030CE4  8C423000   LW V0, 12288(V0)
9D030CE8  7C420300   EXT V0, V0, 12, 1
9D030CEC  304200FF   ANDI V0, V0, 255
9D030CF0  AFC20068   SW V0, 104(S8)
9D030CF4  8FC20068   LW V0, 104(S8)
9D030CF8  1440000E   BNE V0, ZERO, 0x9D030D34
9D030CFC  00000000   NOP
985:                 		{
986:                 			DMACONSET=_DMACON_SUSPEND_MASK;		// suspend
9D030A1C  3C02BF88   LUI V0, -16504
9D030A20  24031000   ADDIU V1, ZERO, 4096
9D030A24  AC433008   SW V1, 12296(V0)
9D030AF0  3C02BF88   LUI V0, -16504
9D030AF4  24031000   ADDIU V1, ZERO, 4096
9D030AF8  AC433008   SW V1, 12296(V0)
9D030C2C  3C02BF88   LUI V0, -16504
9D030C30  24031000   ADDIU V1, ZERO, 4096
9D030C34  AC433008   SW V1, 12296(V0)
9D030D00  3C02BF88   LUI V0, -16504
9D030D04  24031000   ADDIU V1, ZERO, 4096
9D030D08  AC433008   SW V1, 12296(V0)
987:                 			while(!(DMACONbits.SUSPEND));	// wait to be actually suspended
9D030A28  3C02BF88   LUI V0, -16504
9D030A2C  8C423000   LW V0, 12288(V0)
9D030A30  30421000   ANDI V0, V0, 4096
9D030A34  1040FFFC   BEQ V0, ZERO, 0x9D030A28
9D030A38  00000000   NOP
9D030AFC  3C02BF88   LUI V0, -16504
9D030B00  8C423000   LW V0, 12288(V0)
9D030B04  30421000   ANDI V0, V0, 4096
9D030B08  1040FFFC   BEQ V0, ZERO, 0x9D030AFC
9D030B0C  00000000   NOP
9D030B10  0B40C2C9   J 0x9D030B24
9D030B14  00000000   NOP
9D030C38  3C02BF88   LUI V0, -16504
9D030C3C  8C423000   LW V0, 12288(V0)
9D030C40  30421000   ANDI V0, V0, 4096
9D030C44  1040FFFC   BEQ V0, ZERO, 0x9D030C38
9D030C48  00000000   NOP
9D030D0C  3C02BF88   LUI V0, -16504
9D030D10  8C423000   LW V0, 12288(V0)
9D030D14  30421000   ANDI V0, V0, 4096
9D030D18  1040FFFC   BEQ V0, ZERO, 0x9D030D0C
9D030D1C  00000000   NOP
9D030D20  0B40C34D   J 0x9D030D34
9D030D24  00000000   NOP
988:                 		}
989:                 		return suspSt;
9D030A3C  8FC2002C   LW V0, 44(S8)
9D030C4C  8FC2005C   LW V0, 92(S8)
990:                 	}
991:                 
992:                 
993:                 
994:                 	/*********************************************************************
995:                 	 * Function:        void DmaResume(int susp)
996:                 	 *
997:                 	 * PreCondition:    None
998:                 	 *
999:                 	 * Input:		the desired DMA suspended state.
1000:                	 *
1001:                	 * Output:          None
1002:                	 *
1003:                	 * Side Effects:    None
1004:                	 *
1005:                	 * Overview:		The function restores the DMA controller activity to the old suspended mode.
1006:                	 *
1007:                	 * Note:            None.
1008:                	 *
1009:                	 * Example:			int isSusp=DmaSuspend(); {....}; DmaResume(isSusp);
1010:                	 ********************************************************************/
1011:                    extern __inline__ void __attribute__((always_inline)) DmaResume(int susp)
1012:                	{
1013:                		if(susp)
9D030AC4  8FC20034   LW V0, 52(S8)
9D030AC8  10400013   BEQ V0, ZERO, 0x9D030B18
9D030ACC  00000000   NOP
9D030CD4  8FC20064   LW V0, 100(S8)
9D030CD8  10400013   BEQ V0, ZERO, 0x9D030D28
9D030CDC  00000000   NOP
1014:                		{
1015:                			DmaSuspend();
1016:                		}
1017:                		else
1018:                		{
1019:                			DMACONCLR=_DMACON_SUSPEND_MASK;		// resume DMA activity
9D030B18  3C02BF88   LUI V0, -16504
9D030B1C  24031000   ADDIU V1, ZERO, 4096
9D030B20  AC433004   SW V1, 12292(V0)
9D030D28  3C02BF88   LUI V0, -16504
9D030D2C  24031000   ADDIU V1, ZERO, 4096
9D030D30  AC433004   SW V1, 12292(V0)
1020:                		}
1021:                	}
1022:                
1023:                	/*********************************************************************
1024:                	 * Function:        void DmaGetStatus(DmaStatus* pStat)
1025:                	 *
1026:                	 * PreCondition:    pStat	- valid pointer
1027:                	 *
1028:                	 * Input:			pStat	- pointer to a DmaStatus structure to store the current DMA controller
1029:                	 * 							status, carrying the following info:
1030:                	 * 								- chn:	the last active DMA channel
1031:                	 * 								- rdOp: the last DMA operation, read/write
1032:                	 * 								- lastAddress: the most recent DMA address
1033:                	 *
1034:                	 * Output:          None
1035:                	 *
1036:                	 * Side Effects:    None
1037:                	 *
1038:                	 * Overview:		The function updates the info for the current DMA controller status.
1039:                	 * 					It updates the last DMA: operation, channel used and address.
1040:                	 *
1041:                	 * Note:            None.
1042:                	 *
1043:                	 * Example:			DmaStatus stat; DmaGetStatus(&stat);
1044:                	 ********************************************************************/
1045:                	 void			DmaGetStatus(DmaStatus* pStat);
1046:                
1047:                	/*********************************************************************
1048:                	 * Function:        void DmaSetGlobalFlags(DmaGlblFlags gFlags)
1049:                	 *
1050:                	 * PreCondition:    None
1051:                	 *
1052:                	 * Input:			gFlags	- flags to be set, having the following fields:
1053:                	 * 								- DMA_GFLG_SUSPEND: DMA controller operation suspend
1054:                	 * 								- DMA_GFLG_SIDL: DMA controller sleep/active in idle mode
1055:                	 * 								- DMA_GFLG_ON: DMA controller enabled/desabled
1056:                	 * 								- DMA_GFLG_ALL_FLAGS: all flags
1057:                	 *
1058:                	 * Output:          None
1059:                	 *
1060:                	 * Side Effects:    None
1061:                	 *
1062:                	 * Overview:		The function affects the global behavior of the DMA controller.
1063:                	 * 					It sets the specified flags. Any flag that is set in the gFlags will be
1064:                	 * 					enabled, the other flags won't be touched.
1065:                	 *
1066:                	 * Note:            None.
1067:                	 *
1068:                	 * Example:			DmaSetGlobalFlags(DMA_GFLG_SIDL|DMA_GFLG_ON);
1069:                	 ********************************************************************/
1070:                        extern __inline__ void __attribute__((always_inline)) DmaSetGlobalFlags(DmaGlblFlags gFlags)
1071:                	{
1072:                		DMACONSET=gFlags;
1073:                	}
1074:                
1075:                	/*********************************************************************
1076:                	 * Function:        void DmaClrGlobalFlags(DmaGlblFlags gFlags)
1077:                	 *
1078:                	 * PreCondition:    None
1079:                	 *
1080:                	 * Input:			gFlags	- flags to be cleared, having the following fields:
1081:                	 * 								- DMA_GFLG_SUSPEND: DMA controller operation suspend
1082:                	 * 								- DMA_GFLG_SIDL: DMA controller sleep/active in idle mode
1083:                	 * 								- DMA_GFLG_ON: DMA controller enabled/desabled
1084:                	 * 								- DMA_GFLG_ALL_FLAGS: all flags
1085:                	 *
1086:                	 * Output:          None
1087:                	 *
1088:                	 * Side Effects:    None
1089:                	 *
1090:                	 * Overview:		The function affects the global behavior of the DMA controller.
1091:                	 * 					It clears the specified flags. Any flag that is set in the gFlags will be
1092:                	 * 					cleared, the other flags won't be touched.
1093:                	 *
1094:                	 * Note:            None.
1095:                	 *
1096:                	 * Example:			DmaClrGlobalFlags(DMA_GFLG_SUSPEND|DMA_GFLG_SIDL);
1097:                	 ********************************************************************/
1098:                        extern __inline__ void __attribute__((always_inline)) DmaClrGlobalFlags(DmaGlblFlags gFlags)
1099:                	{
1100:                		DMACONCLR=gFlags;
1101:                	}
1102:                
1103:                
1104:                	/*********************************************************************
1105:                	 * Function:        void DmaWriteGlobalFlags(DmaGlblFlags gFlags)
1106:                	 *
1107:                	 * PreCondition:    None
1108:                	 *
1109:                	 * Input:			gFlags	- flags to be set, having the following fields:
1110:                	 * 								- DMA_GFLG_SUSPEND: DMA controller operation suspend
1111:                	 * 								- DMA_GFLG_SIDL: DMA controller sleep/active in idle mode
1112:                	 * 								- DMA_GFLG_ON: DMA controller enabled/desabled
1113:                	 * 								- DMA_GFLG_ALL_FLAGS: all flags
1114:                	 *
1115:                	 * Output:          None
1116:                	 *
1117:                	 * Side Effects:    None
1118:                	 *
1119:                	 * Overview:		The function affects the global behavior of the DMA controller.
1120:                	 * 					It forces the flags to have the specified gFlags value.
1121:                	 *
1122:                	 * Note:            None.
1123:                	 *
1124:                	 * Example:			DmaWriteGlobalFlags(DMA_GFLG_ALL_FLAGS);
1125:                	 ********************************************************************/
1126:                        extern __inline__ void __attribute__((always_inline)) DmaWriteGlobalFlags(DmaGlblFlags gFlags)
1127:                	{
1128:                		DMACON=gFlags;
1129:                	}
1130:                
1131:                	/*********************************************************************
1132:                	 * Function:        DmaGlblFlags DmaGetGlobalFlags(void)
1133:                	 *
1134:                	 * PreCondition:    None
1135:                	 *
1136:                	 * Input:			None
1137:                	 *
1138:                	 * Output:          The current DMA controller flags settings.
1139:                	 * 						- DMA_GFLG_SUSPEND: DMA controller operation suspend
1140:                	 * 						- DMA_GFLG_SIDL: DMA controller sleep/active in idle mode
1141:                	 * 						- DMA_GFLG_ON: DMA controller enabled/desabled
1142:                	 *
1143:                	 * Side Effects:    None
1144:                	 *
1145:                	 * Overview:		The function returns the global flags of the DMA controller.
1146:                	 *
1147:                	 * Note:            None.
1148:                	 *
1149:                	 * Example:			DmaGlblFlags dmaFlags=DmaGetGlobalFlags();
1150:                	 ********************************************************************/
1151:                        extern __inline__ DmaGlblFlags __attribute__((always_inline)) DmaGetGlobalFlags(void)
1152:                	{
1153:                		return (DmaGlblFlags)DMACON;
1154:                	}
1155:                
1156:                
1157:                	/*********************************************************************
1158:                	 * Function:        int DmaGetMaxTxferSize(void)
1159:                	 *
1160:                	 * PreCondition:    None
1161:                	 *
1162:                	 * Input:           None
1163:                	 *
1164:                	 * Output:          The maximum transfer capacity for a DMA channel, in bytes.
1165:                	 *
1166:                	 * Side Effects:    None
1167:                	 *
1168:                	 * Overview:        The function returns the maximum number of bytes that can be transferred by a DMA channel.
1169:                	 *
1170:                	 * Note:            Revision dependant.
1171:                	 *
1172:                	 * Example:         int dmaMaxSz=DmaGetMaxTxferSize();
1173:                	 ********************************************************************/
1174:                	extern __inline__ int __attribute__((always_inline)) DmaGetMaxTxferSize(void)
1175:                	{
1176:                		return 256;
1177:                	}
1178:                
1179:                
1180:                	// Direct Channel control functions
1181:                
1182:                	typedef enum
1183:                	{
1184:                		DMA_CONFIG_DEFAULT = 0,							        // DMA default operation
1185:                		DMA_CONFIG_AUTO	= _DCH0CON_CHAEN_MASK,					// DMA channel is auto enabled
1186:                		DMA_CONFIG_CHAIN_LOW  = (_DCH0CON_CHCHN_MASK|_DCH0CON_CHCHNS_MASK),	// DMA channel is chained to lower channel
1187:                		DMA_CONFIG_CHAIN_HI  = (_DCH0CON_CHCHN_MASK),			// DMA channel is chained to higher channel
1188:                		DMA_CONFIG_DET_EN = _DCH0CON_CHAED_MASK,				// events detection enabled while channel off
1189:                		DMA_CONFIG_ENABLE = _DCH0CON_CHEN_MASK,					// DMA channel is enabled after open
1190:                		DMA_CONFIG_MATCH	= 0x80000000,						// DMA channel stops on match
1191:                	}DmaConfigFlags;	// flags for the channel configuration
1192:                
1193:                	/*********************************************************************
1194:                	 * Function:        void DmaChnConfigure(DmaChannel chn, DmaChannelPri chPri, DmaConfigFlags cFlags)
1195:                	 *
1196:                	 * PreCondition:    chPri  - valid channel priority, 0-3
1197:                	 *
1198:                	 * Input:           chn    - channel to be configured in the DMA controller
1199:                	 *                  chPri  - the priority given to the channel, 0-3
1200:                	 *                  cFlags - orred flags specifying the configuration:
1201:                	 *                           DMA_CONFIG_DEFAULT: DMA default operation mode
1202:                	 *                           DMA_CONFIG_AUTO:	DMA channel is auto enabled
1203:                	 *                           DMA_CONFIG_CHAIN_LOW: DMA channel is chained to lower channel
1204:                	 *                           DMA_CONFIG_CHAIN_HI: DMA channel is chained to higher channel
1205:                	 *                           DMA_CONFIG_DET_EN: events detection enabled while channel off
1206:                	 *                           DMA_CONFIG_ENABLE: DMA channel is enabled when opened
1207:                	 *                           DMA_CONFIG_MATCH:	DMA channel stops on match
1208:                	 *
1209:                	 *
1210:                	 *
1211:                	 * Output:          None
1212:                	 *
1213:                	 * Side Effects:    None
1214:                	 *
1215:                	 * Overview:        The function configures the selected DMA channel using the supplied user flags and priority.
1216:                	 *
1217:                	 * Note:            - The channel is NOT turned off. It should be turned off before calling this function.
1218:                	 *                  The channel is just configured.
1219:                	 *                  - After calling this function, the channel should be enabled using DmaChnEnable(chn) call
1220:                	 *                  if DMA_CONFIG_ENABLE flag was not specified.
1221:                	 *                  - The function does not touch the interrupt flags, interrupt enables, etc.
1222:                	 *                  The interrupt flags should have been previously cleared and interrupts disabled before calling this function.
1223:                	 *                  - The start and abort Irqs, the channel event enable flags are not touched/cleared by this function.
1224:                	 *                  User has to call event channel functions to clear/enable the event flags if needed.
1225:                	 *
1226:                	 * Example:         DmaChnDisable(DMA_CHANNEL2); DmaChnConfigure(DMA_CHANNEL2, DMA_CHN_PRI2, DMA_CONFIG_AUTO|DMA_CONFIG_MATCH|DMA_CONFIG_ENABLE);
1227:                	 ********************************************************************/
1228:                	void			DmaChnConfigure(DmaChannel chn, DmaChannelPri chPri, DmaConfigFlags cFlags);
1229:                
1230:                
1231:                	/*********************************************************************
1232:                	 * Function:        int DmaChnGetSrcPnt(DmaChannel chn)
1233:                	 *
1234:                	 * PreCondition:    chn	- valid DMA channel
1235:                	 *
1236:                	 * Input:			chn		- DMA channel number
1237:                	 *
1238:                	 * Output:          Current channel source pointer.
1239:                	 *
1240:                	 * Side Effects:    None
1241:                	 *
1242:                	 * Overview:		The function retrieves the current source pointer for the selected DMA channel.
1243:                	 * 					It is the current offset, 0 to DmaGetMaxTxferSize()-1, in the source transfer buffer.
1244:                	 *
1245:                	 * Note:            None
1246:                	 *
1247:                	 * Example:         int srcPnt=DmaChnGetSrcPnt(DMA_CHANNEL2);
1248:                	 ********************************************************************/
1249:                	 int			DmaChnGetSrcPnt(DmaChannel chn);
1250:                
1251:                	/*********************************************************************
1252:                	 * Function:        int DmaChnGetDstPnt(DmaChannel chn)
1253:                	 *
1254:                	 * PreCondition:    chn	- valid DMA channel
1255:                	 *
1256:                	 * Input:			chn		- DMA channel number
1257:                	 *
1258:                	 * Output:          Current channel destination pointer.
1259:                	 *
1260:                	 * Side Effects:    None
1261:                	 *
1262:                	 * Overview:		The function retrieves the current destination pointer for the selected DMA channel.
1263:                	 * 					It is the current offset, 0 to DmaGetMaxTxferSize()-1, in the destination transfer buffer.
1264:                	 *
1265:                	 * Note:            None
1266:                	 *
1267:                	 * Example:			int dstPnt=DmaChnGetDstPnt(DMA_CHANNEL2);
1268:                	 ********************************************************************/
1269:                	 int			DmaChnGetDstPnt(DmaChannel chn);
1270:                
1271:                	/*********************************************************************
1272:                	 * Function:        int DmaChnGetCellPnt(DmaChannel chn)
1273:                	 *
1274:                	 * PreCondition:    chn	- valid DMA channel
1275:                	 *
1276:                	 * Input:			chn		- DMA channel number
1277:                	 *
1278:                	 * Output:          Current channel transfer pointer.
1279:                	 *
1280:                	 * Side Effects:    None
1281:                	 *
1282:                	 * Overview:		The function retrieves the current transfer progress pointer for the selected DMA channel.
1283:                	 * 					It ranges 0 to DmaGetMaxTxferSize()-1.
1284:                	 *
1285:                	 * Note:            None
1286:                	 *
1287:                	 * Example:			int cellPnt=DmaChnGetCellPnt(DMA_CHANNEL2);
1288:                	 ********************************************************************/
1289:                	 int			DmaChnGetCellPnt(DmaChannel chn);
1290:                
1291:                
1292:                
1293:                	/*********************************************************************
1294:                	 * Function:        void DmaChnSetEventControlFlags(DmaChannel chn, DmaEvCtrlFlags dmaEvCtrl)
1295:                	 *
1296:                	 * PreCondition:    chn	- valid DMA channel
1297:                	 *
1298:                	 * Input:			chn			- DMA channel number
1299:                	 * 					dmaEvCtrl	- 	either a DmaEvCtrl structure field, carrying the following info:
1300:                	 * 										- AIRQEN: enable/disable the abort IRQ action
1301:                	 * 										- SIRQEN: enable/disable the start IRQ action
1302:                	 * 										- PATEN: enable/disable the pattern match and abort
1303:                	 * 									or any of the DmaEvCtrlFlags:
1304:                	 * 										DMA_EV_ABORT_IRQ_EN|DMA_EV_START_IRQ_EN|DMA_EV_MATCH_EN
1305:                	 *
1306:                	 *
1307:                	 * Output:          None
1308:                	 *
1309:                	 * Side Effects:    None
1310:                	 *
1311:                	 * Overview:		The function sets the events that start and abort the transfer
1312:                	 * 					for the selected DMA channel.
1313:                	 * 					Multiple flags can be orr-ed together. Any flag that is set in the eFlags will be
1314:                	 * 					enabled for the selected channel, the other channel event flags won't be touched.
1315:                	 *
1316:                	 * Note:            None.
1317:                	 *
1318:                	 * Example:			either:
1319:                	 * 						DmaChnSetEventControlFlags(DMA_CHANNEL2, DMA_EV_MATCH_EN|DMA_EV_START_IRQ_EN;
1320:                	 * 					or:
1321:                	 * 						DmaEvCtrl evCtrl; evCtrl.w=0; evCtrl.PATEN=1; evCtrl.SIRQEN=1;
1322:                	 * 						DmaChnSetEventControlFlags(DMA_CHANNEL2, evCtrl.w);
1323:                	 *
1324:                	 ********************************************************************/
1325:                	 void			DmaChnSetEventControlFlags(DmaChannel chn, DmaEvCtrlFlags dmaEvCtrl);
1326:                
1327:                
1328:                	/*********************************************************************
1329:                	 * Function:        void DmaChnClrEventControlFlags(DmaChannel chn, DmaEvCtrlFlags dmaEvCtrl)
1330:                	 *
1331:                	 * PreCondition:    chn	- valid DMA channel
1332:                	 *
1333:                	 * Input:			chn			- DMA channel number
1334:                	 * 					dmaEvCtrl	- 	either a DmaEvCtrl structure field, carrying the following info:
1335:                	 * 										- AIRQEN: enable/disable the abort IRQ action
1336:                	 * 										- SIRQEN: enable/disable the start IRQ action
1337:                	 * 										- PATEN: enable/disable the pattern match and abort
1338:                	 * 									or any of the DmaEvCtrlFlags:
1339:                	 * 										DMA_EV_ABORT_IRQ_EN|DMA_EV_START_IRQ_EN|DMA_EV_MATCH_EN
1340:                	 *
1341:                	 *
1342:                	 * Output:          None
1343:                	 *
1344:                	 * Side Effects:    None
1345:                	 *
1346:                	 * Overview:		The function clears the events that start and abort the transfer
1347:                	 * 					for the selected DMA channel.
1348:                	 * 					Multiple flags can be orr-ed together. Any flag that is set in the eFlags will be
1349:                	 * 					disabled for the selected channel, the other channel event flags won't be touched.
1350:                	 *
1351:                	 * Note:            None.
1352:                	 *
1353:                	 * Example:			either:
1354:                	 * 						DmaChnClrEventControlFlags(DMA_CHANNEL2, DMA_EV_MATCH_EN|DMA_EV_START_IRQ_EN);
1355:                	 * 					or:
1356:                	 * 						DmaEvCtrl evCtrl; evCtrl.w=0; evCtrl.PATEN=1; evCtrl.AIRQEN=1;
1357:                	 * 						DmaChnClrEventControlFlags(DMA_CHANNEL2, evCtrl.w);
1358:                	 *
1359:                	 ********************************************************************/
1360:                	 void			DmaChnClrEventControlFlags(DmaChannel chn, DmaEvCtrlFlags dmaEvCtrl);
1361:                
1362:                
1363:                
1364:                	/*********************************************************************
1365:                	 * Function:        void DmaChnWriteEventControlFlags(DmaChannel chn, DmaEvCtrlFlags dmaEvCtrl)
1366:                	 *
1367:                	 * PreCondition:    chn	- valid DMA channel
1368:                	 *
1369:                	 * Input:			chn			- DMA channel number
1370:                	 * 					dmaEvCtrl	- 	either a DmaEvCtrl structure field, carrying the following info:
1371:                	 * 										- AIRQEN: enable/disable the abort IRQ action
1372:                	 * 										- SIRQEN: enable/disable the start IRQ action
1373:                	 * 										- PATEN: enable/disable the pattern match and abort
1374:                	 * 										- CHSIRQ: IRQ number to start the DMA channel transfer
1375:                	 * 										- CHAIRQ: IRQ number to abort the DMA channel transfer
1376:                	 * 									or any of the DmaEvCtrlFlags:
1377:                	 * 										DMA_EV_ABORT_IRQ_EN|DMA_EV_START_IRQ_EN|DMA_EV_MATCH_EN|DMA_EV_START_IRQ(irq)|DMA_EV_ABORT_IRQ(irq)
1378:                	 *
1379:                	 *
1380:                	 * Output:          None
1381:                	 *
1382:                	 * Side Effects:    None
1383:                	 *
1384:                	 * Overview:		The function writes the events that start and abort the transfer
1385:                	 * 					for the selected DMA channel.
1386:                	 *
1387:                	 * Note:            None.
1388:                	 *
1389:                	 * Example:			either:
1390:                	 * 						DmaChnWriteEventControlFlags(DMA_CHANNEL2, DMA_EV_MATCH_EN|DMA_EV_START_IRQ(_UART2_RX_IRQ));
1391:                	 * 					or:
1392:                	 * 						DmaEvCtrl evCtrl; evCtrl.w=0; evCtrl.AIRQEN=1; evCtrl.PATEN=1; evCtrl.CHSIRQ=_UART2_RX_IRQ;
1393:                	 * 						DmaChnWriteEventControlFlags(DMA_CHANNEL2, evCtrl.w);
1394:                	 *
1395:                	 ********************************************************************/
1396:                	 void			DmaChnWriteEventControlFlags(DmaChannel chn, DmaEvCtrlFlags dmaEvCtrl);
1397:                
1398:                
1399:                
1400:                	/*********************************************************************
1401:                	 * Function:        void DmaChnSetEventControl(DmaChannel chn, DmaEvCtrlFlags dmaEvCtrl)
1402:                	 *
1403:                	 * PreCondition:    chn	- valid DMA channel
1404:                	 *
1405:                	 * Input:			chn			- DMA channel number
1406:                	 * 					dmaEvCtrl	- 	either a DmaEvCtrl structure field, carrying the following info:
1407:                	 * 										- AIRQEN: enable/disable the abort IRQ action
1408:                	 * 										- SIRQEN: enable/disable the start IRQ action
1409:                	 * 										- PATEN: enable/disable the pattern match and abort
1410:                	 * 										- CHSIRQ: IRQ number to start the DMA channel transfer
1411:                	 * 										- CHAIRQ: IRQ number to abort the DMA channel transfer
1412:                	 * 									or any of the DmaEvCtrlFlags:
1413:                	 * 										DMA_EV_ABORT_IRQ_EN|DMA_EV_START_IRQ_EN|DMA_EV_MATCH_EN|DMA_EV_START_IRQ(irq)|DMA_EV_ABORT_IRQ(irq)
1414:                	 *
1415:                	 *
1416:                	 * Output:          None
1417:                	 *
1418:                	 * Side Effects:    None
1419:                	 *
1420:                	 * Overview:		The function sets the events that start and abort the transfer
1421:                	 * 					for the selected DMA channel.
1422:                	 * 					Multiple flags can be orr-ed together. Any flag that is set in the eFlags will be
1423:                	 * 					enabled for the selected channel, the other channel event flags won't be touched.
1424:                	 *
1425:                	 * Note:           A shorter name for DmaChnWriteEventControlFlags();
1426:                	 *
1427:                	 * Example:			either:
1428:                	 * 						DmaChnSetEventControl(DMA_CHANNEL2, DMA_EV_MATCH_EN|DMA_EV_START_IRQ(_UART2_RX_IRQ));
1429:                	 * 					or:
1430:                	 * 						DmaEvCtrl evCtrl; evCtrl.w=0; evCtrl.AIRQEN=1; evCtrl.PATEN=1; evCtrl.CHSIRQ=_UART2_RX_IRQ;
1431:                	 * 						DmaChnSetEventControl(DMA_CHANNEL2, evCtrl.w);
1432:                	 *
1433:                	 ********************************************************************/
1434:                	#define			DmaChnSetEventControl(chn, dmaEvCtrl)	DmaChnWriteEventControlFlags(chn, dmaEvCtrl)
1435:                
1436:                
1437:                	/*********************************************************************
1438:                	 * Function:        DmaEvCtrlFlags DmaChnGetEventControl(DmaChannel chn)
1439:                	 *
1440:                	 * PreCondition:    chn	- valid DMA channel
1441:                	 *
1442:                	 * Input:			chn		- DMA channel number
1443:                	 *
1444:                	 * Output:          - 	either a DmaEvCtrl structure field, carrying the following info:
1445:                	 * 							- AIRQEN: enable/disable the abort IRQ action
1446:                	 * 							- SIRQEN: enable/disable the start IRQ action
1447:                	 * 							- PATEN: enable/disable the pattern match and abort
1448:                	 * 							- CHSIRQ: IRQ number to start the DMA channel transfer
1449:                	 * 							- CHAIRQ: IRQ number to abort the DMA channel transfer
1450:                	 * 						or any of the DmaEvCtrlFlags:
1451:                	 * 							DMA_EV_ABORT_IRQ_EN|DMA_EV_START_IRQ_EN|DMA_EV_MATCH_EN|DMA_EV_START_IRQ(irq)|DMA_EV_ABORT_IRQ(irq)
1452:                	 *
1453:                	 *
1454:                	 * Side Effects:    None
1455:                	 *
1456:                	 * Overview:		The function retrieves the events that start and abort the transfer
1457:                	 * 					for the selected DMA channel.
1458:                	 *
1459:                	 * Note:            None.
1460:                	 *
1461:                	 * Example:			either:
1462:                	 * 						DmaEvCtrlFlags evCtrlW=DmaChnGetEventControl(DMA_CHANNEL2); if(evCtrlW&DMA_EV_MATCH_EN) {...}
1463:                	 * 					or:
1464:                	 * 						DmaEvCtrl evCtrl; evCtrl.w=DmaChnGetEventControl(DMA_CHANNEL2); if(evCtrl.PATEN){...}
1465:                	 *
1466:                	 ********************************************************************/
1467:                	 DmaEvCtrlFlags	DmaChnGetEventControl(DmaChannel chn);
1468:                
1469:                
1470:                	/*********************************************************************
1471:                	 * Function:        void DmaChnSetControlFlags(DmaChannel chn, DmaChnCtrlFlags dmaChnCtrl)
1472:                	 *
1473:                	 * PreCondition:    chn	- valid DMA channel
1474:                	 *
1475:                	 * Input:			chn			- DMA channel number
1476:                	 * 					dmaChnCtrl	- 	either a DmaChnCtrl structure field, carrying the following info:
1477:                	 * 										- autoEn: enable/disable the automatic mode
1478:                	 * 										- chainEn: enable/disable channel chaining
1479:                	 * 										- detectEn: enable/disable events detection when channel disabled
1480:                	 * 										- chEn: enable/disable channel functionality
1481:                	 * 										- chainDir:	chain direction: chain to lower(1)/higher(0),pri channel
1482:                	 * 									or any of the DmaChnCtrlFlags flags:
1483:                	 * 										DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN|DMA_CTL_DET_EN|DMA_CTL_CHN_EN|DMA_CTL_CHAIN_DIR
1484:                	 *
1485:                	 * Output:          None
1486:                	 *
1487:                	 * Side Effects:    None
1488:                	 *
1489:                	 * Overview:		The function sets the selected DMA channel control flags:
1490:                	 * 					the chaining or auto mode, and events detection.
1491:                	 * 					Multiple flags can be orr-ed together. Any flag that is set in the dmaChnCtrl will be
1492:                	 * 					set for the selected channel, the other channel control flags won't be touched.
1493:                	 *
1494:                	 * Note:            None.
1495:                	 *
1496:                	 * Example:			either:
1497:                	 * 						DmaChnSetControlFlags(DMA_CHANNEL2, DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN);
1498:                	 * 					or:
1499:                	 * 						DmaChnCtrl chCtrl; chCtrl.w=0; chCtrl.autoEn=1; chCtrl.chainEn=1;
1500:                	 * 						DmaChnSetControlFlags(DMA_CHANNEL2, chCtrl.w);
1501:                	 *
1502:                	 ********************************************************************/
1503:                	 void			DmaChnSetControlFlags(DmaChannel chn, DmaChnCtrlFlags dmaChnCtrl);
1504:                
1505:                	/*********************************************************************
1506:                	 * Function:        void DmaChnClrControlFlags(DmaChannel chn, DmaChnCtrlFlags dmaChnCtrl)
1507:                	 *
1508:                	 * PreCondition:    chn	- valid DMA channel
1509:                	 *
1510:                	 * Input:			chn			- DMA channel number
1511:                	 * 					dmaChnCtrl	- 	either a DmaChnCtrl structure field, carrying the following info:
1512:                	 * 										- autoEn: enable/disable the automatic mode
1513:                	 * 										- chainEn: enable/disable channel chaining
1514:                	 * 										- detectEn: enable/disable events detection when channel disabled
1515:                	 * 										- chEn: enable/disable channel functionality
1516:                	 * 										- chainDir:	chain direction: chain to lower(1)/higher(0),pri channel
1517:                	 * 									or any of the DmaChnCtrlFlags flags:
1518:                	 * 										DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN|DMA_CTL_DET_EN|DMA_CTL_CHN_EN|DMA_CTL_CHAIN_DIR
1519:                	 *
1520:                	 * Output:          None
1521:                	 *
1522:                	 * Side Effects:    None
1523:                	 *
1524:                	 * Overview:		The function clears the selected DMA channel control flags:
1525:                	 * 					the chaining or auto mode and events detection.
1526:                	 * 					Multiple flags can be orr-ed together. Any flag that is set in the dmaChnCtrl will be
1527:                	 * 					cleared for the selected channel, the other channel control flags won't be touched.
1528:                	 *
1529:                	 * Note:            None.
1530:                	 *
1531:                	 * Example:			either:
1532:                	 * 						DmaChnClrControlFlags(DMA_CHANNEL2, DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN);
1533:                	 * 					or:
1534:                	 * 						DmaChnCtrl chCtrl; chCtrl.w=0; chCtrl.autoEn=1; chCtrl.chainEn=1;
1535:                	 * 						DmaChnClrControlFlags(DMA_CHANNEL2, chCtrl.w);
1536:                	 *
1537:                	 ********************************************************************/
1538:                	 void			DmaChnClrControlFlags(DmaChannel chn, DmaChnCtrlFlags dmaChnCtrl);
1539:                
1540:                	/*********************************************************************
1541:                	 * Function:        void DmaChnWriteControlFlags(DmaChannel chn, DmaChnCtrlFlags dmaChnCtrl)
1542:                	 *
1543:                	 * PreCondition:    chn	- valid DMA channel
1544:                	 *
1545:                	 * Input:			chn			- DMA channel number
1546:                	 * 					dmaChnCtrl	- 	either a DmaChnCtrl structure field, carrying the following info:
1547:                	 * 										- chPri: channel priority 0-3
1548:                	 * 										- autoEn: enable/disable the automatic mode
1549:                	 * 										- chainEn: enable/disable channel chaining
1550:                	 * 										- detectEn: enable/disable events detection when channel disabled
1551:                	 * 										- chEn: enable/disable channel functionality
1552:                	 * 										- chainDir:	chain direction: chain to lower(1)/higher(0),pri channel
1553:                	 * 									or any of the DmaChnCtrlFlags flags:
1554:                	 * 										DMA_CTL_PRI(pri)|DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN|DMA_CTL_DET_EN|DMA_CTL_CHN_EN|DMA_CTL_CHAIN_DIR
1555:                	 *
1556:                	 * Output:          None
1557:                	 *
1558:                	 * Side Effects:    None
1559:                	 *
1560:                	 * Overview:		The function enables/disables the selected DMA channel and also sets
1561:                	 * 					the channel priority, chaining mode or auto and events detection.
1562:                	 *
1563:                	 * Note:            None.
1564:                	 *
1565:                	 * Example:			either:
1566:                	 * 						DmaChnWriteControlFlags(DMA_CHANNEL2, DMA_CTL_PRI(DMA_CHN_PRI2)|DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN);
1567:                	 * 					or:
1568:                	 * 						DmaChnCtrl chCtrl; chCtrl.w=0; chCtrl.chPri=DMA_CHN_PRI2; chCtrl.autoEn=1; chCtrl.chainEn=1;
1569:                	 * 						DmaChnWriteControlFlags(DMA_CHANNEL2, chCtrl.w);
1570:                	 *
1571:                	 ********************************************************************/
1572:                	 void			DmaChnWriteControlFlags(DmaChannel chn, DmaChnCtrlFlags dmaChnCtrl);
1573:                
1574:                	/*********************************************************************
1575:                	 * Function:        void DmaChnSetControl(DmaChannel chn, DmaChnCtrlFlags dmaChnCtrl)
1576:                	 *
1577:                	 * PreCondition:    chn	- valid DMA channel
1578:                	 *
1579:                	 * Input:	    chn		- DMA channel number
1580:                	 *                  dmaChnCtrl	- 	either a DmaChnCtrl structure field, carrying the following info:
1581:                	 * 						- chPri: channel priority 0-3
1582:                	 * 						- autoEn: enable/disable the automatic mode
1583:                	 * 						- chainEn: enable/disable channel chaining
1584:                	 * 						- detectEn: enable/disable events detection when channel disabled
1585:                	 * 						- chEn: enable/disable channel functionality
1586:                	 * 						- chainDir:	chain direction: chain to lower(1)/higher(0),pri channel
1587:                	 * 					or any of the DmaChnCtrlFlags flags:
1588:                	 * 						DMA_CTL_PRI(pri)|DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN|DMA_CTL_DET_EN|DMA_CTL_CHN_EN|DMA_CTL_CHAIN_DIR
1589:                	 *
1590:                	 * Output:          None
1591:                	 *
1592:                	 * Side Effects:    None
1593:                	 *
1594:                	 * Overview:        The function enables/disables the selected DMA channel and also sets
1595:                	 * 					the channel priority, chaining mode or auto and events detection.
1596:                	 *
1597:                	 * Note:            Another name ( backward compatible) for DmaChnWriteControlFlags().
1598:                	 *
1599:                	 * Example:         either:
1600:                	 *                      DmaChnSetControl(DMA_CHANNEL2, DMA_CTL_PRI(DMA_CHN_PRI2)|DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN);
1601:                	 *                  or:
1602:                	 *                     	DmaChnCtrl chCtrl; chCtrl.w=0; chCtrl.chPri=DMA_CHN_PRI2; chCtrl.autoEn=1; chCtrl.chainEn=1;
1603:                	 * 			DmaChnSetControl(DMA_CHANNEL2, chCtrl.w);
1604:                	 *
1605:                	 ********************************************************************/
1606:                #define		DmaChnSetControl(chn, dmaChnCtrl)	DmaChnWriteControlFlags(chn, dmaChnCtrl)
1607:                
1608:                	/*********************************************************************
1609:                	 * Function:        DmaChnCtrlFlags DmaChnGetControlFlags(DmaChannel chn)
1610:                	 *
1611:                	 * PreCondition:    chn	- valid DMA channel
1612:                	 *
1613:                	 * Input:			chn			- DMA channel number
1614:                	 *
1615:                	 * Output:          - either a DmaChnCtrl structure field, carrying the following info:
1616:                	 * 							- chPri: channel priority 0-3
1617:                	 * 							- autoEn: enable/disable the automatic mode
1618:                	 * 							- chainEn: enable/disable channel chaining
1619:                	 * 							- detectEn: enable/disable events detection when channel disabled
1620:                	 * 							- chEn: enable/disable channel functionality
1621:                	 * 							- chainDir:	chain direction: chain to lower(1)/higher(0),pri channel
1622:                	 *						or any of the DmaChnCtrlFlags flags:
1623:                	 *							DMA_CTL_PRI(pri)|DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN|DMA_CTL_DET_EN|DMA_CTL_CHN_EN|DMA_CTL_CHAIN_DIR
1624:                	 *
1625:                	 * Side Effects:    None
1626:                	 *
1627:                	 * Overview:		The function retrieves the current control settings for the selected DMA channel,
1628:                	 * 					including the channel enable/disable status, the channel priority,
1629:                	 * 					chaining mode, auto mode and events detection.
1630:                	 *
1631:                	 * Note:            None.
1632:                	 *
1633:                	 * Example:			either:
1634:                	 * 						DmaChnCtrlFlags ctrl=DmaChnGetControlFlags(DMA_CHANNEL2); if(ctrl&DMA_CTL_AUTO_EN) {...}
1635:                	 * 					or:
1636:                	 * 						DmaChnCtrl chnCtrl; chnCtrl.w=DmaChnGetControlFlags(DMA_CHANNEL2); if(chnCtrl.autoEn) {...}
1637:                	 *
1638:                	 ********************************************************************/
1639:                	 DmaChnCtrlFlags	DmaChnGetControlFlags(DmaChannel chn);
1640:                
1641:                
1642:                	/*********************************************************************
1643:                	 * Function:        int DmaChnGetEvDetect(DmaChannel chn)
1644:                	 *
1645:                	 * PreCondition:    chn	- valid DMA channel
1646:                	 *
1647:                	 * Input:			chn		- DMA channel number
1648:                	 *
1649:                	 * Output:          TRUE if an DMA event was detected, FALSE otherwise.
1650:                	 *
1651:                	 * Side Effects:    None
1652:                	 *
1653:                	 * Overview:		The function returns the current event detection for the selected DMA channel.
1654:                	 *
1655:                	 * Note:            None.
1656:                	 *
1657:                	 * Example:			int evDetect=DmaChnGetEvDetect(DMA_CHANNEL2);
1658:                	 *
1659:                	 ********************************************************************/
1660:                	 int			DmaChnGetEvDetect(DmaChannel chn);
1661:                
1662:                	/*********************************************************************
1663:                	 * Function:        void DmaChnGetTxfer(DmaChannel chn, DmaTxferCtrl* pTxCtrl, int mapToK0)
1664:                	 *
1665:                	 * PreCondition:    chn		- valid DMA channel
1666:                	 * 					pTxCtrl	- valid pointer
1667:                	 *
1668:                	 * Input:			chn			- DMA channel number
1669:                	 * 					pTxCtrl		- pointer to a DmaTxferCtrl that will carry the following info:
1670:                	 * 								- vSrcAdd: source of the DMA transfer
1671:                	 * 								- vDstAdd: destination of the DMA transfer
1672:                	 * 								- srcSize: source buffer size, 1 to DmaGetMaxTxferSize() bytes, wrapped arround
1673:                	 * 								- dstSize: destination buffer size, 1 to DmaGetMaxTxferSize() bytes, wrapped around
1674:                	 * 								- cellSize: cell transfer size, 1 to DmaGetMaxTxferSize() bytes.
1675:                	 *					mapToK0		- if TRUE, a Kernel address is mapped to KSeg0, else KSeg1.
1676:                	 *
1677:                	 * Output:          None
1678:                	 *
1679:                	 * Side Effects:    None
1680:                	 *
1681:                	 * Overview:		The function retrieves the transfer characteristics for a DMA channel transfer:
1682:                	 * 					the source and the destination addresses.
1683:                	 * 					It also retrieves the source and destination lengths
1684:                	 * 					and the number of bytes	transferred per event.
1685:                	 *
1686:                	 * Note:            None
1687:                	 *
1688:                	 * Example:			DmaTxferCtrl txCtl; DmaChnGetTxfer(DMA_CHANNEL2, &txCtl, FALSE);
1689:                	 ********************************************************************/
1690:                	 void			DmaChnGetTxfer(DmaChannel chn, DmaTxferCtrl* pTxCtrl, int mapToK0);
1691:                
1692:                	// Low level CRC functions
1693:                
1694:                	/*********************************************************************
1695:                	 * Function:        void DmaCrcEnable(int enable)
1696:                	 *
1697:                	 * PreCondition:    None
1698:                	 *
1699:                	 * Input:           enable - boolean to enable/disable the CRC module
1700:                	 *
1701:                	 * Output:          None
1702:                	 *
1703:                	 * Side Effects:    None
1704:                	 *
1705:                	 * Overview:        The function enables the CRC module functionality and the attached DMA channel transfers are routed to the CRC module.
1706:                	 *
1707:                	 * Note:            The CRC module should be properly configured before enabled.
1708:                	 *
1709:                	 * Example:         CrcEnable(1);
1710:                	 ********************************************************************/
1711:                	extern __inline__ void __attribute__((always_inline)) DmaCrcEnable(int enable)
1712:                	{
1713:                		if(enable)
1714:                		{
1715:                			DCRCCONSET=_DCRCCON_CRCEN_MASK;
1716:                		}
1717:                		else
1718:                		{
1719:                			DCRCCONCLR=_DCRCCON_CRCEN_MASK;
1720:                		}
1721:                	}
1722:                
1723:                
1724:                
1725:                	/*********************************************************************
1726:                	 * Function:        int DmaCrcGetEnable(void)
1727:                	 *
1728:                	 * PreCondition:    None
1729:                	 *
1730:                	 * Input:			None
1731:                	 *
1732:                	 * Output:          TRUE, if the CRC module is enabled
1733:                	 * 					FALSE otherwise
1734:                	 *
1735:                	 * Side Effects:    None
1736:                	 *
1737:                	 * Overview:		The function returns the CRC module enabling status.
1738:                	 *
1739:                	 * Note:            None
1740:                	 *
1741:                	 * Example:			int isCrcEnabled=DmaCrcGetEnable();
1742:                	 ********************************************************************/
1743:                	extern __inline__ int __attribute__((always_inline)) DmaCrcGetEnable(void)
1744:                	{
1745:                		return	DCRCCONbits.CRCEN!=0;
1746:                	}
1747:                
1748:                	
1749:                	/*********************************************************************
1750:                	 * Function:        void DmaCrcAppendModeEnable(int enable)
1751:                	 *
1752:                	 * PreCondition:    None
1753:                	 *
1754:                	 * Input:           enable - boolean to enable/disable the append mode
1755:                	 *
1756:                	 * Output:          None
1757:                	 *
1758:                	 * Side Effects:    None
1759:                	 *
1760:                	 * Overview:		The function enables the CRC append mode. In this mode, the attached DMA channel reads
1761:                	 * 					the source data but does not write it to the destination address. The data it's just passed
1762:                	 * 					to the CRC generator for CRC calculation.
1763:                	 * 					When the block transfer is completed, the CRC result is written to the
1764:                	 * 					DMA channel destination address.
1765:                	 *
1766:                	 * Note:            The CRC module should be properly configured before enabled.
1767:                	 *
1768:                	 * Example:         DmaCrcAppendModeEnable(1);
1769:                	 ********************************************************************/
1770:                	extern __inline__ void __attribute__((always_inline)) DmaCrcAppendModeEnable(int enable)
1771:                	{
1772:                		if(enable)
1773:                		{
1774:                			DCRCCONSET=_DCRCCON_CRCAPP_MASK;
1775:                		}
1776:                		else
1777:                		{
1778:                			DCRCCONCLR=_DCRCCON_CRCAPP_MASK;
1779:                		}
1780:                	}
1781:                
1782:                
1783:                	/*********************************************************************
1784:                	 * Function:        int DmaCrcGetAppendMode(void)
1785:                	 *
1786:                	 * PreCondition:    None
1787:                	 *
1788:                	 * Input:           None
1789:                	 *
1790:                	 * Output:          TRUE, if the CRC append mode is enabled
1791:                	 * 					FALSE otherwise
1792:                	 *
1793:                	 * Side Effects:    None
1794:                	 *
1795:                	 * Overview:		The function returns the CRC module enabling status.
1796:                	 *
1797:                	 * Note:            None
1798:                	 *
1799:                	 * Example:			int isAppendEnabled=DmaCrcGetAppendMode();
1800:                	 ********************************************************************/
1801:                	extern __inline__ int __attribute__((always_inline)) DmaCrcGetAppendMode(void)
1802:                	{
1803:                		return DCRCCONbits.CRCAPP!=0;
1804:                	}
1805:                
1806:                	/*********************************************************************
1807:                	 * Function:        void DmaCrcSetAttach(DmaChannel chn)
1808:                	 *
1809:                	 * PreCondition:    chn		- valid DMA channel
1810:                	 *
1811:                	 * Input:			chn	- the DMA channel to be attached to the CRC module (the DMA channel transfers will be routed to the CRC module)
1812:                	 *
1813:                	 * Output:          None
1814:                	 *
1815:                	 * Side Effects:    None
1816:                	 *
1817:                	 * Overview:		The function attaches a DMA channel to the CRC module.
1818:                	 *
1819:                	 * Note:            None
1820:                	 *
1821:                	 * Example:			DmaCrcSetAttach(DMA_CHANNEL0);
1822:                	 ********************************************************************/
1823:                	extern __inline__ void __attribute__((always_inline)) DmaCrcSetAttach(DmaChannel chn)
1824:                	{
1825:                		DCRCCONCLR=_DCRCCON_CRCCH_MASK;
1826:                		DCRCCONSET=chn;
1827:                	}
1828:                		
1829:                	/*********************************************************************
1830:                	 * Function:        DmaChannel DmaCrcGetAttach(void)
1831:                	 *
1832:                	 * PreCondition:    None
1833:                	 *
1834:                	 * Input:			None
1835:                	 *
1836:                	 * Output:          the DMA channel that is currently attached to the CRC module
1837:                	 *
1838:                	 * Side Effects:    None
1839:                	 *
1840:                	 * Overview:		The function returns the DMA channel number that is currently attached to the CRC module.
1841:                	 *
1842:                	 * Note:            None
1843:                	 *
1844:                	 * Example:			DmaChannel chn=DmaCrcGetAttach();
1845:                	 ********************************************************************/
1846:                	extern __inline__ DmaChannel __attribute__((always_inline)) DmaCrcGetAttach(void)
1847:                	{
1848:                		return	(DmaChannel)DCRCCONbits.CRCCH;
1849:                	}
1850:                
1851:                
1852:                	/*********************************************************************
1853:                	 * Function:        void DmaCrcSetPLen(int pLen)
1854:                	 *
1855:                	 * PreCondition:    pLen	- valid polynomial length within 1-16
1856:                	 *
1857:                	 * Input:			pLen	- the length of the CRC generator polynomial
1858:                	 *
1859:                	 * Output:          None
1860:                	 *
1861:                	 * Side Effects:    None
1862:                	 *
1863:                	 * Overview:		The length of the CRC generator polynomial is set as being pLen;
1864:                	 *
1865:                	 * Note:            None
1866:                	 *
1867:                	 * Example:         DmaCrcSetPLen(16);
1868:                	 ********************************************************************/
1869:                	extern __inline__ void __attribute__((always_inline)) DmaCrcSetPLen(int pLen)
1870:                	{
1871:                		DCRCCONCLR=_DCRCCON_PLEN_MASK;
1872:                		DCRCCONSET=(pLen)-1;
1873:                	}
1874:                		
1875:                	/*********************************************************************
1876:                	 * Function:        int DmaCrcGetPLen(void)
1877:                	 *
1878:                	 * PreCondition:    None
1879:                	 *
1880:                	 * Input:           None
1881:                	 *
1882:                	 * Output:          the length of the CRC generator polynomial
1883:                	 *
1884:                	 * Side Effects:    None
1885:                	 *
1886:                	 * Overview:        The function returns the current length of the CRC generator polynomial.
1887:                	 *                  It's always a number between 1 and 16.
1888:                	 *
1889:                	 * Note:            None
1890:                	 *
1891:                	 * Example:         int polyLen=DmaCrcGetPLen();
1892:                	 ********************************************************************/
1893:                	extern __inline__ int __attribute__((always_inline)) DmaCrcGetPLen(void)
1894:                	{
1895:                		return	DCRCCONbits.PLEN+1; 
1896:                	}
1897:                	
1898:                
1899:                	/*********************************************************************
1900:                	 * Function:        void DmaCrcSetShiftFeedback(unsigned int feedback)
1901:                	 *
1902:                	 * PreCondition:    None
1903:                	 *
1904:                	 * Input:			feedback	- the layout of the CRC generator
1905:                	 *
1906:                	 * Output:          None
1907:                	 *
1908:                	 * Side Effects:    None
1909:                	 *
1910:                	 * Overview:        The function sets the layout of the shift stages that take place in the CRC generation.
1911:                	 *                  Setting a bit to 1 enables the XOR input from the MSb (pLen bit) to the selected stage in the shift register.
1912:                	 *                  If bit is cleared, the selected shift stage gets data directly from the previous stage in the shift register.
1913:                	 *
1914:                	 * Note:            Bit 0 of the generator polynomial is always XOR'ed.
1915:                	 *
1916:                	 * Example:         DmaCrcSetShiftFeedback(0x8005);
1917:                	 ********************************************************************/
1918:                	extern __inline__ void __attribute__((always_inline)) DmaCrcSetShiftFeedback(unsigned int feedback)
1919:                	{
1920:                		DCRCXOR=feedback;
1921:                	}
1922:                
1923:                		
1924:                	/*********************************************************************
1925:                	 * Function:        unsigned int DmaCrcGetShiftFeedback(void)
1926:                	 *
1927:                	 * PreCondition:    None
1928:                	 *
1929:                	 * Input:			None
1930:                	 *
1931:                	 * Output:          the current layout of the CRC generator
1932:                	 *
1933:                	 * Side Effects:    None
1934:                	 *
1935:                	 * Overview:		The function returns the layout of the shift stages that take place in the CRC generation.
1936:                	 * 					A bit set to 1 enables the XOR input from the MSb (pLen bit) to the selected stage in the shift register.
1937:                	 * 					If a bit is cleared, the selected shift stage gets data directly from the previous stage in the shift register.
1938:                	 *
1939:                	 * Note:            Bit 0 of the generator polynomial is always XOR'ed.
1940:                	 *
1941:                	 * Example:         int feedback=DmaCrcGetShiftFeedback();
1942:                	 ********************************************************************/
1943:                	extern __inline__ unsigned int __attribute__((always_inline)) DmaCrcGetShiftFeedback(void)
1944:                	{
1945:                		return DCRCXOR;
1946:                	}
1947:                
1948:                	/*********************************************************************
1949:                	 * Function:        void DmaCrcSetSeed(unsigned int seed)
1950:                	 *
1951:                	 * PreCondition:    None
1952:                	 *
1953:                	 * Input:			seed	- the initial seed of the CRC generator
1954:                	 *
1955:                	 * Output:          None
1956:                	 *
1957:                	 * Side Effects:    None
1958:                	 *
1959:                	 * Overview:		The function sets the seed of the CRC generator. This is the initial data present in the
1960:                	 * 					CRC shift register before the CRC calculation begins.
1961:                	 *
1962:                	 * Note:            None
1963:                	 *
1964:                	 * Example:			DmaCrcSetSeed(0xffff);
1965:                	 ********************************************************************/
1966:                	extern __inline__ void __attribute__((always_inline)) DmaCrcSetSeed(unsigned int seed)
1967:                	{
1968:                		DCRCDATA=seed;
1969:                	}
1970:                		
1971:                	/*********************************************************************
1972:                	 * Function:        unsigned int DmaCrcGetValue(void)
1973:                	 *
1974:                	 * PreCondition:    None
1975:                	 *
1976:                	 * Input:			None
1977:                	 *
1978:                	 * Output:          the current value of the CRC generator
1979:                	 *
1980:                	 * Side Effects:    None
1981:                	 *
1982:                	 * Overview:		The function returns the current value of the CRC generator.
1983:                	 *
1984:                	 * Note:            Only the remainder bits (0 to pLen-1) are significant, the rest should be ignored.
1985:                	 *
1986:                	 * Example:		unsigned int calcCrc=DmaCrcGetValue();
1987:                	 ********************************************************************/
1988:                	extern __inline__ unsigned int __attribute__((always_inline)) DmaCrcGetValue(void)
1989:                	{
1990:                		return DCRCDATA;
1991:                	}
1992:                
1993:                
1994:                	// Channel test/debug and special functions
1995:                
1996:                	/*********************************************************************
1997:                	 * Function:        void DmaChnSetEvFlags(DmaChannel chn, DmaEvFlags eFlags)
1998:                	 *
1999:                	 * PreCondition:    chn	- valid DMA channel
2000:                	 *
2001:                	 * Input:			chn		- DMA channel number
2002:                	 * 					eFlags	- event flags with the following significance:
2003:                	 * 								- DMA_EV_ERR: address error event
2004:                	 * 								- DMA_EV_ABORT: transfer abort event
2005:                	 * 								- DMA_EV_CELL_DONE: cell transfer complete event
2006:                	 * 								- DMA_EV_BLOCK_DONE: block transfer complete event
2007:                	 * 								- DMA_EV_DST_HALF: destination half event
2008:                	 * 								- DMA_EV_DST_FULL: destination full event
2009:                	 * 								- DMA_EV_SRC_HALF: source half event
2010:                	 * 								- DMA_EV_SRC_FULL: source full event
2011:                	 * 								- DMA_EV_ALL_EVNTS: all of the above flags
2012:                	 *
2013:                	 * Output:          None
2014:                	 *
2015:                	 * Side Effects:    None
2016:                	 *
2017:                	 * Overview:		The function sets the event flags for the selected DMA channel.
2018:                	 * 					Multiple flags can be orr-ed together. Any flag that is set in the eFlags will be
2019:                	 * 					set for the selected channel, the other channel event flags won't be touched.
2020:                	 *
2021:                	 * Note:            This is intended as a channel test function.
2022:                	 *
2023:                	 * Example:			DmaChnSetEvFlags(DMA_CHANNEL2, DMA_EV_ERR|DMA_EV_ABORT|DMA_EV_BLOCK_DONE|DMA_EV_SRC_FULL);
2024:                	 ********************************************************************/
2025:                	 void			DmaChnSetEvFlags(DmaChannel chn, DmaEvFlags eFlags);
2026:                
2027:                	/*********************************************************************
2028:                	 * Function:        void DmaChnWriteEvFlags(DmaChannel chn, DmaEvFlags eFlags)
2029:                	 *
2030:                	 * PreCondition:    chn	- valid DMA channel
2031:                	 *
2032:                	 * Input:			chn		- DMA channel number
2033:                	 * 					eFlags	- event flags with the following significance:
2034:                	 * 								- DMA_EV_ERR: address error event
2035:                	 * 								- DMA_EV_ABORT: transfer abort event
2036:                	 * 								- DMA_EV_CELL_DONE: cell transfer complete event
2037:                	 * 								- DMA_EV_BLOCK_DONE: block transfer complete event
2038:                	 * 								- DMA_EV_DST_HALF: destination half event
2039:                	 * 								- DMA_EV_DST_FULL: destination full event
2040:                	 * 								- DMA_EV_SRC_HALF: source half event
2041:                	 * 								- DMA_EV_SRC_FULL: source full event
2042:                	 * 								- DMA_EV_ALL_EVNTS: all of the above flags
2043:                	 *
2044:                	 * Output:          None
2045:                	 *
2046:                	 * Side Effects:    None
2047:                	 *
2048:                	 * Overview:		The function writes the event flags for the selected DMA channel.
2049:                	 * 					The channel event flags are forced to the eFlags value.
2050:                	 *
2051:                	 * Note:            This is intended as a channel test function.
2052:                	 *
2053:                	 * Example:			DmaChnWriteEvFlags(DMA_CHANNEL2, DMA_EV_ERR|DMA_EV_ABORT|DMA_EV_BLOCK_DONE|DMA_EV_SRC_FULL);
2054:                	 ********************************************************************/
2055:                	 void			DmaChnWriteEvFlags(DmaChannel chn, DmaEvFlags eFlags);
2056:                
2057:                
2058:                	/********************************************************************
2059:                	 * Include legacy DMA functions
2060:                	 * New projects should not use them!
2061:                	 * Note that interrupt functions are no longer provided.
2062:                	 * The functions in the int.h should be used instead.
2063:                	 ********************************************************************/
2064:                	#ifndef _PLIB_DISABLE_LEGACY
2065:                		#include <peripheral/legacy/dma_legacy.h>
2066:                	#endif
2067:                
2068:                	 
2069:                #else
2070:                	#undef _DMA_CHANNELS		// no DMA channels
2071:                #endif	// _DMAC0
2072:                
2073:                #endif /*_DMA_H_*/
2074:                
2075:                
---  C:/Users/Diego/Documents/GitHub/pic32webFREERtos/Pic32Web.X/src/tcpip/src/UDP.c  -------------------
1:                   /*********************************************************************
2:                    *
3:                    *	User Datagram Protocol (UDP) Communications Layer
4:                    *  Module for Microchip TCP/IP Stack
5:                    *	 -Provides unreliable, minimum latency transport of application 
6:                    *    datagram (packet) oriented data
7:                    *	 -Reference: RFC 768
8:                    *
9:                    *********************************************************************
10:                   * FileName:        UDP.c
11:                   * Dependencies:    IP, Ethernet (ENC28J60.c or ETH97J60.c)
12:                   * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32
13:                   * Compiler:        Microchip C32 v1.05 or higher
14:                   *					Microchip C30 v3.12 or higher
15:                   *					Microchip C18 v3.30 or higher
16:                   *					HI-TECH PICC-18 PRO 9.63PL2 or higher
17:                   * Company:         Microchip Technology, Inc.
18:                   *
19:                   * Software License Agreement
20:                   *
21:                   * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights
22:                   * reserved.
23:                   *
24:                   * Microchip licenses to you the right to use, modify, copy, and
25:                   * distribute:
26:                   * (i)  the Software when embedded on a Microchip microcontroller or
27:                   *      digital signal controller product ("Device") which is
28:                   *      integrated into Licensee's product; or
29:                   * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h,
30:                   *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device
31:                   *		used in conjunction with a Microchip ethernet controller for
32:                   *		the sole purpose of interfacing with the ethernet controller.
33:                   *
34:                   * You should refer to the license agreement accompanying this
35:                   * Software for additional information regarding your rights and
36:                   * obligations.
37:                   *
38:                   * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT
39:                   * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT
40:                   * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A
41:                   * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL
42:                   * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR
43:                   * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF
44:                   * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS
45:                   * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE
46:                   * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER
47:                   * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT
48:                   * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE.
49:                   *
50:                   *
51:                   * Author               Date    Comment
52:                   *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
53:                   * Nilesh Rajbharti     3/19/01  Original        (Rev 1.0)
54:                   * Nilesh Rajbharti     2/26/03  Fixed UDPGet and UDPProcess bugs
55:                   *                               as discovered and fixed by John Owen
56:                   *                               of Powerwave.
57:                   *                               1. UDPGet would return FALSE on last good byte
58:                   *                               2. UDPProcess was incorrectly calculating length.
59:                   * Nilesh Rajbharti     5/19/03  Added bFirstRead flag similar to TCP
60:                   *                               to detect very first UDPGet and
61:                   *                               reset MAC Rx pointer to begining of
62:                   *                               UDP data area.  This would ensure that
63:                   *                               if UDP socket has pending Rx data and
64:                   *                               another module resets MAC Rx pointer,
65:                   *                               next UDP socket Get would get correct
66:                   *                               data.
67:                   * Robert Sloan (RSS)    5/29/03 Improved FindMatchingSocket()
68:                   * Nilesh Rajbharti     12/2/03  Added UDPChecksum logic in UDPProcess()
69:                   * Nilesh Rajbharti     12/5/03  Modified UDPProcess() and FindMatchingSocket()
70:                   *                               to include localIP as new parameter.
71:                   *                               This corrects pseudo header checksum
72:                   *                               logic in UDPProcess().
73:                   *                               It also corrects broadcast packet
74:                   *                               matching correct in FindMatchingSocket().
75:                   * Howard Schlunder		1/16/06	 Fixed an imporbable RX checksum bug 
76:                   *								 when using a Microchip Ethernet controller)
77:                   * Howard Schlunder		6/02/06	 Fixed a bug where all RXed UDP packets 
78:                   *								 without a checksum (0x0000) were thrown
79:                   *								 away.  No checksum is legal in UDP.
80:                   * Howard Schlunder		8/10/06	 Fixed a bug where UDP sockets would 
81:                   *								 unintentionally keep the remote MAC 
82:                   *								 address cached, even after calling 
83:                   *								 UDPInit(), UDPClose(), or reseting 
84:                   *								 the part without clearing all the 
85:                   *								 PIC memory.
86:                   ********************************************************************/
87:                  #define __UDP_C
88:                  
89:                  #include "TCPIP Stack/TCPIP.h"
90:                  
91:                  #if defined(STACK_USE_UDP)
92:                  
93:                  /****************************************************************************
94:                    Section:
95:                  	Configuration Parameters
96:                    ***************************************************************************/
97:                  
98:                  // First port number for randomized local port number selection
99:                  #define LOCAL_UDP_PORT_START_NUMBER (4096u)
100:                 
101:                 // Last port number for randomized local port number selection
102:                 #define LOCAL_UDP_PORT_END_NUMBER   (8192u)
103:                 
104:                 /****************************************************************************
105:                   Section:
106:                 	UDP Global Variables
107:                   ***************************************************************************/
108:                 
109:                 // Stores an array of information pertaining to each UDP socket
110:                 UDP_SOCKET_INFO		UDPSocketInfo[MAX_UDP_SOCKETS];
111:                 
112:                 // Indicates which UDP socket is currently active
113:                 UDP_SOCKET			activeUDPSocket;
114:                 
115:                 WORD UDPTxCount;	// Number of bytes written to this UDP segment
116:                 WORD UDPRxCount;	// Number of bytes read from this UDP segment
117:                 static UDP_SOCKET	LastPutSocket = INVALID_UDP_SOCKET;	// Indicates the last socket to which data was written
118:                 static WORD wPutOffset;		// Offset from beginning of payload where data is to be written.
119:                 static WORD wGetOffset;		// Offset from beginning of payload from where data is to be read.
120:                 
121:                 // Stores various flags for the UDP module
122:                 static struct
123:                 {
124:                 	unsigned char bFirstRead : 1;		// No data has been read from this segment yet
125:                 	unsigned char bWasDiscarded : 1;	// The data in this segment has been discarded
126:                 } Flags;
127:                 
128:                 // Indicates which socket has currently received data for this loop
129:                 static UDP_SOCKET SocketWithRxData = INVALID_UDP_SOCKET;
130:                 
131:                 /****************************************************************************
132:                   Section:
133:                 	Function Prototypes
134:                   ***************************************************************************/
135:                 
136:                 static UDP_SOCKET FindMatchingSocket(UDP_HEADER *h, NODE_INFO *remoteNode,
137:                                                     IP_ADDR *localIP);
138:                 
139:                 /****************************************************************************
140:                   Section:
141:                 	Connection Management Functions
142:                   ***************************************************************************/
143:                 
144:                 /*****************************************************************************
145:                   Function:
146:                 	void UDPInit(void)
147:                 
148:                   Summary:
149:                 	Initializes the UDP module.
150:                 
151:                   Description:
152:                 	Initializes the UDP module.  This function initializes all the UDP 
153:                 	sockets to the closed state.
154:                 
155:                   Precondition:
156:                 	None
157:                 
158:                   Parameters:
159:                 	None
160:                 
161:                   Returns:
162:                   	None
163:                   	
164:                   Remarks:
165:                 	This function is called only one during lifetime of the application.
166:                   ***************************************************************************/
167:                 void UDPInit(void)
168:                 {
9D028304  27BDFFE0   ADDIU SP, SP, -32
9D028308  AFBF001C   SW RA, 28(SP)
9D02830C  AFBE0018   SW S8, 24(SP)
9D028310  03A0F021   ADDU S8, SP, ZERO
169:                     UDP_SOCKET s;
170:                 
171:                     for ( s = 0; s < MAX_UDP_SOCKETS; s++ )
9D028314  A3C00010   SB ZERO, 16(S8)
9D028318  0B40A0CF   J 0x9D02833C
9D02831C  00000000   NOP
9D028330  93C20010   LBU V0, 16(S8)
9D028334  24420001   ADDIU V0, V0, 1
9D028338  A3C20010   SB V0, 16(S8)
9D02833C  93C20010   LBU V0, 16(S8)
9D028340  2C420008   SLTIU V0, V0, 8
9D028344  1440FFF6   BNE V0, ZERO, 0x9D028320
9D028348  00000000   NOP
172:                     {
173:                 		UDPClose(s);
9D028320  93C20010   LBU V0, 16(S8)
9D028324  00402021   ADDU A0, V0, ZERO
9D028328  0F40A2B9   JAL UDPClose
9D02832C  00000000   NOP
174:                     }
175:                 	Flags.bWasDiscarded = 1;
9D02834C  938281B4   LBU V0, -32332(GP)
9D028350  24030001   ADDIU V1, ZERO, 1
9D028354  7C620844   INS V0, V1, 1, 1
9D028358  A38281B4   SB V0, -32332(GP)
176:                 }
9D02835C  03C0E821   ADDU SP, S8, ZERO
9D028360  8FBF001C   LW RA, 28(SP)
9D028364  8FBE0018   LW S8, 24(SP)
9D028368  27BD0020   ADDIU SP, SP, 32
9D02836C  03E00008   JR RA
9D028370  00000000   NOP
177:                 
178:                 
179:                 /*****************************************************************************
180:                 Function:
181:                 	UDP_SOCKET UDPOpenEx(DWORD remoteHost, BYTE remoteHostType, UDP_PORT localPort,
182:                 	UDP_PORT remotePort)
183:                 
184:                  Summary:
185:                     Opens a UDP socket for a client.
186:                 
187:                  Description:
188:                     Provides a unified method for opening UDP sockets. This function can open both client and 
189:                     server   sockets. For client sockets, it can accept a host name string to query in DNS, an IP
190:                     address as a string, an IP address in binary form, or a previously resolved NODE_INFO 
191:                     structure containing the remote IP address and associated MAC address. When a host name
192:                     or IP address only is provided, UDP module will internally perform the necessary DNSResolve
193:                     and/or ARP resolution steps before reporting that the UDP socket is connected (via a call to
194:                     UDPISOpen returning TRUE). Server sockets ignore this destination parameter and listen 
195:                     only on the indicated port.	Sockets are statically allocated on boot, but can be claimed with
196:                     this function and freed using UDPClose .
197:                 
198:                 Conditions:
199:                 UDPInit should be called.
200:                 
201:                 Input:
202:                     remoteHost -     Pointer to remote node info (MAC and IP address) for this connection.  
203:                     If this is a     server socket (receives the first packet) or the destination is the broadcast 
204:                     address, then this parameter should be NULL. For client sockets only. Provide a pointer to
205:                     a null-terminated string of the remote host name (ex\:"www.microchip.com" or 
206:                     "192.168.1.123"), a literal destination IP address (ex\: 0x7B01A8C0 or an IP_ADDR data type),
207:                     or a pointer to a NODE_INFO structure with the remote IP address and remote node or gateway
208:                     MAC address specified, If a string is provided.
209:                     
210:                     remoteHostType - Any one of the following flags to identify the meaning of the remoteHost parameter:
211:                     	- UDP_OPEN_SERVER   = Open a server socket and ignore the remoteHost parameter. 
212:                     		(e.g. - SNMP agent, DHCP server, Announce)
213:                     	- UDP_OPEN_IP_ADDRESS = Open a client socket and connect it to a remote IP address.
214:                     		Ex: 0x7B01A8C0 for 192.168.1.123 (DWORD type). Note that the byte ordering is big endian.
215:                     	- UDP_OPEN_NODE_INFO = Open a client socket and connect it to a remote IP and MAC 
216:                     		addresses pair stored in a NODE_INFO structure.
217:                      	- UDP_OPEN_RAM_HOST = Open a client socket and connect it to a remote host who's 
218:                      		name is stored as a null terminated string in a RAM array. Ex:"www.microchip.com" or
219:                      		"192.168.0.123"
220:                      	- UDP_OPEN_ROM_HOST = Open a client socket and connect it to a remote host who's
221:                      		name is stored as a null terminated string in a literal string or ROM array. Ex: 
222:                      		"www.microchip.com" or "192.168.0.123" 
223:                 
224:                     localPort - UDP port number to listen on.  If 0, stack will dynamically assign a unique port 
225:                     number to use.
226:                 
227:                     remotePort - For client sockets, the remote port number.
228:                 
229:                 Return Values:
230:                   	Success - 
231:                 		A UDP socket handle that can be used for subsequent UDP API calls.
232:                 	Failure -
233:                 		INVALID_UDP_SOCKET.  This function fails when no more UDP socket
234:                 		handles are available.  Increase MAX_UDP_SOCKETS to make more sockets 	available.
235:                 Remarks:
236:                 	When finished using the UDP socket handle, call the UDPClose() function to free the 
237:                 	socket and delete the handle.
238:                 
239:                 *****************************************************************************/
240:                 UDP_SOCKET UDPOpenEx(DWORD remoteHost, BYTE remoteHostType, UDP_PORT localPort,
241:                 		UDP_PORT remotePort)
242:                 {
9D028374  27BDFFE0   ADDIU SP, SP, -32
9D028378  AFBF001C   SW RA, 28(SP)
9D02837C  AFBE0018   SW S8, 24(SP)
9D028380  03A0F021   ADDU S8, SP, ZERO
9D028384  AFC40020   SW A0, 32(S8)
9D028388  00A02021   ADDU A0, A1, ZERO
9D02838C  00C01821   ADDU V1, A2, ZERO
9D028390  00E01021   ADDU V0, A3, ZERO
9D028394  A3C40024   SB A0, 36(S8)
9D028398  A7C30028   SH V1, 40(S8)
9D02839C  A7C2002C   SH V0, 44(S8)
243:                 	UDP_SOCKET s;
244:                 	UDP_SOCKET_INFO *p;
245:                 
246:                 	// Local temp port numbers.
247:                 	static WORD NextPort __attribute__((persistent));
248:                 
249:                 
250:                 	p = UDPSocketInfo;
9D0283A0  3C02A000   LUI V0, -24576
9D0283A4  24420648   ADDIU V0, V0, 1608
9D0283A8  AFC20014   SW V0, 20(S8)
251:                 	for ( s = 0; s < MAX_UDP_SOCKETS; s++ )
9D0283AC  A3C00010   SB ZERO, 16(S8)
9D0283B0  0B40A167   J 0x9D02859C
9D0283B4  00000000   NOP
9D028590  93C20010   LBU V0, 16(S8)
9D028594  24420001   ADDIU V0, V0, 1
9D028598  A3C20010   SB V0, 16(S8)
9D02859C  93C20010   LBU V0, 16(S8)
9D0285A0  2C420008   SLTIU V0, V0, 8
9D0285A4  1440FF84   BNE V0, ZERO, 0x9D0283B8
9D0285A8  00000000   NOP
252:                 	{
253:                 		if(p->localPort == INVALID_UDP_PORT)
9D0283B8  8FC20014   LW V0, 20(S8)
9D0283BC  9442000E   LHU V0, 14(V0)
9D0283C0  14400070   BNE V0, ZERO, 0x9D028584
9D0283C4  00000000   NOP
254:                 		{
255:                 		 	p->localPort = localPort;  
9D0283C8  8FC20014   LW V0, 20(S8)
9D0283CC  97C30028   LHU V1, 40(S8)
9D0283D0  A443000E   SH V1, 14(V0)
256:                 			if(localPort == 0x0000u)
9D0283D4  97C20028   LHU V0, 40(S8)
9D0283D8  14400016   BNE V0, ZERO, 0x9D028434
9D0283DC  00000000   NOP
257:                 		   	{
258:                 			   if(NextPort > LOCAL_UDP_PORT_END_NUMBER || NextPort < LOCAL_UDP_PORT_START_NUMBER)
9D0283E0  3C02A000   LUI V0, -24576
9D0283E4  94420226   LHU V0, 550(V0)
9D0283E8  2C422001   SLTIU V0, V0, 8193
9D0283EC  10400006   BEQ V0, ZERO, 0x9D028408
9D0283F0  00000000   NOP
9D0283F4  3C02A000   LUI V0, -24576
9D0283F8  94420226   LHU V0, 550(V0)
9D0283FC  2C421000   SLTIU V0, V0, 4096
9D028400  10400004   BEQ V0, ZERO, 0x9D028414
9D028404  00000000   NOP
259:                 				   NextPort = LOCAL_UDP_PORT_START_NUMBER;
9D028408  3C02A000   LUI V0, -24576
9D02840C  24031000   ADDIU V1, ZERO, 4096
9D028410  A4430226   SH V1, 550(V0)
260:                 
261:                 			   p->localPort    = NextPort++;
9D028414  3C02A000   LUI V0, -24576
9D028418  94420226   LHU V0, 550(V0)
9D02841C  8FC30014   LW V1, 20(S8)
9D028420  A462000E   SH V0, 14(V1)
9D028424  24420001   ADDIU V0, V0, 1
9D028428  3043FFFF   ANDI V1, V0, -1
9D02842C  3C02A000   LUI V0, -24576
9D028430  A4430226   SH V1, 550(V0)
262:                 		   	}
263:                 			if((remoteHostType == UDP_OPEN_SERVER) || (remoteHost == 0))
9D028434  93C20024   LBU V0, 36(S8)
9D028438  10400004   BEQ V0, ZERO, 0x9D02844C
9D02843C  00000000   NOP
9D028440  8FC20020   LW V0, 32(S8)
9D028444  1440000C   BNE V0, ZERO, 0x9D028478
9D028448  00000000   NOP
264:                 			{
265:                 				  //Set remote node as 0xFF ( broadcast address)
266:                 				  // else Set broadcast address
267:                 				  memset((void*)&p->remote.remoteNode, 0xFF, sizeof(p->remote));
9D02844C  8FC20014   LW V0, 20(S8)
9D028450  00402021   ADDU A0, V0, ZERO
9D028454  240500FF   ADDIU A1, ZERO, 255
9D028458  2406000C   ADDIU A2, ZERO, 12
9D02845C  0F40D5EC   JAL 0x9D0357B0
9D028460  00000000   NOP
268:                 				  p->smState = UDP_OPENED;
9D028464  8FC20014   LW V0, 20(S8)
9D028468  24030005   ADDIU V1, ZERO, 5
9D02846C  AC430010   SW V1, 16(V0)
9D028470  0B40A159   J 0x9D028564
9D028474  00000000   NOP
269:                 			}
270:                 			else
271:                 			{
272:                 				switch(remoteHostType)
9D028478  93C20024   LBU V0, 36(S8)
9D02847C  24030003   ADDIU V1, ZERO, 3
9D028480  1043001E   BEQ V0, V1, 0x9D0284FC
9D028484  00000000   NOP
9D028488  28430004   SLTI V1, V0, 4
9D02848C  10600006   BEQ V1, ZERO, 0x9D0284A8
9D028490  00000000   NOP
9D028494  28420001   SLTI V0, V0, 1
9D028498  14400031   BNE V0, ZERO, 0x9D028560
9D02849C  00000000   NOP
9D0284A0  0B40A12F   J 0x9D0284BC
9D0284A4  00000000   NOP
9D0284A8  24030004   ADDIU V1, ZERO, 4
9D0284AC  10430020   BEQ V0, V1, 0x9D028530
9D0284B0  00000000   NOP
273:                 				{
274:                 #if defined (STACK_CLIENT_MODE)
275:                 #if defined (STACK_USE_DNS)
276:                 					case UDP_OPEN_RAM_HOST:
277:                 					case UDP_OPEN_ROM_HOST:
278:                 						//set the UDP state to UDP_GET_DNS_MODULE
279:                 						p->remote.remoteHost = remoteHost;
9D0284BC  8FC20014   LW V0, 20(S8)
9D0284C0  8FC30020   LW V1, 32(S8)
9D0284C4  AC430000   SW V1, 0(V0)
280:                 						p->flags.bRemoteHostIsROM = (remoteHostType == UDP_OPEN_ROM_HOST);
9D0284C8  93C20024   LBU V0, 36(S8)
9D0284CC  38420002   XORI V0, V0, 2
9D0284D0  2C420001   SLTIU V0, V0, 1
9D0284D4  304400FF   ANDI A0, V0, 255
9D0284D8  8FC30014   LW V1, 20(S8)
9D0284DC  8C620018   LW V0, 24(V1)
9D0284E0  7C824204   INS V0, A0, 8, 1
9D0284E4  AC620018   SW V0, 24(V1)
281:                 						p->smState = UDP_DNS_RESOLVE;
9D0284E8  8FC20014   LW V0, 20(S8)
9D0284EC  24030001   ADDIU V1, ZERO, 1
9D0284F0  AC430010   SW V1, 16(V0)
282:                 					break;
9D0284F4  0B40A159   J 0x9D028564
9D0284F8  00000000   NOP
283:                 #endif
284:                 					case UDP_OPEN_IP_ADDRESS:
285:                 					// remoteHost is a literal IP address.	This doesn't need DNS and can skip directly to the Gateway ARPing step. 	
286:                 					//Next UDP state UDP_GATEWAY_SEND_ARP;
287:                 					p->remote.remoteNode.IPAddr.Val = remoteHost;
9D0284FC  8FC20014   LW V0, 20(S8)
9D028500  8FC30020   LW V1, 32(S8)
9D028504  AC430000   SW V1, 0(V0)
288:                 					p->retryCount = 0;
9D028508  8FC20014   LW V0, 20(S8)
9D02850C  A0400018   SB ZERO, 24(V0)
289:                 					p->retryInterval = (TICK_SECOND/4)/256;
9D028510  8FC20014   LW V0, 20(S8)
9D028514  24030098   ADDIU V1, ZERO, 152
9D028518  AC430014   SW V1, 20(V0)
290:                 					p->smState = UDP_GATEWAY_SEND_ARP;
9D02851C  8FC20014   LW V0, 20(S8)
9D028520  24030002   ADDIU V1, ZERO, 2
9D028524  AC430010   SW V1, 16(V0)
291:                 					break;
9D028528  0B40A159   J 0x9D028564
9D02852C  00000000   NOP
292:                 #endif						
293:                 					case UDP_OPEN_NODE_INFO:
294:                 					//skip DNS and ARP resolution steps if connecting to a remote node which we've already
295:                 						memcpy((void*)(BYTE*)&p->remote,(void*)(BYTE*)(PTR_BASE)remoteHost,sizeof(p->remote));
9D028530  8FC30014   LW V1, 20(S8)
9D028534  8FC20020   LW V0, 32(S8)
9D028538  00602021   ADDU A0, V1, ZERO
9D02853C  00402821   ADDU A1, V0, ZERO
9D028540  2406000C   ADDIU A2, ZERO, 12
9D028544  0F40D298   JAL 0x9D034A60
9D028548  00000000   NOP
296:                 						p->smState = UDP_OPENED;
9D02854C  8FC20014   LW V0, 20(S8)
9D028550  24030005   ADDIU V1, ZERO, 5
9D028554  AC430010   SW V1, 16(V0)
297:                 					// CALL UDPFlushto transmit incluind peding data.
298:                 					break;
9D028558  0B40A159   J 0x9D028564
9D02855C  00000000   NOP
299:                 					default:
300:                 						break;
9D0284B4  0B40A159   J 0x9D028564
9D0284B8  00000000   NOP
9D028560  00000000   NOP
301:                 				}
302:                 			}
303:                 			p->remotePort   = remotePort;
9D028564  8FC20014   LW V0, 20(S8)
9D028568  97C3002C   LHU V1, 44(S8)
9D02856C  A443000C   SH V1, 12(V0)
304:                 
305:                 			// Mark this socket as active.
306:                 			// Once an active socket is set, subsequent operation can be
307:                 			// done without explicitely supply socket identifier.
308:                 			activeUDPSocket = s;
9D028570  93C20010   LBU V0, 16(S8)
9D028574  A38281EC   SB V0, -32276(GP)
309:                 			return s;
9D028578  93C20010   LBU V0, 16(S8)
9D02857C  0B40A16C   J 0x9D0285B0
9D028580  00000000   NOP
310:                 		}
311:                 		p++;
9D028584  8FC20014   LW V0, 20(S8)
9D028588  2442001C   ADDIU V0, V0, 28
9D02858C  AFC20014   SW V0, 20(S8)
312:                 	}
313:                 
314:                 	return (UDP_SOCKET)INVALID_UDP_SOCKET;
9D0285AC  240200FF   ADDIU V0, ZERO, 255
315:                 
316:                 }
9D0285B0  03C0E821   ADDU SP, S8, ZERO
9D0285B4  8FBF001C   LW RA, 28(SP)
9D0285B8  8FBE0018   LW S8, 24(SP)
9D0285BC  27BD0020   ADDIU SP, SP, 32
9D0285C0  03E00008   JR RA
9D0285C4  00000000   NOP
317:                 
318:                 
319:                 /******************************************************************************
320:                 Function:
321:                 	void UDPTask(void)
322:                 
323:                   Summary:
324:                   	Performs periodic UDP tasks.
325:                 
326:                   Description:
327:                 	This function performs any required periodic UDP tasks.  Each socket's state machine is 
328:                 	checked, and any elapsed timeout periods are handled.
329:                 
330:                   Precondition:
331:                 	UDP is initialized.
332:                 
333:                   Parameters:
334:                 	None
335:                 
336:                   Returns:
337:                 	None
338:                 
339:                 ******************************************************************************/
340:                 void UDPTask(void)
341:                 {
9D0285C8  27BDFFD8   ADDIU SP, SP, -40
9D0285CC  AFBF0024   SW RA, 36(SP)
9D0285D0  AFBE0020   SW S8, 32(SP)
9D0285D4  AFB0001C   SW S0, 28(SP)
9D0285D8  03A0F021   ADDU S8, SP, ZERO
342:                 	UDP_SOCKET ss;
343:                 	
344:                 	for ( ss = 0; ss < MAX_UDP_SOCKETS; ss++ )
9D0285DC  A3C00010   SB ZERO, 16(S8)
9D0285E0  0B40A29B   J 0x9D028A6C
9D0285E4  00000000   NOP
9D028A60  93C20010   LBU V0, 16(S8)
9D028A64  24420001   ADDIU V0, V0, 1
9D028A68  A3C20010   SB V0, 16(S8)
9D028A6C  93C20010   LBU V0, 16(S8)
9D028A70  2C420008   SLTIU V0, V0, 8
9D028A74  1440FEDC   BNE V0, ZERO, 0x9D0285E8
9D028A78  00000000   NOP
345:                 	{
346:                 
347:                 		// need to put Extra check if UDP has opened or NOT
348:                 
349:                 		if((UDPSocketInfo[ss].smState == UDP_OPENED) ||
9D0285E8  93C40010   LBU A0, 16(S8)
9D0285EC  3C02A000   LUI V0, -24576
9D0285F0  2403001C   ADDIU V1, ZERO, 28
9D0285F4  70831802   MUL V1, A0, V1
9D0285F8  24420648   ADDIU V0, V0, 1608
9D0285FC  00621021   ADDU V0, V1, V0
9D028600  8C430010   LW V1, 16(V0)
9D028604  24020005   ADDIU V0, ZERO, 5
9D028608  10620108   BEQ V1, V0, 0x9D028A2C
9D02860C  00000000   NOP
9D02862C  24020004   ADDIU V0, ZERO, 4
9D028630  10620101   BEQ V1, V0, 0x9D028A38
9D028634  00000000   NOP
350:                 			(UDPSocketInfo[ss].smState == UDP_CLOSED))
9D028610  93C40010   LBU A0, 16(S8)
9D028614  3C02A000   LUI V0, -24576
9D028618  2403001C   ADDIU V1, ZERO, 28
9D02861C  70831802   MUL V1, A0, V1
9D028620  24420648   ADDIU V0, V0, 1608
9D028624  00621021   ADDU V0, V1, V0
9D028628  8C430010   LW V1, 16(V0)
351:                 			continue;
9D028A2C  00000000   NOP
9D028A30  0B40A298   J 0x9D028A60
9D028A34  00000000   NOP
9D028A38  00000000   NOP
9D028A3C  0B40A298   J 0x9D028A60
9D028A40  00000000   NOP
352:                 		// A timeout has occured.  Respond to this timeout condition
353:                 		// depending on what state this socket is in.
354:                 		switch(UDPSocketInfo[ss].smState)
9D028638  93C40010   LBU A0, 16(S8)
9D02863C  3C02A000   LUI V0, -24576
9D028640  2403001C   ADDIU V1, ZERO, 28
9D028644  70831802   MUL V1, A0, V1
9D028648  24420648   ADDIU V0, V0, 1608
9D02864C  00621021   ADDU V0, V1, V0
9D028650  8C420010   LW V0, 16(V0)
9D028654  24030001   ADDIU V1, ZERO, 1
9D028658  1043000C   BEQ V0, V1, 0x9D02868C
9D02865C  00000000   NOP
9D028660  2C430001   SLTIU V1, V0, 1
9D028664  14600039   BNE V1, ZERO, 0x9D02874C
9D028668  00000000   NOP
9D02866C  24030002   ADDIU V1, ZERO, 2
9D028670  1043006B   BEQ V0, V1, 0x9D028820
9D028674  00000000   NOP
9D028678  24030003   ADDIU V1, ZERO, 3
9D02867C  10430085   BEQ V0, V1, 0x9D028894
9D028680  00000000   NOP
355:                 		{
356:                 			#if defined(STACK_CLIENT_MODE)
357:                 			#if defined(STACK_USE_DNS)
358:                 			case UDP_DNS_RESOLVE:
359:                 			if(DNSBeginUsage())
9D02868C  0F40A557   JAL DNSBeginUsage
9D028690  00000000   NOP
9D028694  104000EB   BEQ V0, ZERO, 0x9D028A44
9D028698  00000000   NOP
360:                 			{
361:                 				// call DNS Resolve function and move to UDP next State machine
362:                 				UDPSocketInfo[ss].smState = UDP_DNS_IS_RESOLVED;
9D02869C  93C40010   LBU A0, 16(S8)
9D0286A0  3C02A000   LUI V0, -24576
9D0286A4  2403001C   ADDIU V1, ZERO, 28
9D0286A8  70831802   MUL V1, A0, V1
9D0286AC  24420648   ADDIU V0, V0, 1608
9D0286B0  00621021   ADDU V0, V1, V0
9D0286B4  AC400010   SW ZERO, 16(V0)
363:                 				if(UDPSocketInfo[ss].flags.bRemoteHostIsROM)
9D0286B8  93C40010   LBU A0, 16(S8)
9D0286BC  3C02A000   LUI V0, -24576
9D0286C0  2403001C   ADDIU V1, ZERO, 28
9D0286C4  70831802   MUL V1, A0, V1
9D0286C8  24420648   ADDIU V0, V0, 1608
9D0286CC  00621021   ADDU V0, V1, V0
9D0286D0  8C420018   LW V0, 24(V0)
9D0286D4  7C420200   EXT V0, V0, 8, 1
9D0286D8  304200FF   ANDI V0, V0, 255
9D0286DC  1040000E   BEQ V0, ZERO, 0x9D028718
9D0286E0  00000000   NOP
364:                 					DNSResolveROM((ROM BYTE*)(ROM_PTR_BASE)UDPSocketInfo[ss].remote.remoteHost, DNS_TYPE_A);
9D0286E4  93C40010   LBU A0, 16(S8)
9D0286E8  3C02A000   LUI V0, -24576
9D0286EC  2403001C   ADDIU V1, ZERO, 28
9D0286F0  70831802   MUL V1, A0, V1
9D0286F4  24420648   ADDIU V0, V0, 1608
9D0286F8  00621021   ADDU V0, V1, V0
9D0286FC  8C420000   LW V0, 0(V0)
9D028700  00402021   ADDU A0, V0, ZERO
9D028704  24050001   ADDIU A1, ZERO, 1
9D028708  0F40A588   JAL DNSResolve
9D02870C  00000000   NOP
365:                 				else
366:                 					DNSResolve((BYTE*)(PTR_BASE)UDPSocketInfo[ss].remote.remoteHost, DNS_TYPE_A);
9D028718  93C40010   LBU A0, 16(S8)
9D02871C  3C02A000   LUI V0, -24576
9D028720  2403001C   ADDIU V1, ZERO, 28
9D028724  70831802   MUL V1, A0, V1
9D028728  24420648   ADDIU V0, V0, 1608
9D02872C  00621021   ADDU V0, V1, V0
9D028730  8C420000   LW V0, 0(V0)
9D028734  00402021   ADDU A0, V0, ZERO
9D028738  24050001   ADDIU A1, ZERO, 1
9D02873C  0F40A588   JAL DNSResolve
9D028740  00000000   NOP
367:                 			}
368:                 			break;				
9D028710  0B40A298   J 0x9D028A60
9D028714  00000000   NOP
9D028744  0B40A298   J 0x9D028A60
9D028748  00000000   NOP
9D028A44  00000000   NOP
9D028A48  0B40A298   J 0x9D028A60
9D028A4C  00000000   NOP
369:                 			case UDP_DNS_IS_RESOLVED:
370:                 			{
371:                 				IP_ADDR ipResolvedDNSIP;
372:                 				// See if DNS resolution has finished.	Note that if the DNS 
373:                 				// fails, the &ipResolvedDNSIP will be written with 0x00000000. 
374:                 				// MyTCB.remote.dwRemoteHost is unioned with 
375:                 				// MyTCB.remote.niRemoteMACIP.IPAddr, so we can't directly write 
376:                 				// the DNS result into MyTCB.remote.niRemoteMACIP.IPAddr.  We 
377:                 				// must copy it over only if the DNS is resolution step was 
378:                 				// successful.
379:                 				
380:                 				if(DNSIsResolved(&ipResolvedDNSIP))
9D02874C  27C20014   ADDIU V0, S8, 20
9D028750  00402021   ADDU A0, V0, ZERO
9D028754  0F40A5AD   JAL DNSIsResolved
9D028758  00000000   NOP
9D02875C  104000BC   BEQ V0, ZERO, 0x9D028A50
9D028760  00000000   NOP
381:                 				{
382:                 					if(DNSEndUsage())
9D028764  0F40A56C   JAL DNSEndUsage
9D028768  00000000   NOP
9D02876C  10400022   BEQ V0, ZERO, 0x9D0287F8
9D028770  00000000   NOP
383:                 					{
384:                 						UDPSocketInfo[ss].remote.remoteNode.IPAddr.Val = ipResolvedDNSIP.Val;
9D028774  93C50010   LBU A1, 16(S8)
9D028778  8FC30014   LW V1, 20(S8)
9D02877C  3C02A000   LUI V0, -24576
9D028780  2404001C   ADDIU A0, ZERO, 28
9D028784  70A42002   MUL A0, A1, A0
9D028788  24420648   ADDIU V0, V0, 1608
9D02878C  00821021   ADDU V0, A0, V0
9D028790  AC430000   SW V1, 0(V0)
385:                 						UDPSocketInfo[ss].smState = UDP_GATEWAY_SEND_ARP;
9D028794  93C40010   LBU A0, 16(S8)
9D028798  3C02A000   LUI V0, -24576
9D02879C  2403001C   ADDIU V1, ZERO, 28
9D0287A0  70831802   MUL V1, A0, V1
9D0287A4  24420648   ADDIU V0, V0, 1608
9D0287A8  00621021   ADDU V0, V1, V0
9D0287AC  24030002   ADDIU V1, ZERO, 2
9D0287B0  AC430010   SW V1, 16(V0)
386:                 						UDPSocketInfo[ss].retryCount = 0;
9D0287B4  93C40010   LBU A0, 16(S8)
9D0287B8  3C02A000   LUI V0, -24576
9D0287BC  2403001C   ADDIU V1, ZERO, 28
9D0287C0  70831802   MUL V1, A0, V1
9D0287C4  24420648   ADDIU V0, V0, 1608
9D0287C8  00621021   ADDU V0, V1, V0
9D0287CC  A0400018   SB ZERO, 24(V0)
387:                 						UDPSocketInfo[ss].retryInterval = (TICK_SECOND/4)/256;
9D0287D0  93C40010   LBU A0, 16(S8)
9D0287D4  3C02A000   LUI V0, -24576
9D0287D8  24430648   ADDIU V1, V0, 1608
9D0287DC  2402001C   ADDIU V0, ZERO, 28
9D0287E0  70821002   MUL V0, A0, V0
9D0287E4  00621021   ADDU V0, V1, V0
9D0287E8  24030098   ADDIU V1, ZERO, 152
9D0287EC  AC430014   SW V1, 20(V0)
388:                 					}
389:                 					else
390:                 					{
391:                 						UDPSocketInfo[ss].smState = UDP_DNS_RESOLVE;
9D0287F8  93C40010   LBU A0, 16(S8)
9D0287FC  3C02A000   LUI V0, -24576
9D028800  2403001C   ADDIU V1, ZERO, 28
9D028804  70831802   MUL V1, A0, V1
9D028808  24420648   ADDIU V0, V0, 1608
9D02880C  00621021   ADDU V0, V1, V0
9D028810  24030001   ADDIU V1, ZERO, 1
9D028814  AC430010   SW V1, 16(V0)
392:                 					}
393:                 				}			
394:                 			}
395:                 			break;
9D0287F0  0B40A298   J 0x9D028A60
9D0287F4  00000000   NOP
9D028818  0B40A298   J 0x9D028A60
9D02881C  00000000   NOP
9D028A50  00000000   NOP
9D028A54  0B40A298   J 0x9D028A60
9D028A58  00000000   NOP
396:                 			#endif // #if defined(STACK_USE_DNS)
397:                 
398:                 			case UDP_GATEWAY_SEND_ARP:
399:                 				// Obtain the MAC address associated with the server's IP address 
400:                 				//(either direct MAC address on same subnet, or the MAC address of the Gateway machine)
401:                 				UDPSocketInfo[ss].eventTime = (WORD)TickGetDiv256();
9D028820  93D00010   LBU S0, 16(S8)
9D028824  0F40CDE4   JAL TickGetDiv256
9D028828  00000000   NOP
9D02882C  3043FFFF   ANDI V1, V0, -1
9D028830  3C02A000   LUI V0, -24576
9D028834  2404001C   ADDIU A0, ZERO, 28
9D028838  72042002   MUL A0, S0, A0
9D02883C  24420648   ADDIU V0, V0, 1608
9D028840  00821021   ADDU V0, A0, V0
9D028844  A443001A   SH V1, 26(V0)
402:                 				ARPResolve(&UDPSocketInfo[ss].remote.remoteNode.IPAddr);
9D028848  93C30010   LBU V1, 16(S8)
9D02884C  2402001C   ADDIU V0, ZERO, 28
9D028850  70621802   MUL V1, V1, V0
9D028854  3C02A000   LUI V0, -24576
9D028858  24420648   ADDIU V0, V0, 1608
9D02885C  00621021   ADDU V0, V1, V0
9D028860  00402021   ADDU A0, V0, ZERO
9D028864  0F40BCC0   JAL ARPResolve
9D028868  00000000   NOP
403:                 				UDPSocketInfo[ss].smState = UDP_GATEWAY_GET_ARP;
9D02886C  93C40010   LBU A0, 16(S8)
9D028870  3C02A000   LUI V0, -24576
9D028874  2403001C   ADDIU V1, ZERO, 28
9D028878  70831802   MUL V1, A0, V1
9D02887C  24420648   ADDIU V0, V0, 1608
9D028880  00621021   ADDU V0, V1, V0
9D028884  24030003   ADDIU V1, ZERO, 3
9D028888  AC430010   SW V1, 16(V0)
404:                 				break;
9D02888C  0B40A298   J 0x9D028A60
9D028890  00000000   NOP
405:                 
406:                 			case UDP_GATEWAY_GET_ARP:
407:                 			if(!ARPIsResolved(&UDPSocketInfo[ss].remote.remoteNode.IPAddr, 
9D028894  93C30010   LBU V1, 16(S8)
9D028898  2402001C   ADDIU V0, ZERO, 28
9D02889C  70621802   MUL V1, V1, V0
9D0288A0  3C02A000   LUI V0, -24576
9D0288A4  24420648   ADDIU V0, V0, 1608
9D0288A8  00621821   ADDU V1, V1, V0
9D0288B0  2402001C   ADDIU V0, ZERO, 28
9D0288B4  70822002   MUL A0, A0, V0
9D0288B8  3C02A000   LUI V0, -24576
9D0288BC  24420648   ADDIU V0, V0, 1608
9D0288C0  00821021   ADDU V0, A0, V0
9D0288C4  24420004   ADDIU V0, V0, 4
9D0288C8  00602021   ADDU A0, V1, ZERO
9D0288CC  00402821   ADDU A1, V0, ZERO
9D0288D0  0F40BCF9   JAL ARPIsResolved
9D0288D4  00000000   NOP
9D0288D8  1440004A   BNE V0, ZERO, 0x9D028A04
9D0288DC  00000000   NOP
408:                 								&UDPSocketInfo[ss].remote.remoteNode.MACAddr))
9D0288AC  93C40010   LBU A0, 16(S8)
409:                 			{
410:                 				// Time out if too much time is spent in this state
411:                 				// Note that this will continuously send out ARP 
412:                 				// requests for an infinite time if the Gateway 
413:                 				// never responds
414:                 				if((WORD)TickGetDiv256() - UDPSocketInfo[ss].eventTime> (WORD)UDPSocketInfo[ss].retryInterval)
9D0288E0  0F40CDE4   JAL TickGetDiv256
9D0288E4  00000000   NOP
9D0288E8  3042FFFF   ANDI V0, V0, -1
9D0288EC  00401821   ADDU V1, V0, ZERO
9D0288F0  93C50010   LBU A1, 16(S8)
9D0288F4  3C02A000   LUI V0, -24576
9D0288F8  2404001C   ADDIU A0, ZERO, 28
9D0288FC  70A42002   MUL A0, A1, A0
9D028900  24420648   ADDIU V0, V0, 1608
9D028904  00821021   ADDU V0, A0, V0
9D028908  9442001A   LHU V0, 26(V0)
9D02890C  00621823   SUBU V1, V1, V0
9D028910  93C50010   LBU A1, 16(S8)
9D028914  3C02A000   LUI V0, -24576
9D028918  24440648   ADDIU A0, V0, 1608
9D02891C  2402001C   ADDIU V0, ZERO, 28
9D028920  70A21002   MUL V0, A1, V0
9D028924  00821021   ADDU V0, A0, V0
9D028928  8C420014   LW V0, 20(V0)
9D02892C  3042FFFF   ANDI V0, V0, -1
9D028930  0043102A   SLT V0, V0, V1
9D028934  10400049   BEQ V0, ZERO, 0x9D028A5C
9D028938  00000000   NOP
415:                 				{
416:                 					// Exponentially increase timeout until we reach 6 attempts then stay constant
417:                 					if(UDPSocketInfo[ss].retryCount < 6u)
9D02893C  93C40010   LBU A0, 16(S8)
9D028940  3C02A000   LUI V0, -24576
9D028944  2403001C   ADDIU V1, ZERO, 28
9D028948  70831802   MUL V1, A0, V1
9D02894C  24420648   ADDIU V0, V0, 1608
9D028950  00621021   ADDU V0, V1, V0
9D028954  90420018   LBU V0, 24(V0)
9D028958  2C420006   SLTIU V0, V0, 6
9D02895C  1040001F   BEQ V0, ZERO, 0x9D0289DC
9D028960  00000000   NOP
418:                 					{
419:                 						UDPSocketInfo[ss].retryCount++;
9D028964  93C50010   LBU A1, 16(S8)
9D028968  3C02A000   LUI V0, -24576
9D02896C  2403001C   ADDIU V1, ZERO, 28
9D028970  70A31802   MUL V1, A1, V1
9D028974  24420648   ADDIU V0, V0, 1608
9D028978  00621021   ADDU V0, V1, V0
9D02897C  90420018   LBU V0, 24(V0)
9D028980  24420001   ADDIU V0, V0, 1
9D028984  304300FF   ANDI V1, V0, 255
9D028988  3C02A000   LUI V0, -24576
9D02898C  2404001C   ADDIU A0, ZERO, 28
9D028990  70A42002   MUL A0, A1, A0
9D028994  24420648   ADDIU V0, V0, 1608
9D028998  00821021   ADDU V0, A0, V0
9D02899C  A0430018   SB V1, 24(V0)
420:                 						UDPSocketInfo[ss].retryInterval <<= 1;
9D0289A0  93C50010   LBU A1, 16(S8)
9D0289A4  93C40010   LBU A0, 16(S8)
9D0289A8  3C02A000   LUI V0, -24576
9D0289AC  24430648   ADDIU V1, V0, 1608
9D0289B0  2402001C   ADDIU V0, ZERO, 28
9D0289B4  70821002   MUL V0, A0, V0
9D0289B8  00621021   ADDU V0, V1, V0
9D0289BC  8C420014   LW V0, 20(V0)
9D0289C0  00021840   SLL V1, V0, 1
9D0289C4  3C02A000   LUI V0, -24576
9D0289C8  24440648   ADDIU A0, V0, 1608
9D0289CC  2402001C   ADDIU V0, ZERO, 28
9D0289D0  70A21002   MUL V0, A1, V0
9D0289D4  00821021   ADDU V0, A0, V0
9D0289D8  AC430014   SW V1, 20(V0)
421:                 					}
422:                 					// Retransmit ARP request
423:                 					UDPSocketInfo[ss].smState = UDP_GATEWAY_SEND_ARP;
9D0289DC  93C40010   LBU A0, 16(S8)
9D0289E0  3C02A000   LUI V0, -24576
9D0289E4  2403001C   ADDIU V1, ZERO, 28
9D0289E8  70831802   MUL V1, A0, V1
9D0289EC  24420648   ADDIU V0, V0, 1608
9D0289F0  00621021   ADDU V0, V1, V0
9D0289F4  24030002   ADDIU V1, ZERO, 2
9D0289F8  AC430010   SW V1, 16(V0)
424:                 				}				
425:                 			}
426:                 			else
427:                 			{
428:                 				UDPSocketInfo[ss].smState = UDP_OPENED;
9D028A04  93C40010   LBU A0, 16(S8)
9D028A08  3C02A000   LUI V0, -24576
9D028A0C  2403001C   ADDIU V1, ZERO, 28
9D028A10  70831802   MUL V1, A0, V1
9D028A14  24420648   ADDIU V0, V0, 1608
9D028A18  00621021   ADDU V0, V1, V0
9D028A1C  24030005   ADDIU V1, ZERO, 5
9D028A20  AC430010   SW V1, 16(V0)
429:                 			}
430:                 			break;
9D0289FC  0B40A298   J 0x9D028A60
9D028A00  00000000   NOP
9D028A24  0B40A298   J 0x9D028A60
9D028A28  00000000   NOP
9D028A5C  00000000   NOP
431:                 			default:
432:                 			case UDP_OPENED:
433:                 			case UDP_CLOSED:
434:                 			// not used
435:                 			break;
9D028684  0B40A298   J 0x9D028A60
9D028688  00000000   NOP
436:                 #endif // #if defined(STACK_CLIENT_MODE)
437:                 		}
438:                 	}
439:                 } 
9D028A7C  03C0E821   ADDU SP, S8, ZERO
9D028A80  8FBF0024   LW RA, 36(SP)
9D028A84  8FBE0020   LW S8, 32(SP)
9D028A88  8FB0001C   LW S0, 28(SP)
9D028A8C  27BD0028   ADDIU SP, SP, 40
9D028A90  03E00008   JR RA
9D028A94  00000000   NOP
440:                 
441:                 /******************************************************************************
442:                  
443:                   Function:
444:                 	  BOOL UDPISOpened(UDP_SOCKET socket)
445:                   
446:                  Summary:
447:                 	  Determines if a socket has an established connection.
448:                 
449:                  Description:
450:                 	This function determines if a socket has an established connection to a remote node .  
451:                 	Call this function after calling UDPOpen to determine when the connection is set up 
452:                 	and ready for use.  
453:                 
454:                  Precondition:
455:                 	UDP is initialized.
456:                 
457:                  Parameters:
458:                 	socket - The socket to check.
459:                 
460:                  Return Values:
461:                 	TRUE - The socket has been opened and ARP has been resolved.
462:                 	FALSE - The socket is not currently connected.
463:                 
464:                  Remarks:
465:                 	None
466:                  
467:                  *****************************************************************************/
468:                 BOOL UDPIsOpened(UDP_SOCKET socket)
469:                 {
9D028A98  27BDFFF8   ADDIU SP, SP, -8
9D028A9C  AFBE0004   SW S8, 4(SP)
9D028AA0  03A0F021   ADDU S8, SP, ZERO
9D028AA4  00801021   ADDU V0, A0, ZERO
9D028AA8  A3C20008   SB V0, 8(S8)
470:                 	return (UDPSocketInfo[socket].smState == UDP_OPENED);
9D028AAC  93C40008   LBU A0, 8(S8)
9D028AB0  3C02A000   LUI V0, -24576
9D028AB4  2403001C   ADDIU V1, ZERO, 28
9D028AB8  70831802   MUL V1, A0, V1
9D028ABC  24420648   ADDIU V0, V0, 1608
9D028AC0  00621021   ADDU V0, V1, V0
9D028AC4  8C420010   LW V0, 16(V0)
9D028AC8  38420005   XORI V0, V0, 5
9D028ACC  2C420001   SLTIU V0, V0, 1
471:                 }
9D028AD0  03C0E821   ADDU SP, S8, ZERO
9D028AD4  8FBE0004   LW S8, 4(SP)
9D028AD8  27BD0008   ADDIU SP, SP, 8
9D028ADC  03E00008   JR RA
9D028AE0  00000000   NOP
472:                 
473:                 
474:                 #if 0
475:                 /*****************************************************************************
476:                   Function:
477:                 	void UDPTask(void)
478:                 
479:                   Summary:
480:                 	Performs state management and housekeeping for UDP.
481:                 	
482:                   Description:
483:                 	Performs state management and housekeeping for UDP.  This is an internal
484:                 	function meant to be called by StackTask() (not a user API).
485:                 
486:                   Precondition:
487:                 	None
488:                 
489:                   Parameters:
490:                 	None
491:                 
492:                   Return Values:
493:                   	None
494:                   	
495:                   Remarks:
496:                 	UDPTask() is called once per StackTask() iteration to ensure that calls 
497:                 	to UDPIsPutReady() always update the Ethernet Write pointer location 
498:                 	between StackTask() iterations.
499:                   ***************************************************************************/
500:                 void UDPTask(void)
501:                 {
502:                 	LastPutSocket = INVALID_UDP_SOCKET;
503:                 }
504:                 
505:                 
506:                 /*****************************************************************************
507:                   Function:
508:                 	UDP_SOCKET UDPOpen(UDP_PORT localPort, NODE_INFO* remoteNode, 
509:                 						UDP_PORT remotePort)
510:                 
511:                   Summary:
512:                 	Creates a UDP socket handle for transmiting or receiving UDP packets.
513:                 	
514:                   Description:
515:                 	Creates a UDP socket handle for transmiting or receiving UDP packets.  
516:                 	Call this function to obtain a handle required by other UDP function.
517:                 
518:                   Precondition:
519:                 	UDPInit() must have been previously called.
520:                 
521:                   Parameters:
522:                 	localPort - UDP port number to listen on.  If 0, stack will dynamically 
523:                 		assign a unique port number to use.
524:                 	remoteNode - Pointer to remote node info (MAC and IP address) for this
525:                 		connection.  If this is a server socket (receives the first packet) 
526:                 		or the destination is the broadcast address, then this parameter
527:                 		should be NULL.
528:                 	remotePort - For client sockets, the remote port number.
529:                 
530:                   Return Values:
531:                   	Success -
532:                 		A UDP socket handle that can be used for subsequent UDP API calls.
533:                 	Failure -
534:                 		INVALID_UDP_SOCKET.  This function fails when no more UDP socket 
535:                 		handles are available.  Increase MAX_UDP_SOCKETS to make more sockets 
536:                 		available.
537:                   	
538:                   Remarks:
539:                 	When finished using the UDP socket handle, call the UDPClose() function 
540:                 	to free the socket and delete the handle.
541:                   ***************************************************************************/
542:                 UDP_SOCKET UDPOpen(UDP_PORT localPort,
543:                                    NODE_INFO *remoteNode,
544:                                    UDP_PORT remotePort)
545:                 {
546:                     UDP_SOCKET s;
547:                     UDP_SOCKET_INFO *p;
548:                 
549:                 	// Local temp port numbers.
550:                 	static WORD NextPort __attribute__((persistent));
551:                 
552:                 
553:                     p = UDPSocketInfo;
554:                     for ( s = 0; s < MAX_UDP_SOCKETS; s++ )
555:                     {
556:                         if(p->localPort == INVALID_UDP_PORT)
557:                         {
558:                 			p->localPort = localPort;	
559:                 
560:                 			if(localPort == 0x0000u)
561:                 			{
562:                 				if(NextPort > LOCAL_UDP_PORT_END_NUMBER || NextPort < LOCAL_UDP_PORT_START_NUMBER)
563:                 					NextPort = LOCAL_UDP_PORT_START_NUMBER;
564:                 	
565:                 	            p->localPort    = NextPort++;
566:                 			}
567:                 
568:                             // If remoteNode is supplied, remember it.
569:                             if(remoteNode)
570:                             {
571:                                 memcpy((void*)&p->remoteNode,
572:                                         (const void*)remoteNode,
573:                                         sizeof(p->remoteNode));
574:                             }
575:                             else
576:                 			{
577:                 				// else Set broadcast address
578:                 				memset((void*)&p->remoteNode, 0xFF, sizeof(p->remoteNode));
579:                 			}
580:                 
581:                             p->remotePort   = remotePort;
582:                 
583:                             // Mark this socket as active.
584:                             // Once an active socket is set, subsequent operation can be
585:                             // done without explicitely supply socket identifier.
586:                             activeUDPSocket = s;
587:                             return s;
588:                         }
589:                         p++;
590:                     }
591:                 
592:                     return (UDP_SOCKET)INVALID_UDP_SOCKET;
593:                 }
594:                 
595:                 #endif
596:                 
597:                 
598:                 /*****************************************************************************
599:                   Function:
600:                 	void UDPClose(UDP_SOCKET s)
601:                 
602:                   Summary:
603:                 	Closes a UDP socket and frees the handle.
604:                 	
605:                   Description:
606:                 	Closes a UDP socket and frees the handle.  Call this function to release
607:                 	a socket and return it to the pool for use by future communications.
608:                 
609:                   Precondition:
610:                 	UDPInit() must have been previously called.
611:                 
612:                   Parameters:
613:                 	s - The socket handle to be released.  If an illegal handle value is 
614:                 		provided, the function safely does nothing.
615:                 
616:                   Returns:
617:                   	None
618:                   	
619:                   Remarks:
620:                 	This function does not affect the previously designated active socket.
621:                   ***************************************************************************/
622:                 void UDPClose(UDP_SOCKET s)
623:                 {
9D028AE4  27BDFFF8   ADDIU SP, SP, -8
9D028AE8  AFBE0004   SW S8, 4(SP)
9D028AEC  03A0F021   ADDU S8, SP, ZERO
9D028AF0  00801021   ADDU V0, A0, ZERO
9D028AF4  A3C20008   SB V0, 8(S8)
624:                 	if(s >= MAX_UDP_SOCKETS)
9D028AF8  93C20008   LBU V0, 8(S8)
9D028AFC  2C420008   SLTIU V0, V0, 8
9D028B00  10400019   BEQ V0, ZERO, 0x9D028B68
9D028B04  00000000   NOP
625:                 		return;
9D028B68  00000000   NOP
626:                 
627:                 	UDPSocketInfo[s].localPort = INVALID_UDP_PORT;
9D028B08  93C40008   LBU A0, 8(S8)
9D028B0C  3C02A000   LUI V0, -24576
9D028B10  2403001C   ADDIU V1, ZERO, 28
9D028B14  70831802   MUL V1, A0, V1
9D028B18  24420648   ADDIU V0, V0, 1608
9D028B1C  00621021   ADDU V0, V1, V0
9D028B20  A440000E   SH ZERO, 14(V0)
628:                 	UDPSocketInfo[s].remote.remoteNode.IPAddr.Val = 0x00000000;
9D028B24  93C40008   LBU A0, 8(S8)
9D028B28  3C02A000   LUI V0, -24576
9D028B2C  2403001C   ADDIU V1, ZERO, 28
9D028B30  70831802   MUL V1, A0, V1
9D028B34  24420648   ADDIU V0, V0, 1608
9D028B38  00621021   ADDU V0, V1, V0
9D028B3C  AC400000   SW ZERO, 0(V0)
629:                 	UDPSocketInfo[s].smState = UDP_CLOSED;
9D028B40  93C40008   LBU A0, 8(S8)
9D028B44  3C02A000   LUI V0, -24576
9D028B48  2403001C   ADDIU V1, ZERO, 28
9D028B4C  70831802   MUL V1, A0, V1
9D028B50  24420648   ADDIU V0, V0, 1608
9D028B54  00621021   ADDU V0, V1, V0
9D028B58  24030004   ADDIU V1, ZERO, 4
9D028B5C  AC430010   SW V1, 16(V0)
9D028B60  0B40A2DB   J 0x9D028B6C
9D028B64  00000000   NOP
630:                 }
9D028B6C  03C0E821   ADDU SP, S8, ZERO
9D028B70  8FBE0004   LW S8, 4(SP)
9D028B74  27BD0008   ADDIU SP, SP, 8
9D028B78  03E00008   JR RA
9D028B7C  00000000   NOP
631:                 
632:                 
633:                 /*****************************************************************************
634:                   Function:
635:                 	void UDPSetTxBuffer(WORD wOffset)
636:                 
637:                   Summary:
638:                 	Moves the pointer within the TX buffer.
639:                 	
640:                   Description:
641:                 	This function allows the write location within the TX buffer to be 
642:                 	specified.  Future calls to UDPPut, UDPPutArray, UDPPutString, etc will
643:                 	write data from the indicated location.
644:                 
645:                   Precondition:
646:                 	UDPInit() must have been previously called and a socket is currently 
647:                 	active.
648:                 
649:                   Parameters:
650:                 	wOffset - Offset from beginning of UDP packet data payload to place the
651:                 		write pointer.
652:                 
653:                   Returns:
654:                   	None
655:                   ***************************************************************************/
656:                 void UDPSetTxBuffer(WORD wOffset)
657:                 {
9D028B80  27BDFFE8   ADDIU SP, SP, -24
9D028B84  AFBF0014   SW RA, 20(SP)
9D028B88  AFBE0010   SW S8, 16(SP)
9D028B8C  03A0F021   ADDU S8, SP, ZERO
9D028B90  00801021   ADDU V0, A0, ZERO
9D028B94  A7C20018   SH V0, 24(S8)
658:                 	IPSetTxBuffer(wOffset+sizeof(UDP_HEADER));
9D028B98  97C20018   LHU V0, 24(S8)
9D028B9C  2442002A   ADDIU V0, V0, 42
9D028BA0  00402021   ADDU A0, V0, ZERO
9D028BA4  0F407410   JAL MACSetWritePtr
9D028BA8  00000000   NOP
659:                 	wPutOffset = wOffset;
9D028BAC  97C20018   LHU V0, 24(S8)
9D028BB0  A78281B0   SH V0, -32336(GP)
660:                 }
9D028BB4  03C0E821   ADDU SP, S8, ZERO
9D028BB8  8FBF0014   LW RA, 20(SP)
9D028BBC  8FBE0010   LW S8, 16(SP)
9D028BC0  27BD0018   ADDIU SP, SP, 24
9D028BC4  03E00008   JR RA
9D028BC8  00000000   NOP
661:                 
662:                 
663:                 /*****************************************************************************
664:                   Function:
665:                 	void UDPSetRxBuffer(WORD wOffset)
666:                 
667:                   Summary:
668:                 	Moves the pointer within the RX buffer.
669:                 	
670:                   Description:
671:                 	This function allows the read location within the RX buffer to be 
672:                 	specified.  Future calls to UDPGet and UDPGetArray will read data from
673:                 	the indicated location forward.
674:                 
675:                   Precondition:
676:                 	UDPInit() must have been previously called and a socket is currently 
677:                 	active.
678:                 
679:                   Parameters:
680:                 	wOffset - Offset from beginning of UDP packet data payload to place the
681:                 		read pointer.
682:                 
683:                   Returns:
684:                   	None
685:                   ***************************************************************************/
686:                 void UDPSetRxBuffer(WORD wOffset)
687:                 {
9D028BCC  27BDFFE8   ADDIU SP, SP, -24
9D028BD0  AFBF0014   SW RA, 20(SP)
9D028BD4  AFBE0010   SW S8, 16(SP)
9D028BD8  03A0F021   ADDU S8, SP, ZERO
9D028BDC  00801021   ADDU V0, A0, ZERO
9D028BE0  A7C20018   SH V0, 24(S8)
688:                 	IPSetRxBuffer(wOffset+sizeof(UDP_HEADER));
9D028BE4  97C20018   LHU V0, 24(S8)
9D028BE8  24420008   ADDIU V0, V0, 8
9D028BEC  3042FFFF   ANDI V0, V0, -1
9D028BF0  00402021   ADDU A0, V0, ZERO
9D028BF4  0F40CEF1   JAL IPSetRxBuffer
9D028BF8  00000000   NOP
689:                 	wGetOffset = wOffset;
9D028BFC  97C20018   LHU V0, 24(S8)
9D028C00  A78281B2   SH V0, -32334(GP)
690:                 }
9D028C04  03C0E821   ADDU SP, S8, ZERO
9D028C08  8FBF0014   LW RA, 20(SP)
9D028C0C  8FBE0010   LW S8, 16(SP)
9D028C10  27BD0018   ADDIU SP, SP, 24
9D028C14  03E00008   JR RA
9D028C18  00000000   NOP
691:                 
692:                 
693:                 
694:                 /****************************************************************************
695:                   Section:
696:                 	Transmit Functions
697:                   ***************************************************************************/
698:                   
699:                 /*****************************************************************************
700:                   Function:
701:                 	WORD UDPIsPutReady(UDP_SOCKET s)
702:                 
703:                   Summary:
704:                 	Determines how many bytes can be written to the UDP socket.
705:                 	
706:                   Description:
707:                 	This function determines if bytes can be written to the specified UDP
708:                 	socket.  It also prepares the UDP module for writing by setting the 
709:                 	indicated socket as the currently active connection.
710:                 
711:                   Precondition:
712:                 	UDPInit() must have been previously called.
713:                 
714:                   Parameters:
715:                 	s - The socket to be made active
716:                 
717:                   Returns:
718:                   	The number of bytes that can be written to this socket.
719:                   ***************************************************************************/
720:                 WORD UDPIsPutReady(UDP_SOCKET s)
721:                 {
9D028C1C  27BDFFE8   ADDIU SP, SP, -24
9D028C20  AFBF0014   SW RA, 20(SP)
9D028C24  AFBE0010   SW S8, 16(SP)
9D028C28  03A0F021   ADDU S8, SP, ZERO
9D028C2C  00801021   ADDU V0, A0, ZERO
9D028C30  A3C20018   SB V0, 24(S8)
722:                 	if(!MACIsTxReady())
9D028C34  0F40727E   JAL MACIsTxReady
9D028C38  00000000   NOP
9D028C3C  14400004   BNE V0, ZERO, 0x9D028C50
9D028C40  00000000   NOP
723:                 		return 0;
9D028C44  00001021   ADDU V0, ZERO, ZERO
9D028C48  0B40A324   J 0x9D028C90
9D028C4C  00000000   NOP
724:                 
725:                 	if(LastPutSocket != s)
9D028C50  9382802B   LBU V0, -32725(GP)
9D028C54  93C30018   LBU V1, 24(S8)
9D028C58  10620007   BEQ V1, V0, 0x9D028C78
9D028C5C  00000000   NOP
726:                 	{
727:                 		LastPutSocket = s;
9D028C60  93C20018   LBU V0, 24(S8)
9D028C64  A382802B   SB V0, -32725(GP)
728:                 		UDPTxCount = 0;
9D028C68  A78081EA   SH ZERO, -32278(GP)
729:                 		UDPSetTxBuffer(0);
9D028C6C  00002021   ADDU A0, ZERO, ZERO
9D028C70  0F40A2E0   JAL UDPSetTxBuffer
9D028C74  00000000   NOP
730:                 	}
731:                 
732:                 	activeUDPSocket = s;
9D028C78  93C20018   LBU V0, 24(S8)
9D028C7C  A38281EC   SB V0, -32276(GP)
733:                 
734:                 	return MAC_TX_BUFFER_SIZE - sizeof(IP_HEADER) - sizeof(UDP_HEADER) - UDPTxCount;
9D028C80  978281EA   LHU V0, -32278(GP)
9D028C84  240305C0   ADDIU V1, ZERO, 1472
9D028C88  00621023   SUBU V0, V1, V0
9D028C8C  3042FFFF   ANDI V0, V0, -1
735:                 }
9D028C90  03C0E821   ADDU SP, S8, ZERO
9D028C94  8FBF0014   LW RA, 20(SP)
9D028C98  8FBE0010   LW S8, 16(SP)
9D028C9C  27BD0018   ADDIU SP, SP, 24
9D028CA0  03E00008   JR RA
9D028CA4  00000000   NOP
736:                 
737:                 /*****************************************************************************
738:                   Function:
739:                 	BOOL UDPPut(BYTE v)
740:                 
741:                   Summary:
742:                 	Writes a byte to the currently active socket.
743:                 	
744:                   Description:
745:                 	This function writes a single byte to the currently active UDP socket, 
746:                 	while incrementing the buffer length.  UDPIsPutReady should be used 
747:                 	before calling this function to specify the currently active socket.
748:                 
749:                   Precondition:
750:                 	UDPIsPutReady() was previously called to specify the current socket.
751:                 
752:                   Parameters:
753:                 	v - The byte to be loaded into the transmit buffer.
754:                 
755:                   Return Values:
756:                   	TRUE - The byte was successfully written to the socket.
757:                   	FALSE - The transmit buffer is already full and so the write failed.
758:                   ***************************************************************************/
759:                 BOOL UDPPut(BYTE v)
760:                 {
9D028CA8  27BDFFE8   ADDIU SP, SP, -24
9D028CAC  AFBF0014   SW RA, 20(SP)
9D028CB0  AFBE0010   SW S8, 16(SP)
9D028CB4  03A0F021   ADDU S8, SP, ZERO
9D028CB8  00801021   ADDU V0, A0, ZERO
9D028CBC  A3C20018   SB V0, 24(S8)
761:                 	// See if we are out of transmit space.
762:                 	if(wPutOffset >= (MAC_TX_BUFFER_SIZE - sizeof(IP_HEADER) - sizeof(UDP_HEADER)))
9D028CC0  978281B0   LHU V0, -32336(GP)
9D028CC4  2C4205C0   SLTIU V0, V0, 1472
9D028CC8  14400004   BNE V0, ZERO, 0x9D028CDC
9D028CCC  00000000   NOP
763:                 	{
764:                 		return FALSE;
9D028CD0  00001021   ADDU V0, ZERO, ZERO
9D028CD4  0B40A347   J 0x9D028D1C
9D028CD8  00000000   NOP
765:                 	}
766:                 
767:                     // Load application data byte
768:                     MACPut(v);
9D028CDC  93C20018   LBU V0, 24(S8)
9D028CE0  00402021   ADDU A0, V0, ZERO
9D028CE4  0F40758C   JAL MACPut
9D028CE8  00000000   NOP
769:                 	wPutOffset++;
9D028CEC  978281B0   LHU V0, -32336(GP)
9D028CF0  24420001   ADDIU V0, V0, 1
9D028CF4  3042FFFF   ANDI V0, V0, -1
9D028CF8  A78281B0   SH V0, -32336(GP)
770:                 	if(wPutOffset > UDPTxCount)
9D028CFC  978381B0   LHU V1, -32336(GP)
9D028D00  978281EA   LHU V0, -32278(GP)
9D028D04  0043102B   SLTU V0, V0, V1
9D028D08  10400003   BEQ V0, ZERO, 0x9D028D18
9D028D0C  00000000   NOP
771:                 		UDPTxCount = wPutOffset;
9D028D10  978281B0   LHU V0, -32336(GP)
9D028D14  A78281EA   SH V0, -32278(GP)
772:                 
773:                     return TRUE;
9D028D18  24020001   ADDIU V0, ZERO, 1
774:                 }
9D028D1C  03C0E821   ADDU SP, S8, ZERO
9D028D20  8FBF0014   LW RA, 20(SP)
9D028D24  8FBE0010   LW S8, 16(SP)
9D028D28  27BD0018   ADDIU SP, SP, 24
9D028D2C  03E00008   JR RA
9D028D30  00000000   NOP
775:                 
776:                 /*****************************************************************************
777:                   Function:
778:                 	WORD UDPPutArray(BYTE *cData, WORD wDataLen)
779:                 
780:                   Summary:
781:                 	Writes an array of bytes to the currently active socket.
782:                 	
783:                   Description:
784:                 	This function writes an array of bytes to the currently active UDP socket, 
785:                 	while incrementing the buffer length.  UDPIsPutReady should be used 
786:                 	before calling this function to specify the currently active socket.
787:                 
788:                   Precondition:
789:                 	UDPIsPutReady() was previously called to specify the current socket.
790:                 
791:                   Parameters:
792:                 	cData - The array to write to the socket.
793:                 	wDateLen - Number of bytes from cData to be written.
794:                 	
795:                   Returns:
796:                   	The number of bytes successfully placed in the UDP transmit buffer.  If
797:                   	this value is less than wDataLen, then the buffer became full and the
798:                   	input was truncated.
799:                   ***************************************************************************/
800:                 WORD UDPPutArray(BYTE *cData, WORD wDataLen)
801:                 {
9D028D34  27BDFFE0   ADDIU SP, SP, -32
9D028D38  AFBF001C   SW RA, 28(SP)
9D028D3C  AFBE0018   SW S8, 24(SP)
9D028D40  03A0F021   ADDU S8, SP, ZERO
9D028D44  AFC40020   SW A0, 32(S8)
9D028D48  00A01021   ADDU V0, A1, ZERO
9D028D4C  A7C20024   SH V0, 36(S8)
802:                 	WORD wTemp;
803:                 
804:                 	wTemp = (MAC_TX_BUFFER_SIZE - sizeof(IP_HEADER) - sizeof(UDP_HEADER)) - wPutOffset;
9D028D50  978281B0   LHU V0, -32336(GP)
9D028D54  240305C0   ADDIU V1, ZERO, 1472
9D028D58  00621023   SUBU V0, V1, V0
9D028D5C  A7C20010   SH V0, 16(S8)
805:                 	if(wTemp < wDataLen)
9D028D60  97C30010   LHU V1, 16(S8)
9D028D64  97C20024   LHU V0, 36(S8)
9D028D68  0062102B   SLTU V0, V1, V0
9D028D6C  10400003   BEQ V0, ZERO, 0x9D028D7C
9D028D70  00000000   NOP
806:                 		wDataLen = wTemp;
9D028D74  97C20010   LHU V0, 16(S8)
9D028D78  A7C20024   SH V0, 36(S8)
807:                 
808:                 	wPutOffset += wDataLen;
9D028D7C  978381B0   LHU V1, -32336(GP)
9D028D80  97C20024   LHU V0, 36(S8)
9D028D84  00621021   ADDU V0, V1, V0
9D028D88  3042FFFF   ANDI V0, V0, -1
9D028D8C  A78281B0   SH V0, -32336(GP)
809:                 	if(wPutOffset > UDPTxCount)
9D028D90  978381B0   LHU V1, -32336(GP)
9D028D94  978281EA   LHU V0, -32278(GP)
9D028D98  0043102B   SLTU V0, V0, V1
9D028D9C  10400003   BEQ V0, ZERO, 0x9D028DAC
9D028DA0  00000000   NOP
810:                 		UDPTxCount = wPutOffset;
9D028DA4  978281B0   LHU V0, -32336(GP)
9D028DA8  A78281EA   SH V0, -32278(GP)
811:                 
812:                     // Load application data bytes
813:                     MACPutArray(cData, wDataLen);
9D028DAC  97C20024   LHU V0, 36(S8)
9D028DB0  8FC40020   LW A0, 32(S8)
9D028DB4  00402821   ADDU A1, V0, ZERO
9D028DB8  0F40759D   JAL MACPutArray
9D028DBC  00000000   NOP
814:                 
815:                     return wDataLen;
9D028DC0  97C20024   LHU V0, 36(S8)
816:                 }
9D028DC4  03C0E821   ADDU SP, S8, ZERO
9D028DC8  8FBF001C   LW RA, 28(SP)
9D028DCC  8FBE0018   LW S8, 24(SP)
9D028DD0  27BD0020   ADDIU SP, SP, 32
9D028DD4  03E00008   JR RA
9D028DD8  00000000   NOP
817:                 
818:                 /*****************************************************************************
819:                   Function:
820:                 	WORD UDPPutROMArray(ROM BYTE *cData, WORD wDataLen)
821:                 
822:                   Summary:
823:                 	Writes an array of bytes from ROM to the currently active socket.
824:                 	
825:                   Description:
826:                 	This function writes an array of bytes from ROM to the currently active 
827:                 	UDP socket, while incrementing the buffer length.  UDPIsPutReady should 
828:                 	be used before calling this function to specify the currently active 
829:                 	socket.
830:                 
831:                   Precondition:
832:                 	UDPIsPutReady() was previously called to specify the current socket.
833:                 
834:                   Parameters:
835:                 	cData - The array to write to the socket.
836:                 	wDateLen - Number of bytes from cData to be written.
837:                 	
838:                   Returns:
839:                   	The number of bytes successfully placed in the UDP transmit buffer.  If
840:                   	this value is less than wDataLen, then the buffer became full and the
841:                   	input was truncated.
842:                   	
843:                   Remarks:
844:                 	This function is aliased to UDPPutArray on non-PIC18 platforms.
845:                   ***************************************************************************/
846:                 #if defined(__18CXX)
847:                 WORD UDPPutROMArray(ROM BYTE *cData, WORD wDataLen)
848:                 {
849:                 	WORD wTemp;
850:                 
851:                 	wTemp = (MAC_TX_BUFFER_SIZE - sizeof(IP_HEADER) - sizeof(UDP_HEADER)) - wPutOffset;
852:                 	if(wTemp < wDataLen)
853:                 		wDataLen = wTemp;
854:                 
855:                 	wPutOffset += wDataLen;
856:                 	if(wPutOffset > UDPTxCount)
857:                 		UDPTxCount = wPutOffset;
858:                 
859:                     // Load application data bytes
860:                     MACPutROMArray(cData, wDataLen);
861:                 
862:                     return wDataLen;
863:                 }
864:                 #endif
865:                 
866:                 /*****************************************************************************
867:                   Function:
868:                 	BYTE* UDPPutString(BYTE *strData)
869:                 
870:                   Summary:
871:                 	Writes null-terminated string to the currently active socket.
872:                 	
873:                   Description:
874:                 	This function writes a null-terminated string to the currently active 
875:                 	UDP socket, while incrementing the buffer length.  UDPIsPutReady should 
876:                 	be used before calling this function to specify the currently active
877:                 	socket.
878:                 
879:                   Precondition:
880:                 	UDPIsPutReady() was previously called to specify the current socket.
881:                 
882:                   Parameters:
883:                 	cData - Pointer to the string to be written to the socket.
884:                 	
885:                   Returns:
886:                   	A pointer to the byte following the last byte written.  Note that this
887:                   	is different than the UDPPutArray functions.  If this pointer does not
888:                   	dereference to a NULL byte, then the buffer became full and the input
889:                   	data was truncated.
890:                   ***************************************************************************/
891:                 BYTE* UDPPutString(BYTE *strData)
892:                 {
9D028DDC  27BDFFE8   ADDIU SP, SP, -24
9D028DE0  AFBF0014   SW RA, 20(SP)
9D028DE4  AFBE0010   SW S8, 16(SP)
9D028DE8  03A0F021   ADDU S8, SP, ZERO
9D028DEC  AFC40018   SW A0, 24(S8)
893:                 	return strData + UDPPutArray(strData, strlen((char*)strData));
9D028DF0  8FC20018   LW V0, 24(S8)
9D028DF4  00402021   ADDU A0, V0, ZERO
9D028DF8  0F40D2F2   JAL 0x9D034BC8
9D028DFC  00000000   NOP
9D028E00  3042FFFF   ANDI V0, V0, -1
9D028E04  8FC40018   LW A0, 24(S8)
9D028E08  00402821   ADDU A1, V0, ZERO
9D028E0C  0F40A34D   JAL UDPPutArray
9D028E10  00000000   NOP
9D028E14  8FC30018   LW V1, 24(S8)
9D028E18  00621021   ADDU V0, V1, V0
894:                 }
9D028E1C  03C0E821   ADDU SP, S8, ZERO
9D028E20  8FBF0014   LW RA, 20(SP)
9D028E24  8FBE0010   LW S8, 16(SP)
9D028E28  27BD0018   ADDIU SP, SP, 24
9D028E2C  03E00008   JR RA
9D028E30  00000000   NOP
895:                 
896:                 /*****************************************************************************
897:                   Function:
898:                 	BYTE* UDPPutString(BYTE *strData)
899:                 
900:                   Summary:
901:                 	Writes null-terminated string from ROM to the currently active socket.
902:                 	
903:                   Description:
904:                 	This function writes a null-terminated string from ROM to the currently
905:                 	active UDP socket, while incrementing the buffer length.  UDPIsPutReady
906:                 	should be used before calling this function to specify the currently
907:                 	active socket.
908:                 
909:                   Precondition:
910:                 	UDPIsPutReady() was previously called to specify the current socket.
911:                 
912:                   Parameters:
913:                 	cData - Pointer to the string to be written to the socket.
914:                 	
915:                   Returns:
916:                   	A pointer to the byte following the last byte written.  Note that this
917:                   	is different than the UDPPutArray functions.  If this pointer does not
918:                   	dereference to a NULL byte, then the buffer became full and the input
919:                   	data was truncated.
920:                   
921:                   Remarks:
922:                 	This function is aliased to UDPPutString on non-PIC18 platforms.
923:                   ***************************************************************************/
924:                 #if defined(__18CXX)
925:                 ROM BYTE* UDPPutROMString(ROM BYTE *strData)
926:                 {
927:                 	return strData + UDPPutROMArray(strData, strlenpgm((ROM char*)strData));
928:                 }
929:                 #endif
930:                 
931:                 /*****************************************************************************
932:                   Function:
933:                 	void UDPFlush(void)
934:                 
935:                   Summary:
936:                 	Transmits all pending data in a UDP socket.
937:                 	
938:                   Description:
939:                 	This function builds a UDP packet with the pending TX data and marks it 
940:                 	for transmission over the network interface.  Since UDP is a frame-based
941:                 	protocol, this function must be called before returning to the main
942:                 	stack loop whenever any data is written.
943:                 
944:                   Precondition:
945:                 	UDPIsPutReady() was previously called to specify the current socket, and
946:                 	data has been written to the socket using the UDPPut family of functions.
947:                 
948:                   Parameters:
949:                 	None
950:                 	
951:                   Returns:
952:                   	None
953:                 
954:                   Remarks:
955:                 	Note that unlike TCPFlush, UDPFlush must be called before returning to 
956:                 	the main stack loop.  There is no auto transmit for UDP segments.
957:                   ***************************************************************************/
958:                 void UDPFlush(void)
959:                 {
9D028E34  27BDFFC0   ADDIU SP, SP, -64
9D028E38  AFBF003C   SW RA, 60(SP)
9D028E3C  AFBE0038   SW S8, 56(SP)
9D028E40  03A0F021   ADDU S8, SP, ZERO
960:                     UDP_HEADER      h;
961:                     UDP_SOCKET_INFO *p;
962:                     WORD			wUDPLength;
963:                 
964:                     p = &UDPSocketInfo[activeUDPSocket];
9D028E44  938281EC   LBU V0, -32276(GP)
9D028E48  00401821   ADDU V1, V0, ZERO
9D028E4C  2402001C   ADDIU V0, ZERO, 28
9D028E50  70621802   MUL V1, V1, V0
9D028E54  3C02A000   LUI V0, -24576
9D028E58  24420648   ADDIU V0, V0, 1608
9D028E5C  00621021   ADDU V0, V1, V0
9D028E60  AFC20010   SW V0, 16(S8)
965:                 
966:                 	wUDPLength = UDPTxCount + sizeof(UDP_HEADER);
9D028E64  978281EA   LHU V0, -32278(GP)
9D028E68  24420008   ADDIU V0, V0, 8
9D028E6C  A7C20014   SH V0, 20(S8)
967:                 
968:                 	// Generate the correct UDP header
969:                     h.SourcePort        = swaps(p->localPort);
9D028E70  8FC20010   LW V0, 16(S8)
9D028E74  9442000E   LHU V0, 14(V0)
9D028E78  00402021   ADDU A0, V0, ZERO
9D028E7C  0F409A16   JAL swaps
9D028E80  00000000   NOP
9D028E84  A7C2001C   SH V0, 28(S8)
970:                     h.DestinationPort   = swaps(p->remotePort);
9D028E88  8FC20010   LW V0, 16(S8)
9D028E8C  9442000C   LHU V0, 12(V0)
9D028E90  00402021   ADDU A0, V0, ZERO
9D028E94  0F409A16   JAL swaps
9D028E98  00000000   NOP
9D028E9C  A7C2001E   SH V0, 30(S8)
971:                     h.Length            = swaps(wUDPLength);
9D028EA0  97C20014   LHU V0, 20(S8)
9D028EA4  00402021   ADDU A0, V0, ZERO
9D028EA8  0F409A16   JAL swaps
9D028EAC  00000000   NOP
9D028EB0  A7C20020   SH V0, 32(S8)
972:                 	h.Checksum 			= 0x0000;
9D028EB4  A7C00022   SH ZERO, 34(S8)
973:                     
974:                 	// Calculate IP pseudoheader checksum if we are going to enable 
975:                 	// the checksum field
976:                 	#if defined(UDP_USE_TX_CHECKSUM)
977:                 	{
978:                 		PSEUDO_HEADER   pseudoHeader;
979:                 		
980:                 		pseudoHeader.SourceAddress	= AppConfig.MyIPAddr;
9D028EB8  3C02A000   LUI V0, -24576
9D028EBC  24430728   ADDIU V1, V0, 1832
9D028EC0  88630003   LWL V1, 3(V1)
9D028EC4  00602021   ADDU A0, V1, ZERO
9D028EC8  98440728   LWR A0, 1832(V0)
9D028ECC  00801021   ADDU V0, A0, ZERO
9D028ED0  AFC20024   SW V0, 36(S8)
981:                 		pseudoHeader.DestAddress    = p->remote.remoteNode.IPAddr;
9D028ED4  8FC20010   LW V0, 16(S8)
9D028ED8  8C420000   LW V0, 0(V0)
9D028EDC  AFC20028   SW V0, 40(S8)
982:                 		pseudoHeader.Zero           = 0x0;
9D028EE0  A3C0002C   SB ZERO, 44(S8)
983:                 		pseudoHeader.Protocol       = IP_PROT_UDP;
9D028EE4  24020011   ADDIU V0, ZERO, 17
9D028EE8  A3C2002D   SB V0, 45(S8)
984:                 		pseudoHeader.Length			= wUDPLength;
9D028EEC  97C20014   LHU V0, 20(S8)
9D028EF0  A7C2002E   SH V0, 46(S8)
985:                 		SwapPseudoHeader(pseudoHeader);
9D028EF4  97C2002E   LHU V0, 46(S8)
9D028EF8  00402021   ADDU A0, V0, ZERO
9D028EFC  0F409A16   JAL swaps
9D028F00  00000000   NOP
9D028F04  A7C2002E   SH V0, 46(S8)
986:                 		h.Checksum = ~CalcIPChecksum((BYTE*)&pseudoHeader, sizeof(pseudoHeader));
9D028F08  27C20024   ADDIU V0, S8, 36
9D028F0C  00402021   ADDU A0, V0, ZERO
9D028F10  2405000C   ADDIU A1, ZERO, 12
9D028F14  0F409A63   JAL CalcIPChecksum
9D028F18  00000000   NOP
9D028F1C  00021027   NOR V0, ZERO, V0
9D028F20  3042FFFF   ANDI V0, V0, -1
9D028F24  A7C20022   SH V0, 34(S8)
987:                 	}
988:                 	#endif
989:                 
990:                 	// Position the hardware write pointer where we will need to 
991:                 	// begin writing the IP header
992:                 	MACSetWritePtr(BASE_TX_ADDR + sizeof(ETHER_HEADER));
9D028F28  2404000E   ADDIU A0, ZERO, 14
9D028F2C  0F407410   JAL MACSetWritePtr
9D028F30  00000000   NOP
993:                 	
994:                 	// Write IP header to packet
995:                 	IPPutHeader(&p->remote.remoteNode, IP_PROT_UDP, wUDPLength);
9D028F34  8FC30010   LW V1, 16(S8)
9D028F38  97C20014   LHU V0, 20(S8)
9D028F3C  00602021   ADDU A0, V1, ZERO
9D028F40  24050011   ADDIU A1, ZERO, 17
9D028F44  00403021   ADDU A2, V0, ZERO
9D028F48  0F40CEA6   JAL IPPutHeader
9D028F4C  00000000   NOP
996:                 
997:                     // Write UDP header to packet
998:                     MACPutArray((BYTE*)&h, sizeof(h));
9D028F50  27C2001C   ADDIU V0, S8, 28
9D028F54  00402021   ADDU A0, V0, ZERO
9D028F58  24050008   ADDIU A1, ZERO, 8
9D028F5C  0F40759D   JAL MACPutArray
9D028F60  00000000   NOP
999:                     
1000:                	// Calculate the final UDP checksum and write it in, if enabled
1001:                	#if defined(UDP_USE_TX_CHECKSUM)
1002:                	{
1003:                        PTR_BASE	wReadPtrSave;
1004:                        WORD		wChecksum;
1005:                
1006:                		wReadPtrSave = MACSetReadPtr(BASE_TX_ADDR + sizeof(ETHER_HEADER) + sizeof(IP_HEADER));
9D028F64  24040022   ADDIU A0, ZERO, 34
9D028F68  0F407426   JAL MACSetReadPtr
9D028F6C  00000000   NOP
9D028F70  AFC20018   SW V0, 24(S8)
1007:                		wChecksum = CalcIPBufferChecksum(wUDPLength);
9D028F74  97C20014   LHU V0, 20(S8)
9D028F78  00402021   ADDU A0, V0, ZERO
9D028F7C  0F40748E   JAL CalcIPBufferChecksum
9D028F80  00000000   NOP
9D028F84  A7C20030   SH V0, 48(S8)
1008:                		if(wChecksum == 0x0000u)
9D028F88  97C20030   LHU V0, 48(S8)
9D028F8C  14400003   BNE V0, ZERO, 0x9D028F9C
9D028F90  00000000   NOP
1009:                			wChecksum = 0xFFFF;
9D028F94  2402FFFF   ADDIU V0, ZERO, -1
9D028F98  A7C20030   SH V0, 48(S8)
1010:                		MACSetReadPtr(wReadPtrSave);
9D028F9C  8FC40018   LW A0, 24(S8)
9D028FA0  0F407426   JAL MACSetReadPtr
9D028FA4  00000000   NOP
1011:                		MACSetWritePtr(BASE_TX_ADDR + sizeof(ETHER_HEADER) + sizeof(IP_HEADER) + 6);	// 6 is the offset to the Checksum field in UDP_HEADER
9D028FA8  24040028   ADDIU A0, ZERO, 40
9D028FAC  0F407410   JAL MACSetWritePtr
9D028FB0  00000000   NOP
1012:                		MACPutArray((BYTE*)&wChecksum, sizeof(wChecksum));
9D028FB4  27C20030   ADDIU V0, S8, 48
9D028FB8  00402021   ADDU A0, V0, ZERO
9D028FBC  24050002   ADDIU A1, ZERO, 2
9D028FC0  0F40759D   JAL MACPutArray
9D028FC4  00000000   NOP
1013:                	}
1014:                	#endif
1015:                    
1016:                	// Transmit the packet
1017:                    MACFlush();
9D028FC8  0F4073B4   JAL MACFlush
9D028FCC  00000000   NOP
1018:                
1019:                	// Reset packet size counter for the next TX operation
1020:                    UDPTxCount = 0;
9D028FD0  A78081EA   SH ZERO, -32278(GP)
1021:                	LastPutSocket = INVALID_UDP_SOCKET;
9D028FD4  2402FFFF   ADDIU V0, ZERO, -1
9D028FD8  A382802B   SB V0, -32725(GP)
1022:                }
9D028FDC  03C0E821   ADDU SP, S8, ZERO
9D028FE0  8FBF003C   LW RA, 60(SP)
9D028FE4  8FBE0038   LW S8, 56(SP)
9D028FE8  27BD0040   ADDIU SP, SP, 64
9D028FEC  03E00008   JR RA
9D028FF0  00000000   NOP
1023:                
1024:                
1025:                
1026:                /****************************************************************************
1027:                  Section:
1028:                	Receive Functions
1029:                  ***************************************************************************/
1030:                
1031:                /*****************************************************************************
1032:                  Function:
1033:                	WORD UDPIsGetReady(UDP_SOCKET s)
1034:                
1035:                  Summary:
1036:                	Determines how many bytes can be read from the UDP socket.
1037:                	
1038:                  Description:
1039:                	This function determines if bytes can be read from the specified UDP
1040:                	socket.  It also prepares the UDP module for reading by setting the 
1041:                	indicated socket as the currently active connection.
1042:                
1043:                  Precondition:
1044:                	UDPInit() must have been previously called.
1045:                
1046:                  Parameters:
1047:                	s - The socket to be made active (which has already been opened or is
1048:                		listening)
1049:                
1050:                  Returns:
1051:                  	The number of bytes that can be read from this socket.
1052:                  ***************************************************************************/
1053:                WORD UDPIsGetReady(UDP_SOCKET s)
1054:                {
9D028FF4  27BDFFE8   ADDIU SP, SP, -24
9D028FF8  AFBF0014   SW RA, 20(SP)
9D028FFC  AFBE0010   SW S8, 16(SP)
9D029000  03A0F021   ADDU S8, SP, ZERO
9D029004  00801021   ADDU V0, A0, ZERO
9D029008  A3C20018   SB V0, 24(S8)
1055:                    activeUDPSocket = s;
9D02900C  93C20018   LBU V0, 24(S8)
9D029010  A38281EC   SB V0, -32276(GP)
1056:                	if(SocketWithRxData != s)
9D029014  9382802C   LBU V0, -32724(GP)
9D029018  93C30018   LBU V1, 24(S8)
9D02901C  10620004   BEQ V1, V0, 0x9D029030
9D029020  00000000   NOP
1057:                		return 0;
9D029024  00001021   ADDU V0, ZERO, ZERO
9D029028  0B40A41B   J 0x9D02906C
9D02902C  00000000   NOP
1058:                
1059:                    // If this is the very first time we are accessing this packet, 
1060:                    // move the read point to the begining of the packet.
1061:                    if(Flags.bFirstRead)
9D029030  938281B4   LBU V0, -32332(GP)
9D029034  30420001   ANDI V0, V0, 1
9D029038  304200FF   ANDI V0, V0, 255
9D02903C  10400007   BEQ V0, ZERO, 0x9D02905C
9D029040  00000000   NOP
1062:                    {
1063:                        Flags.bFirstRead = 0;
9D029044  938281B4   LBU V0, -32332(GP)
9D029048  7C020004   INS V0, ZERO, 0, 1
9D02904C  A38281B4   SB V0, -32332(GP)
1064:                        UDPSetRxBuffer(0);
9D029050  00002021   ADDU A0, ZERO, ZERO
9D029054  0F40A2F3   JAL UDPSetRxBuffer
9D029058  00000000   NOP
1065:                    }
1066:                
1067:                    return UDPRxCount - wGetOffset;
9D02905C  978381EE   LHU V1, -32274(GP)
9D029060  978281B2   LHU V0, -32334(GP)
9D029064  00621023   SUBU V0, V1, V0
9D029068  3042FFFF   ANDI V0, V0, -1
1068:                }
9D02906C  03C0E821   ADDU SP, S8, ZERO
9D029070  8FBF0014   LW RA, 20(SP)
9D029074  8FBE0010   LW S8, 16(SP)
9D029078  27BD0018   ADDIU SP, SP, 24
9D02907C  03E00008   JR RA
9D029080  00000000   NOP
1069:                
1070:                /*****************************************************************************
1071:                  Function:
1072:                	BOOL UDPGet(BYTE *v)
1073:                
1074:                  Summary:
1075:                	Reads a byte from the currently active socket.
1076:                	
1077:                  Description:
1078:                	This function reads a single byte from the currently active UDP socket, 
1079:                	while decrementing the remaining buffer length.  UDPIsGetReady should be 
1080:                	used before calling this function to specify the currently active socket.
1081:                
1082:                  Precondition:
1083:                	UDPIsGetReady() was previously called to specify the current socket.
1084:                
1085:                  Parameters:
1086:                	v - The buffer to receive the data being read.
1087:                
1088:                  Return Values:
1089:                  	TRUE - A byte was successfully read
1090:                  	FALSE - No data remained in the read buffer
1091:                  ***************************************************************************/
1092:                BOOL UDPGet(BYTE *v)
1093:                {
9D029084  27BDFFE8   ADDIU SP, SP, -24
9D029088  AFBF0014   SW RA, 20(SP)
9D02908C  AFBE0010   SW S8, 16(SP)
9D029090  03A0F021   ADDU S8, SP, ZERO
9D029094  AFC40018   SW A0, 24(S8)
1094:                	// Make sure that there is data to return
1095:                    if((wGetOffset >= UDPRxCount) || (SocketWithRxData != activeUDPSocket))
9D029098  978381B2   LHU V1, -32334(GP)
9D02909C  978281EE   LHU V0, -32274(GP)
9D0290A0  0062102B   SLTU V0, V1, V0
9D0290A4  10400005   BEQ V0, ZERO, 0x9D0290BC
9D0290A8  00000000   NOP
9D0290AC  9383802C   LBU V1, -32724(GP)
9D0290B0  938281EC   LBU V0, -32276(GP)
9D0290B4  10620004   BEQ V1, V0, 0x9D0290C8
9D0290B8  00000000   NOP
1096:                        return FALSE;
9D0290BC  00001021   ADDU V0, ZERO, ZERO
9D0290C0  0B40A43C   J 0x9D0290F0
9D0290C4  00000000   NOP
1097:                
1098:                    *v = MACGet();
9D0290C8  0F40754F   JAL MACGet
9D0290CC  00000000   NOP
9D0290D0  00401821   ADDU V1, V0, ZERO
9D0290D4  8FC20018   LW V0, 24(S8)
9D0290D8  A0430000   SB V1, 0(V0)
1099:                    wGetOffset++;
9D0290DC  978281B2   LHU V0, -32334(GP)
9D0290E0  24420001   ADDIU V0, V0, 1
9D0290E4  3042FFFF   ANDI V0, V0, -1
9D0290E8  A78281B2   SH V0, -32334(GP)
1100:                
1101:                    return TRUE;
9D0290EC  24020001   ADDIU V0, ZERO, 1
1102:                }
9D0290F0  03C0E821   ADDU SP, S8, ZERO
9D0290F4  8FBF0014   LW RA, 20(SP)
9D0290F8  8FBE0010   LW S8, 16(SP)
9D0290FC  27BD0018   ADDIU SP, SP, 24
9D029100  03E00008   JR RA
9D029104  00000000   NOP
1103:                
1104:                
1105:                /*****************************************************************************
1106:                  Function:
1107:                	WORD UDPGetArray(BYTE *cData, WORD wDataLen)
1108:                
1109:                  Summary:
1110:                	Reads an array of bytes from the currently active socket.
1111:                	
1112:                  Description:
1113:                	This function reads an array of bytes from the currently active UDP socket, 
1114:                	while decrementing the remaining bytes available. UDPIsGetReady should be 
1115:                	used before calling this function to specify the currently active socket.
1116:                
1117:                  Precondition:
1118:                	UDPIsGetReady() was previously called to specify the current socket.
1119:                
1120:                  Parameters:
1121:                	cData - The buffer to receive the bytes being read.  If NULL, the bytes are 
1122:                			simply discarded without being written anywhere (effectively skips 
1123:                			over the bytes in the RX buffer, although if you need to skip a lot 
1124:                			of data, seeking using the UDPSetRxBuffer() will be more efficient).
1125:                	wDateLen - Number of bytes to be read from the socket.
1126:                	
1127:                  Returns:
1128:                  	The number of bytes successfully read from the UDP buffer.  If this
1129:                  	value is less than wDataLen, then the buffer was emptied and no more 
1130:                  	data is available.
1131:                  ***************************************************************************/
1132:                WORD UDPGetArray(BYTE *cData, WORD wDataLen)
1133:                {
9D029108  27BDFFE0   ADDIU SP, SP, -32
9D02910C  AFBF001C   SW RA, 28(SP)
9D029110  AFBE0018   SW S8, 24(SP)
9D029114  03A0F021   ADDU S8, SP, ZERO
9D029118  AFC40020   SW A0, 32(S8)
9D02911C  00A01021   ADDU V0, A1, ZERO
9D029120  A7C20024   SH V0, 36(S8)
1134:                	WORD wBytesAvailable;
1135:                	
1136:                	// Make sure that there is data to return
1137:                    if((wGetOffset >= UDPRxCount) || (SocketWithRxData != activeUDPSocket))
9D029124  978381B2   LHU V1, -32334(GP)
9D029128  978281EE   LHU V0, -32274(GP)
9D02912C  0062102B   SLTU V0, V1, V0
9D029130  10400005   BEQ V0, ZERO, 0x9D029148
9D029134  00000000   NOP
9D029138  9383802C   LBU V1, -32724(GP)
9D02913C  938281EC   LBU V0, -32276(GP)
9D029140  10620004   BEQ V1, V0, 0x9D029154
9D029144  00000000   NOP
1138:                		return 0;
9D029148  00001021   ADDU V0, ZERO, ZERO
9D02914C  0B40A46C   J 0x9D0291B0
9D029150  00000000   NOP
1139:                
1140:                	// Make sure we don't try to read more data than exists
1141:                	wBytesAvailable = UDPRxCount - wGetOffset;
9D029154  978381EE   LHU V1, -32274(GP)
9D029158  978281B2   LHU V0, -32334(GP)
9D02915C  00621023   SUBU V0, V1, V0
9D029160  A7C20010   SH V0, 16(S8)
1142:                	if(wBytesAvailable < wDataLen)
9D029164  97C30010   LHU V1, 16(S8)
9D029168  97C20024   LHU V0, 36(S8)
9D02916C  0062102B   SLTU V0, V1, V0
9D029170  10400003   BEQ V0, ZERO, 0x9D029180
9D029174  00000000   NOP
1143:                		wDataLen = wBytesAvailable;
9D029178  97C20010   LHU V0, 16(S8)
9D02917C  A7C20024   SH V0, 36(S8)
1144:                
1145:                	wDataLen = MACGetArray(cData, wDataLen);
9D029180  97C20024   LHU V0, 36(S8)
9D029184  8FC40020   LW A0, 32(S8)
9D029188  00402821   ADDU A1, V0, ZERO
9D02918C  0F407560   JAL MACGetArray
9D029190  00000000   NOP
9D029194  A7C20024   SH V0, 36(S8)
1146:                    wGetOffset += wDataLen;
9D029198  978381B2   LHU V1, -32334(GP)
9D02919C  97C20024   LHU V0, 36(S8)
9D0291A0  00621021   ADDU V0, V1, V0
9D0291A4  3042FFFF   ANDI V0, V0, -1
9D0291A8  A78281B2   SH V0, -32334(GP)
1147:                
1148:                    return wDataLen;
9D0291AC  97C20024   LHU V0, 36(S8)
1149:                }
9D0291B0  03C0E821   ADDU SP, S8, ZERO
9D0291B4  8FBF001C   LW RA, 28(SP)
9D0291B8  8FBE0018   LW S8, 24(SP)
9D0291BC  27BD0020   ADDIU SP, SP, 32
9D0291C0  03E00008   JR RA
9D0291C4  00000000   NOP
1150:                
1151:                /*****************************************************************************
1152:                  Function:
1153:                	void UDPDiscard(void)
1154:                
1155:                  Summary:
1156:                	Discards any remaining RX data from a UDP socket.
1157:                	
1158:                  Description:
1159:                	This function discards any remaining received data in the currently 
1160:                	active UDP socket.
1161:                
1162:                  Precondition:
1163:                	UDPIsGetReady() was previously called to select the currently active
1164:                	socket.
1165:                
1166:                  Parameters:
1167:                	None
1168:                	
1169:                  Returns:
1170:                  	None
1171:                
1172:                  Remarks:
1173:                	It is safe to call this function more than is necessary.  If no data is
1174:                	available, this function does nothing.
1175:                  ***************************************************************************/
1176:                void UDPDiscard(void)
1177:                {
9D0291C8  27BDFFE8   ADDIU SP, SP, -24
9D0291CC  AFBF0014   SW RA, 20(SP)
9D0291D0  AFBE0010   SW S8, 16(SP)
9D0291D4  03A0F021   ADDU S8, SP, ZERO
1178:                	if(!Flags.bWasDiscarded)
9D0291D8  938281B4   LBU V0, -32332(GP)
9D0291DC  30420002   ANDI V0, V0, 2
9D0291E0  304200FF   ANDI V0, V0, 255
9D0291E4  1440000A   BNE V0, ZERO, 0x9D029210
9D0291E8  00000000   NOP
1179:                	{
1180:                		MACDiscardRx();
9D0291EC  0F40728D   JAL MACDiscardRx
9D0291F0  00000000   NOP
1181:                		UDPRxCount = 0;
9D0291F4  A78081EE   SH ZERO, -32274(GP)
1182:                		SocketWithRxData = INVALID_UDP_SOCKET;
9D0291F8  2402FFFF   ADDIU V0, ZERO, -1
9D0291FC  A382802C   SB V0, -32724(GP)
1183:                		Flags.bWasDiscarded = 1;
9D029200  938281B4   LBU V0, -32332(GP)
9D029204  24030001   ADDIU V1, ZERO, 1
9D029208  7C620844   INS V0, V1, 1, 1
9D02920C  A38281B4   SB V0, -32332(GP)
1184:                	}
1185:                }
9D029210  03C0E821   ADDU SP, S8, ZERO
9D029214  8FBF0014   LW RA, 20(SP)
9D029218  8FBE0010   LW S8, 16(SP)
9D02921C  27BD0018   ADDIU SP, SP, 24
9D029220  03E00008   JR RA
9D029224  00000000   NOP
1186:                
1187:                
1188:                
1189:                /****************************************************************************
1190:                  Section:
1191:                	Data Processing Functions
1192:                  ***************************************************************************/
1193:                
1194:                /*****************************************************************************
1195:                  Function:
1196:                	BOOL UDPProcess(NODE_INFO *remoteNode, IP_ADDR *localIP, WORD len)
1197:                
1198:                  Summary:
1199:                	Handles an incoming UDP segment.
1200:                	
1201:                  Description:
1202:                	This function handles an incoming UDP segment to determine if it is 
1203:                	acceptable and should be handed to one of the stack applications for
1204:                	processing.
1205:                
1206:                  Precondition:
1207:                	UDPInit() has been called an a UDP segment is ready in the MAC buffer.
1208:                
1209:                  Parameters:
1210:                	remoteNode - The remote node that sent this segment.
1211:                	localIP - The destination IP address for this segment.
1212:                	len - Total length of the UDP segment.
1213:                	
1214:                  Return Values:
1215:                  	TRUE - A valid packet is waiting and the stack applications should be
1216:                  		called to handle it.
1217:                  	FALSE - The packet was discarded.
1218:                  ***************************************************************************/
1219:                BOOL UDPProcess(NODE_INFO *remoteNode, IP_ADDR *localIP, WORD len)
1220:                {
9D029228  27BDFFC8   ADDIU SP, SP, -56
9D02922C  AFBF0034   SW RA, 52(SP)
9D029230  AFBE0030   SW S8, 48(SP)
9D029234  03A0F021   ADDU S8, SP, ZERO
9D029238  AFC40038   SW A0, 56(S8)
9D02923C  AFC5003C   SW A1, 60(S8)
9D029240  00C01021   ADDU V0, A2, ZERO
9D029244  A7C20040   SH V0, 64(S8)
1221:                    UDP_HEADER		h;
1222:                    UDP_SOCKET		s;
1223:                    PSEUDO_HEADER	pseudoHeader;
1224:                    DWORD_VAL		checksums;
1225:                
1226:                	UDPRxCount = 0;
9D029248  A78081EE   SH ZERO, -32274(GP)
1227:                
1228:                    // Retrieve UDP header.
1229:                    MACGetArray((BYTE*)&h, sizeof(h));
9D02924C  27C20014   ADDIU V0, S8, 20
9D029250  00402021   ADDU A0, V0, ZERO
9D029254  24050008   ADDIU A1, ZERO, 8
9D029258  0F407560   JAL MACGetArray
9D02925C  00000000   NOP
1230:                
1231:                    h.SourcePort        = swaps(h.SourcePort);
9D029260  97C20014   LHU V0, 20(S8)
9D029264  00402021   ADDU A0, V0, ZERO
9D029268  0F409A16   JAL swaps
9D02926C  00000000   NOP
9D029270  A7C20014   SH V0, 20(S8)
1232:                    h.DestinationPort   = swaps(h.DestinationPort);
9D029274  97C20016   LHU V0, 22(S8)
9D029278  00402021   ADDU A0, V0, ZERO
9D02927C  0F409A16   JAL swaps
9D029280  00000000   NOP
9D029284  A7C20016   SH V0, 22(S8)
1233:                    h.Length            = swaps(h.Length) - sizeof(UDP_HEADER);
9D029288  97C20018   LHU V0, 24(S8)
9D02928C  00402021   ADDU A0, V0, ZERO
9D029290  0F409A16   JAL swaps
9D029294  00000000   NOP
9D029298  2442FFF8   ADDIU V0, V0, -8
9D02929C  3042FFFF   ANDI V0, V0, -1
9D0292A0  A7C20018   SH V0, 24(S8)
1234:                
1235:                	// See if we need to validate the checksum field (0x0000 is disabled)
1236:                	if(h.Checksum)
9D0292A4  97C2001A   LHU V0, 26(S8)
9D0292A8  1040002D   BEQ V0, ZERO, 0x9D029360
9D0292AC  00000000   NOP
1237:                	{
1238:                	    // Calculate IP pseudoheader checksum.
1239:                	    pseudoHeader.SourceAddress		= remoteNode->IPAddr;
9D0292B0  8FC20038   LW V0, 56(S8)
9D0292B4  88430003   LWL V1, 3(V0)
9D0292B8  00602021   ADDU A0, V1, ZERO
9D0292BC  98440000   LWR A0, 0(V0)
9D0292C0  00801021   ADDU V0, A0, ZERO
9D0292C4  AFC2001C   SW V0, 28(S8)
1240:                	    pseudoHeader.DestAddress.Val	= localIP->Val;
9D0292C8  8FC2003C   LW V0, 60(S8)
9D0292CC  8C420000   LW V0, 0(V0)
9D0292D0  AFC20020   SW V0, 32(S8)
1241:                	    pseudoHeader.Zero				= 0x0;
9D0292D4  A3C00024   SB ZERO, 36(S8)
1242:                	    pseudoHeader.Protocol			= IP_PROT_UDP;
9D0292D8  24020011   ADDIU V0, ZERO, 17
9D0292DC  A3C20025   SB V0, 37(S8)
1243:                	    pseudoHeader.Length				= len;
9D0292E0  97C20040   LHU V0, 64(S8)
9D0292E4  A7C20026   SH V0, 38(S8)
1244:                
1245:                	    SwapPseudoHeader(pseudoHeader);
9D0292E8  97C20026   LHU V0, 38(S8)
9D0292EC  00402021   ADDU A0, V0, ZERO
9D0292F0  0F409A16   JAL swaps
9D0292F4  00000000   NOP
9D0292F8  A7C20026   SH V0, 38(S8)
1246:                	
1247:                	    checksums.w[0] = ~CalcIPChecksum((BYTE*)&pseudoHeader,
9D0292FC  27C2001C   ADDIU V0, S8, 28
9D029300  00402021   ADDU A0, V0, ZERO
9D029304  2405000C   ADDIU A1, ZERO, 12
9D029308  0F409A63   JAL CalcIPChecksum
9D02930C  00000000   NOP
9D029310  00021027   NOR V0, ZERO, V0
9D029314  3042FFFF   ANDI V0, V0, -1
9D029318  A7C20028   SH V0, 40(S8)
1248:                	                                    sizeof(pseudoHeader));
1249:                	
1250:                	
1251:                	    // Now calculate UDP packet checksum in NIC RAM -- should match pseudoHeader
1252:                	    IPSetRxBuffer(0);
9D02931C  00002021   ADDU A0, ZERO, ZERO
9D029320  0F40CEF1   JAL IPSetRxBuffer
9D029324  00000000   NOP
1253:                	    checksums.w[1] = CalcIPBufferChecksum(len);
9D029328  97C20040   LHU V0, 64(S8)
9D02932C  00402021   ADDU A0, V0, ZERO
9D029330  0F40748E   JAL CalcIPBufferChecksum
9D029334  00000000   NOP
9D029338  A7C2002A   SH V0, 42(S8)
1254:                	
1255:                	    if(checksums.w[0] != checksums.w[1])
9D02933C  97C30028   LHU V1, 40(S8)
9D029340  97C2002A   LHU V0, 42(S8)
9D029344  10620006   BEQ V1, V0, 0x9D029360
9D029348  00000000   NOP
1256:                	    {
1257:                	        MACDiscardRx();
9D02934C  0F40728D   JAL MACDiscardRx
9D029350  00000000   NOP
1258:                	        return FALSE;
9D029354  00001021   ADDU V0, ZERO, ZERO
9D029358  0B40A4F4   J 0x9D0293D0
9D02935C  00000000   NOP
1259:                	    }
1260:                	}
1261:                
1262:                    s = FindMatchingSocket(&h, remoteNode, localIP);
9D029360  27C20014   ADDIU V0, S8, 20
9D029364  00402021   ADDU A0, V0, ZERO
9D029368  8FC50038   LW A1, 56(S8)
9D02936C  8FC6003C   LW A2, 60(S8)
9D029370  0F40A4FA   JAL 0x9D0293E8
9D029374  00000000   NOP
9D029378  A3C20010   SB V0, 16(S8)
1263:                    if(s == INVALID_UDP_SOCKET)
9D02937C  93C30010   LBU V1, 16(S8)
9D029380  240200FF   ADDIU V0, ZERO, 255
9D029384  14620006   BNE V1, V0, 0x9D0293A0
9D029388  00000000   NOP
1264:                    {
1265:                        // If there is no matching socket, There is no one to handle
1266:                        // this data.  Discard it.
1267:                        MACDiscardRx();
9D02938C  0F40728D   JAL MACDiscardRx
9D029390  00000000   NOP
1268:                		return FALSE;
9D029394  00001021   ADDU V0, ZERO, ZERO
9D029398  0B40A4F4   J 0x9D0293D0
9D02939C  00000000   NOP
1269:                    }
1270:                    else
1271:                    {
1272:                		SocketWithRxData = s;
9D0293A0  93C20010   LBU V0, 16(S8)
9D0293A4  A382802C   SB V0, -32724(GP)
1273:                        UDPRxCount = h.Length;
9D0293A8  97C20018   LHU V0, 24(S8)
9D0293AC  A78281EE   SH V0, -32274(GP)
1274:                        Flags.bFirstRead = 1;
9D0293B0  938281B4   LBU V0, -32332(GP)
9D0293B4  24030001   ADDIU V1, ZERO, 1
9D0293B8  7C620004   INS V0, V1, 0, 1
9D0293BC  A38281B4   SB V0, -32332(GP)
1275:                		Flags.bWasDiscarded = 0;
9D0293C0  938281B4   LBU V0, -32332(GP)
9D0293C4  7C020844   INS V0, ZERO, 1, 1
9D0293C8  A38281B4   SB V0, -32332(GP)
1276:                    }
1277:                
1278:                
1279:                    return TRUE;
9D0293CC  24020001   ADDIU V0, ZERO, 1
1280:                }
9D0293D0  03C0E821   ADDU SP, S8, ZERO
9D0293D4  8FBF0034   LW RA, 52(SP)
9D0293D8  8FBE0030   LW S8, 48(SP)
9D0293DC  27BD0038   ADDIU SP, SP, 56
9D0293E0  03E00008   JR RA
9D0293E4  00000000   NOP
1281:                
1282:                /*****************************************************************************
1283:                  Function:
1284:                	static UDP_SOCKET FindMatchingSocket(UDP_HEADER *h, NODE_INFO *remoteNode,
1285:                                                     		IP_ADDR *localIP)
1286:                
1287:                  Summary:
1288:                	Matches an incoming UDP segment to a currently active socket.
1289:                	
1290:                  Description:
1291:                	This function attempts to match an incoming UDP segment to a currently
1292:                	active socket for processing.
1293:                
1294:                  Precondition:
1295:                	UDP segment header and IP header have both been retrieved.
1296:                
1297:                  Parameters:
1298:                	h - The UDP header that was received.
1299:                	remoteNode - IP and MAC of the remote node that sent this segment.
1300:                	localIP - IP address that this segment was destined for.
1301:                	
1302:                  Returns:
1303:                  	A UDP_SOCKET handle of a matching socket, or INVALID_UDP_SOCKET when no
1304:                  	match could be made.
1305:                  ***************************************************************************/
1306:                static UDP_SOCKET FindMatchingSocket(UDP_HEADER *h,
1307:                                                     NODE_INFO *remoteNode,
1308:                                                     IP_ADDR *localIP)
1309:                {
9D0293E8  27BDFFE0   ADDIU SP, SP, -32
9D0293EC  AFBF001C   SW RA, 28(SP)
9D0293F0  AFBE0018   SW S8, 24(SP)
9D0293F4  03A0F021   ADDU S8, SP, ZERO
9D0293F8  AFC40020   SW A0, 32(S8)
9D0293FC  AFC50024   SW A1, 36(S8)
9D029400  AFC60028   SW A2, 40(S8)
1310:                	UDP_SOCKET s;
1311:                	UDP_SOCKET partialMatch;
1312:                	UDP_SOCKET_INFO *p;
1313:                
1314:                // This is commented out because most applications don't need this type of filtering.  It comes at a performance cost.
1315:                //	// Filter out unicast packets that aren't for our IP address, but accept 
1316:                //	// all multicast and broadcast traffic
1317:                //	if(!((localIP->Val == AppConfig.MyIPAddr.Val) || (localIP->v[0] & 0x80) || (localIP->Val == (AppConfig.MyIPAddr.Val | (~AppConfig.MyMask.Val)))))
1318:                //		return INVALID_UDP_SOCKET;
1319:                
1320:                	// Discard any packets received that were generated by ourself.  In 
1321:                	// structured Wi-Fi networks, the Access Point rebroadcasts our broadcast 
1322:                	// and multicast packets, causing self-reception to occur unless filtered 
1323:                	// out.
1324:                	if(remoteNode->IPAddr.Val == AppConfig.MyIPAddr.Val)
9D029404  8FC20024   LW V0, 36(S8)
9D029408  88430003   LWL V1, 3(V0)
9D02940C  98430000   LWR V1, 0(V0)
9D029410  3C02A000   LUI V0, -24576
9D029414  24440728   ADDIU A0, V0, 1832
9D029418  88840003   LWL A0, 3(A0)
9D02941C  00802821   ADDU A1, A0, ZERO
9D029420  98450728   LWR A1, 1832(V0)
9D029424  00A01021   ADDU V0, A1, ZERO
9D029428  14620004   BNE V1, V0, 0x9D02943C
9D02942C  00000000   NOP
1325:                		return INVALID_UDP_SOCKET;
9D029430  240200FF   ADDIU V0, ZERO, 255
9D029434  0B40A551   J 0x9D029544
9D029438  00000000   NOP
1326:                
1327:                	partialMatch = INVALID_UDP_SOCKET;
9D02943C  2402FFFF   ADDIU V0, ZERO, -1
9D029440  A3C20011   SB V0, 17(S8)
1328:                
1329:                	p = UDPSocketInfo;
9D029444  3C02A000   LUI V0, -24576
9D029448  24420648   ADDIU V0, V0, 1608
9D02944C  AFC20014   SW V0, 20(S8)
1330:                    for(s = 0; s < MAX_UDP_SOCKETS; s++)
9D029450  A3C00010   SB ZERO, 16(S8)
9D029454  0B40A537   J 0x9D0294DC
9D029458  00000000   NOP
9D0294D0  93C20010   LBU V0, 16(S8)
9D0294D4  24420001   ADDIU V0, V0, 1
9D0294D8  A3C20010   SB V0, 16(S8)
9D0294DC  93C20010   LBU V0, 16(S8)
9D0294E0  2C420008   SLTIU V0, V0, 8
9D0294E4  1440FFDD   BNE V0, ZERO, 0x9D02945C
9D0294E8  00000000   NOP
1331:                	{
1332:                		// This packet is said to be matching with current socket:
1333:                		// 1. If its destination port matches with our local port and
1334:                		// 2. Packet source IP address matches with previously saved socket remote IP address and
1335:                		// 3. Packet source port number matches with previously saved socket remote port number
1336:                		if(p->localPort == h->DestinationPort)
9D02945C  8FC20014   LW V0, 20(S8)
9D029460  9443000E   LHU V1, 14(V0)
9D029464  8FC20020   LW V0, 32(S8)
9D029468  94420002   LHU V0, 2(V0)
9D02946C  14620015   BNE V1, V0, 0x9D0294C4
9D029470  00000000   NOP
1337:                		{
1338:                			if(p->remotePort == h->SourcePort)
9D029474  8FC20014   LW V0, 20(S8)
9D029478  9443000C   LHU V1, 12(V0)
9D02947C  8FC20020   LW V0, 32(S8)
9D029480  94420000   LHU V0, 0(V0)
9D029484  1462000D   BNE V1, V0, 0x9D0294BC
9D029488  00000000   NOP
1339:                			{
1340:                				if(p->remote.remoteNode.IPAddr.Val == remoteNode->IPAddr.Val)
9D02948C  8FC20014   LW V0, 20(S8)
9D029490  8C430000   LW V1, 0(V0)
9D029494  8FC20024   LW V0, 36(S8)
9D029498  88440003   LWL A0, 3(V0)
9D02949C  00802821   ADDU A1, A0, ZERO
9D0294A0  98450000   LWR A1, 0(V0)
9D0294A4  00A01021   ADDU V0, A1, ZERO
9D0294A8  14620004   BNE V1, V0, 0x9D0294BC
9D0294AC  00000000   NOP
1341:                				{
1342:                					return s;
9D0294B0  93C20010   LBU V0, 16(S8)
9D0294B4  0B40A551   J 0x9D029544
9D0294B8  00000000   NOP
1343:                				}
1344:                			}
1345:                
1346:                			partialMatch = s;
9D0294BC  93C20010   LBU V0, 16(S8)
9D0294C0  A3C20011   SB V0, 17(S8)
1347:                		}
1348:                		p++;
9D0294C4  8FC20014   LW V0, 20(S8)
9D0294C8  2442001C   ADDIU V0, V0, 28
9D0294CC  AFC20014   SW V0, 20(S8)
1349:                	}
1350:                
1351:                	if(partialMatch != INVALID_UDP_SOCKET)
9D0294EC  93C30011   LBU V1, 17(S8)
9D0294F0  240200FF   ADDIU V0, ZERO, 255
9D0294F4  10620012   BEQ V1, V0, 0x9D029540
9D0294F8  00000000   NOP
1352:                	{
1353:                		p = &UDPSocketInfo[partialMatch];
9D0294FC  93C30011   LBU V1, 17(S8)
9D029500  2402001C   ADDIU V0, ZERO, 28
9D029504  70621802   MUL V1, V1, V0
9D029508  3C02A000   LUI V0, -24576
9D02950C  24420648   ADDIU V0, V0, 1608
9D029510  00621021   ADDU V0, V1, V0
9D029514  AFC20014   SW V0, 20(S8)
1354:                
1355:                		memcpy((void*)&p->remote.remoteNode,
9D029518  8FC20014   LW V0, 20(S8)
9D02951C  00402021   ADDU A0, V0, ZERO
9D029520  8FC50024   LW A1, 36(S8)
9D029524  2406000A   ADDIU A2, ZERO, 10
9D029528  0F40D298   JAL 0x9D034A60
9D02952C  00000000   NOP
1356:                				(const void*)remoteNode, sizeof(p->remote.remoteNode) );
1357:                
1358:                		p->remotePort = h->SourcePort;
9D029530  8FC20020   LW V0, 32(S8)
9D029534  94430000   LHU V1, 0(V0)
9D029538  8FC20014   LW V0, 20(S8)
9D02953C  A443000C   SH V1, 12(V0)
1359:                	}
1360:                
1361:                	return partialMatch;
9D029540  93C20011   LBU V0, 17(S8)
1362:                }
9D029544  03C0E821   ADDU SP, S8, ZERO
9D029548  8FBF001C   LW RA, 28(SP)
9D02954C  8FBE0018   LW S8, 24(SP)
9D029550  27BD0020   ADDIU SP, SP, 32
9D029554  03E00008   JR RA
9D029558  00000000   NOP
1363:                
1364:                
1365:                #endif //#if defined(STACK_USE_UDP)
---  C:/Users/Diego/Documents/GitHub/pic32webFREERtos/Pic32Web.X/src/tcpip/src/UART.c  ------------------
1:                   /*********************************************************************
2:                    *
3:                    *     UART access routines for C18 and C30
4:                    *
5:                    *********************************************************************
6:                    * FileName:        UART.c
7:                    * Dependencies:    Hardware UART module
8:                    * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F
9:                    * Compiler:        Microchip C30 v3.12 or higher
10:                   *					Microchip C18 v3.30 or higher
11:                   *					HI-TECH PICC-18 PRO 9.63PL2 or higher
12:                   * Company:         Microchip Technology, Inc.
13:                   *
14:                   * Software License Agreement
15:                   *
16:                   * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights
17:                   * reserved.
18:                   *
19:                   * Microchip licenses to you the right to use, modify, copy, and
20:                   * distribute:
21:                   * (i)  the Software when embedded on a Microchip microcontroller or
22:                   *      digital signal controller product ("Device") which is
23:                   *      integrated into Licensee's product; or
24:                   * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h,
25:                   *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device
26:                   *		used in conjunction with a Microchip ethernet controller for
27:                   *		the sole purpose of interfacing with the ethernet controller.
28:                   *
29:                   * You should refer to the license agreement accompanying this
30:                   * Software for additional information regarding your rights and
31:                   * obligations.
32:                   *
33:                   * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT
34:                   * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT
35:                   * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A
36:                   * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL
37:                   * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR
38:                   * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF
39:                   * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS
40:                   * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE
41:                   * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER
42:                   * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT
43:                   * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE.
44:                   *
45:                   *
46:                   * Author               Date   		Comment
47:                   *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
48:                   * Howard Schlunder		4/04/06		Copied from dsPIC30 libraries
49:                   * Howard Schlunder		6/16/06		Added PIC18
50:                  ********************************************************************/
51:                  #define __UART_C
52:                  
53:                  #include "TCPIPConfig.h"
54:                  
55:                  #if defined(STACK_USE_UART)
56:                  
57:                  #include "TCPIP Stack/TCPIP.h"
58:                  
59:                  
60:                  BYTE ReadStringUART(BYTE *Dest, BYTE BufferLen)
61:                  {
9D035630  27BDFFF0   ADDIU SP, SP, -16
9D035634  AFBE000C   SW S8, 12(SP)
9D035638  03A0F021   ADDU S8, SP, ZERO
9D03563C  AFC40010   SW A0, 16(S8)
9D035640  00A01021   ADDU V0, A1, ZERO
9D035644  A3C20014   SB V0, 20(S8)
62:                  	BYTE c;
63:                  	BYTE count = 0;
9D035648  A3C00000   SB ZERO, 0(S8)
64:                  
65:                  	while(BufferLen--)
9D03564C  0B40D5B1   J 0x9D0356C4
9D035650  00000000   NOP
9D0356C4  93C20014   LBU V0, 20(S8)
9D0356C8  0002102B   SLTU V0, ZERO, V0
9D0356CC  304200FF   ANDI V0, V0, 255
9D0356D0  93C30014   LBU V1, 20(S8)
9D0356D4  2463FFFF   ADDIU V1, V1, -1
9D0356D8  A3C30014   SB V1, 20(S8)
9D0356DC  1440FFDD   BNE V0, ZERO, 0x9D035654
9D0356E0  00000000   NOP
66:                  	{
67:                  		*Dest = '\0';
9D035654  8FC20010   LW V0, 16(S8)
9D035658  A0400000   SB ZERO, 0(V0)
68:                  
69:                  		while(!DataRdyUART());
9D03565C  00000000   NOP
9D035660  3C02BF80   LUI V0, -16512
9D035664  8C426010   LW V0, 24592(V0)
9D035668  30420001   ANDI V0, V0, 1
9D03566C  1040FFFC   BEQ V0, ZERO, 0x9D035660
9D035670  00000000   NOP
70:                  		c = ReadUART();
9D035674  3C02BF80   LUI V0, -16512
9D035678  8C426030   LW V0, 24624(V0)
9D03567C  A3C20001   SB V0, 1(S8)
71:                  
72:                  		if(c == '\r' || c == '\n')
9D035680  93C30001   LBU V1, 1(S8)
9D035684  2402000D   ADDIU V0, ZERO, 13
9D035688  10620016   BEQ V1, V0, 0x9D0356E4
9D03568C  00000000   NOP
9D035690  93C30001   LBU V1, 1(S8)
9D035694  2402000A   ADDIU V0, ZERO, 10
9D035698  10620012   BEQ V1, V0, 0x9D0356E4
9D03569C  00000000   NOP
73:                  			break;
74:                  
75:                  		count++;
9D0356A0  93C20000   LBU V0, 0(S8)
9D0356A4  24420001   ADDIU V0, V0, 1
9D0356A8  A3C20000   SB V0, 0(S8)
76:                  		*Dest++ = c;
9D0356AC  8FC20010   LW V0, 16(S8)
9D0356B0  93C30001   LBU V1, 1(S8)
9D0356B4  A0430000   SB V1, 0(V0)
9D0356B8  8FC20010   LW V0, 16(S8)
9D0356BC  24420001   ADDIU V0, V0, 1
9D0356C0  AFC20010   SW V0, 16(S8)
77:                  	}
78:                  
79:                  	return count;
9D0356E4  93C20000   LBU V0, 0(S8)
80:                  }
9D0356E8  03C0E821   ADDU SP, S8, ZERO
9D0356EC  8FBE000C   LW S8, 12(SP)
9D0356F0  27BD0010   ADDIU SP, SP, 16
9D0356F4  03E00008   JR RA
9D0356F8  00000000   NOP
81:                  
82:                  
83:                  
84:                  #if defined(__18CXX)	// PIC18
85:                  	char BusyUSART(void)
86:                  	{
87:                  		return !TXSTAbits.TRMT;
88:                  	}
89:                  	
90:                  	void CloseUSART(void)
91:                  	{
92:                  	  RCSTA &= 0x4F;  // Disable the receiver
93:                  	  TXSTAbits.TXEN = 0;   // and transmitter
94:                  	
95:                  	  PIE1 &= 0xCF;   // Disable both interrupts
96:                  	}
97:                  	
98:                  	char DataRdyUSART(void)
99:                  	{
100:                 		if(RCSTAbits.OERR)
101:                 		{
102:                 			RCSTAbits.CREN = 0;
103:                 			RCSTAbits.CREN = 1;
104:                 		}
105:                 	  return PIR1bits.RCIF;
106:                 	}
107:                 	
108:                 	char ReadUSART(void)
109:                 	{
110:                 	  return RCREG;                     // Return the received data
111:                 	}
112:                 	
113:                 	void WriteUSART(char data)
114:                 	{
115:                 	  TXREG = data;      // Write the data byte to the USART
116:                 	}
117:                 	
118:                 	void getsUSART(char *buffer, unsigned char len)
119:                 	{
120:                 	  char i;    // Length counter
121:                 	  unsigned char data;
122:                 	
123:                 	  for(i=0;i<len;i++)  // Only retrieve len characters
124:                 	  {
125:                 	    while(!DataRdyUSART());// Wait for data to be received
126:                 	
127:                 	    data = getcUART();    // Get a character from the USART
128:                 	                           // and save in the string
129:                 	    *buffer = data;
130:                 	    buffer++;              // Increment the string pointer
131:                 	  }
132:                 	}
133:                 	
134:                 	void putsUSART( char *data)
135:                 	{
136:                 	  do
137:                 	  {  // Transmit a byte
138:                 	    while(BusyUSART());
139:                 	    putcUART(*data);
140:                 	  } while( *data++ );
141:                 	}
142:                 	
143:                 	void putrsUSART(const rom char *data)
144:                 	{
145:                 	  do
146:                 	  {  // Transmit a byte
147:                 	    while(BusyUSART());
148:                 	    putcUART(*data);
149:                 	  } while( *data++ );
150:                 	}
151:                 
152:                 
153:                 #elif defined(__C30__) // PIC24F, PIC24H, dsPIC30, dsPIC33
154:                 
155:                 /***************************************************************************
156:                 * Function Name     : putsUART2                                            *
157:                 * Description       : This function puts the data string to be transmitted *
158:                 *                     into the transmit buffer (till NULL character)       * 
159:                 * Parameters        : unsigned int * address of the string buffer to be    *
160:                 *                     transmitted                                          *
161:                 * Return Value      : None                                                 *  
162:                 ***************************************************************************/
163:                 
164:                 void putsUART2(unsigned int *buffer)
165:                 {
166:                     char * temp_ptr = (char *) buffer;
167:                 
168:                     /* transmit till NULL character is encountered */
169:                 
170:                     if(U2MODEbits.PDSEL == 3)        /* check if TX is 8bits or 9bits */
171:                     {
172:                         while(*buffer != '\0') 
173:                         {
174:                             while(U2STAbits.UTXBF); /* wait if the buffer is full */
175:                             U2TXREG = *buffer++;    /* transfer data word to TX reg */
176:                         }
177:                     }
178:                     else
179:                     {
180:                         while(*temp_ptr != '\0')
181:                         {
182:                             while(U2STAbits.UTXBF);  /* wait if the buffer is full */
183:                             U2TXREG = *temp_ptr++;   /* transfer data byte to TX reg */
184:                         }
185:                     }
186:                 }
187:                 
188:                 
189:                 /******************************************************************************
190:                 * Function Name     : getsUART2                                               *
191:                 * Description       : This function gets a string of data of specified length * 
192:                 *                     if available in the UxRXREG buffer into the buffer      *
193:                 *                     specified.                                              *
194:                 * Parameters        : unsigned int length the length expected                 *
195:                 *                     unsigned int *buffer  the received data to be           * 
196:                 *                                  recorded to this array                     *
197:                 *                     unsigned int uart_data_wait timeout value               *
198:                 * Return Value      : unsigned int number of data bytes yet to be received    * 
199:                 ******************************************************************************/
200:                 
201:                 unsigned int getsUART2(unsigned int length,unsigned int *buffer,
202:                                        unsigned int uart_data_wait)
203:                 
204:                 {
205:                     unsigned int wait = 0;
206:                     char *temp_ptr = (char *) buffer;
207:                 
208:                     while(length)                         /* read till length is 0 */
209:                     {
210:                         while(!DataRdyUART2())
211:                         {
212:                             if(wait < uart_data_wait)
213:                                 wait++ ;                  /*wait for more data */
214:                             else
215:                                 return(length);           /*Time out- Return words/bytes to be read */
216:                         }
217:                         wait=0;
218:                         if(U2MODEbits.PDSEL == 3)         /* check if TX/RX is 8bits or 9bits */
219:                             *buffer++ = U2RXREG;          /* data word from HW buffer to SW buffer */
220:                 		else
221:                             *temp_ptr++ = U2RXREG & 0xFF; /* data byte from HW buffer to SW buffer */
222:                 
223:                         length--;
224:                     }
225:                 
226:                     return(length);                       /* number of data yet to be received i.e.,0 */
227:                 }
228:                 
229:                 
230:                 /*********************************************************************
231:                 * Function Name     : DataRdyUart2                                   *
232:                 * Description       : This function checks whether there is any data *
233:                 *                     that can be read from the input buffer, by     *
234:                 *                     checking URXDA bit                             *
235:                 * Parameters        : None                                           *
236:                 * Return Value      : char if any data available in buffer           *
237:                 *********************************************************************/
238:                 
239:                 char DataRdyUART2(void)
240:                 {
241:                     return(U2STAbits.URXDA);
242:                 }
243:                 
244:                 
245:                 /*************************************************************************
246:                 * Function Name     : BusyUART2                                          *
247:                 * Description       : This returns status whether the transmission       *  
248:                 *                     is in progress or not, by checking Status bit TRMT *
249:                 * Parameters        : None                                               *
250:                 * Return Value      : char info whether transmission is in progress      *
251:                 *************************************************************************/
252:                 
253:                 char BusyUART2(void)
254:                 {  
255:                     return(!U2STAbits.TRMT);
256:                 }
257:                 
258:                 
259:                 /***************************************************************************
260:                 * Function Name     : ReadUART2                                            *
261:                 * Description       : This function returns the contents of UxRXREG buffer *
262:                 * Parameters        : None                                                 *  
263:                 * Return Value      : unsigned int value from UxRXREG receive buffer       * 
264:                 ***************************************************************************/
265:                 
266:                 unsigned int ReadUART2(void)
267:                 {
268:                     if(U2MODEbits.PDSEL == 3)
269:                         return (U2RXREG);
270:                     else
271:                         return (U2RXREG & 0xFF);
272:                 }
273:                 
274:                 
275:                 /*********************************************************************
276:                 * Function Name     : WriteUART2                                     *
277:                 * Description       : This function writes data into the UxTXREG,    *
278:                 * Parameters        : unsigned int data the data to be written       *
279:                 * Return Value      : None                                           *
280:                 *********************************************************************/
281:                 
282:                 void WriteUART2(unsigned int data)
283:                 {
284:                     if(U2MODEbits.PDSEL == 3)
285:                         U2TXREG = data;
286:                     else
287:                         U2TXREG = data & 0xFF;  
288:                 }
289:                 
290:                 #endif
291:                 
292:                 
293:                 #endif	//STACK_USE_UART
---  C:/Users/Diego/Documents/GitHub/pic32webFREERtos/Pic32Web.X/src/tcpip/src/Tick.c  ------------------
1:                   /*********************************************************************
2:                    *
3:                    *                  Tick Manager for Timekeeping
4:                    *
5:                    *********************************************************************
6:                    * FileName:        Tick.c
7:                    * Dependencies:    Timer 0 (PIC18) or Timer 1 (PIC24F, PIC24H, 
8:                    *					dsPIC30F, dsPIC33F, PIC32)
9:                    * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32
10:                   * Compiler:        Microchip C32 v1.10b or higher
11:                   *					Microchip C30 v3.12 or higher
12:                   *					Microchip C18 v3.30 or higher
13:                   *					HI-TECH PICC-18 PRO 9.63PL2 or higher
14:                   * Company:         Microchip Technology, Inc.
15:                   *
16:                   * Software License Agreement
17:                   *
18:                   * Copyright (C) 2002-2010 Microchip Technology Inc.  All rights
19:                   * reserved.
20:                   *
21:                   * Microchip licenses to you the right to use, modify, copy, and
22:                   * distribute:
23:                   * (i)  the Software when embedded on a Microchip microcontroller or
24:                   *      digital signal controller product ("Device") which is
25:                   *      integrated into Licensee's product; or
26:                   * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h,
27:                   *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device
28:                   *		used in conjunction with a Microchip ethernet controller for
29:                   *		the sole purpose of interfacing with the ethernet controller.
30:                   *
31:                   * You should refer to the license agreement accompanying this
32:                   * Software for additional information regarding your rights and
33:                   * obligations.
34:                   *
35:                   * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT
36:                   * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT
37:                   * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A
38:                   * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL
39:                   * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR
40:                   * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF
41:                   * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS
42:                   * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE
43:                   * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER
44:                   * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT
45:                   * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE.
46:                   *
47:                   *
48:                   * Author               Date        Comment
49:                   *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
50:                   * Nilesh Rajbharti     6/28/01     Original        (Rev 1.0)
51:                   * Nilesh Rajbharti     2/9/02      Cleanup
52:                   * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail)
53:                   * Howard Schlunder		6/13/07		Changed to use timer without 
54:                   *									writing for perfect accuracy.
55:                  ********************************************************************/
56:                  #define __TICK_C
57:                  
58:                  #include "TCPIP Stack/TCPIP.h"
59:                  
60:                  // Internal counter to store Ticks.  This variable is incremented in an ISR and 
61:                  // therefore must be marked volatile to prevent the compiler optimizer from 
62:                  // reordering code to use this value in the main context while interrupts are 
63:                  // disabled.
64:                  static volatile DWORD dwInternalTicks = 0;
65:                  
66:                  // 6-byte value to store Ticks.  Allows for use over longer periods of time.
67:                  static BYTE vTickReading[6];
68:                  
69:                  static void GetTickCopy(void);
70:                  
71:                  
72:                  /*****************************************************************************
73:                    Function:
74:                  	void TickInit(void)
75:                  
76:                    Summary:
77:                  	Initializes the Tick manager module.
78:                  
79:                    Description:
80:                  	Configures the Tick module and any necessary hardware resources.
81:                  
82:                    Precondition:
83:                  	None
84:                  
85:                    Parameters:
86:                  	None
87:                  
88:                    Returns:
89:                    	None
90:                    	
91:                    Remarks:
92:                  	This function is called only one during lifetime of the application.
93:                    ***************************************************************************/
94:                  void TickInit(void)
95:                  {
9D033600  27BDFFF8   ADDIU SP, SP, -8
9D033604  AFBE0004   SW S8, 4(SP)
9D033608  03A0F021   ADDU S8, SP, ZERO
96:                  #if defined(__18CXX)
97:                  	// Use Timer0 for 8 bit processors
98:                      // Initialize the time
99:                      TMR0H = 0;
100:                     TMR0L = 0;
101:                 
102:                 	// Set up the timer interrupt
103:                 	INTCON2bits.TMR0IP = 0;		// Low priority
104:                     INTCONbits.TMR0IF = 0;
105:                     INTCONbits.TMR0IE = 1;		// Enable interrupt
106:                 
107:                     // Timer0 on, 16-bit, internal timer, 1:256 prescalar
108:                     T0CON = 0x87;
109:                 #else
110:                 	// Use Timer 1 for 16-bit and 32-bit processors
111:                 	// 1:256 prescale
112:                 	T2CONbits.TCKPS = 3;
9D03360C  3C03BF80   LUI V1, -16512
9D033610  8C620800   LW V0, 2048(V1)
9D033614  24040003   ADDIU A0, ZERO, 3
9D033618  7C823104   INS V0, A0, 4, 3
9D03361C  AC620800   SW V0, 2048(V1)
113:                 	// Base
114:                 	PR2 = 0xFFFF;
9D033620  3C02BF80   LUI V0, -16512
9D033624  3403FFFF   ORI V1, ZERO, -1
9D033628  AC430820   SW V1, 2080(V0)
115:                 	// Clear counter
116:                 	TMR2 = 0;
9D03362C  3C02BF80   LUI V0, -16512
9D033630  AC400810   SW ZERO, 2064(V0)
117:                 
118:                 	// Enable timer interrupt
119:                 	#if defined(__C30__)
120:                 		IPC0bits.T1IP = 2;	// Interrupt priority 2 (low)
121:                 		IFS0bits.T1IF = 0;
122:                 		IEC0bits.T1IE = 1;
123:                 	#else
124:                 		IPC2bits.T2IP = 2;	// Interrupt priority 2 (low)
9D033634  3C03BF88   LUI V1, -16504
9D033638  8C6210B0   LW V0, 4272(V1)
9D03363C  24040002   ADDIU A0, ZERO, 2
9D033640  7C822084   INS V0, A0, 2, 3
9D033644  AC6210B0   SW V0, 4272(V1)
125:                 		IFS0CLR = _IFS0_T2IF_MASK;
9D033648  3C02BF88   LUI V0, -16504
9D03364C  24030100   ADDIU V1, ZERO, 256
9D033650  AC431034   SW V1, 4148(V0)
126:                 		IEC0SET = _IEC0_T2IE_MASK;
9D033654  3C02BF88   LUI V0, -16504
9D033658  24030100   ADDIU V1, ZERO, 256
9D03365C  AC431068   SW V1, 4200(V0)
127:                 	#endif
128:                 
129:                 	// Start timer
130:                 	T2CONbits.TON = 1;
9D033660  3C03BF80   LUI V1, -16512
9D033664  8C620800   LW V0, 2048(V1)
9D033668  24040001   ADDIU A0, ZERO, 1
9D03366C  7C827BC4   INS V0, A0, 15, 1
9D033670  AC620800   SW V0, 2048(V1)
131:                 #endif
132:                 }
9D033674  03C0E821   ADDU SP, S8, ZERO
9D033678  8FBE0004   LW S8, 4(SP)
9D03367C  27BD0008   ADDIU SP, SP, 8
9D033680  03E00008   JR RA
9D033684  00000000   NOP
133:                 
134:                 /*****************************************************************************
135:                   Function:
136:                 	static void GetTickCopy(void)
137:                 
138:                   Summary:
139:                 	Reads the tick value.
140:                 
141:                   Description:
142:                 	This function performs an interrupt-safe and synchronized read of the 
143:                 	48-bit Tick value.
144:                 
145:                   Precondition:
146:                 	None
147:                 
148:                   Parameters:
149:                 	None
150:                 
151:                   Returns:
152:                   	None
153:                   ***************************************************************************/
154:                 static void GetTickCopy(void)
155:                 {
9D033688  27BDFFF0   ADDIU SP, SP, -16
9D03368C  AFBE000C   SW S8, 12(SP)
9D033690  03A0F021   ADDU S8, SP, ZERO
156:                 	// Perform an Interrupt safe and synchronized read of the 48-bit 
157:                 	// tick value
158:                 #if defined(__18CXX)
159:                 	do
160:                 	{
161:                 		INTCONbits.TMR0IE = 1;		// Enable interrupt
162:                 		Nop();
163:                 		INTCONbits.TMR0IE = 0;		// Disable interrupt
164:                 		vTickReading[0] = TMR0L;
165:                 		vTickReading[1] = TMR0H;
166:                 		*((DWORD*)&vTickReading[2]) = dwInternalTicks;
167:                 	} while(INTCONbits.TMR0IF);
168:                 	INTCONbits.TMR0IE = 1;			// Enable interrupt
169:                 #elif defined(__C30__)
170:                 	do
171:                 	{
172:                 		DWORD dwTempTicks;
173:                 		
174:                 		IEC0bits.T1IE = 1;			// Enable interrupt
175:                 		Nop();
176:                 		IEC0bits.T1IE = 0;			// Disable interrupt
177:                 
178:                 		// Get low 2 bytes
179:                 		((WORD*)vTickReading)[0] = TMR1;
180:                 		
181:                 		// Correct corner case where interrupt increments byte[4+] but 
182:                 		// TMR1 hasn't rolled over to 0x0000 yet
183:                 		dwTempTicks = dwInternalTicks;
184:                 		if(((WORD*)vTickReading)[0] == 0xFFFFu)
185:                 			dwTempTicks--;
186:                 		
187:                 		// Get high 4 bytes
188:                 		vTickReading[2] = ((BYTE*)&dwTempTicks)[0];
189:                 		vTickReading[3] = ((BYTE*)&dwTempTicks)[1];
190:                 		vTickReading[4] = ((BYTE*)&dwTempTicks)[2];
191:                 		vTickReading[5] = ((BYTE*)&dwTempTicks)[3];
192:                 	} while(IFS0bits.T1IF);
193:                 	IEC0bits.T1IE = 1;				// Enable interrupt
194:                 #else	// PIC32
195:                 	do
196:                 	{
197:                 		DWORD dwTempTicks;
198:                 		
199:                 		IEC0SET = _IEC0_T2IE_MASK;	// Enable interrupt
9D033694  3C02BF88   LUI V0, -16504
9D033698  24030100   ADDIU V1, ZERO, 256
9D03369C  AC431068   SW V1, 4200(V0)
200:                 		Nop();
9D0336A0  00000040   SSNOP
201:                 		IEC0CLR = _IEC0_T2IE_MASK;	// Disable interrupt
9D0336A4  3C02BF88   LUI V0, -16504
9D0336A8  24030100   ADDIU V1, ZERO, 256
9D0336AC  AC431064   SW V1, 4196(V0)
202:                 		
203:                 		// Get low 2 bytes
204:                 		((volatile WORD*)vTickReading)[0] = TMR2;
9D0336B0  278281A8   ADDIU V0, GP, -32344
9D0336B4  3C03BF80   LUI V1, -16512
9D0336B8  8C630810   LW V1, 2064(V1)
9D0336BC  3063FFFF   ANDI V1, V1, -1
9D0336C0  A4430000   SH V1, 0(V0)
205:                 		
206:                 		// Correct corner case where interrupt increments byte[4+] but 
207:                 		// TMR1 hasn't rolled over to 0x0000 yet
208:                 		dwTempTicks = dwInternalTicks;
9D0336C4  8F8281A4   LW V0, -32348(GP)
9D0336C8  AFC20000   SW V0, 0(S8)
209:                 
210:                 		// PIC32MX3XX/4XX devices trigger the timer interrupt when TMR1 == PR1 
211:                 		// (TMR1 prescalar is 0x00), requiring us to undo the ISR's increment 
212:                 		// of the upper 32 bits of our 48 bit timer in the special case when 
213:                 		// TMR1 == PR1 == 0xFFFF.  For other PIC32 families, the ISR is 
214:                 		// triggered when TMR1 increments from PR1 to 0x0000, making no special 
215:                 		// corner case.
216:                 		#if __PIC32_FEATURE_SET__ <= 460
217:                 			if(((WORD*)vTickReading)[0] == 0xFFFFu)
9D0336CC  278281A8   ADDIU V0, GP, -32344
9D0336D0  94430000   LHU V1, 0(V0)
9D0336D4  3402FFFF   ORI V0, ZERO, -1
9D0336D8  14620004   BNE V1, V0, 0x9D0336EC
9D0336DC  00000000   NOP
218:                 				dwTempTicks--;
9D0336E0  8FC20000   LW V0, 0(S8)
9D0336E4  2442FFFF   ADDIU V0, V0, -1
9D0336E8  AFC20000   SW V0, 0(S8)
219:                 		#elif !defined(__PIC32_FEATURE_SET__)
220:                 			#error __PIC32_FEATURE_SET__ macro must be defined.  You need to download a newer C32 compiler version.
221:                 		#endif
222:                 		
223:                 		// Get high 4 bytes
224:                 		vTickReading[2] = ((BYTE*)&dwTempTicks)[0];
9D0336EC  03C01021   ADDU V0, S8, ZERO
9D0336F0  90420000   LBU V0, 0(V0)
9D0336F4  A38281AA   SB V0, -32342(GP)
225:                 		vTickReading[3] = ((BYTE*)&dwTempTicks)[1];
9D0336F8  03C01021   ADDU V0, S8, ZERO
9D0336FC  24420001   ADDIU V0, V0, 1
9D033700  90420000   LBU V0, 0(V0)
9D033704  A38281AB   SB V0, -32341(GP)
226:                 		vTickReading[4] = ((BYTE*)&dwTempTicks)[2];
9D033708  03C01021   ADDU V0, S8, ZERO
9D03370C  24420002   ADDIU V0, V0, 2
9D033710  90420000   LBU V0, 0(V0)
9D033714  A38281AC   SB V0, -32340(GP)
227:                 		vTickReading[5] = ((BYTE*)&dwTempTicks)[3];
9D033718  03C01021   ADDU V0, S8, ZERO
9D03371C  24420003   ADDIU V0, V0, 3
9D033720  90420000   LBU V0, 0(V0)
9D033724  A38281AD   SB V0, -32339(GP)
228:                 	} while(IFS0bits.T2IF);
9D033728  3C02BF88   LUI V0, -16504
9D03372C  8C421030   LW V0, 4144(V0)
9D033730  30420100   ANDI V0, V0, 256
9D033734  1440FFD7   BNE V0, ZERO, 0x9D033694
9D033738  00000000   NOP
229:                 	IEC0SET = _IEC0_T2IE_MASK;		// Enable interrupt
9D03373C  3C02BF88   LUI V0, -16504
9D033740  24030100   ADDIU V1, ZERO, 256
9D033744  AC431068   SW V1, 4200(V0)
230:                 #endif
231:                 }
9D033748  03C0E821   ADDU SP, S8, ZERO
9D03374C  8FBE000C   LW S8, 12(SP)
9D033750  03E00008   JR RA
9D033754  27BD0010   ADDIU SP, SP, 16
232:                 
233:                 
234:                 /*****************************************************************************
235:                   Function:
236:                 	DWORD TickGet(void)
237:                 
238:                   Summary:
239:                 	Obtains the current Tick value.
240:                 
241:                   Description:
242:                 	This function retrieves the current Tick value, allowing timing and
243:                 	measurement code to be written in a non-blocking fashion.  This function
244:                 	retrieves the least significant 32 bits of the internal tick counter, 
245:                 	and is useful for measuring time increments ranging from a few 
246:                 	microseconds to a few hours.  Use TickGetDiv256 or TickGetDiv64K for
247:                 	longer periods of time.
248:                 
249:                   Precondition:
250:                 	None
251:                 
252:                   Parameters:
253:                 	None
254:                 
255:                   Returns:
256:                   	Lower 32 bits of the current Tick value.
257:                   ***************************************************************************/
258:                 DWORD TickGet(void)
259:                 {
9D033758  27BDFFE8   ADDIU SP, SP, -24
9D03375C  AFBF0014   SW RA, 20(SP)
9D033760  AFBE0010   SW S8, 16(SP)
9D033764  03A0F021   ADDU S8, SP, ZERO
260:                 	GetTickCopy();
9D033768  0F40CDA2   JAL 0x9D033688
9D03376C  00000000   NOP
261:                 	return *((DWORD*)&vTickReading[0]);
9D033770  278281A8   ADDIU V0, GP, -32344
9D033774  8C420000   LW V0, 0(V0)
262:                 }
9D033778  03C0E821   ADDU SP, S8, ZERO
9D03377C  8FBF0014   LW RA, 20(SP)
9D033780  8FBE0010   LW S8, 16(SP)
9D033784  27BD0018   ADDIU SP, SP, 24
9D033788  03E00008   JR RA
9D03378C  00000000   NOP
263:                 
264:                 /*****************************************************************************
265:                   Function:
266:                 	DWORD TickGetDiv256(void)
267:                 
268:                   Summary:
269:                 	Obtains the current Tick value divided by 256.
270:                 
271:                   Description:
272:                 	This function retrieves the current Tick value, allowing timing and
273:                 	measurement code to be written in a non-blocking fashion.  This function
274:                 	retrieves the middle 32 bits of the internal tick counter, 
275:                 	and is useful for measuring time increments ranging from a few 
276:                 	minutes to a few weeks.  Use TickGet for shorter periods or TickGetDiv64K
277:                 	for longer ones.
278:                 
279:                   Precondition:
280:                 	None
281:                 
282:                   Parameters:
283:                 	None
284:                 
285:                   Returns:
286:                   	Middle 32 bits of the current Tick value.
287:                   ***************************************************************************/
288:                 DWORD TickGetDiv256(void)
289:                 {
9D033790  27BDFFE0   ADDIU SP, SP, -32
9D033794  AFBF001C   SW RA, 28(SP)
9D033798  AFBE0018   SW S8, 24(SP)
9D03379C  03A0F021   ADDU S8, SP, ZERO
290:                 	DWORD dw;
291:                 
292:                 	GetTickCopy();
9D0337A0  0F40CDA2   JAL 0x9D033688
9D0337A4  00000000   NOP
293:                 	((BYTE*)&dw)[0] = vTickReading[1];	// Note: This copy must be done one 
9D0337A8  27C20010   ADDIU V0, S8, 16
9D0337AC  938381A9   LBU V1, -32343(GP)
9D0337B0  A0430000   SB V1, 0(V0)
294:                 	((BYTE*)&dw)[1] = vTickReading[2];	// byte at a time to prevent misaligned 
9D0337B4  27C20010   ADDIU V0, S8, 16
9D0337B8  24420001   ADDIU V0, V0, 1
9D0337BC  938381AA   LBU V1, -32342(GP)
9D0337C0  A0430000   SB V1, 0(V0)
295:                 	((BYTE*)&dw)[2] = vTickReading[3];	// memory reads, which will reset the PIC.
9D0337C4  27C20010   ADDIU V0, S8, 16
9D0337C8  24420002   ADDIU V0, V0, 2
9D0337CC  938381AB   LBU V1, -32341(GP)
9D0337D0  A0430000   SB V1, 0(V0)
296:                 	((BYTE*)&dw)[3] = vTickReading[4];
9D0337D4  27C20010   ADDIU V0, S8, 16
9D0337D8  24420003   ADDIU V0, V0, 3
9D0337DC  938381AC   LBU V1, -32340(GP)
9D0337E0  A0430000   SB V1, 0(V0)
297:                 	
298:                 	return dw;
9D0337E4  8FC20010   LW V0, 16(S8)
299:                 }
9D0337E8  03C0E821   ADDU SP, S8, ZERO
9D0337EC  8FBF001C   LW RA, 28(SP)
9D0337F0  8FBE0018   LW S8, 24(SP)
9D0337F4  27BD0020   ADDIU SP, SP, 32
9D0337F8  03E00008   JR RA
9D0337FC  00000000   NOP
300:                 
301:                 /*****************************************************************************
302:                   Function:
303:                 	DWORD TickGetDiv64K(void)
304:                 
305:                   Summary:
306:                 	Obtains the current Tick value divided by 64K.
307:                 
308:                   Description:
309:                 	This function retrieves the current Tick value, allowing timing and
310:                 	measurement code to be written in a non-blocking fashion.  This function
311:                 	retrieves the most significant 32 bits of the internal tick counter, 
312:                 	and is useful for measuring time increments ranging from a few 
313:                 	days to a few years, or for absolute time measurements.  Use TickGet or
314:                 	TickGetDiv256 for shorter periods of time.
315:                 
316:                   Precondition:
317:                 	None
318:                 
319:                   Parameters:
320:                 	None
321:                 
322:                   Returns:
323:                   	Upper 32 bits of the current Tick value.
324:                   ***************************************************************************/
325:                 DWORD TickGetDiv64K(void)
326:                 {
9D033800  27BDFFE0   ADDIU SP, SP, -32
9D033804  AFBF001C   SW RA, 28(SP)
9D033808  AFBE0018   SW S8, 24(SP)
9D03380C  03A0F021   ADDU S8, SP, ZERO
327:                 	DWORD dw;
328:                 
329:                 	GetTickCopy();
9D033810  0F40CDA2   JAL 0x9D033688
9D033814  00000000   NOP
330:                 	((BYTE*)&dw)[0] = vTickReading[2];	// Note: This copy must be done one 
9D033818  27C20010   ADDIU V0, S8, 16
9D03381C  938381AA   LBU V1, -32342(GP)
9D033820  A0430000   SB V1, 0(V0)
331:                 	((BYTE*)&dw)[1] = vTickReading[3];	// byte at a time to prevent misaligned 
9D033824  27C20010   ADDIU V0, S8, 16
9D033828  24420001   ADDIU V0, V0, 1
9D03382C  938381AB   LBU V1, -32341(GP)
9D033830  A0430000   SB V1, 0(V0)
332:                 	((BYTE*)&dw)[2] = vTickReading[4];	// memory reads, which will reset the PIC.
9D033834  27C20010   ADDIU V0, S8, 16
9D033838  24420002   ADDIU V0, V0, 2
9D03383C  938381AC   LBU V1, -32340(GP)
9D033840  A0430000   SB V1, 0(V0)
333:                 	((BYTE*)&dw)[3] = vTickReading[5];
9D033844  27C20010   ADDIU V0, S8, 16
9D033848  24420003   ADDIU V0, V0, 3
9D03384C  938381AD   LBU V1, -32339(GP)
9D033850  A0430000   SB V1, 0(V0)
334:                 	
335:                 	return dw;
9D033854  8FC20010   LW V0, 16(S8)
336:                 }
9D033858  03C0E821   ADDU SP, S8, ZERO
9D03385C  8FBF001C   LW RA, 28(SP)
9D033860  8FBE0018   LW S8, 24(SP)
9D033864  27BD0020   ADDIU SP, SP, 32
9D033868  03E00008   JR RA
9D03386C  00000000   NOP
337:                 
338:                 
339:                 /*****************************************************************************
340:                   Function:
341:                 	DWORD TickConvertToMilliseconds(DWORD dwTickValue)
342:                 
343:                   Summary:
344:                 	Converts a Tick value or difference to milliseconds.
345:                 
346:                   Description:
347:                 	This function converts a Tick value or difference to milliseconds.  For
348:                 	example, TickConvertToMilliseconds(32768) returns 1000 when a 32.768kHz 
349:                 	clock with no prescaler drives the Tick module interrupt.
350:                 
351:                   Precondition:
352:                 	None
353:                 
354:                   Parameters:
355:                 	dwTickValue	- Value to convert to milliseconds
356:                 
357:                   Returns:
358:                   	Input value expressed in milliseconds.
359:                 
360:                   Remarks:
361:                 	This function performs division on DWORDs, which is slow.  Avoid using
362:                 	it unless you absolutely must (such as displaying data to a user).  For
363:                 	timeout comparisons, compare the current value to a multiple or fraction 
364:                 	of TICK_SECOND, which will be calculated only once at compile time.
365:                   ***************************************************************************/
366:                 DWORD TickConvertToMilliseconds(DWORD dwTickValue)
367:                 {
9D033870  27BDFFE8   ADDIU SP, SP, -24
9D033874  AFBF0014   SW RA, 20(SP)
9D033878  AFBE0010   SW S8, 16(SP)
9D03387C  03A0F021   ADDU S8, SP, ZERO
9D033880  AFC40018   SW A0, 24(S8)
368:                 	return (dwTickValue+(TICKS_PER_SECOND/2000ul))/((DWORD)(TICKS_PER_SECOND/1000ul));
9D033884  8FC60018   LW A2, 24(S8)
9D033888  00003821   ADDU A3, ZERO, ZERO
9D03388C  2404004E   ADDIU A0, ZERO, 78
9D033890  00002821   ADDU A1, ZERO, ZERO
9D033894  00C41021   ADDU V0, A2, A0
9D033898  0046402B   SLTU T0, V0, A2
9D03389C  00E51821   ADDU V1, A3, A1
9D0338A0  01032021   ADDU A0, T0, V1
9D0338A4  00801821   ADDU V1, A0, ZERO
9D0338A8  00402021   ADDU A0, V0, ZERO
9D0338AC  00602821   ADDU A1, V1, ZERO
9D0338B0  2406009C   ADDIU A2, ZERO, 156
9D0338B4  00003821   ADDU A3, ZERO, ZERO
9D0338B8  0F40C887   JAL __udivdi3
9D0338BC  00000000   NOP
369:                 }
9D0338C0  03C0E821   ADDU SP, S8, ZERO
9D0338C4  8FBF0014   LW RA, 20(SP)
9D0338C8  8FBE0010   LW S8, 16(SP)
9D0338CC  27BD0018   ADDIU SP, SP, 24
9D0338D0  03E00008   JR RA
9D0338D4  00000000   NOP
370:                 
371:                 
372:                 /*****************************************************************************
373:                   Function:
374:                 	void TickUpdate(void)
375:                 
376:                   Description:
377:                 	Updates the tick value when an interrupt occurs.
378:                 
379:                   Precondition:
380:                 	None
381:                 
382:                   Parameters:
383:                 	None
384:                 
385:                   Returns:
386:                   	None
387:                   ***************************************************************************/
388:                 #if defined(__18CXX)
389:                 void TickUpdate(void)
390:                 {
391:                     if(INTCONbits.TMR0IF)
392:                     {
393:                 		// Increment internal high tick counter
394:                 		dwInternalTicks++;
395:                 
396:                 		// Reset interrupt flag
397:                         INTCONbits.TMR0IF = 0;
398:                     }
399:                 }
400:                 
401:                 /*****************************************************************************
402:                   Function:
403:                 	void _ISR _T1Interrupt(void)
404:                 
405:                   Description:
406:                 	Updates the tick value when an interrupt occurs.
407:                 
408:                   Precondition:
409:                 	None
410:                 
411:                   Parameters:
412:                 	None
413:                 
414:                   Returns:
415:                   	None
416:                   ***************************************************************************/
417:                 #elif defined(__PIC32MX__)
418:                 void __attribute((interrupt(ipl2), vector(_TIMER_2_VECTOR), nomips16)) _T2Interrupt(void)
419:                 {
9D0338D8  415DE800   RDPGPR SP, SP
9D0338DC  401A7000   MFC0 K0, EPC
9D0338E0  401B6000   MFC0 K1, Status
9D0338E4  27BDFFE8   ADDIU SP, SP, -24
9D0338E8  AFBA0014   SW K0, 20(SP)
9D0338EC  AFBB0010   SW K1, 16(SP)
9D0338F0  7C1B7844   INS K1, ZERO, 1, 15
9D0338F4  377B0800   ORI K1, K1, 2048
9D0338F8  409B6000   MTC0 K1, Status
9D0338FC  AFBE000C   SW S8, 12(SP)
9D033900  AFA30008   SW V1, 8(SP)
9D033904  AFA20004   SW V0, 4(SP)
9D033908  03A0F021   ADDU S8, SP, ZERO
420:                 	// Increment internal high tick counter
421:                 	dwInternalTicks++;
9D03390C  8F8281A4   LW V0, -32348(GP)
9D033910  24420001   ADDIU V0, V0, 1
9D033914  AF8281A4   SW V0, -32348(GP)
422:                 
423:                 	// Reset interrupt flag
424:                 	IFS0CLR = _IFS0_T2IF_MASK;
9D033918  3C02BF88   LUI V0, -16504
9D03391C  24030100   ADDIU V1, ZERO, 256
9D033920  AC431034   SW V1, 4148(V0)
425:                 }
9D033924  03C0E821   ADDU SP, S8, ZERO
9D033928  8FBE000C   LW S8, 12(SP)
9D03392C  8FA30008   LW V1, 8(SP)
9D033930  8FA20004   LW V0, 4(SP)
9D033934  41606000   DI ZERO
9D033938  000000C0   EHB
9D03393C  8FBA0014   LW K0, 20(SP)
9D033940  8FBB0010   LW K1, 16(SP)
9D033944  409A7000   MTC0 K0, EPC
9D033948  27BD0018   ADDIU SP, SP, 24
9D03394C  41DDE800   WRPGPR SP, SP
9D033950  409B6000   MTC0 K1, Status
9D033954  42000018   ERET
426:                 #else
427:                 #if __C30_VERSION__ >= 300
428:                 void _ISR __attribute__((__no_auto_psv__)) _T1Interrupt(void)
429:                 #else
430:                 void _ISR _T1Interrupt(void)
431:                 #endif
432:                 {
433:                 	// Increment internal high tick counter
434:                 	dwInternalTicks++;
435:                 
436:                 	// Reset interrupt flag
437:                 	IFS0bits.T1IF = 0;
438:                 }
439:                 #endif
---  C:/Users/Diego/Documents/GitHub/pic32webFREERtos/Pic32Web.X/src/tcpip/src/Telnet.c  ----------------
1:                   /*********************************************************************
2:                    *
3:                    *	Telnet Server
4:                    *  Module for Microchip TCP/IP Stack
5:                    *	 -Provides Telnet services on TCP port 23
6:                    *	 -Reference: RFC 854
7:                    *
8:                    *********************************************************************
9:                    * FileName:        Telnet.c
10:                   * Dependencies:    TCP
11:                   * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32
12:                   * Compiler:        Microchip C32 v1.05 or higher
13:                   *					Microchip C30 v3.12 or higher
14:                   *					Microchip C18 v3.30 or higher
15:                   *					HI-TECH PICC-18 PRO 9.63PL2 or higher
16:                   * Company:         Microchip Technology, Inc.
17:                   *
18:                   * Software License Agreement
19:                   *
20:                   * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights
21:                   * reserved.
22:                   *
23:                   * Microchip licenses to you the right to use, modify, copy, and
24:                   * distribute:
25:                   * (i)  the Software when embedded on a Microchip microcontroller or
26:                   *      digital signal controller product ("Device") which is
27:                   *      integrated into Licensee's product; or
28:                   * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h,
29:                   *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device
30:                   *		used in conjunction with a Microchip ethernet controller for
31:                   *		the sole purpose of interfacing with the ethernet controller.
32:                   *
33:                   * You should refer to the license agreement accompanying this
34:                   * Software for additional information regarding your rights and
35:                   * obligations.
36:                   *
37:                   * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT
38:                   * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT
39:                   * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A
40:                   * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL
41:                   * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR
42:                   * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF
43:                   * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS
44:                   * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE
45:                   * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER
46:                   * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT
47:                   * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE.
48:                   *
49:                   *
50:                   * Author               Date    Comment
51:                   *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
52:                   * Howard Schlunder     9/12/06	Original
53:                   ********************************************************************/
54:                  #define __TELNET_C
55:                  
56:                  #include "TCPIPConfig.h"
57:                  
58:                  #if defined(STACK_USE_TELNET_SERVER)
59:                  
60:                  #include "TCPIP Stack/TCPIP.h"
61:                  
62:                  // Set up configuration parameter defaults if not overridden in 
63:                  // TCPIPConfig.h
64:                  #if !defined(TELNET_PORT)
65:                      // Unsecured Telnet port
66:                  	#define TELNET_PORT			23
67:                  #endif
68:                  #if !defined(TELNETS_PORT)	
69:                      // SSL Secured Telnet port (ignored if STACK_USE_SSL_SERVER is undefined)
70:                  	#define TELNETS_PORT		992	
71:                  #endif
72:                  #if !defined(MAX_TELNET_CONNECTIONS)
73:                      // Maximum number of Telnet connections
74:                  	#define MAX_TELNET_CONNECTIONS	(3u)
75:                  #endif
76:                  #if !defined(TELNET_USERNAME)
77:                      // Default Telnet user name
78:                  	#define TELNET_USERNAME		"admin"
79:                  #endif
80:                  #if !defined(TELNET_PASSWORD)
81:                      // Default Telnet password
82:                  	#define TELNET_PASSWORD		"microchip"
83:                  #endif
84:                  
85:                  // Demo title string
86:                  static ROM BYTE strTitle[]			= "\x1b[2J\x1b[31m\x1b[1m"	// 2J is clear screen, 31m is red, 1m is bold
87:                  									  "Microchip Telnet Server 1.1\x1b[0m\r\n"	// 0m is clear all attributes
88:                  									  "(for this demo, type 'admin' for the login and 'microchip' for the password.)\r\n"
89:                  								  	  "Login: ";
90:                  // Demo password
91:                  static ROM BYTE strPassword[]		= "Password: \xff\xfd\x2d";	// DO Suppress Local Echo (stop telnet client from printing typed characters)
92:                  // Access denied message
93:                  static ROM BYTE strAccessDenied[]	= "\r\nAccess denied\r\n\r\n";
94:                  // Successful authentication message
95:                  static ROM BYTE strAuthenticated[]	= "\r\nLogged in successfully\r\n\r\n"
96:                  									  "\r\nPress 'q' to quit\r\n";
97:                  // Demo output string
98:                  static ROM BYTE strDisplay[]		= "\r\nSNTP Time:    (disabled)"
99:                  									  "\r\nAnalog:             1023"
100:                 									  "\r\nButtons:         3 2 1 0"
101:                 									  "\r\nLEDs:    7 6 5 4 3 2 1 0";
102:                 // String with extra spaces, for Demo
103:                 static ROM BYTE strSpaces[]			= "          ";
104:                 // Demo disconnection message
105:                 static ROM BYTE strGoodBye[]		= "\r\n\r\nGoodbye!\r\n";
106:                 
107:                 extern BYTE AN0String[8];
108:                 
109:                 /*********************************************************************
110:                  * Function:        void TelnetTask(void)
111:                  *
112:                  * PreCondition:    Stack is initialized()
113:                  *
114:                  * Input:           None
115:                  *
116:                  * Output:          None
117:                  *
118:                  * Side Effects:    None
119:                  *
120:                  * Overview:        Performs Telnet Server related tasks.  Contains
121:                  *                  the Telnet state machine and state tracking
122:                  *                  variables.
123:                  *
124:                  * Note:            None
125:                  ********************************************************************/
126:                 void TelnetTask(void)
127:                 {
9D02CA60  27BDFFB8   ADDIU SP, SP, -72
9D02CA64  AFBF0044   SW RA, 68(SP)
9D02CA68  AFBE0040   SW S8, 64(SP)
9D02CA6C  AFB0003C   SW S0, 60(SP)
9D02CA70  03A0F021   ADDU S8, SP, ZERO
128:                 	BYTE 		i;
129:                 	BYTE		vTelnetSession;
130:                 	WORD		w, w2;
131:                 	TCP_SOCKET	MySocket;
132:                 	enum
133:                 	{
134:                 		SM_HOME = 0,
135:                 		SM_PRINT_LOGIN,
136:                 		SM_GET_LOGIN,
137:                 		SM_GET_PASSWORD,
138:                 		SM_GET_PASSWORD_BAD_LOGIN,
139:                 		SM_AUTHENTICATED,
140:                 		SM_REFRESH_VALUES
141:                 	} TelnetState;
142:                 	static TCP_SOCKET hTelnetSockets[MAX_TELNET_CONNECTIONS];
143:                 	static BYTE vTelnetStates[MAX_TELNET_CONNECTIONS];
144:                 	static BOOL bInitialized = FALSE;
145:                 
146:                 	// Perform one time initialization on power up
147:                 	if(!bInitialized)
9D02CA74  8F828194   LW V0, -32364(GP)
9D02CA78  14400015   BNE V0, ZERO, 0x9D02CAD0
9D02CA7C  00000000   NOP
148:                 	{
149:                 		for(vTelnetSession = 0; vTelnetSession < MAX_TELNET_CONNECTIONS; vTelnetSession++)
9D02CA80  A3C00018   SB ZERO, 24(S8)
9D02CA84  0B40B2AF   J 0x9D02CABC
9D02CA88  00000000   NOP
9D02CAB0  93C20018   LBU V0, 24(S8)
9D02CAB4  24420001   ADDIU V0, V0, 1
9D02CAB8  A3C20018   SB V0, 24(S8)
9D02CABC  93C20018   LBU V0, 24(S8)
9D02CAC0  1040FFF2   BEQ V0, ZERO, 0x9D02CA8C
9D02CAC4  00000000   NOP
150:                 		{
151:                 			hTelnetSockets[vTelnetSession] = INVALID_SOCKET;
9D02CA8C  93C30018   LBU V1, 24(S8)
9D02CA90  27828198   ADDIU V0, GP, -32360
9D02CA94  00621021   ADDU V0, V1, V0
9D02CA98  2403FFFE   ADDIU V1, ZERO, -2
9D02CA9C  A0430000   SB V1, 0(V0)
152:                 			vTelnetStates[vTelnetSession] = SM_HOME;
9D02CAA0  93C30018   LBU V1, 24(S8)
9D02CAA4  2782819C   ADDIU V0, GP, -32356
9D02CAA8  00621021   ADDU V0, V1, V0
9D02CAAC  A0400000   SB ZERO, 0(V0)
153:                 		}
154:                 		bInitialized = TRUE;
9D02CAC8  24020001   ADDIU V0, ZERO, 1
9D02CACC  AF828194   SW V0, -32364(GP)
155:                 	}
156:                 
157:                 
158:                 	// Loop through each telnet session and process state changes and TX/RX data
159:                 	for(vTelnetSession = 0; vTelnetSession < MAX_TELNET_CONNECTIONS; vTelnetSession++)
9D02CAD0  A3C00018   SB ZERO, 24(S8)
9D02CAD4  0B40B562   J 0x9D02D588
9D02CAD8  00000000   NOP
9D02D57C  93C20018   LBU V0, 24(S8)
9D02D580  24420001   ADDIU V0, V0, 1
9D02D584  A3C20018   SB V0, 24(S8)
9D02D588  93C20018   LBU V0, 24(S8)
9D02D58C  1040FD53   BEQ V0, ZERO, 0x9D02CADC
9D02D590  00000000   NOP
160:                 	{
161:                 		// Load up static state information for this session
162:                 		MySocket = hTelnetSockets[vTelnetSession];
9D02CADC  93C30018   LBU V1, 24(S8)
9D02CAE0  27828198   ADDIU V0, GP, -32360
9D02CAE4  00621021   ADDU V0, V1, V0
9D02CAE8  90420000   LBU V0, 0(V0)
9D02CAEC  A3C20019   SB V0, 25(S8)
163:                 		TelnetState = vTelnetStates[vTelnetSession];
9D02CAF0  93C30018   LBU V1, 24(S8)
9D02CAF4  2782819C   ADDIU V0, GP, -32356
9D02CAF8  00621021   ADDU V0, V1, V0
9D02CAFC  90420000   LBU V0, 0(V0)
9D02CB00  AFC2001C   SW V0, 28(S8)
164:                 
165:                 		// Reset our state if the remote client disconnected from us
166:                 		if(MySocket != INVALID_SOCKET)
9D02CB04  93C30019   LBU V1, 25(S8)
9D02CB08  240200FE   ADDIU V0, ZERO, 254
9D02CB0C  10620009   BEQ V1, V0, 0x9D02CB34
9D02CB10  00000000   NOP
167:                 		{
168:                 			if(TCPWasReset(MySocket))
9D02CB14  93C20019   LBU V0, 25(S8)
9D02CB18  00402021   ADDU A0, V0, ZERO
9D02CB1C  0F400229   JAL TCPWasReset
9D02CB20  00000000   NOP
9D02CB24  10400003   BEQ V0, ZERO, 0x9D02CB34
9D02CB28  00000000   NOP
169:                 				TelnetState = SM_PRINT_LOGIN;
9D02CB2C  24020001   ADDIU V0, ZERO, 1
9D02CB30  AFC2001C   SW V0, 28(S8)
170:                 		}
171:                 	
172:                 		// Handle session state
173:                 		switch(TelnetState)
9D02CB34  8FC2001C   LW V0, 28(S8)
9D02CB38  2C420007   SLTIU V0, V0, 7
9D02CB3C  10400284   BEQ V0, ZERO, 0x9D02D550
9D02CB40  00000000   NOP
9D02CB44  8FC2001C   LW V0, 28(S8)
9D02CB48  00021880   SLL V1, V0, 2
9D02CB4C  3C029D03   LUI V0, -25341
9D02CB50  2442CB64   ADDIU V0, V0, -13468
9D02CB54  00621021   ADDU V0, V1, V0
9D02CB58  8C420000   LW V0, 0(V0)
9D02CB5C  00400008   JR V0
9D02CB60  00000000   NOP
174:                 		{
175:                 			case SM_HOME:
176:                 				// Connect a socket to the remote TCP server
177:                 				MySocket = TCPOpen(0, TCP_OPEN_SERVER, TELNET_PORT, TCP_PURPOSE_TELNET);
9D02CB80  00002021   ADDU A0, ZERO, ZERO
9D02CB84  00002821   ADDU A1, ZERO, ZERO
9D02CB88  24060017   ADDIU A2, ZERO, 23
9D02CB8C  24070002   ADDIU A3, ZERO, 2
9D02CB90  0F400109   JAL TCPOpen
9D02CB94  00000000   NOP
9D02CB98  A3C20019   SB V0, 25(S8)
178:                 				
179:                 				// Abort operation if no TCP socket of type TCP_PURPOSE_TELNET is available
180:                 				// If this ever happens, you need to go add one to TCPIPConfig.h
181:                 				if(MySocket == INVALID_SOCKET)
9D02CB9C  93C30019   LBU V1, 25(S8)
9D02CBA0  240200FE   ADDIU V0, ZERO, 254
9D02CBA4  10620251   BEQ V1, V0, 0x9D02D4EC
9D02CBA8  00000000   NOP
182:                 					break;
9D02D4EC  00000000   NOP
9D02D4F0  0B40B554   J 0x9D02D550
9D02D4F4  00000000   NOP
183:                 	
184:                 				// Open an SSL listener if SSL server support is enabled
185:                 				#if defined(STACK_USE_SSL_SERVER)
186:                 					TCPAddSSLListener(MySocket, TELNETS_PORT);
187:                 				#endif
188:                 	
189:                 				TelnetState++;
9D02CBAC  8FC2001C   LW V0, 28(S8)
9D02CBB0  24420001   ADDIU V0, V0, 1
9D02CBB4  AFC2001C   SW V0, 28(S8)
190:                 				break;
9D02CBB8  0B40B554   J 0x9D02D550
9D02CBBC  00000000   NOP
191:                 	
192:                 			case SM_PRINT_LOGIN:
193:                 				#if defined(STACK_USE_SSL_SERVER)
194:                 					// Reject unsecured connections if TELNET_REJECT_UNSECURED is defined
195:                 					#if defined(TELNET_REJECT_UNSECURED)
196:                 						if(!TCPIsSSL(MySocket))
197:                 						{
198:                 							if(TCPIsConnected(MySocket))
199:                 							{
200:                 								TCPDisconnect(MySocket);
201:                 								TCPDisconnect(MySocket);
202:                 								break;
203:                 							}	
204:                 						}
205:                 					#endif
206:                 						
207:                 					// Don't attempt to transmit anything if we are still handshaking.
208:                 					if(TCPSSLIsHandshaking(MySocket))
209:                 						break;
210:                 				#endif
211:                 				
212:                 				// Make certain the socket can be written to
213:                 				if(TCPIsPutReady(MySocket) < strlenpgm((ROM char*)strTitle))
9D02CBC0  93C20019   LBU V0, 25(S8)
9D02CBC4  00402021   ADDU A0, V0, ZERO
9D02CBC8  0F40038E   JAL TCPIsPutReady
9D02CBCC  00000000   NOP
9D02CBD0  2C420084   SLTIU V0, V0, 132
9D02CBD4  14400248   BNE V0, ZERO, 0x9D02D4F8
9D02CBD8  00000000   NOP
214:                 					break;
9D02D4F8  00000000   NOP
9D02D4FC  0B40B554   J 0x9D02D550
9D02D500  00000000   NOP
215:                 				
216:                 				// Place the application protocol data into the transmit buffer.
217:                 				TCPPutROMString(MySocket, strTitle);
9D02CBDC  93C20019   LBU V0, 25(S8)
9D02CBE0  00402021   ADDU A0, V0, ZERO
9D02CBE4  3C029D03   LUI V0, -25341
9D02CBE8  24454564   ADDIU A1, V0, 17764
9D02CBEC  0F4005FD   JAL TCPPutString
9D02CBF0  00000000   NOP
218:                 	
219:                 				// Send the packet
220:                 				TCPFlush(MySocket);
9D02CBF4  93C20019   LBU V0, 25(S8)
9D02CBF8  00402021   ADDU A0, V0, ZERO
9D02CBFC  0F400366   JAL TCPFlush
9D02CC00  00000000   NOP
221:                 				TelnetState++;
9D02CC04  8FC2001C   LW V0, 28(S8)
9D02CC08  24420001   ADDIU V0, V0, 1
9D02CC0C  AFC2001C   SW V0, 28(S8)
222:                 	
223:                 			case SM_GET_LOGIN:
224:                 				// Make sure we can put the password prompt
225:                 				if(TCPIsPutReady(MySocket) < strlenpgm((ROM char*)strPassword))
9D02CC10  93C20019   LBU V0, 25(S8)
9D02CC14  00402021   ADDU A0, V0, ZERO
9D02CC18  0F40038E   JAL TCPIsPutReady
9D02CC1C  00000000   NOP
9D02CC20  2C42000D   SLTIU V0, V0, 13
9D02CC24  14400237   BNE V0, ZERO, 0x9D02D504
9D02CC28  00000000   NOP
226:                 					break;
9D02D504  00000000   NOP
9D02D508  0B40B554   J 0x9D02D550
9D02D50C  00000000   NOP
227:                 	
228:                 				// See if the user pressed return
229:                 				w = TCPFind(MySocket, '\n', 0, FALSE);
9D02CC2C  93C20019   LBU V0, 25(S8)
9D02CC30  AFA00010   SW ZERO, 16(SP)
9D02CC34  00402021   ADDU A0, V0, ZERO
9D02CC38  2405000A   ADDIU A1, ZERO, 10
9D02CC3C  00003021   ADDU A2, ZERO, ZERO
9D02CC40  00003821   ADDU A3, ZERO, ZERO
9D02CC44  0F400AEB   JAL TCPFindEx
9D02CC48  00000000   NOP
9D02CC4C  A7C20020   SH V0, 32(S8)
230:                 				if(w == 0xFFFFu)
9D02CC50  97C30020   LHU V1, 32(S8)
9D02CC54  3402FFFF   ORI V0, ZERO, -1
9D02CC58  14620014   BNE V1, V0, 0x9D02CCAC
9D02CC5C  00000000   NOP
231:                 				{
232:                 					if(TCPGetRxFIFOFree(MySocket) == 0u)
9D02CC60  93C20019   LBU V0, 25(S8)
9D02CC64  00402021   ADDU A0, V0, ZERO
9D02CC68  0F400868   JAL TCPGetRxFIFOFree
9D02CC6C  00000000   NOP
9D02CC70  14400227   BNE V0, ZERO, 0x9D02D510
9D02CC74  00000000   NOP
233:                 					{
234:                 						TCPPutROMString(MySocket, (ROM BYTE*)"\r\nToo much data.\r\n");
9D02CC78  93C30019   LBU V1, 25(S8)
9D02CC7C  3C029D03   LUI V0, -25341
9D02CC80  244246CC   ADDIU V0, V0, 18124
9D02CC84  00602021   ADDU A0, V1, ZERO
9D02CC88  00402821   ADDU A1, V0, ZERO
9D02CC8C  0F4005FD   JAL TCPPutString
9D02CC90  00000000   NOP
235:                 						TCPDisconnect(MySocket);
9D02CC94  93C20019   LBU V0, 25(S8)
9D02CC98  00402021   ADDU A0, V0, ZERO
9D02CC9C  0F400273   JAL TCPDisconnect
9D02CCA0  00000000   NOP
236:                 					}
237:                 	
238:                 					break;
9D02CCA4  0B40B554   J 0x9D02D550
9D02CCA8  00000000   NOP
9D02D510  00000000   NOP
9D02D514  0B40B554   J 0x9D02D550
9D02D518  00000000   NOP
239:                 				}
240:                 			
241:                 				// Search for the username -- case insensitive
242:                 				w2 = TCPFindROMArray(MySocket, (ROM BYTE*)TELNET_USERNAME, sizeof(TELNET_USERNAME)-1, 0, TRUE);
9D02CCAC  93C30019   LBU V1, 25(S8)
9D02CCB0  3C029D03   LUI V0, -25341
9D02CCB4  244246E0   ADDIU V0, V0, 18144
9D02CCB8  AFA00010   SW ZERO, 16(SP)
9D02CCBC  24040001   ADDIU A0, ZERO, 1
9D02CCC0  AFA40014   SW A0, 20(SP)
9D02CCC4  00602021   ADDU A0, V1, ZERO
9D02CCC8  00402821   ADDU A1, V0, ZERO
9D02CCCC  24060005   ADDIU A2, ZERO, 5
9D02CCD0  00003821   ADDU A3, ZERO, ZERO
9D02CCD4  0F400960   JAL TCPFindArrayEx
9D02CCD8  00000000   NOP
9D02CCDC  A7C20022   SH V0, 34(S8)
243:                 				if((w2 != 0u) || !((sizeof(TELNET_USERNAME)-1 == w) || (sizeof(TELNET_USERNAME) == w)))
9D02CCE0  97C20022   LHU V0, 34(S8)
9D02CCE4  14400009   BNE V0, ZERO, 0x9D02CD0C
9D02CCE8  00000000   NOP
9D02CCEC  97C30020   LHU V1, 32(S8)
9D02CCF0  24020005   ADDIU V0, ZERO, 5
9D02CCF4  10620009   BEQ V1, V0, 0x9D02CD1C
9D02CCF8  00000000   NOP
9D02CCFC  97C30020   LHU V1, 32(S8)
9D02CD00  24020006   ADDIU V0, ZERO, 6
9D02CD04  10620005   BEQ V1, V0, 0x9D02CD1C
9D02CD08  00000000   NOP
244:                 				{
245:                 					// Did not find the username, but let's pretend we did so we don't leak the user name validity
246:                 					TelnetState = SM_GET_PASSWORD_BAD_LOGIN;	
9D02CD0C  24020004   ADDIU V0, ZERO, 4
9D02CD10  AFC2001C   SW V0, 28(S8)
9D02CD14  0B40B349   J 0x9D02CD24
9D02CD18  00000000   NOP
247:                 				}
248:                 				else
249:                 				{
250:                 					TelnetState = SM_GET_PASSWORD;
9D02CD1C  24020003   ADDIU V0, ZERO, 3
9D02CD20  AFC2001C   SW V0, 28(S8)
251:                 				}
252:                 	
253:                 				// Username verified, throw this line of data away
254:                 				TCPGetArray(MySocket, NULL, w + 1);
9D02CD24  93C30019   LBU V1, 25(S8)
9D02CD28  97C20020   LHU V0, 32(S8)
9D02CD2C  24420001   ADDIU V0, V0, 1
9D02CD30  3042FFFF   ANDI V0, V0, -1
9D02CD34  00602021   ADDU A0, V1, ZERO
9D02CD38  00002821   ADDU A1, ZERO, ZERO
9D02CD3C  00403021   ADDU A2, V0, ZERO
9D02CD40  0F40077A   JAL TCPGetArray
9D02CD44  00000000   NOP
255:                 	
256:                 				// Print the password prompt
257:                 				TCPPutROMString(MySocket, strPassword);
9D02CD48  93C20019   LBU V0, 25(S8)
9D02CD4C  00402021   ADDU A0, V0, ZERO
9D02CD50  3C029D03   LUI V0, -25341
9D02CD54  244545EC   ADDIU A1, V0, 17900
9D02CD58  0F4005FD   JAL TCPPutString
9D02CD5C  00000000   NOP
258:                 				TCPFlush(MySocket);
9D02CD60  93C20019   LBU V0, 25(S8)
9D02CD64  00402021   ADDU A0, V0, ZERO
9D02CD68  0F400366   JAL TCPFlush
9D02CD6C  00000000   NOP
259:                 				break;
9D02CD70  0B40B554   J 0x9D02D550
9D02CD74  00000000   NOP
260:                 	
261:                 			case SM_GET_PASSWORD:
262:                 			case SM_GET_PASSWORD_BAD_LOGIN:
263:                 				// Make sure we can put the authenticated prompt
264:                 				if(TCPIsPutReady(MySocket) < strlenpgm((ROM char*)strAuthenticated))
9D02CD78  93C20019   LBU V0, 25(S8)
9D02CD7C  00402021   ADDU A0, V0, ZERO
9D02CD80  0F40038E   JAL TCPIsPutReady
9D02CD84  00000000   NOP
9D02CD88  2C420031   SLTIU V0, V0, 49
9D02CD8C  144001E3   BNE V0, ZERO, 0x9D02D51C
9D02CD90  00000000   NOP
265:                 					break;
9D02D51C  00000000   NOP
9D02D520  0B40B554   J 0x9D02D550
9D02D524  00000000   NOP
266:                 	
267:                 				// See if the user pressed return
268:                 				w = TCPFind(MySocket, '\n', 0, FALSE);
9D02CD94  93C20019   LBU V0, 25(S8)
9D02CD98  AFA00010   SW ZERO, 16(SP)
9D02CD9C  00402021   ADDU A0, V0, ZERO
9D02CDA0  2405000A   ADDIU A1, ZERO, 10
9D02CDA4  00003021   ADDU A2, ZERO, ZERO
9D02CDA8  00003821   ADDU A3, ZERO, ZERO
9D02CDAC  0F400AEB   JAL TCPFindEx
9D02CDB0  00000000   NOP
9D02CDB4  A7C20020   SH V0, 32(S8)
269:                 				if(w == 0xFFFFu)
9D02CDB8  97C30020   LHU V1, 32(S8)
9D02CDBC  3402FFFF   ORI V0, ZERO, -1
9D02CDC0  14620014   BNE V1, V0, 0x9D02CE14
9D02CDC4  00000000   NOP
270:                 				{
271:                 					if(TCPGetRxFIFOFree(MySocket) == 0u)
9D02CDC8  93C20019   LBU V0, 25(S8)
9D02CDCC  00402021   ADDU A0, V0, ZERO
9D02CDD0  0F400868   JAL TCPGetRxFIFOFree
9D02CDD4  00000000   NOP
9D02CDD8  144001D3   BNE V0, ZERO, 0x9D02D528
9D02CDDC  00000000   NOP
272:                 					{
273:                 						TCPPutROMString(MySocket, (ROM BYTE*)"Too much data.\r\n");
9D02CDE0  93C30019   LBU V1, 25(S8)
9D02CDE4  3C029D03   LUI V0, -25341
9D02CDE8  244246E8   ADDIU V0, V0, 18152
9D02CDEC  00602021   ADDU A0, V1, ZERO
9D02CDF0  00402821   ADDU A1, V0, ZERO
9D02CDF4  0F4005FD   JAL TCPPutString
9D02CDF8  00000000   NOP
274:                 						TCPDisconnect(MySocket);
9D02CDFC  93C20019   LBU V0, 25(S8)
9D02CE00  00402021   ADDU A0, V0, ZERO
9D02CE04  0F400273   JAL TCPDisconnect
9D02CE08  00000000   NOP
275:                 					}
276:                 	
277:                 					break;
9D02CE0C  0B40B554   J 0x9D02D550
9D02CE10  00000000   NOP
9D02D528  00000000   NOP
9D02D52C  0B40B554   J 0x9D02D550
9D02D530  00000000   NOP
278:                 				}
279:                 	
280:                 				// Search for the password -- case sensitive
281:                 				w2 = TCPFindROMArray(MySocket, (ROM BYTE*)TELNET_PASSWORD, sizeof(TELNET_PASSWORD)-1, 0, FALSE);
9D02CE14  93C30019   LBU V1, 25(S8)
9D02CE18  3C029D03   LUI V0, -25341
9D02CE1C  244246FC   ADDIU V0, V0, 18172
9D02CE20  AFA00010   SW ZERO, 16(SP)
9D02CE24  AFA00014   SW ZERO, 20(SP)
9D02CE28  00602021   ADDU A0, V1, ZERO
9D02CE2C  00402821   ADDU A1, V0, ZERO
9D02CE30  24060009   ADDIU A2, ZERO, 9
9D02CE34  00003821   ADDU A3, ZERO, ZERO
9D02CE38  0F400960   JAL TCPFindArrayEx
9D02CE3C  00000000   NOP
9D02CE40  A7C20022   SH V0, 34(S8)
282:                 				if((w2 != 3u) || !((sizeof(TELNET_PASSWORD)-1 == w-3) || (sizeof(TELNET_PASSWORD) == w-3)) || (TelnetState == SM_GET_PASSWORD_BAD_LOGIN))
9D02CE44  97C30022   LHU V1, 34(S8)
9D02CE48  24020003   ADDIU V0, ZERO, 3
9D02CE4C  1462000D   BNE V1, V0, 0x9D02CE84
9D02CE50  00000000   NOP
9D02CE54  97C30020   LHU V1, 32(S8)
9D02CE58  2402000C   ADDIU V0, ZERO, 12
9D02CE5C  10620005   BEQ V1, V0, 0x9D02CE74
9D02CE60  00000000   NOP
9D02CE64  97C30020   LHU V1, 32(S8)
9D02CE68  2402000D   ADDIU V0, ZERO, 13
9D02CE6C  14620005   BNE V1, V0, 0x9D02CE84
9D02CE70  00000000   NOP
9D02CE74  8FC3001C   LW V1, 28(S8)
9D02CE78  24020004   ADDIU V0, ZERO, 4
9D02CE7C  1462000F   BNE V1, V0, 0x9D02CEBC
9D02CE80  00000000   NOP
283:                 				{
284:                 					// Did not find the password
285:                 					TelnetState = SM_PRINT_LOGIN;	
9D02CE84  24020001   ADDIU V0, ZERO, 1
9D02CE88  AFC2001C   SW V0, 28(S8)
286:                 					TCPPutROMString(MySocket, strAccessDenied);
9D02CE8C  93C20019   LBU V0, 25(S8)
9D02CE90  00402021   ADDU A0, V0, ZERO
9D02CE94  3C029D03   LUI V0, -25341
9D02CE98  244545FC   ADDIU A1, V0, 17916
9D02CE9C  0F4005FD   JAL TCPPutString
9D02CEA0  00000000   NOP
287:                 					TCPDisconnect(MySocket);
9D02CEA4  93C20019   LBU V0, 25(S8)
9D02CEA8  00402021   ADDU A0, V0, ZERO
9D02CEAC  0F400273   JAL TCPDisconnect
9D02CEB0  00000000   NOP
288:                 					break;
9D02CEB4  0B40B554   J 0x9D02D550
9D02CEB8  00000000   NOP
289:                 				}
290:                 	
291:                 				// Password verified, throw this line of data away
292:                 				TCPGetArray(MySocket, NULL, w + 1);
9D02CEBC  93C30019   LBU V1, 25(S8)
9D02CEC0  97C20020   LHU V0, 32(S8)
9D02CEC4  24420001   ADDIU V0, V0, 1
9D02CEC8  3042FFFF   ANDI V0, V0, -1
9D02CECC  00602021   ADDU A0, V1, ZERO
9D02CED0  00002821   ADDU A1, ZERO, ZERO
9D02CED4  00403021   ADDU A2, V0, ZERO
9D02CED8  0F40077A   JAL TCPGetArray
9D02CEDC  00000000   NOP
293:                 	
294:                 				// Print the authenticated prompt
295:                 				TCPPutROMString(MySocket, strAuthenticated);
9D02CEE0  93C20019   LBU V0, 25(S8)
9D02CEE4  00402021   ADDU A0, V0, ZERO
9D02CEE8  3C029D03   LUI V0, -25341
9D02CEEC  24454610   ADDIU A1, V0, 17936
9D02CEF0  0F4005FD   JAL TCPPutString
9D02CEF4  00000000   NOP
296:                 				TelnetState = SM_AUTHENTICATED;
9D02CEF8  24020005   ADDIU V0, ZERO, 5
9D02CEFC  AFC2001C   SW V0, 28(S8)
297:                 				// No break
298:                 		
299:                 			case SM_AUTHENTICATED:
300:                 				if(TCPIsPutReady(MySocket) < strlenpgm((ROM char*)strDisplay) + 4)
9D02CF00  93C20019   LBU V0, 25(S8)
9D02CF04  00402021   ADDU A0, V0, ZERO
9D02CF08  0F40038E   JAL TCPIsPutReady
9D02CF0C  00000000   NOP
9D02CF10  2C42006C   SLTIU V0, V0, 108
9D02CF14  14400187   BNE V0, ZERO, 0x9D02D534
9D02CF18  00000000   NOP
301:                 					break;
9D02D534  00000000   NOP
9D02D538  0B40B554   J 0x9D02D550
9D02D53C  00000000   NOP
302:                 	
303:                 				TCPPutROMString(MySocket, strDisplay);
9D02CF1C  93C20019   LBU V0, 25(S8)
9D02CF20  00402021   ADDU A0, V0, ZERO
9D02CF24  3C029D03   LUI V0, -25341
9D02CF28  24454644   ADDIU A1, V0, 17988
9D02CF2C  0F4005FD   JAL TCPPutString
9D02CF30  00000000   NOP
304:                 				TelnetState++;
9D02CF34  8FC2001C   LW V0, 28(S8)
9D02CF38  24420001   ADDIU V0, V0, 1
9D02CF3C  AFC2001C   SW V0, 28(S8)
305:                 	
306:                 				// All future characters will be bold
307:                 				TCPPutROMString(MySocket, (ROM BYTE*)"\x1b[1m");
9D02CF40  93C30019   LBU V1, 25(S8)
9D02CF44  3C029D03   LUI V0, -25341
9D02CF48  24424708   ADDIU V0, V0, 18184
9D02CF4C  00602021   ADDU A0, V1, ZERO
9D02CF50  00402821   ADDU A1, V0, ZERO
9D02CF54  0F4005FD   JAL TCPPutString
9D02CF58  00000000   NOP
308:                 	
309:                 			case SM_REFRESH_VALUES:
310:                 				if(TCPIsPutReady(MySocket) >= 78u)
9D02CF5C  93C20019   LBU V0, 25(S8)
9D02CF60  00402021   ADDU A0, V0, ZERO
9D02CF64  0F40038E   JAL TCPIsPutReady
9D02CF68  00000000   NOP
9D02CF6C  2C42004E   SLTIU V0, V0, 78
9D02CF70  14400132   BNE V0, ZERO, 0x9D02D43C
9D02CF74  00000000   NOP
311:                 				{
312:                 					//[10;1]
313:                 					//"SNTP Time:    (disabled)\r\n"
314:                 					//"Analog:             1023\r\n"
315:                 					//"Buttons:         3 2 1 0\r\n"
316:                 					//"LEDs:    7 6 5 4 3 2 1 0\r\n"
317:                 		
318:                 					// Write current UTC seconds from SNTP module, if it is enable 
319:                 					// and has changed.  Note that conversion from a DWORD to an 
320:                 					// ASCII string can take a lot of CPU power, so we only print 
321:                 					// this if the value has changed.
322:                 					#if defined(STACK_USE_SNTP_CLIENT)
323:                 					{
324:                 						static DWORD dwTime;
325:                 						BYTE vTime[11];
326:                 						
327:                 						if(dwTime != SNTPGetUTCSeconds())
9D02CF78  0F40CB7B   JAL SNTPGetUTCSeconds
9D02CF7C  00000000   NOP
9D02CF80  00401821   ADDU V1, V0, ZERO
9D02CF84  8F8281A0   LW V0, -32352(GP)
9D02CF88  10620027   BEQ V1, V0, 0x9D02D028
9D02CF8C  00000000   NOP
328:                 						{
329:                 							
330:                 							// Position cursor at Line 10, Col 15
331:                 							TCPPutROMString(MySocket, (ROM BYTE*)"\x1b[10;15f");
9D02CF90  93C30019   LBU V1, 25(S8)
9D02CF94  3C029D03   LUI V0, -25341
9D02CF98  24424710   ADDIU V0, V0, 18192
9D02CF9C  00602021   ADDU A0, V1, ZERO
9D02CFA0  00402821   ADDU A1, V0, ZERO
9D02CFA4  0F4005FD   JAL TCPPutString
9D02CFA8  00000000   NOP
332:                 							dwTime = SNTPGetUTCSeconds();
9D02CFAC  0F40CB7B   JAL SNTPGetUTCSeconds
9D02CFB0  00000000   NOP
9D02CFB4  AF8281A0   SW V0, -32352(GP)
333:                 							ultoa(dwTime, vTime);
9D02CFB8  27C30028   ADDIU V1, S8, 40
9D02CFBC  8F8281A0   LW V0, -32352(GP)
9D02CFC0  00602021   ADDU A0, V1, ZERO
9D02CFC4  00402821   ADDU A1, V0, ZERO
9D02CFC8  2406000A   ADDIU A2, ZERO, 10
9D02CFCC  0F40D75B   JAL ultoa
9D02CFD0  00000000   NOP
334:                 							TCPPutROMArray(MySocket, (ROM BYTE*)strSpaces, 10-strlen((char*)vTime));							
9D02CFD4  93D00019   LBU S0, 25(S8)
9D02CFD8  27C20028   ADDIU V0, S8, 40
9D02CFDC  00402021   ADDU A0, V0, ZERO
9D02CFE0  0F40D2F2   JAL 0x9D034BC8
9D02CFE4  00000000   NOP
9D02CFE8  3042FFFF   ANDI V0, V0, -1
9D02CFEC  2403000A   ADDIU V1, ZERO, 10
9D02CFF0  00621023   SUBU V0, V1, V0
9D02CFF4  3042FFFF   ANDI V0, V0, -1
9D02CFF8  02002021   ADDU A0, S0, ZERO
9D02CFFC  3C039D03   LUI V1, -25341
9D02D000  246546B0   ADDIU A1, V1, 18096
9D02D004  00403021   ADDU A2, V0, ZERO
9D02D008  0F4004E1   JAL TCPPutArray
9D02D00C  00000000   NOP
335:                 							TCPPutString(MySocket, vTime);
9D02D010  93C30019   LBU V1, 25(S8)
9D02D014  27C20028   ADDIU V0, S8, 40
9D02D018  00602021   ADDU A0, V1, ZERO
9D02D01C  00402821   ADDU A1, V0, ZERO
9D02D020  0F4005FD   JAL TCPPutString
9D02D024  00000000   NOP
336:                 						}
337:                 					}
338:                 					#endif
339:                 	
340:                 					// Position cursor at Line 11, Col 21
341:                 					TCPPutROMString(MySocket, (ROM BYTE*)"\x1b[11;21f");
9D02D028  93C30019   LBU V1, 25(S8)
9D02D02C  3C029D03   LUI V0, -25341
9D02D030  2442471C   ADDIU V0, V0, 18204
9D02D034  00602021   ADDU A0, V1, ZERO
9D02D038  00402821   ADDU A1, V0, ZERO
9D02D03C  0F4005FD   JAL TCPPutString
9D02D040  00000000   NOP
342:                 	
343:                 					// Put analog value with space padding on right side for 4 characters
344:                 					TCPPutROMArray(MySocket, (ROM BYTE*)strSpaces, 4-strlen((char*)AN0String));
9D02D044  93D00019   LBU S0, 25(S8)
9D02D048  278281F0   ADDIU V0, GP, -32272
9D02D04C  00402021   ADDU A0, V0, ZERO
9D02D050  0F40D2F2   JAL 0x9D034BC8
9D02D054  00000000   NOP
9D02D058  3042FFFF   ANDI V0, V0, -1
9D02D05C  24030004   ADDIU V1, ZERO, 4
9D02D060  00621023   SUBU V0, V1, V0
9D02D064  3042FFFF   ANDI V0, V0, -1
9D02D068  02002021   ADDU A0, S0, ZERO
9D02D06C  3C039D03   LUI V1, -25341
9D02D070  246546B0   ADDIU A1, V1, 18096
9D02D074  00403021   ADDU A2, V0, ZERO
9D02D078  0F4004E1   JAL TCPPutArray
9D02D07C  00000000   NOP
345:                 					TCPPutString(MySocket, AN0String);
9D02D080  93C20019   LBU V0, 25(S8)
9D02D084  00402021   ADDU A0, V0, ZERO
9D02D088  278581F0   ADDIU A1, GP, -32272
9D02D08C  0F4005FD   JAL TCPPutString
9D02D090  00000000   NOP
346:                 	
347:                 					// Put Buttons
348:                 					TCPPutROMString(MySocket, (ROM BYTE*)"\x1b[12;18f");
9D02D094  93C30019   LBU V1, 25(S8)
9D02D098  3C029D03   LUI V0, -25341
9D02D09C  24424728   ADDIU V0, V0, 18216
9D02D0A0  00602021   ADDU A0, V1, ZERO
9D02D0A4  00402821   ADDU A1, V0, ZERO
9D02D0A8  0F4005FD   JAL TCPPutString
9D02D0AC  00000000   NOP
349:                 					TCPPut(MySocket, BUTTON3_IO ? '1':'0');
9D02D0B0  93C20019   LBU V0, 25(S8)
9D02D0B4  00402021   ADDU A0, V0, ZERO
9D02D0B8  24050031   ADDIU A1, ZERO, 49
9D02D0BC  0F40040C   JAL TCPPut
9D02D0C0  00000000   NOP
350:                 					TCPPut(MySocket, ' ');
9D02D0C4  93C20019   LBU V0, 25(S8)
9D02D0C8  00402021   ADDU A0, V0, ZERO
9D02D0CC  24050020   ADDIU A1, ZERO, 32
9D02D0D0  0F40040C   JAL TCPPut
9D02D0D4  00000000   NOP
351:                 					TCPPut(MySocket, BUTTON2_IO ? '1':'0');
9D02D0D8  93C30019   LBU V1, 25(S8)
9D02D0DC  3C02BF88   LUI V0, -16504
9D02D0E0  8C4260D0   LW V0, 24784(V0)
9D02D0E4  30422000   ANDI V0, V0, 8192
9D02D0E8  10400004   BEQ V0, ZERO, 0x9D02D0FC
9D02D0EC  00000000   NOP
9D02D0F0  24020031   ADDIU V0, ZERO, 49
9D02D0F4  0B40B440   J 0x9D02D100
9D02D0F8  00000000   NOP
9D02D0FC  24020030   ADDIU V0, ZERO, 48
9D02D100  00602021   ADDU A0, V1, ZERO
9D02D104  00402821   ADDU A1, V0, ZERO
9D02D108  0F40040C   JAL TCPPut
9D02D10C  00000000   NOP
352:                 					TCPPut(MySocket, ' ');
9D02D110  93C20019   LBU V0, 25(S8)
9D02D114  00402021   ADDU A0, V0, ZERO
9D02D118  24050020   ADDIU A1, ZERO, 32
9D02D11C  0F40040C   JAL TCPPut
9D02D120  00000000   NOP
353:                 					TCPPut(MySocket, BUTTON1_IO ? '1':'0');
9D02D124  93C30019   LBU V1, 25(S8)
9D02D128  3C02BF88   LUI V0, -16504
9D02D12C  8C4260D0   LW V0, 24784(V0)
9D02D130  30420080   ANDI V0, V0, 128
9D02D134  10400004   BEQ V0, ZERO, 0x9D02D148
9D02D138  00000000   NOP
9D02D13C  24020031   ADDIU V0, ZERO, 49
9D02D140  0B40B453   J 0x9D02D14C
9D02D144  00000000   NOP
9D02D148  24020030   ADDIU V0, ZERO, 48
9D02D14C  00602021   ADDU A0, V1, ZERO
9D02D150  00402821   ADDU A1, V0, ZERO
9D02D154  0F40040C   JAL TCPPut
9D02D158  00000000   NOP
354:                 					TCPPut(MySocket, ' ');
9D02D15C  93C20019   LBU V0, 25(S8)
9D02D160  00402021   ADDU A0, V0, ZERO
9D02D164  24050020   ADDIU A1, ZERO, 32
9D02D168  0F40040C   JAL TCPPut
9D02D16C  00000000   NOP
355:                 					TCPPut(MySocket, BUTTON0_IO ? '1':'0');
9D02D170  93C30019   LBU V1, 25(S8)
9D02D174  3C02BF88   LUI V0, -16504
9D02D178  8C4260D0   LW V0, 24784(V0)
9D02D17C  30420040   ANDI V0, V0, 64
9D02D180  10400004   BEQ V0, ZERO, 0x9D02D194
9D02D184  00000000   NOP
9D02D188  24020031   ADDIU V0, ZERO, 49
9D02D18C  0B40B466   J 0x9D02D198
9D02D190  00000000   NOP
9D02D194  24020030   ADDIU V0, ZERO, 48
9D02D198  00602021   ADDU A0, V1, ZERO
9D02D19C  00402821   ADDU A1, V0, ZERO
9D02D1A0  0F40040C   JAL TCPPut
9D02D1A4  00000000   NOP
356:                 		
357:                 		
358:                 					// Put LEDs
359:                 					TCPPutROMString(MySocket, (ROM BYTE*)"\x1b[13;10f");
9D02D1A8  93C30019   LBU V1, 25(S8)
9D02D1AC  3C029D03   LUI V0, -25341
9D02D1B0  24424734   ADDIU V0, V0, 18228
9D02D1B4  00602021   ADDU A0, V1, ZERO
9D02D1B8  00402821   ADDU A1, V0, ZERO
9D02D1BC  0F4005FD   JAL TCPPutString
9D02D1C0  00000000   NOP
360:                 					TCPPut(MySocket, LED7_IO ? '1':'0');
9D02D1C4  93C30019   LBU V1, 25(S8)
9D02D1C8  3C02BF88   LUI V0, -16504
9D02D1CC  8C4260E0   LW V0, 24800(V0)
9D02D1D0  30420040   ANDI V0, V0, 64
9D02D1D4  10400004   BEQ V0, ZERO, 0x9D02D1E8
9D02D1D8  00000000   NOP
9D02D1DC  24020031   ADDIU V0, ZERO, 49
9D02D1E0  0B40B47B   J 0x9D02D1EC
9D02D1E4  00000000   NOP
9D02D1E8  24020030   ADDIU V0, ZERO, 48
9D02D1EC  00602021   ADDU A0, V1, ZERO
9D02D1F0  00402821   ADDU A1, V0, ZERO
9D02D1F4  0F40040C   JAL TCPPut
9D02D1F8  00000000   NOP
361:                 					TCPPut(MySocket, ' ');
9D02D1FC  93C20019   LBU V0, 25(S8)
9D02D200  00402021   ADDU A0, V0, ZERO
9D02D204  24050020   ADDIU A1, ZERO, 32
9D02D208  0F40040C   JAL TCPPut
9D02D20C  00000000   NOP
362:                 					TCPPut(MySocket, LED6_IO ? '1':'0');
9D02D210  93C30019   LBU V1, 25(S8)
9D02D214  3C02BF88   LUI V0, -16504
9D02D218  8C4260E0   LW V0, 24800(V0)
9D02D21C  30420040   ANDI V0, V0, 64
9D02D220  10400004   BEQ V0, ZERO, 0x9D02D234
9D02D224  00000000   NOP
9D02D228  24020031   ADDIU V0, ZERO, 49
9D02D22C  0B40B48E   J 0x9D02D238
9D02D230  00000000   NOP
9D02D234  24020030   ADDIU V0, ZERO, 48
9D02D238  00602021   ADDU A0, V1, ZERO
9D02D23C  00402821   ADDU A1, V0, ZERO
9D02D240  0F40040C   JAL TCPPut
9D02D244  00000000   NOP
363:                 					TCPPut(MySocket, ' ');
9D02D248  93C20019   LBU V0, 25(S8)
9D02D24C  00402021   ADDU A0, V0, ZERO
9D02D250  24050020   ADDIU A1, ZERO, 32
9D02D254  0F40040C   JAL TCPPut
9D02D258  00000000   NOP
364:                 					TCPPut(MySocket, LED5_IO ? '1':'0');
9D02D25C  93C30019   LBU V1, 25(S8)
9D02D260  3C02BF88   LUI V0, -16504
9D02D264  8C4260E0   LW V0, 24800(V0)
9D02D268  30420040   ANDI V0, V0, 64
9D02D26C  10400004   BEQ V0, ZERO, 0x9D02D280
9D02D270  00000000   NOP
9D02D274  24020031   ADDIU V0, ZERO, 49
9D02D278  0B40B4A1   J 0x9D02D284
9D02D27C  00000000   NOP
9D02D280  24020030   ADDIU V0, ZERO, 48
9D02D284  00602021   ADDU A0, V1, ZERO
9D02D288  00402821   ADDU A1, V0, ZERO
9D02D28C  0F40040C   JAL TCPPut
9D02D290  00000000   NOP
365:                 					TCPPut(MySocket, ' ');
9D02D294  93C20019   LBU V0, 25(S8)
9D02D298  00402021   ADDU A0, V0, ZERO
9D02D29C  24050020   ADDIU A1, ZERO, 32
9D02D2A0  0F40040C   JAL TCPPut
9D02D2A4  00000000   NOP
366:                 					TCPPut(MySocket, LED4_IO ? '1':'0');
9D02D2A8  93C30019   LBU V1, 25(S8)
9D02D2AC  3C02BF88   LUI V0, -16504
9D02D2B0  8C4260E0   LW V0, 24800(V0)
9D02D2B4  30420040   ANDI V0, V0, 64
9D02D2B8  10400004   BEQ V0, ZERO, 0x9D02D2CC
9D02D2BC  00000000   NOP
9D02D2C0  24020031   ADDIU V0, ZERO, 49
9D02D2C4  0B40B4B4   J 0x9D02D2D0
9D02D2C8  00000000   NOP
9D02D2CC  24020030   ADDIU V0, ZERO, 48
9D02D2D0  00602021   ADDU A0, V1, ZERO
9D02D2D4  00402821   ADDU A1, V0, ZERO
9D02D2D8  0F40040C   JAL TCPPut
9D02D2DC  00000000   NOP
367:                 					TCPPut(MySocket, ' ');
9D02D2E0  93C20019   LBU V0, 25(S8)
9D02D2E4  00402021   ADDU A0, V0, ZERO
9D02D2E8  24050020   ADDIU A1, ZERO, 32
9D02D2EC  0F40040C   JAL TCPPut
9D02D2F0  00000000   NOP
368:                 					TCPPut(MySocket, LED3_IO ? '1':'0');
9D02D2F4  93C30019   LBU V1, 25(S8)
9D02D2F8  3C02BF88   LUI V0, -16504
9D02D2FC  8C4260E0   LW V0, 24800(V0)
9D02D300  30420040   ANDI V0, V0, 64
9D02D304  10400004   BEQ V0, ZERO, 0x9D02D318
9D02D308  00000000   NOP
9D02D30C  24020031   ADDIU V0, ZERO, 49
9D02D310  0B40B4C7   J 0x9D02D31C
9D02D314  00000000   NOP
9D02D318  24020030   ADDIU V0, ZERO, 48
9D02D31C  00602021   ADDU A0, V1, ZERO
9D02D320  00402821   ADDU A1, V0, ZERO
9D02D324  0F40040C   JAL TCPPut
9D02D328  00000000   NOP
369:                 					TCPPut(MySocket, ' ');
9D02D32C  93C20019   LBU V0, 25(S8)
9D02D330  00402021   ADDU A0, V0, ZERO
9D02D334  24050020   ADDIU A1, ZERO, 32
9D02D338  0F40040C   JAL TCPPut
9D02D33C  00000000   NOP
370:                 					TCPPut(MySocket, LED2_IO ? '1':'0');
9D02D340  93C30019   LBU V1, 25(S8)
9D02D344  3C02BF88   LUI V0, -16504
9D02D348  8C4260E0   LW V0, 24800(V0)
9D02D34C  30420004   ANDI V0, V0, 4
9D02D350  10400004   BEQ V0, ZERO, 0x9D02D364
9D02D354  00000000   NOP
9D02D358  24020031   ADDIU V0, ZERO, 49
9D02D35C  0B40B4DA   J 0x9D02D368
9D02D360  00000000   NOP
9D02D364  24020030   ADDIU V0, ZERO, 48
9D02D368  00602021   ADDU A0, V1, ZERO
9D02D36C  00402821   ADDU A1, V0, ZERO
9D02D370  0F40040C   JAL TCPPut
9D02D374  00000000   NOP
371:                 					TCPPut(MySocket, ' ');
9D02D378  93C20019   LBU V0, 25(S8)
9D02D37C  00402021   ADDU A0, V0, ZERO
9D02D380  24050020   ADDIU A1, ZERO, 32
9D02D384  0F40040C   JAL TCPPut
9D02D388  00000000   NOP
372:                 					TCPPut(MySocket, LED1_IO ? '1':'0');
9D02D38C  93C30019   LBU V1, 25(S8)
9D02D390  3C02BF88   LUI V0, -16504
9D02D394  8C4260E0   LW V0, 24800(V0)
9D02D398  30420002   ANDI V0, V0, 2
9D02D39C  10400004   BEQ V0, ZERO, 0x9D02D3B0
9D02D3A0  00000000   NOP
9D02D3A4  24020031   ADDIU V0, ZERO, 49
9D02D3A8  0B40B4ED   J 0x9D02D3B4
9D02D3AC  00000000   NOP
9D02D3B0  24020030   ADDIU V0, ZERO, 48
9D02D3B4  00602021   ADDU A0, V1, ZERO
9D02D3B8  00402821   ADDU A1, V0, ZERO
9D02D3BC  0F40040C   JAL TCPPut
9D02D3C0  00000000   NOP
373:                 					TCPPut(MySocket, ' ');
9D02D3C4  93C20019   LBU V0, 25(S8)
9D02D3C8  00402021   ADDU A0, V0, ZERO
9D02D3CC  24050020   ADDIU A1, ZERO, 32
9D02D3D0  0F40040C   JAL TCPPut
9D02D3D4  00000000   NOP
374:                 					TCPPut(MySocket, LED0_IO ? '1':'0');
9D02D3D8  93C30019   LBU V1, 25(S8)
9D02D3DC  3C02BF88   LUI V0, -16504
9D02D3E0  8C4260E0   LW V0, 24800(V0)
9D02D3E4  30420001   ANDI V0, V0, 1
9D02D3E8  10400004   BEQ V0, ZERO, 0x9D02D3FC
9D02D3EC  00000000   NOP
9D02D3F0  24020031   ADDIU V0, ZERO, 49
9D02D3F4  0B40B500   J 0x9D02D400
9D02D3F8  00000000   NOP
9D02D3FC  24020030   ADDIU V0, ZERO, 48
9D02D400  00602021   ADDU A0, V1, ZERO
9D02D404  00402821   ADDU A1, V0, ZERO
9D02D408  0F40040C   JAL TCPPut
9D02D40C  00000000   NOP
375:                 		
376:                 		
377:                 					// Put cursor at beginning of next line
378:                 					TCPPutROMString(MySocket, (ROM BYTE*)"\x1b[14;1f");
9D02D410  93C30019   LBU V1, 25(S8)
9D02D414  3C029D03   LUI V0, -25341
9D02D418  24424740   ADDIU V0, V0, 18240
9D02D41C  00602021   ADDU A0, V1, ZERO
9D02D420  00402821   ADDU A1, V0, ZERO
9D02D424  0F4005FD   JAL TCPPutString
9D02D428  00000000   NOP
379:                 	
380:                 					// Send the data out immediately
381:                 					TCPFlush(MySocket);
9D02D42C  93C20019   LBU V0, 25(S8)
9D02D430  00402021   ADDU A0, V0, ZERO
9D02D434  0F400366   JAL TCPFlush
9D02D438  00000000   NOP
382:                 				}
383:                 	
384:                 				if(TCPIsGetReady(MySocket))
9D02D43C  93C20019   LBU V0, 25(S8)
9D02D440  00402021   ADDU A0, V0, ZERO
9D02D444  0F400675   JAL TCPIsGetReady
9D02D448  00000000   NOP
9D02D44C  1040003C   BEQ V0, ZERO, 0x9D02D540
9D02D450  00000000   NOP
385:                 				{
386:                 					TCPGet(MySocket, &i);
9D02D454  93C30019   LBU V1, 25(S8)
9D02D458  27C20024   ADDIU V0, S8, 36
9D02D45C  00602021   ADDU A0, V1, ZERO
9D02D460  00402821   ADDU A1, V0, ZERO
9D02D464  0F4006DD   JAL TCPGet
9D02D468  00000000   NOP
387:                 					switch(i)
9D02D46C  93C20024   LBU V0, 36(S8)
9D02D470  24030051   ADDIU V1, ZERO, 81
9D02D474  10430007   BEQ V0, V1, 0x9D02D494
9D02D478  00000000   NOP
9D02D47C  24030071   ADDIU V1, ZERO, 113
9D02D480  10430004   BEQ V0, V1, 0x9D02D494
9D02D484  00000000   NOP
9D02D488  2403000D   ADDIU V1, ZERO, 13
9D02D48C  1443002F   BNE V0, V1, 0x9D02D54C
9D02D490  00000000   NOP
388:                 					{
389:                 						case '\r':
390:                 						case 'q':
391:                 						case 'Q':
392:                 							if(TCPIsPutReady(MySocket) >= strlenpgm((ROM char*)strGoodBye))
9D02D494  93C20019   LBU V0, 25(S8)
9D02D498  00402021   ADDU A0, V0, ZERO
9D02D49C  0F40038E   JAL TCPIsPutReady
9D02D4A0  00000000   NOP
9D02D4A4  2C42000E   SLTIU V0, V0, 14
9D02D4A8  14400007   BNE V0, ZERO, 0x9D02D4C8
9D02D4AC  00000000   NOP
393:                 								TCPPutROMString(MySocket, strGoodBye);
9D02D4B0  93C20019   LBU V0, 25(S8)
9D02D4B4  00402021   ADDU A0, V0, ZERO
9D02D4B8  3C029D03   LUI V0, -25341
9D02D4BC  244546BC   ADDIU A1, V0, 18108
9D02D4C0  0F4005FD   JAL TCPPutString
9D02D4C4  00000000   NOP
394:                 							TCPDisconnect(MySocket);
9D02D4C8  93C20019   LBU V0, 25(S8)
9D02D4CC  00402021   ADDU A0, V0, ZERO
9D02D4D0  0F400273   JAL TCPDisconnect
9D02D4D4  00000000   NOP
395:                 							TelnetState = SM_PRINT_LOGIN;							
9D02D4D8  24020001   ADDIU V0, ZERO, 1
9D02D4DC  AFC2001C   SW V0, 28(S8)
396:                 							break;
9D02D4E0  00000000   NOP
397:                 					}
398:                 				}
399:                 	
400:                 				break;
9D02D4E4  0B40B554   J 0x9D02D550
9D02D4E8  00000000   NOP
9D02D540  00000000   NOP
9D02D544  0B40B554   J 0x9D02D550
9D02D548  00000000   NOP
9D02D54C  00000000   NOP
401:                 		}
402:                 
403:                 
404:                 		// Save session state back into the static array
405:                 		hTelnetSockets[vTelnetSession] = MySocket;
9D02D550  93C30018   LBU V1, 24(S8)
9D02D554  27828198   ADDIU V0, GP, -32360
9D02D558  00621021   ADDU V0, V1, V0
9D02D55C  93C30019   LBU V1, 25(S8)
9D02D560  A0430000   SB V1, 0(V0)
406:                 		vTelnetStates[vTelnetSession] = TelnetState;
9D02D564  93C40018   LBU A0, 24(S8)
9D02D568  8FC2001C   LW V0, 28(S8)
9D02D56C  304300FF   ANDI V1, V0, 255
9D02D570  2782819C   ADDIU V0, GP, -32356
9D02D574  00821021   ADDU V0, A0, V0
9D02D578  A0430000   SB V1, 0(V0)
407:                 	}
408:                 }
9D02D594  03C0E821   ADDU SP, S8, ZERO
9D02D598  8FBF0044   LW RA, 68(SP)
9D02D59C  8FBE0040   LW S8, 64(SP)
9D02D5A0  8FB0003C   LW S0, 60(SP)
9D02D5A4  27BD0048   ADDIU SP, SP, 72
9D02D5A8  03E00008   JR RA
9D02D5AC  00000000   NOP
409:                 
410:                 #endif	//#if defined(STACK_USE_TELNET_SERVER)
---  C:/Users/Diego/Documents/GitHub/pic32webFREERtos/Pic32Web.X/src/tcpip/src/TCPPerformanceTest.c  ----
1:                   /*********************************************************************
2:                    *
3:                    *	TCP Performance Test
4:                    *  Module for Microchip TCP/IP Stack
5:                    *	 -Establishes a connection and then sends out dummy packets 
6:                    *	  from ROM memory
7:                    *	 -Reference: None.  This is for testing only.
8:                    *
9:                    *********************************************************************
10:                   * FileName:        TCPPerformanceTest.c
11:                   * Dependencies:    TCP
12:                   * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32
13:                   * Compiler:        Microchip C32 v1.05 or higher
14:                   *					Microchip C30 v3.12 or higher
15:                   *					Microchip C18 v3.30 or higher
16:                   *					HI-TECH PICC-18 PRO 9.63PL2 or higher
17:                   * Company:         Microchip Technology, Inc.
18:                   *
19:                   * Software License Agreement
20:                   *
21:                   * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights
22:                   * reserved.
23:                   *
24:                   * Microchip licenses to you the right to use, modify, copy, and
25:                   * distribute:
26:                   * (i)  the Software when embedded on a Microchip microcontroller or
27:                   *      digital signal controller product ("Device") which is
28:                   *      integrated into Licensee's product; or
29:                   * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h,
30:                   *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device
31:                   *		used in conjunction with a Microchip ethernet controller for
32:                   *		the sole purpose of interfacing with the ethernet controller.
33:                   *
34:                   * You should refer to the license agreement accompanying this
35:                   * Software for additional information regarding your rights and
36:                   * obligations.
37:                   *
38:                   * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT
39:                   * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT
40:                   * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A
41:                   * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL
42:                   * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR
43:                   * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF
44:                   * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS
45:                   * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE
46:                   * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER
47:                   * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT
48:                   * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE.
49:                   *
50:                   *
51:                   * Author               Date    	Comment
52:                   *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
53:                   * Howard Schlunder     01/29/07	Original
54:                   ********************************************************************/
55:                  #define __TCPPERFORMANCETEST_C
56:                  
57:                  #include "TCPIPConfig.h"
58:                  
59:                  #if defined(STACK_USE_TCP_PERFORMANCE_TEST)
60:                  
61:                  #include "TCPIP Stack/TCPIP.h"
62:                  
63:                  
64:                  // The TCP port to listen on for TCP transmit tests
65:                  #define TX_PERFORMANCE_PORT	9762
66:                  
67:                  // The TCP port to listen on for TCP receive tests
68:                  #define RX_PERFORMANCE_PORT	9763
69:                  
70:                  void TCPTXPerformanceTask(void);
71:                  void TCPRXPerformanceTask(void);
72:                  
73:                  /*****************************************************************************
74:                    Function:
75:                  	void TCPPerformanceTask(void)
76:                  
77:                    Summary:
78:                  	Tests the performance of the TCP module.
79:                  
80:                    Description:
81:                  	This function calls both TCPTXPerformanceTask and TCPRXPerformanceTask
82:                  	to perform the performance task functions.  Refer to the documentation
83:                  	for each of those functions for details.
84:                  
85:                    Precondition:
86:                  	TCP is initialized.
87:                  
88:                    Parameters:
89:                  	None
90:                  
91:                    Returns:
92:                  	None
93:                    ***************************************************************************/
94:                  void TCPPerformanceTask(void)
95:                  {
9D02FC74  27BDFFE8   ADDIU SP, SP, -24
9D02FC78  AFBF0014   SW RA, 20(SP)
9D02FC7C  AFBE0010   SW S8, 16(SP)
9D02FC80  03A0F021   ADDU S8, SP, ZERO
96:                  	TCPTXPerformanceTask();
9D02FC84  0F40BF2B   JAL TCPTXPerformanceTask
9D02FC88  00000000   NOP
97:                  	TCPRXPerformanceTask();
9D02FC8C  0F40C022   JAL TCPRXPerformanceTask
9D02FC90  00000000   NOP
98:                  }
9D02FC94  03C0E821   ADDU SP, S8, ZERO
9D02FC98  8FBF0014   LW RA, 20(SP)
9D02FC9C  8FBE0010   LW S8, 16(SP)
9D02FCA0  27BD0018   ADDIU SP, SP, 24
9D02FCA4  03E00008   JR RA
9D02FCA8  00000000   NOP
99:                  
100:                 /*****************************************************************************
101:                   Function:
102:                 	void TCPTXPerformanceTask(void)
103:                 
104:                   Summary:
105:                 	Tests the transmit performance of the TCP module.
106:                 
107:                   Description:
108:                 	This function tests the transmit performance of the TCP module.  To use,
109:                 	open a telnet connection to the device on TX_PERFORMANCE_PORT (9762 by 
110:                 	default).  The board will rapidly transmit data and report its performance
111:                 	to the telnet client.
112:                 	
113:                 	TCP performance is affected by many factors, including round-trip time 
114:                 	and the TCP buffer size.  For faster results, increase the size of the 
115:                 	TX buffer size for the TCP_PURPOSE_TCP_PERFORMANCE_TX socket in 
116:                 	TCPIPConfig.h.  Round-trip time is affected by the distance to the 
117:                 	device, so across the desk will be orders of magnitude faster than 
118:                 	across the Internet.
119:                 	
120:                 	This function is particularly useful after development to determine the
121:                 	impact of your application code on the stack's performance.  A before and
122:                 	after comparison will indicate if your application is unacceptably
123:                 	blocking the processor or taking too long to execute.
124:                 
125:                   Precondition:
126:                 	TCP is initialized.
127:                 
128:                   Parameters:
129:                 	None
130:                 
131:                   Returns:
132:                 	None
133:                   ***************************************************************************/
134:                 void TCPTXPerformanceTask(void)
135:                 {
9D02FCAC  27BDFFA8   ADDIU SP, SP, -88
9D02FCB0  AFBF0054   SW RA, 84(SP)
9D02FCB4  AFBE0050   SW S8, 80(SP)
9D02FCB8  AFB7004C   SW S7, 76(SP)
9D02FCBC  AFB60048   SW S6, 72(SP)
9D02FCC0  AFB50044   SW S5, 68(SP)
9D02FCC4  AFB40040   SW S4, 64(SP)
9D02FCC8  AFB3003C   SW S3, 60(SP)
9D02FCCC  AFB20038   SW S2, 56(SP)
9D02FCD0  AFB10034   SW S1, 52(SP)
9D02FCD4  AFB00030   SW S0, 48(SP)
9D02FCD8  03A0F021   ADDU S8, SP, ZERO
136:                 	static TCP_SOCKET MySocket = INVALID_SOCKET;
137:                 	static DWORD dwTimeStart;
138:                 	static DWORD dwBytesSent;
139:                 	static DWORD_VAL dwVLine;
140:                 	BYTE vBuffer[10];
141:                 	static BYTE vBytesPerSecond[12];
142:                 	WORD w;
143:                 	DWORD dw;
144:                 	QWORD qw;
145:                 	
146:                 	// Start the TCP server, listening on PERFORMANCE_PORT
147:                 	if(MySocket == INVALID_SOCKET)
9D02FCDC  9383802A   LBU V1, -32726(GP)
9D02FCE0  240200FE   ADDIU V0, ZERO, 254
9D02FCE4  1462000D   BNE V1, V0, 0x9D02FD1C
9D02FCE8  00000000   NOP
148:                 	{
149:                 		MySocket = TCPOpen(0, TCP_OPEN_SERVER, TX_PERFORMANCE_PORT, TCP_PURPOSE_TCP_PERFORMANCE_TX);
9D02FCEC  00002021   ADDU A0, ZERO, ZERO
9D02FCF0  00002821   ADDU A1, ZERO, ZERO
9D02FCF4  24062622   ADDIU A2, ZERO, 9762
9D02FCF8  24070005   ADDIU A3, ZERO, 5
9D02FCFC  0F400109   JAL TCPOpen
9D02FD00  00000000   NOP
9D02FD04  A382802A   SB V0, -32726(GP)
150:                 	
151:                 		// Abort operation if no TCP socket of type TCP_PURPOSE_TCP_PERFORMANCE_TEST is available
152:                 		// If this ever happens, you need to go add one to TCPIPConfig.h
153:                 		if(MySocket == INVALID_SOCKET)
9D02FD08  9383802A   LBU V1, -32726(GP)
9D02FD0C  240200FE   ADDIU V0, ZERO, 254
9D02FD10  106200CB   BEQ V1, V0, 0x9D030040
9D02FD14  00000000   NOP
154:                 			return;
9D030040  00000000   NOP
9D030044  0B40C014   J 0x9D030050
9D030048  00000000   NOP
155:                 
156:                 		// Initialize cumulative line transmission counter
157:                 		dwVLine.Val = 0;
9D02FD18  AF808188   SW ZERO, -32376(GP)
158:                 	}
159:                 	
160:                 	// See how many bytes we can write to the TX FIFO
161:                 	// If we can't fit a single line of data in, then 
162:                 	// lets just wait for now.
163:                 	w = TCPIsPutReady(MySocket);
9D02FD1C  9382802A   LBU V0, -32726(GP)
9D02FD20  00402021   ADDU A0, V0, ZERO
9D02FD24  0F40038E   JAL TCPIsPutReady
9D02FD28  00000000   NOP
9D02FD2C  A7C20010   SH V0, 16(S8)
164:                 	if(w < 12+27+5+32u)
9D02FD30  97C20010   LHU V0, 16(S8)
9D02FD34  2C42004C   SLTIU V0, V0, 76
9D02FD38  144000C4   BNE V0, ZERO, 0x9D03004C
9D02FD3C  00000000   NOP
165:                 		return;
9D03004C  00000000   NOP
166:                 
167:                 	// Upon connection initialize timer and byte count variables
168:                 	if(TCPIsConnected(MySocket))
9D02FD40  9382802A   LBU V0, -32726(GP)
9D02FD44  00402021   ADDU A0, V0, ZERO
9D02FD48  0F400256   JAL TCPIsConnected
9D02FD4C  00000000   NOP
9D02FD50  1040000D   BEQ V0, ZERO, 0x9D02FD88
9D02FD54  00000000   NOP
169:                 	{
170:                 		if(TCPWasReset(MySocket))
9D02FD58  9382802A   LBU V0, -32726(GP)
9D02FD5C  00402021   ADDU A0, V0, ZERO
9D02FD60  0F400229   JAL TCPWasReset
9D02FD64  00000000   NOP
9D02FD68  10400007   BEQ V0, ZERO, 0x9D02FD88
9D02FD6C  00000000   NOP
171:                 		{
172:                 			dwTimeStart = TickGet();
9D02FD70  0F40CDD6   JAL TickGet
9D02FD74  00000000   NOP
9D02FD78  AF82818C   SW V0, -32372(GP)
173:                 			dwBytesSent = 0;
9D02FD7C  AF808190   SW ZERO, -32368(GP)
174:                 			vBytesPerSecond[0] = 0;	// Initialize empty string right now
9D02FD80  3C02A000   LUI V0, -24576
9D02FD84  A04032DC   SB ZERO, 13020(V0)
175:                 		}
176:                 	}
177:                 
178:                 	vBuffer[0] = '0';
9D02FD88  24020030   ADDIU V0, ZERO, 48
9D02FD8C  A3C20020   SB V0, 32(S8)
179:                 	vBuffer[1] = 'x';
9D02FD90  24020078   ADDIU V0, ZERO, 120
9D02FD94  A3C20021   SB V0, 33(S8)
180:                 
181:                 	// Transmit as much data as the TX FIFO will allow
182:                 	while(w >= 12+27+5+32u)
9D02FD98  0B40BFCC   J 0x9D02FF30
9D02FD9C  00000000   NOP
9D02FF30  97C20010   LHU V0, 16(S8)
9D02FF34  2C42004C   SLTIU V0, V0, 76
9D02FF38  1040FF99   BEQ V0, ZERO, 0x9D02FDA0
9D02FF3C  00000000   NOP
183:                 	{
184:                 		dwVLine.Val = TickGet();
9D02FDA0  0F40CDD6   JAL TickGet
9D02FDA4  00000000   NOP
9D02FDA8  AF828188   SW V0, -32376(GP)
185:                 		
186:                 		// Convert line counter to ASCII hex string
187:                 		vBuffer[2] = btohexa_high(dwVLine.v[3]);
9D02FDAC  9382818B   LBU V0, -32373(GP)
9D02FDB0  00402021   ADDU A0, V0, ZERO
9D02FDB4  0F409989   JAL btohexa_high
9D02FDB8  00000000   NOP
9D02FDBC  A3C20022   SB V0, 34(S8)
188:                 		vBuffer[3] = btohexa_low(dwVLine.v[3]);
9D02FDC0  9382818B   LBU V0, -32373(GP)
9D02FDC4  00402021   ADDU A0, V0, ZERO
9D02FDC8  0F4099A2   JAL btohexa_low
9D02FDCC  00000000   NOP
9D02FDD0  A3C20023   SB V0, 35(S8)
189:                 		vBuffer[4] = btohexa_high(dwVLine.v[2]);
9D02FDD4  9382818A   LBU V0, -32374(GP)
9D02FDD8  00402021   ADDU A0, V0, ZERO
9D02FDDC  0F409989   JAL btohexa_high
9D02FDE0  00000000   NOP
9D02FDE4  A3C20024   SB V0, 36(S8)
190:                 		vBuffer[5] = btohexa_low(dwVLine.v[2]);
9D02FDE8  9382818A   LBU V0, -32374(GP)
9D02FDEC  00402021   ADDU A0, V0, ZERO
9D02FDF0  0F4099A2   JAL btohexa_low
9D02FDF4  00000000   NOP
9D02FDF8  A3C20025   SB V0, 37(S8)
191:                 		vBuffer[6] = btohexa_high(dwVLine.v[1]);
9D02FDFC  93828189   LBU V0, -32375(GP)
9D02FE00  00402021   ADDU A0, V0, ZERO
9D02FE04  0F409989   JAL btohexa_high
9D02FE08  00000000   NOP
9D02FE0C  A3C20026   SB V0, 38(S8)
192:                 		vBuffer[7] = btohexa_low(dwVLine.v[1]);
9D02FE10  93828189   LBU V0, -32375(GP)
9D02FE14  00402021   ADDU A0, V0, ZERO
9D02FE18  0F4099A2   JAL btohexa_low
9D02FE1C  00000000   NOP
9D02FE20  A3C20027   SB V0, 39(S8)
193:                 		vBuffer[8] = btohexa_high(dwVLine.v[0]);
9D02FE24  93828188   LBU V0, -32376(GP)
9D02FE28  00402021   ADDU A0, V0, ZERO
9D02FE2C  0F409989   JAL btohexa_high
9D02FE30  00000000   NOP
9D02FE34  A3C20028   SB V0, 40(S8)
194:                 		vBuffer[9] = btohexa_low(dwVLine.v[0]);
9D02FE38  93828188   LBU V0, -32376(GP)
9D02FE3C  00402021   ADDU A0, V0, ZERO
9D02FE40  0F4099A2   JAL btohexa_low
9D02FE44  00000000   NOP
9D02FE48  A3C20029   SB V0, 41(S8)
195:                 
196:                 		dwVLine.Val++;
9D02FE4C  8F828188   LW V0, -32376(GP)
9D02FE50  24420001   ADDIU V0, V0, 1
9D02FE54  AF828188   SW V0, -32376(GP)
197:                 	
198:                 		// Place all data in the TCP TX FIFO
199:                 		TCPPutArray(MySocket, vBuffer, sizeof(vBuffer));
9D02FE58  9382802A   LBU V0, -32726(GP)
9D02FE5C  00401821   ADDU V1, V0, ZERO
9D02FE60  27C20020   ADDIU V0, S8, 32
9D02FE64  00602021   ADDU A0, V1, ZERO
9D02FE68  00402821   ADDU A1, V0, ZERO
9D02FE6C  2406000A   ADDIU A2, ZERO, 10
9D02FE70  0F4004E1   JAL TCPPutArray
9D02FE74  00000000   NOP
200:                 		TCPPutROMString(MySocket, (ROM BYTE*)": We are currently achieving ");
9D02FE78  9382802A   LBU V0, -32726(GP)
9D02FE7C  00401821   ADDU V1, V0, ZERO
9D02FE80  3C029D03   LUI V0, -25341
9D02FE84  24425DD4   ADDIU V0, V0, 24020
9D02FE88  00602021   ADDU A0, V1, ZERO
9D02FE8C  00402821   ADDU A1, V0, ZERO
9D02FE90  0F4005FD   JAL TCPPutString
9D02FE94  00000000   NOP
201:                 		TCPPutROMArray(MySocket, (ROM BYTE*)"       ", 5-strlen((char*)vBytesPerSecond));
9D02FE98  9382802A   LBU V0, -32726(GP)
9D02FE9C  0040B821   ADDU S7, V0, ZERO
9D02FEA0  3C029D03   LUI V0, -25341
9D02FEA4  24565DF4   ADDIU S6, V0, 24052
9D02FEA8  3C02A000   LUI V0, -24576
9D02FEAC  244232DC   ADDIU V0, V0, 13020
9D02FEB0  00402021   ADDU A0, V0, ZERO
9D02FEB4  0F40D2F2   JAL 0x9D034BC8
9D02FEB8  00000000   NOP
9D02FEBC  3042FFFF   ANDI V0, V0, -1
9D02FEC0  24030005   ADDIU V1, ZERO, 5
9D02FEC4  00621023   SUBU V0, V1, V0
9D02FEC8  3042FFFF   ANDI V0, V0, -1
9D02FECC  02E02021   ADDU A0, S7, ZERO
9D02FED0  02C02821   ADDU A1, S6, ZERO
9D02FED4  00403021   ADDU A2, V0, ZERO
9D02FED8  0F4004E1   JAL TCPPutArray
9D02FEDC  00000000   NOP
202:                 		TCPPutString(MySocket, vBytesPerSecond);
9D02FEE0  9382802A   LBU V0, -32726(GP)
9D02FEE4  00402021   ADDU A0, V0, ZERO
9D02FEE8  3C02A000   LUI V0, -24576
9D02FEEC  244532DC   ADDIU A1, V0, 13020
9D02FEF0  0F4005FD   JAL TCPPutString
9D02FEF4  00000000   NOP
203:                 		TCPPutROMString(MySocket, (ROM BYTE*)"00 bytes/second TX throughput.\r\n");
9D02FEF8  9382802A   LBU V0, -32726(GP)
9D02FEFC  00401821   ADDU V1, V0, ZERO
9D02FF00  3C029D03   LUI V0, -25341
9D02FF04  24425DFC   ADDIU V0, V0, 24060
9D02FF08  00602021   ADDU A0, V1, ZERO
9D02FF0C  00402821   ADDU A1, V0, ZERO
9D02FF10  0F4005FD   JAL TCPPutString
9D02FF14  00000000   NOP
204:                 
205:                 		w -= 12+27+5+32;
9D02FF18  97C20010   LHU V0, 16(S8)
9D02FF1C  2442FFB4   ADDIU V0, V0, -76
9D02FF20  A7C20010   SH V0, 16(S8)
206:                 		dwBytesSent += 12+27+5+32;
9D02FF24  8F828190   LW V0, -32368(GP)
9D02FF28  2442004C   ADDIU V0, V0, 76
9D02FF2C  AF828190   SW V0, -32368(GP)
207:                 	}
208:                 	
209:                 	// Send everything immediately
210:                 	TCPFlush(MySocket);
9D02FF40  9382802A   LBU V0, -32726(GP)
9D02FF44  00402021   ADDU A0, V0, ZERO
9D02FF48  0F400366   JAL TCPFlush
9D02FF4C  00000000   NOP
211:                 
212:                 	// Calculate exact bytes/second, less truncation
213:                 	dw = TickGet() - dwTimeStart;
9D02FF50  0F40CDD6   JAL TickGet
9D02FF54  00000000   NOP
9D02FF58  00401821   ADDU V1, V0, ZERO
9D02FF5C  8F82818C   LW V0, -32372(GP)
9D02FF60  00621023   SUBU V0, V1, V0
9D02FF64  AFC20014   SW V0, 20(S8)
214:                 	if(dw > TICK_SECOND/10)
9D02FF68  8FC20014   LW V0, 20(S8)
9D02FF6C  2C423D0A   SLTIU V0, V0, 15626
9D02FF70  14400037   BNE V0, ZERO, 0x9D030050
9D02FF74  00000000   NOP
215:                 	{
216:                 //		qw = ((QWORD)dwBytesSent) * (TICK_SECOND/100/8);
217:                 //		qw = ((QWORD)dwBytesSent) * (TICK_SECOND/100);
218:                 //		qw /= dw;
219:                 		qw = ((QWORD)dwBytesSent)*(TICK_SECOND/100) + (dw>>1);
9D02FF78  8F828190   LW V0, -32368(GP)
9D02FF7C  0040A021   ADDU S4, V0, ZERO
9D02FF80  0000A821   ADDU S5, ZERO, ZERO
9D02FF84  2402061A   ADDIU V0, ZERO, 1562
9D02FF88  72A21002   MUL V0, S5, V0
9D02FF8C  00001821   ADDU V1, ZERO, ZERO
9D02FF90  72831802   MUL V1, S4, V1
9D02FF94  00431021   ADDU V0, V0, V1
9D02FF98  2403061A   ADDIU V1, ZERO, 1562
9D02FF9C  02830019   MULTU 0, S4, V1
9D02FFA0  00002012   MFLO A0, 0
9D02FFA4  00002810   MFHI A1, 0
9D02FFA8  00451021   ADDU V0, V0, A1
9D02FFAC  00402821   ADDU A1, V0, ZERO
9D02FFB0  8FC20014   LW V0, 20(S8)
9D02FFB4  00021042   SRL V0, V0, 1
9D02FFB8  00408021   ADDU S0, V0, ZERO
9D02FFBC  00008821   ADDU S1, ZERO, ZERO
9D02FFC0  00901021   ADDU V0, A0, S0
9D02FFC4  0044302B   SLTU A2, V0, A0
9D02FFC8  00B11821   ADDU V1, A1, S1
9D02FFCC  00C32021   ADDU A0, A2, V1
9D02FFD0  00801821   ADDU V1, A0, ZERO
9D02FFD4  AFC20018   SW V0, 24(S8)
9D02FFD8  AFC3001C   SW V1, 28(S8)
220:                 		qw /= dw;
9D02FFDC  8FD20014   LW S2, 20(S8)
9D02FFE0  00009821   ADDU S3, ZERO, ZERO
9D02FFE4  8FC40018   LW A0, 24(S8)
9D02FFE8  8FC5001C   LW A1, 28(S8)
9D02FFEC  02403021   ADDU A2, S2, ZERO
9D02FFF0  02603821   ADDU A3, S3, ZERO
9D02FFF4  0F40C887   JAL __udivdi3
9D02FFF8  00000000   NOP
9D02FFFC  AFC20018   SW V0, 24(S8)
9D030000  AFC3001C   SW V1, 28(S8)
221:                 		ultoa((DWORD)qw, vBytesPerSecond);
9D030004  3C02A000   LUI V0, -24576
9D030008  244332DC   ADDIU V1, V0, 13020
9D03000C  8FC20018   LW V0, 24(S8)
9D030010  00602021   ADDU A0, V1, ZERO
9D030014  00402821   ADDU A1, V0, ZERO
9D030018  2406000A   ADDIU A2, ZERO, 10
9D03001C  0F40D75B   JAL ultoa
9D030020  00000000   NOP
222:                 		dwTimeStart += dw;
9D030024  8F83818C   LW V1, -32372(GP)
9D030028  8FC20014   LW V0, 20(S8)
9D03002C  00621021   ADDU V0, V1, V0
9D030030  AF82818C   SW V0, -32372(GP)
223:                 		
224:                 		dwBytesSent = 0;
9D030034  AF808190   SW ZERO, -32368(GP)
9D030038  0B40C014   J 0x9D030050
9D03003C  00000000   NOP
225:                 		//dwBytesSent -= dwBytesSent>>4;
226:                 	}
227:                 }
9D030050  03C0E821   ADDU SP, S8, ZERO
9D030054  8FBF0054   LW RA, 84(SP)
9D030058  8FBE0050   LW S8, 80(SP)
9D03005C  8FB7004C   LW S7, 76(SP)
9D030060  8FB60048   LW S6, 72(SP)
9D030064  8FB50044   LW S5, 68(SP)
9D030068  8FB40040   LW S4, 64(SP)
9D03006C  8FB3003C   LW S3, 60(SP)
9D030070  8FB20038   LW S2, 56(SP)
9D030074  8FB10034   LW S1, 52(SP)
9D030078  8FB00030   LW S0, 48(SP)
9D03007C  27BD0058   ADDIU SP, SP, 88
9D030080  03E00008   JR RA
9D030084  00000000   NOP
228:                 
229:                 /*****************************************************************************
230:                   Function:
231:                 	void TCPRXPerformanceTask(void)
232:                 
233:                   Summary:
234:                 	Tests the receive performance of the TCP module.
235:                 
236:                   Description:
237:                 	This function tests the receive performance of the TCP module.  To use,
238:                 	open a telnet connection to the device on RX_PERFORMANCE_PORT (9763 by 
239:                 	default).  Then use your telnet utility to upload a large file to the
240:                 	device.  Each second the board will report back how many bytes were 
241:                 	received in the previous second.
242:                 	
243:                 	TCP performance is affected by many factors, including round-trip time 
244:                 	and the TCP buffer size.  For faster results, increase the size of the 
245:                 	RX buffer size for the TCP_PURPOSE_TCP_PERFORMANCE_RX socket in 
246:                 	TCPIPConfig.h.  Round-trip time is affected by the distance to the 
247:                 	device, so across the desk will be orders of magnitude faster than 
248:                 	across the Internet.
249:                 	
250:                 	This function is particularly useful after development to determine the
251:                 	impact of your application code on the stack's performance.  A before and
252:                 	after comparison will indicate if your application is unacceptably
253:                 	blocking the processor or taking too long to execute.
254:                 
255:                   Precondition:
256:                 	TCP is initialized.
257:                 
258:                   Parameters:
259:                 	None
260:                 
261:                   Returns:
262:                 	None
263:                   ***************************************************************************/
264:                 void TCPRXPerformanceTask(void)
265:                 {
9D030088  27BDFFB0   ADDIU SP, SP, -80
9D03008C  AFBF004C   SW RA, 76(SP)
9D030090  AFBE0048   SW S8, 72(SP)
9D030094  AFB50044   SW S5, 68(SP)
9D030098  AFB40040   SW S4, 64(SP)
9D03009C  AFB3003C   SW S3, 60(SP)
9D0300A0  AFB20038   SW S2, 56(SP)
9D0300A4  AFB10034   SW S1, 52(SP)
9D0300A8  AFB00030   SW S0, 48(SP)
9D0300AC  03A0F021   ADDU S8, SP, ZERO
266:                 	static TCP_SOCKET MySocket = INVALID_SOCKET;
267:                 	static DWORD dwTimeStart;
268:                 	static DWORD dwBytesRead;
269:                 	BYTE vBuffer[12];
270:                 	WORD w, wGetLen;
271:                 	DWORD dw;
272:                 	QWORD qw;
273:                 	
274:                 	// Start the TCP server, listening on RX_PERFORMANCE_PORT
275:                 	if(MySocket == INVALID_SOCKET)
9D0300B0  93838029   LBU V1, -32727(GP)
9D0300B4  240200FE   ADDIU V0, ZERO, 254
9D0300B8  14620010   BNE V1, V0, 0x9D0300FC
9D0300BC  00000000   NOP
276:                 	{
277:                 		MySocket = TCPOpen(0, TCP_OPEN_SERVER, RX_PERFORMANCE_PORT, TCP_PURPOSE_TCP_PERFORMANCE_RX);
9D0300C0  00002021   ADDU A0, ZERO, ZERO
9D0300C4  00002821   ADDU A1, ZERO, ZERO
9D0300C8  24062623   ADDIU A2, ZERO, 9763
9D0300CC  24070006   ADDIU A3, ZERO, 6
9D0300D0  0F400109   JAL TCPOpen
9D0300D4  00000000   NOP
9D0300D8  A3828029   SB V0, -32727(GP)
278:                 	
279:                 		// Abort operation if no TCP socket of type TCP_PURPOSE_TCP_PERFORMANCE_TEST_RX is available
280:                 		// If this ever happens, you need to go add one to TCPIPConfig.h
281:                 		if(MySocket == INVALID_SOCKET)
9D0300DC  93838029   LBU V1, -32727(GP)
9D0300E0  240200FE   ADDIU V0, ZERO, 254
9D0300E4  10620084   BEQ V1, V0, 0x9D0302F8
9D0300E8  00000000   NOP
282:                 			return;
9D0302F8  00000000   NOP
9D0302FC  0B40C0C5   J 0x9D030314
9D030300  00000000   NOP
283:                 
284:                 		dwTimeStart = TickGet();
9D0300EC  0F40CDD6   JAL TickGet
9D0300F0  00000000   NOP
9D0300F4  AF828180   SW V0, -32384(GP)
285:                 		dwBytesRead = 0;
9D0300F8  AF808184   SW ZERO, -32380(GP)
286:                 	}
287:                 	
288:                 	// Read all data out of the TCP RX FIFO
289:                 	w = TCPIsGetReady(MySocket);
9D0300FC  93828029   LBU V0, -32727(GP)
9D030100  00402021   ADDU A0, V0, ZERO
9D030104  0F400675   JAL TCPIsGetReady
9D030108  00000000   NOP
9D03010C  A7C20010   SH V0, 16(S8)
290:                 	if(w == 0u)
9D030110  97C20010   LHU V0, 16(S8)
9D030114  1040007B   BEQ V0, ZERO, 0x9D030304
9D030118  00000000   NOP
291:                 		return;
9D030304  00000000   NOP
9D030308  0B40C0C5   J 0x9D030314
9D03030C  00000000   NOP
292:                 
293:                 	dwBytesRead += w;
9D03011C  97C30010   LHU V1, 16(S8)
9D030120  8F828184   LW V0, -32380(GP)
9D030124  00621021   ADDU V0, V1, V0
9D030128  AF828184   SW V0, -32380(GP)
294:                 	wGetLen = sizeof(vBuffer);
9D03012C  2402000C   ADDIU V0, ZERO, 12
9D030130  A7C20012   SH V0, 18(S8)
295:                 	while(w)
9D030134  0B40C061   J 0x9D030184
9D030138  00000000   NOP
9D030184  97C20010   LHU V0, 16(S8)
9D030188  1440FFEC   BNE V0, ZERO, 0x9D03013C
9D03018C  00000000   NOP
296:                 	{
297:                 		if(w < sizeof(vBuffer))
9D03013C  97C20010   LHU V0, 16(S8)
9D030140  2C42000C   SLTIU V0, V0, 12
9D030144  10400003   BEQ V0, ZERO, 0x9D030154
9D030148  00000000   NOP
298:                 			wGetLen = w;
9D03014C  97C20010   LHU V0, 16(S8)
9D030150  A7C20012   SH V0, 18(S8)
299:                 		TCPGetArray(MySocket, vBuffer, wGetLen);
9D030154  93828029   LBU V0, -32727(GP)
9D030158  00402021   ADDU A0, V0, ZERO
9D03015C  97C20012   LHU V0, 18(S8)
9D030160  27C30020   ADDIU V1, S8, 32
9D030164  00602821   ADDU A1, V1, ZERO
9D030168  00403021   ADDU A2, V0, ZERO
9D03016C  0F40077A   JAL TCPGetArray
9D030170  00000000   NOP
300:                 		w -= wGetLen;
9D030174  97C30010   LHU V1, 16(S8)
9D030178  97C20012   LHU V0, 18(S8)
9D03017C  00621023   SUBU V0, V1, V0
9D030180  A7C20010   SH V0, 16(S8)
301:                 	}
302:                 	
303:                 	dw = TickGet() - dwTimeStart;
9D030190  0F40CDD6   JAL TickGet
9D030194  00000000   NOP
9D030198  00401821   ADDU V1, V0, ZERO
9D03019C  8F828180   LW V0, -32384(GP)
9D0301A0  00621023   SUBU V0, V1, V0
9D0301A4  AFC20014   SW V0, 20(S8)
304:                 	if(dw > TICK_SECOND)
9D0301A8  8FC30014   LW V1, 20(S8)
9D0301AC  3C020002   LUI V0, 2
9D0301B0  3442625B   ORI V0, V0, 25179
9D0301B4  0062102B   SLTU V0, V1, V0
9D0301B8  14400056   BNE V0, ZERO, 0x9D030314
9D0301BC  00000000   NOP
305:                 	{
306:                 		if(TCPIsPutReady(MySocket) < 40u)
9D0301C0  93828029   LBU V0, -32727(GP)
9D0301C4  00402021   ADDU A0, V0, ZERO
9D0301C8  0F40038E   JAL TCPIsPutReady
9D0301CC  00000000   NOP
9D0301D0  2C420028   SLTIU V0, V0, 40
9D0301D4  1440004E   BNE V0, ZERO, 0x9D030310
9D0301D8  00000000   NOP
307:                 			return;
9D030310  00000000   NOP
308:                 
309:                 		dwTimeStart = TickGet();
9D0301DC  0F40CDD6   JAL TickGet
9D0301E0  00000000   NOP
9D0301E4  AF828180   SW V0, -32384(GP)
310:                 
311:                 		// Calculate exact bytes/second, with rounding
312:                 		qw = (QWORD)dwBytesRead * TICK_SECOND;
9D0301E8  8F828184   LW V0, -32380(GP)
9D0301EC  0040A021   ADDU S4, V0, ZERO
9D0301F0  0000A821   ADDU S5, ZERO, ZERO
9D0301F4  3C020002   LUI V0, 2
9D0301F8  3442625A   ORI V0, V0, 25178
9D0301FC  72A22002   MUL A0, S5, V0
9D030200  00001021   ADDU V0, ZERO, ZERO
9D030204  72821002   MUL V0, S4, V0
9D030208  00822021   ADDU A0, A0, V0
9D03020C  3C020002   LUI V0, 2
9D030210  3442625A   ORI V0, V0, 25178
9D030214  02820019   MULTU 0, S4, V0
9D030218  00001012   MFLO V0, 0
9D03021C  00001810   MFHI V1, 0
9D030220  00832021   ADDU A0, A0, V1
9D030224  00801821   ADDU V1, A0, ZERO
9D030228  AFC20018   SW V0, 24(S8)
9D03022C  AFC3001C   SW V1, 28(S8)
9D030230  AFC20018   SW V0, 24(S8)
9D030234  AFC3001C   SW V1, 28(S8)
313:                 		qw += dw>>1;
9D030238  8FC20014   LW V0, 20(S8)
9D03023C  00021042   SRL V0, V0, 1
9D030240  00408021   ADDU S0, V0, ZERO
9D030244  00008821   ADDU S1, ZERO, ZERO
9D030248  8FC40018   LW A0, 24(S8)
9D03024C  8FC5001C   LW A1, 28(S8)
9D030250  00901021   ADDU V0, A0, S0
9D030254  0044302B   SLTU A2, V0, A0
9D030258  00B11821   ADDU V1, A1, S1
9D03025C  00C32021   ADDU A0, A2, V1
9D030260  00801821   ADDU V1, A0, ZERO
9D030264  AFC20018   SW V0, 24(S8)
9D030268  AFC3001C   SW V1, 28(S8)
314:                 		qw /= dw;
9D03026C  8FD20014   LW S2, 20(S8)
9D030270  00009821   ADDU S3, ZERO, ZERO
9D030274  8FC40018   LW A0, 24(S8)
9D030278  8FC5001C   LW A1, 28(S8)
9D03027C  02403021   ADDU A2, S2, ZERO
9D030280  02603821   ADDU A3, S3, ZERO
9D030284  0F40C887   JAL __udivdi3
9D030288  00000000   NOP
9D03028C  AFC20018   SW V0, 24(S8)
9D030290  AFC3001C   SW V1, 28(S8)
315:                 		ultoa((DWORD)qw, vBuffer);
9D030294  27C30020   ADDIU V1, S8, 32
9D030298  8FC20018   LW V0, 24(S8)
9D03029C  00602021   ADDU A0, V1, ZERO
9D0302A0  00402821   ADDU A1, V0, ZERO
9D0302A4  2406000A   ADDIU A2, ZERO, 10
9D0302A8  0F40D75B   JAL ultoa
9D0302AC  00000000   NOP
316:                 		TCPPutString(MySocket, vBuffer);
9D0302B0  93828029   LBU V0, -32727(GP)
9D0302B4  00401821   ADDU V1, V0, ZERO
9D0302B8  27C20020   ADDIU V0, S8, 32
9D0302BC  00602021   ADDU A0, V1, ZERO
9D0302C0  00402821   ADDU A1, V0, ZERO
9D0302C4  0F4005FD   JAL TCPPutString
9D0302C8  00000000   NOP
317:                 		TCPPutROMString(MySocket, (ROM BYTE*)" bytes/second\r\n");
9D0302CC  93828029   LBU V0, -32727(GP)
9D0302D0  00401821   ADDU V1, V0, ZERO
9D0302D4  3C029D03   LUI V0, -25341
9D0302D8  24425E20   ADDIU V0, V0, 24096
9D0302DC  00602021   ADDU A0, V1, ZERO
9D0302E0  00402821   ADDU A1, V0, ZERO
9D0302E4  0F4005FD   JAL TCPPutString
9D0302E8  00000000   NOP
318:                 		
319:                 		dwBytesRead = 0;
9D0302EC  AF808184   SW ZERO, -32380(GP)
9D0302F0  0B40C0C5   J 0x9D030314
9D0302F4  00000000   NOP
320:                 	}
321:                 	
322:                 	
323:                 }
9D030314  03C0E821   ADDU SP, S8, ZERO
9D030318  8FBF004C   LW RA, 76(SP)
9D03031C  8FBE0048   LW S8, 72(SP)
9D030320  8FB50044   LW S5, 68(SP)
9D030324  8FB40040   LW S4, 64(SP)
9D030328  8FB3003C   LW S3, 60(SP)
9D03032C  8FB20038   LW S2, 56(SP)
9D030330  8FB10034   LW S1, 52(SP)
9D030334  8FB00030   LW S0, 48(SP)
9D030338  27BD0050   ADDIU SP, SP, 80
9D03033C  03E00008   JR RA
9D030340  00000000   NOP
324:                 
325:                 #endif //#if defined(STACK_USE_TCP_PERFORMANCE_TEST)
---  C:/Users/Diego/Documents/GitHub/pic32webFREERtos/Pic32Web.X/src/tcpip/src/TCP.c  -------------------
1:                   /*********************************************************************
2:                    *
3:                    *	Transmission Control Protocol (TCP) Communications Layer
4:                    *  Module for Microchip TCP/IP Stack
5:                    *	 -Provides reliable, handshaked transport of application stream 
6:                    *    oriented data with flow control
7:                    *	 -Reference: RFC 793
8:                    *
9:                    *********************************************************************
10:                   * FileName:        TCP.c
11:                   * Dependencies:    IP, Tick, Ethernet/WiFi (ENC28J60.c, ETH97J60.c, 
12:                   *					ENCX24J600.c, or WFMac.c), ARP (optional), 
13:                   *					DNS (optional)
14:                   * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32
15:                   * Compiler:        Microchip C32 v1.05 or higher
16:                   *					Microchip C30 v3.12 or higher
17:                   *					Microchip C18 v3.30 or higher
18:                   *					HI-TECH PICC-18 PRO 9.63PL2 or higher
19:                   * Company:         Microchip Technology, Inc.
20:                   *
21:                   * Software License Agreement
22:                   *
23:                   * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights
24:                   * reserved.
25:                   *
26:                   * Microchip licenses to you the right to use, modify, copy, and
27:                   * distribute:
28:                   * (i)  the Software when embedded on a Microchip microcontroller or
29:                   *      digital signal controller product ("Device") which is
30:                   *      integrated into Licensee's product; or
31:                   * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h,
32:                   *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device
33:                   *		used in conjunction with a Microchip ethernet controller for
34:                   *		the sole purpose of interfacing with the ethernet controller.
35:                   *
36:                   * You should refer to the license agreement accompanying this
37:                   * Software for additional information regarding your rights and
38:                   * obligations.
39:                   *
40:                   * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT
41:                   * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT
42:                   * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A
43:                   * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL
44:                   * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR
45:                   * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF
46:                   * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS
47:                   * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE
48:                   * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER
49:                   * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT
50:                   * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE.
51:                   *
52:                   *
53:                   * Author               Date    	Comment
54:                   *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
55:                   * Nilesh Rajbharti     5/8/01  	Original        (Rev 1.0)
56:                   * Howard Schlunder		12/11/06	Changed almost everything to 
57:                   *									better meet RFC 793.
58:                   ********************************************************************/
59:                  #define __TCP_C
60:                  
61:                  #include "TCPIP Stack/TCPIP.h"
62:                  
63:                  #if defined(STACK_USE_TCP)
64:                  
65:                  /****************************************************************************
66:                    Section:
67:                  	Configuration Parameters
68:                    ***************************************************************************/
69:                  
70:                  // Starting port for client sockets
71:                  #define LOCAL_PORT_START_NUMBER (1024u)
72:                  // End port for client sockets
73:                  #define LOCAL_PORT_END_NUMBER   (5000u)
74:                  
75:                  // For debugging only.  Normal applications should never enable these
76:                  //#define DEBUG_GENERATE_TX_LOSS		62257
77:                  //#define DEBUG_GENERATE_RX_LOSS		64225
78:                  
79:                  // A lot of pointer dereference code can be removed if you 
80:                  // locally copy TCBStubs to an absolute memory location.
81:                  // If you define TCP_OPTIMIZE_FOR_SIZE, local caching will 
82:                  // occur and will substantially decrease the entire TCP ROM 
83:                  // footprint (up to 35%).  If you leave TCP_OPTIMIZE_FOR_SIZE 
84:                  // undefined, the local caching will be disabled.  On PIC18 
85:                  // products, this will improve TCP performance/throughput by 
86:                  // approximately 15%.
87:                  #define TCP_OPTIMIZE_FOR_SIZE
88:                  
89:                  // For smallest size and best throughput, TCP_OPTIMIZE_FOR_SIZE 
90:                  // should always be enabled on PIC24/dsPIC products.  On PIC32 
91:                  // products there is very little difference and depnds on compiler 
92:                  // optimization level
93:                  #if defined(__C30__) && !defined(TCP_OPTIMIZE_FOR_SIZE)
94:                  	#define TCP_OPTIMIZE_FOR_SIZE
95:                  #elif defined(__C32__) && defined(TCP_OPTIMIZE_FOR_SIZE)
96:                  	#undef TCP_OPTIMIZE_FOR_SIZE
97:                  #endif
98:                  
99:                  // TCP Maximum Segment Size for TX.  The TX maximum segment size is actually 
100:                 // govered by the remote node's MSS option advirtised during connection 
101:                 // establishment.  However, if the remote node specifies an unhandlably large 
102:                 // MSS (ex: > Ethernet MTU), this define sets a hard limit so that we don't 
103:                 // cause any TX buffer overflows.  If the remote node does not advirtise a MSS 
104:                 // option, all TX segments are fixed at 536 bytes maximum.
105:                 #define TCP_MAX_SEG_SIZE_TX			(1460u)
106:                 
107:                 // TCP Maximum Segment Size for RX.  This value is advirtised during connection 
108:                 // establishment and the remote node should obey it.  This should be set to 536 
109:                 // to avoid IP layer fragmentation from causing packet loss.  However, raising 
110:                 // its value can enhance performance at the (small) risk of introducing 
111:                 // incompatibility with certain special remote nodes (ex: ones connected via a 
112:                 // slow dial up modem).
113:                 #define TCP_MAX_SEG_SIZE_RX			(536u)
114:                 
115:                 // TCP Timeout and retransmit numbers
116:                 #define TCP_START_TIMEOUT_VAL   	((DWORD)TICK_SECOND*1)	// Timeout to retransmit unacked data
117:                 #define TCP_DELAYED_ACK_TIMEOUT		((DWORD)TICK_SECOND/10)	// Timeout for delayed-acknowledgement algorithm
118:                 #define TCP_FIN_WAIT_2_TIMEOUT		((DWORD)TICK_SECOND*5)	// Timeout for FIN WAIT 2 state
119:                 #define TCP_KEEP_ALIVE_TIMEOUT		((DWORD)TICK_SECOND*10)	// Timeout for keep-alive messages when no traffic is sent
120:                 #define TCP_CLOSE_WAIT_TIMEOUT		((DWORD)TICK_SECOND/5)	// Timeout for the CLOSE_WAIT state
121:                 #define TCP_MAX_RETRIES			    (5u)					// Maximum number of retransmission attempts
122:                 #define TCP_MAX_UNACKED_KEEP_ALIVES	(6u)					// Maximum number of keep-alive messages that can be sent without receiving a response before automatically closing the connection
123:                 #define TCP_MAX_SYN_RETRIES			(2u)	// Smaller than all other retries to reduce SYN flood DoS duration
124:                 
125:                 #define TCP_AUTO_TRANSMIT_TIMEOUT_VAL	(TICK_SECOND/25ull)	// Timeout before automatically transmitting unflushed data
126:                 #define TCP_WINDOW_UPDATE_TIMEOUT_VAL	(TICK_SECOND/5ull)	// Timeout before automatically transmitting a window update due to a TCPGet() or TCPGetArray() function call
127:                 
128:                 #define TCP_SYN_QUEUE_MAX_ENTRIES	(3u) 					// Number of TCP RX SYN packets to save if they cannot be serviced immediately
129:                 #define TCP_SYN_QUEUE_TIMEOUT		((DWORD)TICK_SECOND*3)	// Timeout for when SYN queue entries are deleted if unserviceable
130:                 
131:                 /****************************************************************************
132:                   Section:
133:                 	TCP Header Data Types
134:                   ***************************************************************************/
135:                 
136:                 #define FIN     (0x01)		// FIN Flag as defined in RFC
137:                 #define SYN     (0x02)		// SYN Flag as defined in RFC
138:                 #define RST     (0x04)		// Reset Flag as defined in RFC
139:                 #define PSH     (0x08)		// Push Flag as defined in RFC
140:                 #define ACK     (0x10)		// Acknowledge Flag as defined in RFC
141:                 #define URG     (0x20)		// Urgent Flag as defined in RFC
142:                 
143:                 // TCP Header Data Structure
144:                 typedef struct
145:                 {
146:                 	WORD    SourcePort;		// Local port number
147:                 	WORD    DestPort;		// Remote port number
148:                 	DWORD   SeqNumber;		// Local sequence number
149:                 	DWORD   AckNumber;		// Acknowledging remote sequence number
150:                 
151:                 	struct
152:                 	{
153:                 		unsigned char Reserved3      : 4;
154:                 		unsigned char Val            : 4;
155:                 	} DataOffset;			// Data offset flags nibble
156:                 
157:                 	union
158:                 	{
159:                 		struct
160:                 		{
161:                 			unsigned char flagFIN    : 1;
162:                 			unsigned char flagSYN    : 1;
163:                 			unsigned char flagRST    : 1;
164:                 			unsigned char flagPSH    : 1;
165:                 			unsigned char flagACK    : 1;
166:                 			unsigned char flagURG    : 1;
167:                 			unsigned char Reserved2  : 2;
168:                 		} bits;
169:                 		BYTE byte;
170:                 	} Flags;				// TCP Flags as defined in RFC
171:                 
172:                 	WORD    Window;			// Local free RX buffer window
173:                 	WORD    Checksum;		// Data payload checksum
174:                 	WORD    UrgentPointer;	// Urgent pointer
175:                 } TCP_HEADER;
176:                 
177:                 #define TCP_OPTIONS_END_OF_LIST     (0x00u)		// End of List TCP Option Flag
178:                 #define TCP_OPTIONS_NO_OP           (0x01u)		// No Op TCP Option
179:                 #define TCP_OPTIONS_MAX_SEG_SIZE    (0x02u)		// Maximum segment size TCP flag
180:                 typedef struct
181:                 {
182:                 	BYTE        Kind;							// Type of option
183:                 	BYTE        Length;							// Length
184:                 	WORD_VAL    MaxSegSize;						// Maximum segment size
185:                 } TCP_OPTIONS;									// TCP Options data structure							
186:                 
187:                 // Structure containing all the important elements of an incomming 
188:                 // SYN packet in order to establish a connection at a future time 
189:                 // if all sockets on the listening port are already connected to 
190:                 // someone
191:                 typedef struct 
192:                 {
193:                 	NODE_INFO	niSourceAddress;// Remote IP address and MAC address
194:                 	WORD		wSourcePort;	// Remote TCP port number that the response SYN needs to be sent to
195:                 	DWORD		dwSourceSEQ;	// Remote TCP SEQuence number that must be ACKnowledged when we send our response SYN
196:                 	WORD		wDestPort;		// Local TCP port which the original SYN was destined for
197:                 	WORD		wTimestamp;		// Timer to expire old SYN packets that can't be serviced at all
198:                 } TCP_SYN_QUEUE;
199:                 
200:                 
201:                 #if defined(STACK_CLIENT_MODE)
202:                 static WORD NextPort __attribute__((persistent));	// Tracking variable for next local client port number
203:                 #endif
204:                 
205:                 /****************************************************************************
206:                   Section:
207:                 	TCB Definitions
208:                   ***************************************************************************/
209:                 
210:                 // Determines the number of defined TCP sockets
211:                 #define TCP_SOCKET_COUNT	(sizeof(TCPSocketInitializer)/sizeof(TCPSocketInitializer[0]))
212:                 
213:                 
214:                 #if defined(HI_TECH_C)
215:                 	// The initializer forces this large array out of the bss section 
216:                 	// so we can link correctly.
217:                 	#pragma psect bigdata=TCB_uRAM_BIG
218:                 	#pragma psect data=TCB_uRAM
219:                 	static TCB_STUB TCBStubs[TCP_SOCKET_COUNT] = {'\0'};	
220:                 	#pragma psect data=ordinary_data_sect
221:                 	#pragma psect bigdata=ordinary_data_sect_big
222:                 #else
223:                 	// The TCB array is very large.  With the C18 compiler, one must 
224:                 	// modify the linker script to make an array that spans more than 
225:                 	// one memory bank.  To do this, make the necessary changes to your 
226:                 	// processor's linker script (.lkr).  Here is an example showing 
227:                 	// gpr11 and 128 bytes of gpr12 being combined into one 384 byte 
228:                 	// block used exclusively by the TCB_uRAM data section:
229:                 	// ...
230:                 	// //DATABANK   NAME=gpr11      START=0xB00          END=0xBFF
231:                 	// //DATABANK   NAME=gpr12      START=0xC00          END=0xCFF
232:                 	// DATABANK   NAME=gpr11b     START=0xB00          END=0xC7F           PROTECTED
233:                 	// DATABANK   NAME=gpr12      START=0xC80          END=0xCFF
234:                 	// ...
235:                 	// SECTION    NAME=TCB_uRAM    RAM=gpr11b
236:                 	// ...
237:                 	#if defined(__18CXX) && !defined(HI_TECH_C)	
238:                 		#pragma udata TCB_uRAM
239:                 	#endif
240:                 	static TCB_STUB TCBStubs[TCP_SOCKET_COUNT];
241:                 	#if defined(__18CXX) && !defined(HI_TECH_C)	
242:                 		#pragma udata					// Return to any other RAM section
243:                 	#endif
244:                 #endif
245:                 
246:                 static TCB MyTCB;									// Currently loaded TCB
247:                 static TCP_SOCKET hCurrentTCP = INVALID_SOCKET;		// Current TCP socket
248:                 #if TCP_SYN_QUEUE_MAX_ENTRIES
249:                 	#if defined(__18CXX) && !defined(HI_TECH_C)	
250:                 		#pragma udata SYN_QUEUE_RAM_SECT
251:                 	#endif
252:                 	static TCP_SYN_QUEUE SYNQueue[TCP_SYN_QUEUE_MAX_ENTRIES];	// Array of saved incoming SYN requests that need to be serviced later
253:                 	#if defined(__18CXX) && !defined(HI_TECH_C)	
254:                 		#pragma udata
255:                 	#endif
256:                 #endif
257:                 
258:                 /****************************************************************************
259:                   Section:
260:                 	Function Prototypes
261:                   ***************************************************************************/
262:                 
263:                 static void TCPRAMCopy(PTR_BASE wDest, BYTE vDestType, PTR_BASE wSource, BYTE vSourceType, WORD wLength);
264:                 
265:                 #if defined(__18CXX)
266:                 	static void TCPRAMCopyROM(PTR_BASE wDest, BYTE wDestType, ROM BYTE* wSource, WORD wLength);
267:                 #else
268:                 	#define TCPRAMCopyROM(a,b,c,d)	TCPRAMCopy(a,b,c,TCP_PIC_RAM,d)
269:                 #endif
270:                 
271:                 static void SendTCP(BYTE vTCPFlags, BYTE vSendFlags);
272:                 static void HandleTCPSeg(TCP_HEADER* h, WORD len);
273:                 static BOOL FindMatchingSocket(TCP_HEADER* h, NODE_INFO* remote);
274:                 static void SwapTCPHeader(TCP_HEADER* header);
275:                 static void CloseSocket(void);
276:                 static void SyncTCB(void);
277:                 
278:                 // Indicates if this packet is a retransmission (no reset) or a new packet (reset required)
279:                 #define SENDTCP_RESET_TIMERS	0x01
280:                 // Instead of transmitting normal data, a garbage octet is transmitted according to RFC 1122 section 4.2.3.6
281:                 #define SENDTCP_KEEP_ALIVE		0x02
282:                 
283:                 
284:                 /****************************************************************************
285:                   Section:
286:                 	TCB Optimization Configuration
287:                   ***************************************************************************/
288:                 
289:                 #if defined(TCP_OPTIMIZE_FOR_SIZE)
290:                 	static TCB_STUB MyTCBStub;
291:                 	
292:                 	// Flushes MyTCBStub cache and loads up the specified TCB_STUB.
293:                 	// Does nothing on cache hit.
294:                 	static void SyncTCBStub(TCP_SOCKET hTCP)
295:                 	{
296:                 		if(hCurrentTCP == hTCP)
297:                 			return;
298:                 	
299:                 		if(hCurrentTCP != INVALID_SOCKET)
300:                 		{
301:                 			// Save the current TCB stub
302:                 			memcpy((void*)&TCBStubs[hCurrentTCP], (void*)&MyTCBStub, sizeof(MyTCBStub));
303:                 		}
304:                 	
305:                 		hCurrentTCP = hTCP;
306:                 	
307:                 		if(hTCP == INVALID_SOCKET)
308:                 			return;
309:                 	
310:                 		// Load up the new TCB stub
311:                 		memcpy((void*)&MyTCBStub, (void*)&TCBStubs[hTCP], sizeof(MyTCBStub));
312:                 	}
313:                 #else
314:                 	// Flushes MyTCBStub cache and loads up the specified TCB_STUB.
315:                 	// Does nothing on cache hit.
316:                 	#define SyncTCBStub(a)	hCurrentTCP = (a)
317:                 	// Alias to current TCP stub.
318:                 	#define MyTCBStub		TCBStubs[hCurrentTCP]
319:                 #endif
320:                 
321:                 
322:                 
323:                 // Flushes MyTCB cache and loads up the specified TCB.
324:                 // Does nothing on cache hit.
325:                 static void SyncTCB(void)
326:                 {
9D000020  27BDFFE0   ADDIU SP, SP, -32
9D000024  AFBF001C   SW RA, 28(SP)
9D000028  AFBE0018   SW S8, 24(SP)
9D00002C  03A0F021   ADDU S8, SP, ZERO
327:                 	static TCP_SOCKET hLastTCB = INVALID_SOCKET;
328:                 	
329:                 	if(hLastTCB == hCurrentTCP)
9D000030  93838028   LBU V1, -32728(GP)
9D000034  93828027   LBU V0, -32729(GP)
9D000038  1062003E   BEQ V1, V0, 0x9D000134
9D00003C  00000000   NOP
330:                 		return;
9D000134  00000000   NOP
331:                 
332:                 	if(hLastTCB != INVALID_SOCKET)
9D000040  93838028   LBU V1, -32728(GP)
9D000044  240200FE   ADDIU V0, ZERO, 254
9D000048  1062001C   BEQ V1, V0, 0x9D0000BC
9D00004C  00000000   NOP
333:                 	{
334:                 		// Save the current TCB
335:                 		TCPRAMCopy(TCBStubs[hLastTCB].bufferTxStart - sizeof(MyTCB), TCBStubs[hLastTCB].vMemoryMedium, (PTR_BASE)&MyTCB, TCP_PIC_RAM, sizeof(MyTCB));
9D000050  93828028   LBU V0, -32728(GP)
9D000054  00402021   ADDU A0, V0, ZERO
9D000058  3C02A000   LUI V0, -24576
9D00005C  24030030   ADDIU V1, ZERO, 48
9D000060  70831802   MUL V1, A0, V1
9D000064  24422CDC   ADDIU V0, V0, 11484
9D000068  00621021   ADDU V0, V1, V0
9D00006C  8C420000   LW V0, 0(V0)
9D000070  2444FFD4   ADDIU A0, V0, -44
9D000074  93828028   LBU V0, -32728(GP)
9D000078  00402821   ADDU A1, V0, ZERO
9D00007C  3C02A000   LUI V0, -24576
9D000080  24030030   ADDIU V1, ZERO, 48
9D000084  70A31802   MUL V1, A1, V1
9D000088  24422CDC   ADDIU V0, V0, 11484
9D00008C  00621021   ADDU V0, V1, V0
9D000090  9042002C   LBU V0, 44(V0)
9D000094  00401821   ADDU V1, V0, ZERO
9D000098  3C02A000   LUI V0, -24576
9D00009C  24422E8C   ADDIU V0, V0, 11916
9D0000A0  2405002C   ADDIU A1, ZERO, 44
9D0000A4  AFA50010   SW A1, 16(SP)
9D0000A8  00602821   ADDU A1, V1, ZERO
9D0000AC  00403021   ADDU A2, V0, ZERO
9D0000B0  24070001   ADDIU A3, ZERO, 1
9D0000B4  0F4020BE   JAL TCPRAMCopy
9D0000B8  00000000   NOP
336:                 	}
337:                 
338:                 	// Load up the new TCB
339:                 	hLastTCB = hCurrentTCP;
9D0000BC  93828027   LBU V0, -32729(GP)
9D0000C0  A3828028   SB V0, -32728(GP)
340:                 	TCPRAMCopy((PTR_BASE)&MyTCB, TCP_PIC_RAM, MyTCBStub.bufferTxStart - sizeof(MyTCB), MyTCBStub.vMemoryMedium, sizeof(MyTCB));
9D0000C4  3C02A000   LUI V0, -24576
9D0000C8  24442E8C   ADDIU A0, V0, 11916
9D0000CC  93828027   LBU V0, -32729(GP)
9D0000D0  00402821   ADDU A1, V0, ZERO
9D0000D4  3C02A000   LUI V0, -24576
9D0000D8  24030030   ADDIU V1, ZERO, 48
9D0000DC  70A31802   MUL V1, A1, V1
9D0000E0  24422CDC   ADDIU V0, V0, 11484
9D0000E4  00621021   ADDU V0, V1, V0
9D0000E8  8C420000   LW V0, 0(V0)
9D0000EC  2443FFD4   ADDIU V1, V0, -44
9D0000F0  93828027   LBU V0, -32729(GP)
9D0000F4  00403021   ADDU A2, V0, ZERO
9D0000F8  3C02A000   LUI V0, -24576
9D0000FC  24050030   ADDIU A1, ZERO, 48
9D000100  70C52802   MUL A1, A2, A1
9D000104  24422CDC   ADDIU V0, V0, 11484
9D000108  00A21021   ADDU V0, A1, V0
9D00010C  9042002C   LBU V0, 44(V0)
9D000110  2405002C   ADDIU A1, ZERO, 44
9D000114  AFA50010   SW A1, 16(SP)
9D000118  24050001   ADDIU A1, ZERO, 1
9D00011C  00603021   ADDU A2, V1, ZERO
9D000120  00403821   ADDU A3, V0, ZERO
9D000124  0F4020BE   JAL TCPRAMCopy
9D000128  00000000   NOP
9D00012C  0B40004E   J 0x9D000138
9D000130  00000000   NOP
341:                 }
9D000138  03C0E821   ADDU SP, S8, ZERO
9D00013C  8FBF001C   LW RA, 28(SP)
9D000140  8FBE0018   LW S8, 24(SP)
9D000144  27BD0020   ADDIU SP, SP, 32
9D000148  03E00008   JR RA
9D00014C  00000000   NOP
342:                 
343:                 
344:                 /*****************************************************************************
345:                   Function:
346:                 	void TCPInit(void)
347:                 
348:                   Summary:
349:                 	Initializes the TCP module.
350:                 
351:                   Description:
352:                 	Initializes the TCP module.  This function sets up the TCP buffers
353:                 	in memory and initializes each socket to the CLOSED state.  If
354:                 	insufficient memory was allocated for the TCP sockets, the function
355:                 	will hang here to be captured by the debugger.
356:                 
357:                   Precondition:
358:                 	None
359:                 
360:                   Parameters:
361:                 	None
362:                 
363:                   Returns:
364:                   	None
365:                   	
366:                   Remarks:
367:                 	This function is called only one during lifetime of the application.
368:                   ***************************************************************************/
369:                 void TCPInit(void)
370:                 {
9D000150  27BDFFD8   ADDIU SP, SP, -40
9D000154  AFBF0024   SW RA, 36(SP)
9D000158  AFBE0020   SW S8, 32(SP)
9D00015C  03A0F021   ADDU S8, SP, ZERO
371:                 	BYTE i;
372:                 	BYTE vSocketsAllocated;
373:                 	WORD wTXSize, wRXSize;
374:                 	PTR_BASE ptrBaseAddress;
375:                 	BYTE vMedium;
376:                 	#if TCP_ETH_RAM_SIZE > 0
377:                 	WORD wCurrentETHAddress = TCP_ETH_RAM_BASE_ADDRESS;
9D000160  240205EE   ADDIU V0, ZERO, 1518
9D000164  A7C20012   SH V0, 18(S8)
378:                 	#endif
379:                 	#if TCP_PIC_RAM_SIZE > 0
380:                 	PTR_BASE ptrCurrentPICAddress = TCP_PIC_RAM_BASE_ADDRESS;
381:                 	#endif
382:                 	#if TCP_SPI_RAM_SIZE > 0
383:                 	WORD wCurrentSPIAddress = TCP_SPI_RAM_BASE_ADDRESS;
384:                 	#endif
385:                 
386:                 	#if defined(STACK_CLIENT_MODE)
387:                 		// Initialize NextPort to a random value if it is zero (such as after 
388:                 		// reset on a PIC32 or PIC18 when the static memory initializer is 
389:                 		// used).  By starting with a random number, we decrease the risk of 
390:                 		// reusing a port number that was previously used if the user power 
391:                 		// cycles the device.
392:                 		if(NextPort == 0u)
9D000168  3C02A000   LUI V0, -24576
9D00016C  94420224   LHU V0, 548(V0)
9D000170  1440000A   BNE V0, ZERO, 0x9D00019C
9D000174  00000000   NOP
393:                 			NextPort = (((WORD)GenerateRandomDWORD()) & 0x07FFu) + LOCAL_PORT_START_NUMBER;
9D000178  0F40962B   JAL GenerateRandomDWORD
9D00017C  00000000   NOP
9D000180  3042FFFF   ANDI V0, V0, -1
9D000184  304207FF   ANDI V0, V0, 2047
9D000188  3042FFFF   ANDI V0, V0, -1
9D00018C  24420400   ADDIU V0, V0, 1024
9D000190  3043FFFF   ANDI V1, V0, -1
9D000194  3C02A000   LUI V0, -24576
9D000198  A4430224   SH V1, 548(V0)
394:                 	#endif
395:                 
396:                 
397:                 	// Mark all SYN Queue entries as invalid by zeroing the memory
398:                 	#if TCP_SYN_QUEUE_MAX_ENTRIES
399:                 		memset((void*)SYNQueue, 0x00, sizeof(SYNQueue));
9D00019C  3C02A000   LUI V0, -24576
9D0001A0  24442EB8   ADDIU A0, V0, 11960
9D0001A4  00002821   ADDU A1, ZERO, ZERO
9D0001A8  2406003C   ADDIU A2, ZERO, 60
9D0001AC  0F40D5EC   JAL 0x9D0357B0
9D0001B0  00000000   NOP
400:                 	#endif
401:                 	
402:                 	// Allocate all socket FIFO addresses
403:                 	vSocketsAllocated = 0;
9D0001B4  A3C00014   SB ZERO, 20(S8)
404:                 	for(i = 0; i < TCP_SOCKET_COUNT; i++)
9D0001B8  A3C00010   SB ZERO, 16(S8)
9D0001BC  0B4000FF   J 0x9D0003FC
9D0001C0  00000000   NOP
9D0003E0  93C20010   LBU V0, 16(S8)
9D0003E4  24420001   ADDIU V0, V0, 1
9D0003E8  A3C20010   SB V0, 16(S8)
9D0003EC  0B4000FF   J 0x9D0003FC
9D0003F0  00000000   NOP
9D0003FC  93C20010   LBU V0, 16(S8)
9D000400  2C420009   SLTIU V0, V0, 9
9D000404  1440FF6F   BNE V0, ZERO, 0x9D0001C4
9D000408  00000000   NOP
405:                 	{
406:                 		// Generate all needed sockets of each type (TCP_PURPOSE_*)
407:                 		SyncTCBStub(i);
9D0001C4  93C20010   LBU V0, 16(S8)
9D0001C8  A3828027   SB V0, -32729(GP)
408:                 	
409:                 		vMedium = TCPSocketInitializer[i].vMemoryMedium;
9D0001CC  93C40010   LBU A0, 16(S8)
9D0001D0  3C029D03   LUI V0, -25341
9D0001D4  24030006   ADDIU V1, ZERO, 6
9D0001D8  70831802   MUL V1, A0, V1
9D0001DC  2442601C   ADDIU V0, V0, 24604
9D0001E0  00621021   ADDU V0, V1, V0
9D0001E4  90420001   LBU V0, 1(V0)
9D0001E8  A3C20015   SB V0, 21(S8)
410:                 		wTXSize = TCPSocketInitializer[i].wTXBufferSize;
9D0001EC  93C40010   LBU A0, 16(S8)
9D0001F0  3C029D03   LUI V0, -25341
9D0001F4  24030006   ADDIU V1, ZERO, 6
9D0001F8  70831802   MUL V1, A0, V1
9D0001FC  2442601C   ADDIU V0, V0, 24604
9D000200  00621021   ADDU V0, V1, V0
9D000204  94420002   LHU V0, 2(V0)
9D000208  A7C20016   SH V0, 22(S8)
411:                 		wRXSize = TCPSocketInitializer[i].wRXBufferSize;
9D00020C  93C40010   LBU A0, 16(S8)
9D000210  3C029D03   LUI V0, -25341
9D000214  24030006   ADDIU V1, ZERO, 6
9D000218  70831802   MUL V1, A0, V1
9D00021C  2442601C   ADDIU V0, V0, 24604
9D000220  00621021   ADDU V0, V1, V0
9D000224  94420004   LHU V0, 4(V0)
9D000228  A7C20018   SH V0, 24(S8)
412:                 	
413:                 		switch(vMedium)
9D00022C  93C20015   LBU V0, 21(S8)
9D000230  10400003   BEQ V0, ZERO, 0x9D000240
9D000234  00000000   NOP
9D000238  0B4000FD   J 0x9D0003F4
9D00023C  00000000   NOP
414:                 		{
415:                 			#if TCP_ETH_RAM_SIZE > 0
416:                 			case TCP_ETH_RAM:
417:                 				ptrBaseAddress = wCurrentETHAddress;
9D000240  97C20012   LHU V0, 18(S8)
9D000244  AFC2001C   SW V0, 28(S8)
418:                 				wCurrentETHAddress += sizeof(TCB) + wTXSize+1 + wRXSize+1;
9D000248  97C30016   LHU V1, 22(S8)
9D00024C  97C20018   LHU V0, 24(S8)
9D000250  00621021   ADDU V0, V1, V0
9D000254  3043FFFF   ANDI V1, V0, -1
9D000258  97C20012   LHU V0, 18(S8)
9D00025C  00621021   ADDU V0, V1, V0
9D000260  3042FFFF   ANDI V0, V0, -1
9D000264  2442002E   ADDIU V0, V0, 46
9D000268  A7C20012   SH V0, 18(S8)
419:                 				// Do a sanity check to ensure that we aren't going to use memory that hasn't been allocated to us.
420:                 				// If your code locks up right here, it means you've incorrectly allocated your TCP socket buffers in TCPIPConfig.h.  See the TCP memory allocation section.  More RAM needs to be allocated to the base memory mediums, or the individual sockets TX and RX FIFOS and socket quantiy needs to be shrunken.
421:                 				while(wCurrentETHAddress > TCP_ETH_RAM_BASE_ADDRESS + TCP_ETH_RAM_SIZE);
9D00026C  97C20012   LHU V0, 18(S8)
9D000270  2C4245EF   SLTIU V0, V0, 17903
9D000274  1040FFFD   BEQ V0, ZERO, 0x9D00026C
9D000278  00000000   NOP
422:                 				break;
423:                 			#endif
424:                 				
425:                 			#if TCP_PIC_RAM_SIZE > 0
426:                 			case TCP_PIC_RAM:
427:                 				ptrBaseAddress = ptrCurrentPICAddress;
428:                 				ptrCurrentPICAddress += sizeof(TCB) + wTXSize+1 + wRXSize+1;
429:                 				// Do a sanity check to ensure that we aren't going to use memory that hasn't been allocated to us.
430:                 				// If your code locks up right here, it means you've incorrectly allocated your TCP socket buffers in TCPIPConfig.h.  See the TCP memory allocation section.  More RAM needs to be allocated to the base memory mediums, or the individual sockets TX and RX FIFOS and socket quantiy needs to be shrunken.
431:                 				while(ptrCurrentPICAddress > TCP_PIC_RAM_BASE_ADDRESS + TCP_PIC_RAM_SIZE);
432:                 				break;
433:                 			#endif
434:                 				
435:                 			#if TCP_SPI_RAM_SIZE > 0
436:                 			case TCP_SPI_RAM:
437:                 				ptrBaseAddress = wCurrentSPIAddress;
438:                 				wCurrentSPIAddress += sizeof(TCB) + wTXSize+1 + wRXSize+1;
439:                 				// Do a sanity check to ensure that we aren't going to use memory that hasn't been allocated to us.
440:                 				// If your code locks up right here, it means you've incorrectly allocated your TCP socket buffers in TCPIPConfig.h.  See the TCP memory allocation section.  More RAM needs to be allocated to the base memory mediums, or the individual sockets TX and RX FIFOS and socket quantiy needs to be shrunken.
441:                 				while(wCurrentSPIAddress > TCP_SPI_RAM_BASE_ADDRESS + TCP_SPI_RAM_SIZE);
442:                 				break;
443:                 			#endif
444:                 			
445:                 			default:
446:                 				while(1); // Undefined allocation medium.  Go fix your TCPIPConfig.h TCP memory allocations.
9D0003F4  0B4000FD   J 0x9D0003F4
9D0003F8  00000000   NOP
447:                 		}
448:                 	
449:                 		MyTCBStub.vMemoryMedium = vMedium;
9D00027C  93828027   LBU V0, -32729(GP)
9D000280  00402021   ADDU A0, V0, ZERO
9D000284  3C02A000   LUI V0, -24576
9D000288  24030030   ADDIU V1, ZERO, 48
9D00028C  70831802   MUL V1, A0, V1
9D000290  24422CDC   ADDIU V0, V0, 11484
9D000294  00621021   ADDU V0, V1, V0
9D000298  93C30015   LBU V1, 21(S8)
9D00029C  A043002C   SB V1, 44(V0)
450:                 		MyTCBStub.bufferTxStart	= ptrBaseAddress + sizeof(TCB);
9D0002A0  93828027   LBU V0, -32729(GP)
9D0002A4  00402821   ADDU A1, V0, ZERO
9D0002A8  8FC2001C   LW V0, 28(S8)
9D0002AC  2443002C   ADDIU V1, V0, 44
9D0002B0  3C02A000   LUI V0, -24576
9D0002B4  24040030   ADDIU A0, ZERO, 48
9D0002B8  70A42002   MUL A0, A1, A0
9D0002BC  24422CDC   ADDIU V0, V0, 11484
9D0002C0  00821021   ADDU V0, A0, V0
9D0002C4  AC430000   SW V1, 0(V0)
451:                 		MyTCBStub.bufferRxStart	= MyTCBStub.bufferTxStart + wTXSize + 1;
9D0002C8  93828027   LBU V0, -32729(GP)
9D0002CC  00402821   ADDU A1, V0, ZERO
9D0002D0  93828027   LBU V0, -32729(GP)
9D0002D4  00402021   ADDU A0, V0, ZERO
9D0002D8  3C02A000   LUI V0, -24576
9D0002DC  24030030   ADDIU V1, ZERO, 48
9D0002E0  70831802   MUL V1, A0, V1
9D0002E4  24422CDC   ADDIU V0, V0, 11484
9D0002E8  00621021   ADDU V0, V1, V0
9D0002EC  8C430000   LW V1, 0(V0)
9D0002F0  97C20016   LHU V0, 22(S8)
9D0002F4  00621021   ADDU V0, V1, V0
9D0002F8  24430001   ADDIU V1, V0, 1
9D0002FC  3C02A000   LUI V0, -24576
9D000300  24442CDC   ADDIU A0, V0, 11484
9D000304  24020030   ADDIU V0, ZERO, 48
9D000308  70A21002   MUL V0, A1, V0
9D00030C  00821021   ADDU V0, A0, V0
9D000310  AC430004   SW V1, 4(V0)
452:                 		MyTCBStub.bufferEnd		= MyTCBStub.bufferRxStart + wRXSize;
9D000314  93828027   LBU V0, -32729(GP)
9D000318  00402821   ADDU A1, V0, ZERO
9D00031C  93828027   LBU V0, -32729(GP)
9D000320  00402021   ADDU A0, V0, ZERO
9D000324  3C02A000   LUI V0, -24576
9D000328  24432CDC   ADDIU V1, V0, 11484
9D00032C  24020030   ADDIU V0, ZERO, 48
9D000330  70821002   MUL V0, A0, V0
9D000334  00621021   ADDU V0, V1, V0
9D000338  8C430004   LW V1, 4(V0)
9D00033C  97C20018   LHU V0, 24(S8)
9D000340  00621821   ADDU V1, V1, V0
9D000344  3C02A000   LUI V0, -24576
9D000348  24040030   ADDIU A0, ZERO, 48
9D00034C  70A42002   MUL A0, A1, A0
9D000350  24422CDC   ADDIU V0, V0, 11484
9D000354  00821021   ADDU V0, A0, V0
9D000358  AC430008   SW V1, 8(V0)
453:                 		MyTCBStub.smState		= TCP_CLOSED;
9D00035C  93828027   LBU V0, -32729(GP)
9D000360  00402021   ADDU A0, V0, ZERO
9D000364  3C02A000   LUI V0, -24576
9D000368  24432CDC   ADDIU V1, V0, 11484
9D00036C  24020030   ADDIU V0, ZERO, 48
9D000370  70821002   MUL V0, A0, V0
9D000374  00621021   ADDU V0, V1, V0
9D000378  2403000D   ADDIU V1, ZERO, 13
9D00037C  AC430024   SW V1, 36(V0)
454:                 		MyTCBStub.Flags.bServer	= FALSE;
9D000380  93828027   LBU V0, -32729(GP)
9D000384  00402021   ADDU A0, V0, ZERO
9D000388  3C02A000   LUI V0, -24576
9D00038C  24030030   ADDIU V1, ZERO, 48
9D000390  70831802   MUL V1, A0, V1
9D000394  24422CDC   ADDIU V0, V0, 11484
9D000398  00621821   ADDU V1, V1, V0
9D00039C  8C620028   LW V0, 40(V1)
9D0003A0  7C0218C4   INS V0, ZERO, 3, 1
9D0003A4  AC620028   SW V0, 40(V1)
455:                 		#if defined(STACK_USE_SSL)
456:                 		MyTCBStub.sslStubID = SSL_INVALID_ID;
457:                 		#endif		
458:                 
459:                 		SyncTCB();
9D0003A8  0F400008   JAL SyncTCB
9D0003AC  00000000   NOP
460:                 		MyTCB.vSocketPurpose = TCPSocketInitializer[i].vSocketPurpose;
9D0003B0  93C40010   LBU A0, 16(S8)
9D0003B4  3C029D03   LUI V0, -25341
9D0003B8  24030006   ADDIU V1, ZERO, 6
9D0003BC  70831802   MUL V1, A0, V1
9D0003C0  2442601C   ADDIU V0, V0, 24604
9D0003C4  00621021   ADDU V0, V1, V0
9D0003C8  90430000   LBU V1, 0(V0)
9D0003CC  3C02A000   LUI V0, -24576
9D0003D0  24422E8C   ADDIU V0, V0, 11916
9D0003D4  A043002B   SB V1, 43(V0)
461:                 		CloseSocket();
9D0003D8  0F4014AB   JAL CloseSocket
9D0003DC  00000000   NOP
462:                 	}
463:                 }
9D00040C  03C0E821   ADDU SP, S8, ZERO
9D000410  8FBF0024   LW RA, 36(SP)
9D000414  8FBE0020   LW S8, 32(SP)
9D000418  27BD0028   ADDIU SP, SP, 40
9D00041C  03E00008   JR RA
9D000420  00000000   NOP
464:                 
465:                 /****************************************************************************
466:                   Section:
467:                 	Connection Management Functions
468:                   ***************************************************************************/
469:                 
470:                 
471:                 /*****************************************************************************
472:                   Function:
473:                 	TCP_SOCKET TCPOpen(DWORD dwRemoteHost, BYTE vRemoteHostType, WORD wPort, BYTE vSocketPurpose)
474:                     
475:                   Summary:
476:                     Opens a TCP socket for listening or as a client.
477:                 
478:                   Description:
479:                     Provides a unified method for opening TCP sockets. This function can
480:                     open both client and server sockets. For client sockets, it can accept
481:                     a host name string to query in DNS, an IP address as a string, an IP
482:                     address in binary form, or a previously resolved NODE_INFO structure
483:                     containing the remote IP address and associated MAC address. When a
484:                     host name or IP address only is provided, the TCP module will
485:                     internally perform the necessary DNS and/or ARP resolution steps before
486:                     reporting that the TCP socket is connected (via a call to
487:                     TCPISConnected returning TRUE). Server sockets ignore this destination
488:                     parameter and listen only on the indicated port.
489:                     
490:                     The vSocketPurpose field allows sockets to be opened with varying
491:                     buffer size parameters and memory storage mediums. This field
492:                     corresponds to pre-defined sockets allocated in the
493:                     TCPSocketInitializer[] array in TCPIPConfig.h. The TCPIPConfig.h file
494:                     can be edited using the TCP/IP Configuration Wizard.
495:                     
496:                     Sockets are statically allocated on boot, but can be claimed with this
497:                     \function and freed using TCPDisconnect or TCPClose (for client
498:                     sockets). Server sockets can be freed using TCPClose only (calls to
499:                     TCPDisconnect will return server sockets to the listening state,
500:                     allowing reuse).
501:                 
502:                   Conditions:
503:                     TCP is initialized.
504:                 
505:                   Input:
506:                     dwRemoteHost -     For client sockets only. Provide a pointer to a
507:                                        null\-terminated string of the remote host name (ex\:
508:                                        "www.microchip.com" or "192.168.1.123"), a literal
509:                                        destination IP address (ex\: 0x7B01A8C0 or an IP_ADDR
510:                                        data type), or a pointer to a NODE_INFO structure
511:                                        with the remote IP address and remote node or gateway
512:                                        MAC address specified. If a string is provided, note
513:                                        that it must be statically allocated in memory and
514:                                        cannot be modified or deallocated until
515:                                        TCPIsConnected returns TRUE.<p />This parameter is
516:                                        ignored for server sockets.
517:                     vRemoteHostType -  Any one of the following flags to identify the
518:                                        meaning of the dwRemoteHost parameter\:
519:                                        * TCP_OPEN_SERVER &#45; Open a server socket and
520:                                          ignore the dwRemoteHost parameter.
521:                                        * TCP_OPEN_RAM_HOST &#45; Open a client socket and
522:                                          connect it to a remote host who's name is stored as a
523:                                          null terminated string in a RAM array. Ex\:
524:                                          "www.microchip.com" or "192.168.0.123" (BYTE&#42;
525:                                          type)
526:                                        * TCP_OPEN_ROM_HOST &#45; Open a client socket and
527:                                          connect it to a remote host who's name is stored as a
528:                                          null terminated string in a literal string or ROM
529:                                          array. Ex\: "www.microchip.com" or "192.168.0.123"
530:                                          (ROM BYTE&#42; type)
531:                                        * TCP_OPEN_IP_ADDRESS &#45; Open a client socket and
532:                                          connect it to a remote IP address. Ex\: 0x7B01A8C0
533:                                          for 192.168.1.123 (DWORD type). Note that the byte
534:                                          ordering is big endian.
535:                                        * TCP_OPEN_NODE_INFO &#45; Open a client socket and
536:                                          connect it to a remote IP and MAC addresses pair
537:                                          stored in a NODE_INFO structure. dwRemoteHost must be
538:                                          a pointer to the NODE_INFO structure. This option is
539:                                          provided for backwards compatibility with
540:                                          applications built against prior stack versions that
541:                                          only implemented the TCPConnect() function. It can
542:                                          also be used to skip DNS and ARP resolution steps if
543:                                          connecting to a remote node which you've already
544:                                          connected to and have cached addresses for.
545:                     wPort -            TCP port to listen on or connect to\:
546:                                        * Client sockets &#45; the remote TCP port to which a
547:                                          connection should be made. The local port for client
548:                                          sockets will be automatically picked by the TCP
549:                                          module.
550:                                        * Server sockets &#45; the local TCP port on which to
551:                                          listen for connections.
552:                     vSocketPurpose -   Any of the TCP_PURPOSE_* constants defined in
553:                                        TCPIPConfig.h or the TCPIPConfig utility (see
554:                                        TCPSocketInitializer[] array).
555:                 
556:                   Return Values:
557:                     INVALID_SOCKET -  No sockets of the specified type were available to be
558:                                       opened.
559:                     Otherwise -       A TCP_SOCKET handle. Save this handle and use it when
560:                                       calling all other TCP APIs.
561:                 
562:                   Remarks:
563:                     This function replaces the old TCPConnect and TCPListen functions.
564:                     
565:                     If TCP_OPEN_RAM_HOST or TCP_OPEN_ROM_HOST are used for the destination
566:                     type, the DNS client module must also be enabled (STACK_USE_DNS must be
567:                     defined in TCPIPConfig.h).
568:                 
569:                   Example:
570:                     \ \ 
571:                     <code>
572:                     // Open a server socket
573:                     skt = TCPOpen(NULL, TCP_OPEN_SERVER, HTTP_PORT, TCP_PURPOSE_HTTP_SERVER);
574:                     
575:                     // Open a client socket to www.microchip.com
576:                     // The double cast here prevents compiler warnings
577:                     skt = TCPOpen((DWORD)(PTR_BASE)"www.microchip.com",
578:                                     TCP_OPEN_ROM_HOST, 80, TCP_PURPOSE_DEFAULT);
579:                     
580:                     // Reopen a client socket without repeating DNS or ARP
581:                     SOCKET_INFO cache = TCPGetSocketInfo(skt);  // Call with the old socket
582:                     skt = TCPOpen((DWORD)(PTR_BASE)&amp;cache.remote, TCP_OPEN_NODE_INFO,
583:                                     cache.remotePort.Val, TCP_PURPOSE_DEFAULT);
584:                     </code>                                                    
585:                   *****************************************************************************/
586:                 TCP_SOCKET TCPOpen(DWORD dwRemoteHost, BYTE vRemoteHostType, WORD wPort, BYTE vSocketPurpose)
587:                 {
9D000424  27BDFFD8   ADDIU SP, SP, -40
9D000428  AFBF0024   SW RA, 36(SP)
9D00042C  AFBE0020   SW S8, 32(SP)
9D000430  AFB0001C   SW S0, 28(SP)
9D000434  03A0F021   ADDU S8, SP, ZERO
9D000438  AFC40028   SW A0, 40(S8)
9D00043C  00A02021   ADDU A0, A1, ZERO
9D000440  00C01821   ADDU V1, A2, ZERO
9D000444  00E01021   ADDU V0, A3, ZERO
9D000448  A3C4002C   SB A0, 44(S8)
9D00044C  A7C30030   SH V1, 48(S8)
9D000450  A3C20034   SB V0, 52(S8)
588:                 	TCP_SOCKET hTCP;
589:                 
590:                 	// Find an available socket that matches the specified socket type
591:                 	for(hTCP = 0; hTCP < TCP_SOCKET_COUNT; hTCP++)
9D000454  A3C00010   SB ZERO, 16(S8)
9D000458  0B40021D   J 0x9D000874
9D00045C  00000000   NOP
9D000868  93C20010   LBU V0, 16(S8)
9D00086C  24420001   ADDIU V0, V0, 1
9D000870  A3C20010   SB V0, 16(S8)
9D000874  93C20010   LBU V0, 16(S8)
9D000878  2C420009   SLTIU V0, V0, 9
9D00087C  1440FEF8   BNE V0, ZERO, 0x9D000460
9D000880  00000000   NOP
592:                 	{
593:                 		SyncTCBStub(hTCP);
9D000460  93C20010   LBU V0, 16(S8)
9D000464  A3828027   SB V0, -32729(GP)
594:                 
595:                 		// Sockets that are in use will be in a non-closed state
596:                 		if(MyTCBStub.smState != TCP_CLOSED)
9D000468  93828027   LBU V0, -32729(GP)
9D00046C  00402021   ADDU A0, V0, ZERO
9D000470  3C02A000   LUI V0, -24576
9D000474  24432CDC   ADDIU V1, V0, 11484
9D000478  24020030   ADDIU V0, ZERO, 48
9D00047C  70821002   MUL V0, A0, V0
9D000480  00621021   ADDU V0, V1, V0
9D000484  8C430024   LW V1, 36(V0)
9D000488  2402000D   ADDIU V0, ZERO, 13
9D00048C  146200F2   BNE V1, V0, 0x9D000858
9D000490  00000000   NOP
597:                 			continue;
9D000858  00000000   NOP
9D00085C  0B40021A   J 0x9D000868
9D000860  00000000   NOP
598:                 
599:                 		SyncTCB();
9D000494  0F400008   JAL SyncTCB
9D000498  00000000   NOP
600:                 
601:                 		// See if this socket matches the desired type
602:                 		if(MyTCB.vSocketPurpose != vSocketPurpose)
9D00049C  3C02A000   LUI V0, -24576
9D0004A0  24422E8C   ADDIU V0, V0, 11916
9D0004A4  9042002B   LBU V0, 43(V0)
9D0004A8  93C30034   LBU V1, 52(S8)
9D0004AC  146200ED   BNE V1, V0, 0x9D000864
9D0004B0  00000000   NOP
603:                 			continue;
9D000864  00000000   NOP
604:                 
605:                 		// Start out assuming worst case Maximum Segment Size (changes when MSS 
606:                 		// option is received from remote node)
607:                 		MyTCB.wRemoteMSS = 536;
9D0004B4  3C02A000   LUI V0, -24576
9D0004B8  24422E8C   ADDIU V0, V0, 11916
9D0004BC  24030218   ADDIU V1, ZERO, 536
9D0004C0  A4430028   SH V1, 40(V0)
608:                 
609:                 		// See if this is a server socket
610:                 		if(vRemoteHostType == TCP_OPEN_SERVER)
9D0004C4  93C2002C   LBU V0, 44(S8)
9D0004C8  14400024   BNE V0, ZERO, 0x9D00055C
9D0004CC  00000000   NOP
611:                 		{
612:                 			MyTCB.localPort.Val = wPort;
9D0004D0  3C02A000   LUI V0, -24576
9D0004D4  24422E8C   ADDIU V0, V0, 11916
9D0004D8  97C30030   LHU V1, 48(S8)
9D0004DC  A4430012   SH V1, 18(V0)
613:                 			MyTCBStub.Flags.bServer = TRUE;
9D0004E0  93828027   LBU V0, -32729(GP)
9D0004E4  00402021   ADDU A0, V0, ZERO
9D0004E8  3C02A000   LUI V0, -24576
9D0004EC  24030030   ADDIU V1, ZERO, 48
9D0004F0  70831802   MUL V1, A0, V1
9D0004F4  24422CDC   ADDIU V0, V0, 11484
9D0004F8  00621821   ADDU V1, V1, V0
9D0004FC  8C620028   LW V0, 40(V1)
9D000500  24040001   ADDIU A0, ZERO, 1
9D000504  7C8218C4   INS V0, A0, 3, 1
9D000508  AC620028   SW V0, 40(V1)
614:                 			MyTCBStub.smState = TCP_LISTEN;
9D00050C  93828027   LBU V0, -32729(GP)
9D000510  00402021   ADDU A0, V0, ZERO
9D000514  3C02A000   LUI V0, -24576
9D000518  24432CDC   ADDIU V1, V0, 11484
9D00051C  24020030   ADDIU V0, ZERO, 48
9D000520  70821002   MUL V0, A0, V0
9D000524  00621021   ADDU V0, V1, V0
9D000528  24030004   ADDIU V1, ZERO, 4
9D00052C  AC430024   SW V1, 36(V0)
615:                 			MyTCBStub.remoteHash.Val = wPort;
9D000530  93828027   LBU V0, -32729(GP)
9D000534  00402021   ADDU A0, V0, ZERO
9D000538  3C02A000   LUI V0, -24576
9D00053C  24030030   ADDIU V1, ZERO, 48
9D000540  70831802   MUL V1, A0, V1
9D000544  24422CDC   ADDIU V0, V0, 11484
9D000548  00621021   ADDU V0, V1, V0
9D00054C  97C30030   LHU V1, 48(S8)
9D000550  A443002A   SH V1, 42(V0)
9D000554  0B400213   J 0x9D00084C
9D000558  00000000   NOP
616:                 			#if defined(STACK_USE_SSL_SERVER)
617:                 			MyTCB.localSSLPort.Val = 0;
618:                 			#endif
619:                 		}
620:                 		// Handle all the client mode socket types
621:                 		else
622:                 		{
623:                 			#if defined(STACK_CLIENT_MODE)
624:                 			{
625:                 				// Each new socket that is opened by this node, gets the 
626:                 				// next sequential local port number.
627:                 				if(NextPort < LOCAL_PORT_START_NUMBER || NextPort > LOCAL_PORT_END_NUMBER)
9D00055C  3C02A000   LUI V0, -24576
9D000560  94420224   LHU V0, 548(V0)
9D000564  2C420400   SLTIU V0, V0, 1024
9D000568  14400006   BNE V0, ZERO, 0x9D000584
9D00056C  00000000   NOP
9D000570  3C02A000   LUI V0, -24576
9D000574  94420224   LHU V0, 548(V0)
9D000578  2C421389   SLTIU V0, V0, 5001
9D00057C  14400004   BNE V0, ZERO, 0x9D000590
9D000580  00000000   NOP
628:                 					NextPort = LOCAL_PORT_START_NUMBER;
9D000584  3C02A000   LUI V0, -24576
9D000588  24030400   ADDIU V1, ZERO, 1024
9D00058C  A4430224   SH V1, 548(V0)
629:                 				
630:                 				// Set the non-zero TCB fields
631:                 				MyTCB.localPort.Val = NextPort++;
9D000590  3C02A000   LUI V0, -24576
9D000594  94420224   LHU V0, 548(V0)
9D000598  3C03A000   LUI V1, -24576
9D00059C  24632E8C   ADDIU V1, V1, 11916
9D0005A0  A4620012   SH V0, 18(V1)
9D0005A4  24420001   ADDIU V0, V0, 1
9D0005A8  3043FFFF   ANDI V1, V0, -1
9D0005AC  3C02A000   LUI V0, -24576
9D0005B0  A4430224   SH V1, 548(V0)
632:                 				MyTCB.remotePort.Val = wPort;
9D0005B4  3C02A000   LUI V0, -24576
9D0005B8  24422E8C   ADDIU V0, V0, 11916
9D0005BC  97C30030   LHU V1, 48(S8)
9D0005C0  A4430010   SH V1, 16(V0)
633:                 	
634:                 				// Flag to start the DNS, ARP, SYN processes
635:                 				MyTCBStub.eventTime = TickGet();
9D0005C4  93828027   LBU V0, -32729(GP)
9D0005C8  00408021   ADDU S0, V0, ZERO
9D0005CC  0F40CDD6   JAL TickGet
9D0005D0  00000000   NOP
9D0005D4  00401821   ADDU V1, V0, ZERO
9D0005D8  3C02A000   LUI V0, -24576
9D0005DC  24442CDC   ADDIU A0, V0, 11484
9D0005E0  24020030   ADDIU V0, ZERO, 48
9D0005E4  72021002   MUL V0, S0, V0
9D0005E8  00821021   ADDU V0, A0, V0
9D0005EC  AC43001C   SW V1, 28(V0)
636:                 				MyTCBStub.Flags.bTimerEnabled = 1;
9D0005F0  93828027   LBU V0, -32729(GP)
9D0005F4  00402021   ADDU A0, V0, ZERO
9D0005F8  3C02A000   LUI V0, -24576
9D0005FC  24030030   ADDIU V1, ZERO, 48
9D000600  70831802   MUL V1, A0, V1
9D000604  24422CDC   ADDIU V0, V0, 11484
9D000608  00621821   ADDU V1, V1, V0
9D00060C  8C620028   LW V0, 40(V1)
9D000610  24040001   ADDIU A0, ZERO, 1
9D000614  7C822104   INS V0, A0, 4, 1
9D000618  AC620028   SW V0, 40(V1)
637:                 	
638:                 				switch(vRemoteHostType)
9D00061C  93C2002C   LBU V0, 44(S8)
9D000620  24030003   ADDIU V1, ZERO, 3
9D000624  10430025   BEQ V0, V1, 0x9D0006BC
9D000628  00000000   NOP
9D00062C  28430004   SLTI V1, V0, 4
9D000630  10600006   BEQ V1, ZERO, 0x9D00064C
9D000634  00000000   NOP
9D000638  28420001   SLTI V0, V0, 1
9D00063C  14400083   BNE V0, ZERO, 0x9D00084C
9D000640  00000000   NOP
9D000644  0B400198   J 0x9D000660
9D000648  00000000   NOP
9D00064C  24030004   ADDIU V1, ZERO, 4
9D000650  10430048   BEQ V0, V1, 0x9D000774
9D000654  00000000   NOP
9D000658  0B400213   J 0x9D00084C
9D00065C  00000000   NOP
639:                 				{
640:                 					#if defined(STACK_USE_DNS)
641:                 					case TCP_OPEN_RAM_HOST:
642:                 					case TCP_OPEN_ROM_HOST:
643:                 						MyTCB.remote.dwRemoteHost = dwRemoteHost;
9D000660  8FC30028   LW V1, 40(S8)
9D000664  3C02A000   LUI V0, -24576
9D000668  24422E8C   ADDIU V0, V0, 11916
9D00066C  AC430018   SW V1, 24(V0)
644:                 						MyTCB.flags.bRemoteHostIsROM = (vRemoteHostType == TCP_OPEN_ROM_HOST);
9D000670  93C2002C   LBU V0, 44(S8)
9D000674  38420002   XORI V0, V0, 2
9D000678  2C420001   SLTIU V0, V0, 1
9D00067C  304400FF   ANDI A0, V0, 255
9D000680  3C02A000   LUI V0, -24576
9D000684  24432E8C   ADDIU V1, V0, 11916
9D000688  8C620024   LW V0, 36(V1)
9D00068C  7C829484   INS V0, A0, 18, 1
9D000690  AC620024   SW V0, 36(V1)
645:                 						MyTCBStub.smState = TCP_GET_DNS_MODULE;
9D000694  93828027   LBU V0, -32729(GP)
9D000698  00402021   ADDU A0, V0, ZERO
9D00069C  3C02A000   LUI V0, -24576
9D0006A0  24432CDC   ADDIU V1, V0, 11484
9D0006A4  24020030   ADDIU V0, ZERO, 48
9D0006A8  70821002   MUL V0, A0, V0
9D0006AC  00621021   ADDU V0, V1, V0
9D0006B0  AC400024   SW ZERO, 36(V0)
646:                 						break;
9D0006B4  0B400213   J 0x9D00084C
9D0006B8  00000000   NOP
647:                 					#endif
648:                 		
649:                 					case TCP_OPEN_IP_ADDRESS:
650:                 						// dwRemoteHost is a literal IP address.  This 
651:                 						// doesn't need DNS and can skip directly to the 
652:                 						// Gateway ARPing step.
653:                 						MyTCBStub.remoteHash.Val = (((DWORD_VAL*)&dwRemoteHost)->w[1]+((DWORD_VAL*)&dwRemoteHost)->w[0] + wPort) ^ MyTCB.localPort.Val;
9D0006BC  93828027   LBU V0, -32729(GP)
9D0006C0  00402821   ADDU A1, V0, ZERO
9D0006C4  27C20028   ADDIU V0, S8, 40
9D0006C8  94430002   LHU V1, 2(V0)
9D0006CC  27C20028   ADDIU V0, S8, 40
9D0006D0  94420000   LHU V0, 0(V0)
9D0006D4  00621021   ADDU V0, V1, V0
9D0006D8  3043FFFF   ANDI V1, V0, -1
9D0006DC  97C20030   LHU V0, 48(S8)
9D0006E0  00621021   ADDU V0, V1, V0
9D0006E4  3042FFFF   ANDI V0, V0, -1
9D0006E8  7C021E20   SEH V1, V0
9D0006EC  3C02A000   LUI V0, -24576
9D0006F0  24422E8C   ADDIU V0, V0, 11916
9D0006F4  94420012   LHU V0, 18(V0)
9D0006F8  7C021620   SEH V0, V0
9D0006FC  00621026   XOR V0, V1, V0
9D000700  7C021620   SEH V0, V0
9D000704  3043FFFF   ANDI V1, V0, -1
9D000708  3C02A000   LUI V0, -24576
9D00070C  24040030   ADDIU A0, ZERO, 48
9D000710  70A42002   MUL A0, A1, A0
9D000714  24422CDC   ADDIU V0, V0, 11484
9D000718  00821021   ADDU V0, A0, V0
9D00071C  A443002A   SH V1, 42(V0)
654:                 						MyTCB.remote.niRemoteMACIP.IPAddr.Val = dwRemoteHost;
9D000720  8FC30028   LW V1, 40(S8)
9D000724  3C02A000   LUI V0, -24576
9D000728  24422E8C   ADDIU V0, V0, 11916
9D00072C  AC430018   SW V1, 24(V0)
655:                 						MyTCB.retryCount = 0;
9D000730  3C02A000   LUI V0, -24576
9D000734  24422E8C   ADDIU V0, V0, 11916
9D000738  A040002A   SB ZERO, 42(V0)
656:                 						MyTCB.retryInterval = (TICK_SECOND/4)/256;
9D00073C  3C02A000   LUI V0, -24576
9D000740  24030098   ADDIU V1, ZERO, 152
9D000744  AC432E8C   SW V1, 11916(V0)
657:                 						MyTCBStub.smState = TCP_GATEWAY_SEND_ARP;
9D000748  93828027   LBU V0, -32729(GP)
9D00074C  00402021   ADDU A0, V0, ZERO
9D000750  3C02A000   LUI V0, -24576
9D000754  24432CDC   ADDIU V1, V0, 11484
9D000758  24020030   ADDIU V0, ZERO, 48
9D00075C  70821002   MUL V0, A0, V0
9D000760  00621021   ADDU V0, V1, V0
9D000764  24030002   ADDIU V1, ZERO, 2
9D000768  AC430024   SW V1, 36(V0)
658:                 						break;
9D00076C  0B400213   J 0x9D00084C
9D000770  00000000   NOP
659:                 		
660:                 					case TCP_OPEN_NODE_INFO:
661:                 						MyTCBStub.remoteHash.Val = (((NODE_INFO*)(PTR_BASE)dwRemoteHost)->IPAddr.w[1]+((NODE_INFO*)(PTR_BASE)dwRemoteHost)->IPAddr.w[0] + wPort) ^ MyTCB.localPort.Val;
9D000774  93828027   LBU V0, -32729(GP)
9D000778  00402821   ADDU A1, V0, ZERO
9D00077C  8FC20028   LW V0, 40(S8)
9D000780  90430002   LBU V1, 2(V0)
9D000784  90420003   LBU V0, 3(V0)
9D000788  00021200   SLL V0, V0, 8
9D00078C  00431025   OR V0, V0, V1
9D000790  3043FFFF   ANDI V1, V0, -1
9D000794  8FC20028   LW V0, 40(S8)
9D000798  90440000   LBU A0, 0(V0)
9D00079C  90420001   LBU V0, 1(V0)
9D0007A0  00021200   SLL V0, V0, 8
9D0007A4  00441025   OR V0, V0, A0
9D0007A8  3042FFFF   ANDI V0, V0, -1
9D0007AC  00621021   ADDU V0, V1, V0
9D0007B0  3043FFFF   ANDI V1, V0, -1
9D0007B4  97C20030   LHU V0, 48(S8)
9D0007B8  00621021   ADDU V0, V1, V0
9D0007BC  3042FFFF   ANDI V0, V0, -1
9D0007C0  7C021E20   SEH V1, V0
9D0007C4  3C02A000   LUI V0, -24576
9D0007C8  24422E8C   ADDIU V0, V0, 11916
9D0007CC  94420012   LHU V0, 18(V0)
9D0007D0  7C021620   SEH V0, V0
9D0007D4  00621026   XOR V0, V1, V0
9D0007D8  7C021620   SEH V0, V0
9D0007DC  3043FFFF   ANDI V1, V0, -1
9D0007E0  3C02A000   LUI V0, -24576
9D0007E4  24040030   ADDIU A0, ZERO, 48
9D0007E8  70A42002   MUL A0, A1, A0
9D0007EC  24422CDC   ADDIU V0, V0, 11484
9D0007F0  00821021   ADDU V0, A0, V0
9D0007F4  A443002A   SH V1, 42(V0)
662:                 						memcpy((void*)(BYTE*)&MyTCB.remote, (void*)(BYTE*)(PTR_BASE)dwRemoteHost, sizeof(NODE_INFO));
9D0007F8  8FC20028   LW V0, 40(S8)
9D0007FC  3C03A000   LUI V1, -24576
9D000800  24642EA4   ADDIU A0, V1, 11940
9D000804  00402821   ADDU A1, V0, ZERO
9D000808  2406000A   ADDIU A2, ZERO, 10
9D00080C  0F40D298   JAL 0x9D034A60
9D000810  00000000   NOP
663:                 						MyTCBStub.smState = TCP_SYN_SENT;
9D000814  93828027   LBU V0, -32729(GP)
9D000818  00402021   ADDU A0, V0, ZERO
9D00081C  3C02A000   LUI V0, -24576
9D000820  24432CDC   ADDIU V1, V0, 11484
9D000824  24020030   ADDIU V0, ZERO, 48
9D000828  70821002   MUL V0, A0, V0
9D00082C  00621021   ADDU V0, V1, V0
9D000830  24030005   ADDIU V1, ZERO, 5
9D000834  AC430024   SW V1, 36(V0)
664:                 						SendTCP(SYN, SENDTCP_RESET_TIMERS);
9D000838  24040002   ADDIU A0, ZERO, 2
9D00083C  24050001   ADDIU A1, ZERO, 1
9D000840  0F400F8B   JAL SendTCP
9D000844  00000000   NOP
665:                 						break;
9D000848  00000000   NOP
666:                 				}
667:                 			}		
668:                 			#else
669:                 			{
670:                 				return INVALID_SOCKET;
671:                 			}	
672:                 			#endif
673:                 		}
674:                 		
675:                 		return hTCP;		
9D00084C  93C20010   LBU V0, 16(S8)
9D000850  0B400222   J 0x9D000888
9D000854  00000000   NOP
676:                 	}
677:                 
678:                 	// If there is no socket available, return error.
679:                 	return INVALID_SOCKET;
9D000884  240200FE   ADDIU V0, ZERO, 254
680:                 }
9D000888  03C0E821   ADDU SP, S8, ZERO
9D00088C  8FBF0024   LW RA, 36(SP)
9D000890  8FBE0020   LW S8, 32(SP)
9D000894  8FB0001C   LW S0, 28(SP)
9D000898  27BD0028   ADDIU SP, SP, 40
9D00089C  03E00008   JR RA
9D0008A0  00000000   NOP
681:                 
682:                 
683:                 /*****************************************************************************
684:                   Function:
685:                 	BOOL TCPWasReset(TCP_SOCKET hTCP)
686:                 
687:                   Summary:
688:                 	Self-clearing semaphore inidicating socket reset.
689:                 
690:                   Description:
691:                 	This function is a self-clearing semaphore indicating whether or not
692:                 	a socket has been disconnected since the previous call.  This function
693:                 	works for all possible disconnections: a call to TCPDisconnect, a FIN 
694:                 	from the remote node, or an acknowledgement timeout caused by the loss
695:                 	of a network link.  It also returns TRUE after the first call to TCPInit.
696:                 	Applications should use this function to reset their state machines.
697:                 	
698:                 	This function was added due to the possibility of an error when relying
699:                 	on TCPIsConnected returing FALSE to check for a condition requiring a
700:                 	state machine reset.  If a socket is closed (due to a FIN ACK) and then
701:                 	immediately reopened (due to a the arrival of a new SYN) in the same
702:                 	cycle of the stack, calls to TCPIsConnected by the application will 
703:                 	never return FALSE even though the socket has been disconnected.  This 
704:                 	can cause errors for protocols such as HTTP in which a client will 
705:                 	immediately open a new connection upon closing of a prior one.  Relying
706:                 	on this function instead allows applications to trap those conditions 
707:                 	and properly reset their internal state for the new connection.
708:                 
709:                   Precondition:
710:                 	TCP is initialized.
711:                 
712:                   Parameters:
713:                 	hTCP - The socket to check.
714:                 
715:                   Return Values:
716:                   	TRUE - The socket has been disconnected since the previous call.
717:                   	FALSE - The socket has not been disconnected since the previous call.
718:                   ***************************************************************************/
719:                 BOOL TCPWasReset(TCP_SOCKET hTCP)
720:                 {
9D0008A4  27BDFFF8   ADDIU SP, SP, -8
9D0008A8  AFBE0004   SW S8, 4(SP)
9D0008AC  03A0F021   ADDU S8, SP, ZERO
9D0008B0  00801021   ADDU V0, A0, ZERO
9D0008B4  A3C20008   SB V0, 8(S8)
721:                 	if(hTCP >= TCP_SOCKET_COUNT)
9D0008B8  93C20008   LBU V0, 8(S8)
9D0008BC  2C420009   SLTIU V0, V0, 9
9D0008C0  14400004   BNE V0, ZERO, 0x9D0008D4
9D0008C4  00000000   NOP
722:                     {
723:                         return TRUE;
9D0008C8  24020001   ADDIU V0, ZERO, 1
9D0008CC  0B400251   J 0x9D000944
9D0008D0  00000000   NOP
724:                     }
725:                     
726:                 	SyncTCBStub(hTCP);
9D0008D4  93C20008   LBU V0, 8(S8)
9D0008D8  A3828027   SB V0, -32729(GP)
727:                 	
728:                 	if(MyTCBStub.Flags.bSocketReset)
9D0008DC  93828027   LBU V0, -32729(GP)
9D0008E0  00402021   ADDU A0, V0, ZERO
9D0008E4  3C02A000   LUI V0, -24576
9D0008E8  24030030   ADDIU V1, ZERO, 48
9D0008EC  70831802   MUL V1, A0, V1
9D0008F0  24422CDC   ADDIU V0, V0, 11484
9D0008F4  00621021   ADDU V0, V1, V0
9D0008F8  8C420028   LW V0, 40(V0)
9D0008FC  7C420300   EXT V0, V0, 12, 1
9D000900  304200FF   ANDI V0, V0, 255
9D000904  1040000E   BEQ V0, ZERO, 0x9D000940
9D000908  00000000   NOP
729:                 	{
730:                 		MyTCBStub.Flags.bSocketReset = 0;
9D00090C  93828027   LBU V0, -32729(GP)
9D000910  00402021   ADDU A0, V0, ZERO
9D000914  3C02A000   LUI V0, -24576
9D000918  24030030   ADDIU V1, ZERO, 48
9D00091C  70831802   MUL V1, A0, V1
9D000920  24422CDC   ADDIU V0, V0, 11484
9D000924  00621821   ADDU V1, V1, V0
9D000928  8C620028   LW V0, 40(V1)
9D00092C  7C026304   INS V0, ZERO, 12, 1
9D000930  AC620028   SW V0, 40(V1)
731:                 		return TRUE;
9D000934  24020001   ADDIU V0, ZERO, 1
9D000938  0B400251   J 0x9D000944
9D00093C  00000000   NOP
732:                 	}	
733:                 	
734:                 	return FALSE;
9D000940  00001021   ADDU V0, ZERO, ZERO
735:                 }
9D000944  03C0E821   ADDU SP, S8, ZERO
9D000948  8FBE0004   LW S8, 4(SP)
9D00094C  27BD0008   ADDIU SP, SP, 8
9D000950  03E00008   JR RA
9D000954  00000000   NOP
736:                 
737:                 
738:                 /*****************************************************************************
739:                   Function:
740:                 	BOOL TCPIsConnected(TCP_SOCKET hTCP)
741:                 
742:                   Summary:
743:                 	Determines if a socket has an established connection.
744:                 
745:                   Description:
746:                 	This function determines if a socket has an established connection to 
747:                 	a remote node.  Call this function after calling TCPOpen to determine 
748:                 	when the connection is set up and ready for use.  This function was 
749:                 	historically used to check for disconnections, but TCPWasReset is now a
750:                 	more appropriate solution. 
751:                 
752:                   Precondition:
753:                 	TCP is initialized.
754:                 
755:                   Parameters:
756:                 	hTCP - The socket to check.
757:                 
758:                   Return Values:
759:                   	TRUE - The socket has an established connection to a remote node.
760:                   	FALSE - The socket is not currently connected.
761:                 
762:                   Remarks:
763:                 	A socket is said to be connected only if it is in the TCP_ESTABLISHED
764:                 	state.  Sockets in the process of opening or closing will return FALSE.
765:                   ***************************************************************************/
766:                 BOOL TCPIsConnected(TCP_SOCKET hTCP)
767:                 {
9D000958  27BDFFF8   ADDIU SP, SP, -8
9D00095C  AFBE0004   SW S8, 4(SP)
9D000960  03A0F021   ADDU S8, SP, ZERO
9D000964  00801021   ADDU V0, A0, ZERO
9D000968  A3C20008   SB V0, 8(S8)
768:                 	if(hTCP >= TCP_SOCKET_COUNT)
9D00096C  93C20008   LBU V0, 8(S8)
9D000970  2C420009   SLTIU V0, V0, 9
9D000974  14400004   BNE V0, ZERO, 0x9D000988
9D000978  00000000   NOP
769:                     {
770:                         return FALSE;
9D00097C  00001021   ADDU V0, ZERO, ZERO
9D000980  0B40026E   J 0x9D0009B8
9D000984  00000000   NOP
771:                     }
772:                     
773:                 	SyncTCBStub(hTCP);
9D000988  93C20008   LBU V0, 8(S8)
9D00098C  A3828027   SB V0, -32729(GP)
774:                 	return (MyTCBStub.smState == TCP_ESTABLISHED);
9D000990  93828027   LBU V0, -32729(GP)
9D000994  00402021   ADDU A0, V0, ZERO
9D000998  3C02A000   LUI V0, -24576
9D00099C  24432CDC   ADDIU V1, V0, 11484
9D0009A0  24020030   ADDIU V0, ZERO, 48
9D0009A4  70821002   MUL V0, A0, V0
9D0009A8  00621021   ADDU V0, V1, V0
9D0009AC  8C420024   LW V0, 36(V0)
9D0009B0  38420007   XORI V0, V0, 7
9D0009B4  2C420001   SLTIU V0, V0, 1
775:                 }
9D0009B8  03C0E821   ADDU SP, S8, ZERO
9D0009BC  8FBE0004   LW S8, 4(SP)
9D0009C0  27BD0008   ADDIU SP, SP, 8
9D0009C4  03E00008   JR RA
9D0009C8  00000000   NOP
776:                 
777:                 
778:                 /*****************************************************************************
779:                   Function:
780:                 	void TCPDisconnect(TCP_SOCKET hTCP)
781:                 
782:                   Summary:
783:                 	Disconnects an open socket.
784:                 
785:                   Description:
786:                 	This function closes a connection to a remote node by sending a FIN (if 
787:                 	currently connected).
788:                 	
789:                 	The function can be called a second time to force a socket closed by 
790:                 	sending a RST packet.  This is useful when the application knows that 
791:                 	the remote node will not send an ACK (if it has crashed or lost its link),
792:                 	or when the application needs to reuse the socket immediately regardless
793:                 	of whether or not the remote node would like to transmit more data before
794:                 	closing.
795:                 	
796:                 	For client mode sockets, upon return, the hTCP handle is relinquished to 
797:                 	the TCP/IP stack and must no longer be used by the application (except for 
798:                 	an immediate subsequent call to TCPDisconnect() to force a RST 
799:                 	transmission, if needed).  
800:                 	
801:                 	For server mode sockets, upon return, the hTCP handle is NOT relinquished 
802:                 	to the TCP/IP stack.  After closing, the socket returns to the listening 
803:                 	state allowing future connection requests to be serviced.  This leaves the 
804:                 	hTCP handle in a valid state and must be retained for future operations on 
805:                 	the socket.  If you want to close the server and relinquish the socket back 
806:                 	to the TCP/IP stack, call the TCPClose() API instead of TCPDisconnect().
807:                 
808:                   Precondition:
809:                 	None
810:                 
811:                   Parameters:
812:                 	hTCP - Handle of the socket to disconnect.
813:                 
814:                   Returns:
815:                 	None
816:                 
817:                   Remarks:
818:                 	If the socket is using SSL, a CLOSE_NOTIFY record will be transmitted
819:                 	first to allow the SSL session to be resumed at a later time.
820:                   ***************************************************************************/
821:                 void TCPDisconnect(TCP_SOCKET hTCP)
822:                 {
9D0009CC  27BDFFE8   ADDIU SP, SP, -24
9D0009D0  AFBF0014   SW RA, 20(SP)
9D0009D4  AFBE0010   SW S8, 16(SP)
9D0009D8  03A0F021   ADDU S8, SP, ZERO
9D0009DC  00801021   ADDU V0, A0, ZERO
9D0009E0  A3C20018   SB V0, 24(S8)
823:                 	if(hTCP >= TCP_SOCKET_COUNT)
9D0009E4  93C20018   LBU V0, 24(S8)
9D0009E8  2C420009   SLTIU V0, V0, 9
9D0009EC  1040009A   BEQ V0, ZERO, 0x9D000C58
9D0009F0  00000000   NOP
824:                     {
825:                         return;
9D000C58  00000000   NOP
826:                     }
827:                     
828:                 	SyncTCBStub(hTCP);
9D0009F4  93C20018   LBU V0, 24(S8)
9D0009F8  A3828027   SB V0, -32729(GP)
829:                 
830:                 	// Delete all data in the RX FIFO
831:                 	// In this stack's API, the application TCP handle is 
832:                 	// immediately invalid after calling this function, so there 
833:                 	// is no longer any way to receive data from the TCP RX FIFO, 
834:                 	// even though the data is still there.  Leaving the data there 
835:                 	// could interfere with the remote node sending us a FIN if our
836:                 	// RX window is zero
837:                 	MyTCBStub.rxTail = MyTCBStub.rxHead;
9D0009FC  93828027   LBU V0, -32729(GP)
9D000A00  00402821   ADDU A1, V0, ZERO
9D000A04  93828027   LBU V0, -32729(GP)
9D000A08  00402021   ADDU A0, V0, ZERO
9D000A0C  3C02A000   LUI V0, -24576
9D000A10  24432CDC   ADDIU V1, V0, 11484
9D000A14  24020030   ADDIU V0, ZERO, 48
9D000A18  70821002   MUL V0, A0, V0
9D000A1C  00621021   ADDU V0, V1, V0
9D000A20  8C430014   LW V1, 20(V0)
9D000A24  3C02A000   LUI V0, -24576
9D000A28  24040030   ADDIU A0, ZERO, 48
9D000A2C  70A42002   MUL A0, A1, A0
9D000A30  24422CDC   ADDIU V0, V0, 11484
9D000A34  00821021   ADDU V0, A0, V0
9D000A38  AC430018   SW V1, 24(V0)
838:                 
839:                 	switch(MyTCBStub.smState)
9D000A3C  93828027   LBU V0, -32729(GP)
9D000A40  00402021   ADDU A0, V0, ZERO
9D000A44  3C02A000   LUI V0, -24576
9D000A48  24432CDC   ADDIU V1, V0, 11484
9D000A4C  24020030   ADDIU V0, ZERO, 48
9D000A50  70821002   MUL V0, A0, V0
9D000A54  00621021   ADDU V0, V1, V0
9D000A58  8C420024   LW V0, 36(V0)
9D000A5C  2C43000F   SLTIU V1, V0, 15
9D000A60  10600074   BEQ V1, ZERO, 0x9D000C34
9D000A64  00000000   NOP
9D000A68  00021880   SLL V1, V0, 2
9D000A6C  3C029D00   LUI V0, -25344
9D000A70  24420A84   ADDIU V0, V0, 2692
9D000A74  00621021   ADDU V0, V1, V0
9D000A78  8C420000   LW V0, 0(V0)
9D000A7C  00400008   JR V0
9D000A80  00000000   NOP
840:                 	{
841:                 		#if defined(STACK_CLIENT_MODE) && defined(STACK_USE_DNS)
842:                 		case TCP_DNS_RESOLVE:
843:                 			DNSEndUsage();	// Release the DNS module, since the user is aborting
9D000AC0  0F40A56C   JAL DNSEndUsage
9D000AC4  00000000   NOP
844:                 			CloseSocket();
9D000AC8  0F4014AB   JAL CloseSocket
9D000ACC  00000000   NOP
845:                 			break;
9D000AD0  0B400317   J 0x9D000C5C
9D000AD4  00000000   NOP
846:                 		#endif
847:                 
848:                 		case TCP_GET_DNS_MODULE:
849:                 		case TCP_GATEWAY_SEND_ARP:
850:                 		case TCP_GATEWAY_GET_ARP:
851:                 		case TCP_SYN_SENT:
852:                 			CloseSocket();
9D000AD8  0F4014AB   JAL CloseSocket
9D000ADC  00000000   NOP
853:                 			break;
9D000AE0  0B400317   J 0x9D000C5C
9D000AE4  00000000   NOP
854:                 
855:                 		case TCP_SYN_RECEIVED:
856:                 		case TCP_ESTABLISHED:
857:                 			#if defined(STACK_USE_SSL)
858:                 			// When disconnecting SSL sockets, send a close_notify so we can resume later
859:                 			if(MyTCBStub.sslStubID != SSL_INVALID_ID)
860:                 			{
861:                 				// Flush pending data and send close_notify
862:                 				SSLTxRecord(hTCP, MyTCBStub.sslStubID, SSL_APPLICATION);
863:                 				SSLTxMessage(hTCP, MyTCBStub.sslStubID, SSL_ALERT_CLOSE_NOTIFY);
864:                 			}
865:                 			#endif
866:                 
867:                 			// Send the FIN.  This is done in a loop to ensure that if we have 
868:                 			// more data wating in the TX FIFO than can be sent in a single 
869:                 			// packet (due to the remote Max Segment Size packet size limit), 
870:                 			// we will keep generating more packets until either all data gets 
871:                 			// transmitted or the remote node's receive window fills up.
872:                 			do
873:                 			{
874:                 				SendTCP(FIN | ACK, SENDTCP_RESET_TIMERS);
9D000AE8  24040011   ADDIU A0, ZERO, 17
9D000AEC  24050001   ADDIU A1, ZERO, 1
9D000AF0  0F400F8B   JAL SendTCP
9D000AF4  00000000   NOP
875:                 				if(MyTCB.remoteWindow == 0u)
9D000AF8  3C02A000   LUI V0, -24576
9D000AFC  24422E8C   ADDIU V0, V0, 11916
9D000B00  94420014   LHU V0, 20(V0)
9D000B04  10400010   BEQ V0, ZERO, 0x9D000B48
9D000B08  00000000   NOP
876:                 					break;
9D000B48  00000000   NOP
877:                 			} while(MyTCBStub.txHead != MyTCB.txUnackedTail);
9D000B0C  93828027   LBU V0, -32729(GP)
9D000B10  00402021   ADDU A0, V0, ZERO
9D000B14  3C02A000   LUI V0, -24576
9D000B18  24432CDC   ADDIU V1, V0, 11484
9D000B1C  24020030   ADDIU V0, ZERO, 48
9D000B20  70821002   MUL V0, A0, V0
9D000B24  00621021   ADDU V0, V1, V0
9D000B28  8C43000C   LW V1, 12(V0)
9D000B2C  3C02A000   LUI V0, -24576
9D000B30  24422E8C   ADDIU V0, V0, 11916
9D000B34  8C42000C   LW V0, 12(V0)
9D000B38  1462FFEB   BNE V1, V0, 0x9D000AE8
9D000B3C  00000000   NOP
9D000B40  0B4002D3   J 0x9D000B4C
9D000B44  00000000   NOP
878:                 			
879:                 			MyTCBStub.smState = TCP_FIN_WAIT_1;
9D000B4C  93828027   LBU V0, -32729(GP)
9D000B50  00402021   ADDU A0, V0, ZERO
9D000B54  3C02A000   LUI V0, -24576
9D000B58  24432CDC   ADDIU V1, V0, 11484
9D000B5C  24020030   ADDIU V0, ZERO, 48
9D000B60  70821002   MUL V0, A0, V0
9D000B64  00621021   ADDU V0, V1, V0
9D000B68  24030008   ADDIU V1, ZERO, 8
9D000B6C  AC430024   SW V1, 36(V0)
880:                 			break;
9D000B70  0B400317   J 0x9D000C5C
9D000B74  00000000   NOP
881:                 
882:                 		case TCP_CLOSE_WAIT:
883:                 			// Send the FIN.  This is done in a loop to ensure that if we have 
884:                 			// more data wating in the TX FIFO than can be sent in a single 
885:                 			// packet (due to the remote Max Segment Size packet size limit), 
886:                 			// we will keep generating more packets until either all data gets 
887:                 			// transmitted or the remote node's receive window fills up.
888:                 			do
889:                 			{
890:                 				SendTCP(FIN | ACK, SENDTCP_RESET_TIMERS);
9D000B78  24040011   ADDIU A0, ZERO, 17
9D000B7C  24050001   ADDIU A1, ZERO, 1
9D000B80  0F400F8B   JAL SendTCP
9D000B84  00000000   NOP
891:                 				if(MyTCB.remoteWindow == 0u)
9D000B88  3C02A000   LUI V0, -24576
9D000B8C  24422E8C   ADDIU V0, V0, 11916
9D000B90  94420014   LHU V0, 20(V0)
9D000B94  10400010   BEQ V0, ZERO, 0x9D000BD8
9D000B98  00000000   NOP
892:                 					break;
9D000BD8  00000000   NOP
893:                 			} while(MyTCBStub.txHead != MyTCB.txUnackedTail);
9D000B9C  93828027   LBU V0, -32729(GP)
9D000BA0  00402021   ADDU A0, V0, ZERO
9D000BA4  3C02A000   LUI V0, -24576
9D000BA8  24432CDC   ADDIU V1, V0, 11484
9D000BAC  24020030   ADDIU V0, ZERO, 48
9D000BB0  70821002   MUL V0, A0, V0
9D000BB4  00621021   ADDU V0, V1, V0
9D000BB8  8C43000C   LW V1, 12(V0)
9D000BBC  3C02A000   LUI V0, -24576
9D000BC0  24422E8C   ADDIU V0, V0, 11916
9D000BC4  8C42000C   LW V0, 12(V0)
9D000BC8  1462FFEB   BNE V1, V0, 0x9D000B78
9D000BCC  00000000   NOP
9D000BD0  0B4002F7   J 0x9D000BDC
9D000BD4  00000000   NOP
894:                 
895:                 			MyTCBStub.smState = TCP_LAST_ACK;
9D000BDC  93828027   LBU V0, -32729(GP)
9D000BE0  00402021   ADDU A0, V0, ZERO
9D000BE4  3C02A000   LUI V0, -24576
9D000BE8  24432CDC   ADDIU V1, V0, 11484
9D000BEC  24020030   ADDIU V0, ZERO, 48
9D000BF0  70821002   MUL V0, A0, V0
9D000BF4  00621021   ADDU V0, V1, V0
9D000BF8  2403000C   ADDIU V1, ZERO, 12
9D000BFC  AC430024   SW V1, 36(V0)
896:                 			break;
9D000C00  0B400317   J 0x9D000C5C
9D000C04  00000000   NOP
897:                 			
898:                 		// These states are all already closed or don't need explicit disconnecting -- they will disconnect by themselves after a while
899:                 		//case TCP_CLOSED:
900:                 		//case TCP_LISTEN:
901:                 		//case TCP_CLOSING:
902:                 		//case TCP_TIME_WAIT:
903:                 		//	return;
904:                 
905:                 		case TCP_CLOSED_BUT_RESERVED:
906:                 			MyTCBStub.smState = TCP_CLOSED;
9D000C08  93828027   LBU V0, -32729(GP)
9D000C0C  00402021   ADDU A0, V0, ZERO
9D000C10  3C02A000   LUI V0, -24576
9D000C14  24432CDC   ADDIU V1, V0, 11484
9D000C18  24020030   ADDIU V0, ZERO, 48
9D000C1C  70821002   MUL V0, A0, V0
9D000C20  00621021   ADDU V0, V1, V0
9D000C24  2403000D   ADDIU V1, ZERO, 13
9D000C28  AC430024   SW V1, 36(V0)
907:                 			break;
9D000C2C  0B400317   J 0x9D000C5C
9D000C30  00000000   NOP
908:                 
909:                 		// These states will close themselves after some delay, however, 
910:                 		// this is handled so that the user can call TCPDisconnect() 
911:                 		// twice to immediately close a socket (using an RST) without 
912:                 		// having to get an ACK back from the remote node.  This is 
913:                 		// great for instance when the application determines that 
914:                 		// the remote node has been physically disconnected and 
915:                 		// already knows that no ACK will be returned.  Alternatively, 
916:                 		// if the application needs to immediately reuse the socket 
917:                 		// regardless of what the other node's state is in (half open).
918:                 		case TCP_FIN_WAIT_1:
919:                 		case TCP_FIN_WAIT_2:
920:                 		case TCP_LAST_ACK:
921:                 		default:
922:                 			SendTCP(RST | ACK, 0);
9D000C34  24040014   ADDIU A0, ZERO, 20
9D000C38  00002821   ADDU A1, ZERO, ZERO
9D000C3C  0F400F8B   JAL SendTCP
9D000C40  00000000   NOP
923:                 			CloseSocket();
9D000C44  0F4014AB   JAL CloseSocket
9D000C48  00000000   NOP
924:                 			break;
9D000C4C  00000000   NOP
9D000C50  0B400317   J 0x9D000C5C
9D000C54  00000000   NOP
925:                 	}
926:                 }
9D000C5C  03C0E821   ADDU SP, S8, ZERO
9D000C60  8FBF0014   LW RA, 20(SP)
9D000C64  8FBE0010   LW S8, 16(SP)
9D000C68  27BD0018   ADDIU SP, SP, 24
9D000C6C  03E00008   JR RA
9D000C70  00000000   NOP
927:                 
928:                 
929:                 /*****************************************************************************
930:                   Function:
931:                 	void TCPClose(TCP_SOCKET hTCP)
932:                 
933:                   Summary:
934:                 	Disconnects an open socket and destroys the socket handle, including server 
935:                 	mode socket handles.
936:                 
937:                   Description:
938:                 	Disconnects an open socket and destroys the socket handle, including server 
939:                 	mode socket handles.  This function performs identically to the 
940:                 	TCPDisconnect() function, except that both client and server mode socket 
941:                 	handles are relinquished to the TCP/IP stack upon return.
942:                 
943:                   Precondition:
944:                 	None
945:                 
946:                   Parameters:
947:                 	hTCP - Handle to the socket to disconnect and close.
948:                 
949:                   Returns:
950:                 	None
951:                   ***************************************************************************/
952:                 void TCPClose(TCP_SOCKET hTCP)
953:                 {
9D000C74  27BDFFE8   ADDIU SP, SP, -24
9D000C78  AFBF0014   SW RA, 20(SP)
9D000C7C  AFBE0010   SW S8, 16(SP)
9D000C80  03A0F021   ADDU S8, SP, ZERO
9D000C84  00801021   ADDU V0, A0, ZERO
9D000C88  A3C20018   SB V0, 24(S8)
954:                 	if(hTCP >= TCP_SOCKET_COUNT)
9D000C8C  93C20018   LBU V0, 24(S8)
9D000C90  2C420009   SLTIU V0, V0, 9
9D000C94  10400013   BEQ V0, ZERO, 0x9D000CE4
9D000C98  00000000   NOP
955:                     {
956:                         return;
9D000CE4  00000000   NOP
957:                     }
958:                     
959:                 	SyncTCBStub(hTCP);
9D000C9C  93C20018   LBU V0, 24(S8)
9D000CA0  A3828027   SB V0, -32729(GP)
960:                 	MyTCBStub.Flags.bServer = FALSE;
9D000CA4  93828027   LBU V0, -32729(GP)
9D000CA8  00402021   ADDU A0, V0, ZERO
9D000CAC  3C02A000   LUI V0, -24576
9D000CB0  24030030   ADDIU V1, ZERO, 48
9D000CB4  70831802   MUL V1, A0, V1
9D000CB8  24422CDC   ADDIU V0, V0, 11484
9D000CBC  00621821   ADDU V1, V1, V0
9D000CC0  8C620028   LW V0, 40(V1)
9D000CC4  7C0218C4   INS V0, ZERO, 3, 1
9D000CC8  AC620028   SW V0, 40(V1)
961:                 	TCPDisconnect(hTCP);
9D000CCC  93C20018   LBU V0, 24(S8)
9D000CD0  00402021   ADDU A0, V0, ZERO
9D000CD4  0F400273   JAL TCPDisconnect
9D000CD8  00000000   NOP
9D000CDC  0B40033A   J 0x9D000CE8
9D000CE0  00000000   NOP
962:                 }
9D000CE8  03C0E821   ADDU SP, S8, ZERO
9D000CEC  8FBF0014   LW RA, 20(SP)
9D000CF0  8FBE0010   LW S8, 16(SP)
9D000CF4  27BD0018   ADDIU SP, SP, 24
9D000CF8  03E00008   JR RA
9D000CFC  00000000   NOP
963:                 
964:                 
965:                 /*****************************************************************************
966:                   Function:
967:                 	SOCKET_INFO* TCPGetRemoteInfo(TCP_SOCKET hTCP)
968:                 
969:                   Summary:
970:                 	Obtains information about a currently open socket.
971:                 
972:                   Description:
973:                 	Returns the SOCKET_INFO structure associated with this socket.  This 
974:                 	contains the NODE_INFO structure with IP and MAC address (or gateway
975:                 	MAC) and the remote port.
976:                 
977:                   Precondition:
978:                 	TCP is initialized and the socket is connected.
979:                 
980:                   Parameters:
981:                 	hTCP - The socket to check.
982:                 
983:                   Returns:
984:                 	The SOCKET_INFO structure associated with this socket.  This structure is 
985:                 	allocated statically by the function and is valid only until the next 
986:                 	time TCPGetRemoteInfo() is called.
987:                   ***************************************************************************/
988:                 SOCKET_INFO* TCPGetRemoteInfo(TCP_SOCKET hTCP)
989:                 {
9D000D00  27BDFFE8   ADDIU SP, SP, -24
9D000D04  AFBF0014   SW RA, 20(SP)
9D000D08  AFBE0010   SW S8, 16(SP)
9D000D0C  03A0F021   ADDU S8, SP, ZERO
9D000D10  00801021   ADDU V0, A0, ZERO
9D000D14  A3C20018   SB V0, 24(S8)
990:                 	static SOCKET_INFO	RemoteInfo;
991:                 
992:                 	if(hTCP >= TCP_SOCKET_COUNT)
9D000D18  93C20018   LBU V0, 24(S8)
9D000D1C  2C420009   SLTIU V0, V0, 9
9D000D20  14400004   BNE V0, ZERO, 0x9D000D34
9D000D24  00000000   NOP
993:                     {
994:                         return 0;
9D000D28  00001021   ADDU V0, ZERO, ZERO
9D000D2C  0B400360   J 0x9D000D80
9D000D30  00000000   NOP
995:                     }
996:                     
997:                 	SyncTCBStub(hTCP);
9D000D34  93C20018   LBU V0, 24(S8)
9D000D38  A3828027   SB V0, -32729(GP)
998:                 	SyncTCB();
9D000D3C  0F400008   JAL SyncTCB
9D000D40  00000000   NOP
999:                 	memcpy((void*)&RemoteInfo.remote, (void*)&MyTCB.remote, sizeof(NODE_INFO));
9D000D44  3C02A000   LUI V0, -24576
9D000D48  24442EF4   ADDIU A0, V0, 12020
9D000D4C  3C02A000   LUI V0, -24576
9D000D50  24452EA4   ADDIU A1, V0, 11940
9D000D54  2406000A   ADDIU A2, ZERO, 10
9D000D58  0F40D298   JAL 0x9D034A60
9D000D5C  00000000   NOP
1000:                	RemoteInfo.remotePort.Val = MyTCB.remotePort.Val;
9D000D60  3C02A000   LUI V0, -24576
9D000D64  24422E8C   ADDIU V0, V0, 11916
9D000D68  94430010   LHU V1, 16(V0)
9D000D6C  3C02A000   LUI V0, -24576
9D000D70  24422EF4   ADDIU V0, V0, 12020
9D000D74  A443000A   SH V1, 10(V0)
1001:                
1002:                	return &RemoteInfo;
9D000D78  3C02A000   LUI V0, -24576
9D000D7C  24422EF4   ADDIU V0, V0, 12020
1003:                }
9D000D80  03C0E821   ADDU SP, S8, ZERO
9D000D84  8FBF0014   LW RA, 20(SP)
9D000D88  8FBE0010   LW S8, 16(SP)
9D000D8C  27BD0018   ADDIU SP, SP, 24
9D000D90  03E00008   JR RA
9D000D94  00000000   NOP
1004:                
1005:                
1006:                
1007:                /****************************************************************************
1008:                  Section:
1009:                	Transmit Functions
1010:                  ***************************************************************************/
1011:                
1012:                /*****************************************************************************
1013:                  Function:
1014:                	void TCPFlush(TCP_SOCKET hTCP)
1015:                
1016:                  Summary:
1017:                	Immediately transmits all pending TX data.
1018:                
1019:                  Description:
1020:                	This function immediately transmits all pending TX data with a PSH 
1021:                	flag.  If this function is not called, data will automatically be sent
1022:                	when either a) the TX buffer is half full or b) the 
1023:                	TCP_AUTO_TRANSMIT_TIMEOUT_VAL (default: 40ms) has elapsed.
1024:                
1025:                  Precondition:
1026:                	TCP is initialized and the socket is connected.
1027:                
1028:                  Parameters:
1029:                	hTCP - The socket whose data is to be transmitted.
1030:                
1031:                  Returns:
1032:                	None
1033:                
1034:                  Remarks:
1035:                	SSL application data is automatically flushed, so this function has 
1036:                	no effect for SSL sockets.
1037:                  ***************************************************************************/
1038:                void TCPFlush(TCP_SOCKET hTCP)
1039:                {
9D000D98  27BDFFE8   ADDIU SP, SP, -24
9D000D9C  AFBF0014   SW RA, 20(SP)
9D000DA0  AFBE0010   SW S8, 16(SP)
9D000DA4  03A0F021   ADDU S8, SP, ZERO
9D000DA8  00801021   ADDU V0, A0, ZERO
9D000DAC  A3C20018   SB V0, 24(S8)
1040:                	if(hTCP >= TCP_SOCKET_COUNT)
9D000DB0  93C20018   LBU V0, 24(S8)
9D000DB4  2C420009   SLTIU V0, V0, 9
9D000DB8  10400018   BEQ V0, ZERO, 0x9D000E1C
9D000DBC  00000000   NOP
1041:                    {
1042:                        return;
9D000E1C  00000000   NOP
1043:                    }
1044:                    
1045:                	SyncTCBStub(hTCP);
9D000DC0  93C20018   LBU V0, 24(S8)
9D000DC4  A3828027   SB V0, -32729(GP)
1046:                	SyncTCB();
9D000DC8  0F400008   JAL SyncTCB
9D000DCC  00000000   NOP
1047:                
1048:                	// NOTE: Pending SSL data will NOT be transferred here
1049:                
1050:                	if(MyTCBStub.txHead != MyTCB.txUnackedTail)
9D000DD0  93828027   LBU V0, -32729(GP)
9D000DD4  00402021   ADDU A0, V0, ZERO
9D000DD8  3C02A000   LUI V0, -24576
9D000DDC  24432CDC   ADDIU V1, V0, 11484
9D000DE0  24020030   ADDIU V0, ZERO, 48
9D000DE4  70821002   MUL V0, A0, V0
9D000DE8  00621021   ADDU V0, V1, V0
9D000DEC  8C43000C   LW V1, 12(V0)
9D000DF0  3C02A000   LUI V0, -24576
9D000DF4  24422E8C   ADDIU V0, V0, 11916
9D000DF8  8C42000C   LW V0, 12(V0)
9D000DFC  10620008   BEQ V1, V0, 0x9D000E20
9D000E00  00000000   NOP
1051:                	{
1052:                		// Send the TCP segment with all unacked bytes
1053:                		SendTCP(ACK, SENDTCP_RESET_TIMERS);
9D000E04  24040010   ADDIU A0, ZERO, 16
9D000E08  24050001   ADDIU A1, ZERO, 1
9D000E0C  0F400F8B   JAL SendTCP
9D000E10  00000000   NOP
9D000E14  0B400388   J 0x9D000E20
9D000E18  00000000   NOP
1054:                	}
1055:                }
9D000E20  03C0E821   ADDU SP, S8, ZERO
9D000E24  8FBF0014   LW RA, 20(SP)
9D000E28  8FBE0010   LW S8, 16(SP)
9D000E2C  27BD0018   ADDIU SP, SP, 24
9D000E30  03E00008   JR RA
9D000E34  00000000   NOP
1056:                
1057:                
1058:                /*****************************************************************************
1059:                  Function:
1060:                	WORD TCPIsPutReady(TCP_SOCKET hTCP)
1061:                
1062:                  Summary:
1063:                	Determines how much free space is available in the TCP TX buffer.
1064:                
1065:                  Description:
1066:                	Call this function to determine how many bytes can be written to the 
1067:                	TCP TX buffer.  If this function returns zero, the application must 
1068:                	return to the main stack loop before continuing in order to transmit
1069:                	more data.
1070:                
1071:                  Precondition:
1072:                	TCP is initialized.
1073:                
1074:                  Parameters:
1075:                	hTCP - The socket to check.
1076:                
1077:                  Returns:
1078:                	The number of bytes available to be written in the TCP TX buffer.
1079:                  ***************************************************************************/
1080:                WORD TCPIsPutReady(TCP_SOCKET hTCP)
1081:                {
9D000E38  27BDFFF0   ADDIU SP, SP, -16
9D000E3C  AFBE000C   SW S8, 12(SP)
9D000E40  03A0F021   ADDU S8, SP, ZERO
9D000E44  00801021   ADDU V0, A0, ZERO
9D000E48  A3C20010   SB V0, 16(S8)
1082:                	BYTE i;
1083:                
1084:                	if(hTCP >= TCP_SOCKET_COUNT)
9D000E4C  93C20010   LBU V0, 16(S8)
9D000E50  2C420009   SLTIU V0, V0, 9
9D000E54  14400004   BNE V0, ZERO, 0x9D000E68
9D000E58  00000000   NOP
1085:                    {
1086:                        return 0;
9D000E5C  00001021   ADDU V0, ZERO, ZERO
9D000E60  0B400407   J 0x9D00101C
9D000E64  00000000   NOP
1087:                    }
1088:                    
1089:                	SyncTCBStub(hTCP);
9D000E68  93C20010   LBU V0, 16(S8)
9D000E6C  A3828027   SB V0, -32729(GP)
1090:                
1091:                	i = MyTCBStub.smState;
9D000E70  93828027   LBU V0, -32729(GP)
9D000E74  00402021   ADDU A0, V0, ZERO
9D000E78  3C02A000   LUI V0, -24576
9D000E7C  24432CDC   ADDIU V1, V0, 11484
9D000E80  24020030   ADDIU V0, ZERO, 48
9D000E84  70821002   MUL V0, A0, V0
9D000E88  00621021   ADDU V0, V1, V0
9D000E8C  8C420024   LW V0, 36(V0)
9D000E90  A3C20000   SB V0, 0(S8)
1092:                
1093:                	// Unconnected sockets shouldn't be transmitting anything.
1094:                	if(!( (i == (BYTE)TCP_ESTABLISHED) || (i == (BYTE)TCP_CLOSE_WAIT) ))
9D000E94  93C30000   LBU V1, 0(S8)
9D000E98  24020007   ADDIU V0, ZERO, 7
9D000E9C  10620008   BEQ V1, V0, 0x9D000EC0
9D000EA0  00000000   NOP
9D000EA4  93C30000   LBU V1, 0(S8)
9D000EA8  2402000B   ADDIU V0, ZERO, 11
9D000EAC  10620004   BEQ V1, V0, 0x9D000EC0
9D000EB0  00000000   NOP
1095:                		return 0;
9D000EB4  00001021   ADDU V0, ZERO, ZERO
9D000EB8  0B400407   J 0x9D00101C
9D000EBC  00000000   NOP
1096:                
1097:                	// Calculate the free space in this socket's TX FIFO
1098:                	#if defined(STACK_USE_SSL)
1099:                	if(MyTCBStub.sslStubID != SSL_INVALID_ID)
1100:                	{// Use sslTxHead as the head pointer when SSL is active
1101:                		WORD rem;
1102:                		
1103:                		// Find out raw free space
1104:                		if(MyTCBStub.sslTxHead >= MyTCBStub.txTail)
1105:                			rem = (MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart - 1) - (MyTCBStub.sslTxHead - MyTCBStub.txTail);
1106:                		else
1107:                			rem = MyTCBStub.txTail - MyTCBStub.sslTxHead - 1;
1108:                			
1109:                		// Reserve space for a new MAC and header
1110:                		if(rem > 22u)
1111:                			return rem - 22;
1112:                		else
1113:                			return 0;
1114:                	}
1115:                	#endif
1116:                	
1117:                	if(MyTCBStub.txHead >= MyTCBStub.txTail)
9D000EC0  93828027   LBU V0, -32729(GP)
9D000EC4  00402021   ADDU A0, V0, ZERO
9D000EC8  3C02A000   LUI V0, -24576
9D000ECC  24432CDC   ADDIU V1, V0, 11484
9D000ED0  24020030   ADDIU V0, ZERO, 48
9D000ED4  70821002   MUL V0, A0, V0
9D000ED8  00621021   ADDU V0, V1, V0
9D000EDC  8C43000C   LW V1, 12(V0)
9D000EE0  93828027   LBU V0, -32729(GP)
9D000EE4  00402821   ADDU A1, V0, ZERO
9D000EE8  3C02A000   LUI V0, -24576
9D000EEC  24040030   ADDIU A0, ZERO, 48
9D000EF0  70A42002   MUL A0, A1, A0
9D000EF4  24422CDC   ADDIU V0, V0, 11484
9D000EF8  00821021   ADDU V0, A0, V0
9D000EFC  8C420010   LW V0, 16(V0)
9D000F00  0062102B   SLTU V0, V1, V0
9D000F04  1440002F   BNE V0, ZERO, 0x9D000FC4
9D000F08  00000000   NOP
1118:                		return (MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart - 1) - (MyTCBStub.txHead - MyTCBStub.txTail);
9D000F0C  93828027   LBU V0, -32729(GP)
9D000F10  00402021   ADDU A0, V0, ZERO
9D000F14  3C02A000   LUI V0, -24576
9D000F18  24432CDC   ADDIU V1, V0, 11484
9D000F1C  24020030   ADDIU V0, ZERO, 48
9D000F20  70821002   MUL V0, A0, V0
9D000F24  00621021   ADDU V0, V1, V0
9D000F28  8C420004   LW V0, 4(V0)
9D000F2C  3043FFFF   ANDI V1, V0, -1
9D000F30  93828027   LBU V0, -32729(GP)
9D000F34  00402821   ADDU A1, V0, ZERO
9D000F38  3C02A000   LUI V0, -24576
9D000F3C  24040030   ADDIU A0, ZERO, 48
9D000F40  70A42002   MUL A0, A1, A0
9D000F44  24422CDC   ADDIU V0, V0, 11484
9D000F48  00821021   ADDU V0, A0, V0
9D000F4C  8C420000   LW V0, 0(V0)
9D000F50  3042FFFF   ANDI V0, V0, -1
9D000F54  00621023   SUBU V0, V1, V0
9D000F58  3043FFFF   ANDI V1, V0, -1
9D000F5C  93828027   LBU V0, -32729(GP)
9D000F60  00402821   ADDU A1, V0, ZERO
9D000F64  3C02A000   LUI V0, -24576
9D000F68  24040030   ADDIU A0, ZERO, 48
9D000F6C  70A42002   MUL A0, A1, A0
9D000F70  24422CDC   ADDIU V0, V0, 11484
9D000F74  00821021   ADDU V0, A0, V0
9D000F78  8C420010   LW V0, 16(V0)
9D000F7C  3044FFFF   ANDI A0, V0, -1
9D000F80  93828027   LBU V0, -32729(GP)
9D000F84  00403021   ADDU A2, V0, ZERO
9D000F88  3C02A000   LUI V0, -24576
9D000F8C  24452CDC   ADDIU A1, V0, 11484
9D000F90  24020030   ADDIU V0, ZERO, 48
9D000F94  70C21002   MUL V0, A2, V0
9D000F98  00A21021   ADDU V0, A1, V0
9D000F9C  8C42000C   LW V0, 12(V0)
9D000FA0  3042FFFF   ANDI V0, V0, -1
9D000FA4  00821023   SUBU V0, A0, V0
9D000FA8  3042FFFF   ANDI V0, V0, -1
9D000FAC  00621021   ADDU V0, V1, V0
9D000FB0  3042FFFF   ANDI V0, V0, -1
9D000FB4  2442FFFF   ADDIU V0, V0, -1
9D000FB8  3042FFFF   ANDI V0, V0, -1
9D000FBC  0B400407   J 0x9D00101C
9D000FC0  00000000   NOP
1119:                	else
1120:                		return MyTCBStub.txTail - MyTCBStub.txHead - 1;
9D000FC4  93828027   LBU V0, -32729(GP)
9D000FC8  00402021   ADDU A0, V0, ZERO
9D000FCC  3C02A000   LUI V0, -24576
9D000FD0  24030030   ADDIU V1, ZERO, 48
9D000FD4  70831802   MUL V1, A0, V1
9D000FD8  24422CDC   ADDIU V0, V0, 11484
9D000FDC  00621021   ADDU V0, V1, V0
9D000FE0  8C420010   LW V0, 16(V0)
9D000FE4  3043FFFF   ANDI V1, V0, -1
9D000FE8  93828027   LBU V0, -32729(GP)
9D000FEC  00402821   ADDU A1, V0, ZERO
9D000FF0  3C02A000   LUI V0, -24576
9D000FF4  24442CDC   ADDIU A0, V0, 11484
9D000FF8  24020030   ADDIU V0, ZERO, 48
9D000FFC  70A21002   MUL V0, A1, V0
9D001000  00821021   ADDU V0, A0, V0
9D001004  8C42000C   LW V0, 12(V0)
9D001008  3042FFFF   ANDI V0, V0, -1
9D00100C  00621023   SUBU V0, V1, V0
9D001010  3042FFFF   ANDI V0, V0, -1
9D001014  2442FFFF   ADDIU V0, V0, -1
9D001018  3042FFFF   ANDI V0, V0, -1
1121:                }
9D00101C  03C0E821   ADDU SP, S8, ZERO
9D001020  8FBE000C   LW S8, 12(SP)
9D001024  27BD0010   ADDIU SP, SP, 16
9D001028  03E00008   JR RA
9D00102C  00000000   NOP
1122:                
1123:                
1124:                /*****************************************************************************
1125:                  Function:
1126:                	BOOL TCPPut(TCP_SOCKET hTCP, BYTE byte)
1127:                
1128:                  Description:
1129:                	Writes a single byte to a TCP socket.
1130:                
1131:                  Precondition:
1132:                	TCP is initialized.
1133:                
1134:                  Parameters:
1135:                	hTCP - The socket to which data is to be written.
1136:                	byte - The byte to write.
1137:                
1138:                  Return Values:
1139:                	TRUE - The byte was written to the transmit buffer.
1140:                	FALSE - The transmit buffer was full, or the socket is not connected.
1141:                  ***************************************************************************/
1142:                BOOL TCPPut(TCP_SOCKET hTCP, BYTE byte)
1143:                {
9D001030  27BDFFD0   ADDIU SP, SP, -48
9D001034  AFBF002C   SW RA, 44(SP)
9D001038  AFBE0028   SW S8, 40(SP)
9D00103C  AFB00024   SW S0, 36(SP)
9D001040  03A0F021   ADDU S8, SP, ZERO
9D001044  00801821   ADDU V1, A0, ZERO
9D001048  00A01021   ADDU V0, A1, ZERO
9D00104C  A3C30030   SB V1, 48(S8)
9D001050  A3C20034   SB V0, 52(S8)
1144:                	WORD wFreeTXSpace;
1145:                
1146:                	if(hTCP >= TCP_SOCKET_COUNT)
9D001054  93C20030   LBU V0, 48(S8)
9D001058  2C420009   SLTIU V0, V0, 9
9D00105C  14400004   BNE V0, ZERO, 0x9D001070
9D001060  00000000   NOP
1147:                    {
1148:                        return 0;
9D001064  00001021   ADDU V0, ZERO, ZERO
9D001068  0B4004DA   J 0x9D001368
9D00106C  00000000   NOP
1149:                    }
1150:                    
1151:                	SyncTCBStub(hTCP);
9D001070  93C20030   LBU V0, 48(S8)
9D001074  A3828027   SB V0, -32729(GP)
1152:                
1153:                	wFreeTXSpace = TCPIsPutReady(hTCP);
9D001078  93C20030   LBU V0, 48(S8)
9D00107C  00402021   ADDU A0, V0, ZERO
9D001080  0F40038E   JAL TCPIsPutReady
9D001084  00000000   NOP
9D001088  A7C20018   SH V0, 24(S8)
1154:                	if(wFreeTXSpace == 0u)
9D00108C  97C20018   LHU V0, 24(S8)
9D001090  14400004   BNE V0, ZERO, 0x9D0010A4
9D001094  00000000   NOP
1155:                		return FALSE;
9D001098  00001021   ADDU V0, ZERO, ZERO
9D00109C  0B4004DA   J 0x9D001368
9D0010A0  00000000   NOP
1156:                	else if(wFreeTXSpace == 1u) // About to run out of space, lets transmit so the remote node might send an ACK back faster
9D0010A4  97C30018   LHU V1, 24(S8)
9D0010A8  24020001   ADDIU V0, ZERO, 1
9D0010AC  14620005   BNE V1, V0, 0x9D0010C4
9D0010B0  00000000   NOP
1157:                		TCPFlush(hTCP);	
9D0010B4  93C20030   LBU V0, 48(S8)
9D0010B8  00402021   ADDU A0, V0, ZERO
9D0010BC  0F400366   JAL TCPFlush
9D0010C0  00000000   NOP
1158:                
1159:                	// Send all current bytes if we are crossing half full
1160:                	// This is required to improve performance with the delayed 
1161:                	// acknowledgement algorithm
1162:                	if((!MyTCBStub.Flags.bHalfFullFlush) && (wFreeTXSpace <= ((MyTCBStub.bufferRxStart-MyTCBStub.bufferTxStart)>>1)))
9D0010C4  93828027   LBU V0, -32729(GP)
9D0010C8  00402021   ADDU A0, V0, ZERO
9D0010CC  3C02A000   LUI V0, -24576
9D0010D0  24030030   ADDIU V1, ZERO, 48
9D0010D4  70831802   MUL V1, A0, V1
9D0010D8  24422CDC   ADDIU V0, V0, 11484
9D0010DC  00621021   ADDU V0, V1, V0
9D0010E0  8C420028   LW V0, 40(V0)
9D0010E4  7C420200   EXT V0, V0, 8, 1
9D0010E8  304200FF   ANDI V0, V0, 255
9D0010EC  14400026   BNE V0, ZERO, 0x9D001188
9D0010F0  00000000   NOP
9D0010F4  97C30018   LHU V1, 24(S8)
9D0010F8  93828027   LBU V0, -32729(GP)
9D0010FC  00402821   ADDU A1, V0, ZERO
9D001100  3C02A000   LUI V0, -24576
9D001104  24442CDC   ADDIU A0, V0, 11484
9D001108  24020030   ADDIU V0, ZERO, 48
9D00110C  70A21002   MUL V0, A1, V0
9D001110  00821021   ADDU V0, A0, V0
9D001114  8C440004   LW A0, 4(V0)
9D001118  93828027   LBU V0, -32729(GP)
9D00111C  00403021   ADDU A2, V0, ZERO
9D001120  3C02A000   LUI V0, -24576
9D001124  24050030   ADDIU A1, ZERO, 48
9D001128  70C52802   MUL A1, A2, A1
9D00112C  24422CDC   ADDIU V0, V0, 11484
9D001130  00A21021   ADDU V0, A1, V0
9D001134  8C420000   LW V0, 0(V0)
9D001138  00821023   SUBU V0, A0, V0
9D00113C  00021042   SRL V0, V0, 1
9D001140  0043102B   SLTU V0, V0, V1
9D001144  14400010   BNE V0, ZERO, 0x9D001188
9D001148  00000000   NOP
1163:                	{
1164:                		TCPFlush(hTCP);	
9D00114C  93C20030   LBU V0, 48(S8)
9D001150  00402021   ADDU A0, V0, ZERO
9D001154  0F400366   JAL TCPFlush
9D001158  00000000   NOP
1165:                		MyTCBStub.Flags.bHalfFullFlush = TRUE;
9D00115C  93828027   LBU V0, -32729(GP)
9D001160  00402021   ADDU A0, V0, ZERO
9D001164  3C02A000   LUI V0, -24576
9D001168  24030030   ADDIU V1, ZERO, 48
9D00116C  70831802   MUL V1, A0, V1
9D001170  24422CDC   ADDIU V0, V0, 11484
9D001174  00621821   ADDU V1, V1, V0
9D001178  8C620028   LW V0, 40(V1)
9D00117C  24040001   ADDIU A0, ZERO, 1
9D001180  7C824204   INS V0, A0, 8, 1
9D001184  AC620028   SW V0, 40(V1)
1166:                	}
1167:                
1168:                	#if defined(STACK_USE_SSL)
1169:                	if(MyTCBStub.sslStubID != SSL_INVALID_ID)
1170:                	{
1171:                		TCPRAMCopy(MyTCBStub.sslTxHead, MyTCBStub.vMemoryMedium, (PTR_BASE)&byte, TCP_PIC_RAM, sizeof(byte));
1172:                		if(++MyTCBStub.sslTxHead >= MyTCBStub.bufferRxStart)
1173:                			MyTCBStub.sslTxHead = MyTCBStub.bufferTxStart;
1174:                	}
1175:                	else
1176:                	{
1177:                		TCPRAMCopy(MyTCBStub.txHead, MyTCBStub.vMemoryMedium, (PTR_BASE)&byte, TCP_PIC_RAM, sizeof(byte));
1178:                		if(++MyTCBStub.txHead >= MyTCBStub.bufferRxStart)
1179:                			MyTCBStub.txHead = MyTCBStub.bufferTxStart;
1180:                	}
1181:                	#else
1182:                	TCPRAMCopy(MyTCBStub.txHead, MyTCBStub.vMemoryMedium, (PTR_BASE)&byte, TCP_PIC_RAM, sizeof(byte));
9D001188  93828027   LBU V0, -32729(GP)
9D00118C  00402021   ADDU A0, V0, ZERO
9D001190  3C02A000   LUI V0, -24576
9D001194  24432CDC   ADDIU V1, V0, 11484
9D001198  24020030   ADDIU V0, ZERO, 48
9D00119C  70821002   MUL V0, A0, V0
9D0011A0  00621021   ADDU V0, V1, V0
9D0011A4  8C44000C   LW A0, 12(V0)
9D0011A8  93828027   LBU V0, -32729(GP)
9D0011AC  00402821   ADDU A1, V0, ZERO
9D0011B0  3C02A000   LUI V0, -24576
9D0011B4  24030030   ADDIU V1, ZERO, 48
9D0011B8  70A31802   MUL V1, A1, V1
9D0011BC  24422CDC   ADDIU V0, V0, 11484
9D0011C0  00621021   ADDU V0, V1, V0
9D0011C4  9042002C   LBU V0, 44(V0)
9D0011C8  00401821   ADDU V1, V0, ZERO
9D0011CC  27C20034   ADDIU V0, S8, 52
9D0011D0  24050001   ADDIU A1, ZERO, 1
9D0011D4  AFA50010   SW A1, 16(SP)
9D0011D8  00602821   ADDU A1, V1, ZERO
9D0011DC  00403021   ADDU A2, V0, ZERO
9D0011E0  24070001   ADDIU A3, ZERO, 1
9D0011E4  0F4020BE   JAL TCPRAMCopy
9D0011E8  00000000   NOP
1183:                	if(++MyTCBStub.txHead >= MyTCBStub.bufferRxStart)
9D0011EC  93828027   LBU V0, -32729(GP)
9D0011F0  00402821   ADDU A1, V0, ZERO
9D0011F4  3C02A000   LUI V0, -24576
9D0011F8  24432CDC   ADDIU V1, V0, 11484
9D0011FC  24020030   ADDIU V0, ZERO, 48
9D001200  70A21002   MUL V0, A1, V0
9D001204  00621021   ADDU V0, V1, V0
9D001208  8C42000C   LW V0, 12(V0)
9D00120C  24430001   ADDIU V1, V0, 1
9D001210  3C02A000   LUI V0, -24576
9D001214  24442CDC   ADDIU A0, V0, 11484
9D001218  24020030   ADDIU V0, ZERO, 48
9D00121C  70A21002   MUL V0, A1, V0
9D001220  00821021   ADDU V0, A0, V0
9D001224  AC43000C   SW V1, 12(V0)
9D001228  3C02A000   LUI V0, -24576
9D00122C  24432CDC   ADDIU V1, V0, 11484
9D001230  24020030   ADDIU V0, ZERO, 48
9D001234  70A21002   MUL V0, A1, V0
9D001238  00621021   ADDU V0, V1, V0
9D00123C  8C43000C   LW V1, 12(V0)
9D001240  93828027   LBU V0, -32729(GP)
9D001244  00402821   ADDU A1, V0, ZERO
9D001248  3C02A000   LUI V0, -24576
9D00124C  24442CDC   ADDIU A0, V0, 11484
9D001250  24020030   ADDIU V0, ZERO, 48
9D001254  70A21002   MUL V0, A1, V0
9D001258  00821021   ADDU V0, A0, V0
9D00125C  8C420004   LW V0, 4(V0)
9D001260  0062102B   SLTU V0, V1, V0
9D001264  14400011   BNE V0, ZERO, 0x9D0012AC
9D001268  00000000   NOP
1184:                		MyTCBStub.txHead = MyTCBStub.bufferTxStart;
9D00126C  93828027   LBU V0, -32729(GP)
9D001270  00402821   ADDU A1, V0, ZERO
9D001274  93828027   LBU V0, -32729(GP)
9D001278  00402021   ADDU A0, V0, ZERO
9D00127C  3C02A000   LUI V0, -24576
9D001280  24030030   ADDIU V1, ZERO, 48
9D001284  70831802   MUL V1, A0, V1
9D001288  24422CDC   ADDIU V0, V0, 11484
9D00128C  00621021   ADDU V0, V1, V0
9D001290  8C430000   LW V1, 0(V0)
9D001294  3C02A000   LUI V0, -24576
9D001298  24442CDC   ADDIU A0, V0, 11484
9D00129C  24020030   ADDIU V0, ZERO, 48
9D0012A0  70A21002   MUL V0, A1, V0
9D0012A4  00821021   ADDU V0, A0, V0
9D0012A8  AC43000C   SW V1, 12(V0)
1185:                	#endif
1186:                	
1187:                
1188:                	// Send the last byte as a separate packet (likely will make the remote node send back ACK faster)
1189:                	if(wFreeTXSpace == 1u)
9D0012AC  97C30018   LHU V1, 24(S8)
9D0012B0  24020001   ADDIU V0, ZERO, 1
9D0012B4  14620007   BNE V1, V0, 0x9D0012D4
9D0012B8  00000000   NOP
1190:                	{
1191:                		TCPFlush(hTCP);
9D0012BC  93C20030   LBU V0, 48(S8)
9D0012C0  00402021   ADDU A0, V0, ZERO
9D0012C4  0F400366   JAL TCPFlush
9D0012C8  00000000   NOP
9D0012CC  0B4004D9   J 0x9D001364
9D0012D0  00000000   NOP
1192:                	}
1193:                	// If not already enabled, start a timer so this data will 
1194:                	// eventually get sent even if the application doens't call
1195:                	// TCPFlush()
1196:                	else if(!MyTCBStub.Flags.bTimer2Enabled)
9D0012D4  93828027   LBU V0, -32729(GP)
9D0012D8  00402021   ADDU A0, V0, ZERO
9D0012DC  3C02A000   LUI V0, -24576
9D0012E0  24030030   ADDIU V1, ZERO, 48
9D0012E4  70831802   MUL V1, A0, V1
9D0012E8  24422CDC   ADDIU V0, V0, 11484
9D0012EC  00621021   ADDU V0, V1, V0
9D0012F0  8C420028   LW V0, 40(V0)
9D0012F4  7C420140   EXT V0, V0, 5, 1
9D0012F8  304200FF   ANDI V0, V0, 255
9D0012FC  14400019   BNE V0, ZERO, 0x9D001364
9D001300  00000000   NOP
1197:                	{
1198:                		MyTCBStub.Flags.bTimer2Enabled = TRUE;
9D001304  93828027   LBU V0, -32729(GP)
9D001308  00402021   ADDU A0, V0, ZERO
9D00130C  3C02A000   LUI V0, -24576
9D001310  24030030   ADDIU V1, ZERO, 48
9D001314  70831802   MUL V1, A0, V1
9D001318  24422CDC   ADDIU V0, V0, 11484
9D00131C  00621821   ADDU V1, V1, V0
9D001320  8C620028   LW V0, 40(V1)
9D001324  24040001   ADDIU A0, ZERO, 1
9D001328  7C822944   INS V0, A0, 5, 1
9D00132C  AC620028   SW V0, 40(V1)
1199:                		MyTCBStub.eventTime2 = (WORD)TickGetDiv256() + TCP_AUTO_TRANSMIT_TIMEOUT_VAL/256ull;
9D001330  93828027   LBU V0, -32729(GP)
9D001334  00408021   ADDU S0, V0, ZERO
9D001338  0F40CDE4   JAL TickGetDiv256
9D00133C  00000000   NOP
9D001340  3042FFFF   ANDI V0, V0, -1
9D001344  24420018   ADDIU V0, V0, 24
9D001348  3043FFFF   ANDI V1, V0, -1
9D00134C  3C02A000   LUI V0, -24576
9D001350  24040030   ADDIU A0, ZERO, 48
9D001354  72042002   MUL A0, S0, A0
9D001358  24422CDC   ADDIU V0, V0, 11484
9D00135C  00821021   ADDU V0, A0, V0
9D001360  A4430020   SH V1, 32(V0)
1200:                	}
1201:                
1202:                	return TRUE;
9D001364  24020001   ADDIU V0, ZERO, 1
1203:                }
9D001368  03C0E821   ADDU SP, S8, ZERO
9D00136C  8FBF002C   LW RA, 44(SP)
9D001370  8FBE0028   LW S8, 40(SP)
9D001374  8FB00024   LW S0, 36(SP)
9D001378  27BD0030   ADDIU SP, SP, 48
9D00137C  03E00008   JR RA
9D001380  00000000   NOP
1204:                
1205:                /*****************************************************************************
1206:                  Function:
1207:                	WORD TCPPutArray(TCP_SOCKET hTCP, BYTE* data, WORD len)
1208:                
1209:                  Description:
1210:                	Writes an array from RAM to a TCP socket.
1211:                
1212:                  Precondition:
1213:                	TCP is initialized.
1214:                
1215:                  Parameters:
1216:                	hTCP - The socket to which data is to be written.
1217:                	data - Pointer to the array to be written.
1218:                	len  - Number of bytes to be written.
1219:                
1220:                  Returns:
1221:                	The number of bytes written to the socket.  If less than len, the
1222:                	buffer became full or the socket is not conected.
1223:                  ***************************************************************************/
1224:                WORD TCPPutArray(TCP_SOCKET hTCP, BYTE* data, WORD len)
1225:                {
9D001384  27BDFFD0   ADDIU SP, SP, -48
9D001388  AFBF002C   SW RA, 44(SP)
9D00138C  AFBE0028   SW S8, 40(SP)
9D001390  AFB00024   SW S0, 36(SP)
9D001394  03A0F021   ADDU S8, SP, ZERO
9D001398  00801821   ADDU V1, A0, ZERO
9D00139C  AFC50034   SW A1, 52(S8)
9D0013A0  00C01021   ADDU V0, A2, ZERO
9D0013A4  A3C30030   SB V1, 48(S8)
9D0013A8  A7C20038   SH V0, 56(S8)
1226:                	WORD wActualLen;
1227:                	WORD wFreeTXSpace;
1228:                	WORD wRightLen = 0;
9D0013AC  A7C0001A   SH ZERO, 26(S8)
1229:                
1230:                	if(hTCP >= TCP_SOCKET_COUNT)
9D0013B0  93C20030   LBU V0, 48(S8)
9D0013B4  2C420009   SLTIU V0, V0, 9
9D0013B8  14400004   BNE V0, ZERO, 0x9D0013CC
9D0013BC  00000000   NOP
1231:                    {
1232:                        return 0;
9D0013C0  00001021   ADDU V0, ZERO, ZERO
9D0013C4  0B4005F6   J 0x9D0017D8
9D0013C8  00000000   NOP
1233:                    }
1234:                    
1235:                	SyncTCBStub(hTCP);
9D0013CC  93C20030   LBU V0, 48(S8)
9D0013D0  A3828027   SB V0, -32729(GP)
1236:                
1237:                	wFreeTXSpace = TCPIsPutReady(hTCP);
9D0013D4  93C20030   LBU V0, 48(S8)
9D0013D8  00402021   ADDU A0, V0, ZERO
9D0013DC  0F40038E   JAL TCPIsPutReady
9D0013E0  00000000   NOP
9D0013E4  A7C2001C   SH V0, 28(S8)
1238:                	if(wFreeTXSpace == 0u)
9D0013E8  97C2001C   LHU V0, 28(S8)
9D0013EC  14400008   BNE V0, ZERO, 0x9D001410
9D0013F0  00000000   NOP
1239:                	{
1240:                		TCPFlush(hTCP);
9D0013F4  93C20030   LBU V0, 48(S8)
9D0013F8  00402021   ADDU A0, V0, ZERO
9D0013FC  0F400366   JAL TCPFlush
9D001400  00000000   NOP
1241:                		return 0;
9D001404  00001021   ADDU V0, ZERO, ZERO
9D001408  0B4005F6   J 0x9D0017D8
9D00140C  00000000   NOP
1242:                	}
1243:                
1244:                	wActualLen = wFreeTXSpace;
9D001410  97C2001C   LHU V0, 28(S8)
9D001414  A7C20018   SH V0, 24(S8)
1245:                	if(wFreeTXSpace > len)
9D001418  97C3001C   LHU V1, 28(S8)
9D00141C  97C20038   LHU V0, 56(S8)
9D001420  0043102B   SLTU V0, V0, V1
9D001424  10400003   BEQ V0, ZERO, 0x9D001434
9D001428  00000000   NOP
1246:                		wActualLen = len;
9D00142C  97C20038   LHU V0, 56(S8)
9D001430  A7C20018   SH V0, 24(S8)
1247:                
1248:                	// Send all current bytes if we are crossing half full
1249:                	// This is required to improve performance with the delayed 
1250:                	// acknowledgement algorithm
1251:                	if((!MyTCBStub.Flags.bHalfFullFlush) && (wFreeTXSpace <= ((MyTCBStub.bufferRxStart-MyTCBStub.bufferTxStart)>>1)))
9D001434  93828027   LBU V0, -32729(GP)
9D001438  00402021   ADDU A0, V0, ZERO
9D00143C  3C02A000   LUI V0, -24576
9D001440  24030030   ADDIU V1, ZERO, 48
9D001444  70831802   MUL V1, A0, V1
9D001448  24422CDC   ADDIU V0, V0, 11484
9D00144C  00621021   ADDU V0, V1, V0
9D001450  8C420028   LW V0, 40(V0)
9D001454  7C420200   EXT V0, V0, 8, 1
9D001458  304200FF   ANDI V0, V0, 255
9D00145C  14400026   BNE V0, ZERO, 0x9D0014F8
9D001460  00000000   NOP
9D001464  97C3001C   LHU V1, 28(S8)
9D001468  93828027   LBU V0, -32729(GP)
9D00146C  00402821   ADDU A1, V0, ZERO
9D001470  3C02A000   LUI V0, -24576
9D001474  24442CDC   ADDIU A0, V0, 11484
9D001478  24020030   ADDIU V0, ZERO, 48
9D00147C  70A21002   MUL V0, A1, V0
9D001480  00821021   ADDU V0, A0, V0
9D001484  8C440004   LW A0, 4(V0)
9D001488  93828027   LBU V0, -32729(GP)
9D00148C  00403021   ADDU A2, V0, ZERO
9D001490  3C02A000   LUI V0, -24576
9D001494  24050030   ADDIU A1, ZERO, 48
9D001498  70C52802   MUL A1, A2, A1
9D00149C  24422CDC   ADDIU V0, V0, 11484
9D0014A0  00A21021   ADDU V0, A1, V0
9D0014A4  8C420000   LW V0, 0(V0)
9D0014A8  00821023   SUBU V0, A0, V0
9D0014AC  00021042   SRL V0, V0, 1
9D0014B0  0043102B   SLTU V0, V0, V1
9D0014B4  14400010   BNE V0, ZERO, 0x9D0014F8
9D0014B8  00000000   NOP
1252:                	{
1253:                		TCPFlush(hTCP);	
9D0014BC  93C20030   LBU V0, 48(S8)
9D0014C0  00402021   ADDU A0, V0, ZERO
9D0014C4  0F400366   JAL TCPFlush
9D0014C8  00000000   NOP
1254:                		MyTCBStub.Flags.bHalfFullFlush = TRUE;
9D0014CC  93828027   LBU V0, -32729(GP)
9D0014D0  00402021   ADDU A0, V0, ZERO
9D0014D4  3C02A000   LUI V0, -24576
9D0014D8  24030030   ADDIU V1, ZERO, 48
9D0014DC  70831802   MUL V1, A0, V1
9D0014E0  24422CDC   ADDIU V0, V0, 11484
9D0014E4  00621821   ADDU V1, V1, V0
9D0014E8  8C620028   LW V0, 40(V1)
9D0014EC  24040001   ADDIU A0, ZERO, 1
9D0014F0  7C824204   INS V0, A0, 8, 1
9D0014F4  AC620028   SW V0, 40(V1)
1255:                	}
1256:                	
1257:                	#if defined(STACK_USE_SSL)
1258:                	if(MyTCBStub.sslStubID != SSL_INVALID_ID)
1259:                	{
1260:                		// See if we need a two part put
1261:                		if(MyTCBStub.sslTxHead + wActualLen >= MyTCBStub.bufferRxStart)
1262:                		{
1263:                			wRightLen = MyTCBStub.bufferRxStart-MyTCBStub.sslTxHead;
1264:                			TCPRAMCopy(MyTCBStub.sslTxHead, MyTCBStub.vMemoryMedium, (PTR_BASE)data, TCP_PIC_RAM, wRightLen);
1265:                			data += wRightLen;
1266:                			wActualLen -= wRightLen;
1267:                			MyTCBStub.sslTxHead = MyTCBStub.bufferTxStart;
1268:                		}
1269:                	
1270:                		TCPRAMCopy(MyTCBStub.sslTxHead, MyTCBStub.vMemoryMedium, (PTR_BASE)data, TCP_PIC_RAM, wActualLen);
1271:                		MyTCBStub.sslTxHead += wActualLen;
1272:                	}
1273:                	else
1274:                	{
1275:                		// See if we need a two part put
1276:                		if(MyTCBStub.txHead + wActualLen >= MyTCBStub.bufferRxStart)
1277:                		{
1278:                			wRightLen = MyTCBStub.bufferRxStart-MyTCBStub.txHead;
1279:                			TCPRAMCopy(MyTCBStub.txHead, MyTCBStub.vMemoryMedium, (PTR_BASE)data, TCP_PIC_RAM, wRightLen);
1280:                			data += wRightLen;
1281:                			wActualLen -= wRightLen;
1282:                			MyTCBStub.txHead = MyTCBStub.bufferTxStart;
1283:                		}
1284:                	
1285:                		TCPRAMCopy(MyTCBStub.txHead, MyTCBStub.vMemoryMedium, (PTR_BASE)data, TCP_PIC_RAM, wActualLen);
1286:                		MyTCBStub.txHead += wActualLen;
1287:                	}
1288:                	#else
1289:                	// See if we need a two part put
1290:                	if(MyTCBStub.txHead + wActualLen >= MyTCBStub.bufferRxStart)
9D0014F8  93828027   LBU V0, -32729(GP)
9D0014FC  00402021   ADDU A0, V0, ZERO
9D001500  3C02A000   LUI V0, -24576
9D001504  24432CDC   ADDIU V1, V0, 11484
9D001508  24020030   ADDIU V0, ZERO, 48
9D00150C  70821002   MUL V0, A0, V0
9D001510  00621021   ADDU V0, V1, V0
9D001514  8C43000C   LW V1, 12(V0)
9D001518  97C20018   LHU V0, 24(S8)
9D00151C  00621821   ADDU V1, V1, V0
9D001520  93828027   LBU V0, -32729(GP)
9D001524  00402821   ADDU A1, V0, ZERO
9D001528  3C02A000   LUI V0, -24576
9D00152C  24442CDC   ADDIU A0, V0, 11484
9D001530  24020030   ADDIU V0, ZERO, 48
9D001534  70A21002   MUL V0, A1, V0
9D001538  00821021   ADDU V0, A0, V0
9D00153C  8C420004   LW V0, 4(V0)
9D001540  0062102B   SLTU V0, V1, V0
9D001544  14400046   BNE V0, ZERO, 0x9D001660
9D001548  00000000   NOP
1291:                	{
1292:                		wRightLen = MyTCBStub.bufferRxStart-MyTCBStub.txHead;
9D00154C  93828027   LBU V0, -32729(GP)
9D001550  00402021   ADDU A0, V0, ZERO
9D001554  3C02A000   LUI V0, -24576
9D001558  24432CDC   ADDIU V1, V0, 11484
9D00155C  24020030   ADDIU V0, ZERO, 48
9D001560  70821002   MUL V0, A0, V0
9D001564  00621021   ADDU V0, V1, V0
9D001568  8C420004   LW V0, 4(V0)
9D00156C  3043FFFF   ANDI V1, V0, -1
9D001570  93828027   LBU V0, -32729(GP)
9D001574  00402821   ADDU A1, V0, ZERO
9D001578  3C02A000   LUI V0, -24576
9D00157C  24442CDC   ADDIU A0, V0, 11484
9D001580  24020030   ADDIU V0, ZERO, 48
9D001584  70A21002   MUL V0, A1, V0
9D001588  00821021   ADDU V0, A0, V0
9D00158C  8C42000C   LW V0, 12(V0)
9D001590  3042FFFF   ANDI V0, V0, -1
9D001594  00621023   SUBU V0, V1, V0
9D001598  A7C2001A   SH V0, 26(S8)
1293:                		TCPRAMCopy(MyTCBStub.txHead, MyTCBStub.vMemoryMedium, (PTR_BASE)data, TCP_PIC_RAM, wRightLen);
9D00159C  93828027   LBU V0, -32729(GP)
9D0015A0  00402021   ADDU A0, V0, ZERO
9D0015A4  3C02A000   LUI V0, -24576
9D0015A8  24432CDC   ADDIU V1, V0, 11484
9D0015AC  24020030   ADDIU V0, ZERO, 48
9D0015B0  70821002   MUL V0, A0, V0
9D0015B4  00621021   ADDU V0, V1, V0
9D0015B8  8C44000C   LW A0, 12(V0)
9D0015BC  93828027   LBU V0, -32729(GP)
9D0015C0  00402821   ADDU A1, V0, ZERO
9D0015C4  3C02A000   LUI V0, -24576
9D0015C8  24030030   ADDIU V1, ZERO, 48
9D0015CC  70A31802   MUL V1, A1, V1
9D0015D0  24422CDC   ADDIU V0, V0, 11484
9D0015D4  00621021   ADDU V0, V1, V0
9D0015D8  9042002C   LBU V0, 44(V0)
9D0015DC  00401821   ADDU V1, V0, ZERO
9D0015E0  8FC20034   LW V0, 52(S8)
9D0015E4  97C5001A   LHU A1, 26(S8)
9D0015E8  AFA50010   SW A1, 16(SP)
9D0015EC  00602821   ADDU A1, V1, ZERO
9D0015F0  00403021   ADDU A2, V0, ZERO
9D0015F4  24070001   ADDIU A3, ZERO, 1
9D0015F8  0F4020BE   JAL TCPRAMCopy
9D0015FC  00000000   NOP
1294:                		data += wRightLen;
9D001600  97C2001A   LHU V0, 26(S8)
9D001604  8FC30034   LW V1, 52(S8)
9D001608  00621021   ADDU V0, V1, V0
9D00160C  AFC20034   SW V0, 52(S8)
1295:                		wActualLen -= wRightLen;
9D001610  97C30018   LHU V1, 24(S8)
9D001614  97C2001A   LHU V0, 26(S8)
9D001618  00621023   SUBU V0, V1, V0
9D00161C  A7C20018   SH V0, 24(S8)
1296:                		MyTCBStub.txHead = MyTCBStub.bufferTxStart;
9D001620  93828027   LBU V0, -32729(GP)
9D001624  00402821   ADDU A1, V0, ZERO
9D001628  93828027   LBU V0, -32729(GP)
9D00162C  00402021   ADDU A0, V0, ZERO
9D001630  3C02A000   LUI V0, -24576
9D001634  24030030   ADDIU V1, ZERO, 48
9D001638  70831802   MUL V1, A0, V1
9D00163C  24422CDC   ADDIU V0, V0, 11484
9D001640  00621021   ADDU V0, V1, V0
9D001644  8C430000   LW V1, 0(V0)
9D001648  3C02A000   LUI V0, -24576
9D00164C  24442CDC   ADDIU A0, V0, 11484
9D001650  24020030   ADDIU V0, ZERO, 48
9D001654  70A21002   MUL V0, A1, V0
9D001658  00821021   ADDU V0, A0, V0
9D00165C  AC43000C   SW V1, 12(V0)
1297:                	}
1298:                
1299:                	TCPRAMCopy(MyTCBStub.txHead, MyTCBStub.vMemoryMedium, (PTR_BASE)data, TCP_PIC_RAM, wActualLen);
9D001660  93828027   LBU V0, -32729(GP)
9D001664  00402021   ADDU A0, V0, ZERO
9D001668  3C02A000   LUI V0, -24576
9D00166C  24432CDC   ADDIU V1, V0, 11484
9D001670  24020030   ADDIU V0, ZERO, 48
9D001674  70821002   MUL V0, A0, V0
9D001678  00621021   ADDU V0, V1, V0
9D00167C  8C44000C   LW A0, 12(V0)
9D001680  93828027   LBU V0, -32729(GP)
9D001684  00402821   ADDU A1, V0, ZERO
9D001688  3C02A000   LUI V0, -24576
9D00168C  24030030   ADDIU V1, ZERO, 48
9D001690  70A31802   MUL V1, A1, V1
9D001694  24422CDC   ADDIU V0, V0, 11484
9D001698  00621021   ADDU V0, V1, V0
9D00169C  9042002C   LBU V0, 44(V0)
9D0016A0  00401821   ADDU V1, V0, ZERO
9D0016A4  8FC20034   LW V0, 52(S8)
9D0016A8  97C50018   LHU A1, 24(S8)
9D0016AC  AFA50010   SW A1, 16(SP)
9D0016B0  00602821   ADDU A1, V1, ZERO
9D0016B4  00403021   ADDU A2, V0, ZERO
9D0016B8  24070001   ADDIU A3, ZERO, 1
9D0016BC  0F4020BE   JAL TCPRAMCopy
9D0016C0  00000000   NOP
1300:                	MyTCBStub.txHead += wActualLen;
9D0016C4  93828027   LBU V0, -32729(GP)
9D0016C8  00402821   ADDU A1, V0, ZERO
9D0016CC  93828027   LBU V0, -32729(GP)
9D0016D0  00402021   ADDU A0, V0, ZERO
9D0016D4  3C02A000   LUI V0, -24576
9D0016D8  24432CDC   ADDIU V1, V0, 11484
9D0016DC  24020030   ADDIU V0, ZERO, 48
9D0016E0  70821002   MUL V0, A0, V0
9D0016E4  00621021   ADDU V0, V1, V0
9D0016E8  8C43000C   LW V1, 12(V0)
9D0016EC  97C20018   LHU V0, 24(S8)
9D0016F0  00621821   ADDU V1, V1, V0
9D0016F4  3C02A000   LUI V0, -24576
9D0016F8  24442CDC   ADDIU A0, V0, 11484
9D0016FC  24020030   ADDIU V0, ZERO, 48
9D001700  70A21002   MUL V0, A1, V0
9D001704  00821021   ADDU V0, A0, V0
9D001708  AC43000C   SW V1, 12(V0)
1301:                	#endif
1302:                
1303:                	// Send these bytes right now if we are out of TX buffer space
1304:                	if(wFreeTXSpace <= len)
9D00170C  97C3001C   LHU V1, 28(S8)
9D001710  97C20038   LHU V0, 56(S8)
9D001714  0043102B   SLTU V0, V0, V1
9D001718  14400007   BNE V0, ZERO, 0x9D001738
9D00171C  00000000   NOP
1305:                	{
1306:                		TCPFlush(hTCP);
9D001720  93C20030   LBU V0, 48(S8)
9D001724  00402021   ADDU A0, V0, ZERO
9D001728  0F400366   JAL TCPFlush
9D00172C  00000000   NOP
9D001730  0B4005F2   J 0x9D0017C8
9D001734  00000000   NOP
1307:                	}
1308:                	// If not already enabled, start a timer so this data will 
1309:                	// eventually get sent even if the application doens't call
1310:                	// TCPFlush()
1311:                	else if(!MyTCBStub.Flags.bTimer2Enabled)
9D001738  93828027   LBU V0, -32729(GP)
9D00173C  00402021   ADDU A0, V0, ZERO
9D001740  3C02A000   LUI V0, -24576
9D001744  24030030   ADDIU V1, ZERO, 48
9D001748  70831802   MUL V1, A0, V1
9D00174C  24422CDC   ADDIU V0, V0, 11484
9D001750  00621021   ADDU V0, V1, V0
9D001754  8C420028   LW V0, 40(V0)
9D001758  7C420140   EXT V0, V0, 5, 1
9D00175C  304200FF   ANDI V0, V0, 255
9D001760  14400019   BNE V0, ZERO, 0x9D0017C8
9D001764  00000000   NOP
1312:                	{
1313:                		MyTCBStub.Flags.bTimer2Enabled = TRUE;
9D001768  93828027   LBU V0, -32729(GP)
9D00176C  00402021   ADDU A0, V0, ZERO
9D001770  3C02A000   LUI V0, -24576
9D001774  24030030   ADDIU V1, ZERO, 48
9D001778  70831802   MUL V1, A0, V1
9D00177C  24422CDC   ADDIU V0, V0, 11484
9D001780  00621821   ADDU V1, V1, V0
9D001784  8C620028   LW V0, 40(V1)
9D001788  24040001   ADDIU A0, ZERO, 1
9D00178C  7C822944   INS V0, A0, 5, 1
9D001790  AC620028   SW V0, 40(V1)
1314:                		MyTCBStub.eventTime2 = (WORD)TickGetDiv256() + TCP_AUTO_TRANSMIT_TIMEOUT_VAL/256ull;
9D001794  93828027   LBU V0, -32729(GP)
9D001798  00408021   ADDU S0, V0, ZERO
9D00179C  0F40CDE4   JAL TickGetDiv256
9D0017A0  00000000   NOP
9D0017A4  3042FFFF   ANDI V0, V0, -1
9D0017A8  24420018   ADDIU V0, V0, 24
9D0017AC  3043FFFF   ANDI V1, V0, -1
9D0017B0  3C02A000   LUI V0, -24576
9D0017B4  24040030   ADDIU A0, ZERO, 48
9D0017B8  72042002   MUL A0, S0, A0
9D0017BC  24422CDC   ADDIU V0, V0, 11484
9D0017C0  00821021   ADDU V0, A0, V0
9D0017C4  A4430020   SH V1, 32(V0)
1315:                	}
1316:                
1317:                	return wActualLen + wRightLen;
9D0017C8  97C30018   LHU V1, 24(S8)
9D0017CC  97C2001A   LHU V0, 26(S8)
9D0017D0  00621021   ADDU V0, V1, V0
9D0017D4  3042FFFF   ANDI V0, V0, -1
1318:                }
9D0017D8  03C0E821   ADDU SP, S8, ZERO
9D0017DC  8FBF002C   LW RA, 44(SP)
9D0017E0  8FBE0028   LW S8, 40(SP)
9D0017E4  8FB00024   LW S0, 36(SP)
9D0017E8  27BD0030   ADDIU SP, SP, 48
9D0017EC  03E00008   JR RA
9D0017F0  00000000   NOP
1319:                
1320:                /*****************************************************************************
1321:                  Function:
1322:                	WORD TCPPutROMArray(TCP_SOCKET hTCP, ROM BYTE* data, WORD len)
1323:                
1324:                  Description:
1325:                	Writes an array from ROM to a TCP socket.
1326:                
1327:                  Precondition:
1328:                	TCP is initialized.
1329:                
1330:                  Parameters:
1331:                	hTCP - The socket to which data is to be written.
1332:                	data - Pointer to the array to be written.
1333:                	len  - Number of bytes to be written.
1334:                
1335:                  Returns:
1336:                	The number of bytes written to the socket.  If less than len, the
1337:                	buffer became full or the socket is not conected.
1338:                
1339:                  Remarks:
1340:                	This function is aliased to TCPPutArray on non-PIC18 platforms.
1341:                  ***************************************************************************/
1342:                #if defined(__18CXX)
1343:                WORD TCPPutROMArray(TCP_SOCKET hTCP, ROM BYTE* data, WORD len)
1344:                {
1345:                	WORD wActualLen;
1346:                	WORD wFreeTXSpace;
1347:                	WORD wRightLen = 0;
1348:                
1349:                	if(hTCP >= TCP_SOCKET_COUNT)
1350:                    {
1351:                        return 0;
1352:                    }
1353:                    
1354:                	SyncTCBStub(hTCP);
1355:                
1356:                	wFreeTXSpace = TCPIsPutReady(hTCP);
1357:                	if(wFreeTXSpace == 0u)
1358:                	{
1359:                		TCPFlush(hTCP);
1360:                		return 0;
1361:                	}
1362:                
1363:                	// Send all current bytes if we are crossing half full
1364:                	// This is required to improve performance with the delayed 
1365:                	// acknowledgement algorithm
1366:                	if((!MyTCBStub.Flags.bHalfFullFlush) && (wFreeTXSpace <= ((MyTCBStub.bufferRxStart-MyTCBStub.bufferTxStart)>>1)))
1367:                	{
1368:                		TCPFlush(hTCP);	
1369:                		MyTCBStub.Flags.bHalfFullFlush = TRUE;
1370:                	}
1371:                	
1372:                	wActualLen = wFreeTXSpace;
1373:                	if(wFreeTXSpace > len)
1374:                		wActualLen = len;
1375:                	
1376:                	#if defined(STACK_USE_SSL)
1377:                	if(MyTCBStub.sslStubID != SSL_INVALID_ID)
1378:                	{
1379:                		// See if we need a two part put
1380:                		if(MyTCBStub.sslTxHead + wActualLen >= MyTCBStub.bufferRxStart)
1381:                		{
1382:                			wRightLen = MyTCBStub.bufferRxStart-MyTCBStub.sslTxHead;
1383:                			TCPRAMCopyROM(MyTCBStub.sslTxHead, MyTCBStub.vMemoryMedium, data, wRightLen);
1384:                			data += wRightLen;
1385:                			wActualLen -= wRightLen;
1386:                			MyTCBStub.sslTxHead = MyTCBStub.bufferTxStart;
1387:                		}
1388:                	
1389:                		TCPRAMCopyROM(MyTCBStub.sslTxHead, MyTCBStub.vMemoryMedium, data, wActualLen);
1390:                		MyTCBStub.sslTxHead += wActualLen;
1391:                	}
1392:                	else
1393:                	{
1394:                		// See if we need a two part put
1395:                		if(MyTCBStub.txHead + wActualLen >= MyTCBStub.bufferRxStart)
1396:                		{
1397:                			wRightLen = MyTCBStub.bufferRxStart-MyTCBStub.txHead;
1398:                			TCPRAMCopyROM(MyTCBStub.txHead, MyTCBStub.vMemoryMedium, data, wRightLen);
1399:                			data += wRightLen;
1400:                			wActualLen -= wRightLen;
1401:                			MyTCBStub.txHead = MyTCBStub.bufferTxStart;
1402:                		}
1403:                	
1404:                		TCPRAMCopyROM(MyTCBStub.txHead, MyTCBStub.vMemoryMedium, data, wActualLen);
1405:                		MyTCBStub.txHead += wActualLen;
1406:                	}
1407:                	#else
1408:                	// See if we need a two part put
1409:                	if(MyTCBStub.txHead + wActualLen >= MyTCBStub.bufferRxStart)
1410:                	{
1411:                		wRightLen = MyTCBStub.bufferRxStart-MyTCBStub.txHead;
1412:                		TCPRAMCopyROM(MyTCBStub.txHead, MyTCBStub.vMemoryMedium, data, wRightLen);
1413:                		data += wRightLen;
1414:                		wActualLen -= wRightLen;
1415:                		MyTCBStub.txHead = MyTCBStub.bufferTxStart;
1416:                	}
1417:                
1418:                	TCPRAMCopyROM(MyTCBStub.txHead, MyTCBStub.vMemoryMedium, data, wActualLen);
1419:                	MyTCBStub.txHead += wActualLen;
1420:                	#endif
1421:                
1422:                	// Send these bytes right now if we are out of TX buffer space
1423:                	if(wFreeTXSpace <= len)
1424:                	{
1425:                		TCPFlush(hTCP);
1426:                	}
1427:                	// If not already enabled, start a timer so this data will 
1428:                	// eventually get sent even if the application doens't call
1429:                	// TCPFlush()
1430:                	else if(!MyTCBStub.Flags.bTimer2Enabled)
1431:                	{
1432:                		MyTCBStub.Flags.bTimer2Enabled = TRUE;
1433:                		MyTCBStub.eventTime2 = (WORD)TickGetDiv256() + TCP_AUTO_TRANSMIT_TIMEOUT_VAL/256ull;
1434:                	}
1435:                
1436:                	return wActualLen + wRightLen;
1437:                }
1438:                #endif
1439:                
1440:                /*****************************************************************************
1441:                  Function:
1442:                	BYTE* TCPPutString(TCP_SOCKET hTCP, BYTE* data)
1443:                
1444:                  Description:
1445:                	Writes a null-terminated string from RAM to a TCP socket.  The 
1446:                	null-terminator is not copied to the socket.
1447:                
1448:                  Precondition:
1449:                	TCP is initialized.
1450:                
1451:                  Parameters:
1452:                	hTCP - The socket to which data is to be written.
1453:                	data - Pointer to the string to be written.
1454:                
1455:                  Returns:
1456:                	Pointer to the byte following the last byte written to the socket.  If
1457:                	this pointer does not dereference to a NUL byte, the buffer became full
1458:                	or the socket is not connected.
1459:                
1460:                  Remarks:
1461:                	The return value of this function differs from that of TCPPutArray.  To
1462:                	write long strings in a single state, initialize the *data pointer to the
1463:                	first byte, then call this function repeatedly (breaking to the main 
1464:                	stack loop after each call) until the return value dereferences to a NUL
1465:                	byte.  Save the return value as the new starting *data pointer otherwise.
1466:                  ***************************************************************************/
1467:                BYTE* TCPPutString(TCP_SOCKET hTCP, BYTE* data)
1468:                {
9D0017F4  27BDFFE0   ADDIU SP, SP, -32
9D0017F8  AFBF001C   SW RA, 28(SP)
9D0017FC  AFBE0018   SW S8, 24(SP)
9D001800  AFB00014   SW S0, 20(SP)
9D001804  03A0F021   ADDU S8, SP, ZERO
9D001808  00801021   ADDU V0, A0, ZERO
9D00180C  AFC50024   SW A1, 36(S8)
9D001810  A3C20020   SB V0, 32(S8)
1469:                	return data + TCPPutArray(hTCP, data, strlen((char*)data));
9D001814  93D00020   LBU S0, 32(S8)
9D001818  8FC20024   LW V0, 36(S8)
9D00181C  00402021   ADDU A0, V0, ZERO
9D001820  0F40D2F2   JAL 0x9D034BC8
9D001824  00000000   NOP
9D001828  3042FFFF   ANDI V0, V0, -1
9D00182C  02002021   ADDU A0, S0, ZERO
9D001830  8FC50024   LW A1, 36(S8)
9D001834  00403021   ADDU A2, V0, ZERO
9D001838  0F4004E1   JAL TCPPutArray
9D00183C  00000000   NOP
9D001840  8FC30024   LW V1, 36(S8)
9D001844  00621021   ADDU V0, V1, V0
1470:                }
9D001848  03C0E821   ADDU SP, S8, ZERO
9D00184C  8FBF001C   LW RA, 28(SP)
9D001850  8FBE0018   LW S8, 24(SP)
9D001854  8FB00014   LW S0, 20(SP)
9D001858  27BD0020   ADDIU SP, SP, 32
9D00185C  03E00008   JR RA
9D001860  00000000   NOP
1471:                
1472:                /*****************************************************************************
1473:                  Function:
1474:                	BYTE* TCPPutROMString(TCP_SOCKET hTCP, ROM BYTE* data)
1475:                
1476:                  Description:
1477:                	Writes a null-terminated string from ROM to a TCP socket.  The 
1478:                	null-terminator is not copied to the socket.
1479:                
1480:                  Precondition:
1481:                	TCP is initialized.
1482:                
1483:                  Parameters:
1484:                	hTCP - The socket to which data is to be written.
1485:                	data - Pointer to the string to be written.
1486:                
1487:                  Returns:
1488:                	Pointer to the byte following the last byte written to the socket.  If
1489:                	this pointer does not dereference to a NUL byte, the buffer became full
1490:                	or the socket is not connected.
1491:                
1492:                  Remarks:
1493:                	The return value of this function differs from that of TCPPutArray.  To
1494:                	write long strings in a single state, initialize the *data pointer to the
1495:                	first byte, then call this function repeatedly (breaking to the main 
1496:                	stack loop after each call) until the return value dereferences to a NUL
1497:                	byte.  Save the return value as the new starting *data pointer otherwise.
1498:                	
1499:                	This function is aliased to TCPPutString on non-PIC18 platforms.
1500:                  ***************************************************************************/
1501:                #if defined(__18CXX)
1502:                ROM BYTE* TCPPutROMString(TCP_SOCKET hTCP, ROM BYTE* data)
1503:                {
1504:                	return data + TCPPutROMArray(hTCP, data, strlenpgm((ROM char*)data));
1505:                }
1506:                #endif
1507:                
1508:                /*****************************************************************************
1509:                  Function:
1510:                	WORD TCPGetTxFIFOFull(TCP_SOCKET hTCP)
1511:                
1512:                  Description:
1513:                	Determines how many bytes are pending in the TCP TX FIFO.
1514:                
1515:                  Precondition:
1516:                	TCP is initialized.
1517:                
1518:                  Parameters:
1519:                	hTCP - The socket to check.
1520:                
1521:                  Returns:
1522:                	Number of bytes pending to be flushed in the TCP TX FIFO.
1523:                  ***************************************************************************/
1524:                WORD TCPGetTxFIFOFull(TCP_SOCKET hTCP)
1525:                {
9D001864  27BDFFE0   ADDIU SP, SP, -32
9D001868  AFBF001C   SW RA, 28(SP)
9D00186C  AFBE0018   SW S8, 24(SP)
9D001870  03A0F021   ADDU S8, SP, ZERO
9D001874  00801021   ADDU V0, A0, ZERO
9D001878  A3C20020   SB V0, 32(S8)
1526:                	WORD wDataLen;
1527:                	WORD wFIFOSize;
1528:                
1529:                	if(hTCP >= TCP_SOCKET_COUNT)
9D00187C  93C20020   LBU V0, 32(S8)
9D001880  2C420009   SLTIU V0, V0, 9
9D001884  14400004   BNE V0, ZERO, 0x9D001898
9D001888  00000000   NOP
1530:                    {
1531:                        return 0;
9D00188C  00001021   ADDU V0, ZERO, ZERO
9D001890  0B400647   J 0x9D00191C
9D001894  00000000   NOP
1532:                    }
1533:                    
1534:                	SyncTCBStub(hTCP);
9D001898  93C20020   LBU V0, 32(S8)
9D00189C  A3828027   SB V0, -32729(GP)
1535:                
1536:                	// Calculate total usable FIFO size
1537:                	wFIFOSize = MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart - 1;
9D0018A0  93828027   LBU V0, -32729(GP)
9D0018A4  00402021   ADDU A0, V0, ZERO
9D0018A8  3C02A000   LUI V0, -24576
9D0018AC  24432CDC   ADDIU V1, V0, 11484
9D0018B0  24020030   ADDIU V0, ZERO, 48
9D0018B4  70821002   MUL V0, A0, V0
9D0018B8  00621021   ADDU V0, V1, V0
9D0018BC  8C420004   LW V0, 4(V0)
9D0018C0  3043FFFF   ANDI V1, V0, -1
9D0018C4  93828027   LBU V0, -32729(GP)
9D0018C8  00402821   ADDU A1, V0, ZERO
9D0018CC  3C02A000   LUI V0, -24576
9D0018D0  24040030   ADDIU A0, ZERO, 48
9D0018D4  70A42002   MUL A0, A1, A0
9D0018D8  24422CDC   ADDIU V0, V0, 11484
9D0018DC  00821021   ADDU V0, A0, V0
9D0018E0  8C420000   LW V0, 0(V0)
9D0018E4  3042FFFF   ANDI V0, V0, -1
9D0018E8  00621023   SUBU V0, V1, V0
9D0018EC  3042FFFF   ANDI V0, V0, -1
9D0018F0  2442FFFF   ADDIU V0, V0, -1
9D0018F4  A7C20010   SH V0, 16(S8)
1538:                
1539:                	// Find out how many data bytes are free in the TX FIFO
1540:                	wDataLen = TCPIsPutReady(hTCP);
9D0018F8  93C20020   LBU V0, 32(S8)
9D0018FC  00402021   ADDU A0, V0, ZERO
9D001900  0F40038E   JAL TCPIsPutReady
9D001904  00000000   NOP
9D001908  A7C20012   SH V0, 18(S8)
1541:                
1542:                	return wFIFOSize - wDataLen;
9D00190C  97C30010   LHU V1, 16(S8)
9D001910  97C20012   LHU V0, 18(S8)
9D001914  00621023   SUBU V0, V1, V0
9D001918  3042FFFF   ANDI V0, V0, -1
1543:                }
9D00191C  03C0E821   ADDU SP, S8, ZERO
9D001920  8FBF001C   LW RA, 28(SP)
9D001924  8FBE0018   LW S8, 24(SP)
9D001928  27BD0020   ADDIU SP, SP, 32
9D00192C  03E00008   JR RA
9D001930  00000000   NOP
1544:                
1545:                
1546:                
1547:                /****************************************************************************
1548:                  Section:
1549:                	Receive Functions
1550:                  ***************************************************************************/
1551:                
1552:                /*****************************************************************************
1553:                  Function:
1554:                	void TCPDiscard(TCP_SOCKET hTCP)
1555:                
1556:                  Description:
1557:                	Discards any pending data in the TCP RX FIFO.
1558:                
1559:                  Precondition:
1560:                	TCP is initialized.
1561:                
1562:                  Parameters:
1563:                	hTCP - The socket whose RX FIFO is to be cleared.
1564:                
1565:                  Returns:
1566:                	None
1567:                  ***************************************************************************/
1568:                void TCPDiscard(TCP_SOCKET hTCP)
1569:                {
9D001934  27BDFFE8   ADDIU SP, SP, -24
9D001938  AFBF0014   SW RA, 20(SP)
9D00193C  AFBE0010   SW S8, 16(SP)
9D001940  03A0F021   ADDU S8, SP, ZERO
9D001944  00801021   ADDU V0, A0, ZERO
9D001948  A3C20018   SB V0, 24(S8)
1570:                	if(TCPIsGetReady(hTCP))
9D00194C  93C20018   LBU V0, 24(S8)
9D001950  00402021   ADDU A0, V0, ZERO
9D001954  0F400675   JAL TCPIsGetReady
9D001958  00000000   NOP
9D00195C  10400017   BEQ V0, ZERO, 0x9D0019BC
9D001960  00000000   NOP
1571:                	{
1572:                		SyncTCBStub(hTCP);
9D001964  93C20018   LBU V0, 24(S8)
9D001968  A3828027   SB V0, -32729(GP)
1573:                	
1574:                		// Delete all data in the RX buffer
1575:                		MyTCBStub.rxTail = MyTCBStub.rxHead;
9D00196C  93828027   LBU V0, -32729(GP)
9D001970  00402821   ADDU A1, V0, ZERO
9D001974  93828027   LBU V0, -32729(GP)
9D001978  00402021   ADDU A0, V0, ZERO
9D00197C  3C02A000   LUI V0, -24576
9D001980  24432CDC   ADDIU V1, V0, 11484
9D001984  24020030   ADDIU V0, ZERO, 48
9D001988  70821002   MUL V0, A0, V0
9D00198C  00621021   ADDU V0, V1, V0
9D001990  8C430014   LW V1, 20(V0)
9D001994  3C02A000   LUI V0, -24576
9D001998  24040030   ADDIU A0, ZERO, 48
9D00199C  70A42002   MUL A0, A1, A0
9D0019A0  24422CDC   ADDIU V0, V0, 11484
9D0019A4  00821021   ADDU V0, A0, V0
9D0019A8  AC430018   SW V1, 24(V0)
1576:                	
1577:                		// Send a Window update message to the remote node
1578:                		SendTCP(ACK, SENDTCP_RESET_TIMERS);
9D0019AC  24040010   ADDIU A0, ZERO, 16
9D0019B0  24050001   ADDIU A1, ZERO, 1
9D0019B4  0F400F8B   JAL SendTCP
9D0019B8  00000000   NOP
1579:                	}
1580:                }
9D0019BC  03C0E821   ADDU SP, S8, ZERO
9D0019C0  8FBF0014   LW RA, 20(SP)
9D0019C4  8FBE0010   LW S8, 16(SP)
9D0019C8  27BD0018   ADDIU SP, SP, 24
9D0019CC  03E00008   JR RA
9D0019D0  00000000   NOP
1581:                
1582:                
1583:                /*****************************************************************************
1584:                  Function:
1585:                	void WORD TCPIsGetReady(TCP_SOCKET hTCP)
1586:                
1587:                  Summary:
1588:                	Determines how many bytes can be read from the TCP RX buffer.
1589:                
1590:                  Description:
1591:                	Call this function to determine how many bytes can be read from the 
1592:                	TCP RX buffer.  If this function returns zero, the application must 
1593:                	return to the main stack loop before continuing in order to wait for
1594:                	more data to arrive.
1595:                
1596:                  Precondition:
1597:                	TCP is initialized.
1598:                
1599:                  Parameters:
1600:                	hTCP - The socket to check.
1601:                
1602:                  Returns:
1603:                	The number of bytes available to be read from the TCP RX buffer.
1604:                  ***************************************************************************/
1605:                WORD TCPIsGetReady(TCP_SOCKET hTCP)
1606:                {
9D0019D4  27BDFFF8   ADDIU SP, SP, -8
9D0019D8  AFBE0004   SW S8, 4(SP)
9D0019DC  03A0F021   ADDU S8, SP, ZERO
9D0019E0  00801021   ADDU V0, A0, ZERO
9D0019E4  A3C20008   SB V0, 8(S8)
1607:                	if(hTCP >= TCP_SOCKET_COUNT)
9D0019E8  93C20008   LBU V0, 8(S8)
9D0019EC  2C420009   SLTIU V0, V0, 9
9D0019F0  14400004   BNE V0, ZERO, 0x9D001A04
9D0019F4  00000000   NOP
1608:                    {
1609:                        return 0;
9D0019F8  00001021   ADDU V0, ZERO, ZERO
9D0019FC  0B4006D8   J 0x9D001B60
9D001A00  00000000   NOP
1610:                    }
1611:                    
1612:                	SyncTCBStub(hTCP);
9D001A04  93C20008   LBU V0, 8(S8)
9D001A08  A3828027   SB V0, -32729(GP)
1613:                		
1614:                	if(MyTCBStub.rxHead >= MyTCBStub.rxTail)
9D001A0C  93828027   LBU V0, -32729(GP)
9D001A10  00402021   ADDU A0, V0, ZERO
9D001A14  3C02A000   LUI V0, -24576
9D001A18  24432CDC   ADDIU V1, V0, 11484
9D001A1C  24020030   ADDIU V0, ZERO, 48
9D001A20  70821002   MUL V0, A0, V0
9D001A24  00621021   ADDU V0, V1, V0
9D001A28  8C430014   LW V1, 20(V0)
9D001A2C  93828027   LBU V0, -32729(GP)
9D001A30  00402821   ADDU A1, V0, ZERO
9D001A34  3C02A000   LUI V0, -24576
9D001A38  24040030   ADDIU A0, ZERO, 48
9D001A3C  70A42002   MUL A0, A1, A0
9D001A40  24422CDC   ADDIU V0, V0, 11484
9D001A44  00821021   ADDU V0, A0, V0
9D001A48  8C420018   LW V0, 24(V0)
9D001A4C  0062102B   SLTU V0, V1, V0
9D001A50  14400017   BNE V0, ZERO, 0x9D001AB0
9D001A54  00000000   NOP
1615:                		return MyTCBStub.rxHead - MyTCBStub.rxTail;
9D001A58  93828027   LBU V0, -32729(GP)
9D001A5C  00402021   ADDU A0, V0, ZERO
9D001A60  3C02A000   LUI V0, -24576
9D001A64  24432CDC   ADDIU V1, V0, 11484
9D001A68  24020030   ADDIU V0, ZERO, 48
9D001A6C  70821002   MUL V0, A0, V0
9D001A70  00621021   ADDU V0, V1, V0
9D001A74  8C420014   LW V0, 20(V0)
9D001A78  3043FFFF   ANDI V1, V0, -1
9D001A7C  93828027   LBU V0, -32729(GP)
9D001A80  00402821   ADDU A1, V0, ZERO
9D001A84  3C02A000   LUI V0, -24576
9D001A88  24040030   ADDIU A0, ZERO, 48
9D001A8C  70A42002   MUL A0, A1, A0
9D001A90  24422CDC   ADDIU V0, V0, 11484
9D001A94  00821021   ADDU V0, A0, V0
9D001A98  8C420018   LW V0, 24(V0)
9D001A9C  3042FFFF   ANDI V0, V0, -1
9D001AA0  00621023   SUBU V0, V1, V0
9D001AA4  3042FFFF   ANDI V0, V0, -1
9D001AA8  0B4006D8   J 0x9D001B60
9D001AAC  00000000   NOP
1616:                	else
1617:                		return (MyTCBStub.bufferEnd - MyTCBStub.rxTail + 1) + (MyTCBStub.rxHead - MyTCBStub.bufferRxStart);
9D001AB0  93828027   LBU V0, -32729(GP)
9D001AB4  00402021   ADDU A0, V0, ZERO
9D001AB8  3C02A000   LUI V0, -24576
9D001ABC  24030030   ADDIU V1, ZERO, 48
9D001AC0  70831802   MUL V1, A0, V1
9D001AC4  24422CDC   ADDIU V0, V0, 11484
9D001AC8  00621021   ADDU V0, V1, V0
9D001ACC  8C420008   LW V0, 8(V0)
9D001AD0  3043FFFF   ANDI V1, V0, -1
9D001AD4  93828027   LBU V0, -32729(GP)
9D001AD8  00402821   ADDU A1, V0, ZERO
9D001ADC  3C02A000   LUI V0, -24576
9D001AE0  24040030   ADDIU A0, ZERO, 48
9D001AE4  70A42002   MUL A0, A1, A0
9D001AE8  24422CDC   ADDIU V0, V0, 11484
9D001AEC  00821021   ADDU V0, A0, V0
9D001AF0  8C420018   LW V0, 24(V0)
9D001AF4  3042FFFF   ANDI V0, V0, -1
9D001AF8  00621023   SUBU V0, V1, V0
9D001AFC  3043FFFF   ANDI V1, V0, -1
9D001B00  93828027   LBU V0, -32729(GP)
9D001B04  00402821   ADDU A1, V0, ZERO
9D001B08  3C02A000   LUI V0, -24576
9D001B0C  24442CDC   ADDIU A0, V0, 11484
9D001B10  24020030   ADDIU V0, ZERO, 48
9D001B14  70A21002   MUL V0, A1, V0
9D001B18  00821021   ADDU V0, A0, V0
9D001B1C  8C420014   LW V0, 20(V0)
9D001B20  3044FFFF   ANDI A0, V0, -1
9D001B24  93828027   LBU V0, -32729(GP)
9D001B28  00403021   ADDU A2, V0, ZERO
9D001B2C  3C02A000   LUI V0, -24576
9D001B30  24452CDC   ADDIU A1, V0, 11484
9D001B34  24020030   ADDIU V0, ZERO, 48
9D001B38  70C21002   MUL V0, A2, V0
9D001B3C  00A21021   ADDU V0, A1, V0
9D001B40  8C420004   LW V0, 4(V0)
9D001B44  3042FFFF   ANDI V0, V0, -1
9D001B48  00821023   SUBU V0, A0, V0
9D001B4C  3042FFFF   ANDI V0, V0, -1
9D001B50  00621021   ADDU V0, V1, V0
9D001B54  3042FFFF   ANDI V0, V0, -1
9D001B58  24420001   ADDIU V0, V0, 1
9D001B5C  3042FFFF   ANDI V0, V0, -1
1618:                }
9D001B60  03C0E821   ADDU SP, S8, ZERO
9D001B64  8FBE0004   LW S8, 4(SP)
9D001B68  27BD0008   ADDIU SP, SP, 8
9D001B6C  03E00008   JR RA
9D001B70  00000000   NOP
1619:                
1620:                
1621:                /*****************************************************************************
1622:                  Function:
1623:                	BOOL TCPGet(TCP_SOCKET hTCP, BYTE* byte)
1624:                
1625:                  Description:
1626:                	Retrieves a single byte to a TCP socket.
1627:                
1628:                  Precondition:
1629:                	TCP is initialized.
1630:                
1631:                  Parameters:
1632:                	hTCP - The socket from which to read.
1633:                	byte - Pointer to location in which the read byte should be stored.
1634:                
1635:                  Return Values:
1636:                	TRUE - A byte was read from the buffer.
1637:                	FALSE - The buffer was empty, or the socket is not connected.
1638:                  ***************************************************************************/
1639:                BOOL TCPGet(TCP_SOCKET hTCP, BYTE* byte)
1640:                {
9D001B74  27BDFFD0   ADDIU SP, SP, -48
9D001B78  AFBF002C   SW RA, 44(SP)
9D001B7C  AFBE0028   SW S8, 40(SP)
9D001B80  AFB00024   SW S0, 36(SP)
9D001B84  03A0F021   ADDU S8, SP, ZERO
9D001B88  00801021   ADDU V0, A0, ZERO
9D001B8C  AFC50034   SW A1, 52(S8)
9D001B90  A3C20030   SB V0, 48(S8)
1641:                	WORD wGetReadyCount;
1642:                
1643:                	// See if there is any data which can be read
1644:                	wGetReadyCount = TCPIsGetReady(hTCP);
9D001B94  93C20030   LBU V0, 48(S8)
9D001B98  00402021   ADDU A0, V0, ZERO
9D001B9C  0F400675   JAL TCPIsGetReady
9D001BA0  00000000   NOP
9D001BA4  A7C20018   SH V0, 24(S8)
1645:                	if(wGetReadyCount == 0u)
9D001BA8  97C20018   LHU V0, 24(S8)
9D001BAC  14400004   BNE V0, ZERO, 0x9D001BC0
9D001BB0  00000000   NOP
1646:                		return FALSE;
9D001BB4  00001021   ADDU V0, ZERO, ZERO
9D001BB8  0B400773   J 0x9D001DCC
9D001BBC  00000000   NOP
1647:                
1648:                	SyncTCBStub(hTCP);
9D001BC0  93C20030   LBU V0, 48(S8)
9D001BC4  A3828027   SB V0, -32729(GP)
1649:                	
1650:                	if(byte)
9D001BC8  8FC20034   LW V0, 52(S8)
9D001BCC  10400019   BEQ V0, ZERO, 0x9D001C34
9D001BD0  00000000   NOP
1651:                		TCPRAMCopy((PTR_BASE)byte, TCP_PIC_RAM, MyTCBStub.rxTail, MyTCBStub.vMemoryMedium, 1);
9D001BD4  8FC40034   LW A0, 52(S8)
9D001BD8  93828027   LBU V0, -32729(GP)
9D001BDC  00402821   ADDU A1, V0, ZERO
9D001BE0  3C02A000   LUI V0, -24576
9D001BE4  24030030   ADDIU V1, ZERO, 48
9D001BE8  70A31802   MUL V1, A1, V1
9D001BEC  24422CDC   ADDIU V0, V0, 11484
9D001BF0  00621021   ADDU V0, V1, V0
9D001BF4  8C430018   LW V1, 24(V0)
9D001BF8  93828027   LBU V0, -32729(GP)
9D001BFC  00403021   ADDU A2, V0, ZERO
9D001C00  3C02A000   LUI V0, -24576
9D001C04  24050030   ADDIU A1, ZERO, 48
9D001C08  70C52802   MUL A1, A2, A1
9D001C0C  24422CDC   ADDIU V0, V0, 11484
9D001C10  00A21021   ADDU V0, A1, V0
9D001C14  9042002C   LBU V0, 44(V0)
9D001C18  24050001   ADDIU A1, ZERO, 1
9D001C1C  AFA50010   SW A1, 16(SP)
9D001C20  24050001   ADDIU A1, ZERO, 1
9D001C24  00603021   ADDU A2, V1, ZERO
9D001C28  00403821   ADDU A3, V0, ZERO
9D001C2C  0F4020BE   JAL TCPRAMCopy
9D001C30  00000000   NOP
1652:                	if(++MyTCBStub.rxTail > MyTCBStub.bufferEnd)
9D001C34  93828027   LBU V0, -32729(GP)
9D001C38  00402021   ADDU A0, V0, ZERO
9D001C3C  3C02A000   LUI V0, -24576
9D001C40  24030030   ADDIU V1, ZERO, 48
9D001C44  70831802   MUL V1, A0, V1
9D001C48  24422CDC   ADDIU V0, V0, 11484
9D001C4C  00621021   ADDU V0, V1, V0
9D001C50  8C420018   LW V0, 24(V0)
9D001C54  24430001   ADDIU V1, V0, 1
9D001C58  3C02A000   LUI V0, -24576
9D001C5C  24050030   ADDIU A1, ZERO, 48
9D001C60  70852802   MUL A1, A0, A1
9D001C64  24422CDC   ADDIU V0, V0, 11484
9D001C68  00A21021   ADDU V0, A1, V0
9D001C6C  AC430018   SW V1, 24(V0)
9D001C70  3C02A000   LUI V0, -24576
9D001C74  24030030   ADDIU V1, ZERO, 48
9D001C78  70831802   MUL V1, A0, V1
9D001C7C  24422CDC   ADDIU V0, V0, 11484
9D001C80  00621021   ADDU V0, V1, V0
9D001C84  8C430018   LW V1, 24(V0)
9D001C88  93828027   LBU V0, -32729(GP)
9D001C8C  00402821   ADDU A1, V0, ZERO
9D001C90  3C02A000   LUI V0, -24576
9D001C94  24040030   ADDIU A0, ZERO, 48
9D001C98  70A42002   MUL A0, A1, A0
9D001C9C  24422CDC   ADDIU V0, V0, 11484
9D001CA0  00821021   ADDU V0, A0, V0
9D001CA4  8C420008   LW V0, 8(V0)
9D001CA8  0043102B   SLTU V0, V0, V1
9D001CAC  10400011   BEQ V0, ZERO, 0x9D001CF4
9D001CB0  00000000   NOP
1653:                		MyTCBStub.rxTail = MyTCBStub.bufferRxStart;
9D001CB4  93828027   LBU V0, -32729(GP)
9D001CB8  00402821   ADDU A1, V0, ZERO
9D001CBC  93828027   LBU V0, -32729(GP)
9D001CC0  00402021   ADDU A0, V0, ZERO
9D001CC4  3C02A000   LUI V0, -24576
9D001CC8  24432CDC   ADDIU V1, V0, 11484
9D001CCC  24020030   ADDIU V0, ZERO, 48
9D001CD0  70821002   MUL V0, A0, V0
9D001CD4  00621021   ADDU V0, V1, V0
9D001CD8  8C430004   LW V1, 4(V0)
9D001CDC  3C02A000   LUI V0, -24576
9D001CE0  24040030   ADDIU A0, ZERO, 48
9D001CE4  70A42002   MUL A0, A1, A0
9D001CE8  24422CDC   ADDIU V0, V0, 11484
9D001CEC  00821021   ADDU V0, A0, V0
9D001CF0  AC430018   SW V1, 24(V0)
1654:                
1655:                	// Send a window update if we've run out of data
1656:                	if(wGetReadyCount == 1u)
9D001CF4  97C30018   LHU V1, 24(S8)
9D001CF8  24020001   ADDIU V0, ZERO, 1
9D001CFC  1462000E   BNE V1, V0, 0x9D001D38
9D001D00  00000000   NOP
1657:                	{
1658:                		MyTCBStub.Flags.bTXASAPWithoutTimerReset = 1;
9D001D04  93828027   LBU V0, -32729(GP)
9D001D08  00402021   ADDU A0, V0, ZERO
9D001D0C  3C02A000   LUI V0, -24576
9D001D10  24030030   ADDIU V1, ZERO, 48
9D001D14  70831802   MUL V1, A0, V1
9D001D18  24422CDC   ADDIU V0, V0, 11484
9D001D1C  00621821   ADDU V1, V1, V0
9D001D20  8C620028   LW V0, 40(V1)
9D001D24  24040001   ADDIU A0, ZERO, 1
9D001D28  7C825284   INS V0, A0, 10, 1
9D001D2C  AC620028   SW V0, 40(V1)
9D001D30  0B400772   J 0x9D001DC8
9D001D34  00000000   NOP
1659:                	}
1660:                	// If not already enabled, start a timer so a window 
1661:                	// update will get sent to the remote node at some point
1662:                	else if(!MyTCBStub.Flags.bTimer2Enabled)
9D001D38  93828027   LBU V0, -32729(GP)
9D001D3C  00402021   ADDU A0, V0, ZERO
9D001D40  3C02A000   LUI V0, -24576
9D001D44  24030030   ADDIU V1, ZERO, 48
9D001D48  70831802   MUL V1, A0, V1
9D001D4C  24422CDC   ADDIU V0, V0, 11484
9D001D50  00621021   ADDU V0, V1, V0
9D001D54  8C420028   LW V0, 40(V0)
9D001D58  7C420140   EXT V0, V0, 5, 1
9D001D5C  304200FF   ANDI V0, V0, 255
9D001D60  14400019   BNE V0, ZERO, 0x9D001DC8
9D001D64  00000000   NOP
1663:                	{
1664:                		MyTCBStub.Flags.bTimer2Enabled = TRUE;
9D001D68  93828027   LBU V0, -32729(GP)
9D001D6C  00402021   ADDU A0, V0, ZERO
9D001D70  3C02A000   LUI V0, -24576
9D001D74  24030030   ADDIU V1, ZERO, 48
9D001D78  70831802   MUL V1, A0, V1
9D001D7C  24422CDC   ADDIU V0, V0, 11484
9D001D80  00621821   ADDU V1, V1, V0
9D001D84  8C620028   LW V0, 40(V1)
9D001D88  24040001   ADDIU A0, ZERO, 1
9D001D8C  7C822944   INS V0, A0, 5, 1
9D001D90  AC620028   SW V0, 40(V1)
1665:                		MyTCBStub.eventTime2 = (WORD)TickGetDiv256() + TCP_WINDOW_UPDATE_TIMEOUT_VAL/256ull;
9D001D94  93828027   LBU V0, -32729(GP)
9D001D98  00408021   ADDU S0, V0, ZERO
9D001D9C  0F40CDE4   JAL TickGetDiv256
9D001DA0  00000000   NOP
9D001DA4  3042FFFF   ANDI V0, V0, -1
9D001DA8  2442007A   ADDIU V0, V0, 122
9D001DAC  3043FFFF   ANDI V1, V0, -1
9D001DB0  3C02A000   LUI V0, -24576
9D001DB4  24040030   ADDIU A0, ZERO, 48
9D001DB8  72042002   MUL A0, S0, A0
9D001DBC  24422CDC   ADDIU V0, V0, 11484
9D001DC0  00821021   ADDU V0, A0, V0
9D001DC4  A4430020   SH V1, 32(V0)
1666:                	}
1667:                
1668:                
1669:                	return TRUE;
9D001DC8  24020001   ADDIU V0, ZERO, 1
1670:                }
9D001DCC  03C0E821   ADDU SP, S8, ZERO
9D001DD0  8FBF002C   LW RA, 44(SP)
9D001DD4  8FBE0028   LW S8, 40(SP)
9D001DD8  8FB00024   LW S0, 36(SP)
9D001DDC  27BD0030   ADDIU SP, SP, 48
9D001DE0  03E00008   JR RA
9D001DE4  00000000   NOP
1671:                
1672:                
1673:                /*****************************************************************************
1674:                  Function:
1675:                	WORD TCPGetArray(TCP_SOCKET hTCP, BYTE* buffer, WORD len)
1676:                
1677:                  Description:
1678:                	Reads an array of data bytes from a TCP socket's receive FIFO.  The data 
1679:                	is removed from the FIFO in the process.
1680:                
1681:                  Precondition:
1682:                	TCP is initialized.
1683:                
1684:                  Parameters:
1685:                	hTCP - The socket from which data is to be read.
1686:                	buffer - Pointer to the array to store data that was read.
1687:                	len  - Number of bytes to be read.
1688:                
1689:                  Returns:
1690:                	The number of bytes read from the socket.  If less than len, the
1691:                	RX FIFO buffer became empty or the socket is not conected.
1692:                  ***************************************************************************/
1693:                WORD TCPGetArray(TCP_SOCKET hTCP, BYTE* buffer, WORD len)
1694:                {
9D001DE8  27BDFFD0   ADDIU SP, SP, -48
9D001DEC  AFBF002C   SW RA, 44(SP)
9D001DF0  AFBE0028   SW S8, 40(SP)
9D001DF4  AFB00024   SW S0, 36(SP)
9D001DF8  03A0F021   ADDU S8, SP, ZERO
9D001DFC  00801821   ADDU V1, A0, ZERO
9D001E00  AFC50034   SW A1, 52(S8)
9D001E04  00C01021   ADDU V0, A2, ZERO
9D001E08  A3C30030   SB V1, 48(S8)
9D001E0C  A7C20038   SH V0, 56(S8)
1695:                	WORD wGetReadyCount;
1696:                	WORD RightLen = 0;
9D001E10  A7C00018   SH ZERO, 24(S8)
1697:                
1698:                	// See if there is any data which can be read
1699:                	wGetReadyCount = TCPIsGetReady(hTCP);
9D001E14  93C20030   LBU V0, 48(S8)
9D001E18  00402021   ADDU A0, V0, ZERO
9D001E1C  0F400675   JAL TCPIsGetReady
9D001E20  00000000   NOP
9D001E24  A7C2001A   SH V0, 26(S8)
1700:                	if(wGetReadyCount == 0u)
9D001E28  97C2001A   LHU V0, 26(S8)
9D001E2C  14400004   BNE V0, ZERO, 0x9D001E40
9D001E30  00000000   NOP
1701:                		return 0x0000u;
9D001E34  00001021   ADDU V0, ZERO, ZERO
9D001E38  0B400861   J 0x9D002184
9D001E3C  00000000   NOP
1702:                
1703:                	SyncTCBStub(hTCP);
9D001E40  93C20030   LBU V0, 48(S8)
9D001E44  A3828027   SB V0, -32729(GP)
1704:                
1705:                	// Make sure we don't try to read more data than is available
1706:                	if(len > wGetReadyCount)
9D001E48  97C30038   LHU V1, 56(S8)
9D001E4C  97C2001A   LHU V0, 26(S8)
9D001E50  0043102B   SLTU V0, V0, V1
9D001E54  10400003   BEQ V0, ZERO, 0x9D001E64
9D001E58  00000000   NOP
1707:                		len = wGetReadyCount;
9D001E5C  97C2001A   LHU V0, 26(S8)
9D001E60  A7C20038   SH V0, 56(S8)
1708:                
1709:                	// See if we need a two part get
1710:                	if(MyTCBStub.rxTail + len > MyTCBStub.bufferEnd)
9D001E64  93828027   LBU V0, -32729(GP)
9D001E68  00402021   ADDU A0, V0, ZERO
9D001E6C  3C02A000   LUI V0, -24576
9D001E70  24030030   ADDIU V1, ZERO, 48
9D001E74  70831802   MUL V1, A0, V1
9D001E78  24422CDC   ADDIU V0, V0, 11484
9D001E7C  00621021   ADDU V0, V1, V0
9D001E80  8C430018   LW V1, 24(V0)
9D001E84  97C20038   LHU V0, 56(S8)
9D001E88  00621821   ADDU V1, V1, V0
9D001E8C  93828027   LBU V0, -32729(GP)
9D001E90  00402821   ADDU A1, V0, ZERO
9D001E94  3C02A000   LUI V0, -24576
9D001E98  24040030   ADDIU A0, ZERO, 48
9D001E9C  70A42002   MUL A0, A1, A0
9D001EA0  24422CDC   ADDIU V0, V0, 11484
9D001EA4  00821021   ADDU V0, A0, V0
9D001EA8  8C420008   LW V0, 8(V0)
9D001EAC  0043102B   SLTU V0, V0, V1
9D001EB0  1040004A   BEQ V0, ZERO, 0x9D001FDC
9D001EB4  00000000   NOP
1711:                	{
1712:                		RightLen = MyTCBStub.bufferEnd - MyTCBStub.rxTail + 1;
9D001EB8  93828027   LBU V0, -32729(GP)
9D001EBC  00402021   ADDU A0, V0, ZERO
9D001EC0  3C02A000   LUI V0, -24576
9D001EC4  24030030   ADDIU V1, ZERO, 48
9D001EC8  70831802   MUL V1, A0, V1
9D001ECC  24422CDC   ADDIU V0, V0, 11484
9D001ED0  00621021   ADDU V0, V1, V0
9D001ED4  8C420008   LW V0, 8(V0)
9D001ED8  3043FFFF   ANDI V1, V0, -1
9D001EDC  93828027   LBU V0, -32729(GP)
9D001EE0  00402821   ADDU A1, V0, ZERO
9D001EE4  3C02A000   LUI V0, -24576
9D001EE8  24040030   ADDIU A0, ZERO, 48
9D001EEC  70A42002   MUL A0, A1, A0
9D001EF0  24422CDC   ADDIU V0, V0, 11484
9D001EF4  00821021   ADDU V0, A0, V0
9D001EF8  8C420018   LW V0, 24(V0)
9D001EFC  3042FFFF   ANDI V0, V0, -1
9D001F00  00621023   SUBU V0, V1, V0
9D001F04  3042FFFF   ANDI V0, V0, -1
9D001F08  24420001   ADDIU V0, V0, 1
9D001F0C  A7C20018   SH V0, 24(S8)
1713:                		if(buffer)
9D001F10  8FC20034   LW V0, 52(S8)
9D001F14  1040001D   BEQ V0, ZERO, 0x9D001F8C
9D001F18  00000000   NOP
1714:                		{
1715:                			TCPRAMCopy((PTR_BASE)buffer, TCP_PIC_RAM, MyTCBStub.rxTail, MyTCBStub.vMemoryMedium, RightLen);
9D001F1C  8FC40034   LW A0, 52(S8)
9D001F20  93828027   LBU V0, -32729(GP)
9D001F24  00402821   ADDU A1, V0, ZERO
9D001F28  3C02A000   LUI V0, -24576
9D001F2C  24030030   ADDIU V1, ZERO, 48
9D001F30  70A31802   MUL V1, A1, V1
9D001F34  24422CDC   ADDIU V0, V0, 11484
9D001F38  00621021   ADDU V0, V1, V0
9D001F3C  8C430018   LW V1, 24(V0)
9D001F40  93828027   LBU V0, -32729(GP)
9D001F44  00403021   ADDU A2, V0, ZERO
9D001F48  3C02A000   LUI V0, -24576
9D001F4C  24050030   ADDIU A1, ZERO, 48
9D001F50  70C52802   MUL A1, A2, A1
9D001F54  24422CDC   ADDIU V0, V0, 11484
9D001F58  00A21021   ADDU V0, A1, V0
9D001F5C  9042002C   LBU V0, 44(V0)
9D001F60  97C50018   LHU A1, 24(S8)
9D001F64  AFA50010   SW A1, 16(SP)
9D001F68  24050001   ADDIU A1, ZERO, 1
9D001F6C  00603021   ADDU A2, V1, ZERO
9D001F70  00403821   ADDU A3, V0, ZERO
9D001F74  0F4020BE   JAL TCPRAMCopy
9D001F78  00000000   NOP
1716:                			buffer += RightLen;
9D001F7C  97C20018   LHU V0, 24(S8)
9D001F80  8FC30034   LW V1, 52(S8)
9D001F84  00621021   ADDU V0, V1, V0
9D001F88  AFC20034   SW V0, 52(S8)
1717:                		}
1718:                		len -= RightLen;
9D001F8C  97C30038   LHU V1, 56(S8)
9D001F90  97C20018   LHU V0, 24(S8)
9D001F94  00621023   SUBU V0, V1, V0
9D001F98  A7C20038   SH V0, 56(S8)
1719:                		MyTCBStub.rxTail = MyTCBStub.bufferRxStart;
9D001F9C  93828027   LBU V0, -32729(GP)
9D001FA0  00402821   ADDU A1, V0, ZERO
9D001FA4  93828027   LBU V0, -32729(GP)
9D001FA8  00402021   ADDU A0, V0, ZERO
9D001FAC  3C02A000   LUI V0, -24576
9D001FB0  24432CDC   ADDIU V1, V0, 11484
9D001FB4  24020030   ADDIU V0, ZERO, 48
9D001FB8  70821002   MUL V0, A0, V0
9D001FBC  00621021   ADDU V0, V1, V0
9D001FC0  8C430004   LW V1, 4(V0)
9D001FC4  3C02A000   LUI V0, -24576
9D001FC8  24040030   ADDIU A0, ZERO, 48
9D001FCC  70A42002   MUL A0, A1, A0
9D001FD0  24422CDC   ADDIU V0, V0, 11484
9D001FD4  00821021   ADDU V0, A0, V0
9D001FD8  AC430018   SW V1, 24(V0)
1720:                	}
1721:                
1722:                	if(buffer)
9D001FDC  8FC20034   LW V0, 52(S8)
9D001FE0  10400019   BEQ V0, ZERO, 0x9D002048
9D001FE4  00000000   NOP
1723:                		TCPRAMCopy((PTR_BASE)buffer, TCP_PIC_RAM, MyTCBStub.rxTail, MyTCBStub.vMemoryMedium, len);
9D001FE8  8FC40034   LW A0, 52(S8)
9D001FEC  93828027   LBU V0, -32729(GP)
9D001FF0  00402821   ADDU A1, V0, ZERO
9D001FF4  3C02A000   LUI V0, -24576
9D001FF8  24030030   ADDIU V1, ZERO, 48
9D001FFC  70A31802   MUL V1, A1, V1
9D002000  24422CDC   ADDIU V0, V0, 11484
9D002004  00621021   ADDU V0, V1, V0
9D002008  8C430018   LW V1, 24(V0)
9D00200C  93828027   LBU V0, -32729(GP)
9D002010  00403021   ADDU A2, V0, ZERO
9D002014  3C02A000   LUI V0, -24576
9D002018  24050030   ADDIU A1, ZERO, 48
9D00201C  70C52802   MUL A1, A2, A1
9D002020  24422CDC   ADDIU V0, V0, 11484
9D002024  00A21021   ADDU V0, A1, V0
9D002028  9042002C   LBU V0, 44(V0)
9D00202C  97C50038   LHU A1, 56(S8)
9D002030  AFA50010   SW A1, 16(SP)
9D002034  24050001   ADDIU A1, ZERO, 1
9D002038  00603021   ADDU A2, V1, ZERO
9D00203C  00403821   ADDU A3, V0, ZERO
9D002040  0F4020BE   JAL TCPRAMCopy
9D002044  00000000   NOP
1724:                	MyTCBStub.rxTail += len;
9D002048  93828027   LBU V0, -32729(GP)
9D00204C  00402821   ADDU A1, V0, ZERO
9D002050  93828027   LBU V0, -32729(GP)
9D002054  00402021   ADDU A0, V0, ZERO
9D002058  3C02A000   LUI V0, -24576
9D00205C  24030030   ADDIU V1, ZERO, 48
9D002060  70831802   MUL V1, A0, V1
9D002064  24422CDC   ADDIU V0, V0, 11484
9D002068  00621021   ADDU V0, V1, V0
9D00206C  8C430018   LW V1, 24(V0)
9D002070  97C20038   LHU V0, 56(S8)
9D002074  00621821   ADDU V1, V1, V0
9D002078  3C02A000   LUI V0, -24576
9D00207C  24040030   ADDIU A0, ZERO, 48
9D002080  70A42002   MUL A0, A1, A0
9D002084  24422CDC   ADDIU V0, V0, 11484
9D002088  00821021   ADDU V0, A0, V0
9D00208C  AC430018   SW V1, 24(V0)
1725:                	len += RightLen;
9D002090  97C30038   LHU V1, 56(S8)
9D002094  97C20018   LHU V0, 24(S8)
9D002098  00621021   ADDU V0, V1, V0
9D00209C  A7C20038   SH V0, 56(S8)
1726:                
1727:                	// Send a window update if we've run low on data
1728:                	if(wGetReadyCount - len <= len)
9D0020A0  97C3001A   LHU V1, 26(S8)
9D0020A4  97C20038   LHU V0, 56(S8)
9D0020A8  00621823   SUBU V1, V1, V0
9D0020AC  97C20038   LHU V0, 56(S8)
9D0020B0  0043102A   SLT V0, V0, V1
9D0020B4  1440000E   BNE V0, ZERO, 0x9D0020F0
9D0020B8  00000000   NOP
1729:                	{
1730:                		MyTCBStub.Flags.bTXASAPWithoutTimerReset = 1;
9D0020BC  93828027   LBU V0, -32729(GP)
9D0020C0  00402021   ADDU A0, V0, ZERO
9D0020C4  3C02A000   LUI V0, -24576
9D0020C8  24030030   ADDIU V1, ZERO, 48
9D0020CC  70831802   MUL V1, A0, V1
9D0020D0  24422CDC   ADDIU V0, V0, 11484
9D0020D4  00621821   ADDU V1, V1, V0
9D0020D8  8C620028   LW V0, 40(V1)
9D0020DC  24040001   ADDIU A0, ZERO, 1
9D0020E0  7C825284   INS V0, A0, 10, 1
9D0020E4  AC620028   SW V0, 40(V1)
9D0020E8  0B400860   J 0x9D002180
9D0020EC  00000000   NOP
1731:                	}
1732:                	else if(!MyTCBStub.Flags.bTimer2Enabled)
9D0020F0  93828027   LBU V0, -32729(GP)
9D0020F4  00402021   ADDU A0, V0, ZERO
9D0020F8  3C02A000   LUI V0, -24576
9D0020FC  24030030   ADDIU V1, ZERO, 48
9D002100  70831802   MUL V1, A0, V1
9D002104  24422CDC   ADDIU V0, V0, 11484
9D002108  00621021   ADDU V0, V1, V0
9D00210C  8C420028   LW V0, 40(V0)
9D002110  7C420140   EXT V0, V0, 5, 1
9D002114  304200FF   ANDI V0, V0, 255
9D002118  14400019   BNE V0, ZERO, 0x9D002180
9D00211C  00000000   NOP
1733:                	// If not already enabled, start a timer so a window 
1734:                	// update will get sent to the remote node at some point
1735:                	{
1736:                		MyTCBStub.Flags.bTimer2Enabled = TRUE;
9D002120  93828027   LBU V0, -32729(GP)
9D002124  00402021   ADDU A0, V0, ZERO
9D002128  3C02A000   LUI V0, -24576
9D00212C  24030030   ADDIU V1, ZERO, 48
9D002130  70831802   MUL V1, A0, V1
9D002134  24422CDC   ADDIU V0, V0, 11484
9D002138  00621821   ADDU V1, V1, V0
9D00213C  8C620028   LW V0, 40(V1)
9D002140  24040001   ADDIU A0, ZERO, 1
9D002144  7C822944   INS V0, A0, 5, 1
9D002148  AC620028   SW V0, 40(V1)
1737:                		MyTCBStub.eventTime2 = (WORD)TickGetDiv256() + TCP_WINDOW_UPDATE_TIMEOUT_VAL/256ull;
9D00214C  93828027   LBU V0, -32729(GP)
9D002150  00408021   ADDU S0, V0, ZERO
9D002154  0F40CDE4   JAL TickGetDiv256
9D002158  00000000   NOP
9D00215C  3042FFFF   ANDI V0, V0, -1
9D002160  2442007A   ADDIU V0, V0, 122
9D002164  3043FFFF   ANDI V1, V0, -1
9D002168  3C02A000   LUI V0, -24576
9D00216C  24040030   ADDIU A0, ZERO, 48
9D002170  72042002   MUL A0, S0, A0
9D002174  24422CDC   ADDIU V0, V0, 11484
9D002178  00821021   ADDU V0, A0, V0
9D00217C  A4430020   SH V1, 32(V0)
1738:                	}
1739:                
1740:                	return len;
9D002180  97C20038   LHU V0, 56(S8)
1741:                }
9D002184  03C0E821   ADDU SP, S8, ZERO
9D002188  8FBF002C   LW RA, 44(SP)
9D00218C  8FBE0028   LW S8, 40(SP)
9D002190  8FB00024   LW S0, 36(SP)
9D002194  27BD0030   ADDIU SP, SP, 48
9D002198  03E00008   JR RA
9D00219C  00000000   NOP
1742:                
1743:                
1744:                /*****************************************************************************
1745:                  Function:
1746:                	WORD TCPGetRxFIFOFree(TCP_SOCKET hTCP)
1747:                
1748:                  Description:
1749:                	Determines how many bytes are free in the RX FIFO.
1750:                
1751:                  Precondition:
1752:                	TCP is initialized.
1753:                
1754:                  Parameters:
1755:                	hTCP - The socket to check.
1756:                
1757:                  Returns:
1758:                	The number of bytes free in the TCP RX FIFO.  If zero, no additional 
1759:                	data can be received until the application removes some data using one
1760:                	of the TCPGet family functions.
1761:                  ***************************************************************************/
1762:                WORD TCPGetRxFIFOFree(TCP_SOCKET hTCP)
1763:                {
9D0021A0  27BDFFE0   ADDIU SP, SP, -32
9D0021A4  AFBF001C   SW RA, 28(SP)
9D0021A8  AFBE0018   SW S8, 24(SP)
9D0021AC  03A0F021   ADDU S8, SP, ZERO
9D0021B0  00801021   ADDU V0, A0, ZERO
9D0021B4  A3C20020   SB V0, 32(S8)
1764:                	WORD wDataLen;
1765:                	WORD wFIFOSize;
1766:                	
1767:                	if(hTCP >= TCP_SOCKET_COUNT)
9D0021B8  93C20020   LBU V0, 32(S8)
9D0021BC  2C420009   SLTIU V0, V0, 9
9D0021C0  14400004   BNE V0, ZERO, 0x9D0021D4
9D0021C4  00000000   NOP
1768:                    {
1769:                        return 0;
9D0021C8  00001021   ADDU V0, ZERO, ZERO
9D0021CC  0B400894   J 0x9D002250
9D0021D0  00000000   NOP
1770:                    }
1771:                    
1772:                	SyncTCBStub(hTCP);
9D0021D4  93C20020   LBU V0, 32(S8)
9D0021D8  A3828027   SB V0, -32729(GP)
1773:                	
1774:                	// Calculate total usable FIFO size
1775:                	wFIFOSize = MyTCBStub.bufferEnd - MyTCBStub.bufferRxStart;
9D0021DC  93828027   LBU V0, -32729(GP)
9D0021E0  00402021   ADDU A0, V0, ZERO
9D0021E4  3C02A000   LUI V0, -24576
9D0021E8  24030030   ADDIU V1, ZERO, 48
9D0021EC  70831802   MUL V1, A0, V1
9D0021F0  24422CDC   ADDIU V0, V0, 11484
9D0021F4  00621021   ADDU V0, V1, V0
9D0021F8  8C420008   LW V0, 8(V0)
9D0021FC  3043FFFF   ANDI V1, V0, -1
9D002200  93828027   LBU V0, -32729(GP)
9D002204  00402821   ADDU A1, V0, ZERO
9D002208  3C02A000   LUI V0, -24576
9D00220C  24442CDC   ADDIU A0, V0, 11484
9D002210  24020030   ADDIU V0, ZERO, 48
9D002214  70A21002   MUL V0, A1, V0
9D002218  00821021   ADDU V0, A0, V0
9D00221C  8C420004   LW V0, 4(V0)
9D002220  3042FFFF   ANDI V0, V0, -1
9D002224  00621023   SUBU V0, V1, V0
9D002228  A7C20010   SH V0, 16(S8)
1776:                
1777:                	#if defined(STACK_USE_SSL)
1778:                	{
1779:                		PTR_BASE SSLtemp = MyTCBStub.rxHead;
1780:                
1781:                		// Move SSL pointer to determine full buffer size
1782:                		if(MyTCBStub.sslStubID != SSL_INVALID_ID)
1783:                			MyTCBStub.rxHead = MyTCBStub.sslRxHead;
1784:                
1785:                		// Find out how many data bytes are actually in the RX FIFO
1786:                		wDataLen = TCPIsGetReady(hTCP);
1787:                		
1788:                		// Move SSL pointer back to proper location (if we changed it)
1789:                		MyTCBStub.rxHead = SSLtemp;
1790:                	}
1791:                	#else
1792:                	{
1793:                		// Find out how many data bytes are actually in the RX FIFO
1794:                		wDataLen = TCPIsGetReady(hTCP);
9D00222C  93C20020   LBU V0, 32(S8)
9D002230  00402021   ADDU A0, V0, ZERO
9D002234  0F400675   JAL TCPIsGetReady
9D002238  00000000   NOP
9D00223C  A7C20012   SH V0, 18(S8)
1795:                	}
1796:                	#endif
1797:                	
1798:                	// Perform the calculation	
1799:                	return wFIFOSize - wDataLen;
9D002240  97C30010   LHU V1, 16(S8)
9D002244  97C20012   LHU V0, 18(S8)
9D002248  00621023   SUBU V0, V1, V0
9D00224C  3042FFFF   ANDI V0, V0, -1
1800:                }
9D002250  03C0E821   ADDU SP, S8, ZERO
9D002254  8FBF001C   LW RA, 28(SP)
9D002258  8FBE0018   LW S8, 24(SP)
9D00225C  27BD0020   ADDIU SP, SP, 32
9D002260  03E00008   JR RA
9D002264  00000000   NOP
1801:                
1802:                /*****************************************************************************
1803:                  Function:
1804:                	WORD TCPPeekArray(TCP_SOCKET hTCP, BYTE *vBuffer, WORD wLen, WORD wStart)
1805:                
1806:                  Summary:
1807:                  	Reads a specified number of data bytes from the TCP RX FIFO without 
1808:                  	removing them from the buffer.
1809:                
1810:                  Description:
1811:                	Reads a specified number of data bytes from the TCP RX FIFO without 
1812:                  	removing them from the buffer.  No TCP control actions are taken as a 
1813:                  	result of this function (ex: no window update is sent to the remote node).
1814:                  	
1815:                  Precondition:
1816:                	TCP is initialized.
1817:                
1818:                  Parameters:
1819:                	hTCP - The socket to peak from (read without removing from stream).
1820:                	vBuffer - Destination to write the peeked data bytes.
1821:                	wLen - Length of bytes to peak from the RX FIFO and copy to vBuffer.
1822:                	wStart - Zero-indexed starting position within the FIFO to start peeking 
1823:                		from.
1824:                
1825:                  Return Values:
1826:                	Number of bytes actually peeked from the stream and copied to vBuffer.  
1827:                	This value can be less than wLen if wStart + wLen is greater than the 
1828:                	deepest possible character in the RX FIFO.
1829:                
1830:                  Remarks:
1831:                  	None
1832:                  ***************************************************************************/
1833:                WORD TCPPeekArray(TCP_SOCKET hTCP, BYTE *vBuffer, WORD wLen, WORD wStart)
1834:                {
9D002268  27BDFFD8   ADDIU SP, SP, -40
9D00226C  AFBF0024   SW RA, 36(SP)
9D002270  AFBE0020   SW S8, 32(SP)
9D002274  03A0F021   ADDU S8, SP, ZERO
9D002278  AFC5002C   SW A1, 44(S8)
9D00227C  00C01821   ADDU V1, A2, ZERO
9D002280  00E01021   ADDU V0, A3, ZERO
9D002284  A3C40028   SB A0, 40(S8)
9D002288  A7C30030   SH V1, 48(S8)
9D00228C  A7C20034   SH V0, 52(S8)
1835:                	PTR_BASE ptrRead;
1836:                	WORD w;
1837:                	WORD wBytesUntilWrap;
1838:                
1839:                	if(hTCP >= TCP_SOCKET_COUNT || wLen == 0)
9D002290  93C20028   LBU V0, 40(S8)
9D002294  2C420009   SLTIU V0, V0, 9
9D002298  10400004   BEQ V0, ZERO, 0x9D0022AC
9D00229C  00000000   NOP
9D0022A0  97C20030   LHU V0, 48(S8)
9D0022A4  14400004   BNE V0, ZERO, 0x9D0022B8
9D0022A8  00000000   NOP
1840:                    {
1841:                        return 0;
9D0022AC  00001021   ADDU V0, ZERO, ZERO
9D0022B0  0B400942   J 0x9D002508
9D0022B4  00000000   NOP
1842:                    }
1843:                    
1844:                	SyncTCBStub(hTCP);
9D0022B8  93C20028   LBU V0, 40(S8)
9D0022BC  A3828027   SB V0, -32729(GP)
1845:                
1846:                	// Find out how many bytes are in the RX FIFO and decrease read length 
1847:                	// if the start offset + read length is beyond the end of the FIFO
1848:                	w = TCPIsGetReady(hTCP);
9D0022C0  93C20028   LBU V0, 40(S8)
9D0022C4  00402021   ADDU A0, V0, ZERO
9D0022C8  0F400675   JAL TCPIsGetReady
9D0022CC  00000000   NOP
9D0022D0  A7C2001C   SH V0, 28(S8)
1849:                	if(wStart + wLen > w)
9D0022D4  97C30034   LHU V1, 52(S8)
9D0022D8  97C20030   LHU V0, 48(S8)
9D0022DC  00621821   ADDU V1, V1, V0
9D0022E0  97C2001C   LHU V0, 28(S8)
9D0022E4  0043102A   SLT V0, V0, V1
9D0022E8  10400005   BEQ V0, ZERO, 0x9D002300
9D0022EC  00000000   NOP
1850:                		wLen = w - wStart;
9D0022F0  97C3001C   LHU V1, 28(S8)
9D0022F4  97C20034   LHU V0, 52(S8)
9D0022F8  00621023   SUBU V0, V1, V0
9D0022FC  A7C20030   SH V0, 48(S8)
1851:                
1852:                	// Find the read start location
1853:                	ptrRead = MyTCBStub.rxTail + wStart;
9D002300  93828027   LBU V0, -32729(GP)
9D002304  00402021   ADDU A0, V0, ZERO
9D002308  3C02A000   LUI V0, -24576
9D00230C  24030030   ADDIU V1, ZERO, 48
9D002310  70831802   MUL V1, A0, V1
9D002314  24422CDC   ADDIU V0, V0, 11484
9D002318  00621021   ADDU V0, V1, V0
9D00231C  8C430018   LW V1, 24(V0)
9D002320  97C20034   LHU V0, 52(S8)
9D002324  00621021   ADDU V0, V1, V0
9D002328  AFC20018   SW V0, 24(S8)
1854:                	if(ptrRead > MyTCBStub.bufferEnd)
9D00232C  93828027   LBU V0, -32729(GP)
9D002330  00402021   ADDU A0, V0, ZERO
9D002334  3C02A000   LUI V0, -24576
9D002338  24030030   ADDIU V1, ZERO, 48
9D00233C  70831802   MUL V1, A0, V1
9D002340  24422CDC   ADDIU V0, V0, 11484
9D002344  00621021   ADDU V0, V1, V0
9D002348  8C430008   LW V1, 8(V0)
9D00234C  8FC20018   LW V0, 24(S8)
9D002350  0062102B   SLTU V0, V1, V0
9D002354  10400016   BEQ V0, ZERO, 0x9D0023B0
9D002358  00000000   NOP
1855:                		ptrRead -= MyTCBStub.bufferEnd - MyTCBStub.bufferRxStart + 1;
9D00235C  93828027   LBU V0, -32729(GP)
9D002360  00402021   ADDU A0, V0, ZERO
9D002364  3C02A000   LUI V0, -24576
9D002368  24030030   ADDIU V1, ZERO, 48
9D00236C  70831802   MUL V1, A0, V1
9D002370  24422CDC   ADDIU V0, V0, 11484
9D002374  00621021   ADDU V0, V1, V0
9D002378  8C430008   LW V1, 8(V0)
9D00237C  93828027   LBU V0, -32729(GP)
9D002380  00402821   ADDU A1, V0, ZERO
9D002384  3C02A000   LUI V0, -24576
9D002388  24442CDC   ADDIU A0, V0, 11484
9D00238C  24020030   ADDIU V0, ZERO, 48
9D002390  70A21002   MUL V0, A1, V0
9D002394  00821021   ADDU V0, A0, V0
9D002398  8C420004   LW V0, 4(V0)
9D00239C  00621023   SUBU V0, V1, V0
9D0023A0  00021027   NOR V0, ZERO, V0
9D0023A4  8FC30018   LW V1, 24(S8)
9D0023A8  00621021   ADDU V0, V1, V0
9D0023AC  AFC20018   SW V0, 24(S8)
1856:                
1857:                	// Calculate how many bytes can be read in a single go
1858:                	wBytesUntilWrap = MyTCBStub.bufferEnd - ptrRead + 1;
9D0023B0  93828027   LBU V0, -32729(GP)
9D0023B4  00402021   ADDU A0, V0, ZERO
9D0023B8  3C02A000   LUI V0, -24576
9D0023BC  24030030   ADDIU V1, ZERO, 48
9D0023C0  70831802   MUL V1, A0, V1
9D0023C4  24422CDC   ADDIU V0, V0, 11484
9D0023C8  00621021   ADDU V0, V1, V0
9D0023CC  8C420008   LW V0, 8(V0)
9D0023D0  3043FFFF   ANDI V1, V0, -1
9D0023D4  8FC20018   LW V0, 24(S8)
9D0023D8  3042FFFF   ANDI V0, V0, -1
9D0023DC  00621023   SUBU V0, V1, V0
9D0023E0  3042FFFF   ANDI V0, V0, -1
9D0023E4  24420001   ADDIU V0, V0, 1
9D0023E8  A7C2001E   SH V0, 30(S8)
1859:                	if(wLen <= wBytesUntilWrap)
9D0023EC  97C30030   LHU V1, 48(S8)
9D0023F0  97C2001E   LHU V0, 30(S8)
9D0023F4  0043102B   SLTU V0, V0, V1
9D0023F8  14400014   BNE V0, ZERO, 0x9D00244C
9D0023FC  00000000   NOP
1860:                	{
1861:                		// Read all at once
1862:                		TCPRAMCopy((PTR_BASE)vBuffer, TCP_PIC_RAM, ptrRead, MyTCBStub.vMemoryMedium, wLen);
9D002400  8FC3002C   LW V1, 44(S8)
9D002404  93828027   LBU V0, -32729(GP)
9D002408  00402821   ADDU A1, V0, ZERO
9D00240C  3C02A000   LUI V0, -24576
9D002410  24040030   ADDIU A0, ZERO, 48
9D002414  70A42002   MUL A0, A1, A0
9D002418  24422CDC   ADDIU V0, V0, 11484
9D00241C  00821021   ADDU V0, A0, V0
9D002420  9042002C   LBU V0, 44(V0)
9D002424  97C40030   LHU A0, 48(S8)
9D002428  AFA40010   SW A0, 16(SP)
9D00242C  00602021   ADDU A0, V1, ZERO
9D002430  24050001   ADDIU A1, ZERO, 1
9D002434  8FC60018   LW A2, 24(S8)
9D002438  00403821   ADDU A3, V0, ZERO
9D00243C  0F4020BE   JAL TCPRAMCopy
9D002440  00000000   NOP
9D002444  0B400941   J 0x9D002504
9D002448  00000000   NOP
1863:                	}
1864:                	else
1865:                	{
1866:                		// Read all bytes up to the wrap position and then read remaining bytes 
1867:                		// at the start of the buffer
1868:                		TCPRAMCopy((PTR_BASE)vBuffer, TCP_PIC_RAM, ptrRead, MyTCBStub.vMemoryMedium, wBytesUntilWrap);
9D00244C  8FC3002C   LW V1, 44(S8)
9D002450  93828027   LBU V0, -32729(GP)
9D002454  00402821   ADDU A1, V0, ZERO
9D002458  3C02A000   LUI V0, -24576
9D00245C  24040030   ADDIU A0, ZERO, 48
9D002460  70A42002   MUL A0, A1, A0
9D002464  24422CDC   ADDIU V0, V0, 11484
9D002468  00821021   ADDU V0, A0, V0
9D00246C  9042002C   LBU V0, 44(V0)
9D002470  97C4001E   LHU A0, 30(S8)
9D002474  AFA40010   SW A0, 16(SP)
9D002478  00602021   ADDU A0, V1, ZERO
9D00247C  24050001   ADDIU A1, ZERO, 1
9D002480  8FC60018   LW A2, 24(S8)
9D002484  00403821   ADDU A3, V0, ZERO
9D002488  0F4020BE   JAL TCPRAMCopy
9D00248C  00000000   NOP
1869:                		TCPRAMCopy((PTR_BASE)vBuffer+wBytesUntilWrap, TCP_PIC_RAM, MyTCBStub.bufferRxStart, MyTCBStub.vMemoryMedium, wLen - wBytesUntilWrap);
9D002490  97C3001E   LHU V1, 30(S8)
9D002494  8FC2002C   LW V0, 44(S8)
9D002498  00622021   ADDU A0, V1, V0
9D00249C  93828027   LBU V0, -32729(GP)
9D0024A0  00402821   ADDU A1, V0, ZERO
9D0024A4  3C02A000   LUI V0, -24576
9D0024A8  24432CDC   ADDIU V1, V0, 11484
9D0024AC  24020030   ADDIU V0, ZERO, 48
9D0024B0  70A21002   MUL V0, A1, V0
9D0024B4  00621021   ADDU V0, V1, V0
9D0024B8  8C430004   LW V1, 4(V0)
9D0024BC  93828027   LBU V0, -32729(GP)
9D0024C0  00403021   ADDU A2, V0, ZERO
9D0024C4  3C02A000   LUI V0, -24576
9D0024C8  24050030   ADDIU A1, ZERO, 48
9D0024CC  70C52802   MUL A1, A2, A1
9D0024D0  24422CDC   ADDIU V0, V0, 11484
9D0024D4  00A21021   ADDU V0, A1, V0
9D0024D8  9042002C   LBU V0, 44(V0)
9D0024DC  97C60030   LHU A2, 48(S8)
9D0024E0  97C5001E   LHU A1, 30(S8)
9D0024E4  00C52823   SUBU A1, A2, A1
9D0024E8  30A5FFFF   ANDI A1, A1, -1
9D0024EC  AFA50010   SW A1, 16(SP)
9D0024F0  24050001   ADDIU A1, ZERO, 1
9D0024F4  00603021   ADDU A2, V1, ZERO
9D0024F8  00403821   ADDU A3, V0, ZERO
9D0024FC  0F4020BE   JAL TCPRAMCopy
9D002500  00000000   NOP
1870:                	}
1871:                	
1872:                	return wLen;
9D002504  97C20030   LHU V0, 48(S8)
1873:                }
9D002508  03C0E821   ADDU SP, S8, ZERO
9D00250C  8FBF0024   LW RA, 36(SP)
9D002510  8FBE0020   LW S8, 32(SP)
9D002514  27BD0028   ADDIU SP, SP, 40
9D002518  03E00008   JR RA
9D00251C  00000000   NOP
1874:                
1875:                /*****************************************************************************
1876:                  Function:
1877:                	BYTE TCPPeek(TCP_SOCKET hTCP, WORD wStart)
1878:                
1879:                  Summary:
1880:                  	Peaks at one byte in the TCP RX FIFO without removing it from the buffer.
1881:                
1882:                  Description:
1883:                	Peaks at one byte in the TCP RX FIFO without removing it from the buffer.
1884:                  	
1885:                  Precondition:
1886:                	TCP is initialized.
1887:                
1888:                  Parameters:
1889:                	hTCP - The socket to peak from (read without removing from stream).
1890:                	wStart - Zero-indexed starting position within the FIFO to peek from.
1891:                
1892:                  Return Values:
1893:                	Byte peeked from the RX FIFO.  If there is no data in the buffer or an 
1894:                	illegal wStart starting offset is given, then an indeterminate value is 
1895:                	returned.  The caller must ensure that valid parameters are passed to avoid 
1896:                	(i.e ensure that TCPIsGetReady() returns a number that is less than wStart 
1897:                	before calling TCPPeek()).
1898:                
1899:                  Remarks:
1900:                  	Use the TCPPeekArray() function to read more than one byte.  It will 
1901:                  	perform better than calling TCPPeek() in a loop.
1902:                  ***************************************************************************/
1903:                BYTE TCPPeek(TCP_SOCKET hTCP, WORD wStart)
1904:                {
9D002520  27BDFFE0   ADDIU SP, SP, -32
9D002524  AFBF001C   SW RA, 28(SP)
9D002528  AFBE0018   SW S8, 24(SP)
9D00252C  03A0F021   ADDU S8, SP, ZERO
9D002530  00801821   ADDU V1, A0, ZERO
9D002534  00A01021   ADDU V0, A1, ZERO
9D002538  A3C30020   SB V1, 32(S8)
9D00253C  A7C20024   SH V0, 36(S8)
1905:                	BYTE i;
1906:                	
1907:                	TCPPeekArray(hTCP, &i, 1, wStart);
9D002540  93C30020   LBU V1, 32(S8)
9D002544  97C20024   LHU V0, 36(S8)
9D002548  00602021   ADDU A0, V1, ZERO
9D00254C  27C30010   ADDIU V1, S8, 16
9D002550  00602821   ADDU A1, V1, ZERO
9D002554  24060001   ADDIU A2, ZERO, 1
9D002558  00403821   ADDU A3, V0, ZERO
9D00255C  0F40089A   JAL TCPPeekArray
9D002560  00000000   NOP
1908:                	return i;
9D002564  93C20010   LBU V0, 16(S8)
1909:                }
9D002568  03C0E821   ADDU SP, S8, ZERO
9D00256C  8FBF001C   LW RA, 28(SP)
9D002570  8FBE0018   LW S8, 24(SP)
9D002574  27BD0020   ADDIU SP, SP, 32
9D002578  03E00008   JR RA
9D00257C  00000000   NOP
1910:                
1911:                
1912:                /****************************************************************************
1913:                  Section:
1914:                	Search Functions
1915:                  ***************************************************************************/
1916:                
1917:                /*****************************************************************************
1918:                  Function:
1919:                	WORD TCPFindArrayEx(TCP_SOCKET hTCP, BYTE* cFindArray, WORD wLen, 
1920:                						WORD wStart, WORD wSearchLen, BOOL bTextCompare)
1921:                
1922:                  Summary:
1923:                  	Searches for a string in the TCP RX buffer.
1924:                
1925:                  Description:
1926:                	This function finds the first occurrance of an array of bytes in the
1927:                	TCP RX buffer.  It can be used by an application to abstract searches 
1928:                	out of their own application code.  For increased efficiency, the 
1929:                	function is capable of limiting the scope of search to a specific
1930:                	range of bytes.  It can also perform a case-insensitive search if
1931:                	required.
1932:                	
1933:                	For example, if the buffer contains "I love PIC MCUs!" and the search
1934:                	array is "love" with a length of 4, a value of 2 will be returned.
1935:                
1936:                  Precondition:
1937:                	TCP is initialized.
1938:                
1939:                  Parameters:
1940:                	hTCP - The socket to search within.
1941:                	cFindArray - The array of bytes to find in the buffer.
1942:                	wLen - Length of cFindArray.
1943:                	wStart - Zero-indexed starting position within the buffer.
1944:                	wSearchLen - Length from wStart to search in the buffer.
1945:                	bTextCompare - TRUE for case-insensitive text search, FALSE for binary search
1946:                
1947:                  Return Values:
1948:                	0xFFFF - Search array not found
1949:                	Otherwise - Zero-indexed position of the first occurrance
1950:                
1951:                  Remarks:
1952:                	Since this function usually must transfer data from external storage
1953:                	to internal RAM for comparison, its performance degrades significantly
1954:                	when the buffer is full and the array is not found.  For better 
1955:                	performance, try to search for characters that are expected to exist or
1956:                	limit the scope of the search as much as possible.  The HTTP2 module, 
1957:                	for example, uses this function to parse headers.  However, it searches 
1958:                	for newlines, then the separating colon, then reads the header name to 
1959:                	RAM for final comparison.  This has proven to be significantly faster  
1960:                	than searching for full header name strings outright.
1961:                  ***************************************************************************/
1962:                WORD TCPFindArrayEx(TCP_SOCKET hTCP, BYTE* cFindArray, WORD wLen, WORD wStart, WORD wSearchLen, BOOL bTextCompare)
1963:                {
9D002580  27BDFF98   ADDIU SP, SP, -104
9D002584  AFBF0064   SW RA, 100(SP)
9D002588  AFBE0060   SW S8, 96(SP)
9D00258C  03A0F021   ADDU S8, SP, ZERO
9D002590  00804021   ADDU T0, A0, ZERO
9D002594  AFC5006C   SW A1, 108(S8)
9D002598  00C02021   ADDU A0, A2, ZERO
9D00259C  00E01821   ADDU V1, A3, ZERO
9D0025A0  8FC20078   LW V0, 120(S8)
9D0025A4  A3C80068   SB T0, 104(S8)
9D0025A8  A7C40070   SH A0, 112(S8)
9D0025AC  A7C30074   SH V1, 116(S8)
9D0025B0  A7C20058   SH V0, 88(S8)
1964:                	PTR_BASE ptrRead;
1965:                	WORD wDataLen;
1966:                	WORD wBytesUntilWrap;
1967:                	PTR_BASE ptrLocation;
1968:                	WORD wLenStart;
1969:                	BYTE *cFindArrayStart;
1970:                	BYTE i, j, k;
1971:                	BOOL isFinding;
1972:                	BYTE buffer[32];
1973:                
1974:                	if(hTCP >= TCP_SOCKET_COUNT || wLen == 0)
9D0025B4  93C20068   LBU V0, 104(S8)
9D0025B8  2C420009   SLTIU V0, V0, 9
9D0025BC  10400004   BEQ V0, ZERO, 0x9D0025D0
9D0025C0  00000000   NOP
9D0025C4  97C20070   LHU V0, 112(S8)
9D0025C8  14400004   BNE V0, ZERO, 0x9D0025DC
9D0025CC  00000000   NOP
1975:                    {
1976:                        return 0;
9D0025D0  00001021   ADDU V0, ZERO, ZERO
9D0025D4  0B400AE5   J 0x9D002B94
9D0025D8  00000000   NOP
1977:                    }
1978:                    
1979:                	SyncTCBStub(hTCP);
9D0025DC  93C20068   LBU V0, 104(S8)
9D0025E0  A3828027   SB V0, -32729(GP)
1980:                
1981:                	// Find out how many bytes are in the RX FIFO and return 
1982:                	// immediately if we won't possibly find a match
1983:                	wDataLen = TCPIsGetReady(hTCP) - wStart;
9D0025E4  93C20068   LBU V0, 104(S8)
9D0025E8  00402021   ADDU A0, V0, ZERO
9D0025EC  0F400675   JAL TCPIsGetReady
9D0025F0  00000000   NOP
9D0025F4  00401821   ADDU V1, V0, ZERO
9D0025F8  97C20074   LHU V0, 116(S8)
9D0025FC  00621023   SUBU V0, V1, V0
9D002600  A7C2001C   SH V0, 28(S8)
1984:                	if(wDataLen < wLen)
9D002604  97C3001C   LHU V1, 28(S8)
9D002608  97C20070   LHU V0, 112(S8)
9D00260C  0062102B   SLTU V0, V1, V0
9D002610  10400004   BEQ V0, ZERO, 0x9D002624
9D002614  00000000   NOP
1985:                		return 0xFFFFu;
9D002618  3402FFFF   ORI V0, ZERO, -1
9D00261C  0B400AE5   J 0x9D002B94
9D002620  00000000   NOP
1986:                	if(wSearchLen && (wDataLen > wSearchLen))
9D002624  97C20058   LHU V0, 88(S8)
9D002628  10400008   BEQ V0, ZERO, 0x9D00264C
9D00262C  00000000   NOP
9D002630  97C3001C   LHU V1, 28(S8)
9D002634  97C20058   LHU V0, 88(S8)
9D002638  0043102B   SLTU V0, V0, V1
9D00263C  10400003   BEQ V0, ZERO, 0x9D00264C
9D002640  00000000   NOP
1987:                		wDataLen = wSearchLen;
9D002644  97C20058   LHU V0, 88(S8)
9D002648  A7C2001C   SH V0, 28(S8)
1988:                
1989:                	ptrLocation = MyTCBStub.rxTail + wStart;
9D00264C  93828027   LBU V0, -32729(GP)
9D002650  00402021   ADDU A0, V0, ZERO
9D002654  3C02A000   LUI V0, -24576
9D002658  24030030   ADDIU V1, ZERO, 48
9D00265C  70831802   MUL V1, A0, V1
9D002660  24422CDC   ADDIU V0, V0, 11484
9D002664  00621021   ADDU V0, V1, V0
9D002668  8C430018   LW V1, 24(V0)
9D00266C  97C20074   LHU V0, 116(S8)
9D002670  00621021   ADDU V0, V1, V0
9D002674  AFC20020   SW V0, 32(S8)
1990:                	if(ptrLocation > MyTCBStub.bufferEnd)
9D002678  93828027   LBU V0, -32729(GP)
9D00267C  00402021   ADDU A0, V0, ZERO
9D002680  3C02A000   LUI V0, -24576
9D002684  24030030   ADDIU V1, ZERO, 48
9D002688  70831802   MUL V1, A0, V1
9D00268C  24422CDC   ADDIU V0, V0, 11484
9D002690  00621021   ADDU V0, V1, V0
9D002694  8C430008   LW V1, 8(V0)
9D002698  8FC20020   LW V0, 32(S8)
9D00269C  0062102B   SLTU V0, V1, V0
9D0026A0  10400016   BEQ V0, ZERO, 0x9D0026FC
9D0026A4  00000000   NOP
1991:                		ptrLocation -= MyTCBStub.bufferEnd - MyTCBStub.bufferRxStart + 1;
9D0026A8  93828027   LBU V0, -32729(GP)
9D0026AC  00402021   ADDU A0, V0, ZERO
9D0026B0  3C02A000   LUI V0, -24576
9D0026B4  24030030   ADDIU V1, ZERO, 48
9D0026B8  70831802   MUL V1, A0, V1
9D0026BC  24422CDC   ADDIU V0, V0, 11484
9D0026C0  00621021   ADDU V0, V1, V0
9D0026C4  8C430008   LW V1, 8(V0)
9D0026C8  93828027   LBU V0, -32729(GP)
9D0026CC  00402821   ADDU A1, V0, ZERO
9D0026D0  3C02A000   LUI V0, -24576
9D0026D4  24442CDC   ADDIU A0, V0, 11484
9D0026D8  24020030   ADDIU V0, ZERO, 48
9D0026DC  70A21002   MUL V0, A1, V0
9D0026E0  00821021   ADDU V0, A0, V0
9D0026E4  8C420004   LW V0, 4(V0)
9D0026E8  00621023   SUBU V0, V1, V0
9D0026EC  00021027   NOR V0, ZERO, V0
9D0026F0  8FC30020   LW V1, 32(S8)
9D0026F4  00621021   ADDU V0, V1, V0
9D0026F8  AFC20020   SW V0, 32(S8)
1992:                	ptrRead = ptrLocation;
9D0026FC  8FC20020   LW V0, 32(S8)
9D002700  AFC20018   SW V0, 24(S8)
1993:                	wBytesUntilWrap = MyTCBStub.bufferEnd - ptrLocation + 1;
9D002704  93828027   LBU V0, -32729(GP)
9D002708  00402021   ADDU A0, V0, ZERO
9D00270C  3C02A000   LUI V0, -24576
9D002710  24030030   ADDIU V1, ZERO, 48
9D002714  70831802   MUL V1, A0, V1
9D002718  24422CDC   ADDIU V0, V0, 11484
9D00271C  00621021   ADDU V0, V1, V0
9D002720  8C420008   LW V0, 8(V0)
9D002724  3043FFFF   ANDI V1, V0, -1
9D002728  8FC20020   LW V0, 32(S8)
9D00272C  3042FFFF   ANDI V0, V0, -1
9D002730  00621023   SUBU V0, V1, V0
9D002734  3042FFFF   ANDI V0, V0, -1
9D002738  24420001   ADDIU V0, V0, 1
9D00273C  A7C2001E   SH V0, 30(S8)
1994:                	ptrLocation = wStart;
9D002740  97C20074   LHU V0, 116(S8)
9D002744  AFC20020   SW V0, 32(S8)
1995:                	wLenStart = wLen;
9D002748  97C20070   LHU V0, 112(S8)
9D00274C  A7C2002C   SH V0, 44(S8)
1996:                	cFindArrayStart = cFindArray;
9D002750  8FC2006C   LW V0, 108(S8)
9D002754  AFC20030   SW V0, 48(S8)
1997:                	j = *cFindArray++;
9D002758  8FC2006C   LW V0, 108(S8)
9D00275C  90420000   LBU V0, 0(V0)
9D002760  A3C20025   SB V0, 37(S8)
9D002764  8FC2006C   LW V0, 108(S8)
9D002768  24420001   ADDIU V0, V0, 1
9D00276C  AFC2006C   SW V0, 108(S8)
1998:                	isFinding = FALSE;
9D002770  AFC00028   SW ZERO, 40(S8)
1999:                	if(bTextCompare)
9D002774  8FC2007C   LW V0, 124(S8)
9D002778  1040000C   BEQ V0, ZERO, 0x9D0027AC
9D00277C  00000000   NOP
2000:                	{
2001:                		if(j >= 'a' && j <= 'z')
9D002780  93C20025   LBU V0, 37(S8)
9D002784  2C420061   SLTIU V0, V0, 97
9D002788  14400008   BNE V0, ZERO, 0x9D0027AC
9D00278C  00000000   NOP
9D002790  93C20025   LBU V0, 37(S8)
9D002794  2C42007B   SLTIU V0, V0, 123
9D002798  10400004   BEQ V0, ZERO, 0x9D0027AC
9D00279C  00000000   NOP
2002:                			j += 'A'-'a';
9D0027A0  93C20025   LBU V0, 37(S8)
9D0027A4  2442FFE0   ADDIU V0, V0, -32
9D0027A8  A3C20025   SB V0, 37(S8)
2003:                	}
2004:                
2005:                	// Search for the array
2006:                	while(1)
2007:                	{
2008:                		// Figure out how big of a chunk to read
2009:                		k = sizeof(buffer);
9D0027AC  24020020   ADDIU V0, ZERO, 32
9D0027B0  A3C20026   SB V0, 38(S8)
2010:                		if(k > wBytesUntilWrap)
9D0027B4  93C20026   LBU V0, 38(S8)
9D0027B8  3042FFFF   ANDI V0, V0, -1
9D0027BC  97C3001E   LHU V1, 30(S8)
9D0027C0  0062102B   SLTU V0, V1, V0
9D0027C4  10400003   BEQ V0, ZERO, 0x9D0027D4
9D0027C8  00000000   NOP
2011:                			k = wBytesUntilWrap;
9D0027CC  97C2001E   LHU V0, 30(S8)
9D0027D0  A3C20026   SB V0, 38(S8)
2012:                		if((WORD)k > wDataLen)
9D0027D4  93C20026   LBU V0, 38(S8)
9D0027D8  3042FFFF   ANDI V0, V0, -1
9D0027DC  97C3001C   LHU V1, 28(S8)
9D0027E0  0062102B   SLTU V0, V1, V0
9D0027E4  10400003   BEQ V0, ZERO, 0x9D0027F4
9D0027E8  00000000   NOP
2013:                			k = wDataLen;
9D0027EC  97C2001C   LHU V0, 28(S8)
9D0027F0  A3C20026   SB V0, 38(S8)
2014:                
2015:                		// Read a chunk of data into the buffer
2016:                		TCPRAMCopy((PTR_BASE)buffer, TCP_PIC_RAM, ptrRead, MyTCBStub.vMemoryMedium, (WORD)k);
9D0027F4  27C30034   ADDIU V1, S8, 52
9D0027F8  93828027   LBU V0, -32729(GP)
9D0027FC  00402821   ADDU A1, V0, ZERO
9D002800  3C02A000   LUI V0, -24576
9D002804  24040030   ADDIU A0, ZERO, 48
9D002808  70A42002   MUL A0, A1, A0
9D00280C  24422CDC   ADDIU V0, V0, 11484
9D002810  00821021   ADDU V0, A0, V0
9D002814  9042002C   LBU V0, 44(V0)
9D002818  93C40026   LBU A0, 38(S8)
9D00281C  AFA40010   SW A0, 16(SP)
9D002820  00602021   ADDU A0, V1, ZERO
9D002824  24050001   ADDIU A1, ZERO, 1
9D002828  8FC60018   LW A2, 24(S8)
9D00282C  00403821   ADDU A3, V0, ZERO
9D002830  0F4020BE   JAL TCPRAMCopy
9D002834  00000000   NOP
2017:                		ptrRead += k;
9D002838  93C20026   LBU V0, 38(S8)
9D00283C  8FC30018   LW V1, 24(S8)
9D002840  00621021   ADDU V0, V1, V0
9D002844  AFC20018   SW V0, 24(S8)
2018:                		wBytesUntilWrap -= k;
9D002848  93C20026   LBU V0, 38(S8)
9D00284C  3042FFFF   ANDI V0, V0, -1
9D002850  97C3001E   LHU V1, 30(S8)
9D002854  00621023   SUBU V0, V1, V0
9D002858  A7C2001E   SH V0, 30(S8)
2019:                
2020:                		if(wBytesUntilWrap == 0u)
9D00285C  97C2001E   LHU V0, 30(S8)
9D002860  1440000C   BNE V0, ZERO, 0x9D002894
9D002864  00000000   NOP
2021:                		{
2022:                			ptrRead = MyTCBStub.bufferRxStart;
9D002868  93828027   LBU V0, -32729(GP)
9D00286C  00402021   ADDU A0, V0, ZERO
9D002870  3C02A000   LUI V0, -24576
9D002874  24432CDC   ADDIU V1, V0, 11484
9D002878  24020030   ADDIU V0, ZERO, 48
9D00287C  70821002   MUL V0, A0, V0
9D002880  00621021   ADDU V0, V1, V0
9D002884  8C420004   LW V0, 4(V0)
9D002888  AFC20018   SW V0, 24(S8)
2023:                			wBytesUntilWrap = 0xFFFFu;
9D00288C  2402FFFF   ADDIU V0, ZERO, -1
9D002890  A7C2001E   SH V0, 30(S8)
2024:                		}
2025:                
2026:                		// Convert everything to uppercase
2027:                		if(bTextCompare)
9D002894  8FC2007C   LW V0, 124(S8)
9D002898  1040006E   BEQ V0, ZERO, 0x9D002A54
9D00289C  00000000   NOP
2028:                		{
2029:                			for(i = 0; i < k; i++)
9D0028A0  A3C00024   SB ZERO, 36(S8)
9D0028A4  0B400A8E   J 0x9D002A38
9D0028A8  00000000   NOP
9D002A2C  93C20024   LBU V0, 36(S8)
9D002A30  24420001   ADDIU V0, V0, 1
9D002A34  A3C20024   SB V0, 36(S8)
9D002A38  93C30024   LBU V1, 36(S8)
9D002A3C  93C20026   LBU V0, 38(S8)
9D002A40  0062102B   SLTU V0, V1, V0
9D002A44  1440FF99   BNE V0, ZERO, 0x9D0028AC
9D002A48  00000000   NOP
9D002A4C  0B400AD2   J 0x9D002B48
9D002A50  00000000   NOP
2030:                			{
2031:                				if(buffer[i] >= 'a' && buffer[i] <= 'z')
9D0028AC  93C20024   LBU V0, 36(S8)
9D0028B0  27C30018   ADDIU V1, S8, 24
9D0028B4  00621021   ADDU V0, V1, V0
9D0028B8  9042001C   LBU V0, 28(V0)
9D0028BC  2C420061   SLTIU V0, V0, 97
9D0028C0  14400012   BNE V0, ZERO, 0x9D00290C
9D0028C4  00000000   NOP
9D0028C8  93C20024   LBU V0, 36(S8)
9D0028CC  27C30018   ADDIU V1, S8, 24
9D0028D0  00621021   ADDU V0, V1, V0
9D0028D4  9042001C   LBU V0, 28(V0)
9D0028D8  2C42007B   SLTIU V0, V0, 123
9D0028DC  1040000B   BEQ V0, ZERO, 0x9D00290C
9D0028E0  00000000   NOP
2032:                					buffer[i] += 'A'-'a';
9D0028E4  93C20024   LBU V0, 36(S8)
9D0028E8  93C30024   LBU V1, 36(S8)
9D0028EC  27C40018   ADDIU A0, S8, 24
9D0028F0  00831821   ADDU V1, A0, V1
9D0028F4  9063001C   LBU V1, 28(V1)
9D0028F8  2463FFE0   ADDIU V1, V1, -32
9D0028FC  306300FF   ANDI V1, V1, 255
9D002900  27C40018   ADDIU A0, S8, 24
9D002904  00821021   ADDU V0, A0, V0
9D002908  A043001C   SB V1, 28(V0)
2033:                
2034:                				if(j == buffer[i])
9D00290C  93C20024   LBU V0, 36(S8)
9D002910  27C30018   ADDIU V1, S8, 24
9D002914  00621021   ADDU V0, V1, V0
9D002918  9042001C   LBU V0, 28(V0)
9D00291C  93C30025   LBU V1, 37(S8)
9D002920  14620029   BNE V1, V0, 0x9D0029C8
9D002924  00000000   NOP
2035:                				{
2036:                					if(--wLen == 0u)
9D002928  97C20070   LHU V0, 112(S8)
9D00292C  2442FFFF   ADDIU V0, V0, -1
9D002930  A7C20070   SH V0, 112(S8)
9D002934  97C20070   LHU V0, 112(S8)
9D002938  1440000E   BNE V0, ZERO, 0x9D002974
9D00293C  00000000   NOP
2037:                						return ptrLocation-wLenStart + i + 1;
9D002940  8FC20020   LW V0, 32(S8)
9D002944  3043FFFF   ANDI V1, V0, -1
9D002948  97C2002C   LHU V0, 44(S8)
9D00294C  00621023   SUBU V0, V1, V0
9D002950  3043FFFF   ANDI V1, V0, -1
9D002954  93C20024   LBU V0, 36(S8)
9D002958  3042FFFF   ANDI V0, V0, -1
9D00295C  00621021   ADDU V0, V1, V0
9D002960  3042FFFF   ANDI V0, V0, -1
9D002964  24420001   ADDIU V0, V0, 1
9D002968  3042FFFF   ANDI V0, V0, -1
9D00296C  0B400AE5   J 0x9D002B94
9D002970  00000000   NOP
2038:                					j = *cFindArray++;
9D002974  8FC2006C   LW V0, 108(S8)
9D002978  90420000   LBU V0, 0(V0)
9D00297C  A3C20025   SB V0, 37(S8)
9D002980  8FC2006C   LW V0, 108(S8)
9D002984  24420001   ADDIU V0, V0, 1
9D002988  AFC2006C   SW V0, 108(S8)
2039:                					isFinding = TRUE;
9D00298C  24020001   ADDIU V0, ZERO, 1
9D002990  AFC20028   SW V0, 40(S8)
2040:                					if(j >= 'a' && j <= 'z')
9D002994  93C20025   LBU V0, 37(S8)
9D002998  2C420061   SLTIU V0, V0, 97
9D00299C  14400023   BNE V0, ZERO, 0x9D002A2C
9D0029A0  00000000   NOP
9D0029A4  93C20025   LBU V0, 37(S8)
9D0029A8  2C42007B   SLTIU V0, V0, 123
9D0029AC  1040001F   BEQ V0, ZERO, 0x9D002A2C
9D0029B0  00000000   NOP
2041:                						j += 'A'-'a';
9D0029B4  93C20025   LBU V0, 37(S8)
9D0029B8  2442FFE0   ADDIU V0, V0, -32
9D0029BC  A3C20025   SB V0, 37(S8)
9D0029C0  0B400A8B   J 0x9D002A2C
9D0029C4  00000000   NOP
2042:                				}
2043:                				else
2044:                				{
2045:                					wLen = wLenStart;
9D0029C8  97C2002C   LHU V0, 44(S8)
9D0029CC  A7C20070   SH V0, 112(S8)
2046:                					if(isFinding)
9D0029D0  8FC20028   LW V0, 40(S8)
9D0029D4  10400015   BEQ V0, ZERO, 0x9D002A2C
9D0029D8  00000000   NOP
2047:                					{
2048:                						cFindArray = cFindArrayStart;
9D0029DC  8FC20030   LW V0, 48(S8)
9D0029E0  AFC2006C   SW V0, 108(S8)
2049:                						j = *cFindArray++;
9D0029E4  8FC2006C   LW V0, 108(S8)
9D0029E8  90420000   LBU V0, 0(V0)
9D0029EC  A3C20025   SB V0, 37(S8)
9D0029F0  8FC2006C   LW V0, 108(S8)
9D0029F4  24420001   ADDIU V0, V0, 1
9D0029F8  AFC2006C   SW V0, 108(S8)
2050:                						if(j >= 'a' && j <= 'z')
9D0029FC  93C20025   LBU V0, 37(S8)
9D002A00  2C420061   SLTIU V0, V0, 97
9D002A04  14400008   BNE V0, ZERO, 0x9D002A28
9D002A08  00000000   NOP
9D002A0C  93C20025   LBU V0, 37(S8)
9D002A10  2C42007B   SLTIU V0, V0, 123
9D002A14  10400004   BEQ V0, ZERO, 0x9D002A28
9D002A18  00000000   NOP
2051:                							j += 'A'-'a';
9D002A1C  93C20025   LBU V0, 37(S8)
9D002A20  2442FFE0   ADDIU V0, V0, -32
9D002A24  A3C20025   SB V0, 37(S8)
2052:                						isFinding = FALSE;
9D002A28  AFC00028   SW ZERO, 40(S8)
2053:                					}
2054:                				}
2055:                			}
2056:                		}
2057:                		else	// Compare as is
2058:                		{
2059:                			for(i = 0; i < k; i++)
9D002A54  A3C00024   SB ZERO, 36(S8)
9D002A58  0B400ACD   J 0x9D002B34
9D002A5C  00000000   NOP
9D002B28  93C20024   LBU V0, 36(S8)
9D002B2C  24420001   ADDIU V0, V0, 1
9D002B30  A3C20024   SB V0, 36(S8)
9D002B34  93C30024   LBU V1, 36(S8)
9D002B38  93C20026   LBU V0, 38(S8)
9D002B3C  0062102B   SLTU V0, V1, V0
9D002B40  1440FFC7   BNE V0, ZERO, 0x9D002A60
9D002B44  00000000   NOP
2060:                			{
2061:                				if(j == buffer[i])
9D002A60  93C20024   LBU V0, 36(S8)
9D002A64  27C30018   ADDIU V1, S8, 24
9D002A68  00621021   ADDU V0, V1, V0
9D002A6C  9042001C   LBU V0, 28(V0)
9D002A70  93C30025   LBU V1, 37(S8)
9D002A74  1462001E   BNE V1, V0, 0x9D002AF0
9D002A78  00000000   NOP
2062:                				{
2063:                					if(--wLen == 0u)
9D002A7C  97C20070   LHU V0, 112(S8)
9D002A80  2442FFFF   ADDIU V0, V0, -1
9D002A84  A7C20070   SH V0, 112(S8)
9D002A88  97C20070   LHU V0, 112(S8)
9D002A8C  1440000E   BNE V0, ZERO, 0x9D002AC8
9D002A90  00000000   NOP
2064:                						return ptrLocation-wLenStart + i + 1;
9D002A94  8FC20020   LW V0, 32(S8)
9D002A98  3043FFFF   ANDI V1, V0, -1
9D002A9C  97C2002C   LHU V0, 44(S8)
9D002AA0  00621023   SUBU V0, V1, V0
9D002AA4  3043FFFF   ANDI V1, V0, -1
9D002AA8  93C20024   LBU V0, 36(S8)
9D002AAC  3042FFFF   ANDI V0, V0, -1
9D002AB0  00621021   ADDU V0, V1, V0
9D002AB4  3042FFFF   ANDI V0, V0, -1
9D002AB8  24420001   ADDIU V0, V0, 1
9D002ABC  3042FFFF   ANDI V0, V0, -1
9D002AC0  0B400AE5   J 0x9D002B94
9D002AC4  00000000   NOP
2065:                					j = *cFindArray++;
9D002AC8  8FC2006C   LW V0, 108(S8)
9D002ACC  90420000   LBU V0, 0(V0)
9D002AD0  A3C20025   SB V0, 37(S8)
9D002AD4  8FC2006C   LW V0, 108(S8)
9D002AD8  24420001   ADDIU V0, V0, 1
9D002ADC  AFC2006C   SW V0, 108(S8)
2066:                					isFinding = TRUE;
9D002AE0  24020001   ADDIU V0, ZERO, 1
9D002AE4  AFC20028   SW V0, 40(S8)
9D002AE8  0B400ACA   J 0x9D002B28
9D002AEC  00000000   NOP
2067:                				}
2068:                				else
2069:                				{
2070:                					wLen = wLenStart;
9D002AF0  97C2002C   LHU V0, 44(S8)
9D002AF4  A7C20070   SH V0, 112(S8)
2071:                					if(isFinding)
9D002AF8  8FC20028   LW V0, 40(S8)
9D002AFC  1040000A   BEQ V0, ZERO, 0x9D002B28
9D002B00  00000000   NOP
2072:                					{
2073:                						cFindArray = cFindArrayStart;
9D002B04  8FC20030   LW V0, 48(S8)
9D002B08  AFC2006C   SW V0, 108(S8)
2074:                						j = *cFindArray++;
9D002B0C  8FC2006C   LW V0, 108(S8)
9D002B10  90420000   LBU V0, 0(V0)
9D002B14  A3C20025   SB V0, 37(S8)
9D002B18  8FC2006C   LW V0, 108(S8)
9D002B1C  24420001   ADDIU V0, V0, 1
9D002B20  AFC2006C   SW V0, 108(S8)
2075:                						isFinding = FALSE;
9D002B24  AFC00028   SW ZERO, 40(S8)
2076:                					}
2077:                				}
2078:                			}
2079:                		}
2080:                
2081:                		// Check to see if it is impossible to find a match
2082:                		wDataLen -= k;
9D002B48  93C20026   LBU V0, 38(S8)
9D002B4C  3042FFFF   ANDI V0, V0, -1
9D002B50  97C3001C   LHU V1, 28(S8)
9D002B54  00621023   SUBU V0, V1, V0
9D002B58  A7C2001C   SH V0, 28(S8)
2083:                		if(wDataLen < wLen)
9D002B5C  97C3001C   LHU V1, 28(S8)
9D002B60  97C20070   LHU V0, 112(S8)
9D002B64  0062102B   SLTU V0, V1, V0
9D002B68  10400004   BEQ V0, ZERO, 0x9D002B7C
9D002B6C  00000000   NOP
2084:                			return 0xFFFFu;
9D002B70  3402FFFF   ORI V0, ZERO, -1
9D002B74  0B400AE5   J 0x9D002B94
9D002B78  00000000   NOP
2085:                
2086:                		ptrLocation += k;
9D002B7C  93C20026   LBU V0, 38(S8)
9D002B80  8FC30020   LW V1, 32(S8)
9D002B84  00621021   ADDU V0, V1, V0
9D002B88  AFC20020   SW V0, 32(S8)
2087:                	}
9D002B8C  0B4009EB   J 0x9D0027AC
9D002B90  00000000   NOP
2088:                }
9D002B94  03C0E821   ADDU SP, S8, ZERO
9D002B98  8FBF0064   LW RA, 100(SP)
9D002B9C  8FBE0060   LW S8, 96(SP)
9D002BA0  27BD0068   ADDIU SP, SP, 104
9D002BA4  03E00008   JR RA
9D002BA8  00000000   NOP
2089:                
2090:                /*****************************************************************************
2091:                  Function:
2092:                	WORD TCPFindROMArrayEx(TCP_SOCKET hTCP, BYTE* cFindArray, WORD wLen, 
2093:                						WORD wStart, WORD wSearchLen, BOOL bTextCompare)
2094:                
2095:                  Summary:
2096:                  	Searches for a ROM string in the TCP RX buffer.
2097:                
2098:                  Description:
2099:                	This function finds the first occurrance of an array of bytes in the
2100:                	TCP RX buffer.  It can be used by an application to abstract searches 
2101:                	out of their own application code.  For increased efficiency, the 
2102:                	function is capable of limiting the scope of search to a specific
2103:                	range of bytes.  It can also perform a case-insensitive search if
2104:                	required.
2105:                	
2106:                	For example, if the buffer contains "I love PIC MCUs!" and the search
2107:                	array is "love" with a length of 4, a value of 2 will be returned.
2108:                
2109:                  Precondition:
2110:                	TCP is initialized.
2111:                
2112:                  Parameters:
2113:                	hTCP - The socket to search within.
2114:                	cFindArray - The array of bytes to find in the buffer.
2115:                	wLen - Length of cFindArray.
2116:                	wStart - Zero-indexed starting position within the buffer.
2117:                	wSearchLen - Length from wStart to search in the buffer.
2118:                	bTextCompare - TRUE for case-insensitive text search, FALSE for binary search
2119:                
2120:                  Return Values:
2121:                	0xFFFF - Search array not found
2122:                	Otherwise - Zero-indexed position of the first occurrance
2123:                
2124:                  Remarks:
2125:                	Since this function usually must transfer data from external storage
2126:                	to internal RAM for comparison, its performance degrades significantly
2127:                	when the buffer is full and the array is not found.  For better 
2128:                	performance, try to search for characters that are expected to exist or
2129:                	limit the scope of the search as much as possible.  The HTTP2 module, 
2130:                	for example, uses this function to parse headers.  However, it searches 
2131:                	for newlines, then the separating colon, then reads the header name to 
2132:                	RAM for final comparison.  This has proven to be significantly faster  
2133:                	than searching for full header name strings outright.
2134:                	
2135:                	This function is aliased to TCPFindArrayEx on non-PIC18 platforms.
2136:                  ***************************************************************************/
2137:                #if defined(__18CXX)
2138:                WORD TCPFindROMArrayEx(TCP_SOCKET hTCP, ROM BYTE* cFindArray, WORD wLen, WORD wStart, WORD wSearchLen, BOOL bTextCompare)
2139:                {
2140:                	PTR_BASE ptrRead;
2141:                	WORD wDataLen;
2142:                	WORD wBytesUntilWrap;
2143:                	PTR_BASE ptrLocation;
2144:                	WORD wLenStart;
2145:                	ROM BYTE *cFindArrayStart;
2146:                	BYTE i, j, k;
2147:                	BOOL isFinding;
2148:                	BYTE buffer[32];
2149:                
2150:                	if(hTCP >= TCP_SOCKET_COUNT || wLen == 0)
2151:                    {
2152:                        return 0;
2153:                    }
2154:                    
2155:                	SyncTCBStub(hTCP);
2156:                
2157:                	// Find out how many bytes are in the RX FIFO and return 
2158:                	// immediately if we won't possibly find a match
2159:                	wDataLen = TCPIsGetReady(hTCP) - wStart;
2160:                	if(wDataLen < wLen)
2161:                		return 0xFFFFu;
2162:                	if(wSearchLen && (wDataLen > wSearchLen))
2163:                		wDataLen = wSearchLen;
2164:                
2165:                	ptrLocation = MyTCBStub.rxTail + wStart;
2166:                	if(ptrLocation > MyTCBStub.bufferEnd)
2167:                		ptrLocation -= MyTCBStub.bufferEnd - MyTCBStub.bufferRxStart + 1;
2168:                	ptrRead = ptrLocation;
2169:                	wBytesUntilWrap = MyTCBStub.bufferEnd - ptrLocation + 1;
2170:                	ptrLocation = wStart;
2171:                	wLenStart = wLen;
2172:                	cFindArrayStart = cFindArray;
2173:                	j = *cFindArray++;
2174:                	isFinding = FALSE;
2175:                	if(bTextCompare)
2176:                	{
2177:                		if(j >= 'a' && j <= 'z')
2178:                			j += 'A'-'a';
2179:                	}
2180:                
2181:                	// Search for the array
2182:                	while(1)
2183:                	{
2184:                		// Figure out how big of a chunk to read
2185:                		k = sizeof(buffer);
2186:                		if(k > wBytesUntilWrap)
2187:                			k = wBytesUntilWrap;
2188:                		if((WORD)k > wDataLen)
2189:                			k = wDataLen;
2190:                
2191:                		// Read a chunk of data into the buffer
2192:                		TCPRAMCopy((PTR_BASE)buffer, TCP_PIC_RAM, ptrRead, MyTCBStub.vMemoryMedium, (WORD)k);
2193:                		ptrRead += k;
2194:                		wBytesUntilWrap -= k;
2195:                
2196:                		if(wBytesUntilWrap == 0u)
2197:                		{
2198:                			ptrRead = MyTCBStub.bufferRxStart;
2199:                			wBytesUntilWrap = 0xFFFFu;
2200:                		}
2201:                
2202:                		// Convert everything to uppercase
2203:                		if(bTextCompare)
2204:                		{
2205:                			for(i = 0; i < k; i++)
2206:                			{
2207:                				if(buffer[i] >= 'a' && buffer[i] <= 'z')
2208:                					buffer[i] += 'A'-'a';
2209:                
2210:                				if(j == buffer[i])
2211:                				{
2212:                					if(--wLen == 0u)
2213:                						return ptrLocation-wLenStart + i + 1;
2214:                					j = *cFindArray++;
2215:                					isFinding = TRUE;
2216:                					if(j >= 'a' && j <= 'z')
2217:                						j += 'A'-'a';
2218:                				}
2219:                				else
2220:                				{
2221:                					wLen = wLenStart;
2222:                					if(isFinding)
2223:                					{
2224:                						cFindArray = cFindArrayStart;
2225:                						j = *cFindArray++;
2226:                						if(j >= 'a' && j <= 'z')
2227:                							j += 'A'-'a';
2228:                						isFinding = FALSE;
2229:                					}
2230:                				}
2231:                			}
2232:                		}
2233:                		else	// Compare as is
2234:                		{
2235:                			for(i = 0; i < k; i++)
2236:                			{
2237:                				if(j == buffer[i])
2238:                				{
2239:                					if(--wLen == 0u)
2240:                						return ptrLocation-wLenStart + i + 1;
2241:                					j = *cFindArray++;
2242:                					isFinding = TRUE;
2243:                				}
2244:                				else
2245:                				{
2246:                					wLen = wLenStart;
2247:                					if(isFinding)
2248:                					{
2249:                						cFindArray = cFindArrayStart;
2250:                						j = *cFindArray++;
2251:                						isFinding = FALSE;
2252:                					}
2253:                				}
2254:                			}
2255:                		}
2256:                
2257:                		// Check to see if it is impossible to find a match
2258:                		wDataLen -= k;
2259:                		if(wDataLen < wLen)
2260:                			return 0xFFFFu;
2261:                
2262:                		ptrLocation += k;
2263:                	}
2264:                }
2265:                #endif
2266:                
2267:                
2268:                /*****************************************************************************
2269:                  Function:
2270:                	WORD TCPFindEx(TCP_SOCKET hTCP, BYTE cFind,
2271:                						WORD wStart, WORD wSearchLen, BOOL bTextCompare)
2272:                
2273:                  Summary:
2274:                  	Searches for a byte in the TCP RX buffer.
2275:                
2276:                  Description:
2277:                	This function finds the first occurrance of a byte in the TCP RX
2278:                	buffer.  It can be used by an application to abstract searches 
2279:                	out of their own application code.  For increased efficiency, the 
2280:                	function is capable of limiting the scope of search to a specific
2281:                	range of bytes.  It can also perform a case-insensitive search if
2282:                	required.
2283:                	
2284:                	For example, if the buffer contains "I love PIC MCUs!" and the cFind
2285:                	byte is ' ', a value of 1 will be returned.
2286:                
2287:                  Precondition:
2288:                	TCP is initialized.
2289:                
2290:                  Parameters:
2291:                	hTCP - The socket to search within.
2292:                	cFind - The byte to find in the buffer.
2293:                	wStart - Zero-indexed starting position within the buffer.
2294:                	wSearchLen - Length from wStart to search in the buffer.
2295:                	bTextCompare - TRUE for case-insensitive text search, FALSE for binary search
2296:                
2297:                  Return Values:
2298:                	0xFFFF - Search array not found
2299:                	Otherwise - Zero-indexed position of the first occurrance
2300:                
2301:                  Remarks:
2302:                	Since this function usually must transfer data from external storage
2303:                	to internal RAM for comparison, its performance degrades significantly
2304:                	when the buffer is full and the array is not found.  For better 
2305:                	performance, try to search for characters that are expected to exist or
2306:                	limit the scope of the search as much as possible.  The HTTP2 module, 
2307:                	for example, uses this function to parse headers.  However, it searches 
2308:                	for newlines, then the separating colon, then reads the header name to 
2309:                	RAM for final comparison.  This has proven to be significantly faster  
2310:                	than searching for full header name strings outright.
2311:                  ***************************************************************************/
2312:                WORD TCPFindEx(TCP_SOCKET hTCP, BYTE cFind, WORD wStart, WORD wSearchLen, BOOL bTextCompare)
2313:                {
9D002BAC  27BDFFE0   ADDIU SP, SP, -32
9D002BB0  AFBF001C   SW RA, 28(SP)
9D002BB4  AFBE0018   SW S8, 24(SP)
9D002BB8  03A0F021   ADDU S8, SP, ZERO
9D002BBC  00804021   ADDU T0, A0, ZERO
9D002BC0  00A02021   ADDU A0, A1, ZERO
9D002BC4  00C01821   ADDU V1, A2, ZERO
9D002BC8  00E01021   ADDU V0, A3, ZERO
9D002BCC  A3C80020   SB T0, 32(S8)
9D002BD0  A3C40024   SB A0, 36(S8)
9D002BD4  A7C30028   SH V1, 40(S8)
9D002BD8  A7C2002C   SH V0, 44(S8)
2314:                	return TCPFindArrayEx(hTCP, &cFind, sizeof(cFind), wStart, wSearchLen, bTextCompare);
9D002BDC  93C40020   LBU A0, 32(S8)
9D002BE0  97C20028   LHU V0, 40(S8)
9D002BE4  97C5002C   LHU A1, 44(S8)
9D002BE8  27C30024   ADDIU V1, S8, 36
9D002BEC  AFA50010   SW A1, 16(SP)
9D002BF0  8FC50030   LW A1, 48(S8)
9D002BF4  AFA50014   SW A1, 20(SP)
9D002BF8  00602821   ADDU A1, V1, ZERO
9D002BFC  24060001   ADDIU A2, ZERO, 1
9D002C00  00403821   ADDU A3, V0, ZERO
9D002C04  0F400960   JAL TCPFindArrayEx
9D002C08  00000000   NOP
2315:                }
9D002C0C  03C0E821   ADDU SP, S8, ZERO
9D002C10  8FBF001C   LW RA, 28(SP)
9D002C14  8FBE0018   LW S8, 24(SP)
9D002C18  27BD0020   ADDIU SP, SP, 32
9D002C1C  03E00008   JR RA
9D002C20  00000000   NOP
2316:                
2317:                
2318:                
2319:                /****************************************************************************
2320:                  Section:
2321:                	Data Processing Functions
2322:                  ***************************************************************************/
2323:                
2324:                /*****************************************************************************
2325:                  Function:
2326:                	void TCPTick(void)
2327:                
2328:                  Summary:
2329:                  	Performs periodic TCP tasks.
2330:                
2331:                  Description:
2332:                	This function performs any required periodic TCP tasks.  Each 
2333:                	socket's state machine is checked, and any elapsed timeout periods
2334:                	are handled.
2335:                
2336:                  Precondition:
2337:                	TCP is initialized.
2338:                
2339:                  Parameters:
2340:                	None
2341:                
2342:                  Returns:
2343:                	None
2344:                  ***************************************************************************/
2345:                void TCPTick(void)
2346:                {
9D002C24  27BDFFC0   ADDIU SP, SP, -64
9D002C28  AFBF003C   SW RA, 60(SP)
9D002C2C  AFBE0038   SW S8, 56(SP)
9D002C30  AFB00034   SW S0, 52(SP)
9D002C34  03A0F021   ADDU S8, SP, ZERO
2347:                	TCP_SOCKET hTCP;
2348:                	BOOL bRetransmit;
2349:                	BOOL bCloseSocket;
2350:                	BYTE vFlags;
2351:                	WORD w;
2352:                
2353:                	// Periodically all "not closed" sockets must perform timed operations
2354:                	for(hTCP = 0; hTCP < TCP_SOCKET_COUNT; hTCP++)
9D002C38  A3C00018   SB ZERO, 24(S8)
9D002C3C  0B400ED9   J 0x9D003B64
9D002C40  00000000   NOP
9D003B58  93C20018   LBU V0, 24(S8)
9D003B5C  24420001   ADDIU V0, V0, 1
9D003B60  A3C20018   SB V0, 24(S8)
9D003B64  93C20018   LBU V0, 24(S8)
9D003B68  2C420009   SLTIU V0, V0, 9
9D003B6C  1440FC35   BNE V0, ZERO, 0x9D002C44
9D003B70  00000000   NOP
2355:                	{
2356:                		SyncTCBStub(hTCP);
9D002C44  93C20018   LBU V0, 24(S8)
9D002C48  A3828027   SB V0, -32729(GP)
2357:                		
2358:                		// Handle any SSL Processing and Message Transmission
2359:                		#if defined(STACK_USE_SSL)
2360:                		if(MyTCBStub.sslStubID != SSL_INVALID_ID)
2361:                		{
2362:                			// Handle any periodic tasks, such as RSA operations
2363:                			SSLPeriodic(hTCP, MyTCBStub.sslStubID);
2364:                			
2365:                			// If unsent data is waiting, transmit it as an application record
2366:                			if(MyTCBStub.sslTxHead != MyTCBStub.txHead && TCPSSLGetPendingTxSize(hTCP) != 0u)
2367:                				SSLTxRecord(hTCP, MyTCBStub.sslStubID, SSL_APPLICATION);
2368:                			
2369:                			// If an SSL message is requested, send it now
2370:                			if(MyTCBStub.sslReqMessage != SSL_NO_MESSAGE)
2371:                				SSLTxMessage(hTCP, MyTCBStub.sslStubID, MyTCBStub.sslReqMessage);
2372:                		}
2373:                		#endif
2374:                		
2375:                		vFlags = 0x00;
9D002C4C  A3C00024   SB ZERO, 36(S8)
2376:                		bRetransmit = FALSE;
9D002C50  AFC0001C   SW ZERO, 28(S8)
2377:                		bCloseSocket = FALSE;
9D002C54  AFC00020   SW ZERO, 32(S8)
2378:                
2379:                		// Transmit ASAP data if the medium is available
2380:                		if(MyTCBStub.Flags.bTXASAP || MyTCBStub.Flags.bTXASAPWithoutTimerReset)
9D002C58  93828027   LBU V0, -32729(GP)
9D002C5C  00402021   ADDU A0, V0, ZERO
9D002C60  3C02A000   LUI V0, -24576
9D002C64  24030030   ADDIU V1, ZERO, 48
9D002C68  70831802   MUL V1, A0, V1
9D002C6C  24422CDC   ADDIU V0, V0, 11484
9D002C70  00621021   ADDU V0, V1, V0
9D002C74  8C420028   LW V0, 40(V0)
9D002C78  7C420240   EXT V0, V0, 9, 1
9D002C7C  304200FF   ANDI V0, V0, 255
9D002C80  1440000D   BNE V0, ZERO, 0x9D002CB8
9D002C84  00000000   NOP
9D002C88  93828027   LBU V0, -32729(GP)
9D002C8C  00402021   ADDU A0, V0, ZERO
9D002C90  3C02A000   LUI V0, -24576
9D002C94  24030030   ADDIU V1, ZERO, 48
9D002C98  70831802   MUL V1, A0, V1
9D002C9C  24422CDC   ADDIU V0, V0, 11484
9D002CA0  00621021   ADDU V0, V1, V0
9D002CA4  8C420028   LW V0, 40(V0)
9D002CA8  7C420280   EXT V0, V0, 10, 1
9D002CAC  304200FF   ANDI V0, V0, 255
9D002CB0  10400012   BEQ V0, ZERO, 0x9D002CFC
9D002CB4  00000000   NOP
2381:                		{
2382:                			if(MACIsTxReady())
9D002CB8  0F40727E   JAL MACIsTxReady
9D002CBC  00000000   NOP
9D002CC0  1040000E   BEQ V0, ZERO, 0x9D002CFC
9D002CC4  00000000   NOP
2383:                			{
2384:                				vFlags = ACK;
9D002CC8  24020010   ADDIU V0, ZERO, 16
9D002CCC  A3C20024   SB V0, 36(S8)
2385:                				bRetransmit = MyTCBStub.Flags.bTXASAPWithoutTimerReset;
9D002CD0  93828027   LBU V0, -32729(GP)
9D002CD4  00402021   ADDU A0, V0, ZERO
9D002CD8  3C02A000   LUI V0, -24576
9D002CDC  24030030   ADDIU V1, ZERO, 48
9D002CE0  70831802   MUL V1, A0, V1
9D002CE4  24422CDC   ADDIU V0, V0, 11484
9D002CE8  00621021   ADDU V0, V1, V0
9D002CEC  8C420028   LW V0, 40(V0)
9D002CF0  7C420280   EXT V0, V0, 10, 1
9D002CF4  304200FF   ANDI V0, V0, 255
9D002CF8  AFC2001C   SW V0, 28(S8)
2386:                			}
2387:                		}
2388:                
2389:                		// Perform any needed window updates and data transmissions
2390:                		if(MyTCBStub.Flags.bTimer2Enabled)
9D002CFC  93828027   LBU V0, -32729(GP)
9D002D00  00402021   ADDU A0, V0, ZERO
9D002D04  3C02A000   LUI V0, -24576
9D002D08  24030030   ADDIU V1, ZERO, 48
9D002D0C  70831802   MUL V1, A0, V1
9D002D10  24422CDC   ADDIU V0, V0, 11484
9D002D14  00621021   ADDU V0, V1, V0
9D002D18  8C420028   LW V0, 40(V0)
9D002D1C  7C420140   EXT V0, V0, 5, 1
9D002D20  304200FF   ANDI V0, V0, 255
9D002D24  10400013   BEQ V0, ZERO, 0x9D002D74
9D002D28  00000000   NOP
2391:                		{
2392:                			// See if the timeout has occured, and we need to send a new window update and pending data
2393:                			if((SHORT)(MyTCBStub.eventTime2 - (WORD)TickGetDiv256()) <= (SHORT)0)
9D002D2C  93828027   LBU V0, -32729(GP)
9D002D30  00402021   ADDU A0, V0, ZERO
9D002D34  3C02A000   LUI V0, -24576
9D002D38  24030030   ADDIU V1, ZERO, 48
9D002D3C  70831802   MUL V1, A0, V1
9D002D40  24422CDC   ADDIU V0, V0, 11484
9D002D44  00621021   ADDU V0, V1, V0
9D002D48  94500020   LHU S0, 32(V0)
9D002D4C  0F40CDE4   JAL TickGetDiv256
9D002D50  00000000   NOP
9D002D54  3042FFFF   ANDI V0, V0, -1
9D002D58  02021023   SUBU V0, S0, V0
9D002D5C  3042FFFF   ANDI V0, V0, -1
9D002D60  7C021620   SEH V0, V0
9D002D64  1C400003   BGTZ V0, 0x9D002D74
9D002D68  00000000   NOP
2394:                				vFlags = ACK;
9D002D6C  24020010   ADDIU V0, ZERO, 16
9D002D70  A3C20024   SB V0, 36(S8)
2395:                		}
2396:                
2397:                		// Process Delayed ACKnowledgement timer
2398:                		if(MyTCBStub.Flags.bDelayedACKTimerEnabled)
9D002D74  93828027   LBU V0, -32729(GP)
9D002D78  00402021   ADDU A0, V0, ZERO
9D002D7C  3C02A000   LUI V0, -24576
9D002D80  24030030   ADDIU V1, ZERO, 48
9D002D84  70831802   MUL V1, A0, V1
9D002D88  24422CDC   ADDIU V0, V0, 11484
9D002D8C  00621021   ADDU V0, V1, V0
9D002D90  8C420028   LW V0, 40(V0)
9D002D94  7C420180   EXT V0, V0, 6, 1
9D002D98  304200FF   ANDI V0, V0, 255
9D002D9C  10400013   BEQ V0, ZERO, 0x9D002DEC
9D002DA0  00000000   NOP
2399:                		{
2400:                			// See if the timeout has occured and delayed ACK needs to be sent
2401:                			if((SHORT)(MyTCBStub.OverlappedTimers.delayedACKTime - (WORD)TickGetDiv256()) <= (SHORT)0)
9D002DA4  93828027   LBU V0, -32729(GP)
9D002DA8  00402021   ADDU A0, V0, ZERO
9D002DAC  3C02A000   LUI V0, -24576
9D002DB0  24030030   ADDIU V1, ZERO, 48
9D002DB4  70831802   MUL V1, A0, V1
9D002DB8  24422CDC   ADDIU V0, V0, 11484
9D002DBC  00621021   ADDU V0, V1, V0
9D002DC0  94500022   LHU S0, 34(V0)
9D002DC4  0F40CDE4   JAL TickGetDiv256
9D002DC8  00000000   NOP
9D002DCC  3042FFFF   ANDI V0, V0, -1
9D002DD0  02021023   SUBU V0, S0, V0
9D002DD4  3042FFFF   ANDI V0, V0, -1
9D002DD8  7C021620   SEH V0, V0
9D002DDC  1C400003   BGTZ V0, 0x9D002DEC
9D002DE0  00000000   NOP
2402:                				vFlags = ACK;
9D002DE4  24020010   ADDIU V0, ZERO, 16
9D002DE8  A3C20024   SB V0, 36(S8)
2403:                		}
2404:                		
2405:                		// Process TCP_CLOSE_WAIT timer
2406:                		if(MyTCBStub.smState == TCP_CLOSE_WAIT)
9D002DEC  93828027   LBU V0, -32729(GP)
9D002DF0  00402021   ADDU A0, V0, ZERO
9D002DF4  3C02A000   LUI V0, -24576
9D002DF8  24432CDC   ADDIU V1, V0, 11484
9D002DFC  24020030   ADDIU V0, ZERO, 48
9D002E00  70821002   MUL V0, A0, V0
9D002E04  00621021   ADDU V0, V1, V0
9D002E08  8C430024   LW V1, 36(V0)
9D002E0C  2402000B   ADDIU V0, ZERO, 11
9D002E10  1462001C   BNE V1, V0, 0x9D002E84
9D002E14  00000000   NOP
2407:                		{
2408:                			// Automatically close the socket on our end if the application 
2409:                			// fails to call TCPDisconnect() is a reasonable amount of time.
2410:                			if((SHORT)(MyTCBStub.OverlappedTimers.closeWaitTime - (WORD)TickGetDiv256()) <= (SHORT)0)
9D002E18  93828027   LBU V0, -32729(GP)
9D002E1C  00402021   ADDU A0, V0, ZERO
9D002E20  3C02A000   LUI V0, -24576
9D002E24  24030030   ADDIU V1, ZERO, 48
9D002E28  70831802   MUL V1, A0, V1
9D002E2C  24422CDC   ADDIU V0, V0, 11484
9D002E30  00621021   ADDU V0, V1, V0
9D002E34  94500022   LHU S0, 34(V0)
9D002E38  0F40CDE4   JAL TickGetDiv256
9D002E3C  00000000   NOP
9D002E40  3042FFFF   ANDI V0, V0, -1
9D002E44  02021023   SUBU V0, S0, V0
9D002E48  3042FFFF   ANDI V0, V0, -1
9D002E4C  7C021620   SEH V0, V0
9D002E50  1C40000C   BGTZ V0, 0x9D002E84
9D002E54  00000000   NOP
2411:                			{
2412:                				vFlags = FIN | ACK;
9D002E58  24020011   ADDIU V0, ZERO, 17
9D002E5C  A3C20024   SB V0, 36(S8)
2413:                				MyTCBStub.smState = TCP_LAST_ACK;
9D002E60  93828027   LBU V0, -32729(GP)
9D002E64  00402021   ADDU A0, V0, ZERO
9D002E68  3C02A000   LUI V0, -24576
9D002E6C  24432CDC   ADDIU V1, V0, 11484
9D002E70  24020030   ADDIU V0, ZERO, 48
9D002E74  70821002   MUL V0, A0, V0
9D002E78  00621021   ADDU V0, V1, V0
9D002E7C  2403000C   ADDIU V1, ZERO, 12
9D002E80  AC430024   SW V1, 36(V0)
2414:                			}
2415:                		}
2416:                
2417:                		// Process listening server sockets that might have a SYN waiting in the SYNQueue[]
2418:                		#if TCP_SYN_QUEUE_MAX_ENTRIES
2419:                			if(MyTCBStub.smState == TCP_LISTEN)
9D002E84  93828027   LBU V0, -32729(GP)
9D002E88  00402021   ADDU A0, V0, ZERO
9D002E8C  3C02A000   LUI V0, -24576
9D002E90  24432CDC   ADDIU V1, V0, 11484
9D002E94  24020030   ADDIU V0, ZERO, 48
9D002E98  70821002   MUL V0, A0, V0
9D002E9C  00621021   ADDU V0, V1, V0
9D002EA0  8C430024   LW V1, 36(V0)
9D002EA4  24020004   ADDIU V0, ZERO, 4
9D002EA8  14620093   BNE V1, V0, 0x9D0030F8
9D002EAC  00000000   NOP
2420:                			{
2421:                				for(w = 0; w < TCP_SYN_QUEUE_MAX_ENTRIES; w++)
9D002EB0  A7C00026   SH ZERO, 38(S8)
9D002EB4  0B400C37   J 0x9D0030DC
9D002EB8  00000000   NOP
9D0030D0  97C20026   LHU V0, 38(S8)
9D0030D4  24420001   ADDIU V0, V0, 1
9D0030D8  A7C20026   SH V0, 38(S8)
9D0030DC  97C20026   LHU V0, 38(S8)
9D0030E0  2C420003   SLTIU V0, V0, 3
9D0030E4  1440FF75   BNE V0, ZERO, 0x9D002EBC
9D0030E8  00000000   NOP
9D0030EC  0B400C3E   J 0x9D0030F8
9D0030F0  00000000   NOP
2422:                				{
2423:                					// Abort search if there are no more valid records
2424:                					if(SYNQueue[w].wDestPort == 0u)
9D002EBC  97C40026   LHU A0, 38(S8)
9D002EC0  3C02A000   LUI V0, -24576
9D002EC4  24030014   ADDIU V1, ZERO, 20
9D002EC8  70831802   MUL V1, A0, V1
9D002ECC  24422EB8   ADDIU V0, V0, 11960
9D002ED0  00621021   ADDU V0, V1, V0
9D002ED4  94420010   LHU V0, 16(V0)
9D002ED8  10400086   BEQ V0, ZERO, 0x9D0030F4
9D002EDC  00000000   NOP
2425:                						break;
9D0030F4  00000000   NOP
2426:                					
2427:                					// Stop searching if this SYN queue entry can be used by this socket
2428:                					#if defined(STACK_USE_SSL_SERVER)
2429:                					if(SYNQueue[w].wDestPort == MyTCBStub.remoteHash.Val || SYNQueue[w].wDestPort == MyTCBStub.sslTxHead)
2430:                					#else
2431:                					if(SYNQueue[w].wDestPort == MyTCBStub.remoteHash.Val)
9D002EE0  97C40026   LHU A0, 38(S8)
9D002EE4  3C02A000   LUI V0, -24576
9D002EE8  24030014   ADDIU V1, ZERO, 20
9D002EEC  70831802   MUL V1, A0, V1
9D002EF0  24422EB8   ADDIU V0, V0, 11960
9D002EF4  00621021   ADDU V0, V1, V0
9D002EF8  94430010   LHU V1, 16(V0)
9D002EFC  93828027   LBU V0, -32729(GP)
9D002F00  00402821   ADDU A1, V0, ZERO
9D002F04  3C02A000   LUI V0, -24576
9D002F08  24040030   ADDIU A0, ZERO, 48
9D002F0C  70A42002   MUL A0, A1, A0
9D002F10  24422CDC   ADDIU V0, V0, 11484
9D002F14  00821021   ADDU V0, A0, V0
9D002F18  9442002A   LHU V0, 42(V0)
9D002F1C  1462006C   BNE V1, V0, 0x9D0030D0
9D002F20  00000000   NOP
2432:                					#endif
2433:                					{
2434:                						// Set up our socket and generate a reponse SYN+ACK packet
2435:                						SyncTCB();
9D002F24  0F400008   JAL SyncTCB
9D002F28  00000000   NOP
2436:                						
2437:                						#if defined(STACK_USE_SSL_SERVER)
2438:                						// If this matches the SSL port, make sure that can be configured
2439:                						// before continuing.  If not, break and leave this in the queue
2440:                						if(SYNQueue[w].wDestPort == MyTCBStub.sslTxHead && !TCPStartSSLServer(hTCP))
2441:                							break;
2442:                						#endif
2443:                						
2444:                						memcpy((void*)&MyTCB.remote.niRemoteMACIP, (void*)&SYNQueue[w].niSourceAddress, sizeof(NODE_INFO));
9D002F2C  97C30026   LHU V1, 38(S8)
9D002F30  24020014   ADDIU V0, ZERO, 20
9D002F34  70621802   MUL V1, V1, V0
9D002F38  3C02A000   LUI V0, -24576
9D002F3C  24422EB8   ADDIU V0, V0, 11960
9D002F40  00621021   ADDU V0, V1, V0
9D002F44  3C03A000   LUI V1, -24576
9D002F48  24642EA4   ADDIU A0, V1, 11940
9D002F4C  00402821   ADDU A1, V0, ZERO
9D002F50  2406000A   ADDIU A2, ZERO, 10
9D002F54  0F40D298   JAL 0x9D034A60
9D002F58  00000000   NOP
2445:                						MyTCB.remotePort.Val = SYNQueue[w].wSourcePort;
9D002F5C  97C40026   LHU A0, 38(S8)
9D002F60  3C02A000   LUI V0, -24576
9D002F64  24030014   ADDIU V1, ZERO, 20
9D002F68  70831802   MUL V1, A0, V1
9D002F6C  24422EB8   ADDIU V0, V0, 11960
9D002F70  00621021   ADDU V0, V1, V0
9D002F74  9443000A   LHU V1, 10(V0)
9D002F78  3C02A000   LUI V0, -24576
9D002F7C  24422E8C   ADDIU V0, V0, 11916
9D002F80  A4430010   SH V1, 16(V0)
2446:                						MyTCB.RemoteSEQ = SYNQueue[w].dwSourceSEQ + 1;
9D002F84  97C40026   LHU A0, 38(S8)
9D002F88  3C02A000   LUI V0, -24576
9D002F8C  24432EB8   ADDIU V1, V0, 11960
9D002F90  24020014   ADDIU V0, ZERO, 20
9D002F94  70821002   MUL V0, A0, V0
9D002F98  00621021   ADDU V0, V1, V0
9D002F9C  8C42000C   LW V0, 12(V0)
9D002FA0  24430001   ADDIU V1, V0, 1
9D002FA4  3C02A000   LUI V0, -24576
9D002FA8  24422E8C   ADDIU V0, V0, 11916
9D002FAC  AC430008   SW V1, 8(V0)
2447:                						MyTCBStub.remoteHash.Val = (MyTCB.remote.niRemoteMACIP.IPAddr.w[1] + MyTCB.remote.niRemoteMACIP.IPAddr.w[0] + MyTCB.remotePort.Val) ^ MyTCB.localPort.Val;
9D002FB0  93828027   LBU V0, -32729(GP)
9D002FB4  00402821   ADDU A1, V0, ZERO
9D002FB8  3C02A000   LUI V0, -24576
9D002FBC  24422E8C   ADDIU V0, V0, 11916
9D002FC0  9443001A   LHU V1, 26(V0)
9D002FC4  3C02A000   LUI V0, -24576
9D002FC8  24422E8C   ADDIU V0, V0, 11916
9D002FCC  94420018   LHU V0, 24(V0)
9D002FD0  00621021   ADDU V0, V1, V0
9D002FD4  3043FFFF   ANDI V1, V0, -1
9D002FD8  3C02A000   LUI V0, -24576
9D002FDC  24422E8C   ADDIU V0, V0, 11916
9D002FE0  94420010   LHU V0, 16(V0)
9D002FE4  00621021   ADDU V0, V1, V0
9D002FE8  3042FFFF   ANDI V0, V0, -1
9D002FEC  7C021E20   SEH V1, V0
9D002FF0  3C02A000   LUI V0, -24576
9D002FF4  24422E8C   ADDIU V0, V0, 11916
9D002FF8  94420012   LHU V0, 18(V0)
9D002FFC  7C021620   SEH V0, V0
9D003000  00621026   XOR V0, V1, V0
9D003004  7C021620   SEH V0, V0
9D003008  3043FFFF   ANDI V1, V0, -1
9D00300C  3C02A000   LUI V0, -24576
9D003010  24040030   ADDIU A0, ZERO, 48
9D003014  70A42002   MUL A0, A1, A0
9D003018  24422CDC   ADDIU V0, V0, 11484
9D00301C  00821021   ADDU V0, A0, V0
9D003020  A443002A   SH V1, 42(V0)
2448:                						vFlags = SYN | ACK;
9D003024  24020012   ADDIU V0, ZERO, 18
9D003028  A3C20024   SB V0, 36(S8)
2449:                						MyTCBStub.smState = TCP_SYN_RECEIVED;
9D00302C  93828027   LBU V0, -32729(GP)
9D003030  00402021   ADDU A0, V0, ZERO
9D003034  3C02A000   LUI V0, -24576
9D003038  24432CDC   ADDIU V1, V0, 11484
9D00303C  24020030   ADDIU V0, ZERO, 48
9D003040  70821002   MUL V0, A0, V0
9D003044  00621021   ADDU V0, V1, V0
9D003048  24030006   ADDIU V1, ZERO, 6
9D00304C  AC430024   SW V1, 36(V0)
2450:                						
2451:                						// Delete this SYN from the SYNQueue and compact the SYNQueue[] array
2452:                						TCPRAMCopy((PTR_BASE)&SYNQueue[w], TCP_PIC_RAM, (PTR_BASE)&SYNQueue[w+1], TCP_PIC_RAM, (TCP_SYN_QUEUE_MAX_ENTRIES-1u-w)*sizeof(TCP_SYN_QUEUE));
9D003050  97C30026   LHU V1, 38(S8)
9D003054  24020014   ADDIU V0, ZERO, 20
9D003058  70621802   MUL V1, V1, V0
9D00305C  3C02A000   LUI V0, -24576
9D003060  24422EB8   ADDIU V0, V0, 11960
9D003064  00621021   ADDU V0, V1, V0
9D003068  00401821   ADDU V1, V0, ZERO
9D00306C  97C20026   LHU V0, 38(S8)
9D003070  24440001   ADDIU A0, V0, 1
9D003074  24020014   ADDIU V0, ZERO, 20
9D003078  70822002   MUL A0, A0, V0
9D00307C  3C02A000   LUI V0, -24576
9D003080  24422EB8   ADDIU V0, V0, 11960
9D003084  00821021   ADDU V0, A0, V0
9D003088  97C50026   LHU A1, 38(S8)
9D00308C  2404FFEC   ADDIU A0, ZERO, -20
9D003090  70A42002   MUL A0, A1, A0
9D003094  3084FFFF   ANDI A0, A0, -1
9D003098  24840028   ADDIU A0, A0, 40
9D00309C  3084FFFF   ANDI A0, A0, -1
9D0030A0  AFA40010   SW A0, 16(SP)
9D0030A4  00602021   ADDU A0, V1, ZERO
9D0030A8  24050001   ADDIU A1, ZERO, 1
9D0030AC  00403021   ADDU A2, V0, ZERO
9D0030B0  24070001   ADDIU A3, ZERO, 1
9D0030B4  0F4020BE   JAL TCPRAMCopy
9D0030B8  00000000   NOP
2453:                						SYNQueue[TCP_SYN_QUEUE_MAX_ENTRIES-1].wDestPort = 0u;
9D0030BC  3C02A000   LUI V0, -24576
9D0030C0  24422EB8   ADDIU V0, V0, 11960
9D0030C4  A4400038   SH ZERO, 56(V0)
2454:                	
2455:                						break;
9D0030C8  0B400C3E   J 0x9D0030F8
9D0030CC  00000000   NOP
2456:                					}
2457:                				}
2458:                			}
2459:                		#endif
2460:                
2461:                		if(vFlags)
9D0030F8  93C20024   LBU V0, 36(S8)
9D0030FC  10400008   BEQ V0, ZERO, 0x9D003120
9D003100  00000000   NOP
2462:                			SendTCP(vFlags, bRetransmit ? 0 : SENDTCP_RESET_TIMERS);
9D003104  93C30024   LBU V1, 36(S8)
9D003108  8FC2001C   LW V0, 28(S8)
9D00310C  2C420001   SLTIU V0, V0, 1
9D003110  00602021   ADDU A0, V1, ZERO
9D003114  00402821   ADDU A1, V0, ZERO
9D003118  0F400F8B   JAL SendTCP
9D00311C  00000000   NOP
2463:                
2464:                		// The TCP_CLOSED, TCP_LISTEN, and sometimes the TCP_ESTABLISHED 
2465:                		// state don't need any timeout events, so see if the timer is enabled
2466:                		if(!MyTCBStub.Flags.bTimerEnabled)
9D003120  93828027   LBU V0, -32729(GP)
9D003124  00402021   ADDU A0, V0, ZERO
9D003128  3C02A000   LUI V0, -24576
9D00312C  24030030   ADDIU V1, ZERO, 48
9D003130  70831802   MUL V1, A0, V1
9D003134  24422CDC   ADDIU V0, V0, 11484
9D003138  00621021   ADDU V0, V1, V0
9D00313C  8C420028   LW V0, 40(V0)
9D003140  7C420100   EXT V0, V0, 4, 1
9D003144  304200FF   ANDI V0, V0, 255
9D003148  1440005E   BNE V0, ZERO, 0x9D0032C4
9D00314C  00000000   NOP
2467:                		{
2468:                			#if defined(TCP_KEEP_ALIVE_TIMEOUT)
2469:                				// Only the established state has any use for keep-alives
2470:                				if(MyTCBStub.smState == TCP_ESTABLISHED)
9D003150  93828027   LBU V0, -32729(GP)
9D003154  00402021   ADDU A0, V0, ZERO
9D003158  3C02A000   LUI V0, -24576
9D00315C  24432CDC   ADDIU V1, V0, 11484
9D003160  24020030   ADDIU V0, ZERO, 48
9D003164  70821002   MUL V0, A0, V0
9D003168  00621021   ADDU V0, V1, V0
9D00316C  8C430024   LW V1, 36(V0)
9D003170  24020007   ADDIU V0, ZERO, 7
9D003174  1462026E   BNE V1, V0, 0x9D003B30
9D003178  00000000   NOP
2471:                				{
2472:                					// If timeout has not occured, do not do anything.
2473:                					if((LONG)(TickGet() - MyTCBStub.eventTime) < (LONG)0)
9D00317C  0F40CDD6   JAL TickGet
9D003180  00000000   NOP
9D003184  00401821   ADDU V1, V0, ZERO
9D003188  93828027   LBU V0, -32729(GP)
9D00318C  00402821   ADDU A1, V0, ZERO
9D003190  3C02A000   LUI V0, -24576
9D003194  24442CDC   ADDIU A0, V0, 11484
9D003198  24020030   ADDIU V0, ZERO, 48
9D00319C  70A21002   MUL V0, A1, V0
9D0031A0  00821021   ADDU V0, A0, V0
9D0031A4  8C42001C   LW V0, 28(V0)
9D0031A8  00621023   SUBU V0, V1, V0
9D0031AC  04400263   BLTZ V0, 0x9D003B3C
9D0031B0  00000000   NOP
2474:                						continue;
9D003B3C  00000000   NOP
9D003B40  0B400ED6   J 0x9D003B58
9D003B44  00000000   NOP
2475:                		
2476:                					// If timeout has occured and the connection appears to be dead (no 
2477:                					// responses from remote node at all), close the connection so the 
2478:                					// application doesn't sit around indefinitely with a useless socket 
2479:                					// that it thinks is still open
2480:                					if(MyTCBStub.Flags.vUnackedKeepalives == TCP_MAX_UNACKED_KEEP_ALIVES)
9D0031B4  93828027   LBU V0, -32729(GP)
9D0031B8  00402021   ADDU A0, V0, ZERO
9D0031BC  3C02A000   LUI V0, -24576
9D0031C0  24030030   ADDIU V1, ZERO, 48
9D0031C4  70831802   MUL V1, A0, V1
9D0031C8  24422CDC   ADDIU V0, V0, 11484
9D0031CC  00621021   ADDU V0, V1, V0
9D0031D0  8C420028   LW V0, 40(V0)
9D0031D4  7C421000   EXT V0, V0, 0, 3
9D0031D8  304300FF   ANDI V1, V0, 255
9D0031DC  24020006   ADDIU V0, ZERO, 6
9D0031E0  14620022   BNE V1, V0, 0x9D00326C
9D0031E4  00000000   NOP
2481:                					{
2482:                						vFlags = MyTCBStub.Flags.bServer;
9D0031E8  93828027   LBU V0, -32729(GP)
9D0031EC  00402021   ADDU A0, V0, ZERO
9D0031F0  3C02A000   LUI V0, -24576
9D0031F4  24030030   ADDIU V1, ZERO, 48
9D0031F8  70831802   MUL V1, A0, V1
9D0031FC  24422CDC   ADDIU V0, V0, 11484
9D003200  00621021   ADDU V0, V1, V0
9D003204  8C420028   LW V0, 40(V0)
9D003208  7C4200C0   EXT V0, V0, 3, 1
9D00320C  304200FF   ANDI V0, V0, 255
9D003210  A3C20024   SB V0, 36(S8)
2483:                
2484:                						// Force an immediate FIN and RST transmission
2485:                						// Double calling TCPDisconnect() will also place us 
2486:                						// back in the listening state immediately if a server socket.
2487:                						TCPDisconnect(hTCP);
9D003214  93C20018   LBU V0, 24(S8)
9D003218  00402021   ADDU A0, V0, ZERO
9D00321C  0F400273   JAL TCPDisconnect
9D003220  00000000   NOP
2488:                						TCPDisconnect(hTCP);
9D003224  93C20018   LBU V0, 24(S8)
9D003228  00402021   ADDU A0, V0, ZERO
9D00322C  0F400273   JAL TCPDisconnect
9D003230  00000000   NOP
2489:                						
2490:                						// Prevent client mode sockets from getting reused by other applications.  
2491:                						// The application must call TCPDisconnect() with the handle to free this 
2492:                						// socket (and the handle associated with it)
2493:                						if(!vFlags)
9D003234  93C20024   LBU V0, 36(S8)
9D003238  14400243   BNE V0, ZERO, 0x9D003B48
9D00323C  00000000   NOP
2494:                							MyTCBStub.smState = TCP_CLOSED_BUT_RESERVED;
9D003240  93828027   LBU V0, -32729(GP)
9D003244  00402021   ADDU A0, V0, ZERO
9D003248  3C02A000   LUI V0, -24576
9D00324C  24432CDC   ADDIU V1, V0, 11484
9D003250  24020030   ADDIU V0, ZERO, 48
9D003254  70821002   MUL V0, A0, V0
9D003258  00621021   ADDU V0, V1, V0
9D00325C  2403000E   ADDIU V1, ZERO, 14
9D003260  AC430024   SW V1, 36(V0)
2495:                						
2496:                						continue;
9D003264  0B400ED6   J 0x9D003B58
9D003268  00000000   NOP
9D003B48  00000000   NOP
9D003B4C  0B400ED6   J 0x9D003B58
9D003B50  00000000   NOP
2497:                					}
2498:                					
2499:                					// Otherwise, if a timeout occured, simply send a keep-alive packet
2500:                					SyncTCB();
9D00326C  0F400008   JAL SyncTCB
9D003270  00000000   NOP
2501:                					SendTCP(ACK, SENDTCP_KEEP_ALIVE);
9D003274  24040010   ADDIU A0, ZERO, 16
9D003278  24050002   ADDIU A1, ZERO, 2
9D00327C  0F400F8B   JAL SendTCP
9D003280  00000000   NOP
2502:                					MyTCBStub.eventTime = TickGet() + TCP_KEEP_ALIVE_TIMEOUT;
9D003284  93828027   LBU V0, -32729(GP)
9D003288  00408021   ADDU S0, V0, ZERO
9D00328C  0F40CDD6   JAL TickGet
9D003290  00000000   NOP
9D003294  00401821   ADDU V1, V0, ZERO
9D003298  3C020017   LUI V0, 23
9D00329C  3442D784   ORI V0, V0, -10364
9D0032A0  00621821   ADDU V1, V1, V0
9D0032A4  3C02A000   LUI V0, -24576
9D0032A8  24442CDC   ADDIU A0, V0, 11484
9D0032AC  24020030   ADDIU V0, ZERO, 48
9D0032B0  72021002   MUL V0, S0, V0
9D0032B4  00821021   ADDU V0, A0, V0
9D0032B8  AC43001C   SW V1, 28(V0)
2503:                				}
2504:                			#endif
2505:                			continue;
9D0032BC  0B400ED6   J 0x9D003B58
9D0032C0  00000000   NOP
9D003B30  00000000   NOP
9D003B34  0B400ED6   J 0x9D003B58
9D003B38  00000000   NOP
2506:                		}
2507:                
2508:                		// If timeout has not occured, do not do anything.
2509:                		if((LONG)(TickGet() - MyTCBStub.eventTime) < (LONG)0)
9D0032C4  0F40CDD6   JAL TickGet
9D0032C8  00000000   NOP
9D0032CC  00401821   ADDU V1, V0, ZERO
9D0032D0  93828027   LBU V0, -32729(GP)
9D0032D4  00402821   ADDU A1, V0, ZERO
9D0032D8  3C02A000   LUI V0, -24576
9D0032DC  24442CDC   ADDIU A0, V0, 11484
9D0032E0  24020030   ADDIU V0, ZERO, 48
9D0032E4  70A21002   MUL V0, A1, V0
9D0032E8  00821021   ADDU V0, A0, V0
9D0032EC  8C42001C   LW V0, 28(V0)
9D0032F0  00621023   SUBU V0, V1, V0
9D0032F4  04400217   BLTZ V0, 0x9D003B54
9D0032F8  00000000   NOP
2510:                			continue;
9D003B54  00000000   NOP
2511:                
2512:                		// Load up extended TCB information
2513:                		SyncTCB();
9D0032FC  0F400008   JAL SyncTCB
9D003300  00000000   NOP
2514:                
2515:                		// A timeout has occured.  Respond to this timeout condition
2516:                		// depending on what state this socket is in.
2517:                		switch(MyTCBStub.smState)
9D003304  93828027   LBU V0, -32729(GP)
9D003308  00402021   ADDU A0, V0, ZERO
9D00330C  3C02A000   LUI V0, -24576
9D003310  24432CDC   ADDIU V1, V0, 11484
9D003314  24020030   ADDIU V0, ZERO, 48
9D003318  70821002   MUL V0, A0, V0
9D00331C  00621021   ADDU V0, V1, V0
9D003320  8C420024   LW V0, 36(V0)
9D003324  2C43000D   SLTIU V1, V0, 13
9D003328  1060017B   BEQ V1, ZERO, 0x9D003918
9D00332C  00000000   NOP
9D003330  00021880   SLL V1, V0, 2
9D003334  3C029D00   LUI V0, -25344
9D003338  2442334C   ADDIU V0, V0, 13132
9D00333C  00621021   ADDU V0, V1, V0
9D003340  8C420000   LW V0, 0(V0)
9D003344  00400008   JR V0
9D003348  00000000   NOP
2518:                		{
2519:                			#if defined(STACK_CLIENT_MODE)
2520:                			#if defined(STACK_USE_DNS)
2521:                			case TCP_GET_DNS_MODULE:
2522:                				if(DNSBeginUsage())
9D003380  0F40A557   JAL DNSBeginUsage
9D003384  00000000   NOP
9D003388  10400169   BEQ V0, ZERO, 0x9D003930
9D00338C  00000000   NOP
2523:                				{
2524:                					MyTCBStub.smState = TCP_DNS_RESOLVE;
9D003390  93828027   LBU V0, -32729(GP)
9D003394  00402021   ADDU A0, V0, ZERO
9D003398  3C02A000   LUI V0, -24576
9D00339C  24432CDC   ADDIU V1, V0, 11484
9D0033A0  24020030   ADDIU V0, ZERO, 48
9D0033A4  70821002   MUL V0, A0, V0
9D0033A8  00621021   ADDU V0, V1, V0
9D0033AC  24030001   ADDIU V1, ZERO, 1
9D0033B0  AC430024   SW V1, 36(V0)
2525:                					if(MyTCB.flags.bRemoteHostIsROM)
9D0033B4  3C02A000   LUI V0, -24576
9D0033B8  24422E8C   ADDIU V0, V0, 11916
9D0033BC  8C430024   LW V1, 36(V0)
9D0033C0  3C020004   LUI V0, 4
9D0033C4  00621024   AND V0, V1, V0
9D0033C8  1040000A   BEQ V0, ZERO, 0x9D0033F4
9D0033CC  00000000   NOP
2526:                						DNSResolveROM((ROM BYTE*)(ROM_PTR_BASE)MyTCB.remote.dwRemoteHost, DNS_TYPE_A);
9D0033D0  3C02A000   LUI V0, -24576
9D0033D4  24422E8C   ADDIU V0, V0, 11916
9D0033D8  8C420018   LW V0, 24(V0)
9D0033DC  00402021   ADDU A0, V0, ZERO
9D0033E0  24050001   ADDIU A1, ZERO, 1
9D0033E4  0F40A588   JAL DNSResolve
9D0033E8  00000000   NOP
2527:                					else
2528:                						DNSResolve((BYTE*)(PTR_BASE)MyTCB.remote.dwRemoteHost, DNS_TYPE_A);
9D0033F4  3C02A000   LUI V0, -24576
9D0033F8  24422E8C   ADDIU V0, V0, 11916
9D0033FC  8C420018   LW V0, 24(V0)
9D003400  00402021   ADDU A0, V0, ZERO
9D003404  24050001   ADDIU A1, ZERO, 1
9D003408  0F40A588   JAL DNSResolve
9D00340C  00000000   NOP
2529:                				}
2530:                				break;
9D0033EC  0B400E56   J 0x9D003958
9D0033F0  00000000   NOP
9D003410  0B400E56   J 0x9D003958
9D003414  00000000   NOP
9D003930  00000000   NOP
9D003934  0B400E56   J 0x9D003958
9D003938  00000000   NOP
2531:                				
2532:                			case TCP_DNS_RESOLVE:
2533:                			{
2534:                				IP_ADDR ipResolvedDNSIP;
2535:                
2536:                				// See if DNS resolution has finished.  Note that if the DNS 
2537:                				// fails, the &ipResolvedDNSIP will be written with 0x00000000. 
2538:                				// MyTCB.remote.dwRemoteHost is unioned with 
2539:                				// MyTCB.remote.niRemoteMACIP.IPAddr, so we can't directly write 
2540:                				// the DNS result into MyTCB.remote.niRemoteMACIP.IPAddr.  We 
2541:                				// must copy it over only if the DNS is resolution step was 
2542:                				// successful.
2543:                				if(DNSIsResolved(&ipResolvedDNSIP))
9D003418  27C20028   ADDIU V0, S8, 40
9D00341C  00402021   ADDU A0, V0, ZERO
9D003420  0F40A5AD   JAL DNSIsResolved
9D003424  00000000   NOP
9D003428  10400144   BEQ V0, ZERO, 0x9D00393C
9D00342C  00000000   NOP
2544:                				{
2545:                					if(DNSEndUsage())
9D003430  0F40A56C   JAL DNSEndUsage
9D003434  00000000   NOP
9D003438  10400033   BEQ V0, ZERO, 0x9D003508
9D00343C  00000000   NOP
2546:                					{
2547:                						MyTCB.remote.niRemoteMACIP.IPAddr.Val = ipResolvedDNSIP.Val;
9D003440  8FC30028   LW V1, 40(S8)
9D003444  3C02A000   LUI V0, -24576
9D003448  24422E8C   ADDIU V0, V0, 11916
9D00344C  AC430018   SW V1, 24(V0)
2548:                						MyTCBStub.smState = TCP_GATEWAY_SEND_ARP;
9D003450  93828027   LBU V0, -32729(GP)
9D003454  00402021   ADDU A0, V0, ZERO
9D003458  3C02A000   LUI V0, -24576
9D00345C  24432CDC   ADDIU V1, V0, 11484
9D003460  24020030   ADDIU V0, ZERO, 48
9D003464  70821002   MUL V0, A0, V0
9D003468  00621021   ADDU V0, V1, V0
9D00346C  24030002   ADDIU V1, ZERO, 2
9D003470  AC430024   SW V1, 36(V0)
2549:                						MyTCBStub.remoteHash.Val = (MyTCB.remote.niRemoteMACIP.IPAddr.w[1]+MyTCB.remote.niRemoteMACIP.IPAddr.w[0] + MyTCB.remotePort.Val) ^ MyTCB.localPort.Val;
9D003474  93828027   LBU V0, -32729(GP)
9D003478  00402821   ADDU A1, V0, ZERO
9D00347C  3C02A000   LUI V0, -24576
9D003480  24422E8C   ADDIU V0, V0, 11916
9D003484  9443001A   LHU V1, 26(V0)
9D003488  3C02A000   LUI V0, -24576
9D00348C  24422E8C   ADDIU V0, V0, 11916
9D003490  94420018   LHU V0, 24(V0)
9D003494  00621021   ADDU V0, V1, V0
9D003498  3043FFFF   ANDI V1, V0, -1
9D00349C  3C02A000   LUI V0, -24576
9D0034A0  24422E8C   ADDIU V0, V0, 11916
9D0034A4  94420010   LHU V0, 16(V0)
9D0034A8  00621021   ADDU V0, V1, V0
9D0034AC  3042FFFF   ANDI V0, V0, -1
9D0034B0  7C021E20   SEH V1, V0
9D0034B4  3C02A000   LUI V0, -24576
9D0034B8  24422E8C   ADDIU V0, V0, 11916
9D0034BC  94420012   LHU V0, 18(V0)
9D0034C0  7C021620   SEH V0, V0
9D0034C4  00621026   XOR V0, V1, V0
9D0034C8  7C021620   SEH V0, V0
9D0034CC  3043FFFF   ANDI V1, V0, -1
9D0034D0  3C02A000   LUI V0, -24576
9D0034D4  24040030   ADDIU A0, ZERO, 48
9D0034D8  70A42002   MUL A0, A1, A0
9D0034DC  24422CDC   ADDIU V0, V0, 11484
9D0034E0  00821021   ADDU V0, A0, V0
9D0034E4  A443002A   SH V1, 42(V0)
2550:                						MyTCB.retryCount = 0;
9D0034E8  3C02A000   LUI V0, -24576
9D0034EC  24422E8C   ADDIU V0, V0, 11916
9D0034F0  A040002A   SB ZERO, 42(V0)
2551:                						MyTCB.retryInterval = (TICK_SECOND/4)/256;
9D0034F4  3C02A000   LUI V0, -24576
9D0034F8  24030098   ADDIU V1, ZERO, 152
9D0034FC  AC432E8C   SW V1, 11916(V0)
2552:                					}
2553:                					else
2554:                					{
2555:                						MyTCBStub.eventTime = TickGet() + 10*TICK_SECOND;
9D003508  93828027   LBU V0, -32729(GP)
9D00350C  00408021   ADDU S0, V0, ZERO
9D003510  0F40CDD6   JAL TickGet
9D003514  00000000   NOP
9D003518  00401821   ADDU V1, V0, ZERO
9D00351C  3C020017   LUI V0, 23
9D003520  3442D784   ORI V0, V0, -10364
9D003524  00621821   ADDU V1, V1, V0
9D003528  3C02A000   LUI V0, -24576
9D00352C  24442CDC   ADDIU A0, V0, 11484
9D003530  24020030   ADDIU V0, ZERO, 48
9D003534  72021002   MUL V0, S0, V0
9D003538  00821021   ADDU V0, A0, V0
9D00353C  AC43001C   SW V1, 28(V0)
2556:                						MyTCBStub.smState = TCP_GET_DNS_MODULE;
9D003540  93828027   LBU V0, -32729(GP)
9D003544  00402021   ADDU A0, V0, ZERO
9D003548  3C02A000   LUI V0, -24576
9D00354C  24432CDC   ADDIU V1, V0, 11484
9D003550  24020030   ADDIU V0, ZERO, 48
9D003554  70821002   MUL V0, A0, V0
9D003558  00621021   ADDU V0, V1, V0
9D00355C  AC400024   SW ZERO, 36(V0)
2557:                					}
2558:                				}
2559:                				break;
9D003500  0B400E56   J 0x9D003958
9D003504  00000000   NOP
9D003560  0B400E56   J 0x9D003958
9D003564  00000000   NOP
9D00393C  00000000   NOP
9D003940  0B400E56   J 0x9D003958
9D003944  00000000   NOP
2560:                			}
2561:                			#endif // #if defined(STACK_USE_DNS)
2562:                				
2563:                			case TCP_GATEWAY_SEND_ARP:
2564:                				// Obtain the MAC address associated with the server's IP address (either direct MAC address on same subnet, or the MAC address of the Gateway machine)
2565:                				MyTCBStub.eventTime2 = (WORD)TickGetDiv256();
9D003568  93828027   LBU V0, -32729(GP)
9D00356C  00408021   ADDU S0, V0, ZERO
9D003570  0F40CDE4   JAL TickGetDiv256
9D003574  00000000   NOP
9D003578  3043FFFF   ANDI V1, V0, -1
9D00357C  3C02A000   LUI V0, -24576
9D003580  24040030   ADDIU A0, ZERO, 48
9D003584  72042002   MUL A0, S0, A0
9D003588  24422CDC   ADDIU V0, V0, 11484
9D00358C  00821021   ADDU V0, A0, V0
9D003590  A4430020   SH V1, 32(V0)
2566:                				ARPResolve(&MyTCB.remote.niRemoteMACIP.IPAddr);
9D003594  3C02A000   LUI V0, -24576
9D003598  24442EA4   ADDIU A0, V0, 11940
9D00359C  0F40BCC0   JAL ARPResolve
9D0035A0  00000000   NOP
2567:                				MyTCBStub.smState = TCP_GATEWAY_GET_ARP;
9D0035A4  93828027   LBU V0, -32729(GP)
9D0035A8  00402021   ADDU A0, V0, ZERO
9D0035AC  3C02A000   LUI V0, -24576
9D0035B0  24432CDC   ADDIU V1, V0, 11484
9D0035B4  24020030   ADDIU V0, ZERO, 48
9D0035B8  70821002   MUL V0, A0, V0
9D0035BC  00621021   ADDU V0, V1, V0
9D0035C0  24030003   ADDIU V1, ZERO, 3
9D0035C4  AC430024   SW V1, 36(V0)
2568:                				break;
9D0035C8  0B400E56   J 0x9D003958
9D0035CC  00000000   NOP
2569:                
2570:                			case TCP_GATEWAY_GET_ARP:
2571:                				// Wait for the MAC address to finish being obtained
2572:                				if(!ARPIsResolved(&MyTCB.remote.niRemoteMACIP.IPAddr, &MyTCB.remote.niRemoteMACIP.MACAddr))
9D0035D0  3C02A000   LUI V0, -24576
9D0035D4  24442EA4   ADDIU A0, V0, 11940
9D0035D8  3C02A000   LUI V0, -24576
9D0035DC  24452EA8   ADDIU A1, V0, 11944
9D0035E0  0F40BCF9   JAL ARPIsResolved
9D0035E4  00000000   NOP
9D0035E8  14400032   BNE V0, ZERO, 0x9D0036B4
9D0035EC  00000000   NOP
2573:                				{
2574:                					// Time out if too much time is spent in this state
2575:                					// Note that this will continuously send out ARP 
2576:                					// requests for an infinite time if the Gateway 
2577:                					// never responds
2578:                					if((WORD)TickGetDiv256() - MyTCBStub.eventTime2 > (WORD)MyTCB.retryInterval)
9D0035F0  0F40CDE4   JAL TickGetDiv256
9D0035F4  00000000   NOP
9D0035F8  3042FFFF   ANDI V0, V0, -1
9D0035FC  00401821   ADDU V1, V0, ZERO
9D003600  93828027   LBU V0, -32729(GP)
9D003604  00402821   ADDU A1, V0, ZERO
9D003608  3C02A000   LUI V0, -24576
9D00360C  24040030   ADDIU A0, ZERO, 48
9D003610  70A42002   MUL A0, A1, A0
9D003614  24422CDC   ADDIU V0, V0, 11484
9D003618  00821021   ADDU V0, A0, V0
9D00361C  94420020   LHU V0, 32(V0)
9D003620  00621823   SUBU V1, V1, V0
9D003624  3C02A000   LUI V0, -24576
9D003628  8C422E8C   LW V0, 11916(V0)
9D00362C  3042FFFF   ANDI V0, V0, -1
9D003630  0043102A   SLT V0, V0, V1
9D003634  104000C4   BEQ V0, ZERO, 0x9D003948
9D003638  00000000   NOP
2579:                					{
2580:                						// Exponentially increase timeout until we reach 6 attempts then stay constant
2581:                						if(MyTCB.retryCount < 6u)
9D00363C  3C02A000   LUI V0, -24576
9D003640  24422E8C   ADDIU V0, V0, 11916
9D003644  9042002A   LBU V0, 42(V0)
9D003648  2C420006   SLTIU V0, V0, 6
9D00364C  1040000E   BEQ V0, ZERO, 0x9D003688
9D003650  00000000   NOP
2582:                						{
2583:                							MyTCB.retryCount++;
9D003654  3C02A000   LUI V0, -24576
9D003658  24422E8C   ADDIU V0, V0, 11916
9D00365C  9042002A   LBU V0, 42(V0)
9D003660  24420001   ADDIU V0, V0, 1
9D003664  304300FF   ANDI V1, V0, 255
9D003668  3C02A000   LUI V0, -24576
9D00366C  24422E8C   ADDIU V0, V0, 11916
9D003670  A043002A   SB V1, 42(V0)
2584:                							MyTCB.retryInterval <<= 1;
9D003674  3C02A000   LUI V0, -24576
9D003678  8C422E8C   LW V0, 11916(V0)
9D00367C  00021840   SLL V1, V0, 1
9D003680  3C02A000   LUI V0, -24576
9D003684  AC432E8C   SW V1, 11916(V0)
2585:                						}
2586:                
2587:                						// Retransmit ARP request
2588:                						MyTCBStub.smState = TCP_GATEWAY_SEND_ARP;
9D003688  93828027   LBU V0, -32729(GP)
9D00368C  00402021   ADDU A0, V0, ZERO
9D003690  3C02A000   LUI V0, -24576
9D003694  24432CDC   ADDIU V1, V0, 11484
9D003698  24020030   ADDIU V0, ZERO, 48
9D00369C  70821002   MUL V0, A0, V0
9D0036A0  00621021   ADDU V0, V1, V0
9D0036A4  24030002   ADDIU V1, ZERO, 2
9D0036A8  AC430024   SW V1, 36(V0)
2589:                					}
2590:                					break;
9D0036AC  0B400E56   J 0x9D003958
9D0036B0  00000000   NOP
9D003948  00000000   NOP
9D00394C  0B400E56   J 0x9D003958
9D003950  00000000   NOP
2591:                				}
2592:                				
2593:                				// Send out SYN connection request to remote node
2594:                				// This automatically disables the Timer from 
2595:                				// continuously firing for this socket
2596:                				vFlags = SYN;
9D0036B4  24020002   ADDIU V0, ZERO, 2
9D0036B8  A3C20024   SB V0, 36(S8)
2597:                				bRetransmit = FALSE;
9D0036BC  AFC0001C   SW ZERO, 28(S8)
2598:                				MyTCBStub.smState = TCP_SYN_SENT;
9D0036C0  93828027   LBU V0, -32729(GP)
9D0036C4  00402021   ADDU A0, V0, ZERO
9D0036C8  3C02A000   LUI V0, -24576
9D0036CC  24432CDC   ADDIU V1, V0, 11484
9D0036D0  24020030   ADDIU V0, ZERO, 48
9D0036D4  70821002   MUL V0, A0, V0
9D0036D8  00621021   ADDU V0, V1, V0
9D0036DC  24030005   ADDIU V1, ZERO, 5
9D0036E0  AC430024   SW V1, 36(V0)
2599:                				break;
9D0036E4  0B400E56   J 0x9D003958
9D0036E8  00000000   NOP
2600:                			#endif // #if defined(STACK_CLIENT_MODE)
2601:                			
2602:                			case TCP_SYN_SENT:
2603:                				// Keep sending SYN until we hear from remote node.
2604:                				// This may be for infinite time, in that case
2605:                				// caller must detect it and do something.
2606:                				vFlags = SYN;
9D0036EC  24020002   ADDIU V0, ZERO, 2
9D0036F0  A3C20024   SB V0, 36(S8)
2607:                				bRetransmit = TRUE;
9D0036F4  24020001   ADDIU V0, ZERO, 1
9D0036F8  AFC2001C   SW V0, 28(S8)
2608:                
2609:                				// Exponentially increase timeout until we reach TCP_MAX_RETRIES attempts then stay constant
2610:                				if(MyTCB.retryCount >= (TCP_MAX_RETRIES - 1))
9D0036FC  3C02A000   LUI V0, -24576
9D003700  24422E8C   ADDIU V0, V0, 11916
9D003704  9042002A   LBU V0, 42(V0)
9D003708  2C420004   SLTIU V0, V0, 4
9D00370C  14400091   BNE V0, ZERO, 0x9D003954
9D003710  00000000   NOP
2611:                				{
2612:                					MyTCB.retryCount = TCP_MAX_RETRIES - 1;
9D003714  3C02A000   LUI V0, -24576
9D003718  24422E8C   ADDIU V0, V0, 11916
9D00371C  24030004   ADDIU V1, ZERO, 4
9D003720  A043002A   SB V1, 42(V0)
2613:                					MyTCB.retryInterval = TCP_START_TIMEOUT_VAL<<(TCP_MAX_RETRIES-1);
9D003724  3C02A000   LUI V0, -24576
9D003728  3C030026   LUI V1, 38
9D00372C  346325A0   ORI V1, V1, 9632
9D003730  AC432E8C   SW V1, 11916(V0)
2614:                				}
2615:                				break;
9D003734  0B400E56   J 0x9D003958
9D003738  00000000   NOP
9D003954  00000000   NOP
2616:                	
2617:                			case TCP_SYN_RECEIVED:
2618:                				// We must receive ACK before timeout expires.
2619:                				// If not, resend SYN+ACK.
2620:                				// Abort, if maximum attempts counts are reached.
2621:                				if(MyTCB.retryCount < TCP_MAX_SYN_RETRIES)
9D00373C  3C02A000   LUI V0, -24576
9D003740  24422E8C   ADDIU V0, V0, 11916
9D003744  9042002A   LBU V0, 42(V0)
9D003748  2C420002   SLTIU V0, V0, 2
9D00374C  10400007   BEQ V0, ZERO, 0x9D00376C
9D003750  00000000   NOP
2622:                				{
2623:                					vFlags = SYN | ACK;
9D003754  24020012   ADDIU V0, ZERO, 18
9D003758  A3C20024   SB V0, 36(S8)
2624:                					bRetransmit = TRUE;
9D00375C  24020001   ADDIU V0, ZERO, 1
9D003760  AFC2001C   SW V0, 28(S8)
2625:                				}
2626:                				else
2627:                				{
2628:                					if(MyTCBStub.Flags.bServer)
9D00376C  93828027   LBU V0, -32729(GP)
9D003770  00402021   ADDU A0, V0, ZERO
9D003774  3C02A000   LUI V0, -24576
9D003778  24030030   ADDIU V1, ZERO, 48
9D00377C  70831802   MUL V1, A0, V1
9D003780  24422CDC   ADDIU V0, V0, 11484
9D003784  00621021   ADDU V0, V1, V0
9D003788  8C420028   LW V0, 40(V0)
9D00378C  7C4200C0   EXT V0, V0, 3, 1
9D003790  304200FF   ANDI V0, V0, 255
9D003794  10400007   BEQ V0, ZERO, 0x9D0037B4
9D003798  00000000   NOP
2629:                					{
2630:                						vFlags = RST | ACK;
9D00379C  24020014   ADDIU V0, ZERO, 20
9D0037A0  A3C20024   SB V0, 36(S8)
2631:                						bCloseSocket = TRUE;
9D0037A4  24020001   ADDIU V0, ZERO, 1
9D0037A8  AFC20020   SW V0, 32(S8)
2632:                					}
2633:                					else
2634:                					{
2635:                						vFlags = SYN;
9D0037B4  24020002   ADDIU V0, ZERO, 2
9D0037B8  A3C20024   SB V0, 36(S8)
2636:                					}
2637:                				}
2638:                				break;
9D003764  0B400E56   J 0x9D003958
9D003768  00000000   NOP
9D0037AC  0B400E56   J 0x9D003958
9D0037B0  00000000   NOP
9D0037BC  0B400E56   J 0x9D003958
9D0037C0  00000000   NOP
2639:                	
2640:                			case TCP_ESTABLISHED:
2641:                			case TCP_CLOSE_WAIT:
2642:                				// Retransmit any unacknowledged data
2643:                				if(MyTCB.retryCount < TCP_MAX_RETRIES)
9D0037C4  3C02A000   LUI V0, -24576
9D0037C8  24422E8C   ADDIU V0, V0, 11916
9D0037CC  9042002A   LBU V0, 42(V0)
9D0037D0  2C420005   SLTIU V0, V0, 5
9D0037D4  10400007   BEQ V0, ZERO, 0x9D0037F4
9D0037D8  00000000   NOP
2644:                				{
2645:                					vFlags = ACK;
9D0037DC  24020010   ADDIU V0, ZERO, 16
9D0037E0  A3C20024   SB V0, 36(S8)
2646:                					bRetransmit = TRUE;
9D0037E4  24020001   ADDIU V0, ZERO, 1
9D0037E8  AFC2001C   SW V0, 28(S8)
2647:                				}
2648:                				else
2649:                				{
2650:                					// No response back for too long, close connection
2651:                					// This could happen, for instance, if the communication 
2652:                					// medium was lost
2653:                					MyTCBStub.smState = TCP_FIN_WAIT_1;
9D0037F4  93828027   LBU V0, -32729(GP)
9D0037F8  00402021   ADDU A0, V0, ZERO
9D0037FC  3C02A000   LUI V0, -24576
9D003800  24432CDC   ADDIU V1, V0, 11484
9D003804  24020030   ADDIU V0, ZERO, 48
9D003808  70821002   MUL V0, A0, V0
9D00380C  00621021   ADDU V0, V1, V0
9D003810  24030008   ADDIU V1, ZERO, 8
9D003814  AC430024   SW V1, 36(V0)
2654:                					vFlags = FIN | ACK;
9D003818  24020011   ADDIU V0, ZERO, 17
9D00381C  A3C20024   SB V0, 36(S8)
2655:                				}
2656:                				break;
9D0037EC  0B400E56   J 0x9D003958
9D0037F0  00000000   NOP
9D003820  0B400E56   J 0x9D003958
9D003824  00000000   NOP
2657:                	
2658:                			case TCP_FIN_WAIT_1:
2659:                				if(MyTCB.retryCount < TCP_MAX_RETRIES)
9D003828  3C02A000   LUI V0, -24576
9D00382C  24422E8C   ADDIU V0, V0, 11916
9D003830  9042002A   LBU V0, 42(V0)
9D003834  2C420005   SLTIU V0, V0, 5
9D003838  10400007   BEQ V0, ZERO, 0x9D003858
9D00383C  00000000   NOP
2660:                				{
2661:                					// Send another FIN
2662:                					vFlags = FIN | ACK;
9D003840  24020011   ADDIU V0, ZERO, 17
9D003844  A3C20024   SB V0, 36(S8)
2663:                					bRetransmit = TRUE;
9D003848  24020001   ADDIU V0, ZERO, 1
9D00384C  AFC2001C   SW V0, 28(S8)
2664:                				}
2665:                				else
2666:                				{
2667:                					// Close on our own, we can't seem to communicate 
2668:                					// with the remote node anymore
2669:                					vFlags = RST | ACK;
9D003858  24020014   ADDIU V0, ZERO, 20
9D00385C  A3C20024   SB V0, 36(S8)
2670:                					bCloseSocket = TRUE;
9D003860  24020001   ADDIU V0, ZERO, 1
9D003864  AFC20020   SW V0, 32(S8)
2671:                				}
2672:                				break;
9D003850  0B400E56   J 0x9D003958
9D003854  00000000   NOP
9D003868  0B400E56   J 0x9D003958
9D00386C  00000000   NOP
2673:                	
2674:                			case TCP_FIN_WAIT_2:
2675:                				// Close on our own, we can't seem to communicate 
2676:                				// with the remote node anymore
2677:                				vFlags = RST | ACK;
9D003870  24020014   ADDIU V0, ZERO, 20
9D003874  A3C20024   SB V0, 36(S8)
2678:                				bCloseSocket = TRUE;
9D003878  24020001   ADDIU V0, ZERO, 1
9D00387C  AFC20020   SW V0, 32(S8)
2679:                				break;
9D003880  0B400E56   J 0x9D003958
9D003884  00000000   NOP
2680:                
2681:                			case TCP_CLOSING:
2682:                				if(MyTCB.retryCount < TCP_MAX_RETRIES)
9D003888  3C02A000   LUI V0, -24576
9D00388C  24422E8C   ADDIU V0, V0, 11916
9D003890  9042002A   LBU V0, 42(V0)
9D003894  2C420005   SLTIU V0, V0, 5
9D003898  10400007   BEQ V0, ZERO, 0x9D0038B8
9D00389C  00000000   NOP
2683:                				{
2684:                					// Send another ACK+FIN (the FIN is retransmitted 
2685:                					// automatically since it hasn't been acknowledged by 
2686:                					// the remote node yet)
2687:                					vFlags = ACK;
9D0038A0  24020010   ADDIU V0, ZERO, 16
9D0038A4  A3C20024   SB V0, 36(S8)
2688:                					bRetransmit = TRUE;
9D0038A8  24020001   ADDIU V0, ZERO, 1
9D0038AC  AFC2001C   SW V0, 28(S8)
2689:                				}
2690:                				else
2691:                				{
2692:                					// Close on our own, we can't seem to communicate 
2693:                					// with the remote node anymore
2694:                					vFlags = RST | ACK;
9D0038B8  24020014   ADDIU V0, ZERO, 20
9D0038BC  A3C20024   SB V0, 36(S8)
2695:                					bCloseSocket = TRUE;
9D0038C0  24020001   ADDIU V0, ZERO, 1
9D0038C4  AFC20020   SW V0, 32(S8)
2696:                				}
2697:                				break;
9D0038B0  0B400E56   J 0x9D003958
9D0038B4  00000000   NOP
9D0038C8  0B400E56   J 0x9D003958
9D0038CC  00000000   NOP
2698:                	
2699:                //			case TCP_TIME_WAIT:
2700:                //				// Wait around for a while (2MSL) and then goto closed state
2701:                //				bCloseSocket = TRUE;
2702:                //				break;
2703:                //			
2704:                
2705:                			case TCP_LAST_ACK:
2706:                				// Send some more FINs or close anyway
2707:                				if(MyTCB.retryCount < TCP_MAX_RETRIES)
9D0038D0  3C02A000   LUI V0, -24576
9D0038D4  24422E8C   ADDIU V0, V0, 11916
9D0038D8  9042002A   LBU V0, 42(V0)
9D0038DC  2C420005   SLTIU V0, V0, 5
9D0038E0  10400007   BEQ V0, ZERO, 0x9D003900
9D0038E4  00000000   NOP
2708:                				{
2709:                					vFlags = FIN | ACK;
9D0038E8  24020011   ADDIU V0, ZERO, 17
9D0038EC  A3C20024   SB V0, 36(S8)
2710:                					bRetransmit = TRUE;
9D0038F0  24020001   ADDIU V0, ZERO, 1
9D0038F4  AFC2001C   SW V0, 28(S8)
2711:                				}
2712:                				else
2713:                				{
2714:                					vFlags = RST | ACK;
9D003900  24020014   ADDIU V0, ZERO, 20
9D003904  A3C20024   SB V0, 36(S8)
2715:                					bCloseSocket = TRUE;
9D003908  24020001   ADDIU V0, ZERO, 1
9D00390C  AFC20020   SW V0, 32(S8)
2716:                				}
2717:                				break;
9D0038F8  0B400E56   J 0x9D003958
9D0038FC  00000000   NOP
9D003910  0B400E56   J 0x9D003958
9D003914  00000000   NOP
2718:                			
2719:                			default:
2720:                				break;
9D003918  00000000   NOP
9D00391C  0B400E56   J 0x9D003958
9D003920  00000000   NOP
9D003924  00000000   NOP
9D003928  0B400E56   J 0x9D003958
9D00392C  00000000   NOP
2721:                		}
2722:                
2723:                		if(vFlags)
9D003958  93C20024   LBU V0, 36(S8)
9D00395C  1040006D   BEQ V0, ZERO, 0x9D003B14
9D003960  00000000   NOP
2724:                		{
2725:                			// Transmit all unacknowledged data over again
2726:                			if(bRetransmit)
9D003964  8FC2001C   LW V0, 28(S8)
9D003968  10400065   BEQ V0, ZERO, 0x9D003B00
9D00396C  00000000   NOP
2727:                			{
2728:                				// Set the appropriate retry time
2729:                				MyTCB.retryCount++;
9D003970  3C02A000   LUI V0, -24576
9D003974  24422E8C   ADDIU V0, V0, 11916
9D003978  9042002A   LBU V0, 42(V0)
9D00397C  24420001   ADDIU V0, V0, 1
9D003980  304300FF   ANDI V1, V0, 255
9D003984  3C02A000   LUI V0, -24576
9D003988  24422E8C   ADDIU V0, V0, 11916
9D00398C  A043002A   SB V1, 42(V0)
2730:                				MyTCB.retryInterval <<= 1;
9D003990  3C02A000   LUI V0, -24576
9D003994  8C422E8C   LW V0, 11916(V0)
9D003998  00021840   SLL V1, V0, 1
9D00399C  3C02A000   LUI V0, -24576
9D0039A0  AC432E8C   SW V1, 11916(V0)
2731:                		
2732:                				// Calculate how many bytes we have to roll back and retransmit
2733:                				w = MyTCB.txUnackedTail - MyTCBStub.txTail;
9D0039A4  3C02A000   LUI V0, -24576
9D0039A8  24422E8C   ADDIU V0, V0, 11916
9D0039AC  8C42000C   LW V0, 12(V0)
9D0039B0  3043FFFF   ANDI V1, V0, -1
9D0039B4  93828027   LBU V0, -32729(GP)
9D0039B8  00402821   ADDU A1, V0, ZERO
9D0039BC  3C02A000   LUI V0, -24576
9D0039C0  24040030   ADDIU A0, ZERO, 48
9D0039C4  70A42002   MUL A0, A1, A0
9D0039C8  24422CDC   ADDIU V0, V0, 11484
9D0039CC  00821021   ADDU V0, A0, V0
9D0039D0  8C420010   LW V0, 16(V0)
9D0039D4  3042FFFF   ANDI V0, V0, -1
9D0039D8  00621023   SUBU V0, V1, V0
9D0039DC  A7C20026   SH V0, 38(S8)
2734:                				if(MyTCB.txUnackedTail < MyTCBStub.txTail)
9D0039E0  3C02A000   LUI V0, -24576
9D0039E4  24422E8C   ADDIU V0, V0, 11916
9D0039E8  8C43000C   LW V1, 12(V0)
9D0039EC  93828027   LBU V0, -32729(GP)
9D0039F0  00402821   ADDU A1, V0, ZERO
9D0039F4  3C02A000   LUI V0, -24576
9D0039F8  24040030   ADDIU A0, ZERO, 48
9D0039FC  70A42002   MUL A0, A1, A0
9D003A00  24422CDC   ADDIU V0, V0, 11484
9D003A04  00821021   ADDU V0, A0, V0
9D003A08  8C420010   LW V0, 16(V0)
9D003A0C  0062102B   SLTU V0, V1, V0
9D003A10  10400018   BEQ V0, ZERO, 0x9D003A74
9D003A14  00000000   NOP
2735:                					w += MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart;
9D003A18  93828027   LBU V0, -32729(GP)
9D003A1C  00402021   ADDU A0, V0, ZERO
9D003A20  3C02A000   LUI V0, -24576
9D003A24  24432CDC   ADDIU V1, V0, 11484
9D003A28  24020030   ADDIU V0, ZERO, 48
9D003A2C  70821002   MUL V0, A0, V0
9D003A30  00621021   ADDU V0, V1, V0
9D003A34  8C420004   LW V0, 4(V0)
9D003A38  3043FFFF   ANDI V1, V0, -1
9D003A3C  93828027   LBU V0, -32729(GP)
9D003A40  00402821   ADDU A1, V0, ZERO
9D003A44  3C02A000   LUI V0, -24576
9D003A48  24040030   ADDIU A0, ZERO, 48
9D003A4C  70A42002   MUL A0, A1, A0
9D003A50  24422CDC   ADDIU V0, V0, 11484
9D003A54  00821021   ADDU V0, A0, V0
9D003A58  8C420000   LW V0, 0(V0)
9D003A5C  3042FFFF   ANDI V0, V0, -1
9D003A60  00621023   SUBU V0, V1, V0
9D003A64  3043FFFF   ANDI V1, V0, -1
9D003A68  97C20026   LHU V0, 38(S8)
9D003A6C  00621021   ADDU V0, V1, V0
9D003A70  A7C20026   SH V0, 38(S8)
2736:                				
2737:                				// Perform roll back of local SEQuence counter, remote window 
2738:                				// adjustment, and cause all unacknowledged data to be 
2739:                				// retransmitted by moving the unacked tail pointer.
2740:                				MyTCB.MySEQ -= w;
9D003A74  3C02A000   LUI V0, -24576
9D003A78  24422E8C   ADDIU V0, V0, 11916
9D003A7C  8C430004   LW V1, 4(V0)
9D003A80  97C20026   LHU V0, 38(S8)
9D003A84  00621823   SUBU V1, V1, V0
9D003A88  3C02A000   LUI V0, -24576
9D003A8C  24422E8C   ADDIU V0, V0, 11916
9D003A90  AC430004   SW V1, 4(V0)
2741:                				MyTCB.remoteWindow += w;
9D003A94  3C02A000   LUI V0, -24576
9D003A98  24422E8C   ADDIU V0, V0, 11916
9D003A9C  94430014   LHU V1, 20(V0)
9D003AA0  97C20026   LHU V0, 38(S8)
9D003AA4  00621021   ADDU V0, V1, V0
9D003AA8  3043FFFF   ANDI V1, V0, -1
9D003AAC  3C02A000   LUI V0, -24576
9D003AB0  24422E8C   ADDIU V0, V0, 11916
9D003AB4  A4430014   SH V1, 20(V0)
2742:                				MyTCB.txUnackedTail = MyTCBStub.txTail;		
9D003AB8  93828027   LBU V0, -32729(GP)
9D003ABC  00402021   ADDU A0, V0, ZERO
9D003AC0  3C02A000   LUI V0, -24576
9D003AC4  24030030   ADDIU V1, ZERO, 48
9D003AC8  70831802   MUL V1, A0, V1
9D003ACC  24422CDC   ADDIU V0, V0, 11484
9D003AD0  00621021   ADDU V0, V1, V0
9D003AD4  8C430010   LW V1, 16(V0)
9D003AD8  3C02A000   LUI V0, -24576
9D003ADC  24422E8C   ADDIU V0, V0, 11916
9D003AE0  AC43000C   SW V1, 12(V0)
2743:                				SendTCP(vFlags, 0);
9D003AE4  93C20024   LBU V0, 36(S8)
9D003AE8  00402021   ADDU A0, V0, ZERO
9D003AEC  00002821   ADDU A1, ZERO, ZERO
9D003AF0  0F400F8B   JAL SendTCP
9D003AF4  00000000   NOP
9D003AF8  0B400EC5   J 0x9D003B14
9D003AFC  00000000   NOP
2744:                			}
2745:                			else
2746:                				SendTCP(vFlags, SENDTCP_RESET_TIMERS);
9D003B00  93C20024   LBU V0, 36(S8)
9D003B04  00402021   ADDU A0, V0, ZERO
9D003B08  24050001   ADDIU A1, ZERO, 1
9D003B0C  0F400F8B   JAL SendTCP
9D003B10  00000000   NOP
2747:                
2748:                		}
2749:                		
2750:                		if(bCloseSocket)
9D003B14  8FC20020   LW V0, 32(S8)
9D003B18  1040000F   BEQ V0, ZERO, 0x9D003B58
9D003B1C  00000000   NOP
2751:                			CloseSocket();
9D003B20  0F4014AB   JAL CloseSocket
9D003B24  00000000   NOP
9D003B28  0B400ED6   J 0x9D003B58
9D003B2C  00000000   NOP
2752:                	}
2753:                	
2754:                	
2755:                	#if TCP_SYN_QUEUE_MAX_ENTRIES
2756:                		// Process SYN Queue entry timeouts
2757:                		for(w = 0; w < TCP_SYN_QUEUE_MAX_ENTRIES; w++)
9D003B74  A7C00026   SH ZERO, 38(S8)
9D003B78  0B400F1C   J 0x9D003C70
9D003B7C  00000000   NOP
9D003C64  97C20026   LHU V0, 38(S8)
9D003C68  24420001   ADDIU V0, V0, 1
9D003C6C  A7C20026   SH V0, 38(S8)
9D003C70  97C20026   LHU V0, 38(S8)
9D003C74  2C420003   SLTIU V0, V0, 3
9D003C78  1440FFC1   BNE V0, ZERO, 0x9D003B80
9D003C7C  00000000   NOP
9D003C80  0B400F23   J 0x9D003C8C
9D003C84  00000000   NOP
2758:                		{
2759:                			// Abort search if there are no more valid records
2760:                			if(SYNQueue[w].wDestPort == 0u)
9D003B80  97C40026   LHU A0, 38(S8)
9D003B84  3C02A000   LUI V0, -24576
9D003B88  24030014   ADDIU V1, ZERO, 20
9D003B8C  70831802   MUL V1, A0, V1
9D003B90  24422EB8   ADDIU V0, V0, 11960
9D003B94  00621021   ADDU V0, V1, V0
9D003B98  94420010   LHU V0, 16(V0)
9D003B9C  1040003A   BEQ V0, ZERO, 0x9D003C88
9D003BA0  00000000   NOP
2761:                				break;
9D003C88  00000000   NOP
2762:                			
2763:                			// See if this SYN has timed out
2764:                			if((WORD)TickGetDiv256() - SYNQueue[w].wTimestamp > (WORD)(TCP_SYN_QUEUE_TIMEOUT/256ull))
9D003BA4  0F40CDE4   JAL TickGetDiv256
9D003BA8  00000000   NOP
9D003BAC  3042FFFF   ANDI V0, V0, -1
9D003BB0  00401821   ADDU V1, V0, ZERO
9D003BB4  97C50026   LHU A1, 38(S8)
9D003BB8  3C02A000   LUI V0, -24576
9D003BBC  24040014   ADDIU A0, ZERO, 20
9D003BC0  70A42002   MUL A0, A1, A0
9D003BC4  24422EB8   ADDIU V0, V0, 11960
9D003BC8  00821021   ADDU V0, A0, V0
9D003BCC  94420012   LHU V0, 18(V0)
9D003BD0  00621023   SUBU V0, V1, V0
9D003BD4  28420728   SLTI V0, V0, 1832
9D003BD8  14400022   BNE V0, ZERO, 0x9D003C64
9D003BDC  00000000   NOP
2765:                			{
2766:                				// Delete this SYN from the SYNQueue and compact the SYNQueue[] array
2767:                				TCPRAMCopy((PTR_BASE)&SYNQueue[w], TCP_PIC_RAM, (PTR_BASE)&SYNQueue[w+1], TCP_PIC_RAM, (TCP_SYN_QUEUE_MAX_ENTRIES-1u-w)*sizeof(TCP_SYN_QUEUE));
9D003BE0  97C30026   LHU V1, 38(S8)
9D003BE4  24020014   ADDIU V0, ZERO, 20
9D003BE8  70621802   MUL V1, V1, V0
9D003BEC  3C02A000   LUI V0, -24576
9D003BF0  24422EB8   ADDIU V0, V0, 11960
9D003BF4  00621021   ADDU V0, V1, V0
9D003BF8  00401821   ADDU V1, V0, ZERO
9D003BFC  97C20026   LHU V0, 38(S8)
9D003C00  24440001   ADDIU A0, V0, 1
9D003C04  24020014   ADDIU V0, ZERO, 20
9D003C08  70822002   MUL A0, A0, V0
9D003C0C  3C02A000   LUI V0, -24576
9D003C10  24422EB8   ADDIU V0, V0, 11960
9D003C14  00821021   ADDU V0, A0, V0
9D003C18  97C50026   LHU A1, 38(S8)
9D003C1C  2404FFEC   ADDIU A0, ZERO, -20
9D003C20  70A42002   MUL A0, A1, A0
9D003C24  3084FFFF   ANDI A0, A0, -1
9D003C28  24840028   ADDIU A0, A0, 40
9D003C2C  3084FFFF   ANDI A0, A0, -1
9D003C30  AFA40010   SW A0, 16(SP)
9D003C34  00602021   ADDU A0, V1, ZERO
9D003C38  24050001   ADDIU A1, ZERO, 1
9D003C3C  00403021   ADDU A2, V0, ZERO
9D003C40  24070001   ADDIU A3, ZERO, 1
9D003C44  0F4020BE   JAL TCPRAMCopy
9D003C48  00000000   NOP
2768:                				SYNQueue[TCP_SYN_QUEUE_MAX_ENTRIES-1].wDestPort = 0u;
9D003C4C  3C02A000   LUI V0, -24576
9D003C50  24422EB8   ADDIU V0, V0, 11960
9D003C54  A4400038   SH ZERO, 56(V0)
2769:                	
2770:                				// Since we deleted an entry, we need to roll back one 
2771:                				// index so next loop will process the correct record
2772:                				w--;	
9D003C58  97C20026   LHU V0, 38(S8)
9D003C5C  2442FFFF   ADDIU V0, V0, -1
9D003C60  A7C20026   SH V0, 38(S8)
2773:                			}
2774:                		}
2775:                	#endif
2776:                }
9D003C8C  03C0E821   ADDU SP, S8, ZERO
9D003C90  8FBF003C   LW RA, 60(SP)
9D003C94  8FBE0038   LW S8, 56(SP)
9D003C98  8FB00034   LW S0, 52(SP)
9D003C9C  27BD0040   ADDIU SP, SP, 64
9D003CA0  03E00008   JR RA
9D003CA4  00000000   NOP
2777:                
2778:                
2779:                /*****************************************************************************
2780:                  Function:
2781:                	BOOL TCPProcess(NODE_INFO* remote, IP_ADDR* localIP, WORD len)
2782:                
2783:                  Summary:
2784:                  	Handles incoming TCP segments.
2785:                
2786:                  Description:
2787:                	This function handles incoming TCP segments.  When a segment arrives, it
2788:                	is compared to open sockets using a hash of the remote port and IP.  
2789:                	On a match, the data is passed to HandleTCPSeg for further processing.
2790:                
2791:                  Precondition:
2792:                	TCP is initialized and a TCP segment is ready in the MAC buffer.
2793:                
2794:                  Parameters:
2795:                	remote - Remote NODE_INFO structure
2796:                	localIP - This stack's IP address (for header checking)
2797:                	len - Total length of the waiting TCP segment
2798:                
2799:                  Return Values:
2800:                	TRUE - the segment was properly handled.
2801:                	FALSE - otherwise
2802:                  ***************************************************************************/
2803:                BOOL TCPProcess(NODE_INFO* remote, IP_ADDR* localIP, WORD len)
2804:                {
9D003CA8  27BDFFB8   ADDIU SP, SP, -72
9D003CAC  AFBF0044   SW RA, 68(SP)
9D003CB0  AFBE0040   SW S8, 64(SP)
9D003CB4  03A0F021   ADDU S8, SP, ZERO
9D003CB8  AFC40048   SW A0, 72(S8)
9D003CBC  AFC5004C   SW A1, 76(S8)
9D003CC0  00C01021   ADDU V0, A2, ZERO
9D003CC4  A7C20050   SH V0, 80(S8)
2805:                	TCP_HEADER      TCPHeader;
2806:                	PSEUDO_HEADER   pseudoHeader;
2807:                	WORD_VAL        checksum1;
2808:                	WORD_VAL        checksum2;
2809:                	BYTE            optionsSize;
2810:                
2811:                	// Calculate IP pseudoheader checksum.
2812:                	pseudoHeader.SourceAddress      = remote->IPAddr;
9D003CC8  8FC20048   LW V0, 72(S8)
9D003CCC  88430003   LWL V1, 3(V0)
9D003CD0  00602021   ADDU A0, V1, ZERO
9D003CD4  98440000   LWR A0, 0(V0)
9D003CD8  00801021   ADDU V0, A0, ZERO
9D003CDC  AFC20028   SW V0, 40(S8)
2813:                	pseudoHeader.DestAddress        = *localIP;
9D003CE0  8FC2004C   LW V0, 76(S8)
9D003CE4  8C420000   LW V0, 0(V0)
9D003CE8  AFC2002C   SW V0, 44(S8)
2814:                	pseudoHeader.Zero               = 0x0;
9D003CEC  A3C00030   SB ZERO, 48(S8)
2815:                	pseudoHeader.Protocol           = IP_PROT_TCP;
9D003CF0  24020006   ADDIU V0, ZERO, 6
9D003CF4  A3C20031   SB V0, 49(S8)
2816:                	pseudoHeader.Length          	= len;
9D003CF8  97C20050   LHU V0, 80(S8)
9D003CFC  A7C20032   SH V0, 50(S8)
2817:                
2818:                	SwapPseudoHeader(pseudoHeader);
9D003D00  97C20032   LHU V0, 50(S8)
9D003D04  00402021   ADDU A0, V0, ZERO
9D003D08  0F409A16   JAL swaps
9D003D0C  00000000   NOP
9D003D10  A7C20032   SH V0, 50(S8)
2819:                
2820:                	checksum1.Val = ~CalcIPChecksum((BYTE*)&pseudoHeader,
9D003D14  27C20028   ADDIU V0, S8, 40
9D003D18  00402021   ADDU A0, V0, ZERO
9D003D1C  2405000C   ADDIU A1, ZERO, 12
9D003D20  0F409A63   JAL CalcIPChecksum
9D003D24  00000000   NOP
9D003D28  00021027   NOR V0, ZERO, V0
9D003D2C  3042FFFF   ANDI V0, V0, -1
9D003D30  A7C20034   SH V0, 52(S8)
2821:                		sizeof(pseudoHeader));
2822:                
2823:                	// Now calculate TCP packet checksum in NIC RAM - should match
2824:                	// pesudo header checksum
2825:                	checksum2.Val = CalcIPBufferChecksum(len);
9D003D34  97C20050   LHU V0, 80(S8)
9D003D38  00402021   ADDU A0, V0, ZERO
9D003D3C  0F40748E   JAL CalcIPBufferChecksum
9D003D40  00000000   NOP
9D003D44  A7C20038   SH V0, 56(S8)
2826:                
2827:                	// Compare checksums.
2828:                	if(checksum1.Val != checksum2.Val)
9D003D48  97C30034   LHU V1, 52(S8)
9D003D4C  97C20038   LHU V0, 56(S8)
9D003D50  10620006   BEQ V1, V0, 0x9D003D6C
9D003D54  00000000   NOP
2829:                	{
2830:                		MACDiscardRx();
9D003D58  0F40728D   JAL MACDiscardRx
9D003D5C  00000000   NOP
2831:                		return TRUE;
9D003D60  24020001   ADDIU V0, ZERO, 1
9D003D64  0B400F85   J 0x9D003E14
9D003D68  00000000   NOP
2832:                	}
2833:                
2834:                #if defined(DEBUG_GENERATE_RX_LOSS)
2835:                	// Throw RX packets away randomly
2836:                	if(LFSRRand() > DEBUG_GENERATE_RX_LOSS)
2837:                	{
2838:                		MACDiscardRx();
2839:                		return TRUE;
2840:                	}
2841:                #endif
2842:                
2843:                	// Retrieve TCP header.
2844:                	IPSetRxBuffer(0);
9D003D6C  00002021   ADDU A0, ZERO, ZERO
9D003D70  0F40CEF1   JAL IPSetRxBuffer
9D003D74  00000000   NOP
2845:                	MACGetArray((BYTE*)&TCPHeader, sizeof(TCPHeader));
9D003D78  27C20014   ADDIU V0, S8, 20
9D003D7C  00402021   ADDU A0, V0, ZERO
9D003D80  24050014   ADDIU A1, ZERO, 20
9D003D84  0F407560   JAL MACGetArray
9D003D88  00000000   NOP
2846:                	SwapTCPHeader(&TCPHeader);
9D003D8C  27C20014   ADDIU V0, S8, 20
9D003D90  00402021   ADDU A0, V0, ZERO
9D003D94  0F401468   JAL SwapTCPHeader
9D003D98  00000000   NOP
2847:                
2848:                
2849:                	// Skip over options to retrieve data bytes
2850:                	optionsSize = (BYTE)((TCPHeader.DataOffset.Val << 2)-
9D003D9C  8FC20020   LW V0, 32(S8)
9D003DA0  7C421900   EXT V0, V0, 4, 4
9D003DA4  304200FF   ANDI V0, V0, 255
9D003DA8  00021080   SLL V0, V0, 2
9D003DAC  304200FF   ANDI V0, V0, 255
9D003DB0  2442FFEC   ADDIU V0, V0, -20
9D003DB4  A3C20010   SB V0, 16(S8)
2851:                		sizeof(TCPHeader));
2852:                	len = len - optionsSize - sizeof(TCPHeader);
9D003DB8  93C20010   LBU V0, 16(S8)
9D003DBC  3042FFFF   ANDI V0, V0, -1
9D003DC0  97C30050   LHU V1, 80(S8)
9D003DC4  00621023   SUBU V0, V1, V0
9D003DC8  3042FFFF   ANDI V0, V0, -1
9D003DCC  2442FFEC   ADDIU V0, V0, -20
9D003DD0  A7C20050   SH V0, 80(S8)
2853:                
2854:                	// Find matching socket.
2855:                	if(FindMatchingSocket(&TCPHeader, remote))
9D003DD4  27C20014   ADDIU V0, S8, 20
9D003DD8  00402021   ADDU A0, V0, ZERO
9D003DDC  8FC50048   LW A1, 72(S8)
9D003DE0  0F4012EF   JAL FindMatchingSocket
9D003DE4  00000000   NOP
9D003DE8  10400007   BEQ V0, ZERO, 0x9D003E08
9D003DEC  00000000   NOP
2856:                	{
2857:                		#if defined(STACK_USE_SSL)
2858:                		PTR_BASE prevRxHead;
2859:                		// For SSL connections, show HandleTCPSeg() the full data buffer
2860:                		prevRxHead = MyTCBStub.rxHead;
2861:                		if(MyTCBStub.sslStubID != SSL_INVALID_ID)
2862:                			MyTCBStub.rxHead = MyTCBStub.sslRxHead;
2863:                		#endif
2864:                		
2865:                		HandleTCPSeg(&TCPHeader, len);
9D003DF0  97C20050   LHU V0, 80(S8)
9D003DF4  27C30014   ADDIU V1, S8, 20
9D003DF8  00602021   ADDU A0, V1, ZERO
9D003DFC  00402821   ADDU A1, V0, ZERO
9D003E00  0F401637   JAL HandleTCPSeg
9D003E04  00000000   NOP
2866:                		
2867:                		#if defined(STACK_USE_SSL)
2868:                		if(MyTCBStub.sslStubID != SSL_INVALID_ID)
2869:                		{
2870:                			// Restore the buffer state
2871:                			MyTCBStub.sslRxHead = MyTCBStub.rxHead;
2872:                			MyTCBStub.rxHead = prevRxHead;
2873:                
2874:                			// Process the new SSL data, using the currently loaded stub
2875:                			TCPSSLHandleIncoming(hCurrentTCP);
2876:                		}
2877:                		#endif
2878:                	}
2879:                //	else
2880:                //	{
2881:                //		// NOTE: RFC 793 specifies that if the socket is closed and a segment 
2882:                //		// arrives, we should send back a RST if the RST bit in the incoming 
2883:                //		// packet is not set.  Instead, we will just silently ignore such a 
2884:                //		// packet since this is what firewalls do on purpose to enhance 
2885:                //		// security.
2886:                //		//if(!TCPHeader.Flags.bits.flagRST)
2887:                //		//	SendTCP(RST, SENDTCP_RESET_TIMERS);
2888:                //	}
2889:                
2890:                	// Finished with this packet, discard it and free the Ethernet RAM for new packets
2891:                	MACDiscardRx();
9D003E08  0F40728D   JAL MACDiscardRx
9D003E0C  00000000   NOP
2892:                
2893:                	return TRUE;
9D003E10  24020001   ADDIU V0, ZERO, 1
2894:                }
9D003E14  03C0E821   ADDU SP, S8, ZERO
9D003E18  8FBF0044   LW RA, 68(SP)
9D003E1C  8FBE0040   LW S8, 64(SP)
9D003E20  27BD0048   ADDIU SP, SP, 72
9D003E24  03E00008   JR RA
9D003E28  00000000   NOP
2895:                
2896:                
2897:                /*****************************************************************************
2898:                  Function:
2899:                	static void SendTCP(BYTE vTCPFlags, BYTE vSendFlags)
2900:                
2901:                  Summary:
2902:                	Transmits a TPC segment.
2903:                
2904:                  Description:
2905:                	This function assembles and transmits a TCP segment, including any 
2906:                	pending data.  It also supports retransmissions, keep-alives, and 
2907:                	other packet types.
2908:                
2909:                  Precondition:
2910:                	TCP is initialized.
2911:                
2912:                  Parameters:
2913:                	vTCPFlags - Additional TCP flags to include
2914:                	vSendFlags - Any combinations of SENDTCP_* constants to modify the
2915:                				 transmit behavior or contents.
2916:                
2917:                  Returns:
2918:                	None
2919:                  ***************************************************************************/
2920:                static void SendTCP(BYTE vTCPFlags, BYTE vSendFlags)
2921:                {
9D003E2C  27BDFFA8   ADDIU SP, SP, -88
9D003E30  AFBF0054   SW RA, 84(SP)
9D003E34  AFBE0050   SW S8, 80(SP)
9D003E38  AFB0004C   SW S0, 76(SP)
9D003E3C  03A0F021   ADDU S8, SP, ZERO
9D003E40  00801821   ADDU V1, A0, ZERO
9D003E44  00A01021   ADDU V0, A1, ZERO
9D003E48  A3C30058   SB V1, 88(S8)
9D003E4C  A3C2005C   SB V0, 92(S8)
2922:                	WORD_VAL        wVal;
2923:                	TCP_HEADER      header;
2924:                	TCP_OPTIONS     options;
2925:                	PSEUDO_HEADER   pseudoHeader;
2926:                	WORD 			len;
2927:                	
2928:                	SyncTCB();
9D003E50  0F400008   JAL SyncTCB
9D003E54  00000000   NOP
2929:                
2930:                	// FINs must be handled specially
2931:                	if(vTCPFlags & FIN)
9D003E58  93C20058   LBU V0, 88(S8)
9D003E5C  30420001   ANDI V0, V0, 1
9D003E60  304200FF   ANDI V0, V0, 255
9D003E64  10400010   BEQ V0, ZERO, 0x9D003EA8
9D003E68  00000000   NOP
2932:                	{
2933:                		MyTCBStub.Flags.bTXFIN = 1;
9D003E6C  93828027   LBU V0, -32729(GP)
9D003E70  00402021   ADDU A0, V0, ZERO
9D003E74  3C02A000   LUI V0, -24576
9D003E78  24030030   ADDIU V1, ZERO, 48
9D003E7C  70831802   MUL V1, A0, V1
9D003E80  24422CDC   ADDIU V0, V0, 11484
9D003E84  00621821   ADDU V1, V1, V0
9D003E88  8C620028   LW V0, 40(V1)
9D003E8C  24040001   ADDIU A0, ZERO, 1
9D003E90  7C825AC4   INS V0, A0, 11, 1
9D003E94  AC620028   SW V0, 40(V1)
2934:                		vTCPFlags &= ~FIN;
9D003E98  93C30058   LBU V1, 88(S8)
9D003E9C  2402FFFE   ADDIU V0, ZERO, -2
9D003EA0  00621024   AND V0, V1, V0
9D003EA4  A3C20058   SB V0, 88(S8)
2935:                	}
2936:                
2937:                	// Status will now be synched, disable automatic future 
2938:                	// status transmissions
2939:                	MyTCBStub.Flags.bTimer2Enabled = 0;
9D003EA8  93828027   LBU V0, -32729(GP)
9D003EAC  00402021   ADDU A0, V0, ZERO
9D003EB0  3C02A000   LUI V0, -24576
9D003EB4  24030030   ADDIU V1, ZERO, 48
9D003EB8  70831802   MUL V1, A0, V1
9D003EBC  24422CDC   ADDIU V0, V0, 11484
9D003EC0  00621821   ADDU V1, V1, V0
9D003EC4  8C620028   LW V0, 40(V1)
9D003EC8  7C022944   INS V0, ZERO, 5, 1
9D003ECC  AC620028   SW V0, 40(V1)
2940:                	MyTCBStub.Flags.bDelayedACKTimerEnabled = 0;
9D003ED0  93828027   LBU V0, -32729(GP)
9D003ED4  00402021   ADDU A0, V0, ZERO
9D003ED8  3C02A000   LUI V0, -24576
9D003EDC  24030030   ADDIU V1, ZERO, 48
9D003EE0  70831802   MUL V1, A0, V1
9D003EE4  24422CDC   ADDIU V0, V0, 11484
9D003EE8  00621821   ADDU V1, V1, V0
9D003EEC  8C620028   LW V0, 40(V1)
9D003EF0  7C023184   INS V0, ZERO, 6, 1
9D003EF4  AC620028   SW V0, 40(V1)
2941:                	MyTCBStub.Flags.bOneSegmentReceived = 0;
9D003EF8  93828027   LBU V0, -32729(GP)
9D003EFC  00402021   ADDU A0, V0, ZERO
9D003F00  3C02A000   LUI V0, -24576
9D003F04  24030030   ADDIU V1, ZERO, 48
9D003F08  70831802   MUL V1, A0, V1
9D003F0C  24422CDC   ADDIU V0, V0, 11484
9D003F10  00621821   ADDU V1, V1, V0
9D003F14  8C620028   LW V0, 40(V1)
9D003F18  7C0239C4   INS V0, ZERO, 7, 1
9D003F1C  AC620028   SW V0, 40(V1)
2942:                	MyTCBStub.Flags.bTXASAP = 0;
9D003F20  93828027   LBU V0, -32729(GP)
9D003F24  00402021   ADDU A0, V0, ZERO
9D003F28  3C02A000   LUI V0, -24576
9D003F2C  24030030   ADDIU V1, ZERO, 48
9D003F30  70831802   MUL V1, A0, V1
9D003F34  24422CDC   ADDIU V0, V0, 11484
9D003F38  00621821   ADDU V1, V1, V0
9D003F3C  8C620028   LW V0, 40(V1)
9D003F40  7C024A44   INS V0, ZERO, 9, 1
9D003F44  AC620028   SW V0, 40(V1)
2943:                	MyTCBStub.Flags.bTXASAPWithoutTimerReset = 0;
9D003F48  93828027   LBU V0, -32729(GP)
9D003F4C  00402021   ADDU A0, V0, ZERO
9D003F50  3C02A000   LUI V0, -24576
9D003F54  24030030   ADDIU V1, ZERO, 48
9D003F58  70831802   MUL V1, A0, V1
9D003F5C  24422CDC   ADDIU V0, V0, 11484
9D003F60  00621821   ADDU V1, V1, V0
9D003F64  8C620028   LW V0, 40(V1)
9D003F68  7C025284   INS V0, ZERO, 10, 1
9D003F6C  AC620028   SW V0, 40(V1)
2944:                	MyTCBStub.Flags.bHalfFullFlush = 0;
9D003F70  93828027   LBU V0, -32729(GP)
9D003F74  00402021   ADDU A0, V0, ZERO
9D003F78  3C02A000   LUI V0, -24576
9D003F7C  24030030   ADDIU V1, ZERO, 48
9D003F80  70831802   MUL V1, A0, V1
9D003F84  24422CDC   ADDIU V0, V0, 11484
9D003F88  00621821   ADDU V1, V1, V0
9D003F8C  8C620028   LW V0, 40(V1)
9D003F90  7C024204   INS V0, ZERO, 8, 1
9D003F94  AC620028   SW V0, 40(V1)
2945:                
2946:                	//  Make sure that we can write to the MAC transmit area
2947:                	while(!IPIsTxReady());
9D003F98  00000000   NOP
9D003F9C  0F40727E   JAL MACIsTxReady
9D003FA0  00000000   NOP
9D003FA4  1040FFFD   BEQ V0, ZERO, 0x9D003F9C
9D003FA8  00000000   NOP
2948:                
2949:                	// Put all socket application data in the TX space
2950:                	if(vTCPFlags & (SYN | RST))
9D003FAC  93C20058   LBU V0, 88(S8)
9D003FB0  30420006   ANDI V0, V0, 6
9D003FB4  10400004   BEQ V0, ZERO, 0x9D003FC8
9D003FB8  00000000   NOP
2951:                	{
2952:                		// Don't put any data in SYN and RST messages
2953:                		len = 0;
9D003FBC  A7C00018   SH ZERO, 24(S8)
9D003FC0  0B401134   J 0x9D0044D0
9D003FC4  00000000   NOP
2954:                	}
2955:                	else
2956:                	{
2957:                		// Begin copying any application data over to the TX space
2958:                		if(MyTCBStub.txHead == MyTCB.txUnackedTail)
9D003FC8  93828027   LBU V0, -32729(GP)
9D003FCC  00402021   ADDU A0, V0, ZERO
9D003FD0  3C02A000   LUI V0, -24576
9D003FD4  24432CDC   ADDIU V1, V0, 11484
9D003FD8  24020030   ADDIU V0, ZERO, 48
9D003FDC  70821002   MUL V0, A0, V0
9D003FE0  00621021   ADDU V0, V1, V0
9D003FE4  8C43000C   LW V1, 12(V0)
9D003FE8  3C02A000   LUI V0, -24576
9D003FEC  24422E8C   ADDIU V0, V0, 11916
9D003FF0  8C42000C   LW V0, 12(V0)
9D003FF4  14620004   BNE V1, V0, 0x9D004008
9D003FF8  00000000   NOP
2959:                		{
2960:                			// All caught up on data TX, no real data for this packet
2961:                			len = 0;
9D003FFC  A7C00018   SH ZERO, 24(S8)
9D004000  0B401119   J 0x9D004464
9D004004  00000000   NOP
2962:                		}
2963:                		else if(MyTCBStub.txHead > MyTCB.txUnackedTail)
9D004008  93828027   LBU V0, -32729(GP)
9D00400C  00402021   ADDU A0, V0, ZERO
9D004010  3C02A000   LUI V0, -24576
9D004014  24432CDC   ADDIU V1, V0, 11484
9D004018  24020030   ADDIU V0, ZERO, 48
9D00401C  70821002   MUL V0, A0, V0
9D004020  00621021   ADDU V0, V1, V0
9D004024  8C43000C   LW V1, 12(V0)
9D004028  3C02A000   LUI V0, -24576
9D00402C  24422E8C   ADDIU V0, V0, 11916
9D004030  8C42000C   LW V0, 12(V0)
9D004034  0043102B   SLTU V0, V0, V1
9D004038  1040004E   BEQ V0, ZERO, 0x9D004174
9D00403C  00000000   NOP
2964:                		{
2965:                			len = MyTCBStub.txHead - MyTCB.txUnackedTail;
9D004040  93828027   LBU V0, -32729(GP)
9D004044  00402021   ADDU A0, V0, ZERO
9D004048  3C02A000   LUI V0, -24576
9D00404C  24432CDC   ADDIU V1, V0, 11484
9D004050  24020030   ADDIU V0, ZERO, 48
9D004054  70821002   MUL V0, A0, V0
9D004058  00621021   ADDU V0, V1, V0
9D00405C  8C42000C   LW V0, 12(V0)
9D004060  3043FFFF   ANDI V1, V0, -1
9D004064  3C02A000   LUI V0, -24576
9D004068  24422E8C   ADDIU V0, V0, 11916
9D00406C  8C42000C   LW V0, 12(V0)
9D004070  3042FFFF   ANDI V0, V0, -1
9D004074  00621023   SUBU V0, V1, V0
9D004078  A7C20018   SH V0, 24(S8)
2966:                
2967:                			if(len > MyTCB.remoteWindow)
9D00407C  3C02A000   LUI V0, -24576
9D004080  24422E8C   ADDIU V0, V0, 11916
9D004084  94420014   LHU V0, 20(V0)
9D004088  97C30018   LHU V1, 24(S8)
9D00408C  0043102B   SLTU V0, V0, V1
9D004090  10400005   BEQ V0, ZERO, 0x9D0040A8
9D004094  00000000   NOP
2968:                				len = MyTCB.remoteWindow;
9D004098  3C02A000   LUI V0, -24576
9D00409C  24422E8C   ADDIU V0, V0, 11916
9D0040A0  94420014   LHU V0, 20(V0)
9D0040A4  A7C20018   SH V0, 24(S8)
2969:                
2970:                			if(len > MyTCB.wRemoteMSS)
9D0040A8  3C02A000   LUI V0, -24576
9D0040AC  24422E8C   ADDIU V0, V0, 11916
9D0040B0  94420028   LHU V0, 40(V0)
9D0040B4  97C30018   LHU V1, 24(S8)
9D0040B8  0043102B   SLTU V0, V0, V1
9D0040BC  10400010   BEQ V0, ZERO, 0x9D004100
9D0040C0  00000000   NOP
2971:                			{
2972:                				len = MyTCB.wRemoteMSS;
9D0040C4  3C02A000   LUI V0, -24576
9D0040C8  24422E8C   ADDIU V0, V0, 11916
9D0040CC  94420028   LHU V0, 40(V0)
9D0040D0  A7C20018   SH V0, 24(S8)
2973:                				MyTCBStub.Flags.bTXASAPWithoutTimerReset = 1;
9D0040D4  93828027   LBU V0, -32729(GP)
9D0040D8  00402021   ADDU A0, V0, ZERO
9D0040DC  3C02A000   LUI V0, -24576
9D0040E0  24030030   ADDIU V1, ZERO, 48
9D0040E4  70831802   MUL V1, A0, V1
9D0040E8  24422CDC   ADDIU V0, V0, 11484
9D0040EC  00621821   ADDU V1, V1, V0
9D0040F0  8C620028   LW V0, 40(V1)
9D0040F4  24040001   ADDIU A0, ZERO, 1
9D0040F8  7C825284   INS V0, A0, 10, 1
9D0040FC  AC620028   SW V0, 40(V1)
2974:                			}
2975:                
2976:                			// Copy application data into the raw TX buffer
2977:                			TCPRAMCopy(BASE_TX_ADDR+sizeof(ETHER_HEADER)+sizeof(IP_HEADER)+sizeof(TCP_HEADER), TCP_ETH_RAM, MyTCB.txUnackedTail, MyTCBStub.vMemoryMedium, len);
9D004100  3C02A000   LUI V0, -24576
9D004104  24422E8C   ADDIU V0, V0, 11916
9D004108  8C43000C   LW V1, 12(V0)
9D00410C  93828027   LBU V0, -32729(GP)
9D004110  00402821   ADDU A1, V0, ZERO
9D004114  3C02A000   LUI V0, -24576
9D004118  24040030   ADDIU A0, ZERO, 48
9D00411C  70A42002   MUL A0, A1, A0
9D004120  24422CDC   ADDIU V0, V0, 11484
9D004124  00821021   ADDU V0, A0, V0
9D004128  9042002C   LBU V0, 44(V0)
9D00412C  97C40018   LHU A0, 24(S8)
9D004130  AFA40010   SW A0, 16(SP)
9D004134  24040036   ADDIU A0, ZERO, 54
9D004138  00002821   ADDU A1, ZERO, ZERO
9D00413C  00603021   ADDU A2, V1, ZERO
9D004140  00403821   ADDU A3, V0, ZERO
9D004144  0F4020BE   JAL TCPRAMCopy
9D004148  00000000   NOP
2978:                			MyTCB.txUnackedTail += len;
9D00414C  3C02A000   LUI V0, -24576
9D004150  24422E8C   ADDIU V0, V0, 11916
9D004154  8C43000C   LW V1, 12(V0)
9D004158  97C20018   LHU V0, 24(S8)
9D00415C  00621821   ADDU V1, V1, V0
9D004160  3C02A000   LUI V0, -24576
9D004164  24422E8C   ADDIU V0, V0, 11916
9D004168  AC43000C   SW V1, 12(V0)
9D00416C  0B401119   J 0x9D004464
9D004170  00000000   NOP
2979:                		}
2980:                		else
2981:                		{
2982:                			pseudoHeader.Length = MyTCBStub.bufferRxStart - MyTCB.txUnackedTail;
9D004174  93828027   LBU V0, -32729(GP)
9D004178  00402021   ADDU A0, V0, ZERO
9D00417C  3C02A000   LUI V0, -24576
9D004180  24432CDC   ADDIU V1, V0, 11484
9D004184  24020030   ADDIU V0, ZERO, 48
9D004188  70821002   MUL V0, A0, V0
9D00418C  00621021   ADDU V0, V1, V0
9D004190  8C420004   LW V0, 4(V0)
9D004194  3043FFFF   ANDI V1, V0, -1
9D004198  3C02A000   LUI V0, -24576
9D00419C  24422E8C   ADDIU V0, V0, 11916
9D0041A0  8C42000C   LW V0, 12(V0)
9D0041A4  3042FFFF   ANDI V0, V0, -1
9D0041A8  00621023   SUBU V0, V1, V0
9D0041AC  3042FFFF   ANDI V0, V0, -1
9D0041B0  A7C20042   SH V0, 66(S8)
2983:                			len = pseudoHeader.Length + MyTCBStub.txHead - MyTCBStub.bufferTxStart;
9D0041B4  97C30042   LHU V1, 66(S8)
9D0041B8  93828027   LBU V0, -32729(GP)
9D0041BC  00402821   ADDU A1, V0, ZERO
9D0041C0  3C02A000   LUI V0, -24576
9D0041C4  24442CDC   ADDIU A0, V0, 11484
9D0041C8  24020030   ADDIU V0, ZERO, 48
9D0041CC  70A21002   MUL V0, A1, V0
9D0041D0  00821021   ADDU V0, A0, V0
9D0041D4  8C42000C   LW V0, 12(V0)
9D0041D8  3042FFFF   ANDI V0, V0, -1
9D0041DC  00621021   ADDU V0, V1, V0
9D0041E0  3043FFFF   ANDI V1, V0, -1
9D0041E4  93828027   LBU V0, -32729(GP)
9D0041E8  00402821   ADDU A1, V0, ZERO
9D0041EC  3C02A000   LUI V0, -24576
9D0041F0  24040030   ADDIU A0, ZERO, 48
9D0041F4  70A42002   MUL A0, A1, A0
9D0041F8  24422CDC   ADDIU V0, V0, 11484
9D0041FC  00821021   ADDU V0, A0, V0
9D004200  8C420000   LW V0, 0(V0)
9D004204  3042FFFF   ANDI V0, V0, -1
9D004208  00621023   SUBU V0, V1, V0
9D00420C  A7C20018   SH V0, 24(S8)
2984:                
2985:                			if(len > MyTCB.remoteWindow)
9D004210  3C02A000   LUI V0, -24576
9D004214  24422E8C   ADDIU V0, V0, 11916
9D004218  94420014   LHU V0, 20(V0)
9D00421C  97C30018   LHU V1, 24(S8)
9D004220  0043102B   SLTU V0, V0, V1
9D004224  10400005   BEQ V0, ZERO, 0x9D00423C
9D004228  00000000   NOP
2986:                				len = MyTCB.remoteWindow;
9D00422C  3C02A000   LUI V0, -24576
9D004230  24422E8C   ADDIU V0, V0, 11916
9D004234  94420014   LHU V0, 20(V0)
9D004238  A7C20018   SH V0, 24(S8)
2987:                
2988:                			if(len > MyTCB.wRemoteMSS)
9D00423C  3C02A000   LUI V0, -24576
9D004240  24422E8C   ADDIU V0, V0, 11916
9D004244  94420028   LHU V0, 40(V0)
9D004248  97C30018   LHU V1, 24(S8)
9D00424C  0043102B   SLTU V0, V0, V1
9D004250  10400010   BEQ V0, ZERO, 0x9D004294
9D004254  00000000   NOP
2989:                			{
2990:                				len = MyTCB.wRemoteMSS;
9D004258  3C02A000   LUI V0, -24576
9D00425C  24422E8C   ADDIU V0, V0, 11916
9D004260  94420028   LHU V0, 40(V0)
9D004264  A7C20018   SH V0, 24(S8)
2991:                				MyTCBStub.Flags.bTXASAPWithoutTimerReset = 1;
9D004268  93828027   LBU V0, -32729(GP)
9D00426C  00402021   ADDU A0, V0, ZERO
9D004270  3C02A000   LUI V0, -24576
9D004274  24030030   ADDIU V1, ZERO, 48
9D004278  70831802   MUL V1, A0, V1
9D00427C  24422CDC   ADDIU V0, V0, 11484
9D004280  00621821   ADDU V1, V1, V0
9D004284  8C620028   LW V0, 40(V1)
9D004288  24040001   ADDIU A0, ZERO, 1
9D00428C  7C825284   INS V0, A0, 10, 1
9D004290  AC620028   SW V0, 40(V1)
2992:                			}
2993:                
2994:                			if(pseudoHeader.Length > len)
9D004294  97C20042   LHU V0, 66(S8)
9D004298  97C30018   LHU V1, 24(S8)
9D00429C  0062102B   SLTU V0, V1, V0
9D0042A0  10400003   BEQ V0, ZERO, 0x9D0042B0
9D0042A4  00000000   NOP
2995:                				pseudoHeader.Length = len;
9D0042A8  97C20018   LHU V0, 24(S8)
9D0042AC  A7C20042   SH V0, 66(S8)
2996:                
2997:                			// Copy application data into the raw TX buffer
2998:                			TCPRAMCopy(BASE_TX_ADDR+sizeof(ETHER_HEADER)+sizeof(IP_HEADER)+sizeof(TCP_HEADER), TCP_ETH_RAM, MyTCB.txUnackedTail, MyTCBStub.vMemoryMedium, pseudoHeader.Length);
9D0042B0  3C02A000   LUI V0, -24576
9D0042B4  24422E8C   ADDIU V0, V0, 11916
9D0042B8  8C43000C   LW V1, 12(V0)
9D0042BC  93828027   LBU V0, -32729(GP)
9D0042C0  00402821   ADDU A1, V0, ZERO
9D0042C4  3C02A000   LUI V0, -24576
9D0042C8  24040030   ADDIU A0, ZERO, 48
9D0042CC  70A42002   MUL A0, A1, A0
9D0042D0  24422CDC   ADDIU V0, V0, 11484
9D0042D4  00821021   ADDU V0, A0, V0
9D0042D8  9042002C   LBU V0, 44(V0)
9D0042DC  97C40042   LHU A0, 66(S8)
9D0042E0  AFA40010   SW A0, 16(SP)
9D0042E4  24040036   ADDIU A0, ZERO, 54
9D0042E8  00002821   ADDU A1, ZERO, ZERO
9D0042EC  00603021   ADDU A2, V1, ZERO
9D0042F0  00403821   ADDU A3, V0, ZERO
9D0042F4  0F4020BE   JAL TCPRAMCopy
9D0042F8  00000000   NOP
2999:                			pseudoHeader.Length = len - pseudoHeader.Length;
9D0042FC  97C20042   LHU V0, 66(S8)
9D004300  97C30018   LHU V1, 24(S8)
9D004304  00621023   SUBU V0, V1, V0
9D004308  3042FFFF   ANDI V0, V0, -1
9D00430C  A7C20042   SH V0, 66(S8)
3000:                	
3001:                			// Copy any left over chunks of application data over
3002:                			if(pseudoHeader.Length)
9D004310  97C20042   LHU V0, 66(S8)
9D004314  10400025   BEQ V0, ZERO, 0x9D0043AC
9D004318  00000000   NOP
3003:                			{
3004:                				TCPRAMCopy(BASE_TX_ADDR+sizeof(ETHER_HEADER)+sizeof(IP_HEADER)+sizeof(TCP_HEADER)+(MyTCBStub.bufferRxStart-MyTCB.txUnackedTail), TCP_ETH_RAM, MyTCBStub.bufferTxStart, MyTCBStub.vMemoryMedium, pseudoHeader.Length);
9D00431C  93828027   LBU V0, -32729(GP)
9D004320  00402021   ADDU A0, V0, ZERO
9D004324  3C02A000   LUI V0, -24576
9D004328  24432CDC   ADDIU V1, V0, 11484
9D00432C  24020030   ADDIU V0, ZERO, 48
9D004330  70821002   MUL V0, A0, V0
9D004334  00621021   ADDU V0, V1, V0
9D004338  8C430004   LW V1, 4(V0)
9D00433C  3C02A000   LUI V0, -24576
9D004340  24422E8C   ADDIU V0, V0, 11916
9D004344  8C42000C   LW V0, 12(V0)
9D004348  00621023   SUBU V0, V1, V0
9D00434C  24440036   ADDIU A0, V0, 54
9D004350  93828027   LBU V0, -32729(GP)
9D004354  00402821   ADDU A1, V0, ZERO
9D004358  3C02A000   LUI V0, -24576
9D00435C  24030030   ADDIU V1, ZERO, 48
9D004360  70A31802   MUL V1, A1, V1
9D004364  24422CDC   ADDIU V0, V0, 11484
9D004368  00621021   ADDU V0, V1, V0
9D00436C  8C430000   LW V1, 0(V0)
9D004370  93828027   LBU V0, -32729(GP)
9D004374  00403021   ADDU A2, V0, ZERO
9D004378  3C02A000   LUI V0, -24576
9D00437C  24050030   ADDIU A1, ZERO, 48
9D004380  70C52802   MUL A1, A2, A1
9D004384  24422CDC   ADDIU V0, V0, 11484
9D004388  00A21021   ADDU V0, A1, V0
9D00438C  9042002C   LBU V0, 44(V0)
9D004390  97C50042   LHU A1, 66(S8)
9D004394  AFA50010   SW A1, 16(SP)
9D004398  00002821   ADDU A1, ZERO, ZERO
9D00439C  00603021   ADDU A2, V1, ZERO
9D0043A0  00403821   ADDU A3, V0, ZERO
9D0043A4  0F4020BE   JAL TCPRAMCopy
9D0043A8  00000000   NOP
3005:                			}
3006:                
3007:                			MyTCB.txUnackedTail += len;
9D0043AC  3C02A000   LUI V0, -24576
9D0043B0  24422E8C   ADDIU V0, V0, 11916
9D0043B4  8C43000C   LW V1, 12(V0)
9D0043B8  97C20018   LHU V0, 24(S8)
9D0043BC  00621821   ADDU V1, V1, V0
9D0043C0  3C02A000   LUI V0, -24576
9D0043C4  24422E8C   ADDIU V0, V0, 11916
9D0043C8  AC43000C   SW V1, 12(V0)
3008:                			if(MyTCB.txUnackedTail >= MyTCBStub.bufferRxStart)
9D0043CC  3C02A000   LUI V0, -24576
9D0043D0  24422E8C   ADDIU V0, V0, 11916
9D0043D4  8C43000C   LW V1, 12(V0)
9D0043D8  93828027   LBU V0, -32729(GP)
9D0043DC  00402821   ADDU A1, V0, ZERO
9D0043E0  3C02A000   LUI V0, -24576
9D0043E4  24442CDC   ADDIU A0, V0, 11484
9D0043E8  24020030   ADDIU V0, ZERO, 48
9D0043EC  70A21002   MUL V0, A1, V0
9D0043F0  00821021   ADDU V0, A0, V0
9D0043F4  8C420004   LW V0, 4(V0)
9D0043F8  0062102B   SLTU V0, V1, V0
9D0043FC  14400019   BNE V0, ZERO, 0x9D004464
9D004400  00000000   NOP
3009:                				MyTCB.txUnackedTail -= MyTCBStub.bufferRxStart-MyTCBStub.bufferTxStart;
9D004404  3C02A000   LUI V0, -24576
9D004408  24422E8C   ADDIU V0, V0, 11916
9D00440C  8C43000C   LW V1, 12(V0)
9D004410  93828027   LBU V0, -32729(GP)
9D004414  00402821   ADDU A1, V0, ZERO
9D004418  3C02A000   LUI V0, -24576
9D00441C  24040030   ADDIU A0, ZERO, 48
9D004420  70A42002   MUL A0, A1, A0
9D004424  24422CDC   ADDIU V0, V0, 11484
9D004428  00821021   ADDU V0, A0, V0
9D00442C  8C440000   LW A0, 0(V0)
9D004430  93828027   LBU V0, -32729(GP)
9D004434  00403021   ADDU A2, V0, ZERO
9D004438  3C02A000   LUI V0, -24576
9D00443C  24452CDC   ADDIU A1, V0, 11484
9D004440  24020030   ADDIU V0, ZERO, 48
9D004444  70C21002   MUL V0, A2, V0
9D004448  00A21021   ADDU V0, A1, V0
9D00444C  8C420004   LW V0, 4(V0)
9D004450  00821023   SUBU V0, A0, V0
9D004454  00621821   ADDU V1, V1, V0
9D004458  3C02A000   LUI V0, -24576
9D00445C  24422E8C   ADDIU V0, V0, 11916
9D004460  AC43000C   SW V1, 12(V0)
3010:                		}
3011:                
3012:                		// If we are to transmit a FIN, make sure we can put one in this packet
3013:                		if(MyTCBStub.Flags.bTXFIN)
9D004464  93828027   LBU V0, -32729(GP)
9D004468  00402021   ADDU A0, V0, ZERO
9D00446C  3C02A000   LUI V0, -24576
9D004470  24030030   ADDIU V1, ZERO, 48
9D004474  70831802   MUL V1, A0, V1
9D004478  24422CDC   ADDIU V0, V0, 11484
9D00447C  00621021   ADDU V0, V1, V0
9D004480  8C420028   LW V0, 40(V0)
9D004484  7C4202C0   EXT V0, V0, 11, 1
9D004488  304200FF   ANDI V0, V0, 255
9D00448C  10400010   BEQ V0, ZERO, 0x9D0044D0
9D004490  00000000   NOP
3014:                		{
3015:                			if((len != MyTCB.remoteWindow) && (len != MyTCB.wRemoteMSS))
9D004494  3C02A000   LUI V0, -24576
9D004498  24422E8C   ADDIU V0, V0, 11916
9D00449C  94420014   LHU V0, 20(V0)
9D0044A0  97C30018   LHU V1, 24(S8)
9D0044A4  1062000A   BEQ V1, V0, 0x9D0044D0
9D0044A8  00000000   NOP
9D0044AC  3C02A000   LUI V0, -24576
9D0044B0  24422E8C   ADDIU V0, V0, 11916
9D0044B4  94420028   LHU V0, 40(V0)
9D0044B8  97C30018   LHU V1, 24(S8)
9D0044BC  10620004   BEQ V1, V0, 0x9D0044D0
9D0044C0  00000000   NOP
3016:                				vTCPFlags |= FIN;
9D0044C4  93C20058   LBU V0, 88(S8)
9D0044C8  34420001   ORI V0, V0, 1
9D0044CC  A3C20058   SB V0, 88(S8)
3017:                		}
3018:                	}
3019:                
3020:                	// Ensure that all packets with data of some kind are 
3021:                	// retransmitted by TCPTick() until acknowledged
3022:                	// Pure ACK packets with no data are not ACKed back in TCP
3023:                	if(len || (vTCPFlags & (SYN | FIN)))
9D0044D0  97C20018   LHU V0, 24(S8)
9D0044D4  14400005   BNE V0, ZERO, 0x9D0044EC
9D0044D8  00000000   NOP
9D0044DC  93C20058   LBU V0, 88(S8)
9D0044E0  30420003   ANDI V0, V0, 3
9D0044E4  10400037   BEQ V0, ZERO, 0x9D0045C4
9D0044E8  00000000   NOP
3024:                	{
3025:                		// Transmitting data, update remote window variable to reflect smaller 
3026:                		// window.
3027:                		MyTCB.remoteWindow -= len;
9D0044EC  3C02A000   LUI V0, -24576
9D0044F0  24422E8C   ADDIU V0, V0, 11916
9D0044F4  94430014   LHU V1, 20(V0)
9D0044F8  97C20018   LHU V0, 24(S8)
9D0044FC  00621023   SUBU V0, V1, V0
9D004500  3043FFFF   ANDI V1, V0, -1
9D004504  3C02A000   LUI V0, -24576
9D004508  24422E8C   ADDIU V0, V0, 11916
9D00450C  A4430014   SH V1, 20(V0)
3028:                
3029:                		// Push (PSH) all data for enhanced responsiveness on 
3030:                		// the remote end, especially with GUIs
3031:                		if(len)
9D004510  97C20018   LHU V0, 24(S8)
9D004514  10400004   BEQ V0, ZERO, 0x9D004528
9D004518  00000000   NOP
3032:                			vTCPFlags |= PSH;
9D00451C  93C20058   LBU V0, 88(S8)
9D004520  34420008   ORI V0, V0, 8
9D004524  A3C20058   SB V0, 88(S8)
3033:                
3034:                		if(vSendFlags & SENDTCP_RESET_TIMERS)
9D004528  93C2005C   LBU V0, 92(S8)
9D00452C  30420001   ANDI V0, V0, 1
9D004530  304200FF   ANDI V0, V0, 255
9D004534  10400008   BEQ V0, ZERO, 0x9D004558
9D004538  00000000   NOP
3035:                		{
3036:                			MyTCB.retryCount = 0;
9D00453C  3C02A000   LUI V0, -24576
9D004540  24422E8C   ADDIU V0, V0, 11916
9D004544  A040002A   SB ZERO, 42(V0)
3037:                			MyTCB.retryInterval = TCP_START_TIMEOUT_VAL;
9D004548  3C02A000   LUI V0, -24576
9D00454C  3C030002   LUI V1, 2
9D004550  3463625A   ORI V1, V1, 25178
9D004554  AC432E8C   SW V1, 11916(V0)
3038:                		}	
3039:                
3040:                		MyTCBStub.eventTime = TickGet() + MyTCB.retryInterval;
9D004558  93828027   LBU V0, -32729(GP)
9D00455C  00408021   ADDU S0, V0, ZERO
9D004560  0F40CDD6   JAL TickGet
9D004564  00000000   NOP
9D004568  00401821   ADDU V1, V0, ZERO
9D00456C  3C02A000   LUI V0, -24576
9D004570  8C422E8C   LW V0, 11916(V0)
9D004574  00621821   ADDU V1, V1, V0
9D004578  3C02A000   LUI V0, -24576
9D00457C  24442CDC   ADDIU A0, V0, 11484
9D004580  24020030   ADDIU V0, ZERO, 48
9D004584  72021002   MUL V0, S0, V0
9D004588  00821021   ADDU V0, A0, V0
9D00458C  AC43001C   SW V1, 28(V0)
3041:                		MyTCBStub.Flags.bTimerEnabled = 1;
9D004590  93828027   LBU V0, -32729(GP)
9D004594  00402021   ADDU A0, V0, ZERO
9D004598  3C02A000   LUI V0, -24576
9D00459C  24030030   ADDIU V1, ZERO, 48
9D0045A0  70831802   MUL V1, A0, V1
9D0045A4  24422CDC   ADDIU V0, V0, 11484
9D0045A8  00621821   ADDU V1, V1, V0
9D0045AC  8C620028   LW V0, 40(V1)
9D0045B0  24040001   ADDIU A0, ZERO, 1
9D0045B4  7C822104   INS V0, A0, 4, 1
9D0045B8  AC620028   SW V0, 40(V1)
9D0045BC  0B4011C5   J 0x9D004714
9D0045C0  00000000   NOP
3042:                	}
3043:                	else if(vSendFlags & SENDTCP_KEEP_ALIVE)
9D0045C4  93C2005C   LBU V0, 92(S8)
9D0045C8  30420002   ANDI V0, V0, 2
9D0045CC  10400021   BEQ V0, ZERO, 0x9D004654
9D0045D0  00000000   NOP
3044:                	{
3045:                		// Increment Keep Alive TX counter to handle disconnection if not response is returned
3046:                		MyTCBStub.Flags.vUnackedKeepalives++;
9D0045D4  93828027   LBU V0, -32729(GP)
9D0045D8  00402821   ADDU A1, V0, ZERO
9D0045DC  3C02A000   LUI V0, -24576
9D0045E0  24030030   ADDIU V1, ZERO, 48
9D0045E4  70A31802   MUL V1, A1, V1
9D0045E8  24422CDC   ADDIU V0, V0, 11484
9D0045EC  00621021   ADDU V0, V1, V0
9D0045F0  8C420028   LW V0, 40(V0)
9D0045F4  7C421000   EXT V0, V0, 0, 3
9D0045F8  304200FF   ANDI V0, V0, 255
9D0045FC  24420001   ADDIU V0, V0, 1
9D004600  30420007   ANDI V0, V0, 7
9D004604  304400FF   ANDI A0, V0, 255
9D004608  3C02A000   LUI V0, -24576
9D00460C  24030030   ADDIU V1, ZERO, 48
9D004610  70A31802   MUL V1, A1, V1
9D004614  24422CDC   ADDIU V0, V0, 11484
9D004618  00621821   ADDU V1, V1, V0
9D00461C  8C620028   LW V0, 40(V1)
9D004620  7C821004   INS V0, A0, 0, 3
9D004624  AC620028   SW V0, 40(V1)
3047:                		
3048:                		// Generate a dummy byte
3049:                		MyTCB.MySEQ -= 1;
9D004628  3C02A000   LUI V0, -24576
9D00462C  24422E8C   ADDIU V0, V0, 11916
9D004630  8C420004   LW V0, 4(V0)
9D004634  2443FFFF   ADDIU V1, V0, -1
9D004638  3C02A000   LUI V0, -24576
9D00463C  24422E8C   ADDIU V0, V0, 11916
9D004640  AC430004   SW V1, 4(V0)
3050:                		len = 1;
9D004644  24020001   ADDIU V0, ZERO, 1
9D004648  A7C20018   SH V0, 24(S8)
9D00464C  0B4011C5   J 0x9D004714
9D004650  00000000   NOP
3051:                	}
3052:                	else if(MyTCBStub.Flags.bTimerEnabled) 
9D004654  93828027   LBU V0, -32729(GP)
9D004658  00402021   ADDU A0, V0, ZERO
9D00465C  3C02A000   LUI V0, -24576
9D004660  24030030   ADDIU V1, ZERO, 48
9D004664  70831802   MUL V1, A0, V1
9D004668  24422CDC   ADDIU V0, V0, 11484
9D00466C  00621021   ADDU V0, V1, V0
9D004670  8C420028   LW V0, 40(V0)
9D004674  7C420100   EXT V0, V0, 4, 1
9D004678  304200FF   ANDI V0, V0, 255
9D00467C  10400025   BEQ V0, ZERO, 0x9D004714
9D004680  00000000   NOP
3053:                	{
3054:                		// If we have data to transmit, but the remote RX window is zero, 
3055:                		// so we aren't transmitting any right now then make sure to not 
3056:                		// extend the retry counter or timer.  This will stall our TX 
3057:                		// with a periodic ACK sent to the remote node.
3058:                		if(!(vSendFlags & SENDTCP_RESET_TIMERS))
9D004684  93C2005C   LBU V0, 92(S8)
9D004688  30420001   ANDI V0, V0, 1
9D00468C  14400013   BNE V0, ZERO, 0x9D0046DC
9D004690  00000000   NOP
3059:                		{
3060:                			// Roll back retry counters since we can't send anything, 
3061:                			// but only if we incremented it in the first place
3062:                			if(MyTCB.retryCount)
9D004694  3C02A000   LUI V0, -24576
9D004698  24422E8C   ADDIU V0, V0, 11916
9D00469C  9042002A   LBU V0, 42(V0)
9D0046A0  1040000E   BEQ V0, ZERO, 0x9D0046DC
9D0046A4  00000000   NOP
3063:                			{
3064:                				MyTCB.retryCount--;
9D0046A8  3C02A000   LUI V0, -24576
9D0046AC  24422E8C   ADDIU V0, V0, 11916
9D0046B0  9042002A   LBU V0, 42(V0)
9D0046B4  2442FFFF   ADDIU V0, V0, -1
9D0046B8  304300FF   ANDI V1, V0, 255
9D0046BC  3C02A000   LUI V0, -24576
9D0046C0  24422E8C   ADDIU V0, V0, 11916
9D0046C4  A043002A   SB V1, 42(V0)
3065:                				MyTCB.retryInterval >>= 1;
9D0046C8  3C02A000   LUI V0, -24576
9D0046CC  8C422E8C   LW V0, 11916(V0)
9D0046D0  00021842   SRL V1, V0, 1
9D0046D4  3C02A000   LUI V0, -24576
9D0046D8  AC432E8C   SW V1, 11916(V0)
3066:                			}
3067:                		}
3068:                	
3069:                		MyTCBStub.eventTime = TickGet() + MyTCB.retryInterval;
9D0046DC  93828027   LBU V0, -32729(GP)
9D0046E0  00408021   ADDU S0, V0, ZERO
9D0046E4  0F40CDD6   JAL TickGet
9D0046E8  00000000   NOP
9D0046EC  00401821   ADDU V1, V0, ZERO
9D0046F0  3C02A000   LUI V0, -24576
9D0046F4  8C422E8C   LW V0, 11916(V0)
9D0046F8  00621821   ADDU V1, V1, V0
9D0046FC  3C02A000   LUI V0, -24576
9D004700  24442CDC   ADDIU A0, V0, 11484
9D004704  24020030   ADDIU V0, ZERO, 48
9D004708  72021002   MUL V0, S0, V0
9D00470C  00821021   ADDU V0, A0, V0
9D004710  AC43001C   SW V1, 28(V0)
3070:                	}
3071:                	
3072:                
3073:                	header.SourcePort			= MyTCB.localPort.Val;
9D004714  3C02A000   LUI V0, -24576
9D004718  24422E8C   ADDIU V0, V0, 11916
9D00471C  94420012   LHU V0, 18(V0)
9D004720  A7C20020   SH V0, 32(S8)
3074:                	header.DestPort				= MyTCB.remotePort.Val;
9D004724  3C02A000   LUI V0, -24576
9D004728  24422E8C   ADDIU V0, V0, 11916
9D00472C  94420010   LHU V0, 16(V0)
9D004730  A7C20022   SH V0, 34(S8)
3075:                	header.SeqNumber			= MyTCB.MySEQ;
9D004734  3C02A000   LUI V0, -24576
9D004738  24422E8C   ADDIU V0, V0, 11916
9D00473C  8C420004   LW V0, 4(V0)
9D004740  AFC20024   SW V0, 36(S8)
3076:                	header.AckNumber			= MyTCB.RemoteSEQ;
9D004744  3C02A000   LUI V0, -24576
9D004748  24422E8C   ADDIU V0, V0, 11916
9D00474C  8C420008   LW V0, 8(V0)
9D004750  AFC20028   SW V0, 40(S8)
3077:                	header.Flags.bits.Reserved2	= 0;
9D004754  8FC2002C   LW V0, 44(S8)
9D004758  7C027B84   INS V0, ZERO, 14, 2
9D00475C  AFC2002C   SW V0, 44(S8)
3078:                	header.DataOffset.Reserved3	= 0;
9D004760  8FC2002C   LW V0, 44(S8)
9D004764  7C021804   INS V0, ZERO, 0, 4
9D004768  AFC2002C   SW V0, 44(S8)
3079:                	header.Flags.byte			= vTCPFlags;
9D00476C  93C20058   LBU V0, 88(S8)
9D004770  A3C2002D   SB V0, 45(S8)
3080:                	header.UrgentPointer        = 0;
9D004774  A7C00032   SH ZERO, 50(S8)
3081:                
3082:                	// Update our send sequence number and ensure retransmissions 
3083:                	// of SYNs and FINs use the right sequence number
3084:                	MyTCB.MySEQ += (DWORD)len;
9D004778  3C02A000   LUI V0, -24576
9D00477C  24422E8C   ADDIU V0, V0, 11916
9D004780  8C430004   LW V1, 4(V0)
9D004784  97C20018   LHU V0, 24(S8)
9D004788  00621821   ADDU V1, V1, V0
9D00478C  3C02A000   LUI V0, -24576
9D004790  24422E8C   ADDIU V0, V0, 11916
9D004794  AC430004   SW V1, 4(V0)
3085:                	if(vTCPFlags & SYN)
9D004798  93C20058   LBU V0, 88(S8)
9D00479C  30420002   ANDI V0, V0, 2
9D0047A0  1040001F   BEQ V0, ZERO, 0x9D004820
9D0047A4  00000000   NOP
3086:                	{
3087:                		// SEG.ACK needs to be zero for the first SYN packet for compatibility 
3088:                		// with certain paranoid TCP/IP stacks, even though the ACK flag isn't 
3089:                		// set (indicating that the AckNumber field is unused).
3090:                		if(!(vTCPFlags & ACK))
9D0047A8  93C20058   LBU V0, 88(S8)
9D0047AC  30420010   ANDI V0, V0, 16
9D0047B0  14400002   BNE V0, ZERO, 0x9D0047BC
9D0047B4  00000000   NOP
3091:                			header.AckNumber = 0x00000000;
9D0047B8  AFC00028   SW ZERO, 40(S8)
3092:                
3093:                		if(MyTCB.flags.bSYNSent)
9D0047BC  3C02A000   LUI V0, -24576
9D0047C0  24422E8C   ADDIU V0, V0, 11916
9D0047C4  8C430024   LW V1, 36(V0)
9D0047C8  3C020002   LUI V0, 2
9D0047CC  00621024   AND V0, V1, V0
9D0047D0  10400006   BEQ V0, ZERO, 0x9D0047EC
9D0047D4  00000000   NOP
3094:                			header.SeqNumber--;
9D0047D8  8FC20024   LW V0, 36(S8)
9D0047DC  2442FFFF   ADDIU V0, V0, -1
9D0047E0  AFC20024   SW V0, 36(S8)
9D0047E4  0B401208   J 0x9D004820
9D0047E8  00000000   NOP
3095:                		else
3096:                		{
3097:                			MyTCB.MySEQ++;
9D0047EC  3C02A000   LUI V0, -24576
9D0047F0  24422E8C   ADDIU V0, V0, 11916
9D0047F4  8C420004   LW V0, 4(V0)
9D0047F8  24430001   ADDIU V1, V0, 1
9D0047FC  3C02A000   LUI V0, -24576
9D004800  24422E8C   ADDIU V0, V0, 11916
9D004804  AC430004   SW V1, 4(V0)
3098:                			MyTCB.flags.bSYNSent = 1;
9D004808  3C02A000   LUI V0, -24576
9D00480C  24432E8C   ADDIU V1, V0, 11916
9D004810  8C620024   LW V0, 36(V1)
9D004814  24040001   ADDIU A0, ZERO, 1
9D004818  7C828C44   INS V0, A0, 17, 1
9D00481C  AC620024   SW V0, 36(V1)
3099:                		}
3100:                	}
3101:                	if(vTCPFlags & FIN)
9D004820  93C20058   LBU V0, 88(S8)
9D004824  30420001   ANDI V0, V0, 1
9D004828  304200FF   ANDI V0, V0, 255
9D00482C  10400007   BEQ V0, ZERO, 0x9D00484C
9D004830  00000000   NOP
3102:                	{
3103:                        MyTCB.flags.bFINSent = 1;   // do not advance the seq no for FIN!
9D004834  3C02A000   LUI V0, -24576
9D004838  24432E8C   ADDIU V1, V0, 11916
9D00483C  8C620024   LW V0, 36(V1)
9D004840  24040001   ADDIU A0, ZERO, 1
9D004844  7C828404   INS V0, A0, 16, 1
9D004848  AC620024   SW V0, 36(V1)
3104:                	}
3105:                
3106:                	// Calculate the amount of free space in the RX buffer area of this socket
3107:                	if(MyTCBStub.rxHead >= MyTCBStub.rxTail)
9D00484C  93828027   LBU V0, -32729(GP)
9D004850  00402021   ADDU A0, V0, ZERO
9D004854  3C02A000   LUI V0, -24576
9D004858  24432CDC   ADDIU V1, V0, 11484
9D00485C  24020030   ADDIU V0, ZERO, 48
9D004860  70821002   MUL V0, A0, V0
9D004864  00621021   ADDU V0, V1, V0
9D004868  8C430014   LW V1, 20(V0)
9D00486C  93828027   LBU V0, -32729(GP)
9D004870  00402821   ADDU A1, V0, ZERO
9D004874  3C02A000   LUI V0, -24576
9D004878  24040030   ADDIU A0, ZERO, 48
9D00487C  70A42002   MUL A0, A1, A0
9D004880  24422CDC   ADDIU V0, V0, 11484
9D004884  00821021   ADDU V0, A0, V0
9D004888  8C420018   LW V0, 24(V0)
9D00488C  0062102B   SLTU V0, V1, V0
9D004890  1440002E   BNE V0, ZERO, 0x9D00494C
9D004894  00000000   NOP
3108:                		header.Window = (MyTCBStub.bufferEnd - MyTCBStub.bufferRxStart) - (MyTCBStub.rxHead - MyTCBStub.rxTail);
9D004898  93828027   LBU V0, -32729(GP)
9D00489C  00402021   ADDU A0, V0, ZERO
9D0048A0  3C02A000   LUI V0, -24576
9D0048A4  24030030   ADDIU V1, ZERO, 48
9D0048A8  70831802   MUL V1, A0, V1
9D0048AC  24422CDC   ADDIU V0, V0, 11484
9D0048B0  00621021   ADDU V0, V1, V0
9D0048B4  8C420008   LW V0, 8(V0)
9D0048B8  3043FFFF   ANDI V1, V0, -1
9D0048BC  93828027   LBU V0, -32729(GP)
9D0048C0  00402821   ADDU A1, V0, ZERO
9D0048C4  3C02A000   LUI V0, -24576
9D0048C8  24442CDC   ADDIU A0, V0, 11484
9D0048CC  24020030   ADDIU V0, ZERO, 48
9D0048D0  70A21002   MUL V0, A1, V0
9D0048D4  00821021   ADDU V0, A0, V0
9D0048D8  8C420004   LW V0, 4(V0)
9D0048DC  3042FFFF   ANDI V0, V0, -1
9D0048E0  00621023   SUBU V0, V1, V0
9D0048E4  3043FFFF   ANDI V1, V0, -1
9D0048E8  93828027   LBU V0, -32729(GP)
9D0048EC  00402821   ADDU A1, V0, ZERO
9D0048F0  3C02A000   LUI V0, -24576
9D0048F4  24040030   ADDIU A0, ZERO, 48
9D0048F8  70A42002   MUL A0, A1, A0
9D0048FC  24422CDC   ADDIU V0, V0, 11484
9D004900  00821021   ADDU V0, A0, V0
9D004904  8C420018   LW V0, 24(V0)
9D004908  3044FFFF   ANDI A0, V0, -1
9D00490C  93828027   LBU V0, -32729(GP)
9D004910  00403021   ADDU A2, V0, ZERO
9D004914  3C02A000   LUI V0, -24576
9D004918  24452CDC   ADDIU A1, V0, 11484
9D00491C  24020030   ADDIU V0, ZERO, 48
9D004920  70C21002   MUL V0, A2, V0
9D004924  00A21021   ADDU V0, A1, V0
9D004928  8C420014   LW V0, 20(V0)
9D00492C  3042FFFF   ANDI V0, V0, -1
9D004930  00821023   SUBU V0, A0, V0
9D004934  3042FFFF   ANDI V0, V0, -1
9D004938  00621021   ADDU V0, V1, V0
9D00493C  3042FFFF   ANDI V0, V0, -1
9D004940  A7C2002E   SH V0, 46(S8)
9D004944  0B40126A   J 0x9D0049A8
9D004948  00000000   NOP
3109:                	else
3110:                		header.Window = MyTCBStub.rxTail - MyTCBStub.rxHead - 1;
9D00494C  93828027   LBU V0, -32729(GP)
9D004950  00402021   ADDU A0, V0, ZERO
9D004954  3C02A000   LUI V0, -24576
9D004958  24030030   ADDIU V1, ZERO, 48
9D00495C  70831802   MUL V1, A0, V1
9D004960  24422CDC   ADDIU V0, V0, 11484
9D004964  00621021   ADDU V0, V1, V0
9D004968  8C420018   LW V0, 24(V0)
9D00496C  3043FFFF   ANDI V1, V0, -1
9D004970  93828027   LBU V0, -32729(GP)
9D004974  00402821   ADDU A1, V0, ZERO
9D004978  3C02A000   LUI V0, -24576
9D00497C  24442CDC   ADDIU A0, V0, 11484
9D004980  24020030   ADDIU V0, ZERO, 48
9D004984  70A21002   MUL V0, A1, V0
9D004988  00821021   ADDU V0, A0, V0
9D00498C  8C420014   LW V0, 20(V0)
9D004990  3042FFFF   ANDI V0, V0, -1
9D004994  00621023   SUBU V0, V1, V0
9D004998  3042FFFF   ANDI V0, V0, -1
9D00499C  2442FFFF   ADDIU V0, V0, -1
9D0049A0  3042FFFF   ANDI V0, V0, -1
9D0049A4  A7C2002E   SH V0, 46(S8)
3111:                
3112:                	// Calculate the amount of free space in the MAC RX buffer area and adjust window if needed
3113:                	wVal.Val = MACGetFreeRxSize();
9D0049A8  0F4072B5   JAL MACGetFreeRxSize
9D0049AC  00000000   NOP
9D0049B0  A7C2001C   SH V0, 28(S8)
3114:                	if(wVal.Val < 64)
9D0049B4  97C2001C   LHU V0, 28(S8)
9D0049B8  2C420040   SLTIU V0, V0, 64
9D0049BC  10400004   BEQ V0, ZERO, 0x9D0049D0
9D0049C0  00000000   NOP
3115:                    {
3116:                		wVal.Val = 0;
9D0049C4  A7C0001C   SH ZERO, 28(S8)
9D0049C8  0B401278   J 0x9D0049E0
9D0049CC  00000000   NOP
3117:                    }
3118:                    else
3119:                    {
3120:                		wVal.Val -= 64;
9D0049D0  97C2001C   LHU V0, 28(S8)
9D0049D4  2442FFC0   ADDIU V0, V0, -64
9D0049D8  3042FFFF   ANDI V0, V0, -1
9D0049DC  A7C2001C   SH V0, 28(S8)
3121:                    }
3122:                	// Force the remote node to throttle back if we are running low on general RX buffer space
3123:                	if(header.Window > wVal.Val)
9D0049E0  97C3002E   LHU V1, 46(S8)
9D0049E4  97C2001C   LHU V0, 28(S8)
9D0049E8  0043102B   SLTU V0, V0, V1
9D0049EC  10400003   BEQ V0, ZERO, 0x9D0049FC
9D0049F0  00000000   NOP
3124:                		header.Window = wVal.Val;
9D0049F4  97C2001C   LHU V0, 28(S8)
9D0049F8  A7C2002E   SH V0, 46(S8)
3125:                
3126:                	SwapTCPHeader(&header);
9D0049FC  27C20020   ADDIU V0, S8, 32
9D004A00  00402021   ADDU A0, V0, ZERO
9D004A04  0F401468   JAL SwapTCPHeader
9D004A08  00000000   NOP
3127:                
3128:                
3129:                	len += sizeof(header);
9D004A0C  97C20018   LHU V0, 24(S8)
9D004A10  24420014   ADDIU V0, V0, 20
9D004A14  A7C20018   SH V0, 24(S8)
3130:                	header.DataOffset.Val   = sizeof(header) >> 2;
9D004A18  8FC2002C   LW V0, 44(S8)
9D004A1C  24030005   ADDIU V1, ZERO, 5
9D004A20  7C623904   INS V0, V1, 4, 4
9D004A24  AFC2002C   SW V0, 44(S8)
3131:                
3132:                	// Insert the MSS (Maximum Segment Size) TCP option if this is SYN packet
3133:                	if(vTCPFlags & SYN)
9D004A28  93C20058   LBU V0, 88(S8)
9D004A2C  30420002   ANDI V0, V0, 2
9D004A30  10400014   BEQ V0, ZERO, 0x9D004A84
9D004A34  00000000   NOP
3134:                	{
3135:                		len += sizeof(options);
9D004A38  97C20018   LHU V0, 24(S8)
9D004A3C  24420004   ADDIU V0, V0, 4
9D004A40  A7C20018   SH V0, 24(S8)
3136:                		options.Kind = TCP_OPTIONS_MAX_SEG_SIZE;
9D004A44  24020002   ADDIU V0, ZERO, 2
9D004A48  A3C20034   SB V0, 52(S8)
3137:                		options.Length = 0x04;
9D004A4C  24020004   ADDIU V0, ZERO, 4
9D004A50  A3C20035   SB V0, 53(S8)
3138:                
3139:                		// Load MSS and swap to big endian
3140:                		options.MaxSegSize.Val = (((TCP_MAX_SEG_SIZE_RX)&0x00FF)<<8) | (((TCP_MAX_SEG_SIZE_RX)&0xFF00)>>8);
9D004A54  24021802   ADDIU V0, ZERO, 6146
9D004A58  A7C20036   SH V0, 54(S8)
3141:                
3142:                		header.DataOffset.Val   += sizeof(options) >> 2;
9D004A5C  8FC2002C   LW V0, 44(S8)
9D004A60  7C421900   EXT V0, V0, 4, 4
9D004A64  304200FF   ANDI V0, V0, 255
9D004A68  24420001   ADDIU V0, V0, 1
9D004A6C  304200FF   ANDI V0, V0, 255
9D004A70  3042000F   ANDI V0, V0, 15
9D004A74  304300FF   ANDI V1, V0, 255
9D004A78  8FC2002C   LW V0, 44(S8)
9D004A7C  7C623904   INS V0, V1, 4, 4
9D004A80  AFC2002C   SW V0, 44(S8)
3143:                	}
3144:                
3145:                	// Calculate IP pseudoheader checksum.
3146:                	pseudoHeader.SourceAddress	= AppConfig.MyIPAddr;
9D004A84  3C02A000   LUI V0, -24576
9D004A88  24430728   ADDIU V1, V0, 1832
9D004A8C  88630003   LWL V1, 3(V1)
9D004A90  00602021   ADDU A0, V1, ZERO
9D004A94  98440728   LWR A0, 1832(V0)
9D004A98  00801021   ADDU V0, A0, ZERO
9D004A9C  AFC20038   SW V0, 56(S8)
3147:                	pseudoHeader.DestAddress    = MyTCB.remote.niRemoteMACIP.IPAddr;
9D004AA0  3C02A000   LUI V0, -24576
9D004AA4  24422E8C   ADDIU V0, V0, 11916
9D004AA8  8C420018   LW V0, 24(V0)
9D004AAC  AFC2003C   SW V0, 60(S8)
3148:                	pseudoHeader.Zero           = 0x0;
9D004AB0  A3C00040   SB ZERO, 64(S8)
3149:                	pseudoHeader.Protocol       = IP_PROT_TCP;
9D004AB4  24020006   ADDIU V0, ZERO, 6
9D004AB8  A3C20041   SB V0, 65(S8)
3150:                	pseudoHeader.Length			= len;
9D004ABC  97C20018   LHU V0, 24(S8)
9D004AC0  A7C20042   SH V0, 66(S8)
3151:                	SwapPseudoHeader(pseudoHeader);
9D004AC4  97C20042   LHU V0, 66(S8)
9D004AC8  00402021   ADDU A0, V0, ZERO
9D004ACC  0F409A16   JAL swaps
9D004AD0  00000000   NOP
9D004AD4  A7C20042   SH V0, 66(S8)
3152:                	header.Checksum = ~CalcIPChecksum((BYTE*)&pseudoHeader, sizeof(pseudoHeader));
9D004AD8  27C20038   ADDIU V0, S8, 56
9D004ADC  00402021   ADDU A0, V0, ZERO
9D004AE0  2405000C   ADDIU A1, ZERO, 12
9D004AE4  0F409A63   JAL CalcIPChecksum
9D004AE8  00000000   NOP
9D004AEC  00021027   NOR V0, ZERO, V0
9D004AF0  3042FFFF   ANDI V0, V0, -1
9D004AF4  A7C20030   SH V0, 48(S8)
3153:                
3154:                	// Write IP header
3155:                	MACSetWritePtr(BASE_TX_ADDR + sizeof(ETHER_HEADER));
9D004AF8  2404000E   ADDIU A0, ZERO, 14
9D004AFC  0F407410   JAL MACSetWritePtr
9D004B00  00000000   NOP
3156:                	IPPutHeader(&MyTCB.remote.niRemoteMACIP, IP_PROT_TCP, len);
9D004B04  97C20018   LHU V0, 24(S8)
9D004B08  3C03A000   LUI V1, -24576
9D004B0C  24642EA4   ADDIU A0, V1, 11940
9D004B10  24050006   ADDIU A1, ZERO, 6
9D004B14  00403021   ADDU A2, V0, ZERO
9D004B18  0F40CEA6   JAL IPPutHeader
9D004B1C  00000000   NOP
3157:                	MACPutArray((BYTE*)&header, sizeof(header));
9D004B20  27C20020   ADDIU V0, S8, 32
9D004B24  00402021   ADDU A0, V0, ZERO
9D004B28  24050014   ADDIU A1, ZERO, 20
9D004B2C  0F40759D   JAL MACPutArray
9D004B30  00000000   NOP
3158:                	if(vTCPFlags & SYN)
9D004B34  93C20058   LBU V0, 88(S8)
9D004B38  30420002   ANDI V0, V0, 2
9D004B3C  10400006   BEQ V0, ZERO, 0x9D004B58
9D004B40  00000000   NOP
3159:                		MACPutArray((BYTE*)&options, sizeof(options));
9D004B44  27C20034   ADDIU V0, S8, 52
9D004B48  00402021   ADDU A0, V0, ZERO
9D004B4C  24050004   ADDIU A1, ZERO, 4
9D004B50  0F40759D   JAL MACPutArray
9D004B54  00000000   NOP
3160:                
3161:                	// Update the TCP checksum
3162:                	MACSetReadPtr(BASE_TX_ADDR + sizeof(ETHER_HEADER) + sizeof(IP_HEADER));
9D004B58  24040022   ADDIU A0, ZERO, 34
9D004B5C  0F407426   JAL MACSetReadPtr
9D004B60  00000000   NOP
3163:                	wVal.Val = CalcIPBufferChecksum(len);
9D004B64  97C20018   LHU V0, 24(S8)
9D004B68  00402021   ADDU A0, V0, ZERO
9D004B6C  0F40748E   JAL CalcIPBufferChecksum
9D004B70  00000000   NOP
9D004B74  A7C2001C   SH V0, 28(S8)
3164:                #if defined(DEBUG_GENERATE_TX_LOSS)
3165:                	// Damage TCP checksums on TX packets randomly
3166:                	if(LFSRRand() > DEBUG_GENERATE_TX_LOSS)
3167:                	{
3168:                		wVal.Val++;
3169:                	}
3170:                #endif
3171:                	MACSetWritePtr(BASE_TX_ADDR + sizeof(ETHER_HEADER) + sizeof(IP_HEADER) + 16);
9D004B78  24040032   ADDIU A0, ZERO, 50
9D004B7C  0F407410   JAL MACSetWritePtr
9D004B80  00000000   NOP
3172:                	MACPutArray((BYTE*)&wVal, sizeof(WORD));
9D004B84  27C2001C   ADDIU V0, S8, 28
9D004B88  00402021   ADDU A0, V0, ZERO
9D004B8C  24050002   ADDIU A1, ZERO, 2
9D004B90  0F40759D   JAL MACPutArray
9D004B94  00000000   NOP
3173:                
3174:                	// Physically start the packet transmission over the network
3175:                	MACFlush();
9D004B98  0F4073B4   JAL MACFlush
9D004B9C  00000000   NOP
3176:                }
9D004BA0  03C0E821   ADDU SP, S8, ZERO
9D004BA4  8FBF0054   LW RA, 84(SP)
9D004BA8  8FBE0050   LW S8, 80(SP)
9D004BAC  8FB0004C   LW S0, 76(SP)
9D004BB0  27BD0058   ADDIU SP, SP, 88
9D004BB4  03E00008   JR RA
9D004BB8  00000000   NOP
3177:                
3178:                /*****************************************************************************
3179:                  Function:
3180:                	static BOOL FindMatchingSocket(TCP_HEADER* h, NODE_INFO* remote)
3181:                
3182:                  Summary:
3183:                	Finds a suitable socket for a TCP segment.
3184:                
3185:                  Description:
3186:                	This function searches through the sockets and attempts to match one with
3187:                	a given TCP header and NODE_INFO structure.  If a socket is found, its 
3188:                	index is saved in hCurrentTCP and the associated MyTCBStub and MyTCB are
3189:                	loaded. Otherwise, INVALID_SOCKET is placed in hCurrentTCP.
3190:                	
3191:                  Precondition:
3192:                	TCP is initialized.
3193:                
3194:                  Parameters:
3195:                	h - TCP header to be matched against
3196:                	remote - The remote node who sent this header
3197:                
3198:                  Return Values:
3199:                	TRUE - A match was found and is loaded in hCurrentTCP
3200:                	FALSE - No suitable socket was found and hCurrentTCP is INVALID_SOCKET
3201:                  ***************************************************************************/
3202:                static BOOL FindMatchingSocket(TCP_HEADER* h, NODE_INFO* remote)
3203:                {
9D004BBC  27BDFFD8   ADDIU SP, SP, -40
9D004BC0  AFBF0024   SW RA, 36(SP)
9D004BC4  AFBE0020   SW S8, 32(SP)
9D004BC8  AFB0001C   SW S0, 28(SP)
9D004BCC  03A0F021   ADDU S8, SP, ZERO
9D004BD0  AFC40028   SW A0, 40(S8)
9D004BD4  AFC5002C   SW A1, 44(S8)
3204:                	TCP_SOCKET hTCP;
3205:                	TCP_SOCKET partialMatch;
3206:                	WORD hash;
3207:                
3208:                	// Prevent connections on invalid port 0
3209:                	if(h->DestPort == 0u)
9D004BD8  8FC20028   LW V0, 40(S8)
9D004BDC  94420002   LHU V0, 2(V0)
9D004BE0  14400004   BNE V0, ZERO, 0x9D004BF4
9D004BE4  00000000   NOP
3210:                		return FALSE;
9D004BE8  00001021   ADDU V0, ZERO, ZERO
9D004BEC  0B401461   J 0x9D005184
9D004BF0  00000000   NOP
3211:                
3212:                	partialMatch = INVALID_SOCKET;
9D004BF4  2402FFFE   ADDIU V0, ZERO, -2
9D004BF8  A3C20011   SB V0, 17(S8)
3213:                	hash = (remote->IPAddr.w[1]+remote->IPAddr.w[0] + h->SourcePort) ^ h->DestPort;
9D004BFC  8FC2002C   LW V0, 44(S8)
9D004C00  90430002   LBU V1, 2(V0)
9D004C04  90420003   LBU V0, 3(V0)
9D004C08  00021200   SLL V0, V0, 8
9D004C0C  00431025   OR V0, V0, V1
9D004C10  3043FFFF   ANDI V1, V0, -1
9D004C14  8FC2002C   LW V0, 44(S8)
9D004C18  90440000   LBU A0, 0(V0)
9D004C1C  90420001   LBU V0, 1(V0)
9D004C20  00021200   SLL V0, V0, 8
9D004C24  00441025   OR V0, V0, A0
9D004C28  3042FFFF   ANDI V0, V0, -1
9D004C2C  00621021   ADDU V0, V1, V0
9D004C30  3043FFFF   ANDI V1, V0, -1
9D004C34  8FC20028   LW V0, 40(S8)
9D004C38  94420000   LHU V0, 0(V0)
9D004C3C  00621021   ADDU V0, V1, V0
9D004C40  3042FFFF   ANDI V0, V0, -1
9D004C44  7C021E20   SEH V1, V0
9D004C48  8FC20028   LW V0, 40(S8)
9D004C4C  94420002   LHU V0, 2(V0)
9D004C50  7C021620   SEH V0, V0
9D004C54  00621026   XOR V0, V1, V0
9D004C58  7C021620   SEH V0, V0
9D004C5C  A7C20014   SH V0, 20(S8)
3214:                
3215:                	// Loop through all sockets looking for a socket that is expecting this 
3216:                	// packet or can handle it.
3217:                	for(hTCP = 0; hTCP < TCP_SOCKET_COUNT; hTCP++ )
9D004C60  A3C00010   SB ZERO, 16(S8)
9D004C64  0B401373   J 0x9D004DCC
9D004C68  00000000   NOP
9D004DC0  93C20010   LBU V0, 16(S8)
9D004DC4  24420001   ADDIU V0, V0, 1
9D004DC8  A3C20010   SB V0, 16(S8)
9D004DCC  93C20010   LBU V0, 16(S8)
9D004DD0  2C420009   SLTIU V0, V0, 9
9D004DD4  1440FFA5   BNE V0, ZERO, 0x9D004C6C
9D004DD8  00000000   NOP
3218:                	{
3219:                		SyncTCBStub(hTCP);
9D004C6C  93C20010   LBU V0, 16(S8)
9D004C70  A3828027   SB V0, -32729(GP)
3220:                
3221:                		if(MyTCBStub.smState == TCP_CLOSED)
9D004C74  93828027   LBU V0, -32729(GP)
9D004C78  00402021   ADDU A0, V0, ZERO
9D004C7C  3C02A000   LUI V0, -24576
9D004C80  24432CDC   ADDIU V1, V0, 11484
9D004C84  24020030   ADDIU V0, ZERO, 48
9D004C88  70821002   MUL V0, A0, V0
9D004C8C  00621021   ADDU V0, V1, V0
9D004C90  8C430024   LW V1, 36(V0)
9D004C94  2402000D   ADDIU V0, ZERO, 13
9D004C98  10620042   BEQ V1, V0, 0x9D004DA4
9D004C9C  00000000   NOP
3222:                		{
3223:                			continue;
9D004DA4  00000000   NOP
9D004DA8  0B401370   J 0x9D004DC0
9D004DAC  00000000   NOP
3224:                		}
3225:                		else if(MyTCBStub.smState == TCP_LISTEN)
9D004CA0  93828027   LBU V0, -32729(GP)
9D004CA4  00402021   ADDU A0, V0, ZERO
9D004CA8  3C02A000   LUI V0, -24576
9D004CAC  24432CDC   ADDIU V1, V0, 11484
9D004CB0  24020030   ADDIU V0, ZERO, 48
9D004CB4  70821002   MUL V0, A0, V0
9D004CB8  00621021   ADDU V0, V1, V0
9D004CBC  8C430024   LW V1, 36(V0)
9D004CC0  24020004   ADDIU V0, ZERO, 4
9D004CC4  14620011   BNE V1, V0, 0x9D004D0C
9D004CC8  00000000   NOP
3226:                		{// For listening ports, check if this is the correct port
3227:                			if(MyTCBStub.remoteHash.Val == h->DestPort)
9D004CCC  93828027   LBU V0, -32729(GP)
9D004CD0  00402021   ADDU A0, V0, ZERO
9D004CD4  3C02A000   LUI V0, -24576
9D004CD8  24030030   ADDIU V1, ZERO, 48
9D004CDC  70831802   MUL V1, A0, V1
9D004CE0  24422CDC   ADDIU V0, V0, 11484
9D004CE4  00621021   ADDU V0, V1, V0
9D004CE8  9443002A   LHU V1, 42(V0)
9D004CEC  8FC20028   LW V0, 40(S8)
9D004CF0  94420002   LHU V0, 2(V0)
9D004CF4  1462002E   BNE V1, V0, 0x9D004DB0
9D004CF8  00000000   NOP
3228:                				partialMatch = hTCP;
9D004CFC  93C20010   LBU V0, 16(S8)
9D004D00  A3C20011   SB V0, 17(S8)
3229:                			
3230:                			#if defined(STACK_USE_SSL_SERVER)
3231:                			// Check the SSL port as well for SSL Servers
3232:                			// 0 is defined as an invalid port number
3233:                			if(MyTCBStub.sslTxHead == h->DestPort)
3234:                				partialMatch = hTCP;
3235:                			#endif
3236:                			
3237:                			continue;
9D004D04  0B401370   J 0x9D004DC0
9D004D08  00000000   NOP
9D004DB0  00000000   NOP
9D004DB4  0B401370   J 0x9D004DC0
9D004DB8  00000000   NOP
3238:                		}
3239:                		else if(MyTCBStub.remoteHash.Val != hash)
9D004D0C  93828027   LBU V0, -32729(GP)
9D004D10  00402021   ADDU A0, V0, ZERO
9D004D14  3C02A000   LUI V0, -24576
9D004D18  24030030   ADDIU V1, ZERO, 48
9D004D1C  70831802   MUL V1, A0, V1
9D004D20  24422CDC   ADDIU V0, V0, 11484
9D004D24  00621021   ADDU V0, V1, V0
9D004D28  9442002A   LHU V0, 42(V0)
9D004D2C  97C30014   LHU V1, 20(S8)
9D004D30  14620022   BNE V1, V0, 0x9D004DBC
9D004D34  00000000   NOP
3240:                		{// Ignore if the hash doesn't match
3241:                			continue;
9D004DBC  00000000   NOP
3242:                		}
3243:                
3244:                		SyncTCB();
9D004D38  0F400008   JAL SyncTCB
9D004D3C  00000000   NOP
3245:                		if(	h->DestPort == MyTCB.localPort.Val &&
9D004D40  8FC20028   LW V0, 40(S8)
9D004D44  94430002   LHU V1, 2(V0)
9D004D48  3C02A000   LUI V0, -24576
9D004D4C  24422E8C   ADDIU V0, V0, 11916
9D004D50  94420012   LHU V0, 18(V0)
9D004D54  1462001A   BNE V1, V0, 0x9D004DC0
9D004D58  00000000   NOP
9D004D70  14620013   BNE V1, V0, 0x9D004DC0
9D004D74  00000000   NOP
3246:                			h->SourcePort == MyTCB.remotePort.Val &&
9D004D5C  8FC20028   LW V0, 40(S8)
9D004D60  94430000   LHU V1, 0(V0)
9D004D64  3C02A000   LUI V0, -24576
9D004D68  24422E8C   ADDIU V0, V0, 11916
9D004D6C  94420010   LHU V0, 16(V0)
9D004D90  1462000B   BNE V1, V0, 0x9D004DC0
9D004D94  00000000   NOP
3247:                			remote->IPAddr.Val == MyTCB.remote.niRemoteMACIP.IPAddr.Val)
9D004D78  8FC2002C   LW V0, 44(S8)
9D004D7C  88430003   LWL V1, 3(V0)
9D004D80  98430000   LWR V1, 0(V0)
9D004D84  3C02A000   LUI V0, -24576
9D004D88  24422E8C   ADDIU V0, V0, 11916
9D004D8C  8C420018   LW V0, 24(V0)
3248:                		{
3249:                			return TRUE;
9D004D98  24020001   ADDIU V0, ZERO, 1
9D004D9C  0B401461   J 0x9D005184
9D004DA0  00000000   NOP
3250:                		}
3251:                	}
3252:                
3253:                
3254:                	// If there is a partial match, then a listening socket is currently 
3255:                	// available.  Set up the extended TCB with the info needed 
3256:                	// to establish a connection and return this socket to the 
3257:                	// caller.
3258:                	if(partialMatch != INVALID_SOCKET)
9D004DDC  93C30011   LBU V1, 17(S8)
9D004DE0  240200FE   ADDIU V0, ZERO, 254
9D004DE4  10620030   BEQ V1, V0, 0x9D004EA8
9D004DE8  00000000   NOP
3259:                	{
3260:                		SyncTCBStub(partialMatch);
9D004DEC  93C20011   LBU V0, 17(S8)
9D004DF0  A3828027   SB V0, -32729(GP)
3261:                		SyncTCB();
9D004DF4  0F400008   JAL SyncTCB
9D004DF8  00000000   NOP
3262:                	
3263:                		// For SSL ports, begin the SSL Handshake
3264:                		#if defined(STACK_USE_SSL_SERVER)
3265:                		if(MyTCBStub.sslTxHead == h->DestPort)
3266:                		{
3267:                			// Try to start an SSL session.  If no stubs are available,
3268:                			// we can't service this request right now, so ignore it.
3269:                			if(!TCPStartSSLServer(partialMatch))
3270:                				partialMatch = INVALID_SOCKET;
3271:                		}
3272:                		#endif
3273:                	
3274:                		// Make sure the above check didn't fail (this is unfortunately 
3275:                		// redundant for non-SSL sockets).  Otherwise, fall out to below
3276:                		// and add to the SYN queue.
3277:                		if(partialMatch != INVALID_SOCKET)
9D004DFC  93C30011   LBU V1, 17(S8)
9D004E00  240200FE   ADDIU V0, ZERO, 254
9D004E04  10620028   BEQ V1, V0, 0x9D004EA8
9D004E08  00000000   NOP
3278:                		{
3279:                			MyTCBStub.remoteHash.Val = hash;
9D004E0C  93828027   LBU V0, -32729(GP)
9D004E10  00402021   ADDU A0, V0, ZERO
9D004E14  3C02A000   LUI V0, -24576
9D004E18  24030030   ADDIU V1, ZERO, 48
9D004E1C  70831802   MUL V1, A0, V1
9D004E20  24422CDC   ADDIU V0, V0, 11484
9D004E24  00621021   ADDU V0, V1, V0
9D004E28  97C30014   LHU V1, 20(S8)
9D004E2C  A443002A   SH V1, 42(V0)
3280:                		
3281:                			memcpy((void*)&MyTCB.remote, (void*)remote, sizeof(NODE_INFO));
9D004E30  3C02A000   LUI V0, -24576
9D004E34  24442EA4   ADDIU A0, V0, 11940
9D004E38  8FC5002C   LW A1, 44(S8)
9D004E3C  2406000A   ADDIU A2, ZERO, 10
9D004E40  0F40D298   JAL 0x9D034A60
9D004E44  00000000   NOP
3282:                			MyTCB.remotePort.Val = h->SourcePort;
9D004E48  8FC20028   LW V0, 40(S8)
9D004E4C  94430000   LHU V1, 0(V0)
9D004E50  3C02A000   LUI V0, -24576
9D004E54  24422E8C   ADDIU V0, V0, 11916
9D004E58  A4430010   SH V1, 16(V0)
3283:                			MyTCB.localPort.Val = h->DestPort;
9D004E5C  8FC20028   LW V0, 40(S8)
9D004E60  94430002   LHU V1, 2(V0)
9D004E64  3C02A000   LUI V0, -24576
9D004E68  24422E8C   ADDIU V0, V0, 11916
9D004E6C  A4430012   SH V1, 18(V0)
3284:                			MyTCB.txUnackedTail	= MyTCBStub.bufferTxStart;
9D004E70  93828027   LBU V0, -32729(GP)
9D004E74  00402021   ADDU A0, V0, ZERO
9D004E78  3C02A000   LUI V0, -24576
9D004E7C  24030030   ADDIU V1, ZERO, 48
9D004E80  70831802   MUL V1, A0, V1
9D004E84  24422CDC   ADDIU V0, V0, 11484
9D004E88  00621021   ADDU V0, V1, V0
9D004E8C  8C430000   LW V1, 0(V0)
9D004E90  3C02A000   LUI V0, -24576
9D004E94  24422E8C   ADDIU V0, V0, 11916
9D004E98  AC43000C   SW V1, 12(V0)
3285:                		
3286:                			// All done, and we have a match
3287:                			return TRUE;
9D004E9C  24020001   ADDIU V0, ZERO, 1
9D004EA0  0B401461   J 0x9D005184
9D004EA4  00000000   NOP
3288:                		}
3289:                	}
3290:                
3291:                	// No available sockets are listening on this port.  (Or, for
3292:                	// SSL requests, perhaps no SSL sessions were available.  However,
3293:                	// there may be a server socket which is currently busy but 
3294:                	// could handle this packet, so we should check.
3295:                	#if TCP_SYN_QUEUE_MAX_ENTRIES
3296:                	{
3297:                		WORD wQueueInsertPos;
3298:                		
3299:                		// See if this is a SYN packet
3300:                		if(!h->Flags.bits.flagSYN)
9D004EA8  8FC20028   LW V0, 40(S8)
9D004EAC  8C42000C   LW V0, 12(V0)
9D004EB0  30420200   ANDI V0, V0, 512
9D004EB4  14400004   BNE V0, ZERO, 0x9D004EC8
9D004EB8  00000000   NOP
3301:                			return FALSE;
9D004EBC  00001021   ADDU V0, ZERO, ZERO
9D004EC0  0B401461   J 0x9D005184
9D004EC4  00000000   NOP
3302:                
3303:                		// See if there is space in our SYN queue
3304:                		if(SYNQueue[TCP_SYN_QUEUE_MAX_ENTRIES-1].wDestPort)
9D004EC8  3C02A000   LUI V0, -24576
9D004ECC  24422EB8   ADDIU V0, V0, 11960
9D004ED0  94420038   LHU V0, 56(V0)
9D004ED4  10400004   BEQ V0, ZERO, 0x9D004EE8
9D004ED8  00000000   NOP
3305:                			return FALSE;
9D004EDC  00001021   ADDU V0, ZERO, ZERO
9D004EE0  0B401461   J 0x9D005184
9D004EE4  00000000   NOP
3306:                		
3307:                		// See if we have this SYN already in our SYN queue.
3308:                		// If not already in the queue, find out where we 
3309:                		// should insert this SYN to the queue
3310:                		for(wQueueInsertPos = 0; wQueueInsertPos < TCP_SYN_QUEUE_MAX_ENTRIES; wQueueInsertPos++)
9D004EE8  A7C00012   SH ZERO, 18(S8)
9D004EEC  0B401401   J 0x9D005004
9D004EF0  00000000   NOP
9D004FF8  97C20012   LHU V0, 18(S8)
9D004FFC  24420001   ADDIU V0, V0, 1
9D005000  A7C20012   SH V0, 18(S8)
9D005004  97C20012   LHU V0, 18(S8)
9D005008  2C420003   SLTIU V0, V0, 3
9D00500C  1440FFB9   BNE V0, ZERO, 0x9D004EF4
9D005010  00000000   NOP
9D005014  0B401408   J 0x9D005020
9D005018  00000000   NOP
3311:                		{
3312:                			// Exit loop if we found a free record
3313:                			if(SYNQueue[wQueueInsertPos].wDestPort == 0u)
9D004EF4  97C40012   LHU A0, 18(S8)
9D004EF8  3C02A000   LUI V0, -24576
9D004EFC  24030014   ADDIU V1, ZERO, 20
9D004F00  70831802   MUL V1, A0, V1
9D004F04  24422EB8   ADDIU V0, V0, 11960
9D004F08  00621021   ADDU V0, V1, V0
9D004F0C  94420010   LHU V0, 16(V0)
9D004F10  10400042   BEQ V0, ZERO, 0x9D00501C
9D004F14  00000000   NOP
3314:                				break;
9D00501C  00000000   NOP
3315:                
3316:                			// Check if this SYN packet is already in the SYN queue
3317:                			if(SYNQueue[wQueueInsertPos].wDestPort != h->DestPort)
9D004F18  97C40012   LHU A0, 18(S8)
9D004F1C  3C02A000   LUI V0, -24576
9D004F20  24030014   ADDIU V1, ZERO, 20
9D004F24  70831802   MUL V1, A0, V1
9D004F28  24422EB8   ADDIU V0, V0, 11960
9D004F2C  00621021   ADDU V0, V1, V0
9D004F30  94430010   LHU V1, 16(V0)
9D004F34  8FC20028   LW V0, 40(S8)
9D004F38  94420002   LHU V0, 2(V0)
9D004F3C  14620027   BNE V1, V0, 0x9D004FDC
9D004F40  00000000   NOP
3318:                				continue;
9D004FDC  00000000   NOP
9D004FE0  0B4013FE   J 0x9D004FF8
9D004FE4  00000000   NOP
3319:                			if(SYNQueue[wQueueInsertPos].wSourcePort != h->SourcePort)
9D004F44  97C40012   LHU A0, 18(S8)
9D004F48  3C02A000   LUI V0, -24576
9D004F4C  24030014   ADDIU V1, ZERO, 20
9D004F50  70831802   MUL V1, A0, V1
9D004F54  24422EB8   ADDIU V0, V0, 11960
9D004F58  00621021   ADDU V0, V1, V0
9D004F5C  9443000A   LHU V1, 10(V0)
9D004F60  8FC20028   LW V0, 40(S8)
9D004F64  94420000   LHU V0, 0(V0)
9D004F68  1462001F   BNE V1, V0, 0x9D004FE8
9D004F6C  00000000   NOP
3320:                				continue;
9D004FE8  00000000   NOP
9D004FEC  0B4013FE   J 0x9D004FF8
9D004FF0  00000000   NOP
3321:                			if(SYNQueue[wQueueInsertPos].niSourceAddress.IPAddr.Val != remote->IPAddr.Val)
9D004F70  97C40012   LHU A0, 18(S8)
9D004F74  3C02A000   LUI V0, -24576
9D004F78  24030014   ADDIU V1, ZERO, 20
9D004F7C  70831802   MUL V1, A0, V1
9D004F80  24422EB8   ADDIU V0, V0, 11960
9D004F84  00621021   ADDU V0, V1, V0
9D004F88  8C430000   LW V1, 0(V0)
9D004F8C  8FC2002C   LW V0, 44(S8)
9D004F90  88440003   LWL A0, 3(V0)
9D004F94  00802821   ADDU A1, A0, ZERO
9D004F98  98450000   LWR A1, 0(V0)
9D004F9C  00A01021   ADDU V0, A1, ZERO
9D004FA0  14620014   BNE V1, V0, 0x9D004FF4
9D004FA4  00000000   NOP
3322:                				continue;
9D004FF4  00000000   NOP
3323:                
3324:                			// SYN matches SYN queue entry.  Update timestamp and do nothing.
3325:                			SYNQueue[wQueueInsertPos].wTimestamp = TickGetDiv256();
9D004FA8  97D00012   LHU S0, 18(S8)
9D004FAC  0F40CDE4   JAL TickGetDiv256
9D004FB0  00000000   NOP
9D004FB4  3043FFFF   ANDI V1, V0, -1
9D004FB8  3C02A000   LUI V0, -24576
9D004FBC  24040014   ADDIU A0, ZERO, 20
9D004FC0  72042002   MUL A0, S0, A0
9D004FC4  24422EB8   ADDIU V0, V0, 11960
9D004FC8  00821021   ADDU V0, A0, V0
9D004FCC  A4430012   SH V1, 18(V0)
3326:                			return FALSE;
9D004FD0  00001021   ADDU V0, ZERO, ZERO
9D004FD4  0B401461   J 0x9D005184
9D004FD8  00000000   NOP
3327:                		}
3328:                		
3329:                		// Check to see if we have any server sockets which 
3330:                		// are currently connected, but could handle this SYN 
3331:                		// request at a later time if the client disconnects.
3332:                		for(hTCP = 0; hTCP < TCP_SOCKET_COUNT; hTCP++)
9D005020  A3C00010   SB ZERO, 16(S8)
9D005024  0B40145C   J 0x9D005170
9D005028  00000000   NOP
9D005164  93C20010   LBU V0, 16(S8)
9D005168  24420001   ADDIU V0, V0, 1
9D00516C  A3C20010   SB V0, 16(S8)
9D005170  93C20010   LBU V0, 16(S8)
9D005174  2C420009   SLTIU V0, V0, 9
9D005178  1440FFAC   BNE V0, ZERO, 0x9D00502C
9D00517C  00000000   NOP
3333:                		{
3334:                			SyncTCBStub(hTCP);
9D00502C  93C20010   LBU V0, 16(S8)
9D005030  A3828027   SB V0, -32729(GP)
3335:                			if(!MyTCBStub.Flags.bServer)
9D005034  93828027   LBU V0, -32729(GP)
9D005038  00402021   ADDU A0, V0, ZERO
9D00503C  3C02A000   LUI V0, -24576
9D005040  24030030   ADDIU V1, ZERO, 48
9D005044  70831802   MUL V1, A0, V1
9D005048  24422CDC   ADDIU V0, V0, 11484
9D00504C  00621021   ADDU V0, V1, V0
9D005050  8C420028   LW V0, 40(V0)
9D005054  7C4200C0   EXT V0, V0, 3, 1
9D005058  304200FF   ANDI V0, V0, 255
9D00505C  1040003D   BEQ V0, ZERO, 0x9D005154
9D005060  00000000   NOP
3336:                				continue;
9D005154  00000000   NOP
9D005158  0B401459   J 0x9D005164
9D00515C  00000000   NOP
3337:                
3338:                			SyncTCB();
9D005064  0F400008   JAL SyncTCB
9D005068  00000000   NOP
3339:                			#if defined(STACK_USE_SSL_SERVER)
3340:                			if((MyTCB.localPort.Val != h->DestPort) && (MyTCB.localSSLPort.Val != h->DestPort))
3341:                			#else
3342:                			if(MyTCB.localPort.Val != h->DestPort)
9D00506C  3C02A000   LUI V0, -24576
9D005070  24422E8C   ADDIU V0, V0, 11916
9D005074  94430012   LHU V1, 18(V0)
9D005078  8FC20028   LW V0, 40(S8)
9D00507C  94420002   LHU V0, 2(V0)
9D005080  14620037   BNE V1, V0, 0x9D005160
9D005084  00000000   NOP
3343:                			#endif
3344:                				continue;
9D005160  00000000   NOP
3345:                
3346:                			// Generate the SYN queue entry
3347:                			memcpy((void*)&SYNQueue[wQueueInsertPos].niSourceAddress, (void*)remote, sizeof(NODE_INFO));
9D005088  97C30012   LHU V1, 18(S8)
9D00508C  24020014   ADDIU V0, ZERO, 20
9D005090  70621802   MUL V1, V1, V0
9D005094  3C02A000   LUI V0, -24576
9D005098  24422EB8   ADDIU V0, V0, 11960
9D00509C  00621021   ADDU V0, V1, V0
9D0050A0  00402021   ADDU A0, V0, ZERO
9D0050A4  8FC5002C   LW A1, 44(S8)
9D0050A8  2406000A   ADDIU A2, ZERO, 10
9D0050AC  0F40D298   JAL 0x9D034A60
9D0050B0  00000000   NOP
3348:                			SYNQueue[wQueueInsertPos].wSourcePort = h->SourcePort;
9D0050B4  97C50012   LHU A1, 18(S8)
9D0050B8  8FC20028   LW V0, 40(S8)
9D0050BC  94430000   LHU V1, 0(V0)
9D0050C0  3C02A000   LUI V0, -24576
9D0050C4  24040014   ADDIU A0, ZERO, 20
9D0050C8  70A42002   MUL A0, A1, A0
9D0050CC  24422EB8   ADDIU V0, V0, 11960
9D0050D0  00821021   ADDU V0, A0, V0
9D0050D4  A443000A   SH V1, 10(V0)
3349:                			SYNQueue[wQueueInsertPos].dwSourceSEQ = h->SeqNumber;
9D0050D8  97C50012   LHU A1, 18(S8)
9D0050DC  8FC20028   LW V0, 40(S8)
9D0050E0  8C430004   LW V1, 4(V0)
9D0050E4  3C02A000   LUI V0, -24576
9D0050E8  24442EB8   ADDIU A0, V0, 11960
9D0050EC  24020014   ADDIU V0, ZERO, 20
9D0050F0  70A21002   MUL V0, A1, V0
9D0050F4  00821021   ADDU V0, A0, V0
9D0050F8  AC43000C   SW V1, 12(V0)
3350:                			SYNQueue[wQueueInsertPos].wDestPort = h->DestPort;
9D0050FC  97C50012   LHU A1, 18(S8)
9D005100  8FC20028   LW V0, 40(S8)
9D005104  94430002   LHU V1, 2(V0)
9D005108  3C02A000   LUI V0, -24576
9D00510C  24040014   ADDIU A0, ZERO, 20
9D005110  70A42002   MUL A0, A1, A0
9D005114  24422EB8   ADDIU V0, V0, 11960
9D005118  00821021   ADDU V0, A0, V0
9D00511C  A4430010   SH V1, 16(V0)
3351:                			SYNQueue[wQueueInsertPos].wTimestamp = TickGetDiv256();
9D005120  97D00012   LHU S0, 18(S8)
9D005124  0F40CDE4   JAL TickGetDiv256
9D005128  00000000   NOP
9D00512C  3043FFFF   ANDI V1, V0, -1
9D005130  3C02A000   LUI V0, -24576
9D005134  24040014   ADDIU A0, ZERO, 20
9D005138  72042002   MUL A0, S0, A0
9D00513C  24422EB8   ADDIU V0, V0, 11960
9D005140  00821021   ADDU V0, A0, V0
9D005144  A4430012   SH V1, 18(V0)
3352:                
3353:                			return FALSE;
9D005148  00001021   ADDU V0, ZERO, ZERO
9D00514C  0B401461   J 0x9D005184
9D005150  00000000   NOP
3354:                		}
3355:                	}
3356:                	#endif
3357:                		
3358:                	return FALSE;
9D005180  00001021   ADDU V0, ZERO, ZERO
3359:                
3360:                }
9D005184  03C0E821   ADDU SP, S8, ZERO
9D005188  8FBF0024   LW RA, 36(SP)
9D00518C  8FBE0020   LW S8, 32(SP)
9D005190  8FB0001C   LW S0, 28(SP)
9D005194  27BD0028   ADDIU SP, SP, 40
9D005198  03E00008   JR RA
9D00519C  00000000   NOP
3361:                
3362:                
3363:                
3364:                /*****************************************************************************
3365:                  Function:
3366:                	static void SwapTCPHeader(TCP_HEADER* header)
3367:                
3368:                  Summary:
3369:                	Swaps endian-ness of a TCP header.
3370:                
3371:                  Description:
3372:                	This function swaps the endian-ness of a given TCP header for comparison.
3373:                
3374:                  Precondition:
3375:                	None
3376:                
3377:                  Parameters:
3378:                	header - The TCP header that is to be swapped
3379:                
3380:                  Returns:
3381:                	None
3382:                  ***************************************************************************/
3383:                static void SwapTCPHeader(TCP_HEADER* header)
3384:                {
9D0051A0  27BDFFE8   ADDIU SP, SP, -24
9D0051A4  AFBF0014   SW RA, 20(SP)
9D0051A8  AFBE0010   SW S8, 16(SP)
9D0051AC  03A0F021   ADDU S8, SP, ZERO
9D0051B0  AFC40018   SW A0, 24(S8)
3385:                	header->SourcePort      = swaps(header->SourcePort);
9D0051B4  8FC20018   LW V0, 24(S8)
9D0051B8  94420000   LHU V0, 0(V0)
9D0051BC  00402021   ADDU A0, V0, ZERO
9D0051C0  0F409A16   JAL swaps
9D0051C4  00000000   NOP
9D0051C8  00401821   ADDU V1, V0, ZERO
9D0051CC  8FC20018   LW V0, 24(S8)
9D0051D0  A4430000   SH V1, 0(V0)
3386:                	header->DestPort        = swaps(header->DestPort);
9D0051D4  8FC20018   LW V0, 24(S8)
9D0051D8  94420002   LHU V0, 2(V0)
9D0051DC  00402021   ADDU A0, V0, ZERO
9D0051E0  0F409A16   JAL swaps
9D0051E4  00000000   NOP
9D0051E8  00401821   ADDU V1, V0, ZERO
9D0051EC  8FC20018   LW V0, 24(S8)
9D0051F0  A4430002   SH V1, 2(V0)
3387:                	header->SeqNumber       = swapl(header->SeqNumber);
9D0051F4  8FC20018   LW V0, 24(S8)
9D0051F8  8C420004   LW V0, 4(V0)
9D0051FC  00402021   ADDU A0, V0, ZERO
9D005200  0F409A29   JAL swapl
9D005204  00000000   NOP
9D005208  00401821   ADDU V1, V0, ZERO
9D00520C  8FC20018   LW V0, 24(S8)
9D005210  AC430004   SW V1, 4(V0)
3388:                	header->AckNumber       = swapl(header->AckNumber);
9D005214  8FC20018   LW V0, 24(S8)
9D005218  8C420008   LW V0, 8(V0)
9D00521C  00402021   ADDU A0, V0, ZERO
9D005220  0F409A29   JAL swapl
9D005224  00000000   NOP
9D005228  00401821   ADDU V1, V0, ZERO
9D00522C  8FC20018   LW V0, 24(S8)
9D005230  AC430008   SW V1, 8(V0)
3389:                	header->Window          = swaps(header->Window);
9D005234  8FC20018   LW V0, 24(S8)
9D005238  9442000E   LHU V0, 14(V0)
9D00523C  00402021   ADDU A0, V0, ZERO
9D005240  0F409A16   JAL swaps
9D005244  00000000   NOP
9D005248  00401821   ADDU V1, V0, ZERO
9D00524C  8FC20018   LW V0, 24(S8)
9D005250  A443000E   SH V1, 14(V0)
3390:                	header->Checksum        = swaps(header->Checksum);
9D005254  8FC20018   LW V0, 24(S8)
9D005258  94420010   LHU V0, 16(V0)
9D00525C  00402021   ADDU A0, V0, ZERO
9D005260  0F409A16   JAL swaps
9D005264  00000000   NOP
9D005268  00401821   ADDU V1, V0, ZERO
9D00526C  8FC20018   LW V0, 24(S8)
9D005270  A4430010   SH V1, 16(V0)
3391:                	header->UrgentPointer   = swaps(header->UrgentPointer);
9D005274  8FC20018   LW V0, 24(S8)
9D005278  94420012   LHU V0, 18(V0)
9D00527C  00402021   ADDU A0, V0, ZERO
9D005280  0F409A16   JAL swaps
9D005284  00000000   NOP
9D005288  00401821   ADDU V1, V0, ZERO
9D00528C  8FC20018   LW V0, 24(S8)
9D005290  A4430012   SH V1, 18(V0)
3392:                }
9D005294  03C0E821   ADDU SP, S8, ZERO
9D005298  8FBF0014   LW RA, 20(SP)
9D00529C  8FBE0010   LW S8, 16(SP)
9D0052A0  27BD0018   ADDIU SP, SP, 24
9D0052A4  03E00008   JR RA
9D0052A8  00000000   NOP
3393:                
3394:                
3395:                
3396:                /*****************************************************************************
3397:                  Function:
3398:                	static void CloseSocket(void)
3399:                
3400:                  Summary:
3401:                	Closes a TCP socket.
3402:                
3403:                  Description:
3404:                	This function closes a TCP socket.  All socket state information is 
3405:                	reset, and any buffered bytes are discarded.  The socket is no longer
3406:                	accessible by the application after this point.
3407:                
3408:                  Precondition:
3409:                	The TCPStub corresponding to the socket to be closed is synced.
3410:                
3411:                  Parameters:
3412:                	None
3413:                
3414:                  Returns:
3415:                	None
3416:                  ***************************************************************************/
3417:                static void CloseSocket(void)
3418:                {
9D0052AC  27BDFFE0   ADDIU SP, SP, -32
9D0052B0  AFBF001C   SW RA, 28(SP)
9D0052B4  AFBE0018   SW S8, 24(SP)
9D0052B8  AFB00014   SW S0, 20(SP)
9D0052BC  03A0F021   ADDU S8, SP, ZERO
3419:                	SyncTCB();
9D0052C0  0F400008   JAL SyncTCB
9D0052C4  00000000   NOP
3420:                
3421:                	MyTCBStub.remoteHash.Val = MyTCB.localPort.Val;
9D0052C8  93828027   LBU V0, -32729(GP)
9D0052CC  00402821   ADDU A1, V0, ZERO
9D0052D0  3C02A000   LUI V0, -24576
9D0052D4  24422E8C   ADDIU V0, V0, 11916
9D0052D8  94430012   LHU V1, 18(V0)
9D0052DC  3C02A000   LUI V0, -24576
9D0052E0  24040030   ADDIU A0, ZERO, 48
9D0052E4  70A42002   MUL A0, A1, A0
9D0052E8  24422CDC   ADDIU V0, V0, 11484
9D0052EC  00821021   ADDU V0, A0, V0
9D0052F0  A443002A   SH V1, 42(V0)
3422:                	MyTCBStub.txHead = MyTCBStub.bufferTxStart;
9D0052F4  93828027   LBU V0, -32729(GP)
9D0052F8  00402821   ADDU A1, V0, ZERO
9D0052FC  93828027   LBU V0, -32729(GP)
9D005300  00402021   ADDU A0, V0, ZERO
9D005304  3C02A000   LUI V0, -24576
9D005308  24030030   ADDIU V1, ZERO, 48
9D00530C  70831802   MUL V1, A0, V1
9D005310  24422CDC   ADDIU V0, V0, 11484
9D005314  00621021   ADDU V0, V1, V0
9D005318  8C430000   LW V1, 0(V0)
9D00531C  3C02A000   LUI V0, -24576
9D005320  24442CDC   ADDIU A0, V0, 11484
9D005324  24020030   ADDIU V0, ZERO, 48
9D005328  70A21002   MUL V0, A1, V0
9D00532C  00821021   ADDU V0, A0, V0
9D005330  AC43000C   SW V1, 12(V0)
3423:                	MyTCBStub.txTail = MyTCBStub.bufferTxStart;
9D005334  93828027   LBU V0, -32729(GP)
9D005338  00402821   ADDU A1, V0, ZERO
9D00533C  93828027   LBU V0, -32729(GP)
9D005340  00402021   ADDU A0, V0, ZERO
9D005344  3C02A000   LUI V0, -24576
9D005348  24030030   ADDIU V1, ZERO, 48
9D00534C  70831802   MUL V1, A0, V1
9D005350  24422CDC   ADDIU V0, V0, 11484
9D005354  00621021   ADDU V0, V1, V0
9D005358  8C430000   LW V1, 0(V0)
9D00535C  3C02A000   LUI V0, -24576
9D005360  24040030   ADDIU A0, ZERO, 48
9D005364  70A42002   MUL A0, A1, A0
9D005368  24422CDC   ADDIU V0, V0, 11484
9D00536C  00821021   ADDU V0, A0, V0
9D005370  AC430010   SW V1, 16(V0)
3424:                	MyTCBStub.rxHead = MyTCBStub.bufferRxStart;
9D005374  93828027   LBU V0, -32729(GP)
9D005378  00402821   ADDU A1, V0, ZERO
9D00537C  93828027   LBU V0, -32729(GP)
9D005380  00402021   ADDU A0, V0, ZERO
9D005384  3C02A000   LUI V0, -24576
9D005388  24432CDC   ADDIU V1, V0, 11484
9D00538C  24020030   ADDIU V0, ZERO, 48
9D005390  70821002   MUL V0, A0, V0
9D005394  00621021   ADDU V0, V1, V0
9D005398  8C430004   LW V1, 4(V0)
9D00539C  3C02A000   LUI V0, -24576
9D0053A0  24442CDC   ADDIU A0, V0, 11484
9D0053A4  24020030   ADDIU V0, ZERO, 48
9D0053A8  70A21002   MUL V0, A1, V0
9D0053AC  00821021   ADDU V0, A0, V0
9D0053B0  AC430014   SW V1, 20(V0)
3425:                	MyTCBStub.rxTail = MyTCBStub.bufferRxStart;
9D0053B4  93828027   LBU V0, -32729(GP)
9D0053B8  00402821   ADDU A1, V0, ZERO
9D0053BC  93828027   LBU V0, -32729(GP)
9D0053C0  00402021   ADDU A0, V0, ZERO
9D0053C4  3C02A000   LUI V0, -24576
9D0053C8  24432CDC   ADDIU V1, V0, 11484
9D0053CC  24020030   ADDIU V0, ZERO, 48
9D0053D0  70821002   MUL V0, A0, V0
9D0053D4  00621021   ADDU V0, V1, V0
9D0053D8  8C430004   LW V1, 4(V0)
9D0053DC  3C02A000   LUI V0, -24576
9D0053E0  24040030   ADDIU A0, ZERO, 48
9D0053E4  70A42002   MUL A0, A1, A0
9D0053E8  24422CDC   ADDIU V0, V0, 11484
9D0053EC  00821021   ADDU V0, A0, V0
9D0053F0  AC430018   SW V1, 24(V0)
3426:                	MyTCBStub.smState = MyTCBStub.Flags.bServer ? TCP_LISTEN : TCP_CLOSED;
9D0053F4  93828027   LBU V0, -32729(GP)
9D0053F8  00402821   ADDU A1, V0, ZERO
9D0053FC  93828027   LBU V0, -32729(GP)
9D005400  00402021   ADDU A0, V0, ZERO
9D005404  3C02A000   LUI V0, -24576
9D005408  24030030   ADDIU V1, ZERO, 48
9D00540C  70831802   MUL V1, A0, V1
9D005410  24422CDC   ADDIU V0, V0, 11484
9D005414  00621021   ADDU V0, V1, V0
9D005418  8C420028   LW V0, 40(V0)
9D00541C  7C4200C0   EXT V0, V0, 3, 1
9D005420  304200FF   ANDI V0, V0, 255
9D005424  10400004   BEQ V0, ZERO, 0x9D005438
9D005428  00000000   NOP
9D00542C  24030004   ADDIU V1, ZERO, 4
9D005430  0B40150F   J 0x9D00543C
9D005434  00000000   NOP
9D005438  2403000D   ADDIU V1, ZERO, 13
9D00543C  3C02A000   LUI V0, -24576
9D005440  24442CDC   ADDIU A0, V0, 11484
9D005444  24020030   ADDIU V0, ZERO, 48
9D005448  70A21002   MUL V0, A1, V0
9D00544C  00821021   ADDU V0, A0, V0
9D005450  AC430024   SW V1, 36(V0)
3427:                	MyTCBStub.Flags.vUnackedKeepalives = 0;
9D005454  93828027   LBU V0, -32729(GP)
9D005458  00402021   ADDU A0, V0, ZERO
9D00545C  3C02A000   LUI V0, -24576
9D005460  24030030   ADDIU V1, ZERO, 48
9D005464  70831802   MUL V1, A0, V1
9D005468  24422CDC   ADDIU V0, V0, 11484
9D00546C  00621821   ADDU V1, V1, V0
9D005470  8C620028   LW V0, 40(V1)
9D005474  7C021004   INS V0, ZERO, 0, 3
9D005478  AC620028   SW V0, 40(V1)
3428:                	MyTCBStub.Flags.bTimerEnabled = 0;
9D00547C  93828027   LBU V0, -32729(GP)
9D005480  00402021   ADDU A0, V0, ZERO
9D005484  3C02A000   LUI V0, -24576
9D005488  24030030   ADDIU V1, ZERO, 48
9D00548C  70831802   MUL V1, A0, V1
9D005490  24422CDC   ADDIU V0, V0, 11484
9D005494  00621821   ADDU V1, V1, V0
9D005498  8C620028   LW V0, 40(V1)
9D00549C  7C022104   INS V0, ZERO, 4, 1
9D0054A0  AC620028   SW V0, 40(V1)
3429:                	MyTCBStub.Flags.bTimer2Enabled = 0;
9D0054A4  93828027   LBU V0, -32729(GP)
9D0054A8  00402021   ADDU A0, V0, ZERO
9D0054AC  3C02A000   LUI V0, -24576
9D0054B0  24030030   ADDIU V1, ZERO, 48
9D0054B4  70831802   MUL V1, A0, V1
9D0054B8  24422CDC   ADDIU V0, V0, 11484
9D0054BC  00621821   ADDU V1, V1, V0
9D0054C0  8C620028   LW V0, 40(V1)
9D0054C4  7C022944   INS V0, ZERO, 5, 1
9D0054C8  AC620028   SW V0, 40(V1)
3430:                	MyTCBStub.Flags.bDelayedACKTimerEnabled = 0;
9D0054CC  93828027   LBU V0, -32729(GP)
9D0054D0  00402021   ADDU A0, V0, ZERO
9D0054D4  3C02A000   LUI V0, -24576
9D0054D8  24030030   ADDIU V1, ZERO, 48
9D0054DC  70831802   MUL V1, A0, V1
9D0054E0  24422CDC   ADDIU V0, V0, 11484
9D0054E4  00621821   ADDU V1, V1, V0
9D0054E8  8C620028   LW V0, 40(V1)
9D0054EC  7C023184   INS V0, ZERO, 6, 1
9D0054F0  AC620028   SW V0, 40(V1)
3431:                	MyTCBStub.Flags.bOneSegmentReceived = 0;
9D0054F4  93828027   LBU V0, -32729(GP)
9D0054F8  00402021   ADDU A0, V0, ZERO
9D0054FC  3C02A000   LUI V0, -24576
9D005500  24030030   ADDIU V1, ZERO, 48
9D005504  70831802   MUL V1, A0, V1
9D005508  24422CDC   ADDIU V0, V0, 11484
9D00550C  00621821   ADDU V1, V1, V0
9D005510  8C620028   LW V0, 40(V1)
9D005514  7C0239C4   INS V0, ZERO, 7, 1
9D005518  AC620028   SW V0, 40(V1)
3432:                	MyTCBStub.Flags.bHalfFullFlush = 0;
9D00551C  93828027   LBU V0, -32729(GP)
9D005520  00402021   ADDU A0, V0, ZERO
9D005524  3C02A000   LUI V0, -24576
9D005528  24030030   ADDIU V1, ZERO, 48
9D00552C  70831802   MUL V1, A0, V1
9D005530  24422CDC   ADDIU V0, V0, 11484
9D005534  00621821   ADDU V1, V1, V0
9D005538  8C620028   LW V0, 40(V1)
9D00553C  7C024204   INS V0, ZERO, 8, 1
9D005540  AC620028   SW V0, 40(V1)
3433:                	MyTCBStub.Flags.bTXASAP = 0;
9D005544  93828027   LBU V0, -32729(GP)
9D005548  00402021   ADDU A0, V0, ZERO
9D00554C  3C02A000   LUI V0, -24576
9D005550  24030030   ADDIU V1, ZERO, 48
9D005554  70831802   MUL V1, A0, V1
9D005558  24422CDC   ADDIU V0, V0, 11484
9D00555C  00621821   ADDU V1, V1, V0
9D005560  8C620028   LW V0, 40(V1)
9D005564  7C024A44   INS V0, ZERO, 9, 1
9D005568  AC620028   SW V0, 40(V1)
3434:                	MyTCBStub.Flags.bTXASAPWithoutTimerReset = 0;
9D00556C  93828027   LBU V0, -32729(GP)
9D005570  00402021   ADDU A0, V0, ZERO
9D005574  3C02A000   LUI V0, -24576
9D005578  24030030   ADDIU V1, ZERO, 48
9D00557C  70831802   MUL V1, A0, V1
9D005580  24422CDC   ADDIU V0, V0, 11484
9D005584  00621821   ADDU V1, V1, V0
9D005588  8C620028   LW V0, 40(V1)
9D00558C  7C025284   INS V0, ZERO, 10, 1
9D005590  AC620028   SW V0, 40(V1)
3435:                	MyTCBStub.Flags.bTXFIN = 0;
9D005594  93828027   LBU V0, -32729(GP)
9D005598  00402021   ADDU A0, V0, ZERO
9D00559C  3C02A000   LUI V0, -24576
9D0055A0  24030030   ADDIU V1, ZERO, 48
9D0055A4  70831802   MUL V1, A0, V1
9D0055A8  24422CDC   ADDIU V0, V0, 11484
9D0055AC  00621821   ADDU V1, V1, V0
9D0055B0  8C620028   LW V0, 40(V1)
9D0055B4  7C025AC4   INS V0, ZERO, 11, 1
9D0055B8  AC620028   SW V0, 40(V1)
3436:                	MyTCBStub.Flags.bSocketReset = 1;
9D0055BC  93828027   LBU V0, -32729(GP)
9D0055C0  00402021   ADDU A0, V0, ZERO
9D0055C4  3C02A000   LUI V0, -24576
9D0055C8  24030030   ADDIU V1, ZERO, 48
9D0055CC  70831802   MUL V1, A0, V1
9D0055D0  24422CDC   ADDIU V0, V0, 11484
9D0055D4  00621821   ADDU V1, V1, V0
9D0055D8  8C620028   LW V0, 40(V1)
9D0055DC  24040001   ADDIU A0, ZERO, 1
9D0055E0  7C826304   INS V0, A0, 12, 1
9D0055E4  AC620028   SW V0, 40(V1)
3437:                
3438:                	#if defined(STACK_USE_SSL)
3439:                	// If SSL is active, then we need to close it
3440:                	if(MyTCBStub.sslStubID != SSL_INVALID_ID)
3441:                	{
3442:                		SSLTerminate(MyTCBStub.sslStubID);
3443:                		MyTCBStub.sslStubID = SSL_INVALID_ID;
3444:                
3445:                		// Swap the SSL port and local port back to proper values
3446:                		MyTCBStub.remoteHash.Val = MyTCB.localSSLPort.Val;
3447:                		MyTCB.localSSLPort.Val = MyTCB.localPort.Val;
3448:                		MyTCB.localPort.Val = MyTCBStub.remoteHash.Val;
3449:                	}
3450:                
3451:                	// Reset the SSL buffer pointers
3452:                	MyTCBStub.sslRxHead = MyTCBStub.bufferRxStart;
3453:                	MyTCBStub.sslTxHead = MyTCBStub.bufferTxStart;
3454:                	#endif
3455:                	
3456:                	#if defined(STACK_USE_SSL_SERVER)
3457:                	MyTCBStub.sslTxHead = MyTCB.localSSLPort.Val;
3458:                	#endif
3459:                
3460:                	MyTCB.flags.bFINSent = 0;
9D0055E8  3C02A000   LUI V0, -24576
9D0055EC  24432E8C   ADDIU V1, V0, 11916
9D0055F0  8C620024   LW V0, 36(V1)
9D0055F4  7C028404   INS V0, ZERO, 16, 1
9D0055F8  AC620024   SW V0, 36(V1)
3461:                	MyTCB.flags.bSYNSent = 0;
9D0055FC  3C02A000   LUI V0, -24576
9D005600  24432E8C   ADDIU V1, V0, 11916
9D005604  8C620024   LW V0, 36(V1)
9D005608  7C028C44   INS V0, ZERO, 17, 1
9D00560C  AC620024   SW V0, 36(V1)
3462:                	MyTCB.flags.bRXNoneACKed1 = 0;
9D005610  3C02A000   LUI V0, -24576
9D005614  24432E8C   ADDIU V1, V0, 11916
9D005618  8C620024   LW V0, 36(V1)
9D00561C  7C029CC4   INS V0, ZERO, 19, 1
9D005620  AC620024   SW V0, 36(V1)
3463:                	MyTCB.flags.bRXNoneACKed2 = 0;
9D005624  3C02A000   LUI V0, -24576
9D005628  24432E8C   ADDIU V1, V0, 11916
9D00562C  8C620024   LW V0, 36(V1)
9D005630  7C02A504   INS V0, ZERO, 20, 1
9D005634  AC620024   SW V0, 36(V1)
3464:                	MyTCB.txUnackedTail = MyTCBStub.bufferTxStart;
9D005638  93828027   LBU V0, -32729(GP)
9D00563C  00402021   ADDU A0, V0, ZERO
9D005640  3C02A000   LUI V0, -24576
9D005644  24030030   ADDIU V1, ZERO, 48
9D005648  70831802   MUL V1, A0, V1
9D00564C  24422CDC   ADDIU V0, V0, 11484
9D005650  00621021   ADDU V0, V1, V0
9D005654  8C430000   LW V1, 0(V0)
9D005658  3C02A000   LUI V0, -24576
9D00565C  24422E8C   ADDIU V0, V0, 11916
9D005660  AC43000C   SW V1, 12(V0)
3465:                	((DWORD_VAL*)(&MyTCB.MySEQ))->w[0] = LFSRRand();
9D005664  3C02A000   LUI V0, -24576
9D005668  24502E90   ADDIU S0, V0, 11920
9D00566C  0F40960D   JAL LFSRRand
9D005670  00000000   NOP
9D005674  A6020000   SH V0, 0(S0)
3466:                	((DWORD_VAL*)(&MyTCB.MySEQ))->w[1] = LFSRRand();
9D005678  3C02A000   LUI V0, -24576
9D00567C  24502E90   ADDIU S0, V0, 11920
9D005680  0F40960D   JAL LFSRRand
9D005684  00000000   NOP
9D005688  A6020002   SH V0, 2(S0)
3467:                	MyTCB.sHoleSize = -1;
9D00568C  3C02A000   LUI V0, -24576
9D005690  24422E8C   ADDIU V0, V0, 11916
9D005694  2403FFFF   ADDIU V1, ZERO, -1
9D005698  A4430024   SH V1, 36(V0)
3468:                	MyTCB.remoteWindow = 1;
9D00569C  3C02A000   LUI V0, -24576
9D0056A0  24422E8C   ADDIU V0, V0, 11916
9D0056A4  24030001   ADDIU V1, ZERO, 1
9D0056A8  A4430014   SH V1, 20(V0)
3469:                }
9D0056AC  03C0E821   ADDU SP, S8, ZERO
9D0056B0  8FBF001C   LW RA, 28(SP)
9D0056B4  8FBE0018   LW S8, 24(SP)
9D0056B8  8FB00014   LW S0, 20(SP)
9D0056BC  27BD0020   ADDIU SP, SP, 32
9D0056C0  03E00008   JR RA
9D0056C4  00000000   NOP
3470:                
3471:                
3472:                /*****************************************************************************
3473:                  Function:
3474:                	static WORD GetMaxSegSizeOption(void)
3475:                
3476:                  Summary:
3477:                	Obtains the Maximum Segment Size (MSS) TCP Option out of the TCP header 
3478:                	for the current socket.
3479:                
3480:                  Description:
3481:                	Parses the current TCP packet header and extracts the Maximum Segment Size 
3482:                	option.  
3483:                
3484:                  Precondition:
3485:                	Must be called while a TCP packet is present and being processed via 
3486:                	HandleTCPSeg() and only if the the TCP SYN flag is set.
3487:                
3488:                  Parameters:
3489:                	None
3490:                
3491:                  Returns:
3492:                	Maximum segment size option value.  If illegal or not present, a failsafe 
3493:                	value of 536 is returned.  If the option is larger than the 
3494:                	TCP_MAX_SEG_SIZE_TX upper limit, then TCP_MAX_SEG_SIZE_TX is returned.
3495:                
3496:                  Remarks:
3497:                	The internal MAC Read Pointer is moved but not restored.
3498:                  ***************************************************************************/
3499:                static WORD GetMaxSegSizeOption(void)
3500:                {
9D0056C8  27BDFFD8   ADDIU SP, SP, -40
9D0056CC  AFBF0024   SW RA, 36(SP)
9D0056D0  AFBE0020   SW S8, 32(SP)
9D0056D4  AFB0001C   SW S0, 28(SP)
9D0056D8  03A0F021   ADDU S8, SP, ZERO
3501:                	BYTE vOptionsBytes;
3502:                	BYTE vOption;
3503:                	WORD wMSS;
3504:                
3505:                	// Find out how many options bytes are in this packet.
3506:                	IPSetRxBuffer(2+2+4+4);	// Seek to data offset field, skipping Source port (2), Destination port (2), Sequence number (4), and Acknowledgement number (4)
9D0056DC  2404000C   ADDIU A0, ZERO, 12
9D0056E0  0F40CEF1   JAL IPSetRxBuffer
9D0056E4  00000000   NOP
3507:                	vOptionsBytes = MACGet();
9D0056E8  0F40754F   JAL MACGet
9D0056EC  00000000   NOP
9D0056F0  A3C20010   SB V0, 16(S8)
3508:                	vOptionsBytes = ((vOptionsBytes&0xF0)>>2) - sizeof(TCP_HEADER);
9D0056F4  93C20010   LBU V0, 16(S8)
9D0056F8  304200F0   ANDI V0, V0, 240
9D0056FC  00021083   SRA V0, V0, 2
9D005700  304200FF   ANDI V0, V0, 255
9D005704  2442FFEC   ADDIU V0, V0, -20
9D005708  A3C20010   SB V0, 16(S8)
3509:                
3510:                	// Return minimum Maximum Segment Size value of 536 bytes if none are 
3511:                	// present
3512:                	if(vOptionsBytes == 0u)
9D00570C  93C20010   LBU V0, 16(S8)
9D005710  14400004   BNE V0, ZERO, 0x9D005724
9D005714  00000000   NOP
3513:                		return 536;
9D005718  24020218   ADDIU V0, ZERO, 536
9D00571C  0B401630   J 0x9D0058C0
9D005720  00000000   NOP
3514:                		
3515:                	// Seek to beginning of options
3516:                	MACGetArray(NULL, 7);
9D005724  00002021   ADDU A0, ZERO, ZERO
9D005728  24050007   ADDIU A1, ZERO, 7
9D00572C  0F407560   JAL MACGetArray
9D005730  00000000   NOP
3517:                
3518:                	// Search for the Maximum Segment Size option	
3519:                	while(vOptionsBytes--)
9D005734  0B401618   J 0x9D005860
9D005738  00000000   NOP
9D005860  93C20010   LBU V0, 16(S8)
9D005864  0002102B   SLTU V0, ZERO, V0
9D005868  304200FF   ANDI V0, V0, 255
9D00586C  93C30010   LBU V1, 16(S8)
9D005870  2463FFFF   ADDIU V1, V1, -1
9D005874  A3C30010   SB V1, 16(S8)
9D005878  1440FFB0   BNE V0, ZERO, 0x9D00573C
9D00587C  00000000   NOP
9D005880  0B40162F   J 0x9D0058BC
9D005884  00000000   NOP
3520:                	{
3521:                		vOption = MACGet();
9D00573C  0F40754F   JAL MACGet
9D005740  00000000   NOP
9D005744  A3C20011   SB V0, 17(S8)
3522:                		
3523:                		if(vOption == 0u)	// End of Options list
9D005748  93C20011   LBU V0, 17(S8)
9D00574C  1040004E   BEQ V0, ZERO, 0x9D005888
9D005750  00000000   NOP
3524:                			break;
9D005888  00000000   NOP
9D00588C  0B40162F   J 0x9D0058BC
9D005890  00000000   NOP
3525:                		
3526:                		if(vOption == 1u)	// NOP option
9D005754  93C30011   LBU V1, 17(S8)
9D005758  24020001   ADDIU V0, ZERO, 1
9D00575C  1062003F   BEQ V1, V0, 0x9D00585C
9D005760  00000000   NOP
3527:                			continue;
9D00585C  00000000   NOP
3528:                			
3529:                		if(vOption == 2u)	// Maximum Segment Size option
9D005764  93C30011   LBU V1, 17(S8)
9D005768  24020002   ADDIU V0, ZERO, 2
9D00576C  14620024   BNE V1, V0, 0x9D005800
9D005770  00000000   NOP
3530:                		{
3531:                			if(vOptionsBytes < 3u)
9D005774  93C20010   LBU V0, 16(S8)
9D005778  2C420003   SLTIU V0, V0, 3
9D00577C  14400045   BNE V0, ZERO, 0x9D005894
9D005780  00000000   NOP
3532:                				break;
9D005894  00000000   NOP
9D005898  0B40162F   J 0x9D0058BC
9D00589C  00000000   NOP
3533:                
3534:                			wMSS = 0;
9D005784  A7C00012   SH ZERO, 18(S8)
3535:                				
3536:                			// Get option length
3537:                			vOption = MACGet();
9D005788  0F40754F   JAL MACGet
9D00578C  00000000   NOP
9D005790  A3C20011   SB V0, 17(S8)
3538:                			if(vOption == 4u)
9D005794  93C30011   LBU V1, 17(S8)
9D005798  24020004   ADDIU V0, ZERO, 4
9D00579C  1462000A   BNE V1, V0, 0x9D0057C8
9D0057A0  00000000   NOP
3539:                			{// Retrieve MSS and swap value to little endian
3540:                				((BYTE*)&wMSS)[1] = MACGet();
9D0057A4  27C20012   ADDIU V0, S8, 18
9D0057A8  24500001   ADDIU S0, V0, 1
9D0057AC  0F40754F   JAL MACGet
9D0057B0  00000000   NOP
9D0057B4  A2020000   SB V0, 0(S0)
3541:                				((BYTE*)&wMSS)[0] = MACGet();
9D0057B8  27D00012   ADDIU S0, S8, 18
9D0057BC  0F40754F   JAL MACGet
9D0057C0  00000000   NOP
9D0057C4  A2020000   SB V0, 0(S0)
3542:                			}
3543:                			
3544:                			if(wMSS < 536u)
9D0057C8  97C20012   LHU V0, 18(S8)
9D0057CC  2C420218   SLTIU V0, V0, 536
9D0057D0  14400033   BNE V0, ZERO, 0x9D0058A0
9D0057D4  00000000   NOP
3545:                				break;
9D0058A0  00000000   NOP
9D0058A4  0B40162F   J 0x9D0058BC
9D0058A8  00000000   NOP
3546:                			if(wMSS > TCP_MAX_SEG_SIZE_TX)
9D0057D8  97C20012   LHU V0, 18(S8)
9D0057DC  2C4205B5   SLTIU V0, V0, 1461
9D0057E0  14400004   BNE V0, ZERO, 0x9D0057F4
9D0057E4  00000000   NOP
3547:                				return TCP_MAX_SEG_SIZE_TX;
9D0057E8  240205B4   ADDIU V0, ZERO, 1460
9D0057EC  0B401630   J 0x9D0058C0
9D0057F0  00000000   NOP
3548:                			else 
3549:                				return wMSS;
9D0057F4  97C20012   LHU V0, 18(S8)
9D0057F8  0B401630   J 0x9D0058C0
9D0057FC  00000000   NOP
3550:                		}
3551:                		else
3552:                		{ // Assume this is a multi byte option and throw it way
3553:                			if(vOptionsBytes < 2u)
9D005800  93C20010   LBU V0, 16(S8)
9D005804  2C420002   SLTIU V0, V0, 2
9D005808  14400028   BNE V0, ZERO, 0x9D0058AC
9D00580C  00000000   NOP
3554:                				break;
9D0058AC  00000000   NOP
9D0058B0  0B40162F   J 0x9D0058BC
9D0058B4  00000000   NOP
3555:                			vOption = MACGet();
9D005810  0F40754F   JAL MACGet
9D005814  00000000   NOP
9D005818  A3C20011   SB V0, 17(S8)
3556:                			if(vOptionsBytes < vOption)
9D00581C  93C30010   LBU V1, 16(S8)
9D005820  93C20011   LBU V0, 17(S8)
9D005824  0062102B   SLTU V0, V1, V0
9D005828  14400023   BNE V0, ZERO, 0x9D0058B8
9D00582C  00000000   NOP
3557:                				break;
9D0058B8  00000000   NOP
3558:                			MACGetArray(NULL, vOption);
9D005830  93C20011   LBU V0, 17(S8)
9D005834  00002021   ADDU A0, ZERO, ZERO
9D005838  00402821   ADDU A1, V0, ZERO
9D00583C  0F407560   JAL MACGetArray
9D005840  00000000   NOP
3559:                			vOptionsBytes -= vOption;
9D005844  93C30010   LBU V1, 16(S8)
9D005848  93C20011   LBU V0, 17(S8)
9D00584C  00621023   SUBU V0, V1, V0
9D005850  A3C20010   SB V0, 16(S8)
9D005854  0B401618   J 0x9D005860
9D005858  00000000   NOP
3560:                		}
3561:                		
3562:                	}
3563:                	
3564:                	// Did not find MSS option, return worst case default
3565:                	return 536;
9D0058BC  24020218   ADDIU V0, ZERO, 536
3566:                }
9D0058C0  03C0E821   ADDU SP, S8, ZERO
9D0058C4  8FBF0024   LW RA, 36(SP)
9D0058C8  8FBE0020   LW S8, 32(SP)
9D0058CC  8FB0001C   LW S0, 28(SP)
9D0058D0  27BD0028   ADDIU SP, SP, 40
9D0058D4  03E00008   JR RA
9D0058D8  00000000   NOP
3567:                
3568:                /*****************************************************************************
3569:                  Function:
3570:                	static void HandleTCPSeg(TCP_HEADER* h, WORD len)
3571:                
3572:                  Summary:
3573:                	Processes an incoming TCP segment.
3574:                
3575:                  Description:
3576:                	Once an incoming segment has been matched to a socket, this function
3577:                	performs the necessary processing with the data.  Depending on the 
3578:                	segment and the state, this may include copying data to the TCP buffer,
3579:                	re-assembling out-of order packets, continuing an initialization or 
3580:                	closing handshake, or closing the socket altogether.
3581:                
3582:                  Precondition:
3583:                	TCP is initialized and the current TCP stub is already synced.
3584:                
3585:                  Parameters:
3586:                	h - The TCP header for this packet
3587:                	len - The total buffer length of this segment
3588:                
3589:                  Returns:
3590:                	None
3591:                  ***************************************************************************/
3592:                static void HandleTCPSeg(TCP_HEADER* h, WORD len)
3593:                {
9D0058DC  27BDFFB0   ADDIU SP, SP, -80
9D0058E0  AFBF004C   SW RA, 76(SP)
9D0058E4  AFBE0048   SW S8, 72(SP)
9D0058E8  AFB00044   SW S0, 68(SP)
9D0058EC  03A0F021   ADDU S8, SP, ZERO
9D0058F0  AFC40050   SW A0, 80(S8)
9D0058F4  00A01021   ADDU V0, A1, ZERO
9D0058F8  A7C20054   SH V0, 84(S8)
3594:                	DWORD dwTemp;
3595:                	PTR_BASE wTemp;
3596:                	LONG lMissingBytes;
3597:                	WORD wMissingBytes;
3598:                	WORD wFreeSpace;
3599:                	BYTE localHeaderFlags;
3600:                	DWORD localAckNumber;
3601:                	DWORD localSeqNumber;
3602:                	WORD wSegmentLength;
3603:                	BOOL bSegmentAcceptable;
3604:                	WORD wNewWindow;
3605:                
3606:                
3607:                	// Cache a few variables in local RAM.  
3608:                	// PIC18s take a fair amount of code and execution time to 
3609:                	// dereference pointers frequently.
3610:                	localHeaderFlags = h->Flags.byte;
9D0058FC  8FC20050   LW V0, 80(S8)
9D005900  9042000D   LBU V0, 13(V0)
9D005904  A3C20030   SB V0, 48(S8)
3611:                	localAckNumber = h->AckNumber;
9D005908  8FC20050   LW V0, 80(S8)
9D00590C  8C420008   LW V0, 8(V0)
9D005910  AFC20024   SW V0, 36(S8)
3612:                	localSeqNumber = h->SeqNumber;
9D005914  8FC20050   LW V0, 80(S8)
9D005918  8C420004   LW V0, 4(V0)
9D00591C  AFC20034   SW V0, 52(S8)
3613:                
3614:                	// We received a packet, reset the keep alive timer and count
3615:                	#if defined(TCP_KEEP_ALIVE_TIMEOUT)
3616:                		MyTCBStub.Flags.vUnackedKeepalives = 0;
9D005920  93828027   LBU V0, -32729(GP)
9D005924  00402021   ADDU A0, V0, ZERO
9D005928  3C02A000   LUI V0, -24576
9D00592C  24030030   ADDIU V1, ZERO, 48
9D005930  70831802   MUL V1, A0, V1
9D005934  24422CDC   ADDIU V0, V0, 11484
9D005938  00621821   ADDU V1, V1, V0
9D00593C  8C620028   LW V0, 40(V1)
9D005940  7C021004   INS V0, ZERO, 0, 3
9D005944  AC620028   SW V0, 40(V1)
3617:                		if(!MyTCBStub.Flags.bTimerEnabled)
9D005948  93828027   LBU V0, -32729(GP)
9D00594C  00402021   ADDU A0, V0, ZERO
9D005950  3C02A000   LUI V0, -24576
9D005954  24030030   ADDIU V1, ZERO, 48
9D005958  70831802   MUL V1, A0, V1
9D00595C  24422CDC   ADDIU V0, V0, 11484
9D005960  00621021   ADDU V0, V1, V0
9D005964  8C420028   LW V0, 40(V0)
9D005968  7C420100   EXT V0, V0, 4, 1
9D00596C  304200FF   ANDI V0, V0, 255
9D005970  1440000F   BNE V0, ZERO, 0x9D0059B0
9D005974  00000000   NOP
3618:                			MyTCBStub.eventTime = TickGet() + TCP_KEEP_ALIVE_TIMEOUT;
9D005978  93828027   LBU V0, -32729(GP)
9D00597C  00408021   ADDU S0, V0, ZERO
9D005980  0F40CDD6   JAL TickGet
9D005984  00000000   NOP
9D005988  00401821   ADDU V1, V0, ZERO
9D00598C  3C020017   LUI V0, 23
9D005990  3442D784   ORI V0, V0, -10364
9D005994  00621821   ADDU V1, V1, V0
9D005998  3C02A000   LUI V0, -24576
9D00599C  24442CDC   ADDIU A0, V0, 11484
9D0059A0  24020030   ADDIU V0, ZERO, 48
9D0059A4  72021002   MUL V0, S0, V0
9D0059A8  00821021   ADDU V0, A0, V0
9D0059AC  AC43001C   SW V1, 28(V0)
3619:                	#endif
3620:                
3621:                	// Handle TCP_LISTEN and TCP_SYN_SENT states
3622:                	// Both of these states will return, so code following this 
3623:                	// state machine need not check explicitly for these two 
3624:                	// states.
3625:                	switch(MyTCBStub.smState)
9D0059B0  93828027   LBU V0, -32729(GP)
9D0059B4  00402021   ADDU A0, V0, ZERO
9D0059B8  3C02A000   LUI V0, -24576
9D0059BC  24432CDC   ADDIU V1, V0, 11484
9D0059C0  24020030   ADDIU V0, ZERO, 48
9D0059C4  70821002   MUL V0, A0, V0
9D0059C8  00621021   ADDU V0, V1, V0
9D0059CC  8C420024   LW V0, 36(V0)
9D0059D0  24030004   ADDIU V1, ZERO, 4
9D0059D4  10430006   BEQ V0, V1, 0x9D0059F0
9D0059D8  00000000   NOP
9D0059DC  24030005   ADDIU V1, ZERO, 5
9D0059E0  1043003D   BEQ V0, V1, 0x9D005AD8
9D0059E4  00000000   NOP
9D0059E8  0B401724   J 0x9D005C90
9D0059EC  00000000   NOP
3626:                	{
3627:                		case TCP_LISTEN:
3628:                			// First: check RST flag
3629:                			if(localHeaderFlags & RST)
9D0059F0  93C20030   LBU V0, 48(S8)
9D0059F4  30420004   ANDI V0, V0, 4
9D0059F8  10400005   BEQ V0, ZERO, 0x9D005A10
9D0059FC  00000000   NOP
3630:                			{
3631:                				CloseSocket();	// Unbind remote IP address/port info
9D005A00  0F4014AB   JAL CloseSocket
9D005A04  00000000   NOP
3632:                				return;
9D005A08  0B401EE5   J 0x9D007B94
9D005A0C  00000000   NOP
3633:                			}
3634:                
3635:                			// Second: check ACK flag, which would be invalid
3636:                			if(localHeaderFlags & ACK)
9D005A10  93C20030   LBU V0, 48(S8)
9D005A14  30420010   ANDI V0, V0, 16
9D005A18  1040000D   BEQ V0, ZERO, 0x9D005A50
9D005A1C  00000000   NOP
3637:                			{
3638:                				// Use a believable sequence number and reset the remote node
3639:                				MyTCB.MySEQ = localAckNumber;
9D005A20  3C02A000   LUI V0, -24576
9D005A24  24422E8C   ADDIU V0, V0, 11916
9D005A28  8FC30024   LW V1, 36(S8)
9D005A2C  AC430004   SW V1, 4(V0)
3640:                				SendTCP(RST, 0);
9D005A30  24040004   ADDIU A0, ZERO, 4
9D005A34  00002821   ADDU A1, ZERO, ZERO
9D005A38  0F400F8B   JAL SendTCP
9D005A3C  00000000   NOP
3641:                				CloseSocket();	// Unbind remote IP address/port info
9D005A40  0F4014AB   JAL CloseSocket
9D005A44  00000000   NOP
3642:                				return;
9D005A48  0B401EE5   J 0x9D007B94
9D005A4C  00000000   NOP
3643:                			}
3644:                
3645:                			// Third: check for SYN flag, which is what we're looking for
3646:                			if(localHeaderFlags & SYN)
9D005A50  93C20030   LBU V0, 48(S8)
9D005A54  30420002   ANDI V0, V0, 2
9D005A58  1040001B   BEQ V0, ZERO, 0x9D005AC8
9D005A5C  00000000   NOP
3647:                			{
3648:                				// We now have a sequence number for the remote node
3649:                				MyTCB.RemoteSEQ = localSeqNumber + 1;
9D005A60  8FC20034   LW V0, 52(S8)
9D005A64  24430001   ADDIU V1, V0, 1
9D005A68  3C02A000   LUI V0, -24576
9D005A6C  24422E8C   ADDIU V0, V0, 11916
9D005A70  AC430008   SW V1, 8(V0)
3650:                
3651:                				// Get MSS option
3652:                				MyTCB.wRemoteMSS = GetMaxSegSizeOption();
9D005A74  0F4015B2   JAL GetMaxSegSizeOption
9D005A78  00000000   NOP
9D005A7C  00401821   ADDU V1, V0, ZERO
9D005A80  3C02A000   LUI V0, -24576
9D005A84  24422E8C   ADDIU V0, V0, 11916
9D005A88  A4430028   SH V1, 40(V0)
3653:                
3654:                				// Set Initial Send Sequence (ISS) number
3655:                				// Nothing to do on this step... ISS already set in CloseSocket()
3656:                				
3657:                				// Respond with SYN + ACK
3658:                				SendTCP(SYN | ACK, SENDTCP_RESET_TIMERS);
9D005A8C  24040012   ADDIU A0, ZERO, 18
9D005A90  24050001   ADDIU A1, ZERO, 1
9D005A94  0F400F8B   JAL SendTCP
9D005A98  00000000   NOP
3659:                				MyTCBStub.smState = TCP_SYN_RECEIVED;
9D005A9C  93828027   LBU V0, -32729(GP)
9D005AA0  00402021   ADDU A0, V0, ZERO
9D005AA4  3C02A000   LUI V0, -24576
9D005AA8  24432CDC   ADDIU V1, V0, 11484
9D005AAC  24020030   ADDIU V0, ZERO, 48
9D005AB0  70821002   MUL V0, A0, V0
9D005AB4  00621021   ADDU V0, V1, V0
9D005AB8  24030006   ADDIU V1, ZERO, 6
9D005ABC  AC430024   SW V1, 36(V0)
3660:                			}
3661:                			else
3662:                			{
3663:                				CloseSocket();	// Unbind remote IP address/port info
9D005AC8  0F4014AB   JAL CloseSocket
9D005ACC  00000000   NOP
3664:                			}
3665:                
3666:                			// Fourth: check for other text and control
3667:                			// Nothing to do since we don't support this
3668:                			return;
9D005AC0  0B401EE5   J 0x9D007B94
9D005AC4  00000000   NOP
9D005AD0  0B401EE5   J 0x9D007B94
9D005AD4  00000000   NOP
3669:                
3670:                		case TCP_SYN_SENT:
3671:                			// Second: check the RST bit
3672:                			// This is out of order because this stack has no API for 
3673:                			// notifying the application that the connection seems to 
3674:                			// be failing.  Instead, the application must time out and 
3675:                			// the stack will just keep trying in the mean time.
3676:                			if(localHeaderFlags & RST)
9D005AD8  93C20030   LBU V0, 48(S8)
9D005ADC  30420004   ANDI V0, V0, 4
9D005AE0  14400810   BNE V0, ZERO, 0x9D007B24
9D005AE4  00000000   NOP
3677:                				return;
9D007B24  00000000   NOP
9D007B28  0B401EE5   J 0x9D007B94
9D007B2C  00000000   NOP
3678:                
3679:                			// First: check ACK bit
3680:                			if(localHeaderFlags & ACK)
9D005AE8  93C20030   LBU V0, 48(S8)
9D005AEC  30420010   ANDI V0, V0, 16
9D005AF0  10400019   BEQ V0, ZERO, 0x9D005B58
9D005AF4  00000000   NOP
3681:                			{
3682:                				if(localAckNumber != MyTCB.MySEQ)
9D005AF8  3C02A000   LUI V0, -24576
9D005AFC  24422E8C   ADDIU V0, V0, 11916
9D005B00  8C430004   LW V1, 4(V0)
9D005B04  8FC20024   LW V0, 36(S8)
9D005B08  10620013   BEQ V1, V0, 0x9D005B58
9D005B0C  00000000   NOP
3683:                				{
3684:                					// Send a RST packet with SEQ = SEG.ACK, but retain our SEQ 
3685:                					// number for arivial of any other SYN+ACK packets
3686:                					localSeqNumber = MyTCB.MySEQ;	// Save our original SEQ number
9D005B10  3C02A000   LUI V0, -24576
9D005B14  24422E8C   ADDIU V0, V0, 11916
9D005B18  8C420004   LW V0, 4(V0)
9D005B1C  AFC20034   SW V0, 52(S8)
3687:                					MyTCB.MySEQ = localAckNumber;	// Set SEQ = SEG.ACK
9D005B20  3C02A000   LUI V0, -24576
9D005B24  24422E8C   ADDIU V0, V0, 11916
9D005B28  8FC30024   LW V1, 36(S8)
9D005B2C  AC430004   SW V1, 4(V0)
3688:                					SendTCP(RST, SENDTCP_RESET_TIMERS);		// Send the RST
9D005B30  24040004   ADDIU A0, ZERO, 4
9D005B34  24050001   ADDIU A1, ZERO, 1
9D005B38  0F400F8B   JAL SendTCP
9D005B3C  00000000   NOP
3689:                					MyTCB.MySEQ = localSeqNumber;	// Restore original SEQ number
9D005B40  3C02A000   LUI V0, -24576
9D005B44  24422E8C   ADDIU V0, V0, 11916
9D005B48  8FC30034   LW V1, 52(S8)
9D005B4C  AC430004   SW V1, 4(V0)
3690:                					return;
9D005B50  0B401EE5   J 0x9D007B94
9D005B54  00000000   NOP
3691:                				}
3692:                			}
3693:                
3694:                			// Third: check the security and precedence
3695:                			// No such feature in this stack.  We want to accept all connections.
3696:                
3697:                			// Fourth: check the SYN bit
3698:                			if(localHeaderFlags & SYN)
9D005B58  93C20030   LBU V0, 48(S8)
9D005B5C  30420002   ANDI V0, V0, 2
9D005B60  104007F3   BEQ V0, ZERO, 0x9D007B30
9D005B64  00000000   NOP
3699:                			{
3700:                				// We now have an initial sequence number and window size
3701:                				MyTCB.RemoteSEQ = localSeqNumber + 1;
9D005B68  8FC20034   LW V0, 52(S8)
9D005B6C  24430001   ADDIU V1, V0, 1
9D005B70  3C02A000   LUI V0, -24576
9D005B74  24422E8C   ADDIU V0, V0, 11916
9D005B78  AC430008   SW V1, 8(V0)
3702:                				MyTCB.remoteWindow = h->Window;
9D005B7C  8FC20050   LW V0, 80(S8)
9D005B80  9443000E   LHU V1, 14(V0)
9D005B84  3C02A000   LUI V0, -24576
9D005B88  24422E8C   ADDIU V0, V0, 11916
9D005B8C  A4430014   SH V1, 20(V0)
3703:                
3704:                				// Get MSS option
3705:                				MyTCB.wRemoteMSS = GetMaxSegSizeOption();
9D005B90  0F4015B2   JAL GetMaxSegSizeOption
9D005B94  00000000   NOP
9D005B98  00401821   ADDU V1, V0, ZERO
9D005B9C  3C02A000   LUI V0, -24576
9D005BA0  24422E8C   ADDIU V0, V0, 11916
9D005BA4  A4430028   SH V1, 40(V0)
3706:                
3707:                				if(localHeaderFlags & ACK)
9D005BA8  93C20030   LBU V0, 48(S8)
9D005BAC  30420010   ANDI V0, V0, 16
9D005BB0  10400028   BEQ V0, ZERO, 0x9D005C54
9D005BB4  00000000   NOP
3708:                				{
3709:                					SendTCP(ACK, SENDTCP_RESET_TIMERS);
9D005BB8  24040010   ADDIU A0, ZERO, 16
9D005BBC  24050001   ADDIU A1, ZERO, 1
9D005BC0  0F400F8B   JAL SendTCP
9D005BC4  00000000   NOP
3710:                					MyTCBStub.smState = TCP_ESTABLISHED;
9D005BC8  93828027   LBU V0, -32729(GP)
9D005BCC  00402021   ADDU A0, V0, ZERO
9D005BD0  3C02A000   LUI V0, -24576
9D005BD4  24432CDC   ADDIU V1, V0, 11484
9D005BD8  24020030   ADDIU V0, ZERO, 48
9D005BDC  70821002   MUL V0, A0, V0
9D005BE0  00621021   ADDU V0, V1, V0
9D005BE4  24030007   ADDIU V1, ZERO, 7
9D005BE8  AC430024   SW V1, 36(V0)
3711:                					// Set up keep-alive timer
3712:                					#if defined(TCP_KEEP_ALIVE_TIMEOUT)
3713:                						MyTCBStub.eventTime = TickGet() + TCP_KEEP_ALIVE_TIMEOUT;
9D005BEC  93828027   LBU V0, -32729(GP)
9D005BF0  00408021   ADDU S0, V0, ZERO
9D005BF4  0F40CDD6   JAL TickGet
9D005BF8  00000000   NOP
9D005BFC  00401821   ADDU V1, V0, ZERO
9D005C00  3C020017   LUI V0, 23
9D005C04  3442D784   ORI V0, V0, -10364
9D005C08  00621821   ADDU V1, V1, V0
9D005C0C  3C02A000   LUI V0, -24576
9D005C10  24442CDC   ADDIU A0, V0, 11484
9D005C14  24020030   ADDIU V0, ZERO, 48
9D005C18  72021002   MUL V0, S0, V0
9D005C1C  00821021   ADDU V0, A0, V0
9D005C20  AC43001C   SW V1, 28(V0)
3714:                					#endif
3715:                					MyTCBStub.Flags.bTimerEnabled = 0;
9D005C24  93828027   LBU V0, -32729(GP)
9D005C28  00402021   ADDU A0, V0, ZERO
9D005C2C  3C02A000   LUI V0, -24576
9D005C30  24030030   ADDIU V1, ZERO, 48
9D005C34  70831802   MUL V1, A0, V1
9D005C38  24422CDC   ADDIU V0, V0, 11484
9D005C3C  00621821   ADDU V1, V1, V0
9D005C40  8C620028   LW V0, 40(V1)
9D005C44  7C022104   INS V0, ZERO, 4, 1
9D005C48  AC620028   SW V0, 40(V1)
3716:                				}
3717:                				else
3718:                				{
3719:                					SendTCP(SYN | ACK, SENDTCP_RESET_TIMERS);
9D005C54  24040012   ADDIU A0, ZERO, 18
9D005C58  24050001   ADDIU A1, ZERO, 1
9D005C5C  0F400F8B   JAL SendTCP
9D005C60  00000000   NOP
3720:                					MyTCBStub.smState = TCP_SYN_RECEIVED;
9D005C64  93828027   LBU V0, -32729(GP)
9D005C68  00402021   ADDU A0, V0, ZERO
9D005C6C  3C02A000   LUI V0, -24576
9D005C70  24432CDC   ADDIU V1, V0, 11484
9D005C74  24020030   ADDIU V0, ZERO, 48
9D005C78  70821002   MUL V0, A0, V0
9D005C7C  00621021   ADDU V0, V1, V0
9D005C80  24030006   ADDIU V1, ZERO, 6
9D005C84  AC430024   SW V1, 36(V0)
3721:                				}
3722:                			}
3723:                
3724:                			// Fifth: drop the segment if neither SYN or RST is set
3725:                			return;
9D005C4C  0B401EE5   J 0x9D007B94
9D005C50  00000000   NOP
9D005C88  0B401EE5   J 0x9D007B94
9D005C8C  00000000   NOP
9D007B30  00000000   NOP
9D007B34  0B401EE5   J 0x9D007B94
9D007B38  00000000   NOP
3726:                
3727:                		default:
3728:                			break;
3729:                	}
3730:                
3731:                	//
3732:                	// First: check the sequence number
3733:                	//
3734:                	wSegmentLength = len;
9D005C90  97C20054   LHU V0, 84(S8)
9D005C94  A7C20028   SH V0, 40(S8)
3735:                	if(localHeaderFlags & FIN)
9D005C98  93C20030   LBU V0, 48(S8)
9D005C9C  30420001   ANDI V0, V0, 1
9D005CA0  304200FF   ANDI V0, V0, 255
9D005CA4  10400004   BEQ V0, ZERO, 0x9D005CB8
9D005CA8  00000000   NOP
3736:                		wSegmentLength++;
9D005CAC  97C20028   LHU V0, 40(S8)
9D005CB0  24420001   ADDIU V0, V0, 1
9D005CB4  A7C20028   SH V0, 40(S8)
3737:                	if(localHeaderFlags & SYN)
9D005CB8  93C20030   LBU V0, 48(S8)
9D005CBC  30420002   ANDI V0, V0, 2
9D005CC0  10400004   BEQ V0, ZERO, 0x9D005CD4
9D005CC4  00000000   NOP
3738:                		wSegmentLength++;
9D005CC8  97C20028   LHU V0, 40(S8)
9D005CCC  24420001   ADDIU V0, V0, 1
9D005CD0  A7C20028   SH V0, 40(S8)
3739:                
3740:                	// Calculate the RX FIFO space
3741:                	if(MyTCBStub.rxHead >= MyTCBStub.rxTail)
9D005CD4  93828027   LBU V0, -32729(GP)
9D005CD8  00402021   ADDU A0, V0, ZERO
9D005CDC  3C02A000   LUI V0, -24576
9D005CE0  24432CDC   ADDIU V1, V0, 11484
9D005CE4  24020030   ADDIU V0, ZERO, 48
9D005CE8  70821002   MUL V0, A0, V0
9D005CEC  00621021   ADDU V0, V1, V0
9D005CF0  8C430014   LW V1, 20(V0)
9D005CF4  93828027   LBU V0, -32729(GP)
9D005CF8  00402821   ADDU A1, V0, ZERO
9D005CFC  3C02A000   LUI V0, -24576
9D005D00  24040030   ADDIU A0, ZERO, 48
9D005D04  70A42002   MUL A0, A1, A0
9D005D08  24422CDC   ADDIU V0, V0, 11484
9D005D0C  00821021   ADDU V0, A0, V0
9D005D10  8C420018   LW V0, 24(V0)
9D005D14  0062102B   SLTU V0, V1, V0
9D005D18  1440002D   BNE V0, ZERO, 0x9D005DD0
9D005D1C  00000000   NOP
3742:                		wFreeSpace = (MyTCBStub.bufferEnd - MyTCBStub.bufferRxStart) - (MyTCBStub.rxHead - MyTCBStub.rxTail);
9D005D20  93828027   LBU V0, -32729(GP)
9D005D24  00402021   ADDU A0, V0, ZERO
9D005D28  3C02A000   LUI V0, -24576
9D005D2C  24030030   ADDIU V1, ZERO, 48
9D005D30  70831802   MUL V1, A0, V1
9D005D34  24422CDC   ADDIU V0, V0, 11484
9D005D38  00621021   ADDU V0, V1, V0
9D005D3C  8C420008   LW V0, 8(V0)
9D005D40  3043FFFF   ANDI V1, V0, -1
9D005D44  93828027   LBU V0, -32729(GP)
9D005D48  00402821   ADDU A1, V0, ZERO
9D005D4C  3C02A000   LUI V0, -24576
9D005D50  24442CDC   ADDIU A0, V0, 11484
9D005D54  24020030   ADDIU V0, ZERO, 48
9D005D58  70A21002   MUL V0, A1, V0
9D005D5C  00821021   ADDU V0, A0, V0
9D005D60  8C420004   LW V0, 4(V0)
9D005D64  3042FFFF   ANDI V0, V0, -1
9D005D68  00621023   SUBU V0, V1, V0
9D005D6C  3043FFFF   ANDI V1, V0, -1
9D005D70  93828027   LBU V0, -32729(GP)
9D005D74  00402821   ADDU A1, V0, ZERO
9D005D78  3C02A000   LUI V0, -24576
9D005D7C  24040030   ADDIU A0, ZERO, 48
9D005D80  70A42002   MUL A0, A1, A0
9D005D84  24422CDC   ADDIU V0, V0, 11484
9D005D88  00821021   ADDU V0, A0, V0
9D005D8C  8C420018   LW V0, 24(V0)
9D005D90  3044FFFF   ANDI A0, V0, -1
9D005D94  93828027   LBU V0, -32729(GP)
9D005D98  00403021   ADDU A2, V0, ZERO
9D005D9C  3C02A000   LUI V0, -24576
9D005DA0  24452CDC   ADDIU A1, V0, 11484
9D005DA4  24020030   ADDIU V0, ZERO, 48
9D005DA8  70C21002   MUL V0, A2, V0
9D005DAC  00A21021   ADDU V0, A1, V0
9D005DB0  8C420014   LW V0, 20(V0)
9D005DB4  3042FFFF   ANDI V0, V0, -1
9D005DB8  00821023   SUBU V0, A0, V0
9D005DBC  3042FFFF   ANDI V0, V0, -1
9D005DC0  00621021   ADDU V0, V1, V0
9D005DC4  A7C20020   SH V0, 32(S8)
9D005DC8  0B40178A   J 0x9D005E28
9D005DCC  00000000   NOP
3743:                	else
3744:                		wFreeSpace = MyTCBStub.rxTail - MyTCBStub.rxHead - 1;
9D005DD0  93828027   LBU V0, -32729(GP)
9D005DD4  00402021   ADDU A0, V0, ZERO
9D005DD8  3C02A000   LUI V0, -24576
9D005DDC  24030030   ADDIU V1, ZERO, 48
9D005DE0  70831802   MUL V1, A0, V1
9D005DE4  24422CDC   ADDIU V0, V0, 11484
9D005DE8  00621021   ADDU V0, V1, V0
9D005DEC  8C420018   LW V0, 24(V0)
9D005DF0  3043FFFF   ANDI V1, V0, -1
9D005DF4  93828027   LBU V0, -32729(GP)
9D005DF8  00402821   ADDU A1, V0, ZERO
9D005DFC  3C02A000   LUI V0, -24576
9D005E00  24442CDC   ADDIU A0, V0, 11484
9D005E04  24020030   ADDIU V0, ZERO, 48
9D005E08  70A21002   MUL V0, A1, V0
9D005E0C  00821021   ADDU V0, A0, V0
9D005E10  8C420014   LW V0, 20(V0)
9D005E14  3042FFFF   ANDI V0, V0, -1
9D005E18  00621023   SUBU V0, V1, V0
9D005E1C  3042FFFF   ANDI V0, V0, -1
9D005E20  2442FFFF   ADDIU V0, V0, -1
9D005E24  A7C20020   SH V0, 32(S8)
3745:                
3746:                	// Calculate the number of bytes ahead of our head pointer this segment skips
3747:                	lMissingBytes = localSeqNumber - MyTCB.RemoteSEQ;
9D005E28  3C02A000   LUI V0, -24576
9D005E2C  24422E8C   ADDIU V0, V0, 11916
9D005E30  8C420008   LW V0, 8(V0)
9D005E34  8FC30034   LW V1, 52(S8)
9D005E38  00621023   SUBU V0, V1, V0
9D005E3C  AFC20038   SW V0, 56(S8)
3748:                	wMissingBytes = (WORD)lMissingBytes;
9D005E40  8FC20038   LW V0, 56(S8)
9D005E44  A7C2003C   SH V0, 60(S8)
3749:                	
3750:                	// Run TCP acceptability tests to verify that this packet has a valid sequence number
3751:                	bSegmentAcceptable = FALSE;
9D005E48  AFC0002C   SW ZERO, 44(S8)
3752:                	if(wSegmentLength)
9D005E4C  97C20028   LHU V0, 40(S8)
9D005E50  10400030   BEQ V0, ZERO, 0x9D005F14
9D005E54  00000000   NOP
3753:                	{
3754:                		// Check to see if we have free space, and if so, if any of the data falls within the freespace
3755:                		if(wFreeSpace)
9D005E58  97C20020   LHU V0, 32(S8)
9D005E5C  1040003E   BEQ V0, ZERO, 0x9D005F58
9D005E60  00000000   NOP
3756:                		{
3757:                			// RCV.NXT =< SEG.SEQ < RCV.NXT+RCV.WND
3758:                			if((lMissingBytes >= (LONG)0) && (wFreeSpace > (DWORD)lMissingBytes))
9D005E64  8FC20038   LW V0, 56(S8)
9D005E68  0440000A   BLTZ V0, 0x9D005E94
9D005E6C  00000000   NOP
9D005E70  97C30020   LHU V1, 32(S8)
9D005E74  8FC20038   LW V0, 56(S8)
9D005E78  0043102B   SLTU V0, V0, V1
9D005E7C  10400005   BEQ V0, ZERO, 0x9D005E94
9D005E80  00000000   NOP
3759:                				bSegmentAcceptable = TRUE;
9D005E84  24020001   ADDIU V0, ZERO, 1
9D005E88  AFC2002C   SW V0, 44(S8)
9D005E8C  0B4017B6   J 0x9D005ED8
9D005E90  00000000   NOP
3760:                			else
3761:                			{
3762:                				// RCV.NXT =< SEG.SEQ+SEG.LEN-1 < RCV.NXT+RCV.WND
3763:                				if((lMissingBytes + (LONG)wSegmentLength > (LONG)0) && (lMissingBytes <= (LONG)(SHORT)(wFreeSpace - wSegmentLength)))
9D005E94  97C30028   LHU V1, 40(S8)
9D005E98  8FC20038   LW V0, 56(S8)
9D005E9C  00621021   ADDU V0, V1, V0
9D005EA0  1840000D   BLEZ V0, 0x9D005ED8
9D005EA4  00000000   NOP
9D005EA8  97C30020   LHU V1, 32(S8)
9D005EAC  97C20028   LHU V0, 40(S8)
9D005EB0  00621023   SUBU V0, V1, V0
9D005EB4  3042FFFF   ANDI V0, V0, -1
9D005EB8  7C021620   SEH V0, V0
9D005EBC  00401821   ADDU V1, V0, ZERO
9D005EC0  8FC20038   LW V0, 56(S8)
9D005EC4  0062102A   SLT V0, V1, V0
9D005EC8  14400003   BNE V0, ZERO, 0x9D005ED8
9D005ECC  00000000   NOP
3764:                					bSegmentAcceptable = TRUE;
9D005ED0  24020001   ADDIU V0, ZERO, 1
9D005ED4  AFC2002C   SW V0, 44(S8)
3765:                			}
3766:                			
3767:                			if((lMissingBytes < (LONG)wFreeSpace) && ((SHORT)wMissingBytes + (SHORT)wSegmentLength > (SHORT)0))
9D005ED8  97C30020   LHU V1, 32(S8)
9D005EDC  8FC20038   LW V0, 56(S8)
9D005EE0  0043102A   SLT V0, V0, V1
9D005EE4  1040001C   BEQ V0, ZERO, 0x9D005F58
9D005EE8  00000000   NOP
9D005EEC  87C2003C   LH V0, 60(S8)
9D005EF0  00401821   ADDU V1, V0, ZERO
9D005EF4  87C20028   LH V0, 40(S8)
9D005EF8  00621021   ADDU V0, V1, V0
9D005EFC  18400016   BLEZ V0, 0x9D005F58
9D005F00  00000000   NOP
3768:                				bSegmentAcceptable = TRUE;
9D005F04  24020001   ADDIU V0, ZERO, 1
9D005F08  AFC2002C   SW V0, 44(S8)
9D005F0C  0B4017D6   J 0x9D005F58
9D005F10  00000000   NOP
3769:                		}
3770:                		// Segments with data are not acceptable if we have no free space
3771:                	}
3772:                	else
3773:                	{
3774:                		// Zero length packets are acceptable if they fall within our free space window
3775:                		// SEG.SEQ = RCV.NXT
3776:                		if(lMissingBytes == 0)
9D005F14  8FC20038   LW V0, 56(S8)
9D005F18  14400005   BNE V0, ZERO, 0x9D005F30
9D005F1C  00000000   NOP
3777:                		{
3778:                			bSegmentAcceptable = TRUE;
9D005F20  24020001   ADDIU V0, ZERO, 1
9D005F24  AFC2002C   SW V0, 44(S8)
9D005F28  0B4017D6   J 0x9D005F58
9D005F2C  00000000   NOP
3779:                		}
3780:                		else
3781:                		{
3782:                			// RCV.NXT =< SEG.SEQ < RCV.NXT+RCV.WND
3783:                			if((lMissingBytes >= (LONG)0) && (wFreeSpace > (DWORD)lMissingBytes))
9D005F30  8FC20038   LW V0, 56(S8)
9D005F34  04400008   BLTZ V0, 0x9D005F58
9D005F38  00000000   NOP
9D005F3C  97C30020   LHU V1, 32(S8)
9D005F40  8FC20038   LW V0, 56(S8)
9D005F44  0043102B   SLTU V0, V0, V1
9D005F48  10400003   BEQ V0, ZERO, 0x9D005F58
9D005F4C  00000000   NOP
3784:                				bSegmentAcceptable = TRUE;
9D005F50  24020001   ADDIU V0, ZERO, 1
9D005F54  AFC2002C   SW V0, 44(S8)
3785:                		}
3786:                	}
3787:                	
3788:                	if(!bSegmentAcceptable)
9D005F58  8FC2002C   LW V0, 44(S8)
9D005F5C  1440000B   BNE V0, ZERO, 0x9D005F8C
9D005F60  00000000   NOP
3789:                	{
3790:                		// Unacceptable segment, drop it and respond appropriately
3791:                		if(!(localHeaderFlags & RST)) 
9D005F64  93C20030   LBU V0, 48(S8)
9D005F68  30420004   ANDI V0, V0, 4
9D005F6C  144006F3   BNE V0, ZERO, 0x9D007B3C
9D005F70  00000000   NOP
3792:                			SendTCP(ACK, SENDTCP_RESET_TIMERS);
9D005F74  24040010   ADDIU A0, ZERO, 16
9D005F78  24050001   ADDIU A1, ZERO, 1
9D005F7C  0F400F8B   JAL SendTCP
9D005F80  00000000   NOP
3793:                		return;
9D005F84  0B401EE5   J 0x9D007B94
9D005F88  00000000   NOP
9D007B3C  00000000   NOP
9D007B40  0B401EE5   J 0x9D007B94
9D007B44  00000000   NOP
3794:                	}
3795:                
3796:                
3797:                	//
3798:                	// Second: check the RST bit
3799:                	//
3800:                	//
3801:                	// Fourth: check the SYN bit
3802:                	//
3803:                	// Note, that since the third step is not implemented, we can 
3804:                	// combine this second and fourth step into a single operation.
3805:                	if(localHeaderFlags & (RST | SYN))
9D005F8C  93C20030   LBU V0, 48(S8)
9D005F90  30420006   ANDI V0, V0, 6
9D005F94  10400005   BEQ V0, ZERO, 0x9D005FAC
9D005F98  00000000   NOP
3806:                	{
3807:                		CloseSocket();
9D005F9C  0F4014AB   JAL CloseSocket
9D005FA0  00000000   NOP
3808:                		return;
9D005FA4  0B401EE5   J 0x9D007B94
9D005FA8  00000000   NOP
3809:                	}
3810:                
3811:                	//
3812:                	// Third: check the security and precedence
3813:                	//
3814:                	// Feature not supported.  Let's process this segment.
3815:                
3816:                	//
3817:                	// Fifth: check the ACK bit
3818:                	//
3819:                	if(!(localHeaderFlags & ACK))
9D005FAC  93C20030   LBU V0, 48(S8)
9D005FB0  30420010   ANDI V0, V0, 16
9D005FB4  104006E4   BEQ V0, ZERO, 0x9D007B48
9D005FB8  00000000   NOP
3820:                		return;
9D007B48  00000000   NOP
9D007B4C  0B401EE5   J 0x9D007B94
9D007B50  00000000   NOP
3821:                
3822:                	switch(MyTCBStub.smState)
9D005FBC  93828027   LBU V0, -32729(GP)
9D005FC0  00402021   ADDU A0, V0, ZERO
9D005FC4  3C02A000   LUI V0, -24576
9D005FC8  24432CDC   ADDIU V1, V0, 11484
9D005FCC  24020030   ADDIU V0, ZERO, 48
9D005FD0  70821002   MUL V0, A0, V0
9D005FD4  00621021   ADDU V0, V1, V0
9D005FD8  8C420024   LW V0, 36(V0)
9D005FDC  2C43000C   SLTIU V1, V0, 12
9D005FE0  10600009   BEQ V1, ZERO, 0x9D006008
9D005FE4  00000000   NOP
9D005FE8  2C430007   SLTIU V1, V0, 7
9D005FEC  1060002C   BEQ V1, ZERO, 0x9D0060A0
9D005FF0  00000000   NOP
9D005FF4  24030006   ADDIU V1, ZERO, 6
9D005FF8  10430008   BEQ V0, V1, 0x9D00601C
9D005FFC  00000000   NOP
9D006008  2403000C   ADDIU V1, ZERO, 12
9D00600C  10430322   BEQ V0, V1, 0x9D006C98
9D006010  00000000   NOP
3823:                	{
3824:                		case TCP_SYN_RECEIVED:
3825:                			if(localAckNumber != MyTCB.MySEQ)
9D00601C  3C02A000   LUI V0, -24576
9D006020  24422E8C   ADDIU V0, V0, 11916
9D006024  8C430004   LW V1, 4(V0)
9D006028  8FC20024   LW V0, 36(S8)
9D00602C  10620013   BEQ V1, V0, 0x9D00607C
9D006030  00000000   NOP
3826:                			{
3827:                				// Send a RST packet with SEQ = SEG.ACK, but retain our SEQ 
3828:                				// number for arivial of any other correct packets
3829:                				localSeqNumber = MyTCB.MySEQ;	// Save our original SEQ number
9D006034  3C02A000   LUI V0, -24576
9D006038  24422E8C   ADDIU V0, V0, 11916
9D00603C  8C420004   LW V0, 4(V0)
9D006040  AFC20034   SW V0, 52(S8)
3830:                				MyTCB.MySEQ = localAckNumber;	// Set SEQ = SEG.ACK
9D006044  3C02A000   LUI V0, -24576
9D006048  24422E8C   ADDIU V0, V0, 11916
9D00604C  8FC30024   LW V1, 36(S8)
9D006050  AC430004   SW V1, 4(V0)
3831:                				SendTCP(RST, SENDTCP_RESET_TIMERS);		// Send the RST
9D006054  24040004   ADDIU A0, ZERO, 4
9D006058  24050001   ADDIU A1, ZERO, 1
9D00605C  0F400F8B   JAL SendTCP
9D006060  00000000   NOP
3832:                				MyTCB.MySEQ = localSeqNumber;	// Restore original SEQ number
9D006064  3C02A000   LUI V0, -24576
9D006068  24422E8C   ADDIU V0, V0, 11916
9D00606C  8FC30034   LW V1, 52(S8)
9D006070  AC430004   SW V1, 4(V0)
3833:                				return;
9D006074  0B401EE5   J 0x9D007B94
9D006078  00000000   NOP
3834:                			}
3835:                			MyTCBStub.smState = TCP_ESTABLISHED;
9D00607C  93828027   LBU V0, -32729(GP)
9D006080  00402021   ADDU A0, V0, ZERO
9D006084  3C02A000   LUI V0, -24576
9D006088  24432CDC   ADDIU V1, V0, 11484
9D00608C  24020030   ADDIU V0, ZERO, 48
9D006090  70821002   MUL V0, A0, V0
9D006094  00621021   ADDU V0, V1, V0
9D006098  24030007   ADDIU V1, ZERO, 7
9D00609C  AC430024   SW V1, 36(V0)
3836:                			// No break
3837:                
3838:                		case TCP_ESTABLISHED:
3839:                		case TCP_FIN_WAIT_1:
3840:                		case TCP_FIN_WAIT_2:
3841:                		case TCP_CLOSE_WAIT:
3842:                		case TCP_CLOSING:
3843:                			// Calculate what the highest possible SEQ number in our TX FIFO is
3844:                			wTemp = MyTCBStub.txHead - MyTCB.txUnackedTail;
9D0060A0  93828027   LBU V0, -32729(GP)
9D0060A4  00402021   ADDU A0, V0, ZERO
9D0060A8  3C02A000   LUI V0, -24576
9D0060AC  24432CDC   ADDIU V1, V0, 11484
9D0060B0  24020030   ADDIU V0, ZERO, 48
9D0060B4  70821002   MUL V0, A0, V0
9D0060B8  00621021   ADDU V0, V1, V0
9D0060BC  8C43000C   LW V1, 12(V0)
9D0060C0  3C02A000   LUI V0, -24576
9D0060C4  24422E8C   ADDIU V0, V0, 11916
9D0060C8  8C42000C   LW V0, 12(V0)
9D0060CC  00621023   SUBU V0, V1, V0
9D0060D0  AFC2001C   SW V0, 28(S8)
3845:                			if((SHORT)wTemp < (SHORT)0)
9D0060D4  8FC2001C   LW V0, 28(S8)
9D0060D8  7C021620   SEH V0, V0
9D0060DC  04410015   BGEZ V0, 0x9D006134
9D0060E0  00000000   NOP
3846:                				wTemp += MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart;
9D0060E4  93828027   LBU V0, -32729(GP)
9D0060E8  00402021   ADDU A0, V0, ZERO
9D0060EC  3C02A000   LUI V0, -24576
9D0060F0  24432CDC   ADDIU V1, V0, 11484
9D0060F4  24020030   ADDIU V0, ZERO, 48
9D0060F8  70821002   MUL V0, A0, V0
9D0060FC  00621021   ADDU V0, V1, V0
9D006100  8C430004   LW V1, 4(V0)
9D006104  93828027   LBU V0, -32729(GP)
9D006108  00402821   ADDU A1, V0, ZERO
9D00610C  3C02A000   LUI V0, -24576
9D006110  24040030   ADDIU A0, ZERO, 48
9D006114  70A42002   MUL A0, A1, A0
9D006118  24422CDC   ADDIU V0, V0, 11484
9D00611C  00821021   ADDU V0, A0, V0
9D006120  8C420000   LW V0, 0(V0)
9D006124  00621023   SUBU V0, V1, V0
9D006128  8FC3001C   LW V1, 28(S8)
9D00612C  00621021   ADDU V0, V1, V0
9D006130  AFC2001C   SW V0, 28(S8)
3847:                			dwTemp = MyTCB.MySEQ + (DWORD)wTemp;
9D006134  3C02A000   LUI V0, -24576
9D006138  24422E8C   ADDIU V0, V0, 11916
9D00613C  8C430004   LW V1, 4(V0)
9D006140  8FC2001C   LW V0, 28(S8)
9D006144  00621021   ADDU V0, V1, V0
9D006148  AFC20018   SW V0, 24(S8)
3848:                
3849:                			// Drop the packet if it ACKs something we haven't sent
3850:                            dwTemp = (LONG)localAckNumber - (LONG)dwTemp;
9D00614C  8FC30024   LW V1, 36(S8)
9D006150  8FC20018   LW V0, 24(S8)
9D006154  00621023   SUBU V0, V1, V0
9D006158  AFC20018   SW V0, 24(S8)
3851:                            if((LONG)dwTemp > 0)
9D00615C  8FC20018   LW V0, 24(S8)
9D006160  18400015   BLEZ V0, 0x9D0061B8
9D006164  00000000   NOP
3852:                            {   // acknowledged more than we've sent??
3853:                                if(!MyTCB.flags.bFINSent || dwTemp != 1)
9D006168  3C02A000   LUI V0, -24576
9D00616C  24422E8C   ADDIU V0, V0, 11916
9D006170  8C430024   LW V1, 36(V0)
9D006174  3C020001   LUI V0, 1
9D006178  00621024   AND V0, V1, V0
9D00617C  10400005   BEQ V0, ZERO, 0x9D006194
9D006180  00000000   NOP
9D006184  8FC30018   LW V1, 24(S8)
9D006188  24020001   ADDIU V0, ZERO, 1
9D00618C  10620007   BEQ V1, V0, 0x9D0061AC
9D006190  00000000   NOP
3854:                                {
3855:                                    SendTCP(ACK, 0);
9D006194  24040010   ADDIU A0, ZERO, 16
9D006198  00002821   ADDU A1, ZERO, ZERO
9D00619C  0F400F8B   JAL SendTCP
9D0061A0  00000000   NOP
3856:                                    return;
9D0061A4  0B401EE5   J 0x9D007B94
9D0061A8  00000000   NOP
3857:                                }
3858:                                else
3859:                                {
3860:                                    localAckNumber--;   // since we don't count the FIN anyway
9D0061AC  8FC20024   LW V0, 36(S8)
9D0061B0  2442FFFF   ADDIU V0, V0, -1
9D0061B4  AFC20024   SW V0, 36(S8)
3861:                                }
3862:                            }
3863:                
3864:                			// Throw away all ACKnowledged TX data:
3865:                			// Calculate what the last acknowledged sequence number was (ignoring any FINs we sent)
3866:                			dwTemp = MyTCB.MySEQ - (LONG)(SHORT)(MyTCB.txUnackedTail - MyTCBStub.txTail);
9D0061B8  3C02A000   LUI V0, -24576
9D0061BC  24422E8C   ADDIU V0, V0, 11916
9D0061C0  8C430004   LW V1, 4(V0)
9D0061C4  3C02A000   LUI V0, -24576
9D0061C8  24422E8C   ADDIU V0, V0, 11916
9D0061CC  8C42000C   LW V0, 12(V0)
9D0061D0  3044FFFF   ANDI A0, V0, -1
9D0061D4  93828027   LBU V0, -32729(GP)
9D0061D8  00403021   ADDU A2, V0, ZERO
9D0061DC  3C02A000   LUI V0, -24576
9D0061E0  24050030   ADDIU A1, ZERO, 48
9D0061E4  70C52802   MUL A1, A2, A1
9D0061E8  24422CDC   ADDIU V0, V0, 11484
9D0061EC  00A21021   ADDU V0, A1, V0
9D0061F0  8C420010   LW V0, 16(V0)
9D0061F4  3042FFFF   ANDI V0, V0, -1
9D0061F8  00821023   SUBU V0, A0, V0
9D0061FC  3042FFFF   ANDI V0, V0, -1
9D006200  7C021620   SEH V0, V0
9D006204  00621023   SUBU V0, V1, V0
9D006208  AFC20018   SW V0, 24(S8)
3867:                			if(MyTCB.txUnackedTail < MyTCBStub.txTail)
9D00620C  3C02A000   LUI V0, -24576
9D006210  24422E8C   ADDIU V0, V0, 11916
9D006214  8C43000C   LW V1, 12(V0)
9D006218  93828027   LBU V0, -32729(GP)
9D00621C  00402821   ADDU A1, V0, ZERO
9D006220  3C02A000   LUI V0, -24576
9D006224  24040030   ADDIU A0, ZERO, 48
9D006228  70A42002   MUL A0, A1, A0
9D00622C  24422CDC   ADDIU V0, V0, 11484
9D006230  00821021   ADDU V0, A0, V0
9D006234  8C420010   LW V0, 16(V0)
9D006238  0062102B   SLTU V0, V1, V0
9D00623C  10400015   BEQ V0, ZERO, 0x9D006294
9D006240  00000000   NOP
3868:                				dwTemp -= MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart;
9D006244  93828027   LBU V0, -32729(GP)
9D006248  00402021   ADDU A0, V0, ZERO
9D00624C  3C02A000   LUI V0, -24576
9D006250  24030030   ADDIU V1, ZERO, 48
9D006254  70831802   MUL V1, A0, V1
9D006258  24422CDC   ADDIU V0, V0, 11484
9D00625C  00621021   ADDU V0, V1, V0
9D006260  8C430000   LW V1, 0(V0)
9D006264  93828027   LBU V0, -32729(GP)
9D006268  00402821   ADDU A1, V0, ZERO
9D00626C  3C02A000   LUI V0, -24576
9D006270  24442CDC   ADDIU A0, V0, 11484
9D006274  24020030   ADDIU V0, ZERO, 48
9D006278  70A21002   MUL V0, A1, V0
9D00627C  00821021   ADDU V0, A0, V0
9D006280  8C420004   LW V0, 4(V0)
9D006284  00621023   SUBU V0, V1, V0
9D006288  8FC30018   LW V1, 24(S8)
9D00628C  00621021   ADDU V0, V1, V0
9D006290  AFC20018   SW V0, 24(S8)
3869:                	
3870:                			// Calcluate how many bytes were ACKed with this packet
3871:                			dwTemp = localAckNumber - dwTemp;
9D006294  8FC30024   LW V1, 36(S8)
9D006298  8FC20018   LW V0, 24(S8)
9D00629C  00621023   SUBU V0, V1, V0
9D0062A0  AFC20018   SW V0, 24(S8)
3872:                			if(((LONG)(dwTemp) > (LONG)0) && (dwTemp <= MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart))
9D0062A4  8FC20018   LW V0, 24(S8)
9D0062A8  18400115   BLEZ V0, 0x9D006700
9D0062AC  00000000   NOP
9D0062B0  93828027   LBU V0, -32729(GP)
9D0062B4  00402021   ADDU A0, V0, ZERO
9D0062B8  3C02A000   LUI V0, -24576
9D0062BC  24432CDC   ADDIU V1, V0, 11484
9D0062C0  24020030   ADDIU V0, ZERO, 48
9D0062C4  70821002   MUL V0, A0, V0
9D0062C8  00621021   ADDU V0, V1, V0
9D0062CC  8C430004   LW V1, 4(V0)
9D0062D0  93828027   LBU V0, -32729(GP)
9D0062D4  00402821   ADDU A1, V0, ZERO
9D0062D8  3C02A000   LUI V0, -24576
9D0062DC  24040030   ADDIU A0, ZERO, 48
9D0062E0  70A42002   MUL A0, A1, A0
9D0062E4  24422CDC   ADDIU V0, V0, 11484
9D0062E8  00821021   ADDU V0, A0, V0
9D0062EC  8C420000   LW V0, 0(V0)
9D0062F0  00621823   SUBU V1, V1, V0
9D0062F4  8FC20018   LW V0, 24(S8)
9D0062F8  0062102B   SLTU V0, V1, V0
9D0062FC  14400100   BNE V0, ZERO, 0x9D006700
9D006300  00000000   NOP
3873:                			{
3874:                				MyTCB.flags.bRXNoneACKed1 = 0;
9D006304  3C02A000   LUI V0, -24576
9D006308  24432E8C   ADDIU V1, V0, 11916
9D00630C  8C620024   LW V0, 36(V1)
9D006310  7C029CC4   INS V0, ZERO, 19, 1
9D006314  AC620024   SW V0, 36(V1)
3875:                				MyTCB.flags.bRXNoneACKed2 = 0;
9D006318  3C02A000   LUI V0, -24576
9D00631C  24432E8C   ADDIU V1, V0, 11916
9D006320  8C620024   LW V0, 36(V1)
9D006324  7C02A504   INS V0, ZERO, 20, 1
9D006328  AC620024   SW V0, 36(V1)
3876:                				MyTCBStub.Flags.bHalfFullFlush = FALSE;
9D00632C  93828027   LBU V0, -32729(GP)
9D006330  00402021   ADDU A0, V0, ZERO
9D006334  3C02A000   LUI V0, -24576
9D006338  24030030   ADDIU V1, ZERO, 48
9D00633C  70831802   MUL V1, A0, V1
9D006340  24422CDC   ADDIU V0, V0, 11484
9D006344  00621821   ADDU V1, V1, V0
9D006348  8C620028   LW V0, 40(V1)
9D00634C  7C024204   INS V0, ZERO, 8, 1
9D006350  AC620028   SW V0, 40(V1)
3877:                	
3878:                				// Bytes ACKed, free up the TX FIFO space
3879:                				wTemp = MyTCBStub.txTail;
9D006354  93828027   LBU V0, -32729(GP)
9D006358  00402021   ADDU A0, V0, ZERO
9D00635C  3C02A000   LUI V0, -24576
9D006360  24030030   ADDIU V1, ZERO, 48
9D006364  70831802   MUL V1, A0, V1
9D006368  24422CDC   ADDIU V0, V0, 11484
9D00636C  00621021   ADDU V0, V1, V0
9D006370  8C420010   LW V0, 16(V0)
9D006374  AFC2001C   SW V0, 28(S8)
3880:                				MyTCBStub.txTail += dwTemp;
9D006378  93828027   LBU V0, -32729(GP)
9D00637C  00402821   ADDU A1, V0, ZERO
9D006380  93828027   LBU V0, -32729(GP)
9D006384  00402021   ADDU A0, V0, ZERO
9D006388  3C02A000   LUI V0, -24576
9D00638C  24030030   ADDIU V1, ZERO, 48
9D006390  70831802   MUL V1, A0, V1
9D006394  24422CDC   ADDIU V0, V0, 11484
9D006398  00621021   ADDU V0, V1, V0
9D00639C  8C430010   LW V1, 16(V0)
9D0063A0  8FC20018   LW V0, 24(S8)
9D0063A4  00621821   ADDU V1, V1, V0
9D0063A8  3C02A000   LUI V0, -24576
9D0063AC  24040030   ADDIU A0, ZERO, 48
9D0063B0  70A42002   MUL A0, A1, A0
9D0063B4  24422CDC   ADDIU V0, V0, 11484
9D0063B8  00821021   ADDU V0, A0, V0
9D0063BC  AC430010   SW V1, 16(V0)
3881:                				if(MyTCB.txUnackedTail >= wTemp)
9D0063C0  3C02A000   LUI V0, -24576
9D0063C4  24422E8C   ADDIU V0, V0, 11916
9D0063C8  8C43000C   LW V1, 12(V0)
9D0063CC  8FC2001C   LW V0, 28(S8)
9D0063D0  0062102B   SLTU V0, V1, V0
9D0063D4  1440002F   BNE V0, ZERO, 0x9D006494
9D0063D8  00000000   NOP
3882:                				{
3883:                					if(MyTCB.txUnackedTail < MyTCBStub.txTail)
9D0063DC  3C02A000   LUI V0, -24576
9D0063E0  24422E8C   ADDIU V0, V0, 11916
9D0063E4  8C43000C   LW V1, 12(V0)
9D0063E8  93828027   LBU V0, -32729(GP)
9D0063EC  00402821   ADDU A1, V0, ZERO
9D0063F0  3C02A000   LUI V0, -24576
9D0063F4  24040030   ADDIU A0, ZERO, 48
9D0063F8  70A42002   MUL A0, A1, A0
9D0063FC  24422CDC   ADDIU V0, V0, 11484
9D006400  00821021   ADDU V0, A0, V0
9D006404  8C420010   LW V0, 16(V0)
9D006408  0062102B   SLTU V0, V1, V0
9D00640C  1040005F   BEQ V0, ZERO, 0x9D00658C
9D006410  00000000   NOP
3884:                					{
3885:                						MyTCB.MySEQ += MyTCBStub.txTail - MyTCB.txUnackedTail;
9D006414  3C02A000   LUI V0, -24576
9D006418  24422E8C   ADDIU V0, V0, 11916
9D00641C  8C430004   LW V1, 4(V0)
9D006420  93828027   LBU V0, -32729(GP)
9D006424  00402821   ADDU A1, V0, ZERO
9D006428  3C02A000   LUI V0, -24576
9D00642C  24040030   ADDIU A0, ZERO, 48
9D006430  70A42002   MUL A0, A1, A0
9D006434  24422CDC   ADDIU V0, V0, 11484
9D006438  00821021   ADDU V0, A0, V0
9D00643C  8C440010   LW A0, 16(V0)
9D006440  3C02A000   LUI V0, -24576
9D006444  24422E8C   ADDIU V0, V0, 11916
9D006448  8C42000C   LW V0, 12(V0)
9D00644C  00821023   SUBU V0, A0, V0
9D006450  00621821   ADDU V1, V1, V0
9D006454  3C02A000   LUI V0, -24576
9D006458  24422E8C   ADDIU V0, V0, 11916
9D00645C  AC430004   SW V1, 4(V0)
3886:                						MyTCB.txUnackedTail = MyTCBStub.txTail;
9D006460  93828027   LBU V0, -32729(GP)
9D006464  00402021   ADDU A0, V0, ZERO
9D006468  3C02A000   LUI V0, -24576
9D00646C  24030030   ADDIU V1, ZERO, 48
9D006470  70831802   MUL V1, A0, V1
9D006474  24422CDC   ADDIU V0, V0, 11484
9D006478  00621021   ADDU V0, V1, V0
9D00647C  8C430010   LW V1, 16(V0)
9D006480  3C02A000   LUI V0, -24576
9D006484  24422E8C   ADDIU V0, V0, 11916
9D006488  AC43000C   SW V1, 12(V0)
9D00648C  0B401963   J 0x9D00658C
9D006490  00000000   NOP
3887:                					}
3888:                				}
3889:                				else
3890:                				{
3891:                					wTemp = MyTCB.txUnackedTail + (MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart);
9D006494  3C02A000   LUI V0, -24576
9D006498  24422E8C   ADDIU V0, V0, 11916
9D00649C  8C43000C   LW V1, 12(V0)
9D0064A0  93828027   LBU V0, -32729(GP)
9D0064A4  00402821   ADDU A1, V0, ZERO
9D0064A8  3C02A000   LUI V0, -24576
9D0064AC  24442CDC   ADDIU A0, V0, 11484
9D0064B0  24020030   ADDIU V0, ZERO, 48
9D0064B4  70A21002   MUL V0, A1, V0
9D0064B8  00821021   ADDU V0, A0, V0
9D0064BC  8C440004   LW A0, 4(V0)
9D0064C0  93828027   LBU V0, -32729(GP)
9D0064C4  00403021   ADDU A2, V0, ZERO
9D0064C8  3C02A000   LUI V0, -24576
9D0064CC  24050030   ADDIU A1, ZERO, 48
9D0064D0  70C52802   MUL A1, A2, A1
9D0064D4  24422CDC   ADDIU V0, V0, 11484
9D0064D8  00A21021   ADDU V0, A1, V0
9D0064DC  8C420000   LW V0, 0(V0)
9D0064E0  00821023   SUBU V0, A0, V0
9D0064E4  00621021   ADDU V0, V1, V0
9D0064E8  AFC2001C   SW V0, 28(S8)
3892:                					if(wTemp < MyTCBStub.txTail)
9D0064EC  93828027   LBU V0, -32729(GP)
9D0064F0  00402021   ADDU A0, V0, ZERO
9D0064F4  3C02A000   LUI V0, -24576
9D0064F8  24030030   ADDIU V1, ZERO, 48
9D0064FC  70831802   MUL V1, A0, V1
9D006500  24422CDC   ADDIU V0, V0, 11484
9D006504  00621021   ADDU V0, V1, V0
9D006508  8C430010   LW V1, 16(V0)
9D00650C  8FC2001C   LW V0, 28(S8)
9D006510  0043102B   SLTU V0, V0, V1
9D006514  1040001D   BEQ V0, ZERO, 0x9D00658C
9D006518  00000000   NOP
3893:                					{
3894:                						MyTCB.MySEQ += MyTCBStub.txTail - wTemp;
9D00651C  3C02A000   LUI V0, -24576
9D006520  24422E8C   ADDIU V0, V0, 11916
9D006524  8C430004   LW V1, 4(V0)
9D006528  93828027   LBU V0, -32729(GP)
9D00652C  00402821   ADDU A1, V0, ZERO
9D006530  3C02A000   LUI V0, -24576
9D006534  24040030   ADDIU A0, ZERO, 48
9D006538  70A42002   MUL A0, A1, A0
9D00653C  24422CDC   ADDIU V0, V0, 11484
9D006540  00821021   ADDU V0, A0, V0
9D006544  8C440010   LW A0, 16(V0)
9D006548  8FC2001C   LW V0, 28(S8)
9D00654C  00821023   SUBU V0, A0, V0
9D006550  00621821   ADDU V1, V1, V0
9D006554  3C02A000   LUI V0, -24576
9D006558  24422E8C   ADDIU V0, V0, 11916
9D00655C  AC430004   SW V1, 4(V0)
3895:                						MyTCB.txUnackedTail = MyTCBStub.txTail;
9D006560  93828027   LBU V0, -32729(GP)
9D006564  00402021   ADDU A0, V0, ZERO
9D006568  3C02A000   LUI V0, -24576
9D00656C  24030030   ADDIU V1, ZERO, 48
9D006570  70831802   MUL V1, A0, V1
9D006574  24422CDC   ADDIU V0, V0, 11484
9D006578  00621021   ADDU V0, V1, V0
9D00657C  8C430010   LW V1, 16(V0)
9D006580  3C02A000   LUI V0, -24576
9D006584  24422E8C   ADDIU V0, V0, 11916
9D006588  AC43000C   SW V1, 12(V0)
3896:                					}
3897:                				}
3898:                				if(MyTCBStub.txTail >= MyTCBStub.bufferRxStart)
9D00658C  93828027   LBU V0, -32729(GP)
9D006590  00402021   ADDU A0, V0, ZERO
9D006594  3C02A000   LUI V0, -24576
9D006598  24030030   ADDIU V1, ZERO, 48
9D00659C  70831802   MUL V1, A0, V1
9D0065A0  24422CDC   ADDIU V0, V0, 11484
9D0065A4  00621021   ADDU V0, V1, V0
9D0065A8  8C430010   LW V1, 16(V0)
9D0065AC  93828027   LBU V0, -32729(GP)
9D0065B0  00402821   ADDU A1, V0, ZERO
9D0065B4  3C02A000   LUI V0, -24576
9D0065B8  24442CDC   ADDIU A0, V0, 11484
9D0065BC  24020030   ADDIU V0, ZERO, 48
9D0065C0  70A21002   MUL V0, A1, V0
9D0065C4  00821021   ADDU V0, A0, V0
9D0065C8  8C420004   LW V0, 4(V0)
9D0065CC  0062102B   SLTU V0, V1, V0
9D0065D0  14400023   BNE V0, ZERO, 0x9D006660
9D0065D4  00000000   NOP
3899:                					MyTCBStub.txTail -= MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart;
9D0065D8  93828027   LBU V0, -32729(GP)
9D0065DC  00403021   ADDU A2, V0, ZERO
9D0065E0  93828027   LBU V0, -32729(GP)
9D0065E4  00402021   ADDU A0, V0, ZERO
9D0065E8  3C02A000   LUI V0, -24576
9D0065EC  24030030   ADDIU V1, ZERO, 48
9D0065F0  70831802   MUL V1, A0, V1
9D0065F4  24422CDC   ADDIU V0, V0, 11484
9D0065F8  00621021   ADDU V0, V1, V0
9D0065FC  8C430010   LW V1, 16(V0)
9D006600  93828027   LBU V0, -32729(GP)
9D006604  00402821   ADDU A1, V0, ZERO
9D006608  3C02A000   LUI V0, -24576
9D00660C  24040030   ADDIU A0, ZERO, 48
9D006610  70A42002   MUL A0, A1, A0
9D006614  24422CDC   ADDIU V0, V0, 11484
9D006618  00821021   ADDU V0, A0, V0
9D00661C  8C440000   LW A0, 0(V0)
9D006620  93828027   LBU V0, -32729(GP)
9D006624  00403821   ADDU A3, V0, ZERO
9D006628  3C02A000   LUI V0, -24576
9D00662C  24452CDC   ADDIU A1, V0, 11484
9D006630  24020030   ADDIU V0, ZERO, 48
9D006634  70E21002   MUL V0, A3, V0
9D006638  00A21021   ADDU V0, A1, V0
9D00663C  8C420004   LW V0, 4(V0)
9D006640  00821023   SUBU V0, A0, V0
9D006644  00621821   ADDU V1, V1, V0
9D006648  3C02A000   LUI V0, -24576
9D00664C  24040030   ADDIU A0, ZERO, 48
9D006650  70C42002   MUL A0, A2, A0
9D006654  24422CDC   ADDIU V0, V0, 11484
9D006658  00821021   ADDU V0, A0, V0
9D00665C  AC430010   SW V1, 16(V0)
3900:                				if(MyTCB.txUnackedTail >= MyTCBStub.bufferRxStart)
9D006660  3C02A000   LUI V0, -24576
9D006664  24422E8C   ADDIU V0, V0, 11916
9D006668  8C43000C   LW V1, 12(V0)
9D00666C  93828027   LBU V0, -32729(GP)
9D006670  00402821   ADDU A1, V0, ZERO
9D006674  3C02A000   LUI V0, -24576
9D006678  24442CDC   ADDIU A0, V0, 11484
9D00667C  24020030   ADDIU V0, ZERO, 48
9D006680  70A21002   MUL V0, A1, V0
9D006684  00821021   ADDU V0, A0, V0
9D006688  8C420004   LW V0, 4(V0)
9D00668C  0062102B   SLTU V0, V1, V0
9D006690  14400099   BNE V0, ZERO, 0x9D0068F8
9D006694  00000000   NOP
9D0066F8  0B401A3E   J 0x9D0068F8
9D0066FC  00000000   NOP
3901:                					MyTCB.txUnackedTail -= MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart;
9D006698  3C02A000   LUI V0, -24576
9D00669C  24422E8C   ADDIU V0, V0, 11916
9D0066A0  8C43000C   LW V1, 12(V0)
9D0066A4  93828027   LBU V0, -32729(GP)
9D0066A8  00402821   ADDU A1, V0, ZERO
9D0066AC  3C02A000   LUI V0, -24576
9D0066B0  24040030   ADDIU A0, ZERO, 48
9D0066B4  70A42002   MUL A0, A1, A0
9D0066B8  24422CDC   ADDIU V0, V0, 11484
9D0066BC  00821021   ADDU V0, A0, V0
9D0066C0  8C440000   LW A0, 0(V0)
9D0066C4  93828027   LBU V0, -32729(GP)
9D0066C8  00403021   ADDU A2, V0, ZERO
9D0066CC  3C02A000   LUI V0, -24576
9D0066D0  24452CDC   ADDIU A1, V0, 11484
9D0066D4  24020030   ADDIU V0, ZERO, 48
9D0066D8  70C21002   MUL V0, A2, V0
9D0066DC  00A21021   ADDU V0, A1, V0
9D0066E0  8C420004   LW V0, 4(V0)
9D0066E4  00821023   SUBU V0, A0, V0
9D0066E8  00621821   ADDU V1, V1, V0
9D0066EC  3C02A000   LUI V0, -24576
9D0066F0  24422E8C   ADDIU V0, V0, 11916
9D0066F4  AC43000C   SW V1, 12(V0)
3902:                			}
3903:                			else
3904:                			{
3905:                				// See if we have outstanding TX data that is waiting for an ACK
3906:                				if(MyTCBStub.txTail != MyTCB.txUnackedTail)
9D006700  93828027   LBU V0, -32729(GP)
9D006704  00402021   ADDU A0, V0, ZERO
9D006708  3C02A000   LUI V0, -24576
9D00670C  24030030   ADDIU V1, ZERO, 48
9D006710  70831802   MUL V1, A0, V1
9D006714  24422CDC   ADDIU V0, V0, 11484
9D006718  00621021   ADDU V0, V1, V0
9D00671C  8C430010   LW V1, 16(V0)
9D006720  3C02A000   LUI V0, -24576
9D006724  24422E8C   ADDIU V0, V0, 11916
9D006728  8C42000C   LW V0, 12(V0)
9D00672C  10620072   BEQ V1, V0, 0x9D0068F8
9D006730  00000000   NOP
3907:                				{
3908:                					if(MyTCB.flags.bRXNoneACKed1)
9D006734  3C02A000   LUI V0, -24576
9D006738  24422E8C   ADDIU V0, V0, 11916
9D00673C  8C430024   LW V1, 36(V0)
9D006740  3C020008   LUI V0, 8
9D006744  00621024   AND V0, V1, V0
9D006748  10400065   BEQ V0, ZERO, 0x9D0068E0
9D00674C  00000000   NOP
3909:                					{
3910:                						if(MyTCB.flags.bRXNoneACKed2)
9D006750  3C02A000   LUI V0, -24576
9D006754  24422E8C   ADDIU V0, V0, 11916
9D006758  8C430024   LW V1, 36(V0)
9D00675C  3C020010   LUI V0, 16
9D006760  00621024   AND V0, V1, V0
9D006764  10400058   BEQ V0, ZERO, 0x9D0068C8
9D006768  00000000   NOP
3911:                						{
3912:                							// Set up to perform a fast retransmission
3913:                							// Roll back unacknowledged TX tail pointer to cause retransmit to occur
3914:                							MyTCB.MySEQ -= (LONG)(SHORT)(MyTCB.txUnackedTail - MyTCBStub.txTail);
9D00676C  3C02A000   LUI V0, -24576
9D006770  24422E8C   ADDIU V0, V0, 11916
9D006774  8C430004   LW V1, 4(V0)
9D006778  3C02A000   LUI V0, -24576
9D00677C  24422E8C   ADDIU V0, V0, 11916
9D006780  8C42000C   LW V0, 12(V0)
9D006784  3044FFFF   ANDI A0, V0, -1
9D006788  93828027   LBU V0, -32729(GP)
9D00678C  00403021   ADDU A2, V0, ZERO
9D006790  3C02A000   LUI V0, -24576
9D006794  24050030   ADDIU A1, ZERO, 48
9D006798  70C52802   MUL A1, A2, A1
9D00679C  24422CDC   ADDIU V0, V0, 11484
9D0067A0  00A21021   ADDU V0, A1, V0
9D0067A4  8C420010   LW V0, 16(V0)
9D0067A8  3042FFFF   ANDI V0, V0, -1
9D0067AC  00821023   SUBU V0, A0, V0
9D0067B0  3042FFFF   ANDI V0, V0, -1
9D0067B4  7C021620   SEH V0, V0
9D0067B8  00621823   SUBU V1, V1, V0
9D0067BC  3C02A000   LUI V0, -24576
9D0067C0  24422E8C   ADDIU V0, V0, 11916
9D0067C4  AC430004   SW V1, 4(V0)
3915:                							if(MyTCB.txUnackedTail < MyTCBStub.txTail)
9D0067C8  3C02A000   LUI V0, -24576
9D0067CC  24422E8C   ADDIU V0, V0, 11916
9D0067D0  8C43000C   LW V1, 12(V0)
9D0067D4  93828027   LBU V0, -32729(GP)
9D0067D8  00402821   ADDU A1, V0, ZERO
9D0067DC  3C02A000   LUI V0, -24576
9D0067E0  24040030   ADDIU A0, ZERO, 48
9D0067E4  70A42002   MUL A0, A1, A0
9D0067E8  24422CDC   ADDIU V0, V0, 11484
9D0067EC  00821021   ADDU V0, A0, V0
9D0067F0  8C420010   LW V0, 16(V0)
9D0067F4  0062102B   SLTU V0, V1, V0
9D0067F8  1040001D   BEQ V0, ZERO, 0x9D006870
9D0067FC  00000000   NOP
3916:                								MyTCB.MySEQ -= (LONG)(SHORT)(MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart);
9D006800  3C02A000   LUI V0, -24576
9D006804  24422E8C   ADDIU V0, V0, 11916
9D006808  8C430004   LW V1, 4(V0)
9D00680C  93828027   LBU V0, -32729(GP)
9D006810  00402821   ADDU A1, V0, ZERO
9D006814  3C02A000   LUI V0, -24576
9D006818  24442CDC   ADDIU A0, V0, 11484
9D00681C  24020030   ADDIU V0, ZERO, 48
9D006820  70A21002   MUL V0, A1, V0
9D006824  00821021   ADDU V0, A0, V0
9D006828  8C420004   LW V0, 4(V0)
9D00682C  3044FFFF   ANDI A0, V0, -1
9D006830  93828027   LBU V0, -32729(GP)
9D006834  00403021   ADDU A2, V0, ZERO
9D006838  3C02A000   LUI V0, -24576
9D00683C  24050030   ADDIU A1, ZERO, 48
9D006840  70C52802   MUL A1, A2, A1
9D006844  24422CDC   ADDIU V0, V0, 11484
9D006848  00A21021   ADDU V0, A1, V0
9D00684C  8C420000   LW V0, 0(V0)
9D006850  3042FFFF   ANDI V0, V0, -1
9D006854  00821023   SUBU V0, A0, V0
9D006858  3042FFFF   ANDI V0, V0, -1
9D00685C  7C021620   SEH V0, V0
9D006860  00621823   SUBU V1, V1, V0
9D006864  3C02A000   LUI V0, -24576
9D006868  24422E8C   ADDIU V0, V0, 11916
9D00686C  AC430004   SW V1, 4(V0)
3917:                							MyTCB.txUnackedTail = MyTCBStub.txTail;
9D006870  93828027   LBU V0, -32729(GP)
9D006874  00402021   ADDU A0, V0, ZERO
9D006878  3C02A000   LUI V0, -24576
9D00687C  24030030   ADDIU V1, ZERO, 48
9D006880  70831802   MUL V1, A0, V1
9D006884  24422CDC   ADDIU V0, V0, 11484
9D006888  00621021   ADDU V0, V1, V0
9D00688C  8C430010   LW V1, 16(V0)
9D006890  3C02A000   LUI V0, -24576
9D006894  24422E8C   ADDIU V0, V0, 11916
9D006898  AC43000C   SW V1, 12(V0)
3918:                							MyTCBStub.Flags.bTXASAPWithoutTimerReset = 1;
9D00689C  93828027   LBU V0, -32729(GP)
9D0068A0  00402021   ADDU A0, V0, ZERO
9D0068A4  3C02A000   LUI V0, -24576
9D0068A8  24030030   ADDIU V1, ZERO, 48
9D0068AC  70831802   MUL V1, A0, V1
9D0068B0  24422CDC   ADDIU V0, V0, 11484
9D0068B4  00621821   ADDU V1, V1, V0
9D0068B8  8C620028   LW V0, 40(V1)
9D0068BC  24040001   ADDIU A0, ZERO, 1
9D0068C0  7C825284   INS V0, A0, 10, 1
9D0068C4  AC620028   SW V0, 40(V1)
3919:                						}
3920:                						MyTCB.flags.bRXNoneACKed2 = 1;
9D0068C8  3C02A000   LUI V0, -24576
9D0068CC  24432E8C   ADDIU V1, V0, 11916
9D0068D0  8C620024   LW V0, 36(V1)
9D0068D4  24040001   ADDIU A0, ZERO, 1
9D0068D8  7C82A504   INS V0, A0, 20, 1
9D0068DC  AC620024   SW V0, 36(V1)
3921:                					}
3922:                					MyTCB.flags.bRXNoneACKed1 = 1;
9D0068E0  3C02A000   LUI V0, -24576
9D0068E4  24432E8C   ADDIU V1, V0, 11916
9D0068E8  8C620024   LW V0, 36(V1)
9D0068EC  24040001   ADDIU A0, ZERO, 1
9D0068F0  7C829CC4   INS V0, A0, 19, 1
9D0068F4  AC620024   SW V0, 36(V1)
3923:                				}
3924:                			}
3925:                
3926:                			// No need to keep our retransmit timer going if we have nothing that needs ACKing anymore
3927:                			if(MyTCBStub.txTail == MyTCBStub.txHead)
9D0068F8  93828027   LBU V0, -32729(GP)
9D0068FC  00402021   ADDU A0, V0, ZERO
9D006900  3C02A000   LUI V0, -24576
9D006904  24030030   ADDIU V1, ZERO, 48
9D006908  70831802   MUL V1, A0, V1
9D00690C  24422CDC   ADDIU V0, V0, 11484
9D006910  00621021   ADDU V0, V1, V0
9D006914  8C430010   LW V1, 16(V0)
9D006918  93828027   LBU V0, -32729(GP)
9D00691C  00402821   ADDU A1, V0, ZERO
9D006920  3C02A000   LUI V0, -24576
9D006924  24442CDC   ADDIU A0, V0, 11484
9D006928  24020030   ADDIU V0, ZERO, 48
9D00692C  70A21002   MUL V0, A1, V0
9D006930  00821021   ADDU V0, A0, V0
9D006934  8C42000C   LW V0, 12(V0)
9D006938  14620048   BNE V1, V0, 0x9D006A5C
9D00693C  00000000   NOP
3928:                			{
3929:                				// Make sure there isn't a "FIN byte in our TX FIFO"
3930:                				if(MyTCBStub.Flags.bTXFIN == 0u)
9D006940  93828027   LBU V0, -32729(GP)
9D006944  00402021   ADDU A0, V0, ZERO
9D006948  3C02A000   LUI V0, -24576
9D00694C  24030030   ADDIU V1, ZERO, 48
9D006950  70831802   MUL V1, A0, V1
9D006954  24422CDC   ADDIU V0, V0, 11484
9D006958  00621021   ADDU V0, V1, V0
9D00695C  8C420028   LW V0, 40(V0)
9D006960  7C4202C0   EXT V0, V0, 11, 1
9D006964  304200FF   ANDI V0, V0, 255
9D006968  1440001B   BNE V0, ZERO, 0x9D0069D8
9D00696C  00000000   NOP
3931:                				{
3932:                					// Convert retransmission timer to keep-alive timer
3933:                					#if defined(TCP_KEEP_ALIVE_TIMEOUT)
3934:                						MyTCBStub.eventTime = TickGet() + TCP_KEEP_ALIVE_TIMEOUT;
9D006970  93828027   LBU V0, -32729(GP)
9D006974  00408021   ADDU S0, V0, ZERO
9D006978  0F40CDD6   JAL TickGet
9D00697C  00000000   NOP
9D006980  00401821   ADDU V1, V0, ZERO
9D006984  3C020017   LUI V0, 23
9D006988  3442D784   ORI V0, V0, -10364
9D00698C  00621821   ADDU V1, V1, V0
9D006990  3C02A000   LUI V0, -24576
9D006994  24442CDC   ADDIU A0, V0, 11484
9D006998  24020030   ADDIU V0, ZERO, 48
9D00699C  72021002   MUL V0, S0, V0
9D0069A0  00821021   ADDU V0, A0, V0
9D0069A4  AC43001C   SW V1, 28(V0)
3935:                					#endif
3936:                					MyTCBStub.Flags.bTimerEnabled = 0;
9D0069A8  93828027   LBU V0, -32729(GP)
9D0069AC  00402021   ADDU A0, V0, ZERO
9D0069B0  3C02A000   LUI V0, -24576
9D0069B4  24030030   ADDIU V1, ZERO, 48
9D0069B8  70831802   MUL V1, A0, V1
9D0069BC  24422CDC   ADDIU V0, V0, 11484
9D0069C0  00621821   ADDU V1, V1, V0
9D0069C4  8C620028   LW V0, 40(V1)
9D0069C8  7C022104   INS V0, ZERO, 4, 1
9D0069CC  AC620028   SW V0, 40(V1)
9D0069D0  0B401A97   J 0x9D006A5C
9D0069D4  00000000   NOP
3937:                				}
3938:                				else
3939:                				{
3940:                					// "Throw away" FIN byte from our TX FIFO if it has been ACKed
3941:                					if((MyTCB.MySEQ == localAckNumber) && MyTCB.flags.bFINSent)
9D0069D8  3C02A000   LUI V0, -24576
9D0069DC  24422E8C   ADDIU V0, V0, 11916
9D0069E0  8C430004   LW V1, 4(V0)
9D0069E4  8FC20024   LW V0, 36(S8)
9D0069E8  1462001C   BNE V1, V0, 0x9D006A5C
9D0069EC  00000000   NOP
9D0069F0  3C02A000   LUI V0, -24576
9D0069F4  24422E8C   ADDIU V0, V0, 11916
9D0069F8  8C430024   LW V1, 36(V0)
9D0069FC  3C020001   LUI V0, 1
9D006A00  00621024   AND V0, V1, V0
9D006A04  10400015   BEQ V0, ZERO, 0x9D006A5C
9D006A08  00000000   NOP
3942:                					{
3943:                						MyTCBStub.Flags.bTimerEnabled = 0;
9D006A0C  93828027   LBU V0, -32729(GP)
9D006A10  00402021   ADDU A0, V0, ZERO
9D006A14  3C02A000   LUI V0, -24576
9D006A18  24030030   ADDIU V1, ZERO, 48
9D006A1C  70831802   MUL V1, A0, V1
9D006A20  24422CDC   ADDIU V0, V0, 11484
9D006A24  00621821   ADDU V1, V1, V0
9D006A28  8C620028   LW V0, 40(V1)
9D006A2C  7C022104   INS V0, ZERO, 4, 1
9D006A30  AC620028   SW V0, 40(V1)
3944:                						MyTCBStub.Flags.bTXFIN = 0;
9D006A34  93828027   LBU V0, -32729(GP)
9D006A38  00402021   ADDU A0, V0, ZERO
9D006A3C  3C02A000   LUI V0, -24576
9D006A40  24030030   ADDIU V1, ZERO, 48
9D006A44  70831802   MUL V1, A0, V1
9D006A48  24422CDC   ADDIU V0, V0, 11484
9D006A4C  00621821   ADDU V1, V1, V0
9D006A50  8C620028   LW V0, 40(V1)
9D006A54  7C025AC4   INS V0, ZERO, 11, 1
9D006A58  AC620028   SW V0, 40(V1)
3945:                					}
3946:                				}
3947:                			}
3948:                
3949:                			// The window size advirtised in this packet is adjusted to account 
3950:                			// for any bytes that we have transmitted but haven't been ACKed yet 
3951:                			// by this segment.
3952:                			wNewWindow = h->Window - ((WORD)(MyTCB.MySEQ - localAckNumber));
9D006A5C  8FC20050   LW V0, 80(S8)
9D006A60  9443000E   LHU V1, 14(V0)
9D006A64  8FC20024   LW V0, 36(S8)
9D006A68  3044FFFF   ANDI A0, V0, -1
9D006A6C  3C02A000   LUI V0, -24576
9D006A70  24422E8C   ADDIU V0, V0, 11916
9D006A74  8C420004   LW V0, 4(V0)
9D006A78  3042FFFF   ANDI V0, V0, -1
9D006A7C  00821023   SUBU V0, A0, V0
9D006A80  3042FFFF   ANDI V0, V0, -1
9D006A84  00621021   ADDU V0, V1, V0
9D006A88  A7C2003E   SH V0, 62(S8)
3953:                
3954:                			// Update the local stored copy of the RemoteWindow.
3955:                			// If previously we had a zero window, and now we don't, then 
3956:                			// immediately send whatever was pending.
3957:                			if((MyTCB.remoteWindow == 0u) && wNewWindow)
9D006A8C  3C02A000   LUI V0, -24576
9D006A90  24422E8C   ADDIU V0, V0, 11916
9D006A94  94420014   LHU V0, 20(V0)
9D006A98  1440000F   BNE V0, ZERO, 0x9D006AD8
9D006A9C  00000000   NOP
9D006AA0  97C2003E   LHU V0, 62(S8)
9D006AA4  1040000C   BEQ V0, ZERO, 0x9D006AD8
9D006AA8  00000000   NOP
3958:                				MyTCBStub.Flags.bTXASAP = 1;
9D006AAC  93828027   LBU V0, -32729(GP)
9D006AB0  00402021   ADDU A0, V0, ZERO
9D006AB4  3C02A000   LUI V0, -24576
9D006AB8  24030030   ADDIU V1, ZERO, 48
9D006ABC  70831802   MUL V1, A0, V1
9D006AC0  24422CDC   ADDIU V0, V0, 11484
9D006AC4  00621821   ADDU V1, V1, V0
9D006AC8  8C620028   LW V0, 40(V1)
9D006ACC  24040001   ADDIU A0, ZERO, 1
9D006AD0  7C824A44   INS V0, A0, 9, 1
9D006AD4  AC620028   SW V0, 40(V1)
3959:                			MyTCB.remoteWindow = wNewWindow;
9D006AD8  3C02A000   LUI V0, -24576
9D006ADC  24422E8C   ADDIU V0, V0, 11916
9D006AE0  97C3003E   LHU V1, 62(S8)
9D006AE4  A4430014   SH V1, 20(V0)
3960:                
3961:                			// A couple of states must do all of the TCP_ESTABLISHED stuff, but also a little more
3962:                			if(MyTCBStub.smState == TCP_FIN_WAIT_1)
9D006AE8  93828027   LBU V0, -32729(GP)
9D006AEC  00402021   ADDU A0, V0, ZERO
9D006AF0  3C02A000   LUI V0, -24576
9D006AF4  24432CDC   ADDIU V1, V0, 11484
9D006AF8  24020030   ADDIU V0, ZERO, 48
9D006AFC  70821002   MUL V0, A0, V0
9D006B00  00621021   ADDU V0, V1, V0
9D006B04  8C430024   LW V1, 36(V0)
9D006B08  24020008   ADDIU V0, ZERO, 8
9D006B0C  14620032   BNE V1, V0, 0x9D006BD8
9D006B10  00000000   NOP
3963:                			{
3964:                				// Check to see if our FIN has been ACKnowledged
3965:                				if((MyTCB.MySEQ == localAckNumber) && MyTCB.flags.bFINSent)
9D006B14  3C02A000   LUI V0, -24576
9D006B18  24422E8C   ADDIU V0, V0, 11916
9D006B1C  8C430004   LW V1, 4(V0)
9D006B20  8FC20024   LW V0, 36(S8)
9D006B24  14620067   BNE V1, V0, 0x9D006CC4
9D006B28  00000000   NOP
9D006B2C  3C02A000   LUI V0, -24576
9D006B30  24422E8C   ADDIU V0, V0, 11916
9D006B34  8C430024   LW V1, 36(V0)
9D006B38  3C020001   LUI V0, 1
9D006B3C  00621024   AND V0, V1, V0
9D006B40  10400063   BEQ V0, ZERO, 0x9D006CD0
9D006B44  00000000   NOP
3966:                				{
3967:                					// Reset our timer for forced closure if the remote node 
3968:                					// doesn't send us a FIN in a timely manner.
3969:                					MyTCBStub.eventTime = TickGet() + TCP_FIN_WAIT_2_TIMEOUT;
9D006B48  93828027   LBU V0, -32729(GP)
9D006B4C  00408021   ADDU S0, V0, ZERO
9D006B50  0F40CDD6   JAL TickGet
9D006B54  00000000   NOP
9D006B58  00401821   ADDU V1, V0, ZERO
9D006B5C  3C02000B   LUI V0, 11
9D006B60  3442EBC2   ORI V0, V0, -5182
9D006B64  00621821   ADDU V1, V1, V0
9D006B68  3C02A000   LUI V0, -24576
9D006B6C  24442CDC   ADDIU A0, V0, 11484
9D006B70  24020030   ADDIU V0, ZERO, 48
9D006B74  72021002   MUL V0, S0, V0
9D006B78  00821021   ADDU V0, A0, V0
9D006B7C  AC43001C   SW V1, 28(V0)
3970:                					MyTCBStub.Flags.bTimerEnabled = 1;
9D006B80  93828027   LBU V0, -32729(GP)
9D006B84  00402021   ADDU A0, V0, ZERO
9D006B88  3C02A000   LUI V0, -24576
9D006B8C  24030030   ADDIU V1, ZERO, 48
9D006B90  70831802   MUL V1, A0, V1
9D006B94  24422CDC   ADDIU V0, V0, 11484
9D006B98  00621821   ADDU V1, V1, V0
9D006B9C  8C620028   LW V0, 40(V1)
9D006BA0  24040001   ADDIU A0, ZERO, 1
9D006BA4  7C822104   INS V0, A0, 4, 1
9D006BA8  AC620028   SW V0, 40(V1)
3971:                					MyTCBStub.smState = TCP_FIN_WAIT_2;
9D006BAC  93828027   LBU V0, -32729(GP)
9D006BB0  00402021   ADDU A0, V0, ZERO
9D006BB4  3C02A000   LUI V0, -24576
9D006BB8  24432CDC   ADDIU V1, V0, 11484
9D006BBC  24020030   ADDIU V0, ZERO, 48
9D006BC0  70821002   MUL V0, A0, V0
9D006BC4  00621021   ADDU V0, V1, V0
9D006BC8  24030009   ADDIU V1, ZERO, 9
9D006BCC  AC430024   SW V1, 36(V0)
3972:                				}
3973:                			}
3974:                			else if(MyTCBStub.smState == TCP_FIN_WAIT_2)
9D006BD8  93828027   LBU V0, -32729(GP)
9D006BDC  00402021   ADDU A0, V0, ZERO
9D006BE0  3C02A000   LUI V0, -24576
9D006BE4  24432CDC   ADDIU V1, V0, 11484
9D006BE8  24020030   ADDIU V0, ZERO, 48
9D006BEC  70821002   MUL V0, A0, V0
9D006BF0  00621021   ADDU V0, V1, V0
9D006BF4  8C430024   LW V1, 36(V0)
9D006BF8  24020009   ADDIU V0, ZERO, 9
9D006BFC  14620011   BNE V1, V0, 0x9D006C44
9D006C00  00000000   NOP
3975:                			{
3976:                				// RFC noncompliance:
3977:                				// The remote node should not keep sending us data 
3978:                				// indefinitely after we send a FIN to it.  
3979:                				// However, some bad stacks may still keep sending 
3980:                				// us data indefinitely after ACKing our FIN.  To 
3981:                				// prevent this from locking up our socket, let's 
3982:                				// send a RST right now and close forcefully on 
3983:                				// our side.
3984:                				if(!(localHeaderFlags & FIN))
9D006C04  93C20030   LBU V0, 48(S8)
9D006C08  30420001   ANDI V0, V0, 1
9D006C0C  14400033   BNE V0, ZERO, 0x9D006CDC
9D006C10  00000000   NOP
3985:                				{
3986:                					MyTCB.MySEQ = localAckNumber;	// Set SEQ = SEG.ACK
9D006C14  3C02A000   LUI V0, -24576
9D006C18  24422E8C   ADDIU V0, V0, 11916
9D006C1C  8FC30024   LW V1, 36(S8)
9D006C20  AC430004   SW V1, 4(V0)
3987:                					SendTCP(RST | ACK, 0);
9D006C24  24040014   ADDIU A0, ZERO, 20
9D006C28  00002821   ADDU A1, ZERO, ZERO
9D006C2C  0F400F8B   JAL SendTCP
9D006C30  00000000   NOP
3988:                					CloseSocket();
9D006C34  0F4014AB   JAL CloseSocket
9D006C38  00000000   NOP
3989:                					return;
9D006C3C  0B401EE5   J 0x9D007B94
9D006C40  00000000   NOP
3990:                				}
3991:                			}
3992:                			else if(MyTCBStub.smState == TCP_CLOSING)
9D006C44  93828027   LBU V0, -32729(GP)
9D006C48  00402021   ADDU A0, V0, ZERO
9D006C4C  3C02A000   LUI V0, -24576
9D006C50  24432CDC   ADDIU V1, V0, 11484
9D006C54  24020030   ADDIU V0, ZERO, 48
9D006C58  70821002   MUL V0, A0, V0
9D006C5C  00621021   ADDU V0, V1, V0
9D006C60  8C430024   LW V1, 36(V0)
9D006C64  2402000A   ADDIU V0, ZERO, 10
9D006C68  1462001F   BNE V1, V0, 0x9D006CE8
9D006C6C  00000000   NOP
3993:                			{
3994:                				// Check to see if our FIN has been ACKnowledged
3995:                				if(MyTCB.MySEQ == localAckNumber)
9D006C70  3C02A000   LUI V0, -24576
9D006C74  24422E8C   ADDIU V0, V0, 11916
9D006C78  8C430004   LW V1, 4(V0)
9D006C7C  8FC20024   LW V0, 36(S8)
9D006C80  146203B4   BNE V1, V0, 0x9D007B54
9D006C84  00000000   NOP
3996:                				{
3997:                					// RFC not recommended: We should be going to 
3998:                					// the TCP_TIME_WAIT state right here and 
3999:                					// starting a 2MSL timer, but since we have so 
4000:                					// few precious sockets, we can't afford to 
4001:                					// leave a socket waiting around doing nothing 
4002:                					// for a long time.  If the remote node does 
4003:                					// not recieve this ACK, it'll have to figure 
4004:                					// out on it's own that the connection is now 
4005:                					// closed.
4006:                					CloseSocket();
9D006C88  0F4014AB   JAL CloseSocket
9D006C8C  00000000   NOP
4007:                				}
4008:                
4009:                				return;
9D006C90  0B401EE5   J 0x9D007B94
9D006C94  00000000   NOP
9D007B54  00000000   NOP
9D007B58  0B401EE5   J 0x9D007B94
9D007B5C  00000000   NOP
4010:                			}
4011:                
4012:                			break;
9D006BD0  0B401B3B   J 0x9D006CEC
9D006BD4  00000000   NOP
9D006CC4  00000000   NOP
9D006CC8  0B401B3B   J 0x9D006CEC
9D006CCC  00000000   NOP
9D006CD0  00000000   NOP
9D006CD4  0B401B3B   J 0x9D006CEC
9D006CD8  00000000   NOP
9D006CDC  00000000   NOP
9D006CE0  0B401B3B   J 0x9D006CEC
9D006CE4  00000000   NOP
9D006CE8  00000000   NOP
4013:                
4014:                		case TCP_LAST_ACK:
4015:                			// Check to see if our FIN has been ACKnowledged
4016:                			if(MyTCB.MySEQ + 1 == localAckNumber)
9D006C98  3C02A000   LUI V0, -24576
9D006C9C  24422E8C   ADDIU V0, V0, 11916
9D006CA0  8C420004   LW V0, 4(V0)
9D006CA4  24430001   ADDIU V1, V0, 1
9D006CA8  8FC20024   LW V0, 36(S8)
9D006CAC  146203AC   BNE V1, V0, 0x9D007B60
9D006CB0  00000000   NOP
4017:                				CloseSocket();
9D006CB4  0F4014AB   JAL CloseSocket
9D006CB8  00000000   NOP
4018:                			return;
9D006CBC  0B401EE5   J 0x9D007B94
9D006CC0  00000000   NOP
9D007B60  00000000   NOP
9D007B64  0B401EE5   J 0x9D007B94
9D007B68  00000000   NOP
4019:                
4020:                //		case TCP_TIME_WAIT:
4021:                //			// Nothing is supposed to arrive here.  If it does, reset the quiet timer.
4022:                //			SendTCP(ACK, SENDTCP_RESET_TIMERS);
4023:                //			return;
4024:                
4025:                		default:
4026:                			break;
9D006000  0B401B3B   J 0x9D006CEC
9D006004  00000000   NOP
9D006014  0B401B3B   J 0x9D006CEC
9D006018  00000000   NOP
4027:                	}
4028:                
4029:                	//
4030:                	// Sixth: Check the URG bit
4031:                	//
4032:                	// Urgent packets are not supported in this stack, so we
4033:                	// will throw them away instead
4034:                	if(localHeaderFlags & URG)
9D006CEC  93C20030   LBU V0, 48(S8)
9D006CF0  30420020   ANDI V0, V0, 32
9D006CF4  1440039D   BNE V0, ZERO, 0x9D007B6C
9D006CF8  00000000   NOP
4035:                		return;
9D007B6C  00000000   NOP
9D007B70  0B401EE5   J 0x9D007B94
9D007B74  00000000   NOP
4036:                
4037:                	//
4038:                	// Seventh: Process the segment text
4039:                	//
4040:                	// Throw data away if in a state that doesn't accept data
4041:                	if(MyTCBStub.smState == TCP_CLOSE_WAIT)
9D006CFC  93828027   LBU V0, -32729(GP)
9D006D00  00402021   ADDU A0, V0, ZERO
9D006D04  3C02A000   LUI V0, -24576
9D006D08  24432CDC   ADDIU V1, V0, 11484
9D006D0C  24020030   ADDIU V0, ZERO, 48
9D006D10  70821002   MUL V0, A0, V0
9D006D14  00621021   ADDU V0, V1, V0
9D006D18  8C430024   LW V1, 36(V0)
9D006D1C  2402000B   ADDIU V0, ZERO, 11
9D006D20  10620395   BEQ V1, V0, 0x9D007B78
9D006D24  00000000   NOP
4042:                		return;
9D007B78  00000000   NOP
9D007B7C  0B401EE5   J 0x9D007B94
9D007B80  00000000   NOP
4043:                	if(MyTCBStub.smState == TCP_CLOSING)
9D006D28  93828027   LBU V0, -32729(GP)
9D006D2C  00402021   ADDU A0, V0, ZERO
9D006D30  3C02A000   LUI V0, -24576
9D006D34  24432CDC   ADDIU V1, V0, 11484
9D006D38  24020030   ADDIU V0, ZERO, 48
9D006D3C  70821002   MUL V0, A0, V0
9D006D40  00621021   ADDU V0, V1, V0
9D006D44  8C430024   LW V1, 36(V0)
9D006D48  2402000A   ADDIU V0, ZERO, 10
9D006D4C  1062038D   BEQ V1, V0, 0x9D007B84
9D006D50  00000000   NOP
4044:                		return;
9D007B84  00000000   NOP
9D007B88  0B401EE5   J 0x9D007B94
9D007B8C  00000000   NOP
4045:                	if(MyTCBStub.smState == TCP_LAST_ACK)
9D006D54  93828027   LBU V0, -32729(GP)
9D006D58  00402021   ADDU A0, V0, ZERO
9D006D5C  3C02A000   LUI V0, -24576
9D006D60  24432CDC   ADDIU V1, V0, 11484
9D006D64  24020030   ADDIU V0, ZERO, 48
9D006D68  70821002   MUL V0, A0, V0
9D006D6C  00621021   ADDU V0, V1, V0
9D006D70  8C430024   LW V1, 36(V0)
9D006D74  2402000C   ADDIU V0, ZERO, 12
9D006D78  10620385   BEQ V1, V0, 0x9D007B90
9D006D7C  00000000   NOP
4046:                		return;
9D007B90  00000000   NOP
4047:                //	if(MyTCBStub.smState == TCP_TIME_WAIT)
4048:                //		return;
4049:                
4050:                	// Copy any valid segment data into our RX FIFO, if any
4051:                	if(len)
9D006D80  97C20054   LHU V0, 84(S8)
9D006D84  10400288   BEQ V0, ZERO, 0x9D0077A8
9D006D88  00000000   NOP
4052:                	{
4053:                		// See if there are bytes we must skip
4054:                		if((SHORT)wMissingBytes <= 0)
9D006D8C  87C2003C   LH V0, 60(S8)
9D006D90  1C40013C   BGTZ V0, 0x9D007284
9D006D94  00000000   NOP
4055:                		{
4056:                			// Position packet read pointer to start of useful data area.
4057:                			IPSetRxBuffer((h->DataOffset.Val << 2) - wMissingBytes);
9D006D98  8FC20050   LW V0, 80(S8)
9D006D9C  8C42000C   LW V0, 12(V0)
9D006DA0  7C421900   EXT V0, V0, 4, 4
9D006DA4  304200FF   ANDI V0, V0, 255
9D006DA8  00021080   SLL V0, V0, 2
9D006DAC  3043FFFF   ANDI V1, V0, -1
9D006DB0  97C2003C   LHU V0, 60(S8)
9D006DB4  00621023   SUBU V0, V1, V0
9D006DB8  3042FFFF   ANDI V0, V0, -1
9D006DBC  00402021   ADDU A0, V0, ZERO
9D006DC0  0F40CEF1   JAL IPSetRxBuffer
9D006DC4  00000000   NOP
4058:                			len += wMissingBytes;		
9D006DC8  97C30054   LHU V1, 84(S8)
9D006DCC  97C2003C   LHU V0, 60(S8)
9D006DD0  00621021   ADDU V0, V1, V0
9D006DD4  A7C20054   SH V0, 84(S8)
4059:                	
4060:                			// Truncate packets that would overflow our TCP RX FIFO
4061:                			// and request a retransmit by sending a duplicate ACK
4062:                			if(len > wFreeSpace)
9D006DD8  97C30054   LHU V1, 84(S8)
9D006DDC  97C20020   LHU V0, 32(S8)
9D006DE0  0043102B   SLTU V0, V0, V1
9D006DE4  10400003   BEQ V0, ZERO, 0x9D006DF4
9D006DE8  00000000   NOP
4063:                				len = wFreeSpace;
9D006DEC  97C20020   LHU V0, 32(S8)
9D006DF0  A7C20054   SH V0, 84(S8)
4064:                	
4065:                			MyTCB.RemoteSEQ += (DWORD)len;
9D006DF4  3C02A000   LUI V0, -24576
9D006DF8  24422E8C   ADDIU V0, V0, 11916
9D006DFC  8C430008   LW V1, 8(V0)
9D006E00  97C20054   LHU V0, 84(S8)
9D006E04  00621821   ADDU V1, V1, V0
9D006E08  3C02A000   LUI V0, -24576
9D006E0C  24422E8C   ADDIU V0, V0, 11916
9D006E10  AC430008   SW V1, 8(V0)
4066:                		
4067:                			// Copy the application data from the packet into the socket RX FIFO
4068:                			// See if we need a two part copy (spans bufferEnd->bufferRxStart)
4069:                			if(MyTCBStub.rxHead + len > MyTCBStub.bufferEnd)
9D006E14  93828027   LBU V0, -32729(GP)
9D006E18  00402021   ADDU A0, V0, ZERO
9D006E1C  3C02A000   LUI V0, -24576
9D006E20  24432CDC   ADDIU V1, V0, 11484
9D006E24  24020030   ADDIU V0, ZERO, 48
9D006E28  70821002   MUL V0, A0, V0
9D006E2C  00621021   ADDU V0, V1, V0
9D006E30  8C430014   LW V1, 20(V0)
9D006E34  97C20054   LHU V0, 84(S8)
9D006E38  00621821   ADDU V1, V1, V0
9D006E3C  93828027   LBU V0, -32729(GP)
9D006E40  00402821   ADDU A1, V0, ZERO
9D006E44  3C02A000   LUI V0, -24576
9D006E48  24040030   ADDIU A0, ZERO, 48
9D006E4C  70A42002   MUL A0, A1, A0
9D006E50  24422CDC   ADDIU V0, V0, 11484
9D006E54  00821021   ADDU V0, A0, V0
9D006E58  8C420008   LW V0, 8(V0)
9D006E5C  0043102B   SLTU V0, V0, V1
9D006E60  1040005F   BEQ V0, ZERO, 0x9D006FE0
9D006E64  00000000   NOP
4070:                			{
4071:                				wTemp = MyTCBStub.bufferEnd - MyTCBStub.rxHead + 1;
9D006E68  93828027   LBU V0, -32729(GP)
9D006E6C  00402021   ADDU A0, V0, ZERO
9D006E70  3C02A000   LUI V0, -24576
9D006E74  24030030   ADDIU V1, ZERO, 48
9D006E78  70831802   MUL V1, A0, V1
9D006E7C  24422CDC   ADDIU V0, V0, 11484
9D006E80  00621021   ADDU V0, V1, V0
9D006E84  8C430008   LW V1, 8(V0)
9D006E88  93828027   LBU V0, -32729(GP)
9D006E8C  00402821   ADDU A1, V0, ZERO
9D006E90  3C02A000   LUI V0, -24576
9D006E94  24442CDC   ADDIU A0, V0, 11484
9D006E98  24020030   ADDIU V0, ZERO, 48
9D006E9C  70A21002   MUL V0, A1, V0
9D006EA0  00821021   ADDU V0, A0, V0
9D006EA4  8C420014   LW V0, 20(V0)
9D006EA8  00621023   SUBU V0, V1, V0
9D006EAC  24420001   ADDIU V0, V0, 1
9D006EB0  AFC2001C   SW V0, 28(S8)
4072:                				TCPRAMCopy(MyTCBStub.rxHead, MyTCBStub.vMemoryMedium, (PTR_BASE)-1, TCP_ETH_RAM, wTemp);
9D006EB4  93828027   LBU V0, -32729(GP)
9D006EB8  00402021   ADDU A0, V0, ZERO
9D006EBC  3C02A000   LUI V0, -24576
9D006EC0  24432CDC   ADDIU V1, V0, 11484
9D006EC4  24020030   ADDIU V0, ZERO, 48
9D006EC8  70821002   MUL V0, A0, V0
9D006ECC  00621021   ADDU V0, V1, V0
9D006ED0  8C430014   LW V1, 20(V0)
9D006ED4  93828027   LBU V0, -32729(GP)
9D006ED8  00402821   ADDU A1, V0, ZERO
9D006EDC  3C02A000   LUI V0, -24576
9D006EE0  24040030   ADDIU A0, ZERO, 48
9D006EE4  70A42002   MUL A0, A1, A0
9D006EE8  24422CDC   ADDIU V0, V0, 11484
9D006EEC  00821021   ADDU V0, A0, V0
9D006EF0  9042002C   LBU V0, 44(V0)
9D006EF4  8FC4001C   LW A0, 28(S8)
9D006EF8  3084FFFF   ANDI A0, A0, -1
9D006EFC  AFA40010   SW A0, 16(SP)
9D006F00  00602021   ADDU A0, V1, ZERO
9D006F04  00402821   ADDU A1, V0, ZERO
9D006F08  2406FFFF   ADDIU A2, ZERO, -1
9D006F0C  00003821   ADDU A3, ZERO, ZERO
9D006F10  0F4020BE   JAL TCPRAMCopy
9D006F14  00000000   NOP
4073:                				TCPRAMCopy(MyTCBStub.bufferRxStart, MyTCBStub.vMemoryMedium, (PTR_BASE)-1, TCP_ETH_RAM, len - wTemp);
9D006F18  93828027   LBU V0, -32729(GP)
9D006F1C  00402021   ADDU A0, V0, ZERO
9D006F20  3C02A000   LUI V0, -24576
9D006F24  24432CDC   ADDIU V1, V0, 11484
9D006F28  24020030   ADDIU V0, ZERO, 48
9D006F2C  70821002   MUL V0, A0, V0
9D006F30  00621021   ADDU V0, V1, V0
9D006F34  8C430004   LW V1, 4(V0)
9D006F38  93828027   LBU V0, -32729(GP)
9D006F3C  00402821   ADDU A1, V0, ZERO
9D006F40  3C02A000   LUI V0, -24576
9D006F44  24040030   ADDIU A0, ZERO, 48
9D006F48  70A42002   MUL A0, A1, A0
9D006F4C  24422CDC   ADDIU V0, V0, 11484
9D006F50  00821021   ADDU V0, A0, V0
9D006F54  9042002C   LBU V0, 44(V0)
9D006F58  8FC4001C   LW A0, 28(S8)
9D006F5C  3084FFFF   ANDI A0, A0, -1
9D006F60  97C50054   LHU A1, 84(S8)
9D006F64  00A42023   SUBU A0, A1, A0
9D006F68  3084FFFF   ANDI A0, A0, -1
9D006F6C  AFA40010   SW A0, 16(SP)
9D006F70  00602021   ADDU A0, V1, ZERO
9D006F74  00402821   ADDU A1, V0, ZERO
9D006F78  2406FFFF   ADDIU A2, ZERO, -1
9D006F7C  00003821   ADDU A3, ZERO, ZERO
9D006F80  0F4020BE   JAL TCPRAMCopy
9D006F84  00000000   NOP
4074:                				MyTCBStub.rxHead = MyTCBStub.bufferRxStart + (len - wTemp);
9D006F88  93828027   LBU V0, -32729(GP)
9D006F8C  00402821   ADDU A1, V0, ZERO
9D006F90  93828027   LBU V0, -32729(GP)
9D006F94  00402021   ADDU A0, V0, ZERO
9D006F98  3C02A000   LUI V0, -24576
9D006F9C  24432CDC   ADDIU V1, V0, 11484
9D006FA0  24020030   ADDIU V0, ZERO, 48
9D006FA4  70821002   MUL V0, A0, V0
9D006FA8  00621021   ADDU V0, V1, V0
9D006FAC  8C430004   LW V1, 4(V0)
9D006FB0  97C40054   LHU A0, 84(S8)
9D006FB4  8FC2001C   LW V0, 28(S8)
9D006FB8  00821023   SUBU V0, A0, V0
9D006FBC  00621821   ADDU V1, V1, V0
9D006FC0  3C02A000   LUI V0, -24576
9D006FC4  24442CDC   ADDIU A0, V0, 11484
9D006FC8  24020030   ADDIU V0, ZERO, 48
9D006FCC  70A21002   MUL V0, A1, V0
9D006FD0  00821021   ADDU V0, A0, V0
9D006FD4  AC430014   SW V1, 20(V0)
9D006FD8  0B401C22   J 0x9D007088
9D006FDC  00000000   NOP
4075:                			}
4076:                			else
4077:                			{
4078:                				TCPRAMCopy(MyTCBStub.rxHead, MyTCBStub.vMemoryMedium, (PTR_BASE)-1, TCP_ETH_RAM, len);
9D006FE0  93828027   LBU V0, -32729(GP)
9D006FE4  00402021   ADDU A0, V0, ZERO
9D006FE8  3C02A000   LUI V0, -24576
9D006FEC  24432CDC   ADDIU V1, V0, 11484
9D006FF0  24020030   ADDIU V0, ZERO, 48
9D006FF4  70821002   MUL V0, A0, V0
9D006FF8  00621021   ADDU V0, V1, V0
9D006FFC  8C430014   LW V1, 20(V0)
9D007000  93828027   LBU V0, -32729(GP)
9D007004  00402821   ADDU A1, V0, ZERO
9D007008  3C02A000   LUI V0, -24576
9D00700C  24040030   ADDIU A0, ZERO, 48
9D007010  70A42002   MUL A0, A1, A0
9D007014  24422CDC   ADDIU V0, V0, 11484
9D007018  00821021   ADDU V0, A0, V0
9D00701C  9042002C   LBU V0, 44(V0)
9D007020  97C40054   LHU A0, 84(S8)
9D007024  AFA40010   SW A0, 16(SP)
9D007028  00602021   ADDU A0, V1, ZERO
9D00702C  00402821   ADDU A1, V0, ZERO
9D007030  2406FFFF   ADDIU A2, ZERO, -1
9D007034  00003821   ADDU A3, ZERO, ZERO
9D007038  0F4020BE   JAL TCPRAMCopy
9D00703C  00000000   NOP
4079:                				MyTCBStub.rxHead += len;
9D007040  93828027   LBU V0, -32729(GP)
9D007044  00402821   ADDU A1, V0, ZERO
9D007048  93828027   LBU V0, -32729(GP)
9D00704C  00402021   ADDU A0, V0, ZERO
9D007050  3C02A000   LUI V0, -24576
9D007054  24432CDC   ADDIU V1, V0, 11484
9D007058  24020030   ADDIU V0, ZERO, 48
9D00705C  70821002   MUL V0, A0, V0
9D007060  00621021   ADDU V0, V1, V0
9D007064  8C430014   LW V1, 20(V0)
9D007068  97C20054   LHU V0, 84(S8)
9D00706C  00621821   ADDU V1, V1, V0
9D007070  3C02A000   LUI V0, -24576
9D007074  24442CDC   ADDIU A0, V0, 11484
9D007078  24020030   ADDIU V0, ZERO, 48
9D00707C  70A21002   MUL V0, A1, V0
9D007080  00821021   ADDU V0, A0, V0
9D007084  AC430014   SW V1, 20(V0)
4080:                			}
4081:                		
4082:                			// See if we have a hole and other data waiting already in the RX FIFO
4083:                			if(MyTCB.sHoleSize != -1)
9D007088  3C02A000   LUI V0, -24576
9D00708C  24422E8C   ADDIU V0, V0, 11916
9D007090  84430024   LH V1, 36(V0)
9D007094  2402FFFF   ADDIU V0, ZERO, -1
9D007098  106201C3   BEQ V1, V0, 0x9D0077A8
9D00709C  00000000   NOP
4084:                			{
4085:                				MyTCB.sHoleSize -= len;
9D0070A0  3C02A000   LUI V0, -24576
9D0070A4  24422E8C   ADDIU V0, V0, 11916
9D0070A8  84420024   LH V0, 36(V0)
9D0070AC  3043FFFF   ANDI V1, V0, -1
9D0070B0  97C20054   LHU V0, 84(S8)
9D0070B4  00621023   SUBU V0, V1, V0
9D0070B8  3042FFFF   ANDI V0, V0, -1
9D0070BC  7C021E20   SEH V1, V0
9D0070C0  3C02A000   LUI V0, -24576
9D0070C4  24422E8C   ADDIU V0, V0, 11916
9D0070C8  A4430024   SH V1, 36(V0)
4086:                				wTemp = MyTCB.wFutureDataSize + MyTCB.sHoleSize;
9D0070CC  3C02A000   LUI V0, -24576
9D0070D0  24422E8C   ADDIU V0, V0, 11916
9D0070D4  94420016   LHU V0, 22(V0)
9D0070D8  00401821   ADDU V1, V0, ZERO
9D0070DC  3C02A000   LUI V0, -24576
9D0070E0  24422E8C   ADDIU V0, V0, 11916
9D0070E4  84420024   LH V0, 36(V0)
9D0070E8  00621021   ADDU V0, V1, V0
9D0070EC  AFC2001C   SW V0, 28(S8)
4087:                		
4088:                				// See if we just closed up a hole, and if so, advance head pointer
4089:                				if((SHORT)wTemp < (SHORT)0)
9D0070F0  8FC2001C   LW V0, 28(S8)
9D0070F4  7C021620   SEH V0, V0
9D0070F8  04410007   BGEZ V0, 0x9D007118
9D0070FC  00000000   NOP
4090:                				{
4091:                					MyTCB.sHoleSize = -1;
9D007100  3C02A000   LUI V0, -24576
9D007104  24422E8C   ADDIU V0, V0, 11916
9D007108  2403FFFF   ADDIU V1, ZERO, -1
9D00710C  A4430024   SH V1, 36(V0)
9D007110  0B401DEA   J 0x9D0077A8
9D007114  00000000   NOP
4092:                				}
4093:                				else if(MyTCB.sHoleSize <= 0)
9D007118  3C02A000   LUI V0, -24576
9D00711C  24422E8C   ADDIU V0, V0, 11916
9D007120  84420024   LH V0, 36(V0)
9D007124  1C4001A0   BGTZ V0, 0x9D0077A8
9D007128  00000000   NOP
4094:                				{
4095:                					MyTCB.RemoteSEQ += wTemp;
9D00712C  3C02A000   LUI V0, -24576
9D007130  24422E8C   ADDIU V0, V0, 11916
9D007134  8C430008   LW V1, 8(V0)
9D007138  8FC2001C   LW V0, 28(S8)
9D00713C  00621821   ADDU V1, V1, V0
9D007140  3C02A000   LUI V0, -24576
9D007144  24422E8C   ADDIU V0, V0, 11916
9D007148  AC430008   SW V1, 8(V0)
4096:                					MyTCBStub.rxHead += wTemp;
9D00714C  93828027   LBU V0, -32729(GP)
9D007150  00402821   ADDU A1, V0, ZERO
9D007154  93828027   LBU V0, -32729(GP)
9D007158  00402021   ADDU A0, V0, ZERO
9D00715C  3C02A000   LUI V0, -24576
9D007160  24432CDC   ADDIU V1, V0, 11484
9D007164  24020030   ADDIU V0, ZERO, 48
9D007168  70821002   MUL V0, A0, V0
9D00716C  00621021   ADDU V0, V1, V0
9D007170  8C430014   LW V1, 20(V0)
9D007174  8FC2001C   LW V0, 28(S8)
9D007178  00621821   ADDU V1, V1, V0
9D00717C  3C02A000   LUI V0, -24576
9D007180  24442CDC   ADDIU A0, V0, 11484
9D007184  24020030   ADDIU V0, ZERO, 48
9D007188  70A21002   MUL V0, A1, V0
9D00718C  00821021   ADDU V0, A0, V0
9D007190  AC430014   SW V1, 20(V0)
4097:                					if(MyTCBStub.rxHead > MyTCBStub.bufferEnd)
9D007194  93828027   LBU V0, -32729(GP)
9D007198  00402021   ADDU A0, V0, ZERO
9D00719C  3C02A000   LUI V0, -24576
9D0071A0  24432CDC   ADDIU V1, V0, 11484
9D0071A4  24020030   ADDIU V0, ZERO, 48
9D0071A8  70821002   MUL V0, A0, V0
9D0071AC  00621021   ADDU V0, V1, V0
9D0071B0  8C430014   LW V1, 20(V0)
9D0071B4  93828027   LBU V0, -32729(GP)
9D0071B8  00402821   ADDU A1, V0, ZERO
9D0071BC  3C02A000   LUI V0, -24576
9D0071C0  24040030   ADDIU A0, ZERO, 48
9D0071C4  70A42002   MUL A0, A1, A0
9D0071C8  24422CDC   ADDIU V0, V0, 11484
9D0071CC  00821021   ADDU V0, A0, V0
9D0071D0  8C420008   LW V0, 8(V0)
9D0071D4  0043102B   SLTU V0, V0, V1
9D0071D8  10400024   BEQ V0, ZERO, 0x9D00726C
9D0071DC  00000000   NOP
4098:                						MyTCBStub.rxHead -= MyTCBStub.bufferEnd - MyTCBStub.bufferRxStart + 1;							
9D0071E0  93828027   LBU V0, -32729(GP)
9D0071E4  00403021   ADDU A2, V0, ZERO
9D0071E8  93828027   LBU V0, -32729(GP)
9D0071EC  00402021   ADDU A0, V0, ZERO
9D0071F0  3C02A000   LUI V0, -24576
9D0071F4  24432CDC   ADDIU V1, V0, 11484
9D0071F8  24020030   ADDIU V0, ZERO, 48
9D0071FC  70821002   MUL V0, A0, V0
9D007200  00621021   ADDU V0, V1, V0
9D007204  8C430014   LW V1, 20(V0)
9D007208  93828027   LBU V0, -32729(GP)
9D00720C  00402821   ADDU A1, V0, ZERO
9D007210  3C02A000   LUI V0, -24576
9D007214  24040030   ADDIU A0, ZERO, 48
9D007218  70A42002   MUL A0, A1, A0
9D00721C  24422CDC   ADDIU V0, V0, 11484
9D007220  00821021   ADDU V0, A0, V0
9D007224  8C440008   LW A0, 8(V0)
9D007228  93828027   LBU V0, -32729(GP)
9D00722C  00403821   ADDU A3, V0, ZERO
9D007230  3C02A000   LUI V0, -24576
9D007234  24452CDC   ADDIU A1, V0, 11484
9D007238  24020030   ADDIU V0, ZERO, 48
9D00723C  70E21002   MUL V0, A3, V0
9D007240  00A21021   ADDU V0, A1, V0
9D007244  8C420004   LW V0, 4(V0)
9D007248  00821023   SUBU V0, A0, V0
9D00724C  00021027   NOR V0, ZERO, V0
9D007250  00621821   ADDU V1, V1, V0
9D007254  3C02A000   LUI V0, -24576
9D007258  24442CDC   ADDIU A0, V0, 11484
9D00725C  24020030   ADDIU V0, ZERO, 48
9D007260  70C21002   MUL V0, A2, V0
9D007264  00821021   ADDU V0, A0, V0
9D007268  AC430014   SW V1, 20(V0)
4099:                					MyTCB.sHoleSize = -1;
9D00726C  3C02A000   LUI V0, -24576
9D007270  24422E8C   ADDIU V0, V0, 11916
9D007274  2403FFFF   ADDIU V1, ZERO, -1
9D007278  A4430024   SH V1, 36(V0)
9D00727C  0B401DEA   J 0x9D0077A8
9D007280  00000000   NOP
4100:                				}
4101:                			}
4102:                		} // This packet is out of order or we lost a packet, see if we can generate a hole to accomodate it
4103:                		else if((SHORT)wMissingBytes > 0)
9D007284  87C2003C   LH V0, 60(S8)
9D007288  18400147   BLEZ V0, 0x9D0077A8
9D00728C  00000000   NOP
4104:                		{
4105:                			// Truncate packets that would overflow our TCP RX FIFO
4106:                			if(len + wMissingBytes > wFreeSpace)
9D007290  97C30054   LHU V1, 84(S8)
9D007294  97C2003C   LHU V0, 60(S8)
9D007298  00621821   ADDU V1, V1, V0
9D00729C  97C20020   LHU V0, 32(S8)
9D0072A0  0043102A   SLT V0, V0, V1
9D0072A4  10400005   BEQ V0, ZERO, 0x9D0072BC
9D0072A8  00000000   NOP
4107:                				len = wFreeSpace - wMissingBytes;
9D0072AC  97C30020   LHU V1, 32(S8)
9D0072B0  97C2003C   LHU V0, 60(S8)
9D0072B4  00621023   SUBU V0, V1, V0
9D0072B8  A7C20054   SH V0, 84(S8)
4108:                		
4109:                			// Position packet read pointer to start of useful data area.
4110:                			IPSetRxBuffer(h->DataOffset.Val << 2);
9D0072BC  8FC20050   LW V0, 80(S8)
9D0072C0  8C42000C   LW V0, 12(V0)
9D0072C4  7C421900   EXT V0, V0, 4, 4
9D0072C8  304200FF   ANDI V0, V0, 255
9D0072CC  00021080   SLL V0, V0, 2
9D0072D0  3042FFFF   ANDI V0, V0, -1
9D0072D4  00402021   ADDU A0, V0, ZERO
9D0072D8  0F40CEF1   JAL IPSetRxBuffer
9D0072DC  00000000   NOP
4111:                	
4112:                			// See if we need a two part copy (spans bufferEnd->bufferRxStart)
4113:                			if(MyTCBStub.rxHead + wMissingBytes + len > MyTCBStub.bufferEnd)
9D0072E0  93828027   LBU V0, -32729(GP)
9D0072E4  00402021   ADDU A0, V0, ZERO
9D0072E8  3C02A000   LUI V0, -24576
9D0072EC  24432CDC   ADDIU V1, V0, 11484
9D0072F0  24020030   ADDIU V0, ZERO, 48
9D0072F4  70821002   MUL V0, A0, V0
9D0072F8  00621021   ADDU V0, V1, V0
9D0072FC  8C430014   LW V1, 20(V0)
9D007300  97C2003C   LHU V0, 60(S8)
9D007304  00621821   ADDU V1, V1, V0
9D007308  97C20054   LHU V0, 84(S8)
9D00730C  00621821   ADDU V1, V1, V0
9D007310  93828027   LBU V0, -32729(GP)
9D007314  00402821   ADDU A1, V0, ZERO
9D007318  3C02A000   LUI V0, -24576
9D00731C  24040030   ADDIU A0, ZERO, 48
9D007320  70A42002   MUL A0, A1, A0
9D007324  24422CDC   ADDIU V0, V0, 11484
9D007328  00821021   ADDU V0, A0, V0
9D00732C  8C420008   LW V0, 8(V0)
9D007330  0043102B   SLTU V0, V0, V1
9D007334  10400083   BEQ V0, ZERO, 0x9D007544
9D007338  00000000   NOP
4114:                			{
4115:                				// Calculate number of data bytes to copy before wraparound
4116:                				wTemp = MyTCBStub.bufferEnd - MyTCBStub.rxHead + 1 - wMissingBytes;
9D00733C  93828027   LBU V0, -32729(GP)
9D007340  00402021   ADDU A0, V0, ZERO
9D007344  3C02A000   LUI V0, -24576
9D007348  24030030   ADDIU V1, ZERO, 48
9D00734C  70831802   MUL V1, A0, V1
9D007350  24422CDC   ADDIU V0, V0, 11484
9D007354  00621021   ADDU V0, V1, V0
9D007358  8C430008   LW V1, 8(V0)
9D00735C  93828027   LBU V0, -32729(GP)
9D007360  00402821   ADDU A1, V0, ZERO
9D007364  3C02A000   LUI V0, -24576
9D007368  24442CDC   ADDIU A0, V0, 11484
9D00736C  24020030   ADDIU V0, ZERO, 48
9D007370  70A21002   MUL V0, A1, V0
9D007374  00821021   ADDU V0, A0, V0
9D007378  8C420014   LW V0, 20(V0)
9D00737C  00621823   SUBU V1, V1, V0
9D007380  97C2003C   LHU V0, 60(S8)
9D007384  00021023   SUBU V0, ZERO, V0
9D007388  00621021   ADDU V0, V1, V0
9D00738C  24420001   ADDIU V0, V0, 1
9D007390  AFC2001C   SW V0, 28(S8)
4117:                				if((SHORT)wTemp >= 0)
9D007394  8FC2001C   LW V0, 28(S8)
9D007398  7C021620   SEH V0, V0
9D00739C  0440003A   BLTZ V0, 0x9D007488
9D0073A0  00000000   NOP
4118:                				{
4119:                					TCPRAMCopy(MyTCBStub.rxHead + wMissingBytes, MyTCBStub.vMemoryMedium, (PTR_BASE)-1, TCP_ETH_RAM, wTemp);
9D0073A4  93828027   LBU V0, -32729(GP)
9D0073A8  00402021   ADDU A0, V0, ZERO
9D0073AC  3C02A000   LUI V0, -24576
9D0073B0  24432CDC   ADDIU V1, V0, 11484
9D0073B4  24020030   ADDIU V0, ZERO, 48
9D0073B8  70821002   MUL V0, A0, V0
9D0073BC  00621021   ADDU V0, V1, V0
9D0073C0  8C430014   LW V1, 20(V0)
9D0073C4  97C2003C   LHU V0, 60(S8)
9D0073C8  00621821   ADDU V1, V1, V0
9D0073CC  93828027   LBU V0, -32729(GP)
9D0073D0  00402821   ADDU A1, V0, ZERO
9D0073D4  3C02A000   LUI V0, -24576
9D0073D8  24040030   ADDIU A0, ZERO, 48
9D0073DC  70A42002   MUL A0, A1, A0
9D0073E0  24422CDC   ADDIU V0, V0, 11484
9D0073E4  00821021   ADDU V0, A0, V0
9D0073E8  9042002C   LBU V0, 44(V0)
9D0073EC  8FC4001C   LW A0, 28(S8)
9D0073F0  3084FFFF   ANDI A0, A0, -1
9D0073F4  AFA40010   SW A0, 16(SP)
9D0073F8  00602021   ADDU A0, V1, ZERO
9D0073FC  00402821   ADDU A1, V0, ZERO
9D007400  2406FFFF   ADDIU A2, ZERO, -1
9D007404  00003821   ADDU A3, ZERO, ZERO
9D007408  0F4020BE   JAL TCPRAMCopy
9D00740C  00000000   NOP
4120:                					TCPRAMCopy(MyTCBStub.bufferRxStart, MyTCBStub.vMemoryMedium, (PTR_BASE)-1, TCP_ETH_RAM, len - wTemp);
9D007410  93828027   LBU V0, -32729(GP)
9D007414  00402021   ADDU A0, V0, ZERO
9D007418  3C02A000   LUI V0, -24576
9D00741C  24432CDC   ADDIU V1, V0, 11484
9D007420  24020030   ADDIU V0, ZERO, 48
9D007424  70821002   MUL V0, A0, V0
9D007428  00621021   ADDU V0, V1, V0
9D00742C  8C430004   LW V1, 4(V0)
9D007430  93828027   LBU V0, -32729(GP)
9D007434  00402821   ADDU A1, V0, ZERO
9D007438  3C02A000   LUI V0, -24576
9D00743C  24040030   ADDIU A0, ZERO, 48
9D007440  70A42002   MUL A0, A1, A0
9D007444  24422CDC   ADDIU V0, V0, 11484
9D007448  00821021   ADDU V0, A0, V0
9D00744C  9042002C   LBU V0, 44(V0)
9D007450  8FC4001C   LW A0, 28(S8)
9D007454  3084FFFF   ANDI A0, A0, -1
9D007458  97C50054   LHU A1, 84(S8)
9D00745C  00A42023   SUBU A0, A1, A0
9D007460  3084FFFF   ANDI A0, A0, -1
9D007464  AFA40010   SW A0, 16(SP)
9D007468  00602021   ADDU A0, V1, ZERO
9D00746C  00402821   ADDU A1, V0, ZERO
9D007470  2406FFFF   ADDIU A2, ZERO, -1
9D007474  00003821   ADDU A3, ZERO, ZERO
9D007478  0F4020BE   JAL TCPRAMCopy
9D00747C  00000000   NOP
9D007480  0B401D6B   J 0x9D0075AC
9D007484  00000000   NOP
4121:                				}
4122:                				else
4123:                				{
4124:                					TCPRAMCopy(MyTCBStub.rxHead + wMissingBytes - (MyTCBStub.bufferEnd - MyTCBStub.bufferRxStart + 1), MyTCBStub.vMemoryMedium, (PTR_BASE)-1, TCP_ETH_RAM, len);
9D007488  93828027   LBU V0, -32729(GP)
9D00748C  00402021   ADDU A0, V0, ZERO
9D007490  3C02A000   LUI V0, -24576
9D007494  24432CDC   ADDIU V1, V0, 11484
9D007498  24020030   ADDIU V0, ZERO, 48
9D00749C  70821002   MUL V0, A0, V0
9D0074A0  00621021   ADDU V0, V1, V0
9D0074A4  8C430014   LW V1, 20(V0)
9D0074A8  97C2003C   LHU V0, 60(S8)
9D0074AC  00621821   ADDU V1, V1, V0
9D0074B0  93828027   LBU V0, -32729(GP)
9D0074B4  00402821   ADDU A1, V0, ZERO
9D0074B8  3C02A000   LUI V0, -24576
9D0074BC  24040030   ADDIU A0, ZERO, 48
9D0074C0  70A42002   MUL A0, A1, A0
9D0074C4  24422CDC   ADDIU V0, V0, 11484
9D0074C8  00821021   ADDU V0, A0, V0
9D0074CC  8C440008   LW A0, 8(V0)
9D0074D0  93828027   LBU V0, -32729(GP)
9D0074D4  00403021   ADDU A2, V0, ZERO
9D0074D8  3C02A000   LUI V0, -24576
9D0074DC  24452CDC   ADDIU A1, V0, 11484
9D0074E0  24020030   ADDIU V0, ZERO, 48
9D0074E4  70C21002   MUL V0, A2, V0
9D0074E8  00A21021   ADDU V0, A1, V0
9D0074EC  8C420004   LW V0, 4(V0)
9D0074F0  00821023   SUBU V0, A0, V0
9D0074F4  00021027   NOR V0, ZERO, V0
9D0074F8  00621821   ADDU V1, V1, V0
9D0074FC  93828027   LBU V0, -32729(GP)
9D007500  00402821   ADDU A1, V0, ZERO
9D007504  3C02A000   LUI V0, -24576
9D007508  24040030   ADDIU A0, ZERO, 48
9D00750C  70A42002   MUL A0, A1, A0
9D007510  24422CDC   ADDIU V0, V0, 11484
9D007514  00821021   ADDU V0, A0, V0
9D007518  9042002C   LBU V0, 44(V0)
9D00751C  97C40054   LHU A0, 84(S8)
9D007520  AFA40010   SW A0, 16(SP)
9D007524  00602021   ADDU A0, V1, ZERO
9D007528  00402821   ADDU A1, V0, ZERO
9D00752C  2406FFFF   ADDIU A2, ZERO, -1
9D007530  00003821   ADDU A3, ZERO, ZERO
9D007534  0F4020BE   JAL TCPRAMCopy
9D007538  00000000   NOP
9D00753C  0B401D6B   J 0x9D0075AC
9D007540  00000000   NOP
4125:                				}
4126:                			}
4127:                			else
4128:                			{
4129:                				TCPRAMCopy(MyTCBStub.rxHead + wMissingBytes, MyTCBStub.vMemoryMedium, (PTR_BASE)-1, TCP_ETH_RAM, len);
9D007544  93828027   LBU V0, -32729(GP)
9D007548  00402021   ADDU A0, V0, ZERO
9D00754C  3C02A000   LUI V0, -24576
9D007550  24432CDC   ADDIU V1, V0, 11484
9D007554  24020030   ADDIU V0, ZERO, 48
9D007558  70821002   MUL V0, A0, V0
9D00755C  00621021   ADDU V0, V1, V0
9D007560  8C430014   LW V1, 20(V0)
9D007564  97C2003C   LHU V0, 60(S8)
9D007568  00621821   ADDU V1, V1, V0
9D00756C  93828027   LBU V0, -32729(GP)
9D007570  00402821   ADDU A1, V0, ZERO
9D007574  3C02A000   LUI V0, -24576
9D007578  24040030   ADDIU A0, ZERO, 48
9D00757C  70A42002   MUL A0, A1, A0
9D007580  24422CDC   ADDIU V0, V0, 11484
9D007584  00821021   ADDU V0, A0, V0
9D007588  9042002C   LBU V0, 44(V0)
9D00758C  97C40054   LHU A0, 84(S8)
9D007590  AFA40010   SW A0, 16(SP)
9D007594  00602021   ADDU A0, V1, ZERO
9D007598  00402821   ADDU A1, V0, ZERO
9D00759C  2406FFFF   ADDIU A2, ZERO, -1
9D0075A0  00003821   ADDU A3, ZERO, ZERO
9D0075A4  0F4020BE   JAL TCPRAMCopy
9D0075A8  00000000   NOP
4130:                			}
4131:                		
4132:                			// Record the hole is here
4133:                			if(MyTCB.sHoleSize == -1)
9D0075AC  3C02A000   LUI V0, -24576
9D0075B0  24422E8C   ADDIU V0, V0, 11916
9D0075B4  84430024   LH V1, 36(V0)
9D0075B8  2402FFFF   ADDIU V0, ZERO, -1
9D0075BC  1462000B   BNE V1, V0, 0x9D0075EC
9D0075C0  00000000   NOP
4134:                			{
4135:                				MyTCB.sHoleSize = wMissingBytes;
9D0075C4  87C3003C   LH V1, 60(S8)
9D0075C8  3C02A000   LUI V0, -24576
9D0075CC  24422E8C   ADDIU V0, V0, 11916
9D0075D0  A4430024   SH V1, 36(V0)
4136:                				MyTCB.wFutureDataSize = len;
9D0075D4  3C02A000   LUI V0, -24576
9D0075D8  24422E8C   ADDIU V0, V0, 11916
9D0075DC  97C30054   LHU V1, 84(S8)
9D0075E0  A4430016   SH V1, 22(V0)
9D0075E4  0B401DEA   J 0x9D0077A8
9D0075E8  00000000   NOP
4137:                			}
4138:                			else
4139:                			{
4140:                				// We already have a hole, see if we can shrink the hole 
4141:                				// or extend the future data size
4142:                				if(wMissingBytes < (WORD)MyTCB.sHoleSize)
9D0075EC  3C02A000   LUI V0, -24576
9D0075F0  24422E8C   ADDIU V0, V0, 11916
9D0075F4  84420024   LH V0, 36(V0)
9D0075F8  3042FFFF   ANDI V0, V0, -1
9D0075FC  97C3003C   LHU V1, 60(S8)
9D007600  0062102B   SLTU V0, V1, V0
9D007604  10400035   BEQ V0, ZERO, 0x9D0076DC
9D007608  00000000   NOP
4143:                				{
4144:                					if((wMissingBytes + len > (WORD)MyTCB.sHoleSize + MyTCB.wFutureDataSize) || (wMissingBytes + len < (WORD)MyTCB.sHoleSize))
9D00760C  97C3003C   LHU V1, 60(S8)
9D007610  97C20054   LHU V0, 84(S8)
9D007614  00621821   ADDU V1, V1, V0
9D007618  3C02A000   LUI V0, -24576
9D00761C  24422E8C   ADDIU V0, V0, 11916
9D007620  84420024   LH V0, 36(V0)
9D007624  3042FFFF   ANDI V0, V0, -1
9D007628  00402021   ADDU A0, V0, ZERO
9D00762C  3C02A000   LUI V0, -24576
9D007630  24422E8C   ADDIU V0, V0, 11916
9D007634  94420016   LHU V0, 22(V0)
9D007638  00821021   ADDU V0, A0, V0
9D00763C  0043102A   SLT V0, V0, V1
9D007640  1440000B   BNE V0, ZERO, 0x9D007670
9D007644  00000000   NOP
9D007648  97C3003C   LHU V1, 60(S8)
9D00764C  97C20054   LHU V0, 84(S8)
9D007650  00621821   ADDU V1, V1, V0
9D007654  3C02A000   LUI V0, -24576
9D007658  24422E8C   ADDIU V0, V0, 11916
9D00765C  84420024   LH V0, 36(V0)
9D007660  3042FFFF   ANDI V0, V0, -1
9D007664  0062102A   SLT V0, V1, V0
9D007668  10400007   BEQ V0, ZERO, 0x9D007688
9D00766C  00000000   NOP
4145:                						MyTCB.wFutureDataSize = len;
9D007670  3C02A000   LUI V0, -24576
9D007674  24422E8C   ADDIU V0, V0, 11916
9D007678  97C30054   LHU V1, 84(S8)
9D00767C  A4430016   SH V1, 22(V0)
9D007680  0B401DB1   J 0x9D0076C4
9D007684  00000000   NOP
4146:                					else
4147:                						MyTCB.wFutureDataSize = (WORD)MyTCB.sHoleSize + MyTCB.wFutureDataSize - wMissingBytes;
9D007688  3C02A000   LUI V0, -24576
9D00768C  24422E8C   ADDIU V0, V0, 11916
9D007690  84420024   LH V0, 36(V0)
9D007694  3043FFFF   ANDI V1, V0, -1
9D007698  3C02A000   LUI V0, -24576
9D00769C  24422E8C   ADDIU V0, V0, 11916
9D0076A0  94420016   LHU V0, 22(V0)
9D0076A4  00621021   ADDU V0, V1, V0
9D0076A8  3043FFFF   ANDI V1, V0, -1
9D0076AC  97C2003C   LHU V0, 60(S8)
9D0076B0  00621023   SUBU V0, V1, V0
9D0076B4  3043FFFF   ANDI V1, V0, -1
9D0076B8  3C02A000   LUI V0, -24576
9D0076BC  24422E8C   ADDIU V0, V0, 11916
9D0076C0  A4430016   SH V1, 22(V0)
4148:                					MyTCB.sHoleSize = wMissingBytes;
9D0076C4  87C3003C   LH V1, 60(S8)
9D0076C8  3C02A000   LUI V0, -24576
9D0076CC  24422E8C   ADDIU V0, V0, 11916
9D0076D0  A4430024   SH V1, 36(V0)
9D0076D4  0B401DEA   J 0x9D0077A8
9D0076D8  00000000   NOP
4149:                				}
4150:                				else if(wMissingBytes + len > (WORD)MyTCB.sHoleSize + MyTCB.wFutureDataSize)
9D0076DC  97C3003C   LHU V1, 60(S8)
9D0076E0  97C20054   LHU V0, 84(S8)
9D0076E4  00621821   ADDU V1, V1, V0
9D0076E8  3C02A000   LUI V0, -24576
9D0076EC  24422E8C   ADDIU V0, V0, 11916
9D0076F0  84420024   LH V0, 36(V0)
9D0076F4  3042FFFF   ANDI V0, V0, -1
9D0076F8  00402021   ADDU A0, V0, ZERO
9D0076FC  3C02A000   LUI V0, -24576
9D007700  24422E8C   ADDIU V0, V0, 11916
9D007704  94420016   LHU V0, 22(V0)
9D007708  00821021   ADDU V0, A0, V0
9D00770C  0043102A   SLT V0, V0, V1
9D007710  10400025   BEQ V0, ZERO, 0x9D0077A8
9D007714  00000000   NOP
4151:                				{
4152:                					// Make sure that there isn't a second hole between 
4153:                					// our future data and this TCP segment's future data
4154:                					if(wMissingBytes <= (WORD)MyTCB.sHoleSize + MyTCB.wFutureDataSize)
9D007718  97C3003C   LHU V1, 60(S8)
9D00771C  3C02A000   LUI V0, -24576
9D007720  24422E8C   ADDIU V0, V0, 11916
9D007724  84420024   LH V0, 36(V0)
9D007728  3042FFFF   ANDI V0, V0, -1
9D00772C  00402021   ADDU A0, V0, ZERO
9D007730  3C02A000   LUI V0, -24576
9D007734  24422E8C   ADDIU V0, V0, 11916
9D007738  94420016   LHU V0, 22(V0)
9D00773C  00821021   ADDU V0, A0, V0
9D007740  0043102A   SLT V0, V0, V1
9D007744  14400018   BNE V0, ZERO, 0x9D0077A8
9D007748  00000000   NOP
4155:                						MyTCB.wFutureDataSize += wMissingBytes + len - (WORD)MyTCB.sHoleSize - MyTCB.wFutureDataSize;
9D00774C  3C02A000   LUI V0, -24576
9D007750  24422E8C   ADDIU V0, V0, 11916
9D007754  94430016   LHU V1, 22(V0)
9D007758  97C4003C   LHU A0, 60(S8)
9D00775C  97C20054   LHU V0, 84(S8)
9D007760  00821021   ADDU V0, A0, V0
9D007764  3044FFFF   ANDI A0, V0, -1
9D007768  3C02A000   LUI V0, -24576
9D00776C  24422E8C   ADDIU V0, V0, 11916
9D007770  84420024   LH V0, 36(V0)
9D007774  3042FFFF   ANDI V0, V0, -1
9D007778  00821023   SUBU V0, A0, V0
9D00777C  3044FFFF   ANDI A0, V0, -1
9D007780  3C02A000   LUI V0, -24576
9D007784  24422E8C   ADDIU V0, V0, 11916
9D007788  94420016   LHU V0, 22(V0)
9D00778C  00821023   SUBU V0, A0, V0
9D007790  3042FFFF   ANDI V0, V0, -1
9D007794  00621021   ADDU V0, V1, V0
9D007798  3043FFFF   ANDI V1, V0, -1
9D00779C  3C02A000   LUI V0, -24576
9D0077A0  24422E8C   ADDIU V0, V0, 11916
9D0077A4  A4430016   SH V1, 22(V0)
4156:                				}
4157:                				
4158:                			}
4159:                		}
4160:                	}
4161:                
4162:                	// Send back an ACK of the data (+SYN | FIN) we just received, 
4163:                	// if any.  To minimize bandwidth waste, we are implementing 
4164:                	// the delayed acknowledgement algorithm here, only sending 
4165:                	// back an immediate ACK if this is the second segment received.  
4166:                	// Otherwise, a 200ms timer will cause the ACK to be transmitted.
4167:                	if(wSegmentLength)
9D0077A8  97C20028   LHU V0, 40(S8)
9D0077AC  1040005F   BEQ V0, ZERO, 0x9D00792C
9D0077B0  00000000   NOP
4168:                	{
4169:                		// For non-established sockets, let's delete all data in 
4170:                		// the RX buffer immediately after receiving it.  This is 
4171:                		// not really how TCP was intended to operate since a 
4172:                		// socket cannot receive any response after it sends a FIN,
4173:                		// but our TCP application API doesn't readily accomodate
4174:                		// receiving data after calling TCPDisconnect(), which 
4175:                		// invalidates the application TCP handle.  By deleting all 
4176:                		// data, we'll ensure that the RX window is nonzero and 
4177:                		// the remote node will be able to send us a FIN response, 
4178:                		// which needs an RX window of at least 1.
4179:                		if(MyTCBStub.smState != TCP_ESTABLISHED)
9D0077B4  93828027   LBU V0, -32729(GP)
9D0077B8  00402021   ADDU A0, V0, ZERO
9D0077BC  3C02A000   LUI V0, -24576
9D0077C0  24432CDC   ADDIU V1, V0, 11484
9D0077C4  24020030   ADDIU V0, ZERO, 48
9D0077C8  70821002   MUL V0, A0, V0
9D0077CC  00621021   ADDU V0, V1, V0
9D0077D0  8C430024   LW V1, 36(V0)
9D0077D4  24020007   ADDIU V0, ZERO, 7
9D0077D8  10620011   BEQ V1, V0, 0x9D007820
9D0077DC  00000000   NOP
4180:                			MyTCBStub.rxTail = MyTCBStub.rxHead;
9D0077E0  93828027   LBU V0, -32729(GP)
9D0077E4  00402821   ADDU A1, V0, ZERO
9D0077E8  93828027   LBU V0, -32729(GP)
9D0077EC  00402021   ADDU A0, V0, ZERO
9D0077F0  3C02A000   LUI V0, -24576
9D0077F4  24432CDC   ADDIU V1, V0, 11484
9D0077F8  24020030   ADDIU V0, ZERO, 48
9D0077FC  70821002   MUL V0, A0, V0
9D007800  00621021   ADDU V0, V1, V0
9D007804  8C430014   LW V1, 20(V0)
9D007808  3C02A000   LUI V0, -24576
9D00780C  24040030   ADDIU A0, ZERO, 48
9D007810  70A42002   MUL A0, A1, A0
9D007814  24422CDC   ADDIU V0, V0, 11484
9D007818  00821021   ADDU V0, A0, V0
9D00781C  AC430018   SW V1, 24(V0)
4181:                
4182:                		if(MyTCBStub.Flags.bOneSegmentReceived)
9D007820  93828027   LBU V0, -32729(GP)
9D007824  00402021   ADDU A0, V0, ZERO
9D007828  3C02A000   LUI V0, -24576
9D00782C  24030030   ADDIU V1, ZERO, 48
9D007830  70831802   MUL V1, A0, V1
9D007834  24422CDC   ADDIU V0, V0, 11484
9D007838  00621021   ADDU V0, V1, V0
9D00783C  8C420028   LW V0, 40(V0)
9D007840  7C4201C0   EXT V0, V0, 7, 1
9D007844  304200FF   ANDI V0, V0, 255
9D007848  10400009   BEQ V0, ZERO, 0x9D007870
9D00784C  00000000   NOP
4183:                		{
4184:                			SendTCP(ACK, SENDTCP_RESET_TIMERS);
9D007850  24040010   ADDIU A0, ZERO, 16
9D007854  24050001   ADDIU A1, ZERO, 1
9D007858  0F400F8B   JAL SendTCP
9D00785C  00000000   NOP
4185:                			SyncTCB();
9D007860  0F400008   JAL SyncTCB
9D007864  00000000   NOP
9D007868  0B401E4B   J 0x9D00792C
9D00786C  00000000   NOP
4186:                			// bOneSegmentReceived is cleared in SendTCP(), so no need here
4187:                		}
4188:                		else
4189:                		{
4190:                			MyTCBStub.Flags.bOneSegmentReceived = TRUE;	
9D007870  93828027   LBU V0, -32729(GP)
9D007874  00402021   ADDU A0, V0, ZERO
9D007878  3C02A000   LUI V0, -24576
9D00787C  24030030   ADDIU V1, ZERO, 48
9D007880  70831802   MUL V1, A0, V1
9D007884  24422CDC   ADDIU V0, V0, 11484
9D007888  00621821   ADDU V1, V1, V0
9D00788C  8C620028   LW V0, 40(V1)
9D007890  24040001   ADDIU A0, ZERO, 1
9D007894  7C8239C4   INS V0, A0, 7, 1
9D007898  AC620028   SW V0, 40(V1)
4191:                		
4192:                			// Do not send an ACK immediately back.  Instead, we will 
4193:                			// perform delayed acknowledgements.  To do this, we will 
4194:                			// just start a timer
4195:                			if(!MyTCBStub.Flags.bDelayedACKTimerEnabled)
9D00789C  93828027   LBU V0, -32729(GP)
9D0078A0  00402021   ADDU A0, V0, ZERO
9D0078A4  3C02A000   LUI V0, -24576
9D0078A8  24030030   ADDIU V1, ZERO, 48
9D0078AC  70831802   MUL V1, A0, V1
9D0078B0  24422CDC   ADDIU V0, V0, 11484
9D0078B4  00621021   ADDU V0, V1, V0
9D0078B8  8C420028   LW V0, 40(V0)
9D0078BC  7C420180   EXT V0, V0, 6, 1
9D0078C0  304200FF   ANDI V0, V0, 255
9D0078C4  14400019   BNE V0, ZERO, 0x9D00792C
9D0078C8  00000000   NOP
4196:                			{
4197:                				MyTCBStub.Flags.bDelayedACKTimerEnabled = 1;
9D0078CC  93828027   LBU V0, -32729(GP)
9D0078D0  00402021   ADDU A0, V0, ZERO
9D0078D4  3C02A000   LUI V0, -24576
9D0078D8  24030030   ADDIU V1, ZERO, 48
9D0078DC  70831802   MUL V1, A0, V1
9D0078E0  24422CDC   ADDIU V0, V0, 11484
9D0078E4  00621821   ADDU V1, V1, V0
9D0078E8  8C620028   LW V0, 40(V1)
9D0078EC  24040001   ADDIU A0, ZERO, 1
9D0078F0  7C823184   INS V0, A0, 6, 1
9D0078F4  AC620028   SW V0, 40(V1)
4198:                				MyTCBStub.OverlappedTimers.delayedACKTime = (WORD)TickGetDiv256() + (WORD)((TCP_DELAYED_ACK_TIMEOUT)>>8);
9D0078F8  93828027   LBU V0, -32729(GP)
9D0078FC  00408021   ADDU S0, V0, ZERO
9D007900  0F40CDE4   JAL TickGetDiv256
9D007904  00000000   NOP
9D007908  3042FFFF   ANDI V0, V0, -1
9D00790C  2442003D   ADDIU V0, V0, 61
9D007910  3043FFFF   ANDI V1, V0, -1
9D007914  3C02A000   LUI V0, -24576
9D007918  24040030   ADDIU A0, ZERO, 48
9D00791C  72042002   MUL A0, S0, A0
9D007920  24422CDC   ADDIU V0, V0, 11484
9D007924  00821021   ADDU V0, A0, V0
9D007928  A4430022   SH V1, 34(V0)
4199:                			}
4200:                		}
4201:                	}
4202:                
4203:                	//
4204:                	// Eighth: check the FIN bit
4205:                	//
4206:                	if(localHeaderFlags & FIN)
9D00792C  93C20030   LBU V0, 48(S8)
9D007930  30420001   ANDI V0, V0, 1
9D007934  304200FF   ANDI V0, V0, 255
9D007938  10400096   BEQ V0, ZERO, 0x9D007B94
9D00793C  00000000   NOP
4207:                	{
4208:                		// Note: Since we don't have a good means of storing "FIN bytes" 
4209:                		// in our TCP RX FIFO, we must ensure that FINs are processed 
4210:                		// in-order.
4211:                		if(MyTCB.RemoteSEQ + 1 == localSeqNumber + (DWORD)wSegmentLength)
9D007940  3C02A000   LUI V0, -24576
9D007944  24422E8C   ADDIU V0, V0, 11916
9D007948  8C420008   LW V0, 8(V0)
9D00794C  24430001   ADDIU V1, V0, 1
9D007950  97C40028   LHU A0, 40(S8)
9D007954  8FC20034   LW V0, 52(S8)
9D007958  00821021   ADDU V0, A0, V0
9D00795C  1462008D   BNE V1, V0, 0x9D007B94
9D007960  00000000   NOP
4212:                		{
4213:                			// FINs are treated as one byte of data for ACK sequencing
4214:                			MyTCB.RemoteSEQ++;
9D007964  3C02A000   LUI V0, -24576
9D007968  24422E8C   ADDIU V0, V0, 11916
9D00796C  8C420008   LW V0, 8(V0)
9D007970  24430001   ADDIU V1, V0, 1
9D007974  3C02A000   LUI V0, -24576
9D007978  24422E8C   ADDIU V0, V0, 11916
9D00797C  AC430008   SW V1, 8(V0)
4215:                			
4216:                			switch(MyTCBStub.smState)
9D007980  93828027   LBU V0, -32729(GP)
9D007984  00402021   ADDU A0, V0, ZERO
9D007988  3C02A000   LUI V0, -24576
9D00798C  24432CDC   ADDIU V1, V0, 11484
9D007990  24020030   ADDIU V0, ZERO, 48
9D007994  70821002   MUL V0, A0, V0
9D007998  00621021   ADDU V0, V1, V0
9D00799C  8C420024   LW V0, 36(V0)
9D0079A0  24030007   ADDIU V1, ZERO, 7
9D0079A4  10430020   BEQ V0, V1, 0x9D007A28
9D0079A8  00000000   NOP
9D0079AC  2C430008   SLTIU V1, V0, 8
9D0079B0  10600006   BEQ V1, ZERO, 0x9D0079CC
9D0079B4  00000000   NOP
9D0079B8  24030006   ADDIU V1, ZERO, 6
9D0079BC  1043000B   BEQ V0, V1, 0x9D0079EC
9D0079C0  00000000   NOP
9D0079CC  24030008   ADDIU V1, ZERO, 8
9D0079D0  1043002D   BEQ V0, V1, 0x9D007A88
9D0079D4  00000000   NOP
9D0079D8  24030009   ADDIU V1, ZERO, 9
9D0079DC  10430043   BEQ V0, V1, 0x9D007AEC
9D0079E0  00000000   NOP
4217:                			{
4218:                				case TCP_SYN_RECEIVED:
4219:                					// RFC in exact: Our API has no need for the user 
4220:                					// to explicitly close a socket that never really 
4221:                					// got opened fully in the first place, so just 
4222:                					// transmit a FIN automatically and jump to 
4223:                					// TCP_LAST_ACK
4224:                					MyTCBStub.smState = TCP_LAST_ACK;
9D0079EC  93828027   LBU V0, -32729(GP)
9D0079F0  00402021   ADDU A0, V0, ZERO
9D0079F4  3C02A000   LUI V0, -24576
9D0079F8  24432CDC   ADDIU V1, V0, 11484
9D0079FC  24020030   ADDIU V0, ZERO, 48
9D007A00  70821002   MUL V0, A0, V0
9D007A04  00621021   ADDU V0, V1, V0
9D007A08  2403000C   ADDIU V1, ZERO, 12
9D007A0C  AC430024   SW V1, 36(V0)
4225:                					SendTCP(FIN | ACK, SENDTCP_RESET_TIMERS);
9D007A10  24040011   ADDIU A0, ZERO, 17
9D007A14  24050001   ADDIU A1, ZERO, 1
9D007A18  0F400F8B   JAL SendTCP
9D007A1C  00000000   NOP
4226:                					return;
9D007A20  0B401EE5   J 0x9D007B94
9D007A24  00000000   NOP
4227:                
4228:                				case TCP_ESTABLISHED:
4229:                					// Go to TCP_CLOSE_WAIT state
4230:                					MyTCBStub.smState = TCP_CLOSE_WAIT;
9D007A28  93828027   LBU V0, -32729(GP)
9D007A2C  00402021   ADDU A0, V0, ZERO
9D007A30  3C02A000   LUI V0, -24576
9D007A34  24432CDC   ADDIU V1, V0, 11484
9D007A38  24020030   ADDIU V0, ZERO, 48
9D007A3C  70821002   MUL V0, A0, V0
9D007A40  00621021   ADDU V0, V1, V0
9D007A44  2403000B   ADDIU V1, ZERO, 11
9D007A48  AC430024   SW V1, 36(V0)
4231:                					
4232:                					// For legacy applications that don't call 
4233:                					// TCPDisconnect() as needed and expect the TCP/IP 
4234:                					// Stack to automatically close sockets when the 
4235:                					// remote node sends a FIN, let's start a timer so 
4236:                					// that we will eventually close the socket automatically
4237:                					MyTCBStub.OverlappedTimers.closeWaitTime = (WORD)TickGetDiv256() + (WORD)((TCP_CLOSE_WAIT_TIMEOUT)>>8);
9D007A4C  93828027   LBU V0, -32729(GP)
9D007A50  00408021   ADDU S0, V0, ZERO
9D007A54  0F40CDE4   JAL TickGetDiv256
9D007A58  00000000   NOP
9D007A5C  3042FFFF   ANDI V0, V0, -1
9D007A60  2442007A   ADDIU V0, V0, 122
9D007A64  3043FFFF   ANDI V1, V0, -1
9D007A68  3C02A000   LUI V0, -24576
9D007A6C  24040030   ADDIU A0, ZERO, 48
9D007A70  72042002   MUL A0, S0, A0
9D007A74  24422CDC   ADDIU V0, V0, 11484
9D007A78  00821021   ADDU V0, A0, V0
9D007A7C  A4430022   SH V1, 34(V0)
4238:                					break;
9D007A80  0B401EC3   J 0x9D007B0C
9D007A84  00000000   NOP
4239:                	
4240:                				case TCP_FIN_WAIT_1:
4241:                					if(MyTCB.MySEQ == localAckNumber)
9D007A88  3C02A000   LUI V0, -24576
9D007A8C  24422E8C   ADDIU V0, V0, 11916
9D007A90  8C430004   LW V1, 4(V0)
9D007A94  8FC20024   LW V0, 36(S8)
9D007A98  14620009   BNE V1, V0, 0x9D007AC0
9D007A9C  00000000   NOP
4242:                					{
4243:                						// RFC not recommended: We should be going to 
4244:                						// the TCP_TIME_WAIT state right here and 
4245:                						// starting a 2MSL timer, but since we have so 
4246:                						// few precious sockets, we can't afford to 
4247:                						// leave a socket waiting around doing nothing 
4248:                						// for a long time.  If the remote node does 
4249:                						// not recieve this ACK, it'll have to figure 
4250:                						// out on it's own that the connection is now 
4251:                						// closed.
4252:                						SendTCP(ACK, 0);
9D007AA0  24040010   ADDIU A0, ZERO, 16
9D007AA4  00002821   ADDU A1, ZERO, ZERO
9D007AA8  0F400F8B   JAL SendTCP
9D007AAC  00000000   NOP
4253:                						CloseSocket();
9D007AB0  0F4014AB   JAL CloseSocket
9D007AB4  00000000   NOP
4254:                						return;
9D007AB8  0B401EE5   J 0x9D007B94
9D007ABC  00000000   NOP
4255:                					}
4256:                					else
4257:                					{
4258:                						MyTCBStub.smState = TCP_CLOSING;
9D007AC0  93828027   LBU V0, -32729(GP)
9D007AC4  00402021   ADDU A0, V0, ZERO
9D007AC8  3C02A000   LUI V0, -24576
9D007ACC  24432CDC   ADDIU V1, V0, 11484
9D007AD0  24020030   ADDIU V0, ZERO, 48
9D007AD4  70821002   MUL V0, A0, V0
9D007AD8  00621021   ADDU V0, V1, V0
9D007ADC  2403000A   ADDIU V1, ZERO, 10
9D007AE0  AC430024   SW V1, 36(V0)
4259:                					}
4260:                					break;
9D007AE4  0B401EC3   J 0x9D007B0C
9D007AE8  00000000   NOP
4261:                	
4262:                				case TCP_FIN_WAIT_2:
4263:                					// RFC not recommended: We should be going to 
4264:                					// the TCP_TIME_WAIT state right here and 
4265:                					// starting a 2MSL timer, but since we have so 
4266:                					// few precious sockets, we can't afford to 
4267:                					// leave a socket waiting around doing nothing 
4268:                					// for a long time.  If the remote node does 
4269:                					// not recieve this ACK, it'll have to figure 
4270:                					// out on it's own that the connection is now 
4271:                					// closed.
4272:                					SendTCP(ACK, 0);
9D007AEC  24040010   ADDIU A0, ZERO, 16
9D007AF0  00002821   ADDU A1, ZERO, ZERO
9D007AF4  0F400F8B   JAL SendTCP
9D007AF8  00000000   NOP
4273:                					CloseSocket();
9D007AFC  0F4014AB   JAL CloseSocket
9D007B00  00000000   NOP
4274:                					return;
9D007B04  0B401EE5   J 0x9D007B94
9D007B08  00000000   NOP
4275:                
4276:                				default:
4277:                					break;
9D0079C4  0B401EC3   J 0x9D007B0C
9D0079C8  00000000   NOP
9D0079E4  0B401EC3   J 0x9D007B0C
9D0079E8  00000000   NOP
4278:                			}
4279:                
4280:                			// Acknowledge receipt of FIN
4281:                			SendTCP(ACK, SENDTCP_RESET_TIMERS);
9D007B0C  24040010   ADDIU A0, ZERO, 16
9D007B10  24050001   ADDIU A1, ZERO, 1
9D007B14  0F400F8B   JAL SendTCP
9D007B18  00000000   NOP
9D007B1C  0B401EE5   J 0x9D007B94
9D007B20  00000000   NOP
4282:                		}
4283:                	}
4284:                }
9D007B94  03C0E821   ADDU SP, S8, ZERO
9D007B98  8FBF004C   LW RA, 76(SP)
9D007B9C  8FBE0048   LW S8, 72(SP)
9D007BA0  8FB00044   LW S0, 68(SP)
9D007BA4  27BD0050   ADDIU SP, SP, 80
9D007BA8  03E00008   JR RA
9D007BAC  00000000   NOP
4285:                
4286:                /****************************************************************************
4287:                  Section:
4288:                	Buffer Management Functions
4289:                  ***************************************************************************/
4290:                
4291:                /*****************************************************************************
4292:                  Function:
4293:                	BOOL TCPAdjustFIFOSize(TCP_SOCKET hTCP, WORD wMinRXSize, 
4294:                							WORD wMinTXSize, BYTE vFlags)
4295:                
4296:                  Summary:
4297:                	Adjusts the relative sizes of the RX and TX buffers.
4298:                
4299:                  Description:
4300:                	This function can be used to adjust the relative sizes of the RX and
4301:                	TX FIFO depending on the immediate needs of an application.  Since a 
4302:                	larger FIFO can allow more data to be sent in a given packet, adjusting 
4303:                	the relative sizes on the fly can allow for optimal transmission speed 
4304:                	for one-sided application protocols.  For example, HTTP typically 
4305:                	begins by receiving large amounts of data from the client, then switches
4306:                	to serving large amounts of data back.  Adjusting the FIFO at these 
4307:                	points can increase performance substantially.  Once the FIFO is
4308:                	adjusted, a window update is sent.
4309:                	
4310:                	If neither or both of TCP_ADJUST_GIVE_REST_TO_TX and 
4311:                	TCP_ADJUST_GIVE_REST_TO_RX are set, the function distributes the
4312:                	remaining space equally.
4313:                	
4314:                	Received data can be preserved as long as the buffer is expanding and 
4315:                	has not wrapped.
4316:                
4317:                  Precondition:
4318:                	TCP is initialized.
4319:                
4320:                  Parameters:
4321:                	hTCP		- The socket to be adjusted
4322:                	wMinRXSize	- Minimum number of byte for the RX FIFO
4323:                	wMinTXSize 	- Minimum number of bytes for the RX FIFO
4324:                	vFlags		- Any combination of TCP_ADJUST_GIVE_REST_TO_RX, 
4325:                				  TCP_ADJUST_GIVE_REST_TO_TX, TCP_ADJUST_PRESERVE_RX.
4326:                				  TCP_ADJUST_PRESERVE_TX is not currently supported.
4327:                
4328:                  Return Values:
4329:                	TRUE - The FIFOs were adjusted successfully
4330:                	FALSE - Minimum RX, Minimum TX, or flags couldn't be accommodated and
4331:                			therefore the socket was left unchanged.
4332:                
4333:                  Side Effects:
4334:                	Any unacknowledged or untransmitted data in the TX FIFO is always
4335:                	deleted.
4336:                
4337:                  Remarks:
4338:                	At least one byte must always be allocated to the RX buffer so that
4339:                	a FIN can be received.  The function automatically corrects for this.
4340:                  ***************************************************************************/
4341:                BOOL TCPAdjustFIFOSize(TCP_SOCKET hTCP, WORD wMinRXSize, WORD wMinTXSize, BYTE vFlags)
4342:                {
9D007BB0  27BDFFD0   ADDIU SP, SP, -48
9D007BB4  AFBF002C   SW RA, 44(SP)
9D007BB8  AFBE0028   SW S8, 40(SP)
9D007BBC  03A0F021   ADDU S8, SP, ZERO
9D007BC0  00804021   ADDU T0, A0, ZERO
9D007BC4  00A02021   ADDU A0, A1, ZERO
9D007BC8  00C01821   ADDU V1, A2, ZERO
9D007BCC  00E01021   ADDU V0, A3, ZERO
9D007BD0  A3C80030   SB T0, 48(S8)
9D007BD4  A7C40034   SH A0, 52(S8)
9D007BD8  A7C30038   SH V1, 56(S8)
9D007BDC  A3C2003C   SB V0, 60(S8)
4343:                	PTR_BASE ptrTemp, ptrHead;
4344:                	WORD wTXAllocation;
4345:                	
4346:                	if(hTCP >= TCP_SOCKET_COUNT)
9D007BE0  93C20030   LBU V0, 48(S8)
9D007BE4  2C420009   SLTIU V0, V0, 9
9D007BE8  14400004   BNE V0, ZERO, 0x9D007BFC
9D007BEC  00000000   NOP
4347:                    {
4348:                        return FALSE;
9D007BF0  00001021   ADDU V0, ZERO, ZERO
9D007BF4  0B4020B8   J 0x9D0082E0
9D007BF8  00000000   NOP
4349:                    }
4350:                    
4351:                	// Load up info on this socket
4352:                	SyncTCBStub(hTCP);
9D007BFC  93C20030   LBU V0, 48(S8)
9D007C00  A3828027   SB V0, -32729(GP)
4353:                
4354:                	// RX has to be at least 1 byte to receive SYN and FIN bytes 
4355:                	// from the remote node, even if they aren't stored in the RX FIFO
4356:                	if(wMinRXSize == 0u)
9D007C04  97C20034   LHU V0, 52(S8)
9D007C08  14400003   BNE V0, ZERO, 0x9D007C18
9D007C0C  00000000   NOP
4357:                		wMinRXSize = 1;
9D007C10  24020001   ADDIU V0, ZERO, 1
9D007C14  A7C20034   SH V0, 52(S8)
4358:                		
4359:                	// SSL connections need to be able to send or receive at least 
4360:                	// a full Alert record, MAC, and FIN
4361:                	#if defined(STACK_USE_SSL)
4362:                	if(TCPIsSSL(hTCP) && wMinRXSize < 25u)
4363:                		wMinRXSize = 25;
4364:                	if(TCPIsSSL(hTCP) && wMinTXSize < 25u)
4365:                		wMinTXSize = 25;
4366:                	#endif
4367:                	
4368:                	// Make sure space is available for minimums
4369:                	ptrTemp = MyTCBStub.bufferEnd - MyTCBStub.bufferTxStart - 1;
9D007C18  93828027   LBU V0, -32729(GP)
9D007C1C  00402021   ADDU A0, V0, ZERO
9D007C20  3C02A000   LUI V0, -24576
9D007C24  24030030   ADDIU V1, ZERO, 48
9D007C28  70831802   MUL V1, A0, V1
9D007C2C  24422CDC   ADDIU V0, V0, 11484
9D007C30  00621021   ADDU V0, V1, V0
9D007C34  8C430008   LW V1, 8(V0)
9D007C38  93828027   LBU V0, -32729(GP)
9D007C3C  00402821   ADDU A1, V0, ZERO
9D007C40  3C02A000   LUI V0, -24576
9D007C44  24040030   ADDIU A0, ZERO, 48
9D007C48  70A42002   MUL A0, A1, A0
9D007C4C  24422CDC   ADDIU V0, V0, 11484
9D007C50  00821021   ADDU V0, A0, V0
9D007C54  8C420000   LW V0, 0(V0)
9D007C58  00621023   SUBU V0, V1, V0
9D007C5C  2442FFFF   ADDIU V0, V0, -1
9D007C60  AFC20020   SW V0, 32(S8)
4370:                	if(wMinRXSize + wMinTXSize > ptrTemp)
9D007C64  97C30034   LHU V1, 52(S8)
9D007C68  97C20038   LHU V0, 56(S8)
9D007C6C  00621021   ADDU V0, V1, V0
9D007C70  00401821   ADDU V1, V0, ZERO
9D007C74  8FC20020   LW V0, 32(S8)
9D007C78  0043102B   SLTU V0, V0, V1
9D007C7C  10400004   BEQ V0, ZERO, 0x9D007C90
9D007C80  00000000   NOP
4371:                		return FALSE;
9D007C84  00001021   ADDU V0, ZERO, ZERO
9D007C88  0B4020B8   J 0x9D0082E0
9D007C8C  00000000   NOP
4372:                
4373:                	SyncTCB();
9D007C90  0F400008   JAL SyncTCB
9D007C94  00000000   NOP
4374:                
4375:                	// Set both allocation flags if none set
4376:                	if(!(vFlags & (TCP_ADJUST_GIVE_REST_TO_TX | TCP_ADJUST_GIVE_REST_TO_RX)))
9D007C98  93C2003C   LBU V0, 60(S8)
9D007C9C  30420003   ANDI V0, V0, 3
9D007CA0  14400004   BNE V0, ZERO, 0x9D007CB4
9D007CA4  00000000   NOP
4377:                		vFlags |= TCP_ADJUST_GIVE_REST_TO_TX | TCP_ADJUST_GIVE_REST_TO_RX;
9D007CA8  93C2003C   LBU V0, 60(S8)
9D007CAC  34420003   ORI V0, V0, 3
9D007CB0  A3C2003C   SB V0, 60(S8)
4378:                		
4379:                
4380:                	// Allocate minimums
4381:                	wTXAllocation = wMinTXSize;
9D007CB4  97C20038   LHU V0, 56(S8)
9D007CB8  A7C2001C   SH V0, 28(S8)
4382:                	ptrTemp -= wMinRXSize + wMinTXSize;
9D007CBC  97C30034   LHU V1, 52(S8)
9D007CC0  97C20038   LHU V0, 56(S8)
9D007CC4  00621021   ADDU V0, V1, V0
9D007CC8  8FC30020   LW V1, 32(S8)
9D007CCC  00621023   SUBU V0, V1, V0
9D007CD0  AFC20020   SW V0, 32(S8)
4383:                
4384:                	// Allocate extra
4385:                	if(vFlags & TCP_ADJUST_GIVE_REST_TO_TX)
9D007CD4  93C2003C   LBU V0, 60(S8)
9D007CD8  30420002   ANDI V0, V0, 2
9D007CDC  10400013   BEQ V0, ZERO, 0x9D007D2C
9D007CE0  00000000   NOP
4386:                	{
4387:                		if(vFlags & TCP_ADJUST_GIVE_REST_TO_RX)
9D007CE4  93C2003C   LBU V0, 60(S8)
9D007CE8  30420001   ANDI V0, V0, 1
9D007CEC  304200FF   ANDI V0, V0, 255
9D007CF0  10400009   BEQ V0, ZERO, 0x9D007D18
9D007CF4  00000000   NOP
4388:                		{
4389:                			// Do a 50%/50% split with any odd byte always going to the RX FIFO
4390:                			wTXAllocation += ptrTemp>>1;
9D007CF8  8FC20020   LW V0, 32(S8)
9D007CFC  00021042   SRL V0, V0, 1
9D007D00  3043FFFF   ANDI V1, V0, -1
9D007D04  97C2001C   LHU V0, 28(S8)
9D007D08  00621021   ADDU V0, V1, V0
9D007D0C  A7C2001C   SH V0, 28(S8)
9D007D10  0B401F4B   J 0x9D007D2C
9D007D14  00000000   NOP
4391:                		}
4392:                		else
4393:                		{
4394:                			wTXAllocation += ptrTemp;
9D007D18  8FC20020   LW V0, 32(S8)
9D007D1C  3043FFFF   ANDI V1, V0, -1
9D007D20  97C2001C   LHU V0, 28(S8)
9D007D24  00621021   ADDU V0, V1, V0
9D007D28  A7C2001C   SH V0, 28(S8)
4395:                		}
4396:                	}
4397:                
4398:                	// Calculate new bufferRxStart pointer
4399:                	ptrTemp = MyTCBStub.bufferTxStart + wTXAllocation + 1;
9D007D2C  93828027   LBU V0, -32729(GP)
9D007D30  00402021   ADDU A0, V0, ZERO
9D007D34  3C02A000   LUI V0, -24576
9D007D38  24030030   ADDIU V1, ZERO, 48
9D007D3C  70831802   MUL V1, A0, V1
9D007D40  24422CDC   ADDIU V0, V0, 11484
9D007D44  00621021   ADDU V0, V1, V0
9D007D48  8C430000   LW V1, 0(V0)
9D007D4C  97C2001C   LHU V0, 28(S8)
9D007D50  00621021   ADDU V0, V1, V0
9D007D54  24420001   ADDIU V0, V0, 1
9D007D58  AFC20020   SW V0, 32(S8)
4400:                
4401:                	// Find the head pointer to use
4402:                	ptrHead = MyTCBStub.rxHead;
9D007D5C  93828027   LBU V0, -32729(GP)
9D007D60  00402021   ADDU A0, V0, ZERO
9D007D64  3C02A000   LUI V0, -24576
9D007D68  24432CDC   ADDIU V1, V0, 11484
9D007D6C  24020030   ADDIU V0, ZERO, 48
9D007D70  70821002   MUL V0, A0, V0
9D007D74  00621021   ADDU V0, V1, V0
9D007D78  8C420014   LW V0, 20(V0)
9D007D7C  AFC20018   SW V0, 24(S8)
4403:                	#if defined(STACK_USE_SSL)
4404:                	if(TCPIsSSL(hTCP))
4405:                		ptrHead = MyTCBStub.sslRxHead;
4406:                	#endif
4407:                	
4408:                	// If there's out-of-order data pending, adjust the head pointer to compensate
4409:                	if(MyTCB.sHoleSize != -1)
9D007D80  3C02A000   LUI V0, -24576
9D007D84  24422E8C   ADDIU V0, V0, 11916
9D007D88  84430024   LH V1, 36(V0)
9D007D8C  2402FFFF   ADDIU V0, ZERO, -1
9D007D90  1062002D   BEQ V1, V0, 0x9D007E48
9D007D94  00000000   NOP
4410:                	{
4411:                		ptrHead += MyTCB.sHoleSize + MyTCB.wFutureDataSize;
9D007D98  3C02A000   LUI V0, -24576
9D007D9C  24422E8C   ADDIU V0, V0, 11916
9D007DA0  84420024   LH V0, 36(V0)
9D007DA4  00401821   ADDU V1, V0, ZERO
9D007DA8  3C02A000   LUI V0, -24576
9D007DAC  24422E8C   ADDIU V0, V0, 11916
9D007DB0  94420016   LHU V0, 22(V0)
9D007DB4  00621021   ADDU V0, V1, V0
9D007DB8  8FC30018   LW V1, 24(S8)
9D007DBC  00621021   ADDU V0, V1, V0
9D007DC0  AFC20018   SW V0, 24(S8)
4412:                		if(ptrHead > MyTCBStub.bufferEnd)
9D007DC4  93828027   LBU V0, -32729(GP)
9D007DC8  00402021   ADDU A0, V0, ZERO
9D007DCC  3C02A000   LUI V0, -24576
9D007DD0  24030030   ADDIU V1, ZERO, 48
9D007DD4  70831802   MUL V1, A0, V1
9D007DD8  24422CDC   ADDIU V0, V0, 11484
9D007DDC  00621021   ADDU V0, V1, V0
9D007DE0  8C430008   LW V1, 8(V0)
9D007DE4  8FC20018   LW V0, 24(S8)
9D007DE8  0062102B   SLTU V0, V1, V0
9D007DEC  10400016   BEQ V0, ZERO, 0x9D007E48
9D007DF0  00000000   NOP
4413:                			ptrHead -= MyTCBStub.bufferEnd - MyTCBStub.bufferRxStart + 1;
9D007DF4  93828027   LBU V0, -32729(GP)
9D007DF8  00402021   ADDU A0, V0, ZERO
9D007DFC  3C02A000   LUI V0, -24576
9D007E00  24030030   ADDIU V1, ZERO, 48
9D007E04  70831802   MUL V1, A0, V1
9D007E08  24422CDC   ADDIU V0, V0, 11484
9D007E0C  00621021   ADDU V0, V1, V0
9D007E10  8C430008   LW V1, 8(V0)
9D007E14  93828027   LBU V0, -32729(GP)
9D007E18  00402821   ADDU A1, V0, ZERO
9D007E1C  3C02A000   LUI V0, -24576
9D007E20  24442CDC   ADDIU A0, V0, 11484
9D007E24  24020030   ADDIU V0, ZERO, 48
9D007E28  70A21002   MUL V0, A1, V0
9D007E2C  00821021   ADDU V0, A0, V0
9D007E30  8C420004   LW V0, 4(V0)
9D007E34  00621023   SUBU V0, V1, V0
9D007E38  00021027   NOR V0, ZERO, V0
9D007E3C  8FC30018   LW V1, 24(S8)
9D007E40  00621021   ADDU V0, V1, V0
9D007E44  AFC20018   SW V0, 24(S8)
4414:                	}
4415:                
4416:                	// Determine if resizing will lose any RX data
4417:                	if(MyTCBStub.rxTail < ptrHead)
9D007E48  93828027   LBU V0, -32729(GP)
9D007E4C  00402021   ADDU A0, V0, ZERO
9D007E50  3C02A000   LUI V0, -24576
9D007E54  24030030   ADDIU V1, ZERO, 48
9D007E58  70831802   MUL V1, A0, V1
9D007E5C  24422CDC   ADDIU V0, V0, 11484
9D007E60  00621021   ADDU V0, V1, V0
9D007E64  8C430018   LW V1, 24(V0)
9D007E68  8FC20018   LW V0, 24(S8)
9D007E6C  0062102B   SLTU V0, V1, V0
9D007E70  10400028   BEQ V0, ZERO, 0x9D007F14
9D007E74  00000000   NOP
4418:                	{
4419:                		if(ptrTemp > MyTCBStub.rxTail)
9D007E78  93828027   LBU V0, -32729(GP)
9D007E7C  00402021   ADDU A0, V0, ZERO
9D007E80  3C02A000   LUI V0, -24576
9D007E84  24030030   ADDIU V1, ZERO, 48
9D007E88  70831802   MUL V1, A0, V1
9D007E8C  24422CDC   ADDIU V0, V0, 11484
9D007E90  00621021   ADDU V0, V1, V0
9D007E94  8C430018   LW V1, 24(V0)
9D007E98  8FC20020   LW V0, 32(S8)
9D007E9C  0062102B   SLTU V0, V1, V0
9D007EA0  10400061   BEQ V0, ZERO, 0x9D008028
9D007EA4  00000000   NOP
4420:                		{
4421:                			if(vFlags & TCP_ADJUST_PRESERVE_RX)
9D007EA8  93C2003C   LBU V0, 60(S8)
9D007EAC  30420004   ANDI V0, V0, 4
9D007EB0  10400004   BEQ V0, ZERO, 0x9D007EC4
9D007EB4  00000000   NOP
4422:                				return FALSE;
9D007EB8  00001021   ADDU V0, ZERO, ZERO
9D007EBC  0B4020B8   J 0x9D0082E0
9D007EC0  00000000   NOP
4423:                			else
4424:                			{
4425:                				MyTCBStub.rxTail = ptrTemp;
9D007EC4  93828027   LBU V0, -32729(GP)
9D007EC8  00402021   ADDU A0, V0, ZERO
9D007ECC  3C02A000   LUI V0, -24576
9D007ED0  24030030   ADDIU V1, ZERO, 48
9D007ED4  70831802   MUL V1, A0, V1
9D007ED8  24422CDC   ADDIU V0, V0, 11484
9D007EDC  00621021   ADDU V0, V1, V0
9D007EE0  8FC30020   LW V1, 32(S8)
9D007EE4  AC430018   SW V1, 24(V0)
4426:                				MyTCBStub.rxHead = ptrTemp;
9D007EE8  93828027   LBU V0, -32729(GP)
9D007EEC  00402021   ADDU A0, V0, ZERO
9D007EF0  3C02A000   LUI V0, -24576
9D007EF4  24432CDC   ADDIU V1, V0, 11484
9D007EF8  24020030   ADDIU V0, ZERO, 48
9D007EFC  70821002   MUL V0, A0, V0
9D007F00  00621021   ADDU V0, V1, V0
9D007F04  8FC30020   LW V1, 32(S8)
9D007F08  AC430014   SW V1, 20(V0)
9D007F0C  0B40200A   J 0x9D008028
9D007F10  00000000   NOP
4427:                
4428:                				#if defined(STACK_USE_SSL)
4429:                				MyTCBStub.sslRxHead = ptrTemp;
4430:                				#endif
4431:                			}
4432:                		}
4433:                	}
4434:                	else if(MyTCBStub.rxTail > ptrHead)
9D007F14  93828027   LBU V0, -32729(GP)
9D007F18  00402021   ADDU A0, V0, ZERO
9D007F1C  3C02A000   LUI V0, -24576
9D007F20  24030030   ADDIU V1, ZERO, 48
9D007F24  70831802   MUL V1, A0, V1
9D007F28  24422CDC   ADDIU V0, V0, 11484
9D007F2C  00621021   ADDU V0, V1, V0
9D007F30  8C430018   LW V1, 24(V0)
9D007F34  8FC20018   LW V0, 24(S8)
9D007F38  0043102B   SLTU V0, V0, V1
9D007F3C  10400028   BEQ V0, ZERO, 0x9D007FE0
9D007F40  00000000   NOP
4435:                	{
4436:                		if(ptrTemp > MyTCBStub.bufferRxStart)
9D007F44  93828027   LBU V0, -32729(GP)
9D007F48  00402021   ADDU A0, V0, ZERO
9D007F4C  3C02A000   LUI V0, -24576
9D007F50  24432CDC   ADDIU V1, V0, 11484
9D007F54  24020030   ADDIU V0, ZERO, 48
9D007F58  70821002   MUL V0, A0, V0
9D007F5C  00621021   ADDU V0, V1, V0
9D007F60  8C430004   LW V1, 4(V0)
9D007F64  8FC20020   LW V0, 32(S8)
9D007F68  0062102B   SLTU V0, V1, V0
9D007F6C  1040002E   BEQ V0, ZERO, 0x9D008028
9D007F70  00000000   NOP
4437:                		{
4438:                			if(vFlags & TCP_ADJUST_PRESERVE_RX)
9D007F74  93C2003C   LBU V0, 60(S8)
9D007F78  30420004   ANDI V0, V0, 4
9D007F7C  10400004   BEQ V0, ZERO, 0x9D007F90
9D007F80  00000000   NOP
4439:                				return FALSE;
9D007F84  00001021   ADDU V0, ZERO, ZERO
9D007F88  0B4020B8   J 0x9D0082E0
9D007F8C  00000000   NOP
4440:                			else
4441:                			{
4442:                				MyTCBStub.rxTail = ptrTemp;
9D007F90  93828027   LBU V0, -32729(GP)
9D007F94  00402021   ADDU A0, V0, ZERO
9D007F98  3C02A000   LUI V0, -24576
9D007F9C  24030030   ADDIU V1, ZERO, 48
9D007FA0  70831802   MUL V1, A0, V1
9D007FA4  24422CDC   ADDIU V0, V0, 11484
9D007FA8  00621021   ADDU V0, V1, V0
9D007FAC  8FC30020   LW V1, 32(S8)
9D007FB0  AC430018   SW V1, 24(V0)
4443:                				MyTCBStub.rxHead = ptrTemp;
9D007FB4  93828027   LBU V0, -32729(GP)
9D007FB8  00402021   ADDU A0, V0, ZERO
9D007FBC  3C02A000   LUI V0, -24576
9D007FC0  24432CDC   ADDIU V1, V0, 11484
9D007FC4  24020030   ADDIU V0, ZERO, 48
9D007FC8  70821002   MUL V0, A0, V0
9D007FCC  00621021   ADDU V0, V1, V0
9D007FD0  8FC30020   LW V1, 32(S8)
9D007FD4  AC430014   SW V1, 20(V0)
9D007FD8  0B40200A   J 0x9D008028
9D007FDC  00000000   NOP
4444:                				
4445:                				#if defined(STACK_USE_SSL)
4446:                				MyTCBStub.sslRxHead = ptrTemp;
4447:                				#endif
4448:                			}
4449:                		}
4450:                	}
4451:                	else
4452:                	{
4453:                		// No data to preserve, but we may need to move 
4454:                		// the pointers to stay in the RX space
4455:                		MyTCBStub.rxTail = ptrTemp;
9D007FE0  93828027   LBU V0, -32729(GP)
9D007FE4  00402021   ADDU A0, V0, ZERO
9D007FE8  3C02A000   LUI V0, -24576
9D007FEC  24030030   ADDIU V1, ZERO, 48
9D007FF0  70831802   MUL V1, A0, V1
9D007FF4  24422CDC   ADDIU V0, V0, 11484
9D007FF8  00621021   ADDU V0, V1, V0
9D007FFC  8FC30020   LW V1, 32(S8)
9D008000  AC430018   SW V1, 24(V0)
4456:                		MyTCBStub.rxHead = ptrTemp;
9D008004  93828027   LBU V0, -32729(GP)
9D008008  00402021   ADDU A0, V0, ZERO
9D00800C  3C02A000   LUI V0, -24576
9D008010  24432CDC   ADDIU V1, V0, 11484
9D008014  24020030   ADDIU V0, ZERO, 48
9D008018  70821002   MUL V0, A0, V0
9D00801C  00621021   ADDU V0, V1, V0
9D008020  8FC30020   LW V1, 32(S8)
9D008024  AC430014   SW V1, 20(V0)
4457:                		
4458:                		#if defined(STACK_USE_SSL)
4459:                		MyTCBStub.sslRxHead = ptrTemp;
4460:                		#endif
4461:                	}
4462:                	
4463:                	// If we need to preserve data that wrapped in the ring, we must copy
4464:                	if(ptrHead < MyTCBStub.rxTail && (vFlags & TCP_ADJUST_PRESERVE_RX))
9D008028  93828027   LBU V0, -32729(GP)
9D00802C  00402021   ADDU A0, V0, ZERO
9D008030  3C02A000   LUI V0, -24576
9D008034  24030030   ADDIU V1, ZERO, 48
9D008038  70831802   MUL V1, A0, V1
9D00803C  24422CDC   ADDIU V0, V0, 11484
9D008040  00621021   ADDU V0, V1, V0
9D008044  8C430018   LW V1, 24(V0)
9D008048  8FC20018   LW V0, 24(S8)
9D00804C  0043102B   SLTU V0, V0, V1
9D008050  1040005F   BEQ V0, ZERO, 0x9D0081D0
9D008054  00000000   NOP
9D008058  93C2003C   LBU V0, 60(S8)
9D00805C  30420004   ANDI V0, V0, 4
9D008060  1040005B   BEQ V0, ZERO, 0x9D0081D0
9D008064  00000000   NOP
4465:                	{
4466:                		TCPRAMCopy(ptrTemp, MyTCBStub.vMemoryMedium, 
9D008068  93828027   LBU V0, -32729(GP)
9D00806C  00402021   ADDU A0, V0, ZERO
9D008070  3C02A000   LUI V0, -24576
9D008074  24030030   ADDIU V1, ZERO, 48
9D008078  70831802   MUL V1, A0, V1
9D00807C  24422CDC   ADDIU V0, V0, 11484
9D008080  00621021   ADDU V0, V1, V0
9D008084  9042002C   LBU V0, 44(V0)
9D008088  00402821   ADDU A1, V0, ZERO
9D00808C  93828027   LBU V0, -32729(GP)
9D008090  00402021   ADDU A0, V0, ZERO
9D008094  3C02A000   LUI V0, -24576
9D008098  24432CDC   ADDIU V1, V0, 11484
9D00809C  24020030   ADDIU V0, ZERO, 48
9D0080A0  70821002   MUL V0, A0, V0
9D0080A4  00621021   ADDU V0, V1, V0
9D0080A8  8C460004   LW A2, 4(V0)
9D0080CC  00401821   ADDU V1, V0, ZERO
9D0080D0  8FC20018   LW V0, 24(S8)
9D0080D4  3044FFFF   ANDI A0, V0, -1
9D0080F8  3042FFFF   ANDI V0, V0, -1
9D0080FC  00821023   SUBU V0, A0, V0
9D008100  3042FFFF   ANDI V0, V0, -1
9D008104  AFA20010   SW V0, 16(SP)
9D008108  8FC40020   LW A0, 32(S8)
9D00810C  00603821   ADDU A3, V1, ZERO
9D008110  0F4020BE   JAL TCPRAMCopy
9D008114  00000000   NOP
4467:                			MyTCBStub.bufferRxStart, MyTCBStub.vMemoryMedium,
9D0080AC  93828027   LBU V0, -32729(GP)
9D0080B0  00402021   ADDU A0, V0, ZERO
9D0080B4  3C02A000   LUI V0, -24576
9D0080B8  24030030   ADDIU V1, ZERO, 48
9D0080BC  70831802   MUL V1, A0, V1
9D0080C0  24422CDC   ADDIU V0, V0, 11484
9D0080C4  00621021   ADDU V0, V1, V0
9D0080C8  9042002C   LBU V0, 44(V0)
4468:                			ptrHead - MyTCBStub.bufferRxStart);
9D0080D8  93828027   LBU V0, -32729(GP)
9D0080DC  00404021   ADDU T0, V0, ZERO
9D0080E0  3C02A000   LUI V0, -24576
9D0080E4  24472CDC   ADDIU A3, V0, 11484
9D0080E8  24020030   ADDIU V0, ZERO, 48
9D0080EC  71021002   MUL V0, T0, V0
9D0080F0  00E21021   ADDU V0, A3, V0
9D0080F4  8C420004   LW V0, 4(V0)
4469:                
4470:                		// Move the pointers if they were in front of the tail
4471:                		#if defined(STACK_USE_SSL)
4472:                		if(TCPIsSSL(hTCP) && MyTCBStub.sslRxHead < MyTCBStub.rxTail)
4473:                			MyTCBStub.sslRxHead -= MyTCBStub.bufferRxStart - ptrTemp;
4474:                		#endif
4475:                		if(MyTCBStub.rxHead < MyTCBStub.rxTail)
9D008118  93828027   LBU V0, -32729(GP)
9D00811C  00402021   ADDU A0, V0, ZERO
9D008120  3C02A000   LUI V0, -24576
9D008124  24432CDC   ADDIU V1, V0, 11484
9D008128  24020030   ADDIU V0, ZERO, 48
9D00812C  70821002   MUL V0, A0, V0
9D008130  00621021   ADDU V0, V1, V0
9D008134  8C430014   LW V1, 20(V0)
9D008138  93828027   LBU V0, -32729(GP)
9D00813C  00402821   ADDU A1, V0, ZERO
9D008140  3C02A000   LUI V0, -24576
9D008144  24040030   ADDIU A0, ZERO, 48
9D008148  70A42002   MUL A0, A1, A0
9D00814C  24422CDC   ADDIU V0, V0, 11484
9D008150  00821021   ADDU V0, A0, V0
9D008154  8C420018   LW V0, 24(V0)
9D008158  0062102B   SLTU V0, V1, V0
9D00815C  1040001C   BEQ V0, ZERO, 0x9D0081D0
9D008160  00000000   NOP
4476:                			MyTCBStub.rxHead -= MyTCBStub.bufferRxStart - ptrTemp;
9D008164  93828027   LBU V0, -32729(GP)
9D008168  00402821   ADDU A1, V0, ZERO
9D00816C  93828027   LBU V0, -32729(GP)
9D008170  00402021   ADDU A0, V0, ZERO
9D008174  3C02A000   LUI V0, -24576
9D008178  24432CDC   ADDIU V1, V0, 11484
9D00817C  24020030   ADDIU V0, ZERO, 48
9D008180  70821002   MUL V0, A0, V0
9D008184  00621021   ADDU V0, V1, V0
9D008188  8C430014   LW V1, 20(V0)
9D00818C  93828027   LBU V0, -32729(GP)
9D008190  00403021   ADDU A2, V0, ZERO
9D008194  3C02A000   LUI V0, -24576
9D008198  24442CDC   ADDIU A0, V0, 11484
9D00819C  24020030   ADDIU V0, ZERO, 48
9D0081A0  70C21002   MUL V0, A2, V0
9D0081A4  00821021   ADDU V0, A0, V0
9D0081A8  8C420004   LW V0, 4(V0)
9D0081AC  8FC40020   LW A0, 32(S8)
9D0081B0  00821023   SUBU V0, A0, V0
9D0081B4  00621821   ADDU V1, V1, V0
9D0081B8  3C02A000   LUI V0, -24576
9D0081BC  24442CDC   ADDIU A0, V0, 11484
9D0081C0  24020030   ADDIU V0, ZERO, 48
9D0081C4  70A21002   MUL V0, A1, V0
9D0081C8  00821021   ADDU V0, A0, V0
9D0081CC  AC430014   SW V1, 20(V0)
4477:                	}
4478:                	
4479:                	// Move the RX buffer pointer - it's the one that divides the two
4480:                	MyTCBStub.bufferRxStart = ptrTemp;
9D0081D0  93828027   LBU V0, -32729(GP)
9D0081D4  00402021   ADDU A0, V0, ZERO
9D0081D8  3C02A000   LUI V0, -24576
9D0081DC  24432CDC   ADDIU V1, V0, 11484
9D0081E0  24020030   ADDIU V0, ZERO, 48
9D0081E4  70821002   MUL V0, A0, V0
9D0081E8  00621021   ADDU V0, V1, V0
9D0081EC  8FC30020   LW V1, 32(S8)
9D0081F0  AC430004   SW V1, 4(V0)
4481:                
4482:                	// Empty the TX buffer
4483:                	MyTCB.txUnackedTail = MyTCBStub.bufferTxStart;
9D0081F4  93828027   LBU V0, -32729(GP)
9D0081F8  00402021   ADDU A0, V0, ZERO
9D0081FC  3C02A000   LUI V0, -24576
9D008200  24030030   ADDIU V1, ZERO, 48
9D008204  70831802   MUL V1, A0, V1
9D008208  24422CDC   ADDIU V0, V0, 11484
9D00820C  00621021   ADDU V0, V1, V0
9D008210  8C430000   LW V1, 0(V0)
9D008214  3C02A000   LUI V0, -24576
9D008218  24422E8C   ADDIU V0, V0, 11916
9D00821C  AC43000C   SW V1, 12(V0)
4484:                	MyTCBStub.txTail = MyTCBStub.bufferTxStart;
9D008220  93828027   LBU V0, -32729(GP)
9D008224  00402821   ADDU A1, V0, ZERO
9D008228  93828027   LBU V0, -32729(GP)
9D00822C  00402021   ADDU A0, V0, ZERO
9D008230  3C02A000   LUI V0, -24576
9D008234  24030030   ADDIU V1, ZERO, 48
9D008238  70831802   MUL V1, A0, V1
9D00823C  24422CDC   ADDIU V0, V0, 11484
9D008240  00621021   ADDU V0, V1, V0
9D008244  8C430000   LW V1, 0(V0)
9D008248  3C02A000   LUI V0, -24576
9D00824C  24040030   ADDIU A0, ZERO, 48
9D008250  70A42002   MUL A0, A1, A0
9D008254  24422CDC   ADDIU V0, V0, 11484
9D008258  00821021   ADDU V0, A0, V0
9D00825C  AC430010   SW V1, 16(V0)
4485:                	MyTCBStub.txHead = MyTCBStub.bufferTxStart;
9D008260  93828027   LBU V0, -32729(GP)
9D008264  00402821   ADDU A1, V0, ZERO
9D008268  93828027   LBU V0, -32729(GP)
9D00826C  00402021   ADDU A0, V0, ZERO
9D008270  3C02A000   LUI V0, -24576
9D008274  24030030   ADDIU V1, ZERO, 48
9D008278  70831802   MUL V1, A0, V1
9D00827C  24422CDC   ADDIU V0, V0, 11484
9D008280  00621021   ADDU V0, V1, V0
9D008284  8C430000   LW V1, 0(V0)
9D008288  3C02A000   LUI V0, -24576
9D00828C  24442CDC   ADDIU A0, V0, 11484
9D008290  24020030   ADDIU V0, ZERO, 48
9D008294  70A21002   MUL V0, A1, V0
9D008298  00821021   ADDU V0, A0, V0
9D00829C  AC43000C   SW V1, 12(V0)
4486:                	
4487:                	#if defined(STACK_USE_SSL)
4488:                	if(TCPIsSSL(hTCP))
4489:                		MyTCBStub.sslTxHead = MyTCBStub.txHead + 5;
4490:                	#endif
4491:                	
4492:                	// Send a window update to notify remote node of change
4493:                	if(MyTCBStub.smState == TCP_ESTABLISHED)
9D0082A0  93828027   LBU V0, -32729(GP)
9D0082A4  00402021   ADDU A0, V0, ZERO
9D0082A8  3C02A000   LUI V0, -24576
9D0082AC  24432CDC   ADDIU V1, V0, 11484
9D0082B0  24020030   ADDIU V0, ZERO, 48
9D0082B4  70821002   MUL V0, A0, V0
9D0082B8  00621021   ADDU V0, V1, V0
9D0082BC  8C430024   LW V1, 36(V0)
9D0082C0  24020007   ADDIU V0, ZERO, 7
9D0082C4  14620005   BNE V1, V0, 0x9D0082DC
9D0082C8  00000000   NOP
4494:                		SendTCP(ACK, SENDTCP_RESET_TIMERS);
9D0082CC  24040010   ADDIU A0, ZERO, 16
9D0082D0  24050001   ADDIU A1, ZERO, 1
9D0082D4  0F400F8B   JAL SendTCP
9D0082D8  00000000   NOP
4495:                
4496:                	return TRUE;
9D0082DC  24020001   ADDIU V0, ZERO, 1
4497:                
4498:                }
9D0082E0  03C0E821   ADDU SP, S8, ZERO
9D0082E4  8FBF002C   LW RA, 44(SP)
9D0082E8  8FBE0028   LW S8, 40(SP)
9D0082EC  27BD0030   ADDIU SP, SP, 48
9D0082F0  03E00008   JR RA
9D0082F4  00000000   NOP
4499:                
4500:                /*****************************************************************************
4501:                  Function:
4502:                	static void TCPRAMCopy(PTR_BASE ptrDest, BYTE vDestType, PTR_BASE ptrSource, 
4503:                							BYTE vSourceType, WORD wLength)
4504:                
4505:                  Summary:
4506:                	Copies data to/from various memory mediums.
4507:                
4508:                  Description:
4509:                	This function copies data between memory mediums (PIC RAM, SPI
4510:                	RAM, and Ethernet buffer RAM).
4511:                
4512:                  Precondition:
4513:                	TCP is initialized.
4514:                
4515:                  Parameters:
4516:                	ptrDest		- Address to write to
4517:                	vDestType	- Destination meidum (TCP_PIC_RAM, TCP_ETH_RAM, TCP_SPI_RAM)
4518:                	ptrSource	- Address to copy from
4519:                	vSourceType - Source medium (TCP_PIC_RAM, TCP_ETH_RAM, or TCP_SPI_RAM)
4520:                	wLength		- Number of bytes to copy
4521:                
4522:                  Returns:
4523:                	None
4524:                
4525:                  Remarks:
4526:                	Copying to a destination region that overlaps with the source address 
4527:                	is supported only if the destination start address is at a lower memory 
4528:                	address (closer to 0x0000) than the source pointer.  However, if they do 
4529:                	overlap there must be at least 4 bytes of non-overlap to ensure correct 
4530:                	results due to hardware DMA requirements.
4531:                  ***************************************************************************/
4532:                static void TCPRAMCopy(PTR_BASE ptrDest, BYTE vDestType, PTR_BASE ptrSource, BYTE vSourceType, WORD wLength)
4533:                {
9D0082F8  27BDFFE0   ADDIU SP, SP, -32
9D0082FC  AFBF001C   SW RA, 28(SP)
9D008300  AFBE0018   SW S8, 24(SP)
9D008304  03A0F021   ADDU S8, SP, ZERO
9D008308  AFC40020   SW A0, 32(S8)
9D00830C  00A02021   ADDU A0, A1, ZERO
9D008310  AFC60028   SW A2, 40(S8)
9D008314  00E01821   ADDU V1, A3, ZERO
9D008318  8FC20030   LW V0, 48(S8)
9D00831C  A3C40024   SB A0, 36(S8)
9D008320  A3C3002C   SB V1, 44(S8)
9D008324  A7C20010   SH V0, 16(S8)
4534:                	#if defined(SPIRAM_CS_TRIS)
4535:                	BYTE vBuffer[16];
4536:                	WORD w;
4537:                	#endif
4538:                		
4539:                	switch(vSourceType)
9D008328  93C2002C   LBU V0, 44(S8)
9D00832C  10400023   BEQ V0, ZERO, 0x9D0083BC
9D008330  00000000   NOP
9D008334  24030001   ADDIU V1, ZERO, 1
9D008338  14430048   BNE V0, V1, 0x9D00845C
9D00833C  00000000   NOP
4540:                	{
4541:                		case TCP_PIC_RAM:
4542:                			switch(vDestType)
9D008340  93C20024   LBU V0, 36(S8)
9D008344  1040000D   BEQ V0, ZERO, 0x9D00837C
9D008348  00000000   NOP
9D00834C  24030001   ADDIU V1, ZERO, 1
9D008350  1443003E   BNE V0, V1, 0x9D00844C
9D008354  00000000   NOP
4543:                			{
4544:                				case TCP_PIC_RAM:
4545:                					memcpy((void*)(BYTE*)ptrDest, (void*)(BYTE*)ptrSource, wLength);
9D008358  8FC40020   LW A0, 32(S8)
9D00835C  8FC30028   LW V1, 40(S8)
9D008360  97C20010   LHU V0, 16(S8)
9D008364  00602821   ADDU A1, V1, ZERO
9D008368  00403021   ADDU A2, V0, ZERO
9D00836C  0F40D298   JAL 0x9D034A60
9D008370  00000000   NOP
4546:                					break;
9D008374  0B4020ED   J 0x9D0083B4
9D008378  00000000   NOP
4547:                	
4548:                				case TCP_ETH_RAM:
4549:                					if(ptrDest!=(PTR_BASE)-1)
9D00837C  8FC30020   LW V1, 32(S8)
9D008380  2402FFFF   ADDIU V0, ZERO, -1
9D008384  10620004   BEQ V1, V0, 0x9D008398
9D008388  00000000   NOP
4550:                						MACSetWritePtr(ptrDest);
9D00838C  8FC40020   LW A0, 32(S8)
9D008390  0F407410   JAL MACSetWritePtr
9D008394  00000000   NOP
4551:                					MACPutArray((BYTE*)ptrSource, wLength);
9D008398  8FC30028   LW V1, 40(S8)
9D00839C  97C20010   LHU V0, 16(S8)
9D0083A0  00602021   ADDU A0, V1, ZERO
9D0083A4  00402821   ADDU A1, V0, ZERO
9D0083A8  0F40759D   JAL MACPutArray
9D0083AC  00000000   NOP
4552:                					break;
9D0083B0  00000000   NOP
4553:                	
4554:                				#if defined(SPIRAM_CS_TRIS)
4555:                				case TCP_SPI_RAM:
4556:                					SPIRAMPutArray(ptrDest, (BYTE*)ptrSource, wLength);
4557:                					break;
4558:                				#endif
4559:                			}
4560:                			break;
9D0083B4  0B402117   J 0x9D00845C
9D0083B8  00000000   NOP
9D00844C  00000000   NOP
9D008450  0B402117   J 0x9D00845C
9D008454  00000000   NOP
4561:                	
4562:                		case TCP_ETH_RAM:
4563:                			switch(vDestType)
9D0083BC  93C20024   LBU V0, 36(S8)
9D0083C0  10400013   BEQ V0, ZERO, 0x9D008410
9D0083C4  00000000   NOP
9D0083C8  24030001   ADDIU V1, ZERO, 1
9D0083CC  14430022   BNE V0, V1, 0x9D008458
9D0083D0  00000000   NOP
4564:                			{
4565:                				case TCP_PIC_RAM:
4566:                					if(ptrSource!=(PTR_BASE)-1)
9D0083D4  8FC30028   LW V1, 40(S8)
9D0083D8  2402FFFF   ADDIU V0, ZERO, -1
9D0083DC  10620004   BEQ V1, V0, 0x9D0083F0
9D0083E0  00000000   NOP
4567:                						MACSetReadPtr(ptrSource);
9D0083E4  8FC40028   LW A0, 40(S8)
9D0083E8  0F407426   JAL MACSetReadPtr
9D0083EC  00000000   NOP
4568:                					MACGetArray((BYTE*)ptrDest, wLength);
9D0083F0  8FC30020   LW V1, 32(S8)
9D0083F4  97C20010   LHU V0, 16(S8)
9D0083F8  00602021   ADDU A0, V1, ZERO
9D0083FC  00402821   ADDU A1, V0, ZERO
9D008400  0F407560   JAL MACGetArray
9D008404  00000000   NOP
4569:                					break;
9D008408  0B402110   J 0x9D008440
9D00840C  00000000   NOP
4570:                	
4571:                				case TCP_ETH_RAM:
4572:                					MACMemCopyAsync(ptrDest, ptrSource, wLength);
9D008410  97C20010   LHU V0, 16(S8)
9D008414  8FC40020   LW A0, 32(S8)
9D008418  8FC50028   LW A1, 40(S8)
9D00841C  00403021   ADDU A2, V0, ZERO
9D008420  0F4074D3   JAL MACMemCopyAsync
9D008424  00000000   NOP
4573:                					while(!MACIsMemCopyDone());
9D008428  00000000   NOP
9D00842C  0F407532   JAL MACIsMemCopyDone
9D008430  00000000   NOP
9D008434  1040FFFD   BEQ V0, ZERO, 0x9D00842C
9D008438  00000000   NOP
4574:                					break;
9D00843C  00000000   NOP
4575:                	
4576:                				#if defined(SPIRAM_CS_TRIS)
4577:                				case TCP_SPI_RAM:
4578:                					if(ptrSource!=(PTR_BASE)-1)
4579:                						MACSetReadPtr(ptrSource);
4580:                					w = sizeof(vBuffer);
4581:                					while(wLength)
4582:                					{
4583:                						if(w > wLength)
4584:                							w = wLength;
4585:                						
4586:                						// Read and write a chunk	
4587:                						MACGetArray(vBuffer, w);
4588:                						SPIRAMPutArray(ptrDest, vBuffer, w);
4589:                						ptrDest += w;
4590:                						wLength -= w;
4591:                					}
4592:                					break;
4593:                				#endif
4594:                			}
4595:                			break;
9D008440  00000000   NOP
9D008444  0B402117   J 0x9D00845C
9D008448  00000000   NOP
9D008458  00000000   NOP
4596:                	
4597:                		#if defined(SPIRAM_CS_TRIS)
4598:                		case TCP_SPI_RAM:
4599:                			switch(vDestType)
4600:                			{
4601:                				case TCP_PIC_RAM:
4602:                					SPIRAMGetArray(ptrSource, (BYTE*)ptrDest, wLength);
4603:                					break;
4604:                	
4605:                				case TCP_ETH_RAM:
4606:                					if(ptrDest!=(PTR_BASE)-1)
4607:                						MACSetWritePtr(ptrDest);
4608:                					w = sizeof(vBuffer);
4609:                					while(wLength)
4610:                					{
4611:                						if(w > wLength)
4612:                							w = wLength;
4613:                						
4614:                						// Read and write a chunk	
4615:                						SPIRAMGetArray(ptrSource, vBuffer, w);
4616:                						ptrSource += w;
4617:                						MACPutArray(vBuffer, w);
4618:                						wLength -= w;
4619:                					}
4620:                					break;
4621:                	
4622:                				case TCP_SPI_RAM:
4623:                					// Copy all of the data over in chunks
4624:                					w = sizeof(vBuffer);
4625:                					while(wLength)
4626:                					{
4627:                						if(w > wLength)
4628:                							w = wLength;
4629:                							
4630:                						SPIRAMGetArray(ptrSource, vBuffer, w);
4631:                						SPIRAMPutArray(ptrDest, vBuffer, w);
4632:                						ptrSource += w;
4633:                						ptrDest += w;
4634:                						wLength -= w;
4635:                					}
4636:                					break;
4637:                			}
4638:                			break;
4639:                		#endif			
4640:                	}
4641:                }
9D00845C  03C0E821   ADDU SP, S8, ZERO
9D008460  8FBF001C   LW RA, 28(SP)
9D008464  8FBE0018   LW S8, 24(SP)
9D008468  27BD0020   ADDIU SP, SP, 32
9D00846C  03E00008   JR RA
9D008470  00000000   NOP
4642:                
4643:                /*****************************************************************************
4644:                  Function:
4645:                	static void TCPRAMCopyROM(PTR_BASE wDest, BYTE wDestType, ROM BYTE* wSource, 
4646:                								WORD wLength)
4647:                
4648:                  Summary:
4649:                	Copies data to/from various memory mediums.
4650:                
4651:                  Description:
4652:                	This function copies data between memory mediums (PIC RAM, SPI
4653:                	RAM, and Ethernet buffer RAM).  This function is to be used when 
4654:                	copying from ROM.
4655:                
4656:                  Precondition:
4657:                	TCP is initialized.
4658:                
4659:                  Parameters:
4660:                	wDest		- Address to write to
4661:                	wDestType	- Destination meidum (TCP_PIC_RAM, TCP_ETH_RAM, TCP_SPI_RAM)
4662:                	wSource		- Address to copy from
4663:                	wLength		- Number of bytes to copy
4664:                
4665:                  Returns:
4666:                	None
4667:                
4668:                  Remarks:
4669:                	Copying to a destination region that overlaps with the source address 
4670:                	is supported only if the destination start address is at a lower memory 
4671:                	address (closer to 0x0000) than the source pointer.
4672:                	
4673:                	This function is aliased to TCPRAMCopy on non-PIC18 platforms.
4674:                  ***************************************************************************/
4675:                #if defined(__18CXX)
4676:                static void TCPRAMCopyROM(PTR_BASE wDest, BYTE wDestType, ROM BYTE* wSource, WORD wLength)
4677:                {
4678:                	BYTE vBuffer[16];
4679:                	WORD w;
4680:                	
4681:                	switch(wDestType)
4682:                	{
4683:                		case TCP_PIC_RAM:
4684:                			memcpypgm2ram((void*)(BYTE*)wDest, (ROM void*)wSource, wLength);
4685:                			break;
4686:                	
4687:                		case TCP_ETH_RAM:
4688:                			if(wDest!=(PTR_BASE)-1)
4689:                				MACSetWritePtr(wDest);
4690:                			w = sizeof(vBuffer);
4691:                			while(wLength)
4692:                			{
4693:                				if(w > wLength)
4694:                					w = wLength;
4695:                				
4696:                				// Read and write a chunk	
4697:                				memcpypgm2ram(vBuffer, (ROM void*)wSource, w);
4698:                				MACPutArray(vBuffer, w);
4699:                				wSource += w;
4700:                				wLength -= w;
4701:                			}
4702:                			break;
4703:                	
4704:                		#if defined(SPIRAM_CS_TRIS)
4705:                		case TCP_SPI_RAM:
4706:                			w = sizeof(vBuffer);
4707:                			while(wLength)
4708:                			{
4709:                				if(w > wLength)
4710:                					w = wLength;
4711:                				
4712:                				// Read and write a chunk	
4713:                				memcpypgm2ram(vBuffer, (ROM void*)wSource, w);
4714:                				SPIRAMPutArray(wDest, vBuffer, w);
4715:                				wDest += w;
4716:                				wSource += w;
4717:                				wLength -= w;
4718:                			}
4719:                			break;
4720:                		#endif
4721:                	}
4722:                }
4723:                #endif
4724:                
4725:                /****************************************************************************
4726:                  Section:
4727:                	SSL Functions
4728:                  ***************************************************************************/
4729:                
4730:                /*****************************************************************************
4731:                  Function:
4732:                	BOOL TCPStartSSLClient(TCP_SOCKET hTCP, BYTE* host)
4733:                
4734:                  Summary:
4735:                	Begins an SSL client session.
4736:                
4737:                  Description:
4738:                	This function escalates the current connection to an SSL secured 
4739:                	connection by initiating an SSL client handshake.
4740:                
4741:                  Precondition:
4742:                	TCP is initialized and hTCP is already connected.
4743:                
4744:                  Parameters:
4745:                	hTCP		- TCP connection to secure
4746:                	host		- Expected host name on certificate (currently ignored)
4747:                
4748:                  Return Values:
4749:                	TRUE 		- an SSL connection was initiated
4750:                	FALSE 		- Insufficient SSL resources (stubs) were available
4751:                
4752:                  Remarks:
4753:                	The host parameter is currently ignored and is not validated.
4754:                  ***************************************************************************/
4755:                #if defined(STACK_USE_SSL_CLIENT)
4756:                BOOL TCPStartSSLClient(TCP_SOCKET hTCP, BYTE* host)
4757:                {
4758:                	BYTE i;
4759:                	
4760:                	if(hTCP >= TCP_SOCKET_COUNT)
4761:                    {
4762:                        return FALSE;
4763:                    }
4764:                    
4765:                	SyncTCBStub(hTCP);
4766:                	
4767:                	// Make sure SSL is not established already
4768:                	if(MyTCBStub.sslStubID != SSL_INVALID_ID)
4769:                		return FALSE;
4770:                	
4771:                	// Try to start the session
4772:                	MyTCBStub.sslStubID = SSLStartSession(hTCP, NULL, 0);
4773:                	
4774:                	// Make sure a session stub was obtained
4775:                	if(MyTCBStub.sslStubID == SSL_INVALID_ID)
4776:                		return FALSE;
4777:                
4778:                	// Mark connection as handshaking and return
4779:                	MyTCBStub.sslReqMessage = SSL_CLIENT_HELLO;
4780:                	MyTCBStub.sslRxHead = MyTCBStub.rxHead;
4781:                	MyTCBStub.sslTxHead = MyTCBStub.txHead;
4782:                	MyTCBStub.Flags.bSSLHandshaking = 1;
4783:                	for(i = 0; i < 5u; i++)
4784:                	{// Skip first 5 bytes in TX for the record header
4785:                		if(++MyTCBStub.sslTxHead >= MyTCBStub.bufferRxStart)
4786:                			MyTCBStub.sslTxHead = MyTCBStub.bufferTxStart;
4787:                	}
4788:                	return TRUE;
4789:                }
4790:                #endif // SSL Client
4791:                
4792:                /*****************************************************************************
4793:                  Function:
4794:                	BOOL TCPStartSSLClientEx(TCP_SOCKET hTCP, BYTE* host, BYTE * buffer, BYTE suppDataType)
4795:                
4796:                  Summary:
4797:                	Begins an SSL client session.
4798:                
4799:                  Description:
4800:                	This function escalates the current connection to an SSL secured 
4801:                	connection by initiating an SSL client handshake.
4802:                
4803:                  Precondition:
4804:                	TCP is initialized and hTCP is already connected.
4805:                
4806:                  Parameters:
4807:                	hTCP			- TCP connection to secure
4808:                	host			- Expected host name on certificate (currently ignored)
4809:                	buffer      	- Buffer for supplementary data return
4810:                	suppDataType 	- Type of supplementary data to copy
4811:                
4812:                  Return Values:
4813:                	TRUE 		- an SSL connection was initiated
4814:                	FALSE 		- Insufficient SSL resources (stubs) were available
4815:                
4816:                  Remarks:
4817:                	The host parameter is currently ignored and is not validated.
4818:                  ***************************************************************************/
4819:                #if defined(STACK_USE_SSL_CLIENT)
4820:                BOOL TCPStartSSLClientEx(TCP_SOCKET hTCP, BYTE* host, void * buffer, BYTE suppDataType)
4821:                {
4822:                	BYTE i;
4823:                	
4824:                	if(hTCP >= TCP_SOCKET_COUNT)
4825:                    {
4826:                        return FALSE;
4827:                    }
4828:                    
4829:                	SyncTCBStub(hTCP);
4830:                	
4831:                	// Make sure SSL is not established already
4832:                	if(MyTCBStub.sslStubID != SSL_INVALID_ID)
4833:                		return FALSE;
4834:                	
4835:                	// Try to start the session
4836:                	MyTCBStub.sslStubID = SSLStartSession(hTCP, buffer, suppDataType);
4837:                	
4838:                	// Make sure a session stub was obtained
4839:                	if(MyTCBStub.sslStubID == SSL_INVALID_ID)
4840:                		return FALSE;
4841:                
4842:                	// Mark connection as handshaking and return
4843:                	MyTCBStub.sslReqMessage = SSL_CLIENT_HELLO;
4844:                	MyTCBStub.sslRxHead = MyTCBStub.rxHead;
4845:                	MyTCBStub.sslTxHead = MyTCBStub.txHead;
4846:                	MyTCBStub.Flags.bSSLHandshaking = 1;
4847:                	for(i = 0; i < 5u; i++)
4848:                	{// Skip first 5 bytes in TX for the record header
4849:                		if(++MyTCBStub.sslTxHead >= MyTCBStub.bufferRxStart)
4850:                			MyTCBStub.sslTxHead = MyTCBStub.bufferTxStart;
4851:                	}
4852:                	return TRUE;
4853:                }
4854:                #endif // SSL Client
4855:                
4856:                /*****************************************************************************
4857:                  Function:
4858:                	BOOL TCPStartSSLServer(TCP_SOCKET hTCP)
4859:                
4860:                  Summary:
4861:                	Begins an SSL server session.
4862:                
4863:                  Description:
4864:                	This function sets up an SSL server session when a new connection is
4865:                	established on an SSL port.
4866:                
4867:                  Precondition:
4868:                	TCP is initialized and hTCP is already connected.
4869:                
4870:                  Parameters:
4871:                	hTCP		- TCP connection to secure
4872:                
4873:                  Return Values:
4874:                	TRUE		- an SSL connection was initiated
4875:                	FALSE		- Insufficient SSL resources (stubs) were available
4876:                  ***************************************************************************/
4877:                #if defined(STACK_USE_SSL_SERVER)
4878:                BOOL TCPStartSSLServer(TCP_SOCKET hTCP)
4879:                {
4880:                	BYTE i;
4881:                	
4882:                	if(hTCP >= TCP_SOCKET_COUNT)
4883:                    {
4884:                        return FALSE;
4885:                    }
4886:                    
4887:                	SyncTCBStub(hTCP);
4888:                	SyncTCB();
4889:                	
4890:                	// Make sure SSL is not established already
4891:                	if(MyTCBStub.sslStubID != SSL_INVALID_ID)
4892:                		return TRUE;
4893:                	
4894:                	// Try to start the session
4895:                	MyTCBStub.sslStubID = SSLStartSession(hTCP, NULL, 0);
4896:                	
4897:                	// Make sure a session stub was obtained
4898:                	if(MyTCBStub.sslStubID == SSL_INVALID_ID)
4899:                		return FALSE;
4900:                
4901:                	// Swap the localPort and localSSLPort
4902:                	MyTCBStub.remoteHash.Val = MyTCB.localPort.Val;
4903:                	MyTCB.localPort.Val = MyTCB.localSSLPort.Val;
4904:                	MyTCB.localSSLPort.Val = MyTCBStub.remoteHash.Val;	
4905:                
4906:                	// Mark connection as handshaking and return
4907:                	MyTCBStub.sslReqMessage = SSL_NO_MESSAGE;
4908:                	MyTCBStub.sslRxHead = MyTCBStub.rxHead;
4909:                	MyTCBStub.sslTxHead = MyTCBStub.txHead;
4910:                	MyTCBStub.Flags.bSSLHandshaking = 1;
4911:                	for(i = 0; i < 5u; i++)
4912:                	{// Skip first 5 bytes in TX for the record header
4913:                		if(++MyTCBStub.sslTxHead >= MyTCBStub.bufferRxStart)
4914:                			MyTCBStub.sslTxHead = MyTCBStub.bufferTxStart;
4915:                	}
4916:                	return TRUE;
4917:                }
4918:                #endif // SSL Client
4919:                
4920:                /*****************************************************************************
4921:                  Function:
4922:                	BOOL TCPAddSSLListener(TCP_SOCKET hTCP, WORD port)
4923:                
4924:                  Summary:
4925:                	Listens for SSL connection on a specific port.
4926:                
4927:                  Description:
4928:                	This function adds an additional listening port to a TCP connection.  
4929:                	Connections made on this alternate port will be secured via SSL.
4930:                
4931:                  Precondition:
4932:                	TCP is initialized and hTCP is listening.
4933:                
4934:                  Parameters:
4935:                	hTCP		- TCP connection to secure
4936:                	port		- SSL port to listen on
4937:                
4938:                  Return Values:
4939:                	TRUE		- SSL port was added.
4940:                	FALSE		- The socket was not a listening socket.
4941:                  ***************************************************************************/
4942:                #if defined(STACK_USE_SSL_SERVER)
4943:                BOOL TCPAddSSLListener(TCP_SOCKET hTCP, WORD port)
4944:                {
4945:                	if(hTCP >= TCP_SOCKET_COUNT)
4946:                    {
4947:                        return FALSE;
4948:                    }
4949:                    
4950:                	SyncTCBStub(hTCP);
4951:                	
4952:                	if(MyTCBStub.smState != TCP_LISTEN)
4953:                		return FALSE;
4954:                	
4955:                	SyncTCB();
4956:                	
4957:                	MyTCB.localSSLPort.Val = port;
4958:                	MyTCBStub.sslTxHead = port;
4959:                
4960:                	return TRUE;
4961:                }
4962:                #endif // SSL Server
4963:                
4964:                /*****************************************************************************
4965:                  Function:
4966:                	BOOL TCPRequestSSLMessage(TCP_SOCKET hTCP, BYTE msg)
4967:                
4968:                  Summary:
4969:                	Requests an SSL message to be transmitted.
4970:                
4971:                  Description:
4972:                	This function is called to request that a specific SSL message be
4973:                	transmitted.  This message should only be called by the SSL module.
4974:                	
4975:                  Precondition:
4976:                	TCP is initialized.
4977:                
4978:                  Parameters:
4979:                	hTCP		- TCP connection to use
4980:                	msg			- One of the SSL_MESSAGE types to transmit.
4981:                
4982:                  Return Values:
4983:                	TRUE		- The message was requested.
4984:                	FALSE		- Another message is already pending transmission.
4985:                  ***************************************************************************/
4986:                #if defined(STACK_USE_SSL)
4987:                BOOL TCPRequestSSLMessage(TCP_SOCKET hTCP, BYTE msg)
4988:                {
4989:                	if(hTCP >= TCP_SOCKET_COUNT)
4990:                    {
4991:                        return FALSE;
4992:                    }
4993:                    
4994:                	SyncTCBStub(hTCP);
4995:                	
4996:                	if(msg == SSL_NO_MESSAGE || MyTCBStub.sslReqMessage == SSL_NO_MESSAGE)
4997:                	{
4998:                		MyTCBStub.sslReqMessage = msg;
4999:                		return TRUE;
5000:                	}
5001:                	
5002:                	return FALSE;
5003:                }
5004:                #endif // SSL
5005:                
5006:                /*****************************************************************************
5007:                  Function:
5008:                	BOOL TCPSSLIsHandshaking(TCP_SOCKET hTCP)
5009:                
5010:                  Summary:
5011:                	Determines if an SSL session is still handshaking.
5012:                
5013:                  Description:
5014:                	Call this function after calling TCPStartSSLClient until FALSE is
5015:                	returned.  Then your application may continue with its normal data
5016:                	transfer (which is now secured).
5017:                	
5018:                  Precondition:
5019:                	TCP is initialized and hTCP is connected.
5020:                
5021:                  Parameters:
5022:                	hTCP		- TCP connection to check
5023:                
5024:                  Return Values:
5025:                	TRUE		- SSL handshake is still progressing
5026:                	FALSE		- SSL handshake has completed
5027:                  ***************************************************************************/
5028:                #if defined(STACK_USE_SSL)
5029:                BOOL TCPSSLIsHandshaking(TCP_SOCKET hTCP)
5030:                {
5031:                	if(hTCP >= TCP_SOCKET_COUNT)
5032:                    {
5033:                        return FALSE;
5034:                    }
5035:                    
5036:                	SyncTCBStub(hTCP);
5037:                	return MyTCBStub.Flags.bSSLHandshaking;	
5038:                }
5039:                #endif // SSL
5040:                
5041:                /*****************************************************************************
5042:                  Function:
5043:                	BOOL TCPIsSSL(TCP_SOCKET hTCP)
5044:                
5045:                  Summary:
5046:                	Determines if a TCP connection is secured with SSL.
5047:                
5048:                  Description:
5049:                	Call this function to determine whether or not a TCP connection is 
5050:                	secured with SSL.
5051:                	
5052:                  Precondition:
5053:                	TCP is initialized and hTCP is connected.
5054:                
5055:                  Parameters:
5056:                	hTCP		- TCP connection to check
5057:                
5058:                  Return Values:
5059:                	TRUE		- Connection is secured via SSL
5060:                	FALSE		- Connection is not secured
5061:                  ***************************************************************************/
5062:                #if defined(STACK_USE_SSL)
5063:                BOOL TCPIsSSL(TCP_SOCKET hTCP)
5064:                {
5065:                	if(hTCP >= TCP_SOCKET_COUNT)
5066:                    {
5067:                        return FALSE;
5068:                    }
5069:                    
5070:                	SyncTCBStub(hTCP);
5071:                	
5072:                	if(MyTCBStub.sslStubID == SSL_INVALID_ID)
5073:                		return FALSE;
5074:                	
5075:                	return TRUE;
5076:                }
5077:                #endif // SSL
5078:                
5079:                /*****************************************************************************
5080:                  Function:
5081:                	void TCPSSLHandshakeComplete(TCP_SOCKET hTCP)
5082:                
5083:                  Summary:
5084:                	Clears the SSL handshake flag.
5085:                
5086:                  Description:
5087:                	This function clears the flag indicating that an SSL handshake is
5088:                	complete.
5089:                	
5090:                  Precondition:
5091:                	TCP is initialized and hTCP is connected.
5092:                
5093:                  Parameters:
5094:                	hTCP		- TCP connection to set
5095:                
5096:                  Returns:
5097:                	None
5098:                
5099:                  Remarks:
5100:                	This function should never be called by an application.  It is used 
5101:                	only by the SSL module itself.
5102:                  ***************************************************************************/
5103:                #if defined(STACK_USE_SSL)
5104:                void TCPSSLHandshakeComplete(TCP_SOCKET hTCP)
5105:                {
5106:                	if(hTCP >= TCP_SOCKET_COUNT)
5107:                    {
5108:                        return;
5109:                    }
5110:                    
5111:                	SyncTCBStub(hTCP);
5112:                	MyTCBStub.Flags.bSSLHandshaking = 0;
5113:                }
5114:                #endif // SSL
5115:                
5116:                /*****************************************************************************
5117:                  Function:
5118:                	void TCPSSLDecryptMAC(TCP_SOCKET hTCP, ARCFOUR_CTX* ctx, WORD len)
5119:                
5120:                  Summary:
5121:                	Decrypts and MACs data arriving via SSL.
5122:                
5123:                  Description:
5124:                	This function decrypts data in the TCP buffer and calculates the MAC over
5125:                	the data.  All data is left in the exact same location in the TCP buffer.
5126:                	It is called to help process incoming SSL records.
5127:                	
5128:                  Precondition:
5129:                	TCP is initialized, hTCP is connected, and ctx's Sbox is loaded.
5130:                
5131:                  Parameters:
5132:                	hTCP		- TCP connection to decrypt in
5133:                	ctx			- ARCFOUR encryption context to use
5134:                	len 		- Number of bytes to crypt
5135:                	inPlace		- TRUE to write back in place, FALSE to write at end of
5136:                					currently visible data.
5137:                
5138:                  Returns:
5139:                	None
5140:                
5141:                  Remarks:
5142:                	This function should never be called by an application.  It is used 
5143:                	only by the SSL module itself.
5144:                  ***************************************************************************/
5145:                #if defined(STACK_USE_SSL)
5146:                void TCPSSLDecryptMAC(TCP_SOCKET hTCP, ARCFOUR_CTX* ctx, WORD len)
5147:                {
5148:                	PTR_BASE wSrc, wDest, wBlockLen, wTemp;
5149:                	BYTE buffer[32];
5150:                	
5151:                	if(hTCP >= TCP_SOCKET_COUNT)
5152:                    {
5153:                        return;
5154:                    }
5155:                    
5156:                	// Set up the pointers
5157:                	SyncTCBStub(hTCP);
5158:                	wSrc = MyTCBStub.rxTail;
5159:                	wDest = wSrc;
5160:                	
5161:                	// Handle 32 bytes at a time
5162:                	while(len)
5163:                	{
5164:                		// Determine how many bytes we can read
5165:                		wBlockLen = sizeof(buffer);
5166:                		if(wBlockLen > len) // Don't do more than we should
5167:                			wBlockLen = len;
5168:                		
5169:                		// Read those bytes to a buffer
5170:                		if(wSrc + wBlockLen > MyTCBStub.bufferEnd)
5171:                		{// Two part read
5172:                			wTemp = MyTCBStub.bufferEnd - wSrc + 1;
5173:                			TCPRAMCopy((PTR_BASE)buffer, TCP_PIC_RAM, wSrc, MyTCBStub.vMemoryMedium, wTemp);
5174:                			TCPRAMCopy((PTR_BASE)buffer+wTemp, TCP_PIC_RAM, MyTCBStub.bufferRxStart, MyTCBStub.vMemoryMedium, wBlockLen - wTemp);
5175:                			wSrc = MyTCBStub.bufferRxStart + wBlockLen - wTemp;
5176:                		}
5177:                		else
5178:                		{
5179:                			TCPRAMCopy((PTR_BASE)buffer, TCP_PIC_RAM, wSrc, MyTCBStub.vMemoryMedium, wBlockLen);
5180:                			wSrc += wBlockLen;
5181:                		}
5182:                		
5183:                		// Decrypt and hash
5184:                		ARCFOURCrypt(ctx, buffer, wBlockLen);
5185:                		SSLMACAdd(buffer, wBlockLen);
5186:                		
5187:                		// Write decrypted bytes back
5188:                		if(wDest + wBlockLen > MyTCBStub.bufferEnd)
5189:                		{// Two part write
5190:                			wTemp = MyTCBStub.bufferEnd - wDest + 1;
5191:                			TCPRAMCopy(wDest, MyTCBStub.vMemoryMedium, (PTR_BASE)buffer, TCP_PIC_RAM, wTemp);
5192:                			TCPRAMCopy(MyTCBStub.bufferRxStart, MyTCBStub.vMemoryMedium, (PTR_BASE)buffer+wTemp, TCP_PIC_RAM, wBlockLen - wTemp);
5193:                			wDest = MyTCBStub.bufferRxStart + wBlockLen - wTemp;
5194:                		}
5195:                		else
5196:                		{
5197:                			TCPRAMCopy(wDest, MyTCBStub.vMemoryMedium, (PTR_BASE)buffer, TCP_PIC_RAM, wBlockLen);
5198:                			wDest += wBlockLen;
5199:                		}
5200:                		
5201:                		// Update the length remaining
5202:                		len -= wBlockLen;
5203:                	}
5204:                }	
5205:                #endif // SSL
5206:                
5207:                /*****************************************************************************
5208:                  Function:
5209:                	void TCPSSLInPlaceMACEncrypt(TCP_SOCKET hTCP, ARCFOUR_CTX* ctx, 
5210:                									BYTE* MACSecret, WORD len)
5211:                
5212:                  Summary:
5213:                	Encrypts and MACs data in place in the TCP TX buffer.
5214:                
5215:                  Description:
5216:                	This function encrypts data in the TCP buffer while calcuating a MAC.  
5217:                	When encryption is finished, the MAC is appended to the buffer and 
5218:                	the record will be ready to transmit.
5219:                	
5220:                  Precondition:
5221:                	TCP is initialized, hTCP is connected, and ctx's Sbox is loaded.
5222:                
5223:                  Parameters:
5224:                	hTCP		- TCP connection to encrypt in
5225:                	ctx			- ARCFOUR encryption context to use
5226:                	MACSecret	- MAC encryption secret to use
5227:                	len 		- Number of bytes to crypt
5228:                
5229:                  Returns:
5230:                	None
5231:                
5232:                  Remarks:
5233:                	This function should never be called by an application.  It is used 
5234:                	only by the SSL module itself.
5235:                  ***************************************************************************/
5236:                #if defined(STACK_USE_SSL)
5237:                void TCPSSLInPlaceMACEncrypt(TCP_SOCKET hTCP, ARCFOUR_CTX* ctx, BYTE* MACSecret, WORD len)
5238:                {
5239:                	PTR_BASE pos;
5240:                	WORD blockLen;
5241:                	BYTE buffer[32];
5242:                	
5243:                	if(hTCP >= TCP_SOCKET_COUNT)
5244:                    {
5245:                        return;
5246:                    }
5247:                    
5248:                	// Set up the pointers
5249:                	SyncTCBStub(hTCP);
5250:                	pos = MyTCBStub.txHead;
5251:                	for(blockLen = 0; blockLen < 5u; blockLen++)
5252:                	{// Skips first 5 bytes for the header
5253:                		if(++pos >= MyTCBStub.bufferRxStart)
5254:                			pos = MyTCBStub.bufferTxStart;
5255:                	}
5256:                	
5257:                	// Handle 32 bytes at a time
5258:                	while(len)
5259:                	{
5260:                		// Determine how many bytes we can read
5261:                		blockLen = sizeof(buffer);
5262:                		if(blockLen > len) // Don't do more than we should
5263:                			blockLen = len;
5264:                		if(blockLen > MyTCBStub.bufferRxStart - pos) // Don't pass the end
5265:                			blockLen = MyTCBStub.bufferRxStart - pos;
5266:                		
5267:                		// Read those bytes to a buffer
5268:                		TCPRAMCopy((PTR_BASE)buffer, TCP_PIC_RAM, pos, MyTCBStub.vMemoryMedium, blockLen);
5269:                		
5270:                		// Hash and encrypt
5271:                		SSLMACAdd(buffer, blockLen);
5272:                		ARCFOURCrypt(ctx, buffer, blockLen);
5273:                		
5274:                		// Put them back
5275:                		TCPRAMCopy(pos, MyTCBStub.vMemoryMedium, (PTR_BASE)buffer, TCP_PIC_RAM, blockLen);
5276:                		
5277:                		// Update the pointers
5278:                		pos += blockLen;
5279:                		len -= blockLen;
5280:                		if(pos >= MyTCBStub.bufferRxStart)
5281:                			pos = MyTCBStub.bufferTxStart;
5282:                	}
5283:                	
5284:                	// Calculate and add the MAC
5285:                	SSLMACCalc(MACSecret, buffer);
5286:                	ARCFOURCrypt(ctx, buffer, 16);
5287:                
5288:                	// Write the MAC to the TX FIFO
5289:                	// Can't use TCPPutArray here because TCPIsPutReady() saves 16 bytes for the MAC
5290:                	// TCPPut* functions use this to prevent writing too much data.  Therefore, the
5291:                	// functionality is duplicated here.
5292:                	
5293:                	len = 16;
5294:                	blockLen = 0;
5295:                	// See if we need a two part put
5296:                	if(MyTCBStub.sslTxHead + len >= MyTCBStub.bufferRxStart)
5297:                	{
5298:                		blockLen = MyTCBStub.bufferRxStart-MyTCBStub.sslTxHead;
5299:                		TCPRAMCopy(MyTCBStub.sslTxHead, MyTCBStub.vMemoryMedium, (PTR_BASE)buffer, TCP_PIC_RAM, blockLen);
5300:                		len -= blockLen;
5301:                		MyTCBStub.sslTxHead = MyTCBStub.bufferTxStart;
5302:                	}
5303:                	
5304:                	TCPRAMCopy(MyTCBStub.sslTxHead, MyTCBStub.vMemoryMedium, (PTR_BASE)&buffer[blockLen], TCP_PIC_RAM, len);
5305:                	MyTCBStub.sslTxHead += len;
5306:                
5307:                }	
5308:                #endif // SSL
5309:                
5310:                /*****************************************************************************
5311:                  Function:
5312:                	void TCPSSLPutRecordHeader(TCP_SOCKET hTCP, BYTE* hdr, BOOL recDone)
5313:                
5314:                  Summary:
5315:                	Writes an SSL record header and sends an SSL record.
5316:                
5317:                  Description:
5318:                	This function writes an SSL record header to the pending TCP SSL data, 
5319:                	then indicates that the data is ready to be sent by moving the txHead
5320:                	pointer.
5321:                	
5322:                	If the record is complete, set recDone to TRUE.  The sslTxHead 
5323:                	pointer will be moved forward 5 bytes to leave space for a future 
5324:                	record header.  If the record is only partially sent, use FALSE and
5325:                	to leave the pointer where it is so that more data can be added
5326:                	to the record.  Partial records can only be used for the 
5327:                	SERVER_CERTIFICATE handshake message.
5328:                	
5329:                  Precondition:
5330:                	TCP is initialized, and hTCP is connected with an active SSL session.
5331:                
5332:                  Parameters:
5333:                	hTCP		- TCP connection to write the header and transmit with
5334:                	hdr			- Record header (5 bytes) to send or NULL to just 
5335:                				  move the pointerctx
5336:                	recDone		- TRUE if the record is done, FALSE otherwise
5337:                
5338:                  Returns:
5339:                	None
5340:                
5341:                  Remarks:
5342:                	This function should never be called by an application.  It is used 
5343:                	only by the SSL module itself.
5344:                  ***************************************************************************/
5345:                #if defined(STACK_USE_SSL)
5346:                void TCPSSLPutRecordHeader(TCP_SOCKET hTCP, BYTE* hdr, BOOL recDone)
5347:                {
5348:                	BYTE i;
5349:                	
5350:                	if(hTCP >= TCP_SOCKET_COUNT)
5351:                    {
5352:                        return;
5353:                    }
5354:                    
5355:                	// Set up the pointers
5356:                	SyncTCBStub(hTCP);
5357:                	
5358:                	// Write the header if needed
5359:                	if(hdr)
5360:                	{// This is a new record, so insert the header
5361:                		for(i = 0; i < 5u; i++)
5362:                		{
5363:                			TCPRAMCopy(MyTCBStub.txHead, MyTCBStub.vMemoryMedium, (PTR_BASE)hdr+i, TCP_PIC_RAM, sizeof(BYTE));
5364:                			if(++MyTCBStub.txHead >= MyTCBStub.bufferRxStart)
5365:                				MyTCBStub.txHead = MyTCBStub.bufferTxStart;
5366:                		}
5367:                	}
5368:                	
5369:                	// Move the txHead pointer to indicate what data is ready
5370:                	// Also, flush just the header, then all the data.  This shotguns two 
5371:                	// packets down the line, therefore causing immediate ACKs by the 
5372:                	// remote node.  Reconnect handshakes are as much as 60% faster now.
5373:                	TCPFlush(hTCP);
5374:                	MyTCBStub.txHead = MyTCBStub.sslTxHead;
5375:                	TCPFlush(hTCP);
5376:                	
5377:                	// If this record is done, move the sslTxHead forward
5378:                	// to accomodate the next record header
5379:                	if(recDone)
5380:                	{
5381:                		for(i = 0; i < 5u; i++)
5382:                		{// Skip first 5 bytes in TX for the record header
5383:                			if(++MyTCBStub.sslTxHead >= MyTCBStub.bufferRxStart)
5384:                				MyTCBStub.sslTxHead = MyTCBStub.bufferTxStart;
5385:                		}
5386:                	}
5387:                }	
5388:                #endif // SSL
5389:                
5390:                /*****************************************************************************
5391:                  Function:
5392:                	WORD TCPSSLGetPendingTxSize(TCP_SOCKET hTCP)
5393:                
5394:                  Summary:
5395:                	Determines how many bytes are pending for a future SSL record.
5396:                
5397:                  Description:
5398:                	This function determines how many bytes are pending for a future SSL
5399:                	record.
5400:                	
5401:                  Precondition:
5402:                	TCP is initialized, and hTCP is connected with an active SSL connection.
5403:                
5404:                  Parameters:
5405:                	hTCP		- TCP connection to check
5406:                
5407:                  Returns:
5408:                	None
5409:                  ***************************************************************************/
5410:                #if defined(STACK_USE_SSL)
5411:                WORD TCPSSLGetPendingTxSize(TCP_SOCKET hTCP)
5412:                {
5413:                	if(hTCP >= TCP_SOCKET_COUNT)
5414:                    {
5415:                        return 0;
5416:                    }
5417:                    
5418:                	SyncTCBStub(hTCP);
5419:                
5420:                	// Non-SSL connections have no pending SSL data
5421:                	//if(MyTCBStub.sslStubID == SSL_INVALID_ID)
5422:                	//	return 0;
5423:                			
5424:                	// Determine how many bytes are waiting to be written in this record
5425:                	if(MyTCBStub.sslTxHead > MyTCBStub.txHead)
5426:                		return MyTCBStub.sslTxHead - MyTCBStub.txHead - 5;
5427:                	else
5428:                		return (MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart - 1) - (MyTCBStub.txHead - MyTCBStub.sslTxHead - 1) - 5;
5429:                }
5430:                #endif
5431:                
5432:                
5433:                /*****************************************************************************
5434:                  Function:
5435:                	void TCPSSLHandleIncoming(TCP_SOCKET hTCP)
5436:                
5437:                  Summary:
5438:                	Hands newly arrive TCP data to the SSL module for processing.
5439:                
5440:                  Description:
5441:                	This function processes incoming TCP data as an SSL record and 
5442:                	performs any necessary repositioning and decrypting.
5443:                	
5444:                  Precondition:
5445:                	TCP is initialized, and hTCP is connected with an active SSL session.
5446:                
5447:                  Parameters:
5448:                	hTCP		- TCP connection to handle incoming data on
5449:                
5450:                  Returns:
5451:                	None
5452:                
5453:                  Remarks:
5454:                	This function should never be called by an application.  It is used 
5455:                	only by the SSL module itself.
5456:                  ***************************************************************************/
5457:                #if defined(STACK_USE_SSL)
5458:                void TCPSSLHandleIncoming(TCP_SOCKET hTCP)
5459:                {
5460:                	PTR_BASE prevRxTail, nextRxHead, startRxTail, wSrc, wDest;
5461:                	WORD wToMove, wLen, wSSLBytesThatPoofed, wDecryptedBytes;
5462:                	
5463:                	if(hTCP >= TCP_SOCKET_COUNT)
5464:                    {
5465:                        return;
5466:                    }
5467:                    
5468:                	// Sync the stub
5469:                	SyncTCBStub(hTCP);
5470:                
5471:                	// If new data is waiting
5472:                	if(MyTCBStub.sslRxHead != MyTCBStub.rxHead)
5473:                	{
5474:                		// Reconfigure pointers for SSL use
5475:                		prevRxTail = MyTCBStub.rxTail;
5476:                		nextRxHead = MyTCBStub.rxHead;
5477:                		MyTCBStub.rxTail = MyTCBStub.rxHead;
5478:                		MyTCBStub.rxHead = MyTCBStub.sslRxHead;
5479:                		
5480:                		do
5481:                		{
5482:                			startRxTail = MyTCBStub.rxTail;
5483:                
5484:                			// Handle incoming data.  This function performs deframing of the 
5485:                			// SSL records, decryption, and MAC verification.
5486:                			wSSLBytesThatPoofed = TCPIsGetReady(hTCP);
5487:                			wDecryptedBytes = SSLRxRecord(hTCP, MyTCBStub.sslStubID);
5488:                			wSSLBytesThatPoofed -= TCPIsGetReady(hTCP);
5489:                
5490:                			// Now need to move data to fill the SSL header/MAC/padding hole, 
5491:                			// if there is one
5492:                			if(wSSLBytesThatPoofed)
5493:                			{	
5494:                				// Sync the TCP so we can see if there is a TCP hole
5495:                				SyncTCB();
5496:                
5497:                				// Calculate how big the SSL hole is
5498:                				if(MyTCB.sHoleSize == -1)
5499:                				{// Just need to move pending SSL data
5500:                					wToMove = TCPIsGetReady(hTCP);
5501:                				}
5502:                				else
5503:                				{// A TCP hole exists, so move all data
5504:                					wToMove = TCPIsGetReady(hTCP) + MyTCB.sHoleSize + MyTCB.wFutureDataSize;
5505:                				}
5506:                				
5507:                				// Start with the destination as the startRxTail and source as current rxTail
5508:                				wDest = startRxTail;
5509:                				wSrc = MyTCBStub.rxTail;
5510:                				
5511:                				// If data exists between the end of the buffer and 
5512:                				// the destination, then move it forward
5513:                				if(wSrc > wDest)
5514:                				{
5515:                					wLen = MyTCBStub.bufferEnd - wSrc + 1;
5516:                					if(wLen > wToMove)
5517:                						wLen = wToMove;
5518:                					TCPRAMCopy(wDest, MyTCBStub.vMemoryMedium, 
5519:                							   wSrc, MyTCBStub.vMemoryMedium, wLen);
5520:                					wDest += wLen;
5521:                					wSrc = MyTCBStub.bufferRxStart;
5522:                					wToMove -= wLen;
5523:                				}
5524:                				
5525:                				// If data remains to be moved, fill in to end of buffer
5526:                				if(wToMove)
5527:                				{
5528:                					wLen = MyTCBStub.bufferEnd - wDest + 1;
5529:                					if(wLen > wToMove)
5530:                						wLen = wToMove;
5531:                					TCPRAMCopy(wDest, MyTCBStub.vMemoryMedium, 
5532:                							   wSrc, MyTCBStub.vMemoryMedium, wLen);
5533:                					wDest = MyTCBStub.bufferRxStart;
5534:                					wSrc += wLen;
5535:                					wToMove -= wLen;
5536:                				}
5537:                				
5538:                				// If data still remains, copy from from front + len to front
5539:                				if(wToMove)
5540:                				{
5541:                					TCPRAMCopy(wDest, MyTCBStub.vMemoryMedium,
5542:                							   wSrc, MyTCBStub.vMemoryMedium, wToMove);
5543:                				}
5544:                
5545:                				// Since bytes poofed, we need to move the head pointers 
5546:                				// backwards by an equal amount.
5547:                				MyTCBStub.rxHead -= wSSLBytesThatPoofed;
5548:                				if(MyTCBStub.rxHead < MyTCBStub.bufferRxStart)
5549:                					MyTCBStub.rxHead += MyTCBStub.bufferEnd - MyTCBStub.bufferRxStart + 1;
5550:                				MyTCBStub.sslRxHead = MyTCBStub.rxHead;
5551:                			}
5552:                				
5553:                			// Move tail pointer forward by the number of decrypted bytes ready 
5554:                			// for the application (but not poofed bytes)
5555:                			MyTCBStub.rxTail = startRxTail + wDecryptedBytes;
5556:                			if(MyTCBStub.rxTail > MyTCBStub.bufferEnd)
5557:                				MyTCBStub.rxTail -= MyTCBStub.bufferEnd - MyTCBStub.bufferRxStart + 1;
5558:                			nextRxHead += wDecryptedBytes;
5559:                			
5560:                			// Loop until SSLRxRecord() runs out of data and stops doing 
5561:                			// anything
5562:                		} while(wSSLBytesThatPoofed || (startRxTail != MyTCBStub.rxTail));
5563:                
5564:                		// Restore TCP buffer pointers to point to the decrypted application data 
5565:                		// only
5566:                		if(nextRxHead > MyTCBStub.bufferEnd)
5567:                			nextRxHead -= MyTCBStub.bufferEnd - MyTCBStub.bufferRxStart + 1;
5568:                		MyTCBStub.rxTail = prevRxTail;
5569:                		MyTCBStub.rxHead = nextRxHead;
5570:                	}
5571:                }	
5572:                #endif
5573:                
5574:                
5575:                #endif //#if defined(STACK_USE_TCP)
---  C:/Users/Diego/Documents/GitHub/pic32webFREERtos/Pic32Web.X/src/tcpip/src/StackTsk.c  --------------
1:                   /*********************************************************************
2:                    *
3:                    *	TCP/IP Stack Manager
4:                    *  Module for Microchip TCP/IP Stack
5:                    *	 -Handles internal RX packet pre-processing prior to dispatching 
6:                    *    to upper application layers.
7:                    *	 -Reference: AN833
8:                    *
9:                    *********************************************************************
10:                   * FileName:        StackTsk.c
11:                   * Dependencies:    ARP, IP, Network layer interface (ENC28J60.c, 
12:                   *					ETH97J60.c, ENCX24J600.c, or WFMac.c)
13:                   * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32
14:                   * Compiler:        Microchip C32 v1.05 or higher
15:                   *					Microchip C30 v3.12 or higher
16:                   *					Microchip C18 v3.30 or higher
17:                   *					HI-TECH PICC-18 PRO 9.63PL2 or higher
18:                   * Company:         Microchip Technology, Inc.
19:                   *
20:                   * Software License Agreement
21:                   *
22:                   * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights
23:                   * reserved.
24:                   *
25:                   * Microchip licenses to you the right to use, modify, copy, and
26:                   * distribute:
27:                   * (i)  the Software when embedded on a Microchip microcontroller or
28:                   *      digital signal controller product ("Device") which is
29:                   *      integrated into Licensee's product; or
30:                   * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h,
31:                   *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device
32:                   *		used in conjunction with a Microchip ethernet controller for
33:                   *		the sole purpose of interfacing with the ethernet controller.
34:                   *
35:                   * You should refer to the license agreement accompanying this
36:                   * Software for additional information regarding your rights and
37:                   * obligations.
38:                   *
39:                   * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT
40:                   * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT
41:                   * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A
42:                   * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL
43:                   * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR
44:                   * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF
45:                   * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS
46:                   * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE
47:                   * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER
48:                   * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT
49:                   * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE.
50:                   *
51:                   *
52:                   * V5.36 ---- STACK_USE_MPFS has been removed.
53:                  ********************************************************************/
54:                  #define __STACKTSK_C
55:                  
56:                  #include "TCPIP Stack/TCPIP.h"
57:                  
58:                  #if defined( WF_CS_TRIS )
59:                      #if defined( WF_CONFIG_CONSOLE )
60:                          #include "TCPIP Stack/WFConsole.h"
61:                      #endif
62:                      #if defined( STACK_USE_EZ_CONFIG ) || defined( EZ_CONFIG_SCAN )
63:                          #include "TCPIP Stack/WFEasyConfig.h"
64:                      #endif
65:                  	#include "TCPIP Stack/WFApi.h"
66:                  #endif
67:                  
68:                  // Stack FSM states.
69:                  typedef enum
70:                  {
71:                      SM_STACK_IDLE,
72:                      SM_STACK_MAC,
73:                      SM_STACK_IP,
74:                      SM_STACK_ARP,
75:                      SM_STACK_TCP,
76:                      SM_STACK_UDP
77:                  } SM_STACK;
78:                  static SM_STACK smStack;
79:                  
80:                  NODE_INFO remoteNode;
81:                  
82:                  #if defined (WF_CS_TRIS) && defined (STACK_USE_DHCP_CLIENT)
83:                  BOOL g_DhcpRenew = FALSE;
84:                  extern void SetDhcpProgressState(void);
85:                  UINT32 g_DhcpRetryTimer = 0;
86:                  #endif
87:                  
88:                  
89:                  /*********************************************************************
90:                   * Function:        void StackInit(void)
91:                   *
92:                   * PreCondition:    None
93:                   *
94:                   * Input:           None
95:                   *
96:                   * Output:          Stack and its componets are initialized
97:                   *
98:                   * Side Effects:    None
99:                   *
100:                  * Note:            This function must be called before any of the
101:                  *                  stack or its component routines are used.
102:                  *
103:                  ********************************************************************/
104:                 void StackInit(void)
105:                 {
9D031DD8  27BDFFE8   ADDIU SP, SP, -24
9D031DDC  AFBF0014   SW RA, 20(SP)
9D031DE0  AFBE0010   SW S8, 16(SP)
9D031DE4  03A0F021   ADDU S8, SP, ZERO
106:                 	static BOOL once = FALSE;
107:                     smStack                     = SM_STACK_IDLE;
9D031DE8  AF808174   SW ZERO, -32396(GP)
108:                 
109:                 #if defined(STACK_USE_IP_GLEANING) || defined(STACK_USE_DHCP_CLIENT)
110:                     /*
111:                      * If DHCP or IP Gleaning is enabled,
112:                      * startup in Config Mode.
113:                      */
114:                     AppConfig.Flags.bInConfigMode = TRUE;
9D031DEC  3C02A000   LUI V0, -24576
9D031DF0  24430728   ADDIU V1, V0, 1832
9D031DF4  9062002C   LBU V0, 44(V1)
9D031DF8  24040001   ADDIU A0, ZERO, 1
9D031DFC  7C8239C4   INS V0, A0, 7, 1
9D031E00  A062002C   SB V0, 44(V1)
115:                 
116:                 #endif
117:                 
118:                 #if defined (WF_CS_TRIS) && defined (STACK_USE_DHCP_CLIENT)
119:                 	g_DhcpRenew = FALSE;
120:                 	g_DhcpRetryTimer = 0;
121:                 #endif
122:                 
123:                 	if (!once) {
9D031E04  8F82817C   LW V0, -32388(GP)
9D031E08  14400008   BNE V0, ZERO, 0x9D031E2C
9D031E0C  00000000   NOP
124:                 		// Seed the LFSRRand() function
125:                 		LFSRSeedRand(GenerateRandomDWORD());
9D031E10  0F40962B   JAL GenerateRandomDWORD
9D031E14  00000000   NOP
9D031E18  00402021   ADDU A0, V0, ZERO
9D031E1C  0F4095EC   JAL LFSRSeedRand
9D031E20  00000000   NOP
126:                 		once = TRUE;
9D031E24  24020001   ADDIU V0, ZERO, 1
9D031E28  AF82817C   SW V0, -32388(GP)
127:                 	}
128:                 
129:                     MACInit();
9D031E2C  0F40717E   JAL MACInit
9D031E30  00000000   NOP
130:                 
131:                 #if defined (WF_AGGRESSIVE_PS) && defined (WF_CS_TRIS)
132:                 	WFEnableAggressivePowerSave();
133:                 #endif
134:                 
135:                 #if defined(WF_CS_TRIS) && defined(STACK_USE_EZ_CONFIG) && !defined(__18CXX)
136:                     WFEasyConfigInit();
137:                 #endif    
138:                 
139:                     ARPInit();
9D031E34  0F40BBF3   JAL ARPInit
9D031E38  00000000   NOP
140:                 
141:                 #if defined(STACK_USE_UDP)
142:                     UDPInit();
9D031E3C  0F40A0C1   JAL UDPInit
9D031E40  00000000   NOP
143:                 #endif
144:                 
145:                 #if defined(STACK_USE_TCP)
146:                     TCPInit();
9D031E44  0F400054   JAL TCPInit
9D031E48  00000000   NOP
147:                 #endif
148:                 
149:                 #if defined(STACK_USE_BERKELEY_API)
150:                 	BerkeleySocketInit();
9D031E4C  0F4089D5   JAL BerkeleySocketInit
9D031E50  00000000   NOP
151:                 #endif
152:                 
153:                 #if defined(STACK_USE_HTTP2_SERVER)
154:                     HTTPInit();
9D031E54  0F404379   JAL HTTPInit
9D031E58  00000000   NOP
155:                 #endif
156:                 
157:                 #if defined(STACK_USE_RSA)
158:                 	RSAInit();
159:                 #endif
160:                 
161:                 #if defined(STACK_USE_SSL)
162:                     SSLInit();
163:                 #endif
164:                 
165:                 #if defined(STACK_USE_FTP_SERVER) && defined(STACK_USE_MPFS2)
166:                     FTPInit();
167:                 #endif
168:                 
169:                 #if defined(STACK_USE_SNMP_SERVER)
170:                 	SNMPInit();
171:                 #endif
172:                 
173:                 #if defined(STACK_USE_DHCP_CLIENT)
174:                 	DHCPInit(0);
9D031E5C  00002021   ADDU A0, ZERO, ZERO
9D031E60  0F409015   JAL DHCPInit
9D031E64  00000000   NOP
175:                     if(!AppConfig.Flags.bIsDHCPEnabled)
9D031E68  3C02A000   LUI V0, -24576
9D031E6C  24420728   ADDIU V0, V0, 1832
9D031E70  9042002C   LBU V0, 44(V0)
9D031E74  30420040   ANDI V0, V0, 64
9D031E78  304200FF   ANDI V0, V0, 255
9D031E7C  14400004   BNE V0, ZERO, 0x9D031E90
9D031E80  00000000   NOP
176:                     {
177:                         DHCPDisable(0);
9D031E84  00002021   ADDU A0, ZERO, ZERO
9D031E88  0F409052   JAL DHCPDisable
9D031E8C  00000000   NOP
178:                     }
179:                 #endif
180:                 
181:                 #if defined(STACK_USE_AUTO_IP)
182:                     AutoIPInit(0);
9D031E90  00002021   ADDU A0, ZERO, ZERO
9D031E94  0F40A929   JAL AutoIPInit
9D031E98  00000000   NOP
183:                 #endif
184:                 
185:                 #if defined(STACK_USE_DYNAMICDNS_CLIENT)
186:                 	DDNSInit();
187:                 #endif
188:                 
189:                 #if defined(STACK_USE_RANDOM)
190:                 	RandomInit();
191:                 #endif
192:                 }
9D031E9C  03C0E821   ADDU SP, S8, ZERO
9D031EA0  8FBF0014   LW RA, 20(SP)
9D031EA4  8FBE0010   LW S8, 16(SP)
9D031EA8  27BD0018   ADDIU SP, SP, 24
9D031EAC  03E00008   JR RA
9D031EB0  00000000   NOP
193:                 
194:                 
195:                 /*********************************************************************
196:                  * Function:        void StackTask(void)
197:                  *
198:                  * PreCondition:    StackInit() is already called.
199:                  *
200:                  * Input:           None
201:                  *
202:                  * Output:          Stack FSM is executed.
203:                  *
204:                  * Side Effects:    None
205:                  *
206:                  * Note:            This FSM checks for new incoming packets,
207:                  *                  and routes it to appropriate stack components.
208:                  *                  It also performs timed operations.
209:                  *
210:                  *                  This function must be called periodically to
211:                  *                  ensure timely responses.
212:                  *
213:                  ********************************************************************/
214:                 void StackTask(void)
215:                 {
9D031EB4  27BDFFD8   ADDIU SP, SP, -40
9D031EB8  AFBF0024   SW RA, 36(SP)
9D031EBC  AFBE0020   SW S8, 32(SP)
9D031EC0  03A0F021   ADDU S8, SP, ZERO
216:                     WORD dataCount;
217:                     IP_ADDR tempLocalIP;
218:                 	BYTE cFrameType;
219:                 	BYTE cIPFrameType;
220:                 
221:                    
222:                     #if defined( WF_CS_TRIS )
223:                         // This task performs low-level MAC processing specific to the MRF24W
224:                         MACProcess();
225:                         #if defined( STACK_USE_EZ_CONFIG ) && !defined(__18CXX)
226:                             WFEasyConfigMgr();
227:                         #endif
228:                         
229:                     	#if defined(STACK_USE_DHCP_CLIENT)
230:                         	// Normally, an application would not include  DHCP module
231:                         	// if it is not enabled. But in case some one wants to disable
232:                         	// DHCP module at run-time, remember to not clear our IP
233:                         	// address if link is removed.
234:                         	if(AppConfig.Flags.bIsDHCPEnabled)
235:                         	{
236:                         		if(g_DhcpRenew == TRUE)
237:                         		{
238:                         			g_DhcpRenew = FALSE;
239:                             		AppConfig.MyIPAddr.Val = AppConfig.DefaultIPAddr.Val;
240:                         			AppConfig.MyMask.Val = AppConfig.DefaultMask.Val;
241:                         			AppConfig.Flags.bInConfigMode = TRUE;
242:                         			DHCPInit(0);
243:                 					g_DhcpRetryTimer = (UINT32)TickGet();
244:                         		} else {
245:                         			if (g_DhcpRetryTimer && TickGet() - g_DhcpRetryTimer >= TICKS_PER_SECOND * 8) {
246:                 						DHCPInit(0);
247:                 						g_DhcpRetryTimer = (UINT32)TickGet();
248:                         			}
249:                         		}
250:                         	
251:                         		// DHCP must be called all the time even after IP configuration is
252:                         		// discovered.
253:                         		// DHCP has to account lease expiration time and renew the configuration
254:                         		// time.
255:                         		DHCPTask();
256:                         		
257:                         		if(DHCPIsBound(0)) {
258:                         			AppConfig.Flags.bInConfigMode = FALSE;
259:                 					g_DhcpRetryTimer = 0;
260:                         		}
261:                         	}
262:                     	#endif // STACK_USE_DHCP_CLIENT
263:                         
264:                     #endif // WF_CS_TRIS
265:                 
266:                 
267:                 	#if defined(STACK_USE_DHCP_CLIENT) && !defined(WF_CS_TRIS)
268:                 	// Normally, an application would not include  DHCP module
269:                 	// if it is not enabled. But in case some one wants to disable
270:                 	// DHCP module at run-time, remember to not clear our IP
271:                 	// address if link is removed.
272:                 	if(AppConfig.Flags.bIsDHCPEnabled)
9D031EC4  3C02A000   LUI V0, -24576
9D031EC8  24420728   ADDIU V0, V0, 1832
9D031ECC  9042002C   LBU V0, 44(V0)
9D031ED0  30420040   ANDI V0, V0, 64
9D031ED4  304200FF   ANDI V0, V0, 255
9D031ED8  10400032   BEQ V0, ZERO, 0x9D031FA4
9D031EDC  00000000   NOP
273:                 	{
274:                 		static BOOL bLastLinkState = FALSE;
275:                 		BOOL bCurrentLinkState;
276:                 		
277:                 		bCurrentLinkState = MACIsLinked();
9D031EE0  0F40726F   JAL MACIsLinked
9D031EE4  00000000   NOP
9D031EE8  AFC20010   SW V0, 16(S8)
278:                 		if(bCurrentLinkState != bLastLinkState)
9D031EEC  8F828178   LW V0, -32392(GP)
9D031EF0  8FC30010   LW V1, 16(S8)
9D031EF4  1062001F   BEQ V1, V0, 0x9D031F74
9D031EF8  00000000   NOP
279:                 		{
280:                 			bLastLinkState = bCurrentLinkState;
9D031EFC  8FC20010   LW V0, 16(S8)
9D031F00  AF828178   SW V0, -32392(GP)
281:                 			if(!bCurrentLinkState)
9D031F04  8FC20010   LW V0, 16(S8)
9D031F08  1440001A   BNE V0, ZERO, 0x9D031F74
9D031F0C  00000000   NOP
282:                 			{
283:                 				AppConfig.MyIPAddr.Val = AppConfig.DefaultIPAddr.Val;
9D031F10  3C02A000   LUI V0, -24576
9D031F14  24420728   ADDIU V0, V0, 1832
9D031F18  88430017   LWL V1, 23(V0)
9D031F1C  98430014   LWR V1, 20(V0)
9D031F20  3C02A000   LUI V0, -24576
9D031F24  24440728   ADDIU A0, V0, 1832
9D031F28  A8830003   SWL V1, 3(A0)
9D031F2C  B8430728   SWR V1, 1832(V0)
284:                 				AppConfig.MyMask.Val = AppConfig.DefaultMask.Val;
9D031F30  3C02A000   LUI V0, -24576
9D031F34  24420728   ADDIU V0, V0, 1832
9D031F38  8843001B   LWL V1, 27(V0)
9D031F3C  98430018   LWR V1, 24(V0)
9D031F40  3C02A000   LUI V0, -24576
9D031F44  24420728   ADDIU V0, V0, 1832
9D031F48  A8430007   SWL V1, 7(V0)
9D031F4C  B8430004   SWR V1, 4(V0)
285:                 				AppConfig.Flags.bInConfigMode = TRUE;
9D031F50  3C02A000   LUI V0, -24576
9D031F54  24430728   ADDIU V1, V0, 1832
9D031F58  9062002C   LBU V0, 44(V1)
9D031F5C  24040001   ADDIU A0, ZERO, 1
9D031F60  7C8239C4   INS V0, A0, 7, 1
9D031F64  A062002C   SB V0, 44(V1)
286:                 				DHCPInit(0);
9D031F68  00002021   ADDU A0, ZERO, ZERO
9D031F6C  0F409015   JAL DHCPInit
9D031F70  00000000   NOP
287:                 			}
288:                 		}
289:                 	
290:                 		// DHCP must be called all the time even after IP configuration is
291:                 		// discovered.
292:                 		// DHCP has to account lease expiration time and renew the configuration
293:                 		// time.
294:                 		DHCPTask();
9D031F74  0F4090CB   JAL DHCPTask
9D031F78  00000000   NOP
295:                 		
296:                 		if(DHCPIsBound(0))
9D031F7C  00002021   ADDU A0, ZERO, ZERO
9D031F80  0F409094   JAL DHCPIsBound
9D031F84  00000000   NOP
9D031F88  10400006   BEQ V0, ZERO, 0x9D031FA4
9D031F8C  00000000   NOP
297:                 			AppConfig.Flags.bInConfigMode = FALSE;
9D031F90  3C02A000   LUI V0, -24576
9D031F94  24430728   ADDIU V1, V0, 1832
9D031F98  9062002C   LBU V0, 44(V1)
9D031F9C  7C0239C4   INS V0, ZERO, 7, 1
9D031FA0  A062002C   SB V0, 44(V1)
298:                 	}
299:                 	#endif
300:                 	
301:                 
302:                     #if defined (STACK_USE_AUTO_IP)
303:                     AutoIPTasks();
9D031FA4  0F40A96C   JAL AutoIPTasks
9D031FA8  00000000   NOP
304:                     #endif
305:                 
306:                 	#if defined(STACK_USE_TCP)
307:                 	// Perform all TCP time related tasks (retransmit, send acknowledge, close connection, etc)
308:                 	TCPTick();
9D031FAC  0F400B09   JAL TCPTick
9D031FB0  00000000   NOP
309:                 	#endif
310:                 
311:                 
312:                 	#if defined(STACK_USE_UDP)
313:                 	UDPTask();
9D031FB4  0F40A172   JAL UDPTask
9D031FB8  00000000   NOP
9D031FBC  0B40C7F2   J 0x9D031FC8
9D031FC0  00000000   NOP
314:                 	#endif
315:                 
316:                 	// Process as many incomming packets as we can
317:                 	while(1)
318:                 	{
319:                 		//if using the random module, generate entropy
320:                 		#if defined(STACK_USE_RANDOM)
321:                 			RandomAdd(remoteNode.MACAddr.v[5]);
322:                 		#endif
323:                 
324:                 		// We are about to fetch a new packet, make sure that the 
325:                 		// UDP module knows that any old RX data it has laying 
326:                 		// around will now be gone.
327:                 		#if defined(STACK_USE_UDP)
328:                 			UDPDiscard();
9D031FC8  0F40A472   JAL UDPDiscard
9D031FCC  00000000   NOP
329:                 		#endif
330:                 
331:                 		// Fetch a packet (throws old one away, if not thrown away 
332:                 		// yet)
333:                 		if(!MACGetHeader(&remoteNode.MACAddr, &cFrameType))
9D031FD0  27C2001C   ADDIU V0, S8, 28
9D031FD4  3C03A000   LUI V1, -24576
9D031FD8  24640640   ADDIU A0, V1, 1600
9D031FDC  00402821   ADDU A1, V0, ZERO
9D031FE0  0F4072D6   JAL MACGetHeader
9D031FE4  00000000   NOP
9D031FE8  10400066   BEQ V0, ZERO, 0x9D032184
9D031FEC  00000000   NOP
334:                 			break;
9D032184  00000000   NOP
9D032188  0B40C865   J 0x9D032194
9D03218C  00000000   NOP
335:                 
336:                 		// When using a WiFi module, filter out all incoming packets that have 
337:                 		// the same source MAC address as our own MAC address.  This is to 
338:                 		// prevent receiving and passing our own broadcast packets up to other 
339:                 		// layers and avoid, for example, having our own gratuitous ARPs get 
340:                 		// answered by ourself.
341:                 		#if defined(WF_CS_TRIS)
342:                 			if(memcmp((void*)&remoteNode.MACAddr, (void*)&AppConfig.MyMACAddr, 6) == 0u)
343:                 				continue;
344:                 		#endif
345:                 
346:                 		// Dispatch the packet to the appropriate handler
347:                 		switch(cFrameType)
9D031FF0  93C2001C   LBU V0, 28(S8)
9D031FF4  10400008   BEQ V0, ZERO, 0x9D032018
9D031FF8  00000000   NOP
9D031FFC  24030006   ADDIU V1, ZERO, 6
9D032000  1443FFF0   BNE V0, V1, 0x9D031FC4
9D032004  00000000   NOP
348:                 		{
349:                 			case MAC_ARP:
350:                 				ARPProcess();
9D032008  0F40BC15   JAL ARPProcess
9D03200C  00000000   NOP
351:                 				break;
9D032010  0B40C85F   J 0x9D03217C
9D032014  00000000   NOP
352:                 	
353:                 			case MAC_IP:
354:                 				if(!IPGetHeader(&tempLocalIP, &remoteNode, &cIPFrameType, &dataCount))
9D032018  27C40018   ADDIU A0, S8, 24
9D03201C  27C3001D   ADDIU V1, S8, 29
9D032020  27C20014   ADDIU V0, S8, 20
9D032024  3C05A000   LUI A1, -24576
9D032028  24A5063C   ADDIU A1, A1, 1596
9D03202C  00603021   ADDU A2, V1, ZERO
9D032030  00403821   ADDU A3, V0, ZERO
9D032034  0F40CE56   JAL IPGetHeader
9D032038  00000000   NOP
9D03203C  14400003   BNE V0, ZERO, 0x9D03204C
9D032040  00000000   NOP
355:                 					break;
9D032044  0B40C85F   J 0x9D03217C
9D032048  00000000   NOP
356:                 
357:                 				#if defined(STACK_USE_ICMP_SERVER) || defined(STACK_USE_ICMP_CLIENT)
358:                 				if(cIPFrameType == IP_PROT_ICMP)
9D03204C  93C3001D   LBU V1, 29(S8)
9D032050  24020001   ADDIU V0, ZERO, 1
9D032054  1462002C   BNE V1, V0, 0x9D032108
9D032058  00000000   NOP
359:                 				{
360:                 					#if defined(STACK_USE_IP_GLEANING)
361:                 					if(AppConfig.Flags.bInConfigMode && AppConfig.Flags.bIsDHCPEnabled)
362:                 					{
363:                 						// According to "IP Gleaning" procedure,
364:                 						// when we receive an ICMP packet with a valid
365:                 						// IP address while we are still in configuration
366:                 						// mode, accept that address as ours and conclude
367:                 						// configuration mode.
368:                 						if(tempLocalIP.Val != 0xffffffff)
369:                 						{
370:                 							AppConfig.Flags.bInConfigMode = FALSE;
371:                 							AppConfig.MyIPAddr = tempLocalIP;
372:                 						}
373:                 					}
374:                 					#endif
375:                 
376:                 					// Process this ICMP packet if it the destination IP address matches our address or one of the broadcast IP addressees
377:                 					if( (tempLocalIP.Val == AppConfig.MyIPAddr.Val) ||
9D03205C  8FC30018   LW V1, 24(S8)
9D032060  3C02A000   LUI V0, -24576
9D032064  24440728   ADDIU A0, V0, 1832
9D032068  88840003   LWL A0, 3(A0)
9D03206C  00802821   ADDU A1, A0, ZERO
9D032070  98450728   LWR A1, 1832(V0)
9D032074  00A01021   ADDU V0, A1, ZERO
9D032078  1062001B   BEQ V1, V0, 0x9D0320E8
9D03207C  00000000   NOP
9D032084  2402FFFF   ADDIU V0, ZERO, -1
9D032088  10620017   BEQ V1, V0, 0x9D0320E8
9D03208C  00000000   NOP
378:                 						(tempLocalIP.Val == 0xFFFFFFFF) ||
9D032080  8FC30018   LW V1, 24(S8)
9D0320E0  14620007   BNE V1, V0, 0x9D032100
9D0320E4  00000000   NOP
379:                 #if defined(STACK_USE_ZEROCONF_LINK_LOCAL) || defined(STACK_USE_ZEROCONF_MDNS_SD)
380:                                                                 (tempLocalIP.Val == 0xFB0000E0) ||
381:                 #endif
382:                 						(tempLocalIP.Val == ((AppConfig.MyIPAddr.Val & AppConfig.MyMask.Val) | ~AppConfig.MyMask.Val)))
9D032090  8FC30018   LW V1, 24(S8)
9D032094  3C02A000   LUI V0, -24576
9D032098  24440728   ADDIU A0, V0, 1832
9D03209C  88840003   LWL A0, 3(A0)
9D0320A0  98440728   LWR A0, 1832(V0)
9D0320A4  3C02A000   LUI V0, -24576
9D0320A8  24420728   ADDIU V0, V0, 1832
9D0320AC  88450007   LWL A1, 7(V0)
9D0320B0  00A03021   ADDU A2, A1, ZERO
9D0320B4  98460004   LWR A2, 4(V0)
9D0320B8  00C01021   ADDU V0, A2, ZERO
9D0320BC  00822024   AND A0, A0, V0
9D0320C0  3C02A000   LUI V0, -24576
9D0320C4  24420728   ADDIU V0, V0, 1832
9D0320C8  88450007   LWL A1, 7(V0)
9D0320CC  00A03021   ADDU A2, A1, ZERO
9D0320D0  98460004   LWR A2, 4(V0)
9D0320D4  00C01021   ADDU V0, A2, ZERO
9D0320D8  00021027   NOR V0, ZERO, V0
9D0320DC  00821025   OR V0, A0, V0
383:                 					{
384:                 						ICMPProcess(&remoteNode, dataCount);
9D0320E8  97C20014   LHU V0, 20(S8)
9D0320EC  3C03A000   LUI V1, -24576
9D0320F0  2464063C   ADDIU A0, V1, 1596
9D0320F4  00402821   ADDU A1, V0, ZERO
9D0320F8  0F40C0D1   JAL ICMPProcess
9D0320FC  00000000   NOP
385:                 					}
386:                 
387:                 					break;
9D032100  0B40C85F   J 0x9D03217C
9D032104  00000000   NOP
388:                 				}
389:                 				#endif
390:                 				
391:                 				#if defined(STACK_USE_TCP)
392:                 				if(cIPFrameType == IP_PROT_TCP)
9D032108  93C3001D   LBU V1, 29(S8)
9D03210C  24020006   ADDIU V0, ZERO, 6
9D032110  1462000B   BNE V1, V0, 0x9D032140
9D032114  00000000   NOP
393:                 				{
394:                 					TCPProcess(&remoteNode, &tempLocalIP, dataCount);
9D032118  97C20014   LHU V0, 20(S8)
9D03211C  27C30018   ADDIU V1, S8, 24
9D032120  3C04A000   LUI A0, -24576
9D032124  2484063C   ADDIU A0, A0, 1596
9D032128  00602821   ADDU A1, V1, ZERO
9D03212C  00403021   ADDU A2, V0, ZERO
9D032130  0F400F2A   JAL TCPProcess
9D032134  00000000   NOP
395:                 					break;
9D032138  0B40C85F   J 0x9D03217C
9D03213C  00000000   NOP
396:                 				}
397:                 				#endif
398:                 				
399:                 				#if defined(STACK_USE_UDP)
400:                 				if(cIPFrameType == IP_PROT_UDP)
9D032140  93C3001D   LBU V1, 29(S8)
9D032144  24020011   ADDIU V0, ZERO, 17
9D032148  1462000B   BNE V1, V0, 0x9D032178
9D03214C  00000000   NOP
401:                 				{
402:                 					// Stop processing packets if we came upon a UDP frame with application data in it
403:                 					if(UDPProcess(&remoteNode, &tempLocalIP, dataCount))
9D032150  97C20014   LHU V0, 20(S8)
9D032154  27C30018   ADDIU V1, S8, 24
9D032158  3C04A000   LUI A0, -24576
9D03215C  2484063C   ADDIU A0, A0, 1596
9D032160  00602821   ADDU A1, V1, ZERO
9D032164  00403021   ADDU A2, V0, ZERO
9D032168  0F40A48A   JAL UDPProcess
9D03216C  00000000   NOP
9D032170  14400007   BNE V0, ZERO, 0x9D032190
9D032174  00000000   NOP
404:                 						return;
9D032190  00000000   NOP
405:                 				}
406:                 				#endif
407:                 
408:                 				break;
9D032178  00000000   NOP
409:                 		}
410:                 	}
9D031FC4  00000000   NOP
9D03217C  0B40C7F2   J 0x9D031FC8
9D032180  00000000   NOP
411:                 }
9D032194  03C0E821   ADDU SP, S8, ZERO
9D032198  8FBF0024   LW RA, 36(SP)
9D03219C  8FBE0020   LW S8, 32(SP)
9D0321A0  27BD0028   ADDIU SP, SP, 40
9D0321A4  03E00008   JR RA
9D0321A8  00000000   NOP
412:                 
413:                 /*********************************************************************
414:                  * Function:        void StackApplications(void)
415:                  *
416:                  * PreCondition:    StackInit() is already called.
417:                  *
418:                  * Input:           None
419:                  *
420:                  * Output:          Calls all loaded application modules.
421:                  *
422:                  * Side Effects:    None
423:                  *
424:                  * Note:            This function must be called periodically to
425:                  *                  ensure timely responses.
426:                  *
427:                  ********************************************************************/
428:                 void StackApplications(void)
429:                 {
9D0321AC  27BDFFE8   ADDIU SP, SP, -24
9D0321B0  AFBF0014   SW RA, 20(SP)
9D0321B4  AFBE0010   SW S8, 16(SP)
9D0321B8  03A0F021   ADDU S8, SP, ZERO
430:                 	#if defined(STACK_USE_HTTP2_SERVER)
431:                 	HTTPServer();
9D0321BC  0F4043C0   JAL HTTPServer
9D0321C0  00000000   NOP
432:                 	#endif
433:                 	
434:                 	#if defined(STACK_USE_FTP_SERVER) && defined(STACK_USE_MPFS2)
435:                 	FTPServer();
436:                 	#endif
437:                 	
438:                 	#if defined(STACK_USE_SNMP_SERVER)
439:                 	SNMPTask();
440:                 	#endif
441:                 	
442:                 	#if defined(STACK_USE_ANNOUNCE)
443:                 	DiscoveryTask();
9D0321C4  0F40CC00   JAL DiscoveryTask
9D0321C8  00000000   NOP
444:                 	#endif
445:                 	
446:                 	#if defined(STACK_USE_NBNS)
447:                 	NBNSTask();
9D0321CC  0F40BD54   JAL NBNSTask
9D0321D0  00000000   NOP
448:                 	#endif
449:                 	
450:                 	#if defined(STACK_USE_DHCP_SERVER)
451:                 	DHCPServerTask();
9D0321D4  0F40ACB5   JAL DHCPServerTask
9D0321D8  00000000   NOP
452:                 	#endif
453:                 	
454:                 	#if defined(STACK_USE_DNS_SERVER)
455:                 	DNSServerTask();
456:                 	#endif
457:                 	
458:                 	#if defined (STACK_USE_DYNAMICDNS_CLIENT)
459:                 	DDNSTask();
460:                 	#endif
461:                 	
462:                 	#if defined(STACK_USE_TELNET_SERVER)
463:                 	TelnetTask();
9D0321DC  0F40B298   JAL TelnetTask
9D0321E0  00000000   NOP
464:                 	#endif
465:                 	
466:                 	#if defined(STACK_USE_REBOOT_SERVER)
467:                 	RebootTask();
9D0321E4  0F40D34C   JAL RebootTask
9D0321E8  00000000   NOP
468:                 	#endif
469:                 	
470:                 	#if defined(STACK_USE_SNTP_CLIENT)
471:                 	SNTPClient();
9D0321EC  0F40CAA3   JAL SNTPClient
9D0321F0  00000000   NOP
472:                 	#endif
473:                 	
474:                 	#if defined(STACK_USE_UDP_PERFORMANCE_TEST)
475:                 	UDPPerformanceTask();
476:                 	#endif
477:                 	
478:                 	#if defined(STACK_USE_TCP_PERFORMANCE_TEST)
479:                 	TCPPerformanceTask();
9D0321F4  0F40BF1D   JAL TCPPerformanceTask
9D0321F8  00000000   NOP
480:                 	#endif
481:                 	
482:                 	#if defined(STACK_USE_SMTP_CLIENT)
483:                 	SMTPTask();
9D0321FC  0F405D44   JAL SMTPTask
9D032200  00000000   NOP
484:                 	#endif
485:                 	
486:                 	#if defined(STACK_USE_UART2TCP_BRIDGE)
487:                 	UART2TCPBridgeTask();
488:                 	#endif
489:                 }
9D032204  03C0E821   ADDU SP, S8, ZERO
9D032208  8FBF0014   LW RA, 20(SP)
9D03220C  8FBE0010   LW S8, 16(SP)
9D032210  27BD0018   ADDIU SP, SP, 24
9D032214  03E00008   JR RA
9D032218  00000000   NOP
490:                 
491:                 #if defined(WF_CS_TRIS) && defined(STACK_USE_DHCP_CLIENT)
492:                 void RenewDhcp(void)
493:                 {
494:                     g_DhcpRenew = TRUE;
495:                     SetDhcpProgressState();
496:                 }    
497:                     
498:                 #endif
499:                 
500:                 
501:                 
---  C:/Users/Diego/Documents/GitHub/pic32webFREERtos/Pic32Web.X/src/tcpip/src/SNTP.c  ------------------
1:                   /*********************************************************************
2:                    *
3:                    *	Simple Network Time Protocol (SNTP) Client Version 3
4:                    *  Module for Microchip TCP/IP Stack
5:                    *	 -Locates an NTP Server from public site using DNS
6:                    *	 -Requests UTC time using SNTP and updates SNTPTime structure
7:                    *	  periodically, according to NTP_QUERY_INTERVAL value
8:                    *	- Reference: RFC 1305
9:                    *
10:                   *********************************************************************
11:                   * FileName:        SNTP.c
12:                   * Dependencies:    UDP, ARP, DNS, Tick
13:                   * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32
14:                   * Compiler:        Microchip C32 v1.05 or higher
15:                   *					Microchip C30 v3.12 or higher
16:                   *					Microchip C18 v3.30 or higher
17:                   *					HI-TECH PICC-18 PRO 9.63PL2 or higher
18:                   * Company:         Microchip Technology, Inc.
19:                   *
20:                   * Software License Agreement
21:                   *
22:                   * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights
23:                   * reserved.
24:                   *
25:                   * Microchip licenses to you the right to use, modify, copy, and
26:                   * distribute:
27:                   * (i)  the Software when embedded on a Microchip microcontroller or
28:                   *      digital signal controller product ("Device") which is
29:                   *      integrated into Licensee's product; or
30:                   * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h,
31:                   *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device
32:                   *		used in conjunction with a Microchip ethernet controller for
33:                   *		the sole purpose of interfacing with the ethernet controller.
34:                   *
35:                   * You should refer to the license agreement accompanying this
36:                   * Software for additional information regarding your rights and
37:                   * obligations.
38:                   *
39:                   * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT
40:                   * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT
41:                   * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A
42:                   * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL
43:                   * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR
44:                   * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF
45:                   * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS
46:                   * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE
47:                   * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER
48:                   * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT
49:                   * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE.
50:                   *
51:                   *
52:                   * Author               Date    	Comment
53:                   *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
54:                   * Darren Wenn			03/08/07	Original
55:                   * Howard Schlunder		06/20/07	Modified for release
56:                   ********************************************************************/
57:                  #define __SNTP_C
58:                  
59:                  #include "TCPIPConfig.h"
60:                  
61:                  #if defined(STACK_USE_SNTP_CLIENT)
62:                  
63:                  #include "TCPIP Stack/TCPIP.h"
64:                  
65:                  
66:                  // Defines how frequently to resynchronize the date/time (default: 10 minutes)
67:                  #define NTP_QUERY_INTERVAL		(10ull*60ull * TICK_SECOND)
68:                  
69:                  // Defines how long to wait to retry an update after a failure.
70:                  // Updates may take up to 6 seconds to fail, so this 14 second delay is actually only an 8-second retry.
71:                  #define NTP_FAST_QUERY_INTERVAL	(14ull * TICK_SECOND)
72:                  
73:                  // Port for contacting NTP servers
74:                  #define NTP_SERVER_PORT			(123ul)
75:                  
76:                  // Reference Epoch to use.  (default: 01-Jan-1970 00:00:00)
77:                  #define NTP_EPOCH 				(86400ul * (365ul * 70ul + 17ul))
78:                  
79:                  // Defines how long to wait before assuming the query has failed
80:                  #define NTP_REPLY_TIMEOUT		(6ul*TICK_SECOND)
81:                  
82:                  // These are normally available network time servers.
83:                  // The actual IP returned from the pool will vary every
84:                  // minute so as to spread the load around stratum 1 timeservers.
85:                  // For best accuracy and network overhead you should locate the 
86:                  // pool server closest to your geography, but it will still work
87:                  // if you use the global pool.ntp.org address or choose the wrong 
88:                  // one or ship your embedded device to another geography.
89:                  #define NTP_SERVER	"pool.ntp.org"
90:                  //#define NTP_SERVER	"europe.pool.ntp.org"
91:                  //#define NTP_SERVER	"asia.pool.ntp.org"
92:                  //#define NTP_SERVER	"oceania.pool.ntp.org"
93:                  //#define NTP_SERVER	"north-america.pool.ntp.org"
94:                  //#define NTP_SERVER	"south-america.pool.ntp.org"
95:                  //#define NTP_SERVER	"africa.pool.ntp.org"
96:                  
97:                  // Defines the structure of an NTP packet
98:                  typedef struct
99:                  {
100:                 	struct
101:                 	{
102:                 		BYTE mode			: 3;	// NTP mode
103:                 		BYTE versionNumber 	: 3;	// SNTP version number
104:                 		BYTE leapIndicator	: 2;	// Leap second indicator
105:                 	} flags;						// Flags for the packet
106:                 
107:                 	BYTE stratum;					// Stratum level of local clock
108:                 	CHAR poll;						// Poll interval
109:                 	CHAR precision;					// Precision (seconds to nearest power of 2)
110:                 	DWORD root_delay;				// Root delay between local machine and server
111:                 	DWORD root_dispersion;			// Root dispersion (maximum error)
112:                 	DWORD ref_identifier;			// Reference clock identifier
113:                 	DWORD ref_ts_secs;				// Reference timestamp (in seconds)
114:                 	DWORD ref_ts_fraq;				// Reference timestamp (fractions)
115:                 	DWORD orig_ts_secs;				// Origination timestamp (in seconds)
116:                 	DWORD orig_ts_fraq;				// Origination timestamp (fractions)
117:                 	DWORD recv_ts_secs;				// Time at which request arrived at sender (seconds)
118:                 	DWORD recv_ts_fraq;				// Time at which request arrived at sender (fractions)
119:                 	DWORD tx_ts_secs;				// Time at which request left sender (seconds)
120:                 	DWORD tx_ts_fraq;				// Time at which request left sender (fractions)
121:                 } NTP_PACKET;
122:                 
123:                 // Seconds value obtained by last update
124:                 static DWORD dwSNTPSeconds = 0;
125:                 
126:                 // Tick count of last update
127:                 static DWORD dwLastUpdateTick = 0;
128:                 
129:                 
130:                 /*****************************************************************************
131:                   Function:
132:                 	void SNTPClient(void)
133:                 
134:                   Summary:
135:                 	Periodically checks the current time from a pool of servers.
136:                 
137:                   Description:
138:                 	This function periodically checks a pool of time servers to obtain the
139:                 	current date/time.
140:                 
141:                   Precondition:
142:                 	UDP is initialized.
143:                 
144:                   Parameters:
145:                 	None
146:                 
147:                   Returns:
148:                   	None
149:                   	
150:                   Remarks:
151:                 	This function requires once available UDP socket while processing, but
152:                 	frees that socket when the SNTP module is idle.
153:                   ***************************************************************************/
154:                 void SNTPClient(void)
155:                 {
9D032A8C  27BDFFB0   ADDIU SP, SP, -80
9D032A90  AFBF004C   SW RA, 76(SP)
9D032A94  AFBE0048   SW S8, 72(SP)
9D032A98  03A0F021   ADDU S8, SP, ZERO
156:                 	NTP_PACKET			pkt;
157:                 	WORD		 		w;
158:                 //	static NODE_INFO	Server;
159:                 	static DWORD		dwTimer;
160:                 	static UDP_SOCKET	MySocket = INVALID_UDP_SOCKET;
161:                 	static enum
162:                 	{
163:                 		SM_HOME = 0,
164:                 		SM_UDP_IS_OPENED,
165:                 		//SM_NAME_RESOLVE,
166:                 		//SM_ARP_START_RESOLVE,
167:                 		//SM_ARP_RESOLVE,
168:                 		//SM_ARP_START_RESOLVE2,
169:                 		//SM_ARP_RESOLVE2,
170:                 		//SM_ARP_START_RESOLVE3,
171:                 		//SM_ARP_RESOLVE3,
172:                 		//SM_ARP_RESOLVE_FAIL,
173:                 		SM_UDP_SEND,
174:                 		SM_UDP_RECV,
175:                 		SM_SHORT_WAIT,
176:                 		SM_WAIT
177:                 	} SNTPState = SM_HOME;
178:                 
179:                 
180:                 	switch(SNTPState)
9D032A9C  8F82816C   LW V0, -32404(GP)
9D032AA0  2C430006   SLTIU V1, V0, 6
9D032AA4  106000CB   BEQ V1, ZERO, 0x9D032DD4
9D032AA8  00000000   NOP
9D032AAC  00021880   SLL V1, V0, 2
9D032AB0  3C029D03   LUI V0, -25341
9D032AB4  24422AC8   ADDIU V0, V0, 10952
9D032AB8  00621021   ADDU V0, V1, V0
9D032ABC  8C420000   LW V0, 0(V0)
9D032AC0  00400008   JR V0
9D032AC4  00000000   NOP
181:                 	{
182:                 		case SM_HOME:
183:                 			if(MySocket == INVALID_UDP_SOCKET)
9D032AE0  93838026   LBU V1, -32730(GP)
9D032AE4  240200FF   ADDIU V0, ZERO, 255
9D032AE8  1462000A   BNE V1, V0, 0x9D032B14
9D032AEC  00000000   NOP
184:                 				MySocket = UDPOpenEx((DWORD)NTP_SERVER,UDP_OPEN_ROM_HOST,0,NTP_SERVER_PORT);
9D032AF0  3C029D03   LUI V0, -25341
9D032AF4  2442624C   ADDIU V0, V0, 25164
9D032AF8  00402021   ADDU A0, V0, ZERO
9D032AFC  24050002   ADDIU A1, ZERO, 2
9D032B00  00003021   ADDU A2, ZERO, ZERO
9D032B04  2407007B   ADDIU A3, ZERO, 123
9D032B08  0F40A0DD   JAL UDPOpenEx
9D032B0C  00000000   NOP
9D032B10  A3828026   SB V0, -32730(GP)
185:                 			
186:                 			SNTPState++;
9D032B14  8F82816C   LW V0, -32404(GP)
9D032B18  24420001   ADDIU V0, V0, 1
9D032B1C  AF82816C   SW V0, -32404(GP)
187:                 			break;
9D032B20  0B40CB75   J 0x9D032DD4
9D032B24  00000000   NOP
188:                 			
189:                 		case SM_UDP_IS_OPENED:
190:                 			if(UDPIsOpened(MySocket) == TRUE)
9D032B28  93828026   LBU V0, -32730(GP)
9D032B2C  00402021   ADDU A0, V0, ZERO
9D032B30  0F40A2A6   JAL UDPIsOpened
9D032B34  00000000   NOP
9D032B38  00401821   ADDU V1, V0, ZERO
9D032B3C  24020001   ADDIU V0, ZERO, 1
9D032B40  14620094   BNE V1, V0, 0x9D032D94
9D032B44  00000000   NOP
191:                 			{
192:                 				SNTPState = SM_UDP_SEND;
9D032B48  24020002   ADDIU V0, ZERO, 2
9D032B4C  AF82816C   SW V0, -32404(GP)
193:                 			}
194:                 		/*	else
195:                 			{
196:                 				UDPClose(MySocket);
197:                 				SNTPState = SM_HOME;
198:                 				MySocket = INVALID_UDP_SOCKET;
199:                 			}
200:                 		*/		
201:                 			break;
9D032B50  0B40CB75   J 0x9D032DD4
9D032B54  00000000   NOP
9D032D94  00000000   NOP
9D032D98  0B40CB75   J 0x9D032DD4
9D032D9C  00000000   NOP
202:                 
203:                 #if 0			
204:                 			// Obtain ownership of the DNS resolution module
205:                 			if(!DNSBeginUsage())
206:                 				break;
207:                 
208:                 			// Obtain the IP address associated with the server name
209:                 			DNSResolveROM((ROM BYTE*)NTP_SERVER, DNS_TYPE_A);
210:                 			dwTimer = TickGet();
211:                 			SNTPState = SM_NAME_RESOLVE;
212:                 			break;
213:                 
214:                 		case SM_NAME_RESOLVE:
215:                 			// Wait for DNS resolution to complete
216:                 			if(!DNSIsResolved(&Server.IPAddr)) 
217:                 			{
218:                 				if((TickGet() - dwTimer) > (5 * TICK_SECOND)) 
219:                 				{
220:                 					DNSEndUsage();
221:                 					dwTimer = TickGetDiv64K();
222:                 					SNTPState = SM_SHORT_WAIT;
223:                 				}
224:                 				break;
225:                 			}
226:                 			
227:                 			// Obtain DNS resolution result
228:                 			if(!DNSEndUsage())
229:                 			{
230:                 				// No valid IP address was returned from the DNS 
231:                 				// server.  Quit and fail for a while if host is not valid.
232:                 				dwTimer = TickGetDiv64K();
233:                 				SNTPState = SM_SHORT_WAIT;
234:                 				break;
235:                 			}
236:                 			SNTPState = SM_ARP_START_RESOLVE;
237:                 			// No need to break
238:                 
239:                 		case SM_ARP_START_RESOLVE:
240:                 		case SM_ARP_START_RESOLVE2:
241:                 		case SM_ARP_START_RESOLVE3:
242:                 			// Obtain the MAC address associated with the server's IP address 
243:                 			ARPResolve(&Server.IPAddr);
244:                 			dwTimer = TickGet();
245:                 			SNTPState++;
246:                 			break;
247:                 
248:                 		case SM_ARP_RESOLVE:
249:                 		case SM_ARP_RESOLVE2:
250:                 		case SM_ARP_RESOLVE3:
251:                 			// Wait for the MAC address to finish being obtained
252:                 			if(!ARPIsResolved(&Server.IPAddr, &Server.MACAddr))
253:                 			{
254:                 				// Time out if too much time is spent in this state
255:                 				if(TickGet() - dwTimer > 1*TICK_SECOND)
256:                 				{
257:                 					// Retransmit ARP request by going to next SM_ARP_START_RESOLVE state or fail by going to SM_ARP_RESOLVE_FAIL state.
258:                 					SNTPState++;
259:                 				}
260:                 				break;
261:                 			}
262:                 			SNTPState = SM_UDP_SEND;
263:                 			break;
264:                 
265:                 		case SM_ARP_RESOLVE_FAIL:
266:                 			// ARP failed after 3 tries, abort and wait for next time query
267:                 			dwTimer = TickGetDiv64K();
268:                 			SNTPState = SM_SHORT_WAIT;
269:                 			break;
270:                 #endif
271:                 // case SM_UDP_IS_OPENED:
272:                 		case SM_UDP_SEND:
273:                 			// Open up the sending UDP socket
274:                 			//MySocket = UDPOpen(0, &Server, NTP_SERVER_PORT);
275:                 #if 0
276:                 
277:                 			MySocket = UDPOpenEx(NTP_SERVER,UDP_OPEN_ROM_HOST,0,NTP_SERVER_PORT);
278:                 			if(MySocket == INVALID_UDP_SOCKET)
279:                 				break;
280:                 #endif			
281:                 
282:                 			// Make certain the socket can be written to
283:                 			if(!UDPIsPutReady(MySocket))
9D032B58  93828026   LBU V0, -32730(GP)
9D032B5C  00402021   ADDU A0, V0, ZERO
9D032B60  0F40A307   JAL UDPIsPutReady
9D032B64  00000000   NOP
9D032B68  1440000A   BNE V0, ZERO, 0x9D032B94
9D032B6C  00000000   NOP
284:                 			{
285:                 				UDPClose(MySocket);
9D032B70  93828026   LBU V0, -32730(GP)
9D032B74  00402021   ADDU A0, V0, ZERO
9D032B78  0F40A2B9   JAL UDPClose
9D032B7C  00000000   NOP
286:                 				SNTPState = SM_HOME;
9D032B80  AF80816C   SW ZERO, -32404(GP)
287:                 				MySocket = INVALID_UDP_SOCKET;
9D032B84  2402FFFF   ADDIU V0, ZERO, -1
9D032B88  A3828026   SB V0, -32730(GP)
288:                 				break;
9D032B8C  0B40CB75   J 0x9D032DD4
9D032B90  00000000   NOP
289:                 			}
290:                 
291:                 			// Transmit a time request packet
292:                 			memset(&pkt, 0, sizeof(pkt));
9D032B94  27C20014   ADDIU V0, S8, 20
9D032B98  00402021   ADDU A0, V0, ZERO
9D032B9C  00002821   ADDU A1, ZERO, ZERO
9D032BA0  24060030   ADDIU A2, ZERO, 48
9D032BA4  0F40D5EC   JAL 0x9D0357B0
9D032BA8  00000000   NOP
293:                 			pkt.flags.versionNumber = 3;	// NTP Version 3
9D032BAC  8FC20014   LW V0, 20(S8)
9D032BB0  24030003   ADDIU V1, ZERO, 3
9D032BB4  7C6228C4   INS V0, V1, 3, 3
9D032BB8  AFC20014   SW V0, 20(S8)
294:                 			pkt.flags.mode = 3;				// NTP Client
9D032BBC  8FC20014   LW V0, 20(S8)
9D032BC0  24030003   ADDIU V1, ZERO, 3
9D032BC4  7C621004   INS V0, V1, 0, 3
9D032BC8  AFC20014   SW V0, 20(S8)
295:                 			pkt.orig_ts_secs = swapl(NTP_EPOCH);
9D032BCC  3C0283AA   LUI V0, -31830
9D032BD0  34447E80   ORI A0, V0, 32384
9D032BD4  0F409A29   JAL swapl
9D032BD8  00000000   NOP
9D032BDC  AFC2002C   SW V0, 44(S8)
296:                 			UDPPutArray((BYTE*) &pkt, sizeof(pkt));	
9D032BE0  27C20014   ADDIU V0, S8, 20
9D032BE4  00402021   ADDU A0, V0, ZERO
9D032BE8  24050030   ADDIU A1, ZERO, 48
9D032BEC  0F40A34D   JAL UDPPutArray
9D032BF0  00000000   NOP
297:                 			UDPFlush();	
9D032BF4  0F40A38D   JAL UDPFlush
9D032BF8  00000000   NOP
298:                 			
299:                 			dwTimer = TickGet();
9D032BFC  0F40CDD6   JAL TickGet
9D032C00  00000000   NOP
9D032C04  AF828170   SW V0, -32400(GP)
300:                 			SNTPState = SM_UDP_RECV;		
9D032C08  24020003   ADDIU V0, ZERO, 3
9D032C0C  AF82816C   SW V0, -32404(GP)
301:                 			break;
9D032C10  0B40CB75   J 0x9D032DD4
9D032C14  00000000   NOP
302:                 
303:                 		case SM_UDP_RECV:
304:                 			// Look for a response time packet
305:                 			if(!UDPIsGetReady(MySocket)) 
9D032C18  93828026   LBU V0, -32730(GP)
9D032C1C  00402021   ADDU A0, V0, ZERO
9D032C20  0F40A3FD   JAL UDPIsGetReady
9D032C24  00000000   NOP
9D032C28  14400014   BNE V0, ZERO, 0x9D032C7C
9D032C2C  00000000   NOP
306:                 			{
307:                 				if((TickGet()) - dwTimer > NTP_REPLY_TIMEOUT)
9D032C30  0F40CDD6   JAL TickGet
9D032C34  00000000   NOP
9D032C38  00401821   ADDU V1, V0, ZERO
9D032C3C  8F828170   LW V0, -32400(GP)
9D032C40  00621823   SUBU V1, V1, V0
9D032C44  3C02000E   LUI V0, 14
9D032C48  34424E1D   ORI V0, V0, 19997
9D032C4C  0062102B   SLTU V0, V1, V0
9D032C50  14400053   BNE V0, ZERO, 0x9D032DA0
9D032C54  00000000   NOP
308:                 				{
309:                 					// Abort the request and wait until the next timeout period
310:                 					UDPClose(MySocket);
9D032C58  93828026   LBU V0, -32730(GP)
9D032C5C  00402021   ADDU A0, V0, ZERO
9D032C60  0F40A2B9   JAL UDPClose
9D032C64  00000000   NOP
311:                 					//dwTimer = TickGetDiv64K();
312:                 					//SNTPState = SM_SHORT_WAIT;
313:                 					SNTPState = SM_HOME;
9D032C68  AF80816C   SW ZERO, -32404(GP)
314:                 					MySocket = INVALID_UDP_SOCKET;
9D032C6C  2402FFFF   ADDIU V0, ZERO, -1
9D032C70  A3828026   SB V0, -32730(GP)
315:                 					break;
9D032C74  0B40CB75   J 0x9D032DD4
9D032C78  00000000   NOP
316:                 				}
317:                 				break;
9D032DA0  00000000   NOP
9D032DA4  0B40CB75   J 0x9D032DD4
9D032DA8  00000000   NOP
318:                 			}
319:                 			
320:                 			// Get the response time packet
321:                 			w = UDPGetArray((BYTE*) &pkt, sizeof(pkt));
9D032C7C  27C20014   ADDIU V0, S8, 20
9D032C80  00402021   ADDU A0, V0, ZERO
9D032C84  24050030   ADDIU A1, ZERO, 48
9D032C88  0F40A442   JAL UDPGetArray
9D032C8C  00000000   NOP
9D032C90  A7C20010   SH V0, 16(S8)
322:                 			UDPClose(MySocket);
9D032C94  93828026   LBU V0, -32730(GP)
9D032C98  00402021   ADDU A0, V0, ZERO
9D032C9C  0F40A2B9   JAL UDPClose
9D032CA0  00000000   NOP
323:                 			dwTimer = TickGetDiv64K();
9D032CA4  0F40CE00   JAL TickGetDiv64K
9D032CA8  00000000   NOP
9D032CAC  AF828170   SW V0, -32400(GP)
324:                 			SNTPState = SM_WAIT;
9D032CB0  24020005   ADDIU V0, ZERO, 5
9D032CB4  AF82816C   SW V0, -32404(GP)
325:                 			MySocket = INVALID_UDP_SOCKET;
9D032CB8  2402FFFF   ADDIU V0, ZERO, -1
9D032CBC  A3828026   SB V0, -32730(GP)
326:                 			
327:                 			// Validate packet size
328:                 			if(w != sizeof(pkt)) 
9D032CC0  97C30010   LHU V1, 16(S8)
9D032CC4  24020030   ADDIU V0, ZERO, 48
9D032CC8  14620038   BNE V1, V0, 0x9D032DAC
9D032CCC  00000000   NOP
329:                 			{
330:                 				break;	
9D032DAC  00000000   NOP
9D032DB0  0B40CB75   J 0x9D032DD4
9D032DB4  00000000   NOP
331:                 			}
332:                 			
333:                 			// Set out local time to match the returned time
334:                 			dwLastUpdateTick = TickGet();
9D032CD0  0F40CDD6   JAL TickGet
9D032CD4  00000000   NOP
9D032CD8  AF828168   SW V0, -32408(GP)
335:                 			dwSNTPSeconds = swapl(pkt.tx_ts_secs) - NTP_EPOCH;
9D032CDC  8FC2003C   LW V0, 60(S8)
9D032CE0  00402021   ADDU A0, V0, ZERO
9D032CE4  0F409A29   JAL swapl
9D032CE8  00000000   NOP
9D032CEC  00401821   ADDU V1, V0, ZERO
9D032CF0  3C027C55   LUI V0, 31829
9D032CF4  34428180   ORI V0, V0, -32384
9D032CF8  00621021   ADDU V0, V1, V0
9D032CFC  AF828164   SW V0, -32412(GP)
336:                 			// Do rounding.  If the partial seconds is > 0.5 then add 1 to the seconds count.
337:                 			if(((BYTE*)&pkt.tx_ts_fraq)[0] & 0x80)
9D032D00  27C20014   ADDIU V0, S8, 20
9D032D04  2442002C   ADDIU V0, V0, 44
9D032D08  90420000   LBU V0, 0(V0)
9D032D0C  7C021420   SEB V0, V0
9D032D10  04410029   BGEZ V0, 0x9D032DB8
9D032D14  00000000   NOP
338:                 				dwSNTPSeconds++;
9D032D18  8F828164   LW V0, -32412(GP)
9D032D1C  24420001   ADDIU V0, V0, 1
9D032D20  AF828164   SW V0, -32412(GP)
339:                 
340:                 			break;
9D032D24  0B40CB75   J 0x9D032DD4
9D032D28  00000000   NOP
9D032DB8  00000000   NOP
9D032DBC  0B40CB75   J 0x9D032DD4
9D032DC0  00000000   NOP
341:                 
342:                 		case SM_SHORT_WAIT:
343:                 			// Attempt to requery the NTP server after a specified NTP_FAST_QUERY_INTERVAL time (ex: 8 seconds) has elapsed.
344:                 			if(TickGetDiv64K() - dwTimer > (NTP_FAST_QUERY_INTERVAL/65536ull))
9D032D2C  0F40CE00   JAL TickGetDiv64K
9D032D30  00000000   NOP
9D032D34  00401821   ADDU V1, V0, ZERO
9D032D38  8F828170   LW V0, -32400(GP)
9D032D3C  00621023   SUBU V0, V1, V0
9D032D40  2C420022   SLTIU V0, V0, 34
9D032D44  1440001F   BNE V0, ZERO, 0x9D032DC4
9D032D48  00000000   NOP
345:                 			{
346:                 				SNTPState = SM_HOME;
9D032D4C  AF80816C   SW ZERO, -32404(GP)
347:                 				MySocket = INVALID_UDP_SOCKET;
9D032D50  2402FFFF   ADDIU V0, ZERO, -1
9D032D54  A3828026   SB V0, -32730(GP)
348:                 			}
349:                 			break;
9D032D58  0B40CB75   J 0x9D032DD4
9D032D5C  00000000   NOP
9D032DC4  00000000   NOP
9D032DC8  0B40CB75   J 0x9D032DD4
9D032DCC  00000000   NOP
350:                 
351:                 		case SM_WAIT:
352:                 			// Requery the NTP server after a specified NTP_QUERY_INTERVAL time (ex: 10 minutes) has elapsed.
353:                 			if(TickGetDiv64K() - dwTimer > (NTP_QUERY_INTERVAL/65536ull))
9D032D60  0F40CE00   JAL TickGetDiv64K
9D032D64  00000000   NOP
9D032D68  00401821   ADDU V1, V0, ZERO
9D032D6C  8F828170   LW V0, -32400(GP)
9D032D70  00621023   SUBU V0, V1, V0
9D032D74  2C420597   SLTIU V0, V0, 1431
9D032D78  14400015   BNE V0, ZERO, 0x9D032DD0
9D032D7C  00000000   NOP
354:                 			{
355:                 				SNTPState = SM_HOME;
9D032D80  AF80816C   SW ZERO, -32404(GP)
356:                 				MySocket = INVALID_UDP_SOCKET;
9D032D84  2402FFFF   ADDIU V0, ZERO, -1
9D032D88  A3828026   SB V0, -32730(GP)
357:                 			}
358:                 
359:                 			break;
9D032D8C  0B40CB75   J 0x9D032DD4
9D032D90  00000000   NOP
9D032DD0  00000000   NOP
360:                 	}
361:                 }
9D032DD4  03C0E821   ADDU SP, S8, ZERO
9D032DD8  8FBF004C   LW RA, 76(SP)
9D032DDC  8FBE0048   LW S8, 72(SP)
9D032DE0  27BD0050   ADDIU SP, SP, 80
9D032DE4  03E00008   JR RA
9D032DE8  00000000   NOP
362:                 
363:                 
364:                 /*****************************************************************************
365:                   Function:
366:                 	DWORD SNTPGetUTCSeconds(void)
367:                 
368:                   Summary:
369:                 	Obtains the current time from the SNTP module.
370:                 
371:                   Description:
372:                 	This function obtains the current time as reported by the SNTP module.  
373:                 	Use this value for absolute time stamping.  The value returned is (by
374:                 	default) the number of seconds since 01-Jan-1970 00:00:00.
375:                 
376:                   Precondition:
377:                 	None
378:                 
379:                   Parameters:
380:                 	None
381:                 
382:                   Returns:
383:                   	The number of seconds since the Epoch.  (Default 01-Jan-1970 00:00:00)
384:                   	
385:                   Remarks:
386:                 	Do not use this function for time difference measurements.  The Tick
387:                 	module is more appropriate for those requirements.
388:                   ***************************************************************************/
389:                 DWORD SNTPGetUTCSeconds(void)
390:                 {
9D032DEC  27BDFFE0   ADDIU SP, SP, -32
9D032DF0  AFBF001C   SW RA, 28(SP)
9D032DF4  AFBE0018   SW S8, 24(SP)
9D032DF8  03A0F021   ADDU S8, SP, ZERO
391:                 	DWORD dwTickDelta;
392:                 	DWORD dwTick;
393:                 
394:                 	// Update the dwSNTPSeconds variable with the number of seconds 
395:                 	// that has elapsed
396:                 	dwTick = TickGet();
9D032DFC  0F40CDD6   JAL TickGet
9D032E00  00000000   NOP
9D032E04  AFC20014   SW V0, 20(S8)
397:                 	dwTickDelta = dwTick - dwLastUpdateTick;
9D032E08  8F828168   LW V0, -32408(GP)
9D032E0C  8FC30014   LW V1, 20(S8)
9D032E10  00621023   SUBU V0, V1, V0
9D032E14  AFC20010   SW V0, 16(S8)
398:                 	while(dwTickDelta > TICK_SECOND)
9D032E18  0B40CB90   J 0x9D032E40
9D032E1C  00000000   NOP
9D032E40  8FC30010   LW V1, 16(S8)
9D032E44  3C020002   LUI V0, 2
9D032E48  3442625B   ORI V0, V0, 25179
9D032E4C  0062102B   SLTU V0, V1, V0
9D032E50  1040FFF3   BEQ V0, ZERO, 0x9D032E20
9D032E54  00000000   NOP
399:                 	{
400:                 		dwSNTPSeconds++;
9D032E20  8F828164   LW V0, -32412(GP)
9D032E24  24420001   ADDIU V0, V0, 1
9D032E28  AF828164   SW V0, -32412(GP)
401:                 		dwTickDelta -= TICK_SECOND;
9D032E2C  8FC30010   LW V1, 16(S8)
9D032E30  3C02FFFD   LUI V0, -3
9D032E34  34429DA6   ORI V0, V0, -25178
9D032E38  00621021   ADDU V0, V1, V0
9D032E3C  AFC20010   SW V0, 16(S8)
402:                 	}
403:                 	
404:                 	// Save the tick and residual fractional seconds for the next call
405:                 	dwLastUpdateTick = dwTick - dwTickDelta;
9D032E58  8FC30014   LW V1, 20(S8)
9D032E5C  8FC20010   LW V0, 16(S8)
9D032E60  00621023   SUBU V0, V1, V0
9D032E64  AF828168   SW V0, -32408(GP)
406:                 
407:                 	return dwSNTPSeconds;
9D032E68  8F828164   LW V0, -32412(GP)
408:                 }
9D032E6C  03C0E821   ADDU SP, S8, ZERO
9D032E70  8FBF001C   LW RA, 28(SP)
9D032E74  8FBE0018   LW S8, 24(SP)
9D032E78  27BD0020   ADDIU SP, SP, 32
9D032E7C  03E00008   JR RA
9D032E80  00000000   NOP
409:                 
410:                 #endif  //if defined(STACK_USE_SNTP_CLIENT)
---  C:/Users/Diego/Documents/GitHub/pic32webFREERtos/Pic32Web.X/src/tcpip/src/SMTP.c  ------------------
1:                   /*********************************************************************
2:                    *
3:                    *	Simple Mail Transfer Protocol (SMTP) Client
4:                    *	Module for Microchip TCP/IP Stack
5:                    *   -Provides ability to send Emails
6:                    *	 -Reference: RFC 2821
7:                    *
8:                    *********************************************************************
9:                    * FileName:        SMTP.c
10:                   * Dependencies:    TCP, ARP, DNS, Tick
11:                   * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32
12:                   * Compiler:        Microchip C32 v1.05 or higher
13:                   *					Microchip C30 v3.12 or higher
14:                   *					Microchip C18 v3.30 or higher
15:                   *					HI-TECH PICC-18 PRO 9.63PL2 or higher
16:                   * Company:         Microchip Technology, Inc.
17:                   *
18:                   * Software License Agreement
19:                   *
20:                   * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights
21:                   * reserved.
22:                   *
23:                   * Microchip licenses to you the right to use, modify, copy, and
24:                   * distribute:
25:                   * (i)  the Software when embedded on a Microchip microcontroller or
26:                   *      digital signal controller product ("Device") which is
27:                   *      integrated into Licensee's product; or
28:                   * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h,
29:                   *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device
30:                   *		used in conjunction with a Microchip ethernet controller for
31:                   *		the sole purpose of interfacing with the ethernet controller.
32:                   *
33:                   * You should refer to the license agreement accompanying this
34:                   * Software for additional information regarding your rights and
35:                   * obligations.
36:                   *
37:                   * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT
38:                   * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT
39:                   * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A
40:                   * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL
41:                   * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR
42:                   * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF
43:                   * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS
44:                   * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE
45:                   * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER
46:                   * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT
47:                   * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE.
48:                   *
49:                   *
50:                   * Author               Date    Comment
51:                   *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
52:                   * Howard Schlunder     3/03/06	Original
53:                   * Howard Schlunder		11/2/06	Vastly improved for release
54:                   ********************************************************************/
55:                  #define __SMTP_C
56:                  
57:                  #include "TCPIPConfig.h"
58:                  
59:                  #if defined(STACK_USE_SMTP_CLIENT)
60:                  
61:                  #include "TCPIP Stack/TCPIP.h"
62:                  
63:                  
64:                  /****************************************************************************
65:                    Section:
66:                  	SMTP Client Configuration Parameters
67:                    ***************************************************************************/
68:                  #define SMTP_PORT					25					// Default port to use when unspecified
69:                  #define SMTP_SERVER_REPLY_TIMEOUT	(TICK_SECOND*8)		// How long to wait before assuming the connection has been dropped (default 8 seconds)
70:                  
71:                  
72:                  /****************************************************************************
73:                    Section:
74:                  	SMTP Client Public Variables
75:                    ***************************************************************************/
76:                  // The global set of SMTP_POINTERS.
77:                  // Set these parameters after calling SMTPBeginUsage successfully.
78:                  SMTP_POINTERS SMTPClient;	
79:                  
80:                  /****************************************************************************
81:                    Section:
82:                  	SMTP Client Internal Variables
83:                    ***************************************************************************/
84:                  static IP_ADDR SMTPServer;						// IP address of the remote SMTP server
85:                  static TCP_SOCKET MySocket = INVALID_SOCKET;	// Socket currently in use by the SMTP client
86:                  
87:                  // State machine for the CR LF Period replacement
88:                  // Used by SMTPPut to transparently replace "\r\n." with "\r\n.."
89:                  static union
90:                  {
91:                  	BYTE *Pos;
92:                  	enum
93:                  	{
94:                  		CR_PERIOD_SEEK_CR = 0,		// Idle state, waiting for '\r'
95:                  		CR_PERIOD_SEEK_LF,			// "\r" has been written, so check next byte for '\n'
96:                  		CR_PERIOD_SEEK_PERIOD,		// "\r\n" has been written, so check next byte for '.'
97:                  		CR_PERIOD_NEED_INSERTION	// "\r\n." has been written, so an additional '.'
98:                  									//   must be written before the next byte.
99:                  	} State;
100:                 } CRPeriod;
101:                 
102:                 // State of the transport for the SMTP Client
103:                 static enum
104:                 {
105:                 	TRANSPORT_HOME = 0,			// Idle state
106:                 	TRANSPORT_BEGIN,			// Preparing to make connection
107:                 	TRANSPORT_NAME_RESOLVE,		// Resolving the SMTP server address
108:                 	TRANSPORT_OBTAIN_SOCKET,	// Obtaining a socket for the SMTP connection
109:                 	#if defined(STACK_USE_SSL_CLIENT)
110:                 	TRANSPORT_SECURING_SOCKET,	// Securing the socket for the SMTP over SSL connection
111:                 	#endif
112:                 	TRANSPORT_SOCKET_OBTAINED,	// SMTP connection successful
113:                 	TRANSPORT_CLOSE				// STMP socket is closed
114:                 } TransportState = TRANSPORT_HOME;
115:                 
116:                 // Message state machine for the SMTP Client
117:                 static enum
118:                 {
119:                 	SMTP_HOME = 0,				// Idle start state for SMTP client (application is preparing message)
120:                 	SMTP_HELO,					// HELO is being sent to server
121:                 	SMTP_HELO_ACK,				// Received an ACK for the HELO
122:                 	SMTP_AUTH_LOGIN,			// Requesting to log in
123:                 	SMTP_AUTH_LOGIN_ACK,		// Log in request accepted
124:                 	SMTP_AUTH_USERNAME,			// Sending user name
125:                 	SMTP_AUTH_USERNAME_ACK,		// User name accepted
126:                 	SMTP_AUTH_PASSWORD,			// Sending password
127:                 	SMTP_AUTH_PASSWORD_ACK,		// Password was accepted
128:                 	SMTP_MAILFROM,				// Sending inital MAIL FROM command
129:                 	SMTP_MAILFROM_ACK,			// MAIL FROM was accepted
130:                 	SMTP_RCPTTO_INIT,			// Preparing to send RCPT TO
131:                 	SMTP_RCPTTO,				// Sending RCPT TO command
132:                 	SMTP_RCPTTO_ACK,			// RCPT TO was accepted
133:                 	SMTP_RCPTTO_ISDONE,			// Done sending RCPT TO commands
134:                 	SMTP_RCPTTOCC_INIT,			// Preparing to send RCPT TO CC commands
135:                 	SMTP_RCPTTOCC,				// Sending RCPT TO CC commands
136:                 	SMTP_RCPTTOCC_ACK,			// RCPT TO CC was accepted
137:                 	SMTP_RCPTTOCC_ISDONE,		// Done sending RCPT TO CC
138:                 	SMTP_RCPTTOBCC_INIT,		// Preparing to send RCPT TO BCC commands
139:                 	SMTP_RCPTTOBCC,				// Sending RCPT TO BCC commands
140:                 	SMTP_RCPTTOBCC_ACK,			// RCPT TO BCC was accepted
141:                 	SMTP_RCPTTOBCC_ISDONE,		// Done sending RCPT TO BCC
142:                 	SMTP_DATA,					// Sending DATA command
143:                 	SMTP_DATA_ACK,				// DATA command accpted
144:                 	SMTP_DATA_HEADER,			// Sending message headers
145:                 	SMTP_DATA_BODY_INIT,		// Preparing for message body
146:                 	SMTP_DATA_BODY,				// Sending message body
147:                 	SMTP_DATA_BODY_ACK,			// Message body accepted
148:                 	SMTP_QUIT_INIT,				// Sending QUIT command
149:                 	SMTP_QUIT					// QUIT accepted, connection closing
150:                 } SMTPState;
151:                 
152:                 // State machine for writing the SMTP message headers
153:                 static enum
154:                 {
155:                 	PUTHEADERS_FROM_INIT = 0,	// Preparing to send From header
156:                 	PUTHEADERS_FROM,			// Sending From header
157:                 	PUTHEADERS_TO_INIT,			// Preparing to send To header
158:                 	PUTHEADERS_TO,				// Sending To header
159:                 	PUTHEADERS_CC_INIT,			// Preparing to send CC header
160:                 	PUTHEADERS_CC,				// Sending CC header
161:                 	PUTHEADERS_SUBJECT_INIT,	// Preparing to send Subject header
162:                 	PUTHEADERS_SUBJECT,			// Sending Subject header
163:                 	PUTHEADERS_OTHER_INIT,		// Preparing to send additional headers
164:                 	PUTHEADERS_OTHER,			// Sending additional headers
165:                 	PUTHEADERS_DONE				// Done writing all headers
166:                 } PutHeadersState;
167:                 
168:                 // State machine for parsing incoming responses
169:                 static enum
170:                 {
171:                 	RX_BYTE_0 = 0,
172:                 	RX_BYTE_1,
173:                 	RX_BYTE_2,
174:                 	RX_BYTE_3,
175:                 	RX_SEEK_CR,
176:                 	RX_SEEK_LF
177:                 } RXParserState;
178:                 
179:                 // Internal flags used by the SMTP Client
180:                 static union
181:                 {
182:                 	BYTE Val;
183:                 	struct
184:                 	{
185:                 		unsigned char RXSkipResponse:1;
186:                 		unsigned char SMTPInUse:1;
187:                 		unsigned char SentSuccessfully:1;
188:                 		unsigned char ReadyToStart:1;
189:                 		unsigned char ReadyToFinish:1;
190:                 		unsigned char ConnectedOnce:1;
191:                 		unsigned char filler:2;
192:                 	} bits;
193:                 } SMTPFlags = {0x00};
194:                 	
195:                 // Response code from server when an error exists
196:                 static WORD ResponseCode;
197:                 
198:                 /****************************************************************************
199:                   Section:
200:                 	SMTP Client Internal Function Prototypes
201:                   ***************************************************************************/
202:                 static BYTE *FindEmailAddress(BYTE *str, WORD *wLen);
203:                 static ROM BYTE *FindROMEmailAddress(ROM BYTE *str, WORD *wLen);
204:                 
205:                 /****************************************************************************
206:                   Section:
207:                 	SMTP Function Implementations
208:                   ***************************************************************************/
209:                 
210:                 /*****************************************************************************
211:                   Function:
212:                 	BOOL SMTPBeginUsage(void)
213:                 
214:                   Summary:
215:                 	Requests control of the SMTP client module.
216:                 
217:                   Description:
218:                 	Call this function before calling any other SMTP Client APIs.  This 
219:                 	function obtains a lock on the SMTP Client, which can only be used by
220:                 	one stack application at a time.  Once the application is finished
221:                 	with the SMTP client, it must call SMTPEndUsage to release control
222:                 	of the module to any other waiting applications.
223:                 	
224:                 	This function initializes all the SMTP state machines and variables
225:                 	back to their default state.
226:                 
227:                   Precondition:
228:                 	None
229:                 
230:                   Parameters:
231:                 	None
232:                 
233:                   Return Values:
234:                 	TRUE - The application has successfully obtained control of the module
235:                 	FALSE - The SMTP module is in use by another application.  Call 
236:                 		SMTPBeginUsage again later, after returning to the main program loop
237:                   ***************************************************************************/
238:                 BOOL SMTPBeginUsage(void)
239:                 {
9D0173BC  27BDFFE8   ADDIU SP, SP, -24
9D0173C0  AFBF0014   SW RA, 20(SP)
9D0173C4  AFBE0010   SW S8, 16(SP)
9D0173C8  03A0F021   ADDU S8, SP, ZERO
240:                 	if(SMTPFlags.bits.SMTPInUse)
9D0173CC  93828148   LBU V0, -32440(GP)
9D0173D0  30420002   ANDI V0, V0, 2
9D0173D4  304200FF   ANDI V0, V0, 255
9D0173D8  10400004   BEQ V0, ZERO, 0x9D0173EC
9D0173DC  00000000   NOP
241:                 		return FALSE;
9D0173E0  00001021   ADDU V0, ZERO, ZERO
9D0173E4  0B405D0F   J 0x9D01743C
9D0173E8  00000000   NOP
242:                 
243:                 	SMTPFlags.Val = 0x00;
9D0173EC  A3808148   SB ZERO, -32440(GP)
244:                 	SMTPFlags.bits.SMTPInUse = TRUE;
9D0173F0  93828148   LBU V0, -32440(GP)
9D0173F4  24030001   ADDIU V1, ZERO, 1
9D0173F8  7C620844   INS V0, V1, 1, 1
9D0173FC  A3828148   SB V0, -32440(GP)
245:                 	TransportState = TRANSPORT_BEGIN;
9D017400  24020001   ADDIU V0, ZERO, 1
9D017404  AF828138   SW V0, -32456(GP)
246:                 	RXParserState = RX_BYTE_0;
9D017408  AF808144   SW ZERO, -32444(GP)
247:                 	SMTPState = SMTP_HOME;
9D01740C  AF80813C   SW ZERO, -32452(GP)
248:                 	memset((void*)&SMTPClient, 0x00, sizeof(SMTPClient));
9D017410  3C02A000   LUI V0, -24576
9D017414  24440610   ADDIU A0, V0, 1552
9D017418  00002821   ADDU A1, ZERO, ZERO
9D01741C  2406002C   ADDIU A2, ZERO, 44
9D017420  0F40D5EC   JAL 0x9D0357B0
9D017424  00000000   NOP
249:                 	SMTPClient.ServerPort = SMTP_PORT;
9D017428  3C02A000   LUI V0, -24576
9D01742C  24420610   ADDIU V0, V0, 1552
9D017430  24030019   ADDIU V1, ZERO, 25
9D017434  A443002A   SH V1, 42(V0)
250:                 		
251:                 	return TRUE;
9D017438  24020001   ADDIU V0, ZERO, 1
252:                 }
9D01743C  03C0E821   ADDU SP, S8, ZERO
9D017440  8FBF0014   LW RA, 20(SP)
9D017444  8FBE0010   LW S8, 16(SP)
9D017448  27BD0018   ADDIU SP, SP, 24
9D01744C  03E00008   JR RA
9D017450  00000000   NOP
253:                 
254:                 /*****************************************************************************
255:                   Function:
256:                 	WORD SMTPEndUsage(void)
257:                 
258:                   Summary:
259:                 	Releases control of the SMTP client module.
260:                 
261:                   Description:
262:                 	Call this function to release control of the SMTP client module once
263:                 	an application is finished using it.  This function releases the lock
264:                 	obtained by SMTPBeginUsage, and frees the SMTP client to be used by 
265:                 	another application.
266:                 
267:                   Precondition:
268:                 	SMTPBeginUsage returned TRUE on a previous call.
269:                 
270:                   Parameters:
271:                 	None
272:                 
273:                   Return Values:
274:                 	SMTP_SUCCESS - A message was successfully sent
275:                 	SMTP_RESOLVE_ERROR - The SMTP server could not be resolved
276:                 	SMTP_CONNECT_ERROR - The connection to the SMTP server failed or was
277:                 		prematurely terminated
278:                 	1-199 and 300-399 - The last SMTP server response code
279:                   ***************************************************************************/
280:                 WORD SMTPEndUsage(void)
281:                 {
9D017454  27BDFFE8   ADDIU SP, SP, -24
9D017458  AFBF0014   SW RA, 20(SP)
9D01745C  AFBE0010   SW S8, 16(SP)
9D017460  03A0F021   ADDU S8, SP, ZERO
282:                 	if(!SMTPFlags.bits.SMTPInUse)
9D017464  93828148   LBU V0, -32440(GP)
9D017468  30420002   ANDI V0, V0, 2
9D01746C  304200FF   ANDI V0, V0, 255
9D017470  14400004   BNE V0, ZERO, 0x9D017484
9D017474  00000000   NOP
283:                 		return 0xFFFF;
9D017478  3402FFFF   ORI V0, ZERO, -1
9D01747C  0B405D3E   J 0x9D0174F8
9D017480  00000000   NOP
284:                 
285:                 	// Release the DNS module, if in use
286:                 	if(TransportState == TRANSPORT_NAME_RESOLVE)
9D017484  8F838138   LW V1, -32456(GP)
9D017488  24020002   ADDIU V0, ZERO, 2
9D01748C  14620003   BNE V1, V0, 0x9D01749C
9D017490  00000000   NOP
287:                 		DNSEndUsage();
9D017494  0F40A56C   JAL DNSEndUsage
9D017498  00000000   NOP
288:                 	
289:                 	// Release the TCP socket, if in use
290:                 	if(MySocket != INVALID_SOCKET)
9D01749C  93838025   LBU V1, -32731(GP)
9D0174A0  240200FE   ADDIU V0, ZERO, 254
9D0174A4  10620007   BEQ V1, V0, 0x9D0174C4
9D0174A8  00000000   NOP
291:                 	{
292:                 		TCPDisconnect(MySocket);
9D0174AC  93828025   LBU V0, -32731(GP)
9D0174B0  00402021   ADDU A0, V0, ZERO
9D0174B4  0F400273   JAL TCPDisconnect
9D0174B8  00000000   NOP
293:                 		MySocket = INVALID_SOCKET;
9D0174BC  2402FFFE   ADDIU V0, ZERO, -2
9D0174C0  A3828025   SB V0, -32731(GP)
294:                 	}
295:                 	
296:                 	// Release the SMTP module
297:                 	SMTPFlags.bits.SMTPInUse = FALSE;
9D0174C4  93828148   LBU V0, -32440(GP)
9D0174C8  7C020844   INS V0, ZERO, 1, 1
9D0174CC  A3828148   SB V0, -32440(GP)
298:                 	TransportState = TRANSPORT_HOME;
9D0174D0  AF808138   SW ZERO, -32456(GP)
299:                 
300:                 	if(SMTPFlags.bits.SentSuccessfully)
9D0174D4  93828148   LBU V0, -32440(GP)
9D0174D8  30420004   ANDI V0, V0, 4
9D0174DC  304200FF   ANDI V0, V0, 255
9D0174E0  10400004   BEQ V0, ZERO, 0x9D0174F4
9D0174E4  00000000   NOP
301:                 	{
302:                 		return 0;
9D0174E8  00001021   ADDU V0, ZERO, ZERO
9D0174EC  0B405D3E   J 0x9D0174F8
9D0174F0  00000000   NOP
303:                 	}
304:                 	else
305:                 	{
306:                 		return ResponseCode;
9D0174F4  9782814A   LHU V0, -32438(GP)
307:                 	}
308:                 }
9D0174F8  03C0E821   ADDU SP, S8, ZERO
9D0174FC  8FBF0014   LW RA, 20(SP)
9D017500  8FBE0010   LW S8, 16(SP)
9D017504  27BD0018   ADDIU SP, SP, 24
9D017508  03E00008   JR RA
9D01750C  00000000   NOP
309:                 
310:                 /*****************************************************************************
311:                   Function:
312:                 	void SMTPTask(void)
313:                 
314:                   Summary:
315:                 	Performs any pending SMTP client tasks
316:                 
317:                   Description:
318:                 	This function handles periodic tasks associated with the SMTP client,
319:                 	such as processing initial connections and command sequences.
320:                 
321:                   Precondition:
322:                 	None
323:                 
324:                   Parameters:
325:                 	None
326:                 
327:                   Returns:
328:                 	None
329:                 
330:                   Remarks:
331:                 	This function acts as a task (similar to one in an RTOS).  It
332:                 	performs its task in a co-operative manner, and the main application
333:                 	must call this function repeatedly to ensure that all open or new
334:                 	connections are served in a timely fashion.
335:                   ***************************************************************************/
336:                 void SMTPTask(void)
337:                 {
9D017510  27BDFFD8   ADDIU SP, SP, -40
9D017514  AFBF0024   SW RA, 36(SP)
9D017518  AFBE0020   SW S8, 32(SP)
9D01751C  AFB0001C   SW S0, 28(SP)
9D017520  03A0F021   ADDU S8, SP, ZERO
338:                 	BYTE			i;
339:                 	WORD			w;
340:                 	BYTE			vBase64Buffer[4];
341:                 	static DWORD	Timer;
342:                 	static BYTE		RXBuffer[4];
343:                 	static ROM BYTE *ROMStrPtr, *ROMStrPtr2;
344:                 	static BYTE 	*RAMStrPtr;
345:                 	static WORD		wAddressLength;
346:                 
347:                 	switch(TransportState)
9D017524  8F828138   LW V0, -32456(GP)
9D017528  2C430006   SLTIU V1, V0, 6
9D01752C  10600823   BEQ V1, ZERO, 0x9D0195BC
9D017530  00000000   NOP
9D017534  00021880   SLL V1, V0, 2
9D017538  3C029D01   LUI V0, -25343
9D01753C  24427550   ADDIU V0, V0, 30032
9D017540  00621021   ADDU V0, V1, V0
9D017544  8C420000   LW V0, 0(V0)
9D017548  00400008   JR V0
9D01754C  00000000   NOP
348:                 	{
349:                 		case TRANSPORT_HOME:
350:                 			// SMTPBeginUsage() is the only function which will kick 
351:                 			// the state machine into the next state
352:                 			break;
9D019570  00000000   NOP
9D019574  0B40656F   J 0x9D0195BC
9D019578  00000000   NOP
353:                 
354:                 		case TRANSPORT_BEGIN:
355:                 			// Wait for the user to program all the pointers and then 
356:                 			// call SMTPSendMail()
357:                 			if(!SMTPFlags.bits.ReadyToStart)
9D017568  93828148   LBU V0, -32440(GP)
9D01756C  30420008   ANDI V0, V0, 8
9D017570  304200FF   ANDI V0, V0, 255
9D017574  10400801   BEQ V0, ZERO, 0x9D01957C
9D017578  00000000   NOP
358:                 				break;
9D01957C  00000000   NOP
9D019580  0B40656F   J 0x9D0195BC
9D019584  00000000   NOP
359:                 
360:                 			// Obtain ownership of the DNS resolution module
361:                 			if(!DNSBeginUsage())
9D01757C  0F40A557   JAL DNSBeginUsage
9D017580  00000000   NOP
9D017584  10400800   BEQ V0, ZERO, 0x9D019588
9D017588  00000000   NOP
362:                 				break;
9D019588  00000000   NOP
9D01958C  0B40656F   J 0x9D0195BC
9D019590  00000000   NOP
363:                 
364:                 			// Obtain the IP address associated with the SMTP mail server
365:                 			if(SMTPClient.Server.szRAM || SMTPClient.Server.szROM)
9D01758C  3C02A000   LUI V0, -24576
9D017590  8C420610   LW V0, 1552(V0)
9D017594  14400005   BNE V0, ZERO, 0x9D0175AC
9D017598  00000000   NOP
9D01759C  3C02A000   LUI V0, -24576
9D0175A0  8C420610   LW V0, 1552(V0)
9D0175A4  10400017   BEQ V0, ZERO, 0x9D017604
9D0175A8  00000000   NOP
366:                 			{
367:                 				if(SMTPClient.ROMPointers.Server)
9D0175AC  3C02A000   LUI V0, -24576
9D0175B0  24420610   ADDIU V0, V0, 1552
9D0175B4  8C420028   LW V0, 40(V0)
9D0175B8  30420001   ANDI V0, V0, 1
9D0175BC  10400009   BEQ V0, ZERO, 0x9D0175E4
9D0175C0  00000000   NOP
9D0175DC  0B405E63   J 0x9D01798C
9D0175E0  00000000   NOP
9D0175FC  0B405E63   J 0x9D01798C
9D017600  00000000   NOP
368:                 					DNSResolveROM(SMTPClient.Server.szROM, DNS_TYPE_A);
9D0175C4  3C02A000   LUI V0, -24576
9D0175C8  8C420610   LW V0, 1552(V0)
9D0175CC  00402021   ADDU A0, V0, ZERO
9D0175D0  24050001   ADDIU A1, ZERO, 1
9D0175D4  0F40A588   JAL DNSResolve
9D0175D8  00000000   NOP
369:                 				else
370:                 					DNSResolve(SMTPClient.Server.szRAM, DNS_TYPE_A);
9D0175E4  3C02A000   LUI V0, -24576
9D0175E8  8C420610   LW V0, 1552(V0)
9D0175EC  00402021   ADDU A0, V0, ZERO
9D0175F0  24050001   ADDIU A1, ZERO, 1
9D0175F4  0F40A588   JAL DNSResolve
9D0175F8  00000000   NOP
371:                 			}
372:                 			else
373:                 			{
374:                 				// If we don't have a mail server, try to send the mail 
375:                 				// directly to the destination SMTP server
376:                 				if(SMTPClient.To.szRAM && !SMTPClient.ROMPointers.To)
9D017604  3C02A000   LUI V0, -24576
9D017608  24420610   ADDIU V0, V0, 1552
9D01760C  8C42000C   LW V0, 12(V0)
9D017610  10400018   BEQ V0, ZERO, 0x9D017674
9D017614  00000000   NOP
9D017618  3C02A000   LUI V0, -24576
9D01761C  24420610   ADDIU V0, V0, 1552
9D017620  8C420028   LW V0, 40(V0)
9D017624  30420008   ANDI V0, V0, 8
9D017628  14400012   BNE V0, ZERO, 0x9D017674
9D01762C  00000000   NOP
377:                 				{
378:                 					SMTPClient.Server.szRAM = (BYTE*)strchr((char*)SMTPClient.To.szRAM, '@');
9D017630  3C02A000   LUI V0, -24576
9D017634  24420610   ADDIU V0, V0, 1552
9D017638  8C42000C   LW V0, 12(V0)
9D01763C  00402021   ADDU A0, V0, ZERO
9D017640  24050040   ADDIU A1, ZERO, 64
9D017644  0F40D838   JAL strchr
9D017648  00000000   NOP
9D01764C  00401821   ADDU V1, V0, ZERO
9D017650  3C02A000   LUI V0, -24576
9D017654  AC430610   SW V1, 1552(V0)
379:                 					SMTPClient.ROMPointers.Server = 0;
9D017658  3C02A000   LUI V0, -24576
9D01765C  24430610   ADDIU V1, V0, 1552
9D017660  8C620028   LW V0, 40(V1)
9D017664  7C020004   INS V0, ZERO, 0, 1
9D017668  AC620028   SW V0, 40(V1)
9D01766C  0B405DB8   J 0x9D0176E0
9D017670  00000000   NOP
380:                 				}
381:                 				else if(SMTPClient.To.szROM && SMTPClient.ROMPointers.To)
9D017674  3C02A000   LUI V0, -24576
9D017678  24420610   ADDIU V0, V0, 1552
9D01767C  8C42000C   LW V0, 12(V0)
9D017680  10400017   BEQ V0, ZERO, 0x9D0176E0
9D017684  00000000   NOP
9D017688  3C02A000   LUI V0, -24576
9D01768C  24420610   ADDIU V0, V0, 1552
9D017690  8C420028   LW V0, 40(V0)
9D017694  30420008   ANDI V0, V0, 8
9D017698  10400011   BEQ V0, ZERO, 0x9D0176E0
9D01769C  00000000   NOP
382:                 				{
383:                 					SMTPClient.Server.szROM = (ROM BYTE*)strchrpgm((ROM char*)SMTPClient.To.szROM, '@');
9D0176A0  3C02A000   LUI V0, -24576
9D0176A4  24420610   ADDIU V0, V0, 1552
9D0176A8  8C42000C   LW V0, 12(V0)
9D0176AC  00402021   ADDU A0, V0, ZERO
9D0176B0  24050040   ADDIU A1, ZERO, 64
9D0176B4  0F40D838   JAL strchr
9D0176B8  00000000   NOP
9D0176BC  00401821   ADDU V1, V0, ZERO
9D0176C0  3C02A000   LUI V0, -24576
9D0176C4  AC430610   SW V1, 1552(V0)
384:                 					SMTPClient.ROMPointers.Server = 1;
9D0176C8  3C02A000   LUI V0, -24576
9D0176CC  24430610   ADDIU V1, V0, 1552
9D0176D0  8C620028   LW V0, 40(V1)
9D0176D4  24040001   ADDIU A0, ZERO, 1
9D0176D8  7C820004   INS V0, A0, 0, 1
9D0176DC  AC620028   SW V0, 40(V1)
385:                 				}
386:                 
387:                 				if(!(SMTPClient.Server.szRAM || SMTPClient.Server.szROM))
9D0176E0  3C02A000   LUI V0, -24576
9D0176E4  8C420610   LW V0, 1552(V0)
9D0176E8  1440003C   BNE V0, ZERO, 0x9D0177DC
9D0176EC  00000000   NOP
9D0176F0  3C02A000   LUI V0, -24576
9D0176F4  8C420610   LW V0, 1552(V0)
9D0176F8  14400038   BNE V0, ZERO, 0x9D0177DC
9D0176FC  00000000   NOP
388:                 				{
389:                 					if(SMTPClient.CC.szRAM && !SMTPClient.ROMPointers.CC)
9D017700  3C02A000   LUI V0, -24576
9D017704  24420610   ADDIU V0, V0, 1552
9D017708  8C420010   LW V0, 16(V0)
9D01770C  10400018   BEQ V0, ZERO, 0x9D017770
9D017710  00000000   NOP
9D017714  3C02A000   LUI V0, -24576
9D017718  24420610   ADDIU V0, V0, 1552
9D01771C  8C420028   LW V0, 40(V0)
9D017720  30420010   ANDI V0, V0, 16
9D017724  14400012   BNE V0, ZERO, 0x9D017770
9D017728  00000000   NOP
390:                 					{
391:                 						SMTPClient.Server.szRAM = (BYTE*)strchr((char*)SMTPClient.CC.szRAM, '@');
9D01772C  3C02A000   LUI V0, -24576
9D017730  24420610   ADDIU V0, V0, 1552
9D017734  8C420010   LW V0, 16(V0)
9D017738  00402021   ADDU A0, V0, ZERO
9D01773C  24050040   ADDIU A1, ZERO, 64
9D017740  0F40D838   JAL strchr
9D017744  00000000   NOP
9D017748  00401821   ADDU V1, V0, ZERO
9D01774C  3C02A000   LUI V0, -24576
9D017750  AC430610   SW V1, 1552(V0)
392:                 						SMTPClient.ROMPointers.Server = 0;
9D017754  3C02A000   LUI V0, -24576
9D017758  24430610   ADDIU V1, V0, 1552
9D01775C  8C620028   LW V0, 40(V1)
9D017760  7C020004   INS V0, ZERO, 0, 1
9D017764  AC620028   SW V0, 40(V1)
9D017768  0B405DF7   J 0x9D0177DC
9D01776C  00000000   NOP
393:                 					}
394:                 					else if(SMTPClient.CC.szROM && SMTPClient.ROMPointers.CC)
9D017770  3C02A000   LUI V0, -24576
9D017774  24420610   ADDIU V0, V0, 1552
9D017778  8C420010   LW V0, 16(V0)
9D01777C  10400017   BEQ V0, ZERO, 0x9D0177DC
9D017780  00000000   NOP
9D017784  3C02A000   LUI V0, -24576
9D017788  24420610   ADDIU V0, V0, 1552
9D01778C  8C420028   LW V0, 40(V0)
9D017790  30420010   ANDI V0, V0, 16
9D017794  10400011   BEQ V0, ZERO, 0x9D0177DC
9D017798  00000000   NOP
395:                 					{
396:                 						SMTPClient.Server.szROM = (ROM BYTE*)strchrpgm((ROM char*)SMTPClient.CC.szROM, '@');
9D01779C  3C02A000   LUI V0, -24576
9D0177A0  24420610   ADDIU V0, V0, 1552
9D0177A4  8C420010   LW V0, 16(V0)
9D0177A8  00402021   ADDU A0, V0, ZERO
9D0177AC  24050040   ADDIU A1, ZERO, 64
9D0177B0  0F40D838   JAL strchr
9D0177B4  00000000   NOP
9D0177B8  00401821   ADDU V1, V0, ZERO
9D0177BC  3C02A000   LUI V0, -24576
9D0177C0  AC430610   SW V1, 1552(V0)
397:                 						SMTPClient.ROMPointers.Server = 1;
9D0177C4  3C02A000   LUI V0, -24576
9D0177C8  24430610   ADDIU V1, V0, 1552
9D0177CC  8C620028   LW V0, 40(V1)
9D0177D0  24040001   ADDIU A0, ZERO, 1
9D0177D4  7C820004   INS V0, A0, 0, 1
9D0177D8  AC620028   SW V0, 40(V1)
398:                 					}
399:                 				}
400:                 
401:                 				if(!(SMTPClient.Server.szRAM || SMTPClient.Server.szROM))
9D0177DC  3C02A000   LUI V0, -24576
9D0177E0  8C420610   LW V0, 1552(V0)
9D0177E4  1440003C   BNE V0, ZERO, 0x9D0178D8
9D0177E8  00000000   NOP
9D0177EC  3C02A000   LUI V0, -24576
9D0177F0  8C420610   LW V0, 1552(V0)
9D0177F4  14400038   BNE V0, ZERO, 0x9D0178D8
9D0177F8  00000000   NOP
402:                 				{
403:                 					if(SMTPClient.BCC.szRAM && !SMTPClient.ROMPointers.BCC)
9D0177FC  3C02A000   LUI V0, -24576
9D017800  24420610   ADDIU V0, V0, 1552
9D017804  8C420014   LW V0, 20(V0)
9D017808  10400018   BEQ V0, ZERO, 0x9D01786C
9D01780C  00000000   NOP
9D017810  3C02A000   LUI V0, -24576
9D017814  24420610   ADDIU V0, V0, 1552
9D017818  8C420028   LW V0, 40(V0)
9D01781C  30420020   ANDI V0, V0, 32
9D017820  14400012   BNE V0, ZERO, 0x9D01786C
9D017824  00000000   NOP
404:                 					{
405:                 						SMTPClient.Server.szRAM = (BYTE*)strchr((char*)SMTPClient.BCC.szRAM, '@');
9D017828  3C02A000   LUI V0, -24576
9D01782C  24420610   ADDIU V0, V0, 1552
9D017830  8C420014   LW V0, 20(V0)
9D017834  00402021   ADDU A0, V0, ZERO
9D017838  24050040   ADDIU A1, ZERO, 64
9D01783C  0F40D838   JAL strchr
9D017840  00000000   NOP
9D017844  00401821   ADDU V1, V0, ZERO
9D017848  3C02A000   LUI V0, -24576
9D01784C  AC430610   SW V1, 1552(V0)
406:                 						SMTPClient.ROMPointers.Server = 0;
9D017850  3C02A000   LUI V0, -24576
9D017854  24430610   ADDIU V1, V0, 1552
9D017858  8C620028   LW V0, 40(V1)
9D01785C  7C020004   INS V0, ZERO, 0, 1
9D017860  AC620028   SW V0, 40(V1)
9D017864  0B405E36   J 0x9D0178D8
9D017868  00000000   NOP
407:                 					}
408:                 					else if(SMTPClient.BCC.szROM && SMTPClient.ROMPointers.BCC)
9D01786C  3C02A000   LUI V0, -24576
9D017870  24420610   ADDIU V0, V0, 1552
9D017874  8C420014   LW V0, 20(V0)
9D017878  10400017   BEQ V0, ZERO, 0x9D0178D8
9D01787C  00000000   NOP
9D017880  3C02A000   LUI V0, -24576
9D017884  24420610   ADDIU V0, V0, 1552
9D017888  8C420028   LW V0, 40(V0)
9D01788C  30420020   ANDI V0, V0, 32
9D017890  10400011   BEQ V0, ZERO, 0x9D0178D8
9D017894  00000000   NOP
409:                 					{
410:                 						SMTPClient.Server.szROM = (ROM BYTE*)strchrpgm((ROM char*)SMTPClient.BCC.szROM, '@');
9D017898  3C02A000   LUI V0, -24576
9D01789C  24420610   ADDIU V0, V0, 1552
9D0178A0  8C420014   LW V0, 20(V0)
9D0178A4  00402021   ADDU A0, V0, ZERO
9D0178A8  24050040   ADDIU A1, ZERO, 64
9D0178AC  0F40D838   JAL strchr
9D0178B0  00000000   NOP
9D0178B4  00401821   ADDU V1, V0, ZERO
9D0178B8  3C02A000   LUI V0, -24576
9D0178BC  AC430610   SW V1, 1552(V0)
411:                 						SMTPClient.ROMPointers.Server = 1;
9D0178C0  3C02A000   LUI V0, -24576
9D0178C4  24430610   ADDIU V1, V0, 1552
9D0178C8  8C620028   LW V0, 40(V1)
9D0178CC  24040001   ADDIU A0, ZERO, 1
9D0178D0  7C820004   INS V0, A0, 0, 1
9D0178D4  AC620028   SW V0, 40(V1)
412:                 					}
413:                 				}
414:                 
415:                 				// See if we found a hostname anywhere which we could resolve
416:                 				if(!(SMTPClient.Server.szRAM || SMTPClient.Server.szROM))
9D0178D8  3C02A000   LUI V0, -24576
9D0178DC  8C420610   LW V0, 1552(V0)
9D0178E0  1440000C   BNE V0, ZERO, 0x9D017914
9D0178E4  00000000   NOP
9D0178E8  3C02A000   LUI V0, -24576
9D0178EC  8C420610   LW V0, 1552(V0)
9D0178F0  14400008   BNE V0, ZERO, 0x9D017914
9D0178F4  00000000   NOP
417:                 				{
418:                 					DNSEndUsage();
9D0178F8  0F40A56C   JAL DNSEndUsage
9D0178FC  00000000   NOP
419:                 					ResponseCode = SMTP_RESOLVE_ERROR;
9D017900  24028000   ADDIU V0, ZERO, -32768
9D017904  A782814A   SH V0, -32438(GP)
420:                 					TransportState = TRANSPORT_HOME;
9D017908  AF808138   SW ZERO, -32456(GP)
421:                 					break;
9D01790C  0B40656F   J 0x9D0195BC
9D017910  00000000   NOP
422:                 				}
423:                 
424:                 				// Skip over the @ sign and resolve the host name
425:                 				if(SMTPClient.ROMPointers.Server)
9D017914  3C02A000   LUI V0, -24576
9D017918  24420610   ADDIU V0, V0, 1552
9D01791C  8C420028   LW V0, 40(V0)
9D017920  30420001   ANDI V0, V0, 1
9D017924  1040000E   BEQ V0, ZERO, 0x9D017960
9D017928  00000000   NOP
426:                 				{
427:                 					SMTPClient.Server.szROM++;
9D01792C  3C02A000   LUI V0, -24576
9D017930  8C420610   LW V0, 1552(V0)
9D017934  24430001   ADDIU V1, V0, 1
9D017938  3C02A000   LUI V0, -24576
9D01793C  AC430610   SW V1, 1552(V0)
428:                 					DNSResolveROM(SMTPClient.Server.szROM, DNS_TYPE_MX);
9D017940  3C02A000   LUI V0, -24576
9D017944  8C420610   LW V0, 1552(V0)
9D017948  00402021   ADDU A0, V0, ZERO
9D01794C  2405000F   ADDIU A1, ZERO, 15
9D017950  0F40A588   JAL DNSResolve
9D017954  00000000   NOP
9D017958  0B405E63   J 0x9D01798C
9D01795C  00000000   NOP
429:                 				}
430:                 				else
431:                 				{
432:                 					SMTPClient.Server.szRAM++;
9D017960  3C02A000   LUI V0, -24576
9D017964  8C420610   LW V0, 1552(V0)
9D017968  24430001   ADDIU V1, V0, 1
9D01796C  3C02A000   LUI V0, -24576
9D017970  AC430610   SW V1, 1552(V0)
433:                 					DNSResolve(SMTPClient.Server.szRAM, DNS_TYPE_MX);
9D017974  3C02A000   LUI V0, -24576
9D017978  8C420610   LW V0, 1552(V0)
9D01797C  00402021   ADDU A0, V0, ZERO
9D017980  2405000F   ADDIU A1, ZERO, 15
9D017984  0F40A588   JAL DNSResolve
9D017988  00000000   NOP
434:                 				}
435:                 			}
436:                 			
437:                 			Timer = TickGet();
9D01798C  0F40CDD6   JAL TickGet
9D017990  00000000   NOP
9D017994  AF82814C   SW V0, -32436(GP)
438:                 			TransportState++;
9D017998  8F828138   LW V0, -32456(GP)
9D01799C  24420001   ADDIU V0, V0, 1
9D0179A0  AF828138   SW V0, -32456(GP)
439:                 			break;
9D0179A4  0B40656F   J 0x9D0195BC
9D0179A8  00000000   NOP
440:                 
441:                 		case TRANSPORT_NAME_RESOLVE:
442:                 			// Wait for the DNS server to return the requested IP address
443:                 			if(!DNSIsResolved(&SMTPServer))
9D0179AC  27848130   ADDIU A0, GP, -32464
9D0179B0  0F40A5AD   JAL DNSIsResolved
9D0179B4  00000000   NOP
9D0179B8  14400012   BNE V0, ZERO, 0x9D017A04
9D0179BC  00000000   NOP
444:                 			{
445:                 				// Timeout after 6 seconds of unsuccessful DNS resolution
446:                 				if(TickGet() - Timer > 6*TICK_SECOND)
9D0179C0  0F40CDD6   JAL TickGet
9D0179C4  00000000   NOP
9D0179C8  00401821   ADDU V1, V0, ZERO
9D0179CC  8F82814C   LW V0, -32436(GP)
9D0179D0  00621823   SUBU V1, V1, V0
9D0179D4  3C02000E   LUI V0, 14
9D0179D8  34424E1D   ORI V0, V0, 19997
9D0179DC  0062102B   SLTU V0, V1, V0
9D0179E0  144006EC   BNE V0, ZERO, 0x9D019594
9D0179E4  00000000   NOP
447:                 				{
448:                 					ResponseCode = SMTP_RESOLVE_ERROR;
9D0179E8  24028000   ADDIU V0, ZERO, -32768
9D0179EC  A782814A   SH V0, -32438(GP)
449:                 					TransportState = TRANSPORT_HOME;
9D0179F0  AF808138   SW ZERO, -32456(GP)
450:                 					DNSEndUsage();
9D0179F4  0F40A56C   JAL DNSEndUsage
9D0179F8  00000000   NOP
451:                 				}
452:                 				break;
9D0179FC  0B40656F   J 0x9D0195BC
9D017A00  00000000   NOP
9D019594  00000000   NOP
9D019598  0B40656F   J 0x9D0195BC
9D01959C  00000000   NOP
453:                 			}
454:                 
455:                 			// Release the DNS module, we no longer need it
456:                 			if(!DNSEndUsage())
9D017A04  0F40A56C   JAL DNSEndUsage
9D017A08  00000000   NOP
9D017A0C  14400006   BNE V0, ZERO, 0x9D017A28
9D017A10  00000000   NOP
457:                 			{
458:                 				// An invalid IP address was returned from the DNS 
459:                 				// server.  Quit and fail permanantly if host is not valid.
460:                 				ResponseCode = SMTP_RESOLVE_ERROR;
9D017A14  24028000   ADDIU V0, ZERO, -32768
9D017A18  A782814A   SH V0, -32438(GP)
461:                 				TransportState = TRANSPORT_HOME;
9D017A1C  AF808138   SW ZERO, -32456(GP)
462:                 				break;
9D017A20  0B40656F   J 0x9D0195BC
9D017A24  00000000   NOP
463:                 			}
464:                 
465:                 			TransportState++;
9D017A28  8F828138   LW V0, -32456(GP)
9D017A2C  24420001   ADDIU V0, V0, 1
9D017A30  AF828138   SW V0, -32456(GP)
466:                 			// No need to break here
467:                 
468:                 		case TRANSPORT_OBTAIN_SOCKET:
469:                 			// Connect a TCP socket to the remote SMTP server
470:                 			MySocket = TCPOpen(SMTPServer.Val, TCP_OPEN_IP_ADDRESS, SMTPClient.ServerPort, TCP_PURPOSE_DEFAULT);
9D017A34  8F838130   LW V1, -32464(GP)
9D017A38  3C02A000   LUI V0, -24576
9D017A3C  24420610   ADDIU V0, V0, 1552
9D017A40  9442002A   LHU V0, 42(V0)
9D017A44  00602021   ADDU A0, V1, ZERO
9D017A48  24050003   ADDIU A1, ZERO, 3
9D017A4C  00403021   ADDU A2, V0, ZERO
9D017A50  24070009   ADDIU A3, ZERO, 9
9D017A54  0F400109   JAL TCPOpen
9D017A58  00000000   NOP
9D017A5C  A3828025   SB V0, -32731(GP)
471:                 			
472:                 			// Abort operation if no TCP sockets are available
473:                 			// If this ever happens, add some more 
474:                 			// TCP_PURPOSE_DEFAULT sockets in TCPIPConfig.h
475:                 			if(MySocket == INVALID_SOCKET)
9D017A60  93838025   LBU V1, -32731(GP)
9D017A64  240200FE   ADDIU V0, ZERO, 254
9D017A68  106206CD   BEQ V1, V0, 0x9D0195A0
9D017A6C  00000000   NOP
476:                 				break;
9D0195A0  00000000   NOP
9D0195A4  0B40656F   J 0x9D0195BC
9D0195A8  00000000   NOP
477:                 
478:                 			TransportState++;
9D017A70  8F828138   LW V0, -32456(GP)
9D017A74  24420001   ADDIU V0, V0, 1
9D017A78  AF828138   SW V0, -32456(GP)
479:                 			Timer = TickGet();
9D017A7C  0F40CDD6   JAL TickGet
9D017A80  00000000   NOP
9D017A84  AF82814C   SW V0, -32436(GP)
480:                 			// No break; fall into TRANSPORT_SOCKET_OBTAINED
481:                 			
482:                 		#if defined(STACK_USE_SSL_CLIENT)
483:                 		case TRANSPORT_SECURING_SOCKET:		
484:                 			if(!TCPIsConnected(MySocket))
485:                 			{
486:                 				// Don't stick around in the wrong state if the
487:                 				// server was connected, but then disconnected us.
488:                 				// Also time out if we can't establish the connection 
489:                 				// to the SMTP server
490:                 				if((LONG)(TickGet()-Timer) > (LONG)(SMTP_SERVER_REPLY_TIMEOUT))
491:                 				{
492:                 					ResponseCode = SMTP_CONNECT_ERROR;
493:                 					TransportState = TRANSPORT_CLOSE;
494:                 				}
495:                 
496:                 				break;
497:                 			}
498:                 			SMTPFlags.bits.ConnectedOnce = TRUE;
499:                 			
500:                 			// Start SSL if needed for this connection
501:                 			if(SMTPClient.UseSSL && !TCPStartSSLClient(MySocket,NULL))
502:                 				break;
503:                 			
504:                 			// Move on to main state
505:                 			Timer = TickGet();
506:                 			TransportState++;
507:                 			break;		
508:                 		#endif
509:                 
510:                 		case TRANSPORT_SOCKET_OBTAINED:
511:                 			if(!TCPIsConnected(MySocket))
9D017A88  93828025   LBU V0, -32731(GP)
9D017A8C  00402021   ADDU A0, V0, ZERO
9D017A90  0F400256   JAL TCPIsConnected
9D017A94  00000000   NOP
9D017A98  14400017   BNE V0, ZERO, 0x9D017AF8
9D017A9C  00000000   NOP
512:                 			{
513:                 				// Don't stick around in the wrong state if the
514:                 				// server was connected, but then disconnected us.
515:                 				// Also time out if we can't establish the connection 
516:                 				// to the SMTP server
517:                 				if(SMTPFlags.bits.ConnectedOnce || ((LONG)(TickGet()-Timer) > (LONG)(SMTP_SERVER_REPLY_TIMEOUT)))
9D017AA0  93828148   LBU V0, -32440(GP)
9D017AA4  30420020   ANDI V0, V0, 32
9D017AA8  304200FF   ANDI V0, V0, 255
9D017AAC  1440000C   BNE V0, ZERO, 0x9D017AE0
9D017AB0  00000000   NOP
9D017AB4  0F40CDD6   JAL TickGet
9D017AB8  00000000   NOP
9D017ABC  00401821   ADDU V1, V0, ZERO
9D017AC0  8F82814C   LW V0, -32436(GP)
9D017AC4  00621023   SUBU V0, V1, V0
9D017AC8  00401821   ADDU V1, V0, ZERO
9D017ACC  3C020013   LUI V0, 19
9D017AD0  344212D1   ORI V0, V0, 4817
9D017AD4  0062102A   SLT V0, V1, V0
9D017AD8  144006B4   BNE V0, ZERO, 0x9D0195AC
9D017ADC  00000000   NOP
518:                 				{
519:                 					ResponseCode = SMTP_CONNECT_ERROR;
9D017AE0  24028001   ADDIU V0, ZERO, -32767
9D017AE4  A782814A   SH V0, -32438(GP)
520:                 					TransportState = TRANSPORT_CLOSE;
9D017AE8  24020005   ADDIU V0, ZERO, 5
9D017AEC  AF828138   SW V0, -32456(GP)
521:                 				}
522:                 
523:                 				break;
9D017AF0  0B40656F   J 0x9D0195BC
9D017AF4  00000000   NOP
9D0195AC  00000000   NOP
9D0195B0  0B40656F   J 0x9D0195BC
9D0195B4  00000000   NOP
524:                 			}
525:                 			SMTPFlags.bits.ConnectedOnce = TRUE;
9D017AF8  93828148   LBU V0, -32440(GP)
9D017AFC  24030001   ADDIU V1, ZERO, 1
9D017B00  7C622944   INS V0, V1, 5, 1
9D017B04  A3828148   SB V0, -32440(GP)
526:                 			
527:                 			#if defined(STACK_USE_SSL_CLIENT)
528:                 			// Make sure the SSL handshake has completed
529:                 			if(SMTPClient.UseSSL && TCPSSLIsHandshaking(MySocket))
530:                 				break;
531:                 			#endif
532:                 
533:                 			// See if the server sent us anything
534:                 			while(TCPIsGetReady(MySocket))
9D017B08  0B405FC3   J 0x9D017F0C
9D017B0C  00000000   NOP
9D017F0C  93828025   LBU V0, -32731(GP)
9D017F10  00402021   ADDU A0, V0, ZERO
9D017F14  0F400675   JAL TCPIsGetReady
9D017F18  00000000   NOP
9D017F1C  1440FEFC   BNE V0, ZERO, 0x9D017B10
9D017F20  00000000   NOP
535:                 			{
536:                 				TCPGet(MySocket, &i);
9D017B10  93828025   LBU V0, -32731(GP)
9D017B14  00401821   ADDU V1, V0, ZERO
9D017B18  27C20012   ADDIU V0, S8, 18
9D017B1C  00602021   ADDU A0, V1, ZERO
9D017B20  00402821   ADDU A1, V0, ZERO
9D017B24  0F4006DD   JAL TCPGet
9D017B28  00000000   NOP
537:                 				switch(RXParserState)
9D017B2C  8F828144   LW V0, -32444(GP)
9D017B30  2C430006   SLTIU V1, V0, 6
9D017B34  106000F5   BEQ V1, ZERO, 0x9D017F0C
9D017B38  00000000   NOP
9D017B3C  00021880   SLL V1, V0, 2
9D017B40  3C029D01   LUI V0, -25343
9D017B44  24427B58   ADDIU V0, V0, 31576
9D017B48  00621021   ADDU V0, V1, V0
9D017B4C  8C420000   LW V0, 0(V0)
9D017B50  00400008   JR V0
9D017B54  00000000   NOP
538:                 				{
539:                 					case RX_BYTE_0:
540:                 					case RX_BYTE_1:
541:                 					case RX_BYTE_2:
542:                 						RXBuffer[RXParserState] = i;
9D017B70  8F848144   LW A0, -32444(GP)
9D017B74  93C30012   LBU V1, 18(S8)
9D017B78  27828150   ADDIU V0, GP, -32432
9D017B7C  00821021   ADDU V0, A0, V0
9D017B80  A0430000   SB V1, 0(V0)
543:                 						RXParserState++;
9D017B84  8F828144   LW V0, -32444(GP)
9D017B88  24420001   ADDIU V0, V0, 1
9D017B8C  AF828144   SW V0, -32444(GP)
544:                 						break;
9D017B90  0B405FC3   J 0x9D017F0C
9D017B94  00000000   NOP
545:                 	
546:                 					case RX_BYTE_3:
547:                 						switch(i)
9D017B98  93C20012   LBU V0, 18(S8)
9D017B9C  24030020   ADDIU V1, ZERO, 32
9D017BA0  10430009   BEQ V0, V1, 0x9D017BC8
9D017BA4  00000000   NOP
9D017BA8  2403002D   ADDIU V1, ZERO, 45
9D017BAC  1043000E   BEQ V0, V1, 0x9D017BE8
9D017BB0  00000000   NOP
9D017BB4  2403000D   ADDIU V1, ZERO, 13
9D017BB8  10430014   BEQ V0, V1, 0x9D017C0C
9D017BBC  00000000   NOP
548:                 						{
549:                 							case ' ':
550:                 								SMTPFlags.bits.RXSkipResponse = FALSE;
9D017BC8  93828148   LBU V0, -32440(GP)
9D017BCC  7C020004   INS V0, ZERO, 0, 1
9D017BD0  A3828148   SB V0, -32440(GP)
551:                 								RXParserState++;
9D017BD4  8F828144   LW V0, -32444(GP)
9D017BD8  24420001   ADDIU V0, V0, 1
9D017BDC  AF828144   SW V0, -32444(GP)
552:                 								break;
9D017BE0  0B405F06   J 0x9D017C18
9D017BE4  00000000   NOP
553:                 							case '-':
554:                 								SMTPFlags.bits.RXSkipResponse = TRUE;
9D017BE8  93828148   LBU V0, -32440(GP)
9D017BEC  24030001   ADDIU V1, ZERO, 1
9D017BF0  7C620004   INS V0, V1, 0, 1
9D017BF4  A3828148   SB V0, -32440(GP)
555:                 								RXParserState++;
9D017BF8  8F828144   LW V0, -32444(GP)
9D017BFC  24420001   ADDIU V0, V0, 1
9D017C00  AF828144   SW V0, -32444(GP)
556:                 								break;
9D017C04  0B405F06   J 0x9D017C18
9D017C08  00000000   NOP
557:                 							case '\r':
558:                 								RXParserState = RX_SEEK_LF;
9D017C0C  24020005   ADDIU V0, ZERO, 5
9D017C10  AF828144   SW V0, -32444(GP)
559:                 								break;
9D017C14  00000000   NOP
560:                 						}
561:                 						break;
9D017BC0  0B405FC3   J 0x9D017F0C
9D017BC4  00000000   NOP
9D017C18  0B405FC3   J 0x9D017F0C
9D017C1C  00000000   NOP
562:                 	
563:                 					case RX_SEEK_CR:
564:                 						if(i == '\r')
9D017C20  93C30012   LBU V1, 18(S8)
9D017C24  2402000D   ADDIU V0, ZERO, 13
9D017C28  146200B1   BNE V1, V0, 0x9D017EF0
9D017C2C  00000000   NOP
565:                 							RXParserState++;
9D017C30  8F828144   LW V0, -32444(GP)
9D017C34  24420001   ADDIU V0, V0, 1
9D017C38  AF828144   SW V0, -32444(GP)
566:                 						break;
9D017C3C  0B405FC3   J 0x9D017F0C
9D017C40  00000000   NOP
9D017EF0  00000000   NOP
9D017EF4  0B405FC3   J 0x9D017F0C
9D017EF8  00000000   NOP
567:                 	
568:                 					case RX_SEEK_LF:
569:                 						// If we received the whole command
570:                 						if(i == '\n')
9D017C44  93C30012   LBU V1, 18(S8)
9D017C48  2402000A   ADDIU V0, ZERO, 10
9D017C4C  1462009F   BNE V1, V0, 0x9D017ECC
9D017C50  00000000   NOP
571:                 						{
572:                 							RXParserState = RX_BYTE_0;
9D017C54  AF808144   SW ZERO, -32444(GP)
573:                 
574:                 							if(!SMTPFlags.bits.RXSkipResponse)
9D017C58  93828148   LBU V0, -32440(GP)
9D017C5C  30420001   ANDI V0, V0, 1
9D017C60  304200FF   ANDI V0, V0, 255
9D017C64  144000A5   BNE V0, ZERO, 0x9D017EFC
9D017C68  00000000   NOP
575:                 							{
576:                 								// The server sent us a response code
577:                 								// Null terminate the ASCII reponse code so we can convert it to an integer
578:                 								RXBuffer[3] = 0;
9D017C6C  A3808153   SB ZERO, -32429(GP)
579:                 								ResponseCode = atoi((char*)RXBuffer);
9D017C70  27828150   ADDIU V0, GP, -32432
9D017C74  00402021   ADDU A0, V0, ZERO
9D017C78  0F40D616   JAL atoi
9D017C7C  00000000   NOP
9D017C80  3042FFFF   ANDI V0, V0, -1
9D017C84  A782814A   SH V0, -32438(GP)
580:                 
581:                 								// Handle the response
582:                 								switch(SMTPState)
9D017C88  8F82813C   LW V0, -32452(GP)
9D017C8C  2C43001D   SLTIU V1, V0, 29
9D017C90  1060008B   BEQ V1, ZERO, 0x9D017EC0
9D017C94  00000000   NOP
9D017C98  00021880   SLL V1, V0, 2
9D017C9C  3C029D01   LUI V0, -25343
9D017CA0  24427CB4   ADDIU V0, V0, 31924
9D017CA4  00621021   ADDU V0, V1, V0
9D017CA8  8C420000   LW V0, 0(V0)
9D017CAC  00400008   JR V0
9D017CB0  00000000   NOP
583:                 								{
584:                 									case SMTP_HELO_ACK:
585:                 										if(ResponseCode >= 200u && ResponseCode <= 299u)
9D017D28  9782814A   LHU V0, -32438(GP)
9D017D2C  2C4200C8   SLTIU V0, V0, 200
9D017D30  14400017   BNE V0, ZERO, 0x9D017D90
9D017D34  00000000   NOP
9D017D38  9782814A   LHU V0, -32438(GP)
9D017D3C  2C42012C   SLTIU V0, V0, 300
9D017D40  10400013   BEQ V0, ZERO, 0x9D017D90
9D017D44  00000000   NOP
586:                 										{
587:                 											if(SMTPClient.Username.szRAM || SMTPClient.Username.szROM)
9D017D48  3C02A000   LUI V0, -24576
9D017D4C  24420610   ADDIU V0, V0, 1552
9D017D50  8C420004   LW V0, 4(V0)
9D017D54  14400006   BNE V0, ZERO, 0x9D017D70
9D017D58  00000000   NOP
9D017D5C  3C02A000   LUI V0, -24576
9D017D60  24420610   ADDIU V0, V0, 1552
9D017D64  8C420004   LW V0, 4(V0)
9D017D68  10400005   BEQ V0, ZERO, 0x9D017D80
9D017D6C  00000000   NOP
9D017D88  0B405F66   J 0x9D017D98
9D017D8C  00000000   NOP
588:                 												SMTPState = SMTP_AUTH_LOGIN;
9D017D70  24020003   ADDIU V0, ZERO, 3
9D017D74  AF82813C   SW V0, -32452(GP)
9D017D78  0B405F62   J 0x9D017D88
9D017D7C  00000000   NOP
589:                 											else
590:                 												SMTPState = SMTP_MAILFROM;
9D017D80  24020009   ADDIU V0, ZERO, 9
9D017D84  AF82813C   SW V0, -32452(GP)
591:                 										}
592:                 										else
593:                 											SMTPState = SMTP_QUIT_INIT;
9D017D90  2402001D   ADDIU V0, ZERO, 29
9D017D94  AF82813C   SW V0, -32452(GP)
594:                 										break;
9D017D98  0B405FB1   J 0x9D017EC4
9D017D9C  00000000   NOP
595:                 
596:                 
597:                 									case SMTP_AUTH_LOGIN_ACK:
598:                 									case SMTP_AUTH_USERNAME_ACK:
599:                 										if(ResponseCode == 334u)
9D017DA0  9783814A   LHU V1, -32438(GP)
9D017DA4  2402014E   ADDIU V0, ZERO, 334
9D017DA8  14620006   BNE V1, V0, 0x9D017DC4
9D017DAC  00000000   NOP
600:                 											SMTPState++;
9D017DB0  8F82813C   LW V0, -32452(GP)
9D017DB4  24420001   ADDIU V0, V0, 1
9D017DB8  AF82813C   SW V0, -32452(GP)
9D017DBC  0B405F73   J 0x9D017DCC
9D017DC0  00000000   NOP
601:                 										else
602:                 											SMTPState = SMTP_QUIT_INIT;
9D017DC4  2402001D   ADDIU V0, ZERO, 29
9D017DC8  AF82813C   SW V0, -32452(GP)
603:                 										break;
9D017DCC  0B405FB1   J 0x9D017EC4
9D017DD0  00000000   NOP
604:                 
605:                 									case SMTP_AUTH_PASSWORD_ACK:
606:                 										if(ResponseCode == 235u)
9D017DD4  9783814A   LHU V1, -32438(GP)
9D017DD8  240200EB   ADDIU V0, ZERO, 235
9D017DDC  14620006   BNE V1, V0, 0x9D017DF8
9D017DE0  00000000   NOP
607:                 											SMTPState++;
9D017DE4  8F82813C   LW V0, -32452(GP)
9D017DE8  24420001   ADDIU V0, V0, 1
9D017DEC  AF82813C   SW V0, -32452(GP)
9D017DF0  0B405F80   J 0x9D017E00
9D017DF4  00000000   NOP
608:                 										else
609:                 											SMTPState = SMTP_QUIT_INIT;
9D017DF8  2402001D   ADDIU V0, ZERO, 29
9D017DFC  AF82813C   SW V0, -32452(GP)
610:                 										break;
9D017E00  0B405FB1   J 0x9D017EC4
9D017E04  00000000   NOP
611:                 
612:                 									case SMTP_HOME:
613:                 									case SMTP_MAILFROM_ACK:
614:                 									case SMTP_RCPTTO_ACK:
615:                 									case SMTP_RCPTTOCC_ACK:
616:                 									case SMTP_RCPTTOBCC_ACK:
617:                 										if(ResponseCode >= 200u && ResponseCode <= 299u)
9D017E08  9782814A   LHU V0, -32438(GP)
9D017E0C  2C4200C8   SLTIU V0, V0, 200
9D017E10  1440000A   BNE V0, ZERO, 0x9D017E3C
9D017E14  00000000   NOP
9D017E18  9782814A   LHU V0, -32438(GP)
9D017E1C  2C42012C   SLTIU V0, V0, 300
9D017E20  10400006   BEQ V0, ZERO, 0x9D017E3C
9D017E24  00000000   NOP
618:                 											SMTPState++;
9D017E28  8F82813C   LW V0, -32452(GP)
9D017E2C  24420001   ADDIU V0, V0, 1
9D017E30  AF82813C   SW V0, -32452(GP)
9D017E34  0B405F91   J 0x9D017E44
9D017E38  00000000   NOP
619:                 										else
620:                 											SMTPState = SMTP_QUIT_INIT;
9D017E3C  2402001D   ADDIU V0, ZERO, 29
9D017E40  AF82813C   SW V0, -32452(GP)
621:                 										break;
9D017E44  0B405FB1   J 0x9D017EC4
9D017E48  00000000   NOP
622:                 							
623:                 									case SMTP_DATA_ACK:
624:                 										if(ResponseCode == 354u)
9D017E4C  9783814A   LHU V1, -32438(GP)
9D017E50  24020162   ADDIU V0, ZERO, 354
9D017E54  14620006   BNE V1, V0, 0x9D017E70
9D017E58  00000000   NOP
625:                 											SMTPState++;
9D017E5C  8F82813C   LW V0, -32452(GP)
9D017E60  24420001   ADDIU V0, V0, 1
9D017E64  AF82813C   SW V0, -32452(GP)
9D017E68  0B405F9E   J 0x9D017E78
9D017E6C  00000000   NOP
626:                 										else
627:                 											SMTPState = SMTP_QUIT_INIT;
9D017E70  2402001D   ADDIU V0, ZERO, 29
9D017E74  AF82813C   SW V0, -32452(GP)
628:                 										break;
9D017E78  0B405FB1   J 0x9D017EC4
9D017E7C  00000000   NOP
629:                 							
630:                 									case SMTP_DATA_BODY_ACK:
631:                 										if(ResponseCode >= 200u && ResponseCode <= 299u)
9D017E80  9782814A   LHU V0, -32438(GP)
9D017E84  2C4200C8   SLTIU V0, V0, 200
9D017E88  14400009   BNE V0, ZERO, 0x9D017EB0
9D017E8C  00000000   NOP
9D017E90  9782814A   LHU V0, -32438(GP)
9D017E94  2C42012C   SLTIU V0, V0, 300
9D017E98  10400005   BEQ V0, ZERO, 0x9D017EB0
9D017E9C  00000000   NOP
632:                 											SMTPFlags.bits.SentSuccessfully = TRUE;
9D017EA0  93828148   LBU V0, -32440(GP)
9D017EA4  24030001   ADDIU V1, ZERO, 1
9D017EA8  7C621084   INS V0, V1, 2, 1
9D017EAC  A3828148   SB V0, -32440(GP)
633:                 							
634:                 										SMTPState = SMTP_QUIT_INIT;
9D017EB0  2402001D   ADDIU V0, ZERO, 29
9D017EB4  AF82813C   SW V0, -32452(GP)
635:                 										break;
9D017EB8  0B405FB1   J 0x9D017EC4
9D017EBC  00000000   NOP
636:                 
637:                 									// Default case needed to supress compiler diagnostics
638:                 									default:
639:                 										break;
9D017EC0  00000000   NOP
640:                 								}
641:                 							}
642:                 						}
643:                 						else if(i != '\r')
9D017ECC  93C30012   LBU V1, 18(S8)
9D017ED0  2402000D   ADDIU V0, ZERO, 13
9D017ED4  1062000C   BEQ V1, V0, 0x9D017F08
9D017ED8  00000000   NOP
644:                 							RXParserState--;
9D017EDC  8F828144   LW V0, -32444(GP)
9D017EE0  2442FFFF   ADDIU V0, V0, -1
9D017EE4  AF828144   SW V0, -32444(GP)
645:                 	
646:                 						break;
9D017EC4  0B405FC3   J 0x9D017F0C
9D017EC8  00000000   NOP
9D017EE8  0B405FC3   J 0x9D017F0C
9D017EEC  00000000   NOP
9D017EFC  00000000   NOP
9D017F00  0B405FC3   J 0x9D017F0C
9D017F04  00000000   NOP
9D017F08  00000000   NOP
647:                 				}
648:                 			}
649:                 
650:                 			// Generate new data in the TX buffer, as needed, if possible
651:                 			if(TCPIsPutReady(MySocket) < 64u)
9D017F24  93828025   LBU V0, -32731(GP)
9D017F28  00402021   ADDU A0, V0, ZERO
9D017F2C  0F40038E   JAL TCPIsPutReady
9D017F30  00000000   NOP
9D017F34  2C420040   SLTIU V0, V0, 64
9D017F38  1440059F   BNE V0, ZERO, 0x9D0195B8
9D017F3C  00000000   NOP
652:                 				break;
9D0195B8  00000000   NOP
653:                 
654:                 			switch(SMTPState)
9D017F40  8F82813C   LW V0, -32452(GP)
9D017F44  2C43001F   SLTIU V1, V0, 31
9D017F48  1060057C   BEQ V1, ZERO, 0x9D01953C
9D017F4C  00000000   NOP
9D017F50  00021880   SLL V1, V0, 2
9D017F54  3C029D01   LUI V0, -25343
9D017F58  24427F6C   ADDIU V0, V0, 32620
9D017F5C  00621021   ADDU V0, V1, V0
9D017F60  8C420000   LW V0, 0(V0)
9D017F64  00400008   JR V0
9D017F68  00000000   NOP
655:                 			{
656:                 				case SMTP_HELO:
657:                 					if(SMTPClient.Username.szROM == NULL)
9D017FE8  3C02A000   LUI V0, -24576
9D017FEC  24420610   ADDIU V0, V0, 1552
9D017FF0  8C420004   LW V0, 4(V0)
9D017FF4  1440000B   BNE V0, ZERO, 0x9D018024
9D017FF8  00000000   NOP
658:                 						TCPPutROMString(MySocket, (ROM BYTE*)"HELO MCHPBOARD\r\n");
9D017FFC  93828025   LBU V0, -32731(GP)
9D018000  00401821   ADDU V1, V0, ZERO
9D018004  3C029D03   LUI V0, -25341
9D018008  24425ACC   ADDIU V0, V0, 23244
9D01800C  00602021   ADDU A0, V1, ZERO
9D018010  00402821   ADDU A1, V0, ZERO
9D018014  0F4005FD   JAL TCPPutString
9D018018  00000000   NOP
9D01801C  0B406011   J 0x9D018044
9D018020  00000000   NOP
659:                 					else
660:                 						TCPPutROMString(MySocket, (ROM BYTE*)"EHLO MCHPBOARD\r\n");
9D018024  93828025   LBU V0, -32731(GP)
9D018028  00401821   ADDU V1, V0, ZERO
9D01802C  3C029D03   LUI V0, -25341
9D018030  24425AE0   ADDIU V0, V0, 23264
9D018034  00602021   ADDU A0, V1, ZERO
9D018038  00402821   ADDU A1, V0, ZERO
9D01803C  0F4005FD   JAL TCPPutString
9D018040  00000000   NOP
661:                 					TCPFlush(MySocket);
9D018044  93828025   LBU V0, -32731(GP)
9D018048  00402021   ADDU A0, V0, ZERO
9D01804C  0F400366   JAL TCPFlush
9D018050  00000000   NOP
662:                 					SMTPState++;
9D018054  8F82813C   LW V0, -32452(GP)
9D018058  24420001   ADDIU V0, V0, 1
9D01805C  AF82813C   SW V0, -32452(GP)
663:                 					break;
9D018060  0B406550   J 0x9D019540
9D018064  00000000   NOP
664:                 
665:                 				case SMTP_AUTH_LOGIN:
666:                 					// Note: This state is only entered from SMTP_HELO_ACK if the application 
667:                 					// has specified a Username to use (either SMTPClient.Username.szROM or 
668:                 					// SMTPClient.Username.szRAM is non-NULL)
669:                 					TCPPutROMString(MySocket, (ROM BYTE*)"AUTH LOGIN\r\n");
9D018068  93828025   LBU V0, -32731(GP)
9D01806C  00401821   ADDU V1, V0, ZERO
9D018070  3C029D03   LUI V0, -25341
9D018074  24425AF4   ADDIU V0, V0, 23284
9D018078  00602021   ADDU A0, V1, ZERO
9D01807C  00402821   ADDU A1, V0, ZERO
9D018080  0F4005FD   JAL TCPPutString
9D018084  00000000   NOP
670:                 					TCPFlush(MySocket);
9D018088  93828025   LBU V0, -32731(GP)
9D01808C  00402021   ADDU A0, V0, ZERO
9D018090  0F400366   JAL TCPFlush
9D018094  00000000   NOP
671:                 					SMTPState++;
9D018098  8F82813C   LW V0, -32452(GP)
9D01809C  24420001   ADDIU V0, V0, 1
9D0180A0  AF82813C   SW V0, -32452(GP)
672:                 					break;
9D0180A4  0B406550   J 0x9D019540
9D0180A8  00000000   NOP
673:                 
674:                 				case SMTP_AUTH_USERNAME:
675:                 					// Base 64 encode and transmit the username.
676:                 					if(SMTPClient.ROMPointers.Username)
9D0180AC  3C02A000   LUI V0, -24576
9D0180B0  24420610   ADDIU V0, V0, 1552
9D0180B4  8C420028   LW V0, 40(V0)
9D0180B8  30420002   ANDI V0, V0, 2
9D0180BC  1040000C   BEQ V0, ZERO, 0x9D0180F0
9D0180C0  00000000   NOP
677:                 					{
678:                 						ROMStrPtr = SMTPClient.Username.szROM;
9D0180C4  3C02A000   LUI V0, -24576
9D0180C8  24420610   ADDIU V0, V0, 1552
9D0180CC  8C420004   LW V0, 4(V0)
9D0180D0  AF828154   SW V0, -32428(GP)
679:                 						w = strlenpgm((ROM char*)ROMStrPtr);
9D0180D4  8F828154   LW V0, -32428(GP)
9D0180D8  00402021   ADDU A0, V0, ZERO
9D0180DC  0F40D2F2   JAL 0x9D034BC8
9D0180E0  00000000   NOP
9D0180E4  A7C20010   SH V0, 16(S8)
680:                 					}
681:                 					else
682:                 					{
683:                 						RAMStrPtr = SMTPClient.Username.szRAM;
9D0180F0  3C02A000   LUI V0, -24576
9D0180F4  24420610   ADDIU V0, V0, 1552
9D0180F8  8C420004   LW V0, 4(V0)
9D0180FC  AF828158   SW V0, -32424(GP)
684:                 						w = strlen((char*)RAMStrPtr);
9D018100  8F828158   LW V0, -32424(GP)
9D018104  00402021   ADDU A0, V0, ZERO
9D018108  0F40D2F2   JAL 0x9D034BC8
9D01810C  00000000   NOP
9D018110  A7C20010   SH V0, 16(S8)
685:                 					}
686:                 
687:                 					while(w)
9D0180E8  0B406086   J 0x9D018218
9D0180EC  00000000   NOP
9D018114  0B406086   J 0x9D018218
9D018118  00000000   NOP
9D018218  97C20010   LHU V0, 16(S8)
9D01821C  1440FFBF   BNE V0, ZERO, 0x9D01811C
9D018220  00000000   NOP
688:                 					{
689:                 						i = 0;
9D01811C  A3C00012   SB ZERO, 18(S8)
690:                 						while((i < w) && (i < sizeof(vBase64Buffer)*3/4))
9D018120  0B406068   J 0x9D0181A0
9D018124  00000000   NOP
9D0181A0  93C20012   LBU V0, 18(S8)
9D0181A4  97C30010   LHU V1, 16(S8)
9D0181A8  0043102B   SLTU V0, V0, V1
9D0181AC  10400005   BEQ V0, ZERO, 0x9D0181C4
9D0181B0  00000000   NOP
9D0181B4  93C20012   LBU V0, 18(S8)
9D0181B8  2C420003   SLTIU V0, V0, 3
9D0181BC  1440FFDA   BNE V0, ZERO, 0x9D018128
9D0181C0  00000000   NOP
691:                 						{
692:                 							if(SMTPClient.ROMPointers.Username)
9D018128  3C02A000   LUI V0, -24576
9D01812C  24420610   ADDIU V0, V0, 1552
9D018130  8C420028   LW V0, 40(V0)
9D018134  30420002   ANDI V0, V0, 2
9D018138  1040000C   BEQ V0, ZERO, 0x9D01816C
9D01813C  00000000   NOP
693:                 								vBase64Buffer[i] = *ROMStrPtr++;
9D018140  93C20012   LBU V0, 18(S8)
9D018144  00401821   ADDU V1, V0, ZERO
9D018148  8F828154   LW V0, -32428(GP)
9D01814C  90440000   LBU A0, 0(V0)
9D018150  27C50010   ADDIU A1, S8, 16
9D018154  00A31821   ADDU V1, A1, V1
9D018158  A0640004   SB A0, 4(V1)
9D01815C  24420001   ADDIU V0, V0, 1
9D018160  AF828154   SW V0, -32428(GP)
9D018164  0B406064   J 0x9D018190
9D018168  00000000   NOP
694:                 							else
695:                 								vBase64Buffer[i] = *RAMStrPtr++;
9D01816C  93C20012   LBU V0, 18(S8)
9D018170  00401821   ADDU V1, V0, ZERO
9D018174  8F828158   LW V0, -32424(GP)
9D018178  90440000   LBU A0, 0(V0)
9D01817C  27C50010   ADDIU A1, S8, 16
9D018180  00A31821   ADDU V1, A1, V1
9D018184  A0640004   SB A0, 4(V1)
9D018188  24420001   ADDIU V0, V0, 1
9D01818C  AF828158   SW V0, -32424(GP)
696:                 							i++;
9D018190  93C20012   LBU V0, 18(S8)
9D018194  24420001   ADDIU V0, V0, 1
9D018198  304200FF   ANDI V0, V0, 255
9D01819C  A3C20012   SB V0, 18(S8)
697:                 						}
698:                 						w -= i;					
9D0181C4  93C20012   LBU V0, 18(S8)
9D0181C8  97C30010   LHU V1, 16(S8)
9D0181CC  00621023   SUBU V0, V1, V0
9D0181D0  A7C20010   SH V0, 16(S8)
699:                 						Base64Encode(vBase64Buffer, i, vBase64Buffer, sizeof(vBase64Buffer));
9D0181D4  93C20012   LBU V0, 18(S8)
9D0181D8  00401821   ADDU V1, V0, ZERO
9D0181DC  27C40014   ADDIU A0, S8, 20
9D0181E0  27C20014   ADDIU V0, S8, 20
9D0181E4  00602821   ADDU A1, V1, ZERO
9D0181E8  00403021   ADDU A2, V0, ZERO
9D0181EC  24070004   ADDIU A3, ZERO, 4
9D0181F0  0F409852   JAL Base64Encode
9D0181F4  00000000   NOP
700:                 						TCPPutArray(MySocket, vBase64Buffer, sizeof(vBase64Buffer));
9D0181F8  93828025   LBU V0, -32731(GP)
9D0181FC  00401821   ADDU V1, V0, ZERO
9D018200  27C20014   ADDIU V0, S8, 20
9D018204  00602021   ADDU A0, V1, ZERO
9D018208  00402821   ADDU A1, V0, ZERO
9D01820C  24060004   ADDIU A2, ZERO, 4
9D018210  0F4004E1   JAL TCPPutArray
9D018214  00000000   NOP
701:                 					}
702:                 					TCPPutROMString(MySocket, (ROM BYTE*)"\r\n");
9D018224  93828025   LBU V0, -32731(GP)
9D018228  00401821   ADDU V1, V0, ZERO
9D01822C  3C029D03   LUI V0, -25341
9D018230  24425B04   ADDIU V0, V0, 23300
9D018234  00602021   ADDU A0, V1, ZERO
9D018238  00402821   ADDU A1, V0, ZERO
9D01823C  0F4005FD   JAL TCPPutString
9D018240  00000000   NOP
703:                 					TCPFlush(MySocket);
9D018244  93828025   LBU V0, -32731(GP)
9D018248  00402021   ADDU A0, V0, ZERO
9D01824C  0F400366   JAL TCPFlush
9D018250  00000000   NOP
704:                 					SMTPState++;
9D018254  8F82813C   LW V0, -32452(GP)
9D018258  24420001   ADDIU V0, V0, 1
9D01825C  AF82813C   SW V0, -32452(GP)
705:                 					break;
9D018260  0B406550   J 0x9D019540
9D018264  00000000   NOP
706:                 
707:                 				case SMTP_AUTH_PASSWORD:
708:                 					// Base 64 encode and transmit the password
709:                 					if(SMTPClient.ROMPointers.Password)
9D018268  3C02A000   LUI V0, -24576
9D01826C  24420610   ADDIU V0, V0, 1552
9D018270  8C420028   LW V0, 40(V0)
9D018274  30420004   ANDI V0, V0, 4
9D018278  1040000C   BEQ V0, ZERO, 0x9D0182AC
9D01827C  00000000   NOP
710:                 					{
711:                 						ROMStrPtr = SMTPClient.Password.szROM;
9D018280  3C02A000   LUI V0, -24576
9D018284  24420610   ADDIU V0, V0, 1552
9D018288  8C420008   LW V0, 8(V0)
9D01828C  AF828154   SW V0, -32428(GP)
712:                 						w = strlenpgm((ROM char*)ROMStrPtr);
9D018290  8F828154   LW V0, -32428(GP)
9D018294  00402021   ADDU A0, V0, ZERO
9D018298  0F40D2F2   JAL 0x9D034BC8
9D01829C  00000000   NOP
9D0182A0  A7C20010   SH V0, 16(S8)
713:                 					}
714:                 					else
715:                 					{
716:                 						RAMStrPtr = SMTPClient.Password.szRAM;
9D0182AC  3C02A000   LUI V0, -24576
9D0182B0  24420610   ADDIU V0, V0, 1552
9D0182B4  8C420008   LW V0, 8(V0)
9D0182B8  AF828158   SW V0, -32424(GP)
717:                 						w = strlen((char*)RAMStrPtr);
9D0182BC  8F828158   LW V0, -32424(GP)
9D0182C0  00402021   ADDU A0, V0, ZERO
9D0182C4  0F40D2F2   JAL 0x9D034BC8
9D0182C8  00000000   NOP
9D0182CC  A7C20010   SH V0, 16(S8)
718:                 					}
719:                 
720:                 					while(w)
9D0182A4  0B4060F5   J 0x9D0183D4
9D0182A8  00000000   NOP
9D0182D0  0B4060F5   J 0x9D0183D4
9D0182D4  00000000   NOP
9D0183D4  97C20010   LHU V0, 16(S8)
9D0183D8  1440FFBF   BNE V0, ZERO, 0x9D0182D8
9D0183DC  00000000   NOP
721:                 					{
722:                 						i = 0;
9D0182D8  A3C00012   SB ZERO, 18(S8)
723:                 						while((i < w) && (i < sizeof(vBase64Buffer)*3/4))
9D0182DC  0B4060D7   J 0x9D01835C
9D0182E0  00000000   NOP
9D01835C  93C20012   LBU V0, 18(S8)
9D018360  97C30010   LHU V1, 16(S8)
9D018364  0043102B   SLTU V0, V0, V1
9D018368  10400005   BEQ V0, ZERO, 0x9D018380
9D01836C  00000000   NOP
9D018370  93C20012   LBU V0, 18(S8)
9D018374  2C420003   SLTIU V0, V0, 3
9D018378  1440FFDA   BNE V0, ZERO, 0x9D0182E4
9D01837C  00000000   NOP
724:                 						{
725:                 							if(SMTPClient.ROMPointers.Password)
9D0182E4  3C02A000   LUI V0, -24576
9D0182E8  24420610   ADDIU V0, V0, 1552
9D0182EC  8C420028   LW V0, 40(V0)
9D0182F0  30420004   ANDI V0, V0, 4
9D0182F4  1040000C   BEQ V0, ZERO, 0x9D018328
9D0182F8  00000000   NOP
726:                 								vBase64Buffer[i] = *ROMStrPtr++;
9D0182FC  93C20012   LBU V0, 18(S8)
9D018300  00401821   ADDU V1, V0, ZERO
9D018304  8F828154   LW V0, -32428(GP)
9D018308  90440000   LBU A0, 0(V0)
9D01830C  27C50010   ADDIU A1, S8, 16
9D018310  00A31821   ADDU V1, A1, V1
9D018314  A0640004   SB A0, 4(V1)
9D018318  24420001   ADDIU V0, V0, 1
9D01831C  AF828154   SW V0, -32428(GP)
9D018320  0B4060D3   J 0x9D01834C
9D018324  00000000   NOP
727:                 							else
728:                 								vBase64Buffer[i] = *RAMStrPtr++;
9D018328  93C20012   LBU V0, 18(S8)
9D01832C  00401821   ADDU V1, V0, ZERO
9D018330  8F828158   LW V0, -32424(GP)
9D018334  90440000   LBU A0, 0(V0)
9D018338  27C50010   ADDIU A1, S8, 16
9D01833C  00A31821   ADDU V1, A1, V1
9D018340  A0640004   SB A0, 4(V1)
9D018344  24420001   ADDIU V0, V0, 1
9D018348  AF828158   SW V0, -32424(GP)
729:                 							i++;
9D01834C  93C20012   LBU V0, 18(S8)
9D018350  24420001   ADDIU V0, V0, 1
9D018354  304200FF   ANDI V0, V0, 255
9D018358  A3C20012   SB V0, 18(S8)
730:                 						}
731:                 						w -= i;					
9D018380  93C20012   LBU V0, 18(S8)
9D018384  97C30010   LHU V1, 16(S8)
9D018388  00621023   SUBU V0, V1, V0
9D01838C  A7C20010   SH V0, 16(S8)
732:                 						Base64Encode(vBase64Buffer, i, vBase64Buffer, sizeof(vBase64Buffer));
9D018390  93C20012   LBU V0, 18(S8)
9D018394  00401821   ADDU V1, V0, ZERO
9D018398  27C40014   ADDIU A0, S8, 20
9D01839C  27C20014   ADDIU V0, S8, 20
9D0183A0  00602821   ADDU A1, V1, ZERO
9D0183A4  00403021   ADDU A2, V0, ZERO
9D0183A8  24070004   ADDIU A3, ZERO, 4
9D0183AC  0F409852   JAL Base64Encode
9D0183B0  00000000   NOP
733:                 						TCPPutArray(MySocket, vBase64Buffer, sizeof(vBase64Buffer));
9D0183B4  93828025   LBU V0, -32731(GP)
9D0183B8  00401821   ADDU V1, V0, ZERO
9D0183BC  27C20014   ADDIU V0, S8, 20
9D0183C0  00602021   ADDU A0, V1, ZERO
9D0183C4  00402821   ADDU A1, V0, ZERO
9D0183C8  24060004   ADDIU A2, ZERO, 4
9D0183CC  0F4004E1   JAL TCPPutArray
9D0183D0  00000000   NOP
734:                 					}
735:                 					TCPPutROMString(MySocket, (ROM BYTE*)"\r\n");
9D0183E0  93828025   LBU V0, -32731(GP)
9D0183E4  00401821   ADDU V1, V0, ZERO
9D0183E8  3C029D03   LUI V0, -25341
9D0183EC  24425B04   ADDIU V0, V0, 23300
9D0183F0  00602021   ADDU A0, V1, ZERO
9D0183F4  00402821   ADDU A1, V0, ZERO
9D0183F8  0F4005FD   JAL TCPPutString
9D0183FC  00000000   NOP
736:                 					TCPFlush(MySocket);
9D018400  93828025   LBU V0, -32731(GP)
9D018404  00402021   ADDU A0, V0, ZERO
9D018408  0F400366   JAL TCPFlush
9D01840C  00000000   NOP
737:                 					SMTPState++;
9D018410  8F82813C   LW V0, -32452(GP)
9D018414  24420001   ADDIU V0, V0, 1
9D018418  AF82813C   SW V0, -32452(GP)
738:                 					break;
9D01841C  0B406550   J 0x9D019540
9D018420  00000000   NOP
739:                 
740:                 				case SMTP_MAILFROM:
741:                 					// Send MAIL FROM header.  Note that this is for the SMTP server validation, 
742:                 					// not what actually will be displayed in the recipients mail client as a 
743:                 					// return address.
744:                 					TCPPutROMString(MySocket, (ROM BYTE*)"MAIL FROM:<");
9D018424  93828025   LBU V0, -32731(GP)
9D018428  00401821   ADDU V1, V0, ZERO
9D01842C  3C029D03   LUI V0, -25341
9D018430  24425B08   ADDIU V0, V0, 23304
9D018434  00602021   ADDU A0, V1, ZERO
9D018438  00402821   ADDU A1, V0, ZERO
9D01843C  0F4005FD   JAL TCPPutString
9D018440  00000000   NOP
745:                 					if(SMTPClient.ROMPointers.From)
9D018444  3C02A000   LUI V0, -24576
9D018448  24420610   ADDIU V0, V0, 1552
9D01844C  8C420028   LW V0, 40(V0)
9D018450  30420040   ANDI V0, V0, 64
9D018454  10400013   BEQ V0, ZERO, 0x9D0184A4
9D018458  00000000   NOP
746:                 					{
747:                 						ROMStrPtr = FindROMEmailAddress(SMTPClient.From.szROM, &wAddressLength);
9D01845C  3C02A000   LUI V0, -24576
9D018460  24420610   ADDIU V0, V0, 1552
9D018464  8C420018   LW V0, 24(V0)
9D018468  00402021   ADDU A0, V0, ZERO
9D01846C  2785815C   ADDIU A1, GP, -32420
9D018470  0F4066E8   JAL 0x9D019BA0
9D018474  00000000   NOP
9D018478  AF828154   SW V0, -32428(GP)
748:                 						TCPPutROMArray(MySocket, ROMStrPtr, wAddressLength);
9D01847C  93828025   LBU V0, -32731(GP)
9D018480  00402021   ADDU A0, V0, ZERO
9D018484  8F838154   LW V1, -32428(GP)
9D018488  9782815C   LHU V0, -32420(GP)
9D01848C  00602821   ADDU A1, V1, ZERO
9D018490  00403021   ADDU A2, V0, ZERO
9D018494  0F4004E1   JAL TCPPutArray
9D018498  00000000   NOP
9D01849C  0B406139   J 0x9D0184E4
9D0184A0  00000000   NOP
749:                 					}
750:                 					else
751:                 					{
752:                 						RAMStrPtr = FindEmailAddress(SMTPClient.From.szRAM, &wAddressLength);
9D0184A4  3C02A000   LUI V0, -24576
9D0184A8  24420610   ADDIU V0, V0, 1552
9D0184AC  8C420018   LW V0, 24(V0)
9D0184B0  00402021   ADDU A0, V0, ZERO
9D0184B4  2785815C   ADDIU A1, GP, -32420
9D0184B8  0F406679   JAL 0x9D0199E4
9D0184BC  00000000   NOP
9D0184C0  AF828158   SW V0, -32424(GP)
753:                 						TCPPutArray(MySocket, RAMStrPtr, wAddressLength);
9D0184C4  93828025   LBU V0, -32731(GP)
9D0184C8  00402021   ADDU A0, V0, ZERO
9D0184CC  8F838158   LW V1, -32424(GP)
9D0184D0  9782815C   LHU V0, -32420(GP)
9D0184D4  00602821   ADDU A1, V1, ZERO
9D0184D8  00403021   ADDU A2, V0, ZERO
9D0184DC  0F4004E1   JAL TCPPutArray
9D0184E0  00000000   NOP
754:                 					}
755:                 					TCPPutROMString(MySocket, (ROM BYTE*)">\r\n");
9D0184E4  93828025   LBU V0, -32731(GP)
9D0184E8  00401821   ADDU V1, V0, ZERO
9D0184EC  3C029D03   LUI V0, -25341
9D0184F0  24425B14   ADDIU V0, V0, 23316
9D0184F4  00602021   ADDU A0, V1, ZERO
9D0184F8  00402821   ADDU A1, V0, ZERO
9D0184FC  0F4005FD   JAL TCPPutString
9D018500  00000000   NOP
756:                 					TCPFlush(MySocket);
9D018504  93828025   LBU V0, -32731(GP)
9D018508  00402021   ADDU A0, V0, ZERO
9D01850C  0F400366   JAL TCPFlush
9D018510  00000000   NOP
757:                 					SMTPState++;
9D018514  8F82813C   LW V0, -32452(GP)
9D018518  24420001   ADDIU V0, V0, 1
9D01851C  AF82813C   SW V0, -32452(GP)
758:                 					break;
9D018520  0B406550   J 0x9D019540
9D018524  00000000   NOP
759:                 
760:                 				case SMTP_RCPTTO_INIT:
761:                 					// See if there are any (To) recipients to process
762:                 					if(SMTPClient.To.szRAM && !SMTPClient.ROMPointers.To)
9D018528  3C02A000   LUI V0, -24576
9D01852C  24420610   ADDIU V0, V0, 1552
9D018530  8C42000C   LW V0, 12(V0)
9D018534  10400016   BEQ V0, ZERO, 0x9D018590
9D018538  00000000   NOP
9D01853C  3C02A000   LUI V0, -24576
9D018540  24420610   ADDIU V0, V0, 1552
9D018544  8C420028   LW V0, 40(V0)
9D018548  30420008   ANDI V0, V0, 8
9D01854C  14400010   BNE V0, ZERO, 0x9D018590
9D018550  00000000   NOP
763:                 					{
764:                 						RAMStrPtr = FindEmailAddress(SMTPClient.To.szRAM, &wAddressLength);
9D018554  3C02A000   LUI V0, -24576
9D018558  24420610   ADDIU V0, V0, 1552
9D01855C  8C42000C   LW V0, 12(V0)
9D018560  00402021   ADDU A0, V0, ZERO
9D018564  2785815C   ADDIU A1, GP, -32420
9D018568  0F406679   JAL 0x9D0199E4
9D01856C  00000000   NOP
9D018570  AF828158   SW V0, -32424(GP)
765:                 						if(wAddressLength)
9D018574  9782815C   LHU V0, -32420(GP)
9D018578  10400005   BEQ V0, ZERO, 0x9D018590
9D01857C  00000000   NOP
766:                 						{
767:                 							SMTPState = SMTP_RCPTTO;
9D018580  2402000C   ADDIU V0, ZERO, 12
9D018584  AF82813C   SW V0, -32452(GP)
768:                 							break;
9D018588  0B406550   J 0x9D019540
9D01858C  00000000   NOP
769:                 						}
770:                 					}
771:                 					if(SMTPClient.To.szROM && SMTPClient.ROMPointers.To)
9D018590  3C02A000   LUI V0, -24576
9D018594  24420610   ADDIU V0, V0, 1552
9D018598  8C42000C   LW V0, 12(V0)
9D01859C  10400016   BEQ V0, ZERO, 0x9D0185F8
9D0185A0  00000000   NOP
9D0185A4  3C02A000   LUI V0, -24576
9D0185A8  24420610   ADDIU V0, V0, 1552
9D0185AC  8C420028   LW V0, 40(V0)
9D0185B0  30420008   ANDI V0, V0, 8
9D0185B4  10400010   BEQ V0, ZERO, 0x9D0185F8
9D0185B8  00000000   NOP
772:                 					{
773:                 						ROMStrPtr = FindROMEmailAddress(SMTPClient.To.szROM, &wAddressLength);
9D0185BC  3C02A000   LUI V0, -24576
9D0185C0  24420610   ADDIU V0, V0, 1552
9D0185C4  8C42000C   LW V0, 12(V0)
9D0185C8  00402021   ADDU A0, V0, ZERO
9D0185CC  2785815C   ADDIU A1, GP, -32420
9D0185D0  0F4066E8   JAL 0x9D019BA0
9D0185D4  00000000   NOP
9D0185D8  AF828154   SW V0, -32428(GP)
774:                 						if(wAddressLength)
9D0185DC  9782815C   LHU V0, -32420(GP)
9D0185E0  10400005   BEQ V0, ZERO, 0x9D0185F8
9D0185E4  00000000   NOP
775:                 						{
776:                 							SMTPState = SMTP_RCPTTO;
9D0185E8  2402000C   ADDIU V0, ZERO, 12
9D0185EC  AF82813C   SW V0, -32452(GP)
777:                 							break;
9D0185F0  0B406550   J 0x9D019540
9D0185F4  00000000   NOP
778:                 						}
779:                 					}
780:                 					
781:                 					SMTPState = SMTP_RCPTTOCC_INIT;
9D0185F8  2402000F   ADDIU V0, ZERO, 15
9D0185FC  AF82813C   SW V0, -32452(GP)
782:                 					break;
9D018600  0B406550   J 0x9D019540
9D018604  00000000   NOP
783:                 
784:                 				case SMTP_RCPTTO:
785:                 				case SMTP_RCPTTOCC:
786:                 				case SMTP_RCPTTOBCC:
787:                 					TCPPutROMString(MySocket, (ROM BYTE*)"RCPT TO:<");
9D018608  93828025   LBU V0, -32731(GP)
9D01860C  00401821   ADDU V1, V0, ZERO
9D018610  3C029D03   LUI V0, -25341
9D018614  24425B18   ADDIU V0, V0, 23320
9D018618  00602021   ADDU A0, V1, ZERO
9D01861C  00402821   ADDU A1, V0, ZERO
9D018620  0F4005FD   JAL TCPPutString
9D018624  00000000   NOP
788:                 					if(	(SMTPClient.ROMPointers.To  && (SMTPState == SMTP_RCPTTO)) || 
9D018628  3C02A000   LUI V0, -24576
9D01862C  24420610   ADDIU V0, V0, 1552
9D018630  8C420028   LW V0, 40(V0)
9D018634  30420008   ANDI V0, V0, 8
9D018638  10400005   BEQ V0, ZERO, 0x9D018650
9D01863C  00000000   NOP
9D018640  8F83813C   LW V1, -32452(GP)
9D018644  2402000C   ADDIU V0, ZERO, 12
9D018648  10620015   BEQ V1, V0, 0x9D0186A0
9D01864C  00000000   NOP
9D018660  10400005   BEQ V0, ZERO, 0x9D018678
9D018664  00000000   NOP
789:                 						(SMTPClient.ROMPointers.CC  && (SMTPState == SMTP_RCPTTOCC)) || 
9D018650  3C02A000   LUI V0, -24576
9D018654  24420610   ADDIU V0, V0, 1552
9D018658  8C420028   LW V0, 40(V0)
9D01865C  30420010   ANDI V0, V0, 16
9D018668  8F83813C   LW V1, -32452(GP)
9D01866C  24020010   ADDIU V0, ZERO, 16
9D018670  1062000B   BEQ V1, V0, 0x9D0186A0
9D018674  00000000   NOP
9D018688  1040000F   BEQ V0, ZERO, 0x9D0186C8
9D01868C  00000000   NOP
790:                 						(SMTPClient.ROMPointers.BCC && (SMTPState == SMTP_RCPTTOBCC)) )
9D018678  3C02A000   LUI V0, -24576
9D01867C  24420610   ADDIU V0, V0, 1552
9D018680  8C420028   LW V0, 40(V0)
9D018684  30420020   ANDI V0, V0, 32
9D018690  8F83813C   LW V1, -32452(GP)
9D018694  24020014   ADDIU V0, ZERO, 20
9D018698  1462000B   BNE V1, V0, 0x9D0186C8
9D01869C  00000000   NOP
791:                 						TCPPutROMArray(MySocket, ROMStrPtr, wAddressLength);
9D0186A0  93828025   LBU V0, -32731(GP)
9D0186A4  00402021   ADDU A0, V0, ZERO
9D0186A8  8F838154   LW V1, -32428(GP)
9D0186AC  9782815C   LHU V0, -32420(GP)
9D0186B0  00602821   ADDU A1, V1, ZERO
9D0186B4  00403021   ADDU A2, V0, ZERO
9D0186B8  0F4004E1   JAL TCPPutArray
9D0186BC  00000000   NOP
9D0186C0  0B4061BA   J 0x9D0186E8
9D0186C4  00000000   NOP
792:                 					else
793:                 						TCPPutArray(MySocket, RAMStrPtr, wAddressLength);
9D0186C8  93828025   LBU V0, -32731(GP)
9D0186CC  00402021   ADDU A0, V0, ZERO
9D0186D0  8F838158   LW V1, -32424(GP)
9D0186D4  9782815C   LHU V0, -32420(GP)
9D0186D8  00602821   ADDU A1, V1, ZERO
9D0186DC  00403021   ADDU A2, V0, ZERO
9D0186E0  0F4004E1   JAL TCPPutArray
9D0186E4  00000000   NOP
794:                 					TCPPutROMString(MySocket, (ROM BYTE*)">\r\n");
9D0186E8  93828025   LBU V0, -32731(GP)
9D0186EC  00401821   ADDU V1, V0, ZERO
9D0186F0  3C029D03   LUI V0, -25341
9D0186F4  24425B14   ADDIU V0, V0, 23316
9D0186F8  00602021   ADDU A0, V1, ZERO
9D0186FC  00402821   ADDU A1, V0, ZERO
9D018700  0F4005FD   JAL TCPPutString
9D018704  00000000   NOP
795:                 					TCPFlush(MySocket);
9D018708  93828025   LBU V0, -32731(GP)
9D01870C  00402021   ADDU A0, V0, ZERO
9D018710  0F400366   JAL TCPFlush
9D018714  00000000   NOP
796:                 					SMTPState++;
9D018718  8F82813C   LW V0, -32452(GP)
9D01871C  24420001   ADDIU V0, V0, 1
9D018720  AF82813C   SW V0, -32452(GP)
797:                 					break;
9D018724  0B406550   J 0x9D019540
9D018728  00000000   NOP
798:                 
799:                 				case SMTP_RCPTTO_ISDONE:
800:                 					// See if we have any more (To) recipients to process
801:                 					// If we do, we must roll back a couple of states
802:                 					if(SMTPClient.ROMPointers.To)
9D01872C  3C02A000   LUI V0, -24576
9D018730  24420610   ADDIU V0, V0, 1552
9D018734  8C420028   LW V0, 40(V0)
9D018738  30420008   ANDI V0, V0, 8
9D01873C  1040000B   BEQ V0, ZERO, 0x9D01876C
9D018740  00000000   NOP
803:                 						ROMStrPtr = FindROMEmailAddress(ROMStrPtr+wAddressLength, &wAddressLength);
9D018744  8F838154   LW V1, -32428(GP)
9D018748  9782815C   LHU V0, -32420(GP)
9D01874C  00621021   ADDU V0, V1, V0
9D018750  00402021   ADDU A0, V0, ZERO
9D018754  2785815C   ADDIU A1, GP, -32420
9D018758  0F4066E8   JAL 0x9D019BA0
9D01875C  00000000   NOP
9D018760  AF828154   SW V0, -32428(GP)
9D018764  0B4061E3   J 0x9D01878C
9D018768  00000000   NOP
804:                 					else
805:                 						RAMStrPtr = FindEmailAddress(RAMStrPtr+wAddressLength, &wAddressLength);
9D01876C  8F838158   LW V1, -32424(GP)
9D018770  9782815C   LHU V0, -32420(GP)
9D018774  00621021   ADDU V0, V1, V0
9D018778  00402021   ADDU A0, V0, ZERO
9D01877C  2785815C   ADDIU A1, GP, -32420
9D018780  0F406679   JAL 0x9D0199E4
9D018784  00000000   NOP
9D018788  AF828158   SW V0, -32424(GP)
806:                 	
807:                 					if(wAddressLength)
9D01878C  9782815C   LHU V0, -32420(GP)
9D018790  10400005   BEQ V0, ZERO, 0x9D0187A8
9D018794  00000000   NOP
808:                 					{
809:                 						SMTPState = SMTP_RCPTTO;
9D018798  2402000C   ADDIU V0, ZERO, 12
9D01879C  AF82813C   SW V0, -32452(GP)
810:                 						break;
9D0187A0  0B406550   J 0x9D019540
9D0187A4  00000000   NOP
811:                 					}
812:                 
813:                 					// All done with To field
814:                 					SMTPState++;
9D0187A8  8F82813C   LW V0, -32452(GP)
9D0187AC  24420001   ADDIU V0, V0, 1
9D0187B0  AF82813C   SW V0, -32452(GP)
815:                 					//No break
816:                 
817:                 				case SMTP_RCPTTOCC_INIT:
818:                 					// See if there are any Carbon Copy (CC) recipients to process
819:                 					if(SMTPClient.CC.szRAM && !SMTPClient.ROMPointers.CC)
9D0187B4  3C02A000   LUI V0, -24576
9D0187B8  24420610   ADDIU V0, V0, 1552
9D0187BC  8C420010   LW V0, 16(V0)
9D0187C0  10400016   BEQ V0, ZERO, 0x9D01881C
9D0187C4  00000000   NOP
9D0187C8  3C02A000   LUI V0, -24576
9D0187CC  24420610   ADDIU V0, V0, 1552
9D0187D0  8C420028   LW V0, 40(V0)
9D0187D4  30420010   ANDI V0, V0, 16
9D0187D8  14400010   BNE V0, ZERO, 0x9D01881C
9D0187DC  00000000   NOP
820:                 					{
821:                 						RAMStrPtr = FindEmailAddress(SMTPClient.CC.szRAM, &wAddressLength);
9D0187E0  3C02A000   LUI V0, -24576
9D0187E4  24420610   ADDIU V0, V0, 1552
9D0187E8  8C420010   LW V0, 16(V0)
9D0187EC  00402021   ADDU A0, V0, ZERO
9D0187F0  2785815C   ADDIU A1, GP, -32420
9D0187F4  0F406679   JAL 0x9D0199E4
9D0187F8  00000000   NOP
9D0187FC  AF828158   SW V0, -32424(GP)
822:                 						if(wAddressLength)
9D018800  9782815C   LHU V0, -32420(GP)
9D018804  10400005   BEQ V0, ZERO, 0x9D01881C
9D018808  00000000   NOP
823:                 						{
824:                 							SMTPState = SMTP_RCPTTOCC;
9D01880C  24020010   ADDIU V0, ZERO, 16
9D018810  AF82813C   SW V0, -32452(GP)
825:                 							break;
9D018814  0B406550   J 0x9D019540
9D018818  00000000   NOP
826:                 						}
827:                 					}
828:                 					if(SMTPClient.CC.szROM && SMTPClient.ROMPointers.CC)
9D01881C  3C02A000   LUI V0, -24576
9D018820  24420610   ADDIU V0, V0, 1552
9D018824  8C420010   LW V0, 16(V0)
9D018828  10400016   BEQ V0, ZERO, 0x9D018884
9D01882C  00000000   NOP
9D018830  3C02A000   LUI V0, -24576
9D018834  24420610   ADDIU V0, V0, 1552
9D018838  8C420028   LW V0, 40(V0)
9D01883C  30420010   ANDI V0, V0, 16
9D018840  10400010   BEQ V0, ZERO, 0x9D018884
9D018844  00000000   NOP
829:                 					{
830:                 						ROMStrPtr = FindROMEmailAddress(SMTPClient.CC.szROM, &wAddressLength);
9D018848  3C02A000   LUI V0, -24576
9D01884C  24420610   ADDIU V0, V0, 1552
9D018850  8C420010   LW V0, 16(V0)
9D018854  00402021   ADDU A0, V0, ZERO
9D018858  2785815C   ADDIU A1, GP, -32420
9D01885C  0F4066E8   JAL 0x9D019BA0
9D018860  00000000   NOP
9D018864  AF828154   SW V0, -32428(GP)
831:                 						if(wAddressLength)
9D018868  9782815C   LHU V0, -32420(GP)
9D01886C  10400005   BEQ V0, ZERO, 0x9D018884
9D018870  00000000   NOP
832:                 						{
833:                 							SMTPState = SMTP_RCPTTOCC;
9D018874  24020010   ADDIU V0, ZERO, 16
9D018878  AF82813C   SW V0, -32452(GP)
834:                 							break;
9D01887C  0B406550   J 0x9D019540
9D018880  00000000   NOP
835:                 						}
836:                 					}
837:                 					
838:                 					SMTPState = SMTP_RCPTTOBCC_INIT;
9D018884  24020013   ADDIU V0, ZERO, 19
9D018888  AF82813C   SW V0, -32452(GP)
839:                 					break;
9D01888C  0B406550   J 0x9D019540
9D018890  00000000   NOP
840:                 
841:                 				case SMTP_RCPTTOCC_ISDONE:
842:                 					// See if we have any more Carbon Copy (CC) recipients to process
843:                 					// If we do, we must roll back a couple of states
844:                 					if(SMTPClient.ROMPointers.CC)
9D018894  3C02A000   LUI V0, -24576
9D018898  24420610   ADDIU V0, V0, 1552
9D01889C  8C420028   LW V0, 40(V0)
9D0188A0  30420010   ANDI V0, V0, 16
9D0188A4  1040000B   BEQ V0, ZERO, 0x9D0188D4
9D0188A8  00000000   NOP
845:                 						ROMStrPtr = FindROMEmailAddress(ROMStrPtr+wAddressLength, &wAddressLength);
9D0188AC  8F838154   LW V1, -32428(GP)
9D0188B0  9782815C   LHU V0, -32420(GP)
9D0188B4  00621021   ADDU V0, V1, V0
9D0188B8  00402021   ADDU A0, V0, ZERO
9D0188BC  2785815C   ADDIU A1, GP, -32420
9D0188C0  0F4066E8   JAL 0x9D019BA0
9D0188C4  00000000   NOP
9D0188C8  AF828154   SW V0, -32428(GP)
9D0188CC  0B40623D   J 0x9D0188F4
9D0188D0  00000000   NOP
846:                 					else
847:                 						RAMStrPtr = FindEmailAddress(RAMStrPtr+wAddressLength, &wAddressLength);
9D0188D4  8F838158   LW V1, -32424(GP)
9D0188D8  9782815C   LHU V0, -32420(GP)
9D0188DC  00621021   ADDU V0, V1, V0
9D0188E0  00402021   ADDU A0, V0, ZERO
9D0188E4  2785815C   ADDIU A1, GP, -32420
9D0188E8  0F406679   JAL 0x9D0199E4
9D0188EC  00000000   NOP
9D0188F0  AF828158   SW V0, -32424(GP)
848:                 
849:                 					if(wAddressLength)
9D0188F4  9782815C   LHU V0, -32420(GP)
9D0188F8  10400005   BEQ V0, ZERO, 0x9D018910
9D0188FC  00000000   NOP
850:                 					{
851:                 						SMTPState = SMTP_RCPTTOCC;
9D018900  24020010   ADDIU V0, ZERO, 16
9D018904  AF82813C   SW V0, -32452(GP)
852:                 						break;
9D018908  0B406550   J 0x9D019540
9D01890C  00000000   NOP
853:                 					}
854:                 
855:                 					// All done with CC field
856:                 					SMTPState++;
9D018910  8F82813C   LW V0, -32452(GP)
9D018914  24420001   ADDIU V0, V0, 1
9D018918  AF82813C   SW V0, -32452(GP)
857:                 					//No break
858:                 
859:                 				case SMTP_RCPTTOBCC_INIT:
860:                 					// See if there are any Blind Carbon Copy (BCC) recipients to process
861:                 					if(SMTPClient.BCC.szRAM && !SMTPClient.ROMPointers.BCC)
9D01891C  3C02A000   LUI V0, -24576
9D018920  24420610   ADDIU V0, V0, 1552
9D018924  8C420014   LW V0, 20(V0)
9D018928  10400016   BEQ V0, ZERO, 0x9D018984
9D01892C  00000000   NOP
9D018930  3C02A000   LUI V0, -24576
9D018934  24420610   ADDIU V0, V0, 1552
9D018938  8C420028   LW V0, 40(V0)
9D01893C  30420020   ANDI V0, V0, 32
9D018940  14400010   BNE V0, ZERO, 0x9D018984
9D018944  00000000   NOP
862:                 					{
863:                 						RAMStrPtr = FindEmailAddress(SMTPClient.BCC.szRAM, &wAddressLength);
9D018948  3C02A000   LUI V0, -24576
9D01894C  24420610   ADDIU V0, V0, 1552
9D018950  8C420014   LW V0, 20(V0)
9D018954  00402021   ADDU A0, V0, ZERO
9D018958  2785815C   ADDIU A1, GP, -32420
9D01895C  0F406679   JAL 0x9D0199E4
9D018960  00000000   NOP
9D018964  AF828158   SW V0, -32424(GP)
864:                 						if(wAddressLength)
9D018968  9782815C   LHU V0, -32420(GP)
9D01896C  10400005   BEQ V0, ZERO, 0x9D018984
9D018970  00000000   NOP
865:                 						{
866:                 							SMTPState = SMTP_RCPTTOBCC;
9D018974  24020014   ADDIU V0, ZERO, 20
9D018978  AF82813C   SW V0, -32452(GP)
867:                 							break;
9D01897C  0B406550   J 0x9D019540
9D018980  00000000   NOP
868:                 						}
869:                 					}
870:                 					if(SMTPClient.BCC.szROM && SMTPClient.ROMPointers.BCC)
9D018984  3C02A000   LUI V0, -24576
9D018988  24420610   ADDIU V0, V0, 1552
9D01898C  8C420014   LW V0, 20(V0)
9D018990  10400016   BEQ V0, ZERO, 0x9D0189EC
9D018994  00000000   NOP
9D018998  3C02A000   LUI V0, -24576
9D01899C  24420610   ADDIU V0, V0, 1552
9D0189A0  8C420028   LW V0, 40(V0)
9D0189A4  30420020   ANDI V0, V0, 32
9D0189A8  10400010   BEQ V0, ZERO, 0x9D0189EC
9D0189AC  00000000   NOP
871:                 					{
872:                 						ROMStrPtr = FindROMEmailAddress(SMTPClient.BCC.szROM, &wAddressLength);
9D0189B0  3C02A000   LUI V0, -24576
9D0189B4  24420610   ADDIU V0, V0, 1552
9D0189B8  8C420014   LW V0, 20(V0)
9D0189BC  00402021   ADDU A0, V0, ZERO
9D0189C0  2785815C   ADDIU A1, GP, -32420
9D0189C4  0F4066E8   JAL 0x9D019BA0
9D0189C8  00000000   NOP
9D0189CC  AF828154   SW V0, -32428(GP)
873:                 						if(wAddressLength)
9D0189D0  9782815C   LHU V0, -32420(GP)
9D0189D4  10400005   BEQ V0, ZERO, 0x9D0189EC
9D0189D8  00000000   NOP
874:                 						{
875:                 							SMTPState = SMTP_RCPTTOBCC;
9D0189DC  24020014   ADDIU V0, ZERO, 20
9D0189E0  AF82813C   SW V0, -32452(GP)
876:                 							break;
9D0189E4  0B406550   J 0x9D019540
9D0189E8  00000000   NOP
877:                 						}
878:                 					}
879:                 
880:                 					// All done with BCC field
881:                 					SMTPState = SMTP_DATA;
9D0189EC  24020017   ADDIU V0, ZERO, 23
9D0189F0  AF82813C   SW V0, -32452(GP)
882:                 					break;
9D0189F4  0B406550   J 0x9D019540
9D0189F8  00000000   NOP
883:                 
884:                 				case SMTP_RCPTTOBCC_ISDONE:
885:                 					// See if we have any more Blind Carbon Copy (CC) recipients to process
886:                 					// If we do, we must roll back a couple of states
887:                 					if(SMTPClient.ROMPointers.BCC)
9D0189FC  3C02A000   LUI V0, -24576
9D018A00  24420610   ADDIU V0, V0, 1552
9D018A04  8C420028   LW V0, 40(V0)
9D018A08  30420020   ANDI V0, V0, 32
9D018A0C  1040000B   BEQ V0, ZERO, 0x9D018A3C
9D018A10  00000000   NOP
888:                 						ROMStrPtr = FindROMEmailAddress(ROMStrPtr+wAddressLength, &wAddressLength);
9D018A14  8F838154   LW V1, -32428(GP)
9D018A18  9782815C   LHU V0, -32420(GP)
9D018A1C  00621021   ADDU V0, V1, V0
9D018A20  00402021   ADDU A0, V0, ZERO
9D018A24  2785815C   ADDIU A1, GP, -32420
9D018A28  0F4066E8   JAL 0x9D019BA0
9D018A2C  00000000   NOP
9D018A30  AF828154   SW V0, -32428(GP)
9D018A34  0B406297   J 0x9D018A5C
9D018A38  00000000   NOP
889:                 					else
890:                 						RAMStrPtr = FindEmailAddress(RAMStrPtr+wAddressLength, &wAddressLength);
9D018A3C  8F838158   LW V1, -32424(GP)
9D018A40  9782815C   LHU V0, -32420(GP)
9D018A44  00621021   ADDU V0, V1, V0
9D018A48  00402021   ADDU A0, V0, ZERO
9D018A4C  2785815C   ADDIU A1, GP, -32420
9D018A50  0F406679   JAL 0x9D0199E4
9D018A54  00000000   NOP
9D018A58  AF828158   SW V0, -32424(GP)
891:                 
892:                 					if(wAddressLength)
9D018A5C  9782815C   LHU V0, -32420(GP)
9D018A60  10400005   BEQ V0, ZERO, 0x9D018A78
9D018A64  00000000   NOP
893:                 					{
894:                 						SMTPState = SMTP_RCPTTOBCC;
9D018A68  24020014   ADDIU V0, ZERO, 20
9D018A6C  AF82813C   SW V0, -32452(GP)
895:                 						break;
9D018A70  0B406550   J 0x9D019540
9D018A74  00000000   NOP
896:                 					}
897:                 
898:                 					// All done with BCC field
899:                 					SMTPState++;
9D018A78  8F82813C   LW V0, -32452(GP)
9D018A7C  24420001   ADDIU V0, V0, 1
9D018A80  AF82813C   SW V0, -32452(GP)
900:                 					//No break
901:                 
902:                 				case SMTP_DATA:
903:                 					TCPPutROMString(MySocket, (ROM BYTE*)"DATA\r\n");
9D018A84  93828025   LBU V0, -32731(GP)
9D018A88  00401821   ADDU V1, V0, ZERO
9D018A8C  3C029D03   LUI V0, -25341
9D018A90  24425B24   ADDIU V0, V0, 23332
9D018A94  00602021   ADDU A0, V1, ZERO
9D018A98  00402821   ADDU A1, V0, ZERO
9D018A9C  0F4005FD   JAL TCPPutString
9D018AA0  00000000   NOP
904:                 					SMTPState++;
9D018AA4  8F82813C   LW V0, -32452(GP)
9D018AA8  24420001   ADDIU V0, V0, 1
9D018AAC  AF82813C   SW V0, -32452(GP)
905:                 					PutHeadersState = PUTHEADERS_FROM_INIT;
9D018AB0  AF808140   SW ZERO, -32448(GP)
906:                 					TCPFlush(MySocket);
9D018AB4  93828025   LBU V0, -32731(GP)
9D018AB8  00402021   ADDU A0, V0, ZERO
9D018ABC  0F400366   JAL TCPFlush
9D018AC0  00000000   NOP
907:                 					break;
9D018AC4  0B406550   J 0x9D019540
9D018AC8  00000000   NOP
908:                 
909:                 				case SMTP_DATA_HEADER:
910:                 					while((PutHeadersState != PUTHEADERS_DONE) && (TCPIsPutReady(MySocket) > 64u))
9D0191CC  00000000   NOP
9D0191D0  0B406495   J 0x9D019254
9D0191D4  00000000   NOP
9D019254  8F838140   LW V1, -32448(GP)
9D019258  2402000A   ADDIU V0, ZERO, 10
9D01925C  10620008   BEQ V1, V0, 0x9D019280
9D019260  00000000   NOP
9D019264  93828025   LBU V0, -32731(GP)
9D019268  00402021   ADDU A0, V0, ZERO
9D01926C  0F40038E   JAL TCPIsPutReady
9D019270  00000000   NOP
9D019274  2C420041   SLTIU V0, V0, 65
9D019278  1040FE14   BEQ V0, ZERO, 0x9D018ACC
9D01927C  00000000   NOP
911:                 					{
912:                 						switch(PutHeadersState)
9D018ACC  8F828140   LW V0, -32448(GP)
9D018AD0  2C43000A   SLTIU V1, V0, 10
9D018AD4  106001C0   BEQ V1, ZERO, 0x9D0191D8
9D018AD8  00000000   NOP
9D018ADC  00021880   SLL V1, V0, 2
9D018AE0  3C029D02   LUI V0, -25342
9D018AE4  24428AF8   ADDIU V0, V0, -29960
9D018AE8  00621021   ADDU V0, V1, V0
9D018AEC  8C420000   LW V0, 0(V0)
9D018AF0  00400008   JR V0
9D018AF4  00000000   NOP
913:                 						{
914:                 							case PUTHEADERS_FROM_INIT:
915:                 								if(SMTPClient.From.szRAM || SMTPClient.From.szROM)
9D018B20  3C02A000   LUI V0, -24576
9D018B24  24420610   ADDIU V0, V0, 1552
9D018B28  8C420018   LW V0, 24(V0)
9D018B2C  14400006   BNE V0, ZERO, 0x9D018B48
9D018B30  00000000   NOP
9D018B34  3C02A000   LUI V0, -24576
9D018B38  24420610   ADDIU V0, V0, 1552
9D018B3C  8C420018   LW V0, 24(V0)
9D018B40  1040000D   BEQ V0, ZERO, 0x9D018B78
9D018B44  00000000   NOP
916:                 								{
917:                 									PutHeadersState = PUTHEADERS_FROM;
9D018B48  24020001   ADDIU V0, ZERO, 1
9D018B4C  AF828140   SW V0, -32448(GP)
918:                 									TCPPutROMString(MySocket, (ROM BYTE*)"From: ");
9D018B50  93828025   LBU V0, -32731(GP)
9D018B54  00401821   ADDU V1, V0, ZERO
9D018B58  3C029D03   LUI V0, -25341
9D018B5C  24425B2C   ADDIU V0, V0, 23340
9D018B60  00602021   ADDU A0, V1, ZERO
9D018B64  00402821   ADDU A1, V0, ZERO
9D018B68  0F4005FD   JAL TCPPutString
9D018B6C  00000000   NOP
919:                 								}
920:                 								else
921:                 								{
922:                 									PutHeadersState = PUTHEADERS_TO_INIT;
9D018B78  24020002   ADDIU V0, ZERO, 2
9D018B7C  AF828140   SW V0, -32448(GP)
923:                 								}
924:                 								break;
9D018B70  0B406495   J 0x9D019254
9D018B74  00000000   NOP
9D018B80  0B406495   J 0x9D019254
9D018B84  00000000   NOP
925:                 								
926:                 							case PUTHEADERS_FROM:
927:                 								if(SMTPClient.ROMPointers.From)
9D018B88  3C02A000   LUI V0, -24576
9D018B8C  24420610   ADDIU V0, V0, 1552
9D018B90  8C420028   LW V0, 40(V0)
9D018B94  30420040   ANDI V0, V0, 64
9D018B98  10400018   BEQ V0, ZERO, 0x9D018BFC
9D018B9C  00000000   NOP
928:                 								{
929:                 									SMTPClient.From.szROM = TCPPutROMString(MySocket, SMTPClient.From.szROM);
9D018BA0  93828025   LBU V0, -32731(GP)
9D018BA4  00401821   ADDU V1, V0, ZERO
9D018BA8  3C02A000   LUI V0, -24576
9D018BAC  24420610   ADDIU V0, V0, 1552
9D018BB0  8C420018   LW V0, 24(V0)
9D018BB4  00602021   ADDU A0, V1, ZERO
9D018BB8  00402821   ADDU A1, V0, ZERO
9D018BBC  0F4005FD   JAL TCPPutString
9D018BC0  00000000   NOP
9D018BC4  00401821   ADDU V1, V0, ZERO
9D018BC8  3C02A000   LUI V0, -24576
9D018BCC  24420610   ADDIU V0, V0, 1552
9D018BD0  AC430018   SW V1, 24(V0)
930:                 									if(*SMTPClient.From.szROM == 0u)
9D018BD4  3C02A000   LUI V0, -24576
9D018BD8  24420610   ADDIU V0, V0, 1552
9D018BDC  8C420018   LW V0, 24(V0)
9D018BE0  90420000   LBU V0, 0(V0)
9D018BE4  1440017F   BNE V0, ZERO, 0x9D0191E4
9D018BE8  00000000   NOP
931:                 										PutHeadersState = PUTHEADERS_TO_INIT;
9D018BEC  24020002   ADDIU V0, ZERO, 2
9D018BF0  AF828140   SW V0, -32448(GP)
932:                 								}
933:                 								else
934:                 								{
935:                 									SMTPClient.From.szRAM = TCPPutString(MySocket, SMTPClient.From.szRAM);
9D018BFC  93828025   LBU V0, -32731(GP)
9D018C00  00401821   ADDU V1, V0, ZERO
9D018C04  3C02A000   LUI V0, -24576
9D018C08  24420610   ADDIU V0, V0, 1552
9D018C0C  8C420018   LW V0, 24(V0)
9D018C10  00602021   ADDU A0, V1, ZERO
9D018C14  00402821   ADDU A1, V0, ZERO
9D018C18  0F4005FD   JAL TCPPutString
9D018C1C  00000000   NOP
9D018C20  00401821   ADDU V1, V0, ZERO
9D018C24  3C02A000   LUI V0, -24576
9D018C28  24420610   ADDIU V0, V0, 1552
9D018C2C  AC430018   SW V1, 24(V0)
936:                 									if(*SMTPClient.From.szRAM == 0u)
9D018C30  3C02A000   LUI V0, -24576
9D018C34  24420610   ADDIU V0, V0, 1552
9D018C38  8C420018   LW V0, 24(V0)
9D018C3C  90420000   LBU V0, 0(V0)
9D018C40  1440016B   BNE V0, ZERO, 0x9D0191F0
9D018C44  00000000   NOP
937:                 										PutHeadersState = PUTHEADERS_TO_INIT;
9D018C48  24020002   ADDIU V0, ZERO, 2
9D018C4C  AF828140   SW V0, -32448(GP)
938:                 								}
939:                 								break;
9D018BF4  0B406495   J 0x9D019254
9D018BF8  00000000   NOP
9D018C50  0B406495   J 0x9D019254
9D018C54  00000000   NOP
9D0191E4  00000000   NOP
9D0191E8  0B406495   J 0x9D019254
9D0191EC  00000000   NOP
9D0191F0  00000000   NOP
9D0191F4  0B406495   J 0x9D019254
9D0191F8  00000000   NOP
940:                 
941:                 							case PUTHEADERS_TO_INIT:
942:                 								if(SMTPClient.To.szRAM || SMTPClient.To.szROM)
9D018C58  3C02A000   LUI V0, -24576
9D018C5C  24420610   ADDIU V0, V0, 1552
9D018C60  8C42000C   LW V0, 12(V0)
9D018C64  14400006   BNE V0, ZERO, 0x9D018C80
9D018C68  00000000   NOP
9D018C6C  3C02A000   LUI V0, -24576
9D018C70  24420610   ADDIU V0, V0, 1552
9D018C74  8C42000C   LW V0, 12(V0)
9D018C78  1040000D   BEQ V0, ZERO, 0x9D018CB0
9D018C7C  00000000   NOP
943:                 								{
944:                 									PutHeadersState = PUTHEADERS_TO;
9D018C80  24020003   ADDIU V0, ZERO, 3
9D018C84  AF828140   SW V0, -32448(GP)
945:                 									TCPPutROMString(MySocket, (ROM BYTE*)"\r\nTo: ");
9D018C88  93828025   LBU V0, -32731(GP)
9D018C8C  00401821   ADDU V1, V0, ZERO
9D018C90  3C029D03   LUI V0, -25341
9D018C94  24425B34   ADDIU V0, V0, 23348
9D018C98  00602021   ADDU A0, V1, ZERO
9D018C9C  00402821   ADDU A1, V0, ZERO
9D018CA0  0F4005FD   JAL TCPPutString
9D018CA4  00000000   NOP
946:                 								}
947:                 								else
948:                 								{
949:                 									PutHeadersState = PUTHEADERS_CC_INIT;
9D018CB0  24020004   ADDIU V0, ZERO, 4
9D018CB4  AF828140   SW V0, -32448(GP)
950:                 								}
951:                 								break;
9D018CA8  0B406495   J 0x9D019254
9D018CAC  00000000   NOP
9D018CB8  0B406495   J 0x9D019254
9D018CBC  00000000   NOP
952:                 								
953:                 							case PUTHEADERS_TO:
954:                 								if(SMTPClient.ROMPointers.To)
9D018CC0  3C02A000   LUI V0, -24576
9D018CC4  24420610   ADDIU V0, V0, 1552
9D018CC8  8C420028   LW V0, 40(V0)
9D018CCC  30420008   ANDI V0, V0, 8
9D018CD0  10400018   BEQ V0, ZERO, 0x9D018D34
9D018CD4  00000000   NOP
955:                 								{
956:                 									SMTPClient.To.szROM = TCPPutROMString(MySocket, SMTPClient.To.szROM);
9D018CD8  93828025   LBU V0, -32731(GP)
9D018CDC  00401821   ADDU V1, V0, ZERO
9D018CE0  3C02A000   LUI V0, -24576
9D018CE4  24420610   ADDIU V0, V0, 1552
9D018CE8  8C42000C   LW V0, 12(V0)
9D018CEC  00602021   ADDU A0, V1, ZERO
9D018CF0  00402821   ADDU A1, V0, ZERO
9D018CF4  0F4005FD   JAL TCPPutString
9D018CF8  00000000   NOP
9D018CFC  00401821   ADDU V1, V0, ZERO
9D018D00  3C02A000   LUI V0, -24576
9D018D04  24420610   ADDIU V0, V0, 1552
9D018D08  AC43000C   SW V1, 12(V0)
957:                 									if(*SMTPClient.To.szROM == 0u)
9D018D0C  3C02A000   LUI V0, -24576
9D018D10  24420610   ADDIU V0, V0, 1552
9D018D14  8C42000C   LW V0, 12(V0)
9D018D18  90420000   LBU V0, 0(V0)
9D018D1C  14400137   BNE V0, ZERO, 0x9D0191FC
9D018D20  00000000   NOP
958:                 										PutHeadersState = PUTHEADERS_CC_INIT;
9D018D24  24020004   ADDIU V0, ZERO, 4
9D018D28  AF828140   SW V0, -32448(GP)
959:                 								}
960:                 								else
961:                 								{
962:                 									SMTPClient.To.szRAM = TCPPutString(MySocket, SMTPClient.To.szRAM);
9D018D34  93828025   LBU V0, -32731(GP)
9D018D38  00401821   ADDU V1, V0, ZERO
9D018D3C  3C02A000   LUI V0, -24576
9D018D40  24420610   ADDIU V0, V0, 1552
9D018D44  8C42000C   LW V0, 12(V0)
9D018D48  00602021   ADDU A0, V1, ZERO
9D018D4C  00402821   ADDU A1, V0, ZERO
9D018D50  0F4005FD   JAL TCPPutString
9D018D54  00000000   NOP
9D018D58  00401821   ADDU V1, V0, ZERO
9D018D5C  3C02A000   LUI V0, -24576
9D018D60  24420610   ADDIU V0, V0, 1552
9D018D64  AC43000C   SW V1, 12(V0)
963:                 									if(*SMTPClient.To.szRAM == 0u)
9D018D68  3C02A000   LUI V0, -24576
9D018D6C  24420610   ADDIU V0, V0, 1552
9D018D70  8C42000C   LW V0, 12(V0)
9D018D74  90420000   LBU V0, 0(V0)
9D018D78  14400123   BNE V0, ZERO, 0x9D019208
9D018D7C  00000000   NOP
964:                 										PutHeadersState = PUTHEADERS_CC_INIT;
9D018D80  24020004   ADDIU V0, ZERO, 4
9D018D84  AF828140   SW V0, -32448(GP)
965:                 								}
966:                 								break;
9D018D2C  0B406495   J 0x9D019254
9D018D30  00000000   NOP
9D018D88  0B406495   J 0x9D019254
9D018D8C  00000000   NOP
9D0191FC  00000000   NOP
9D019200  0B406495   J 0x9D019254
9D019204  00000000   NOP
9D019208  00000000   NOP
9D01920C  0B406495   J 0x9D019254
9D019210  00000000   NOP
967:                 
968:                 							case PUTHEADERS_CC_INIT:
969:                 								if(SMTPClient.CC.szRAM || SMTPClient.CC.szROM)
9D018D90  3C02A000   LUI V0, -24576
9D018D94  24420610   ADDIU V0, V0, 1552
9D018D98  8C420010   LW V0, 16(V0)
9D018D9C  14400006   BNE V0, ZERO, 0x9D018DB8
9D018DA0  00000000   NOP
9D018DA4  3C02A000   LUI V0, -24576
9D018DA8  24420610   ADDIU V0, V0, 1552
9D018DAC  8C420010   LW V0, 16(V0)
9D018DB0  1040000D   BEQ V0, ZERO, 0x9D018DE8
9D018DB4  00000000   NOP
970:                 								{
971:                 									PutHeadersState = PUTHEADERS_CC;
9D018DB8  24020005   ADDIU V0, ZERO, 5
9D018DBC  AF828140   SW V0, -32448(GP)
972:                 									TCPPutROMString(MySocket, (ROM BYTE*)"\r\nCC: ");
9D018DC0  93828025   LBU V0, -32731(GP)
9D018DC4  00401821   ADDU V1, V0, ZERO
9D018DC8  3C029D03   LUI V0, -25341
9D018DCC  24425B3C   ADDIU V0, V0, 23356
9D018DD0  00602021   ADDU A0, V1, ZERO
9D018DD4  00402821   ADDU A1, V0, ZERO
9D018DD8  0F4005FD   JAL TCPPutString
9D018DDC  00000000   NOP
973:                 								}
974:                 								else
975:                 								{
976:                 									PutHeadersState = PUTHEADERS_SUBJECT_INIT;
9D018DE8  24020006   ADDIU V0, ZERO, 6
9D018DEC  AF828140   SW V0, -32448(GP)
977:                 								}
978:                 								break;
9D018DE0  0B406495   J 0x9D019254
9D018DE4  00000000   NOP
9D018DF0  0B406495   J 0x9D019254
9D018DF4  00000000   NOP
979:                 								
980:                 							case PUTHEADERS_CC:
981:                 								if(SMTPClient.ROMPointers.CC)
9D018DF8  3C02A000   LUI V0, -24576
9D018DFC  24420610   ADDIU V0, V0, 1552
9D018E00  8C420028   LW V0, 40(V0)
9D018E04  30420010   ANDI V0, V0, 16
9D018E08  10400018   BEQ V0, ZERO, 0x9D018E6C
9D018E0C  00000000   NOP
982:                 								{
983:                 									SMTPClient.CC.szROM = TCPPutROMString(MySocket, SMTPClient.CC.szROM);
9D018E10  93828025   LBU V0, -32731(GP)
9D018E14  00401821   ADDU V1, V0, ZERO
9D018E18  3C02A000   LUI V0, -24576
9D018E1C  24420610   ADDIU V0, V0, 1552
9D018E20  8C420010   LW V0, 16(V0)
9D018E24  00602021   ADDU A0, V1, ZERO
9D018E28  00402821   ADDU A1, V0, ZERO
9D018E2C  0F4005FD   JAL TCPPutString
9D018E30  00000000   NOP
9D018E34  00401821   ADDU V1, V0, ZERO
9D018E38  3C02A000   LUI V0, -24576
9D018E3C  24420610   ADDIU V0, V0, 1552
9D018E40  AC430010   SW V1, 16(V0)
984:                 									if(*SMTPClient.CC.szROM == 0u)
9D018E44  3C02A000   LUI V0, -24576
9D018E48  24420610   ADDIU V0, V0, 1552
9D018E4C  8C420010   LW V0, 16(V0)
9D018E50  90420000   LBU V0, 0(V0)
9D018E54  144000EF   BNE V0, ZERO, 0x9D019214
9D018E58  00000000   NOP
985:                 										PutHeadersState = PUTHEADERS_SUBJECT_INIT;
9D018E5C  24020006   ADDIU V0, ZERO, 6
9D018E60  AF828140   SW V0, -32448(GP)
986:                 								}
987:                 								else
988:                 								{
989:                 									SMTPClient.CC.szRAM = TCPPutString(MySocket, SMTPClient.CC.szRAM);
9D018E6C  93828025   LBU V0, -32731(GP)
9D018E70  00401821   ADDU V1, V0, ZERO
9D018E74  3C02A000   LUI V0, -24576
9D018E78  24420610   ADDIU V0, V0, 1552
9D018E7C  8C420010   LW V0, 16(V0)
9D018E80  00602021   ADDU A0, V1, ZERO
9D018E84  00402821   ADDU A1, V0, ZERO
9D018E88  0F4005FD   JAL TCPPutString
9D018E8C  00000000   NOP
9D018E90  00401821   ADDU V1, V0, ZERO
9D018E94  3C02A000   LUI V0, -24576
9D018E98  24420610   ADDIU V0, V0, 1552
9D018E9C  AC430010   SW V1, 16(V0)
990:                 									if(*SMTPClient.CC.szRAM == 0u)
9D018EA0  3C02A000   LUI V0, -24576
9D018EA4  24420610   ADDIU V0, V0, 1552
9D018EA8  8C420010   LW V0, 16(V0)
9D018EAC  90420000   LBU V0, 0(V0)
9D018EB0  144000DB   BNE V0, ZERO, 0x9D019220
9D018EB4  00000000   NOP
991:                 										PutHeadersState = PUTHEADERS_SUBJECT_INIT;
9D018EB8  24020006   ADDIU V0, ZERO, 6
9D018EBC  AF828140   SW V0, -32448(GP)
992:                 								}
993:                 								break;
9D018E64  0B406495   J 0x9D019254
9D018E68  00000000   NOP
9D018EC0  0B406495   J 0x9D019254
9D018EC4  00000000   NOP
9D019214  00000000   NOP
9D019218  0B406495   J 0x9D019254
9D01921C  00000000   NOP
9D019220  00000000   NOP
9D019224  0B406495   J 0x9D019254
9D019228  00000000   NOP
994:                 
995:                 							case PUTHEADERS_SUBJECT_INIT:
996:                 								if(SMTPClient.Subject.szRAM || SMTPClient.Subject.szROM)
9D018EC8  3C02A000   LUI V0, -24576
9D018ECC  24420610   ADDIU V0, V0, 1552
9D018ED0  8C42001C   LW V0, 28(V0)
9D018ED4  14400006   BNE V0, ZERO, 0x9D018EF0
9D018ED8  00000000   NOP
9D018EDC  3C02A000   LUI V0, -24576
9D018EE0  24420610   ADDIU V0, V0, 1552
9D018EE4  8C42001C   LW V0, 28(V0)
9D018EE8  1040000D   BEQ V0, ZERO, 0x9D018F20
9D018EEC  00000000   NOP
997:                 								{
998:                 									PutHeadersState = PUTHEADERS_SUBJECT;
9D018EF0  24020007   ADDIU V0, ZERO, 7
9D018EF4  AF828140   SW V0, -32448(GP)
999:                 									TCPPutROMString(MySocket, (ROM BYTE*)"\r\nSubject: ");
9D018EF8  93828025   LBU V0, -32731(GP)
9D018EFC  00401821   ADDU V1, V0, ZERO
9D018F00  3C029D03   LUI V0, -25341
9D018F04  24425B44   ADDIU V0, V0, 23364
9D018F08  00602021   ADDU A0, V1, ZERO
9D018F0C  00402821   ADDU A1, V0, ZERO
9D018F10  0F4005FD   JAL TCPPutString
9D018F14  00000000   NOP
1000:                								}
1001:                								else
1002:                								{
1003:                									PutHeadersState = PUTHEADERS_OTHER_INIT;
9D018F20  24020008   ADDIU V0, ZERO, 8
9D018F24  AF828140   SW V0, -32448(GP)
1004:                								}
1005:                								break;
9D018F18  0B406495   J 0x9D019254
9D018F1C  00000000   NOP
9D018F28  0B406495   J 0x9D019254
9D018F2C  00000000   NOP
1006:                								
1007:                							case PUTHEADERS_SUBJECT:
1008:                								if(SMTPClient.ROMPointers.Subject)
9D018F30  3C02A000   LUI V0, -24576
9D018F34  24420610   ADDIU V0, V0, 1552
9D018F38  8C420028   LW V0, 40(V0)
9D018F3C  30420080   ANDI V0, V0, 128
9D018F40  10400018   BEQ V0, ZERO, 0x9D018FA4
9D018F44  00000000   NOP
1009:                								{
1010:                									SMTPClient.Subject.szROM = TCPPutROMString(MySocket, SMTPClient.Subject.szROM);
9D018F48  93828025   LBU V0, -32731(GP)
9D018F4C  00401821   ADDU V1, V0, ZERO
9D018F50  3C02A000   LUI V0, -24576
9D018F54  24420610   ADDIU V0, V0, 1552
9D018F58  8C42001C   LW V0, 28(V0)
9D018F5C  00602021   ADDU A0, V1, ZERO
9D018F60  00402821   ADDU A1, V0, ZERO
9D018F64  0F4005FD   JAL TCPPutString
9D018F68  00000000   NOP
9D018F6C  00401821   ADDU V1, V0, ZERO
9D018F70  3C02A000   LUI V0, -24576
9D018F74  24420610   ADDIU V0, V0, 1552
9D018F78  AC43001C   SW V1, 28(V0)
1011:                									if(*SMTPClient.Subject.szROM == 0u)
9D018F7C  3C02A000   LUI V0, -24576
9D018F80  24420610   ADDIU V0, V0, 1552
9D018F84  8C42001C   LW V0, 28(V0)
9D018F88  90420000   LBU V0, 0(V0)
9D018F8C  144000A7   BNE V0, ZERO, 0x9D01922C
9D018F90  00000000   NOP
1012:                										PutHeadersState = PUTHEADERS_OTHER_INIT;
9D018F94  24020008   ADDIU V0, ZERO, 8
9D018F98  AF828140   SW V0, -32448(GP)
1013:                								}
1014:                								else
1015:                								{
1016:                									SMTPClient.Subject.szRAM = TCPPutString(MySocket, SMTPClient.Subject.szRAM);
9D018FA4  93828025   LBU V0, -32731(GP)
9D018FA8  00401821   ADDU V1, V0, ZERO
9D018FAC  3C02A000   LUI V0, -24576
9D018FB0  24420610   ADDIU V0, V0, 1552
9D018FB4  8C42001C   LW V0, 28(V0)
9D018FB8  00602021   ADDU A0, V1, ZERO
9D018FBC  00402821   ADDU A1, V0, ZERO
9D018FC0  0F4005FD   JAL TCPPutString
9D018FC4  00000000   NOP
9D018FC8  00401821   ADDU V1, V0, ZERO
9D018FCC  3C02A000   LUI V0, -24576
9D018FD0  24420610   ADDIU V0, V0, 1552
9D018FD4  AC43001C   SW V1, 28(V0)
1017:                									if(*SMTPClient.Subject.szRAM == 0u)
9D018FD8  3C02A000   LUI V0, -24576
9D018FDC  24420610   ADDIU V0, V0, 1552
9D018FE0  8C42001C   LW V0, 28(V0)
9D018FE4  90420000   LBU V0, 0(V0)
9D018FE8  14400093   BNE V0, ZERO, 0x9D019238
9D018FEC  00000000   NOP
1018:                										PutHeadersState = PUTHEADERS_OTHER_INIT;
9D018FF0  24020008   ADDIU V0, ZERO, 8
9D018FF4  AF828140   SW V0, -32448(GP)
1019:                								}
1020:                								break;
9D018F9C  0B406495   J 0x9D019254
9D018FA0  00000000   NOP
9D018FF8  0B406495   J 0x9D019254
9D018FFC  00000000   NOP
9D01922C  00000000   NOP
9D019230  0B406495   J 0x9D019254
9D019234  00000000   NOP
9D019238  00000000   NOP
9D01923C  0B406495   J 0x9D019254
9D019240  00000000   NOP
1021:                
1022:                							case PUTHEADERS_OTHER_INIT:
1023:                								TCPPutROMArray(MySocket, (ROM BYTE*)"\r\n", 2);
9D019000  93828025   LBU V0, -32731(GP)
9D019004  00401821   ADDU V1, V0, ZERO
9D019008  3C029D03   LUI V0, -25341
9D01900C  24425B04   ADDIU V0, V0, 23300
9D019010  00602021   ADDU A0, V1, ZERO
9D019014  00402821   ADDU A1, V0, ZERO
9D019018  24060002   ADDIU A2, ZERO, 2
9D01901C  0F4004E1   JAL TCPPutArray
9D019020  00000000   NOP
1024:                								if(SMTPClient.OtherHeaders.szRAM || SMTPClient.OtherHeaders.szROM)
9D019024  3C02A000   LUI V0, -24576
9D019028  24420610   ADDIU V0, V0, 1552
9D01902C  8C420020   LW V0, 32(V0)
9D019030  14400006   BNE V0, ZERO, 0x9D01904C
9D019034  00000000   NOP
9D019038  3C02A000   LUI V0, -24576
9D01903C  24420610   ADDIU V0, V0, 1552
9D019040  8C420020   LW V0, 32(V0)
9D019044  10400005   BEQ V0, ZERO, 0x9D01905C
9D019048  00000000   NOP
1025:                								{
1026:                									PutHeadersState = PUTHEADERS_OTHER;
9D01904C  24020009   ADDIU V0, ZERO, 9
9D019050  AF828140   SW V0, -32448(GP)
1027:                								}
1028:                								else
1029:                								{
1030:                									TCPPutROMArray(MySocket, (ROM BYTE*)"\r\n", 2);
9D01905C  93828025   LBU V0, -32731(GP)
9D019060  00401821   ADDU V1, V0, ZERO
9D019064  3C029D03   LUI V0, -25341
9D019068  24425B04   ADDIU V0, V0, 23300
9D01906C  00602021   ADDU A0, V1, ZERO
9D019070  00402821   ADDU A1, V0, ZERO
9D019074  24060002   ADDIU A2, ZERO, 2
9D019078  0F4004E1   JAL TCPPutArray
9D01907C  00000000   NOP
1031:                									PutHeadersState = PUTHEADERS_DONE;
9D019080  2402000A   ADDIU V0, ZERO, 10
9D019084  AF828140   SW V0, -32448(GP)
1032:                									SMTPState++;
9D019088  8F82813C   LW V0, -32452(GP)
9D01908C  24420001   ADDIU V0, V0, 1
9D019090  AF82813C   SW V0, -32452(GP)
1033:                								}
1034:                								break;
9D019054  0B406495   J 0x9D019254
9D019058  00000000   NOP
9D019094  0B406495   J 0x9D019254
9D019098  00000000   NOP
1035:                								
1036:                							case PUTHEADERS_OTHER:
1037:                								if(SMTPClient.ROMPointers.OtherHeaders)
9D01909C  3C02A000   LUI V0, -24576
9D0190A0  24420610   ADDIU V0, V0, 1552
9D0190A4  8C420028   LW V0, 40(V0)
9D0190A8  30420100   ANDI V0, V0, 256
9D0190AC  10400024   BEQ V0, ZERO, 0x9D019140
9D0190B0  00000000   NOP
1038:                								{
1039:                									SMTPClient.OtherHeaders.szROM = TCPPutROMString(MySocket, SMTPClient.OtherHeaders.szROM);
9D0190B4  93828025   LBU V0, -32731(GP)
9D0190B8  00401821   ADDU V1, V0, ZERO
9D0190BC  3C02A000   LUI V0, -24576
9D0190C0  24420610   ADDIU V0, V0, 1552
9D0190C4  8C420020   LW V0, 32(V0)
9D0190C8  00602021   ADDU A0, V1, ZERO
9D0190CC  00402821   ADDU A1, V0, ZERO
9D0190D0  0F4005FD   JAL TCPPutString
9D0190D4  00000000   NOP
9D0190D8  00401821   ADDU V1, V0, ZERO
9D0190DC  3C02A000   LUI V0, -24576
9D0190E0  24420610   ADDIU V0, V0, 1552
9D0190E4  AC430020   SW V1, 32(V0)
1040:                									if(*SMTPClient.OtherHeaders.szROM == 0u)
9D0190E8  3C02A000   LUI V0, -24576
9D0190EC  24420610   ADDIU V0, V0, 1552
9D0190F0  8C420020   LW V0, 32(V0)
9D0190F4  90420000   LBU V0, 0(V0)
9D0190F8  14400052   BNE V0, ZERO, 0x9D019244
9D0190FC  00000000   NOP
1041:                									{
1042:                										TCPPutROMArray(MySocket, (ROM BYTE*)"\r\n", 2);
9D019100  93828025   LBU V0, -32731(GP)
9D019104  00401821   ADDU V1, V0, ZERO
9D019108  3C029D03   LUI V0, -25341
9D01910C  24425B04   ADDIU V0, V0, 23300
9D019110  00602021   ADDU A0, V1, ZERO
9D019114  00402821   ADDU A1, V0, ZERO
9D019118  24060002   ADDIU A2, ZERO, 2
9D01911C  0F4004E1   JAL TCPPutArray
9D019120  00000000   NOP
1043:                										PutHeadersState = PUTHEADERS_DONE;
9D019124  2402000A   ADDIU V0, ZERO, 10
9D019128  AF828140   SW V0, -32448(GP)
1044:                										SMTPState++;
9D01912C  8F82813C   LW V0, -32452(GP)
9D019130  24420001   ADDIU V0, V0, 1
9D019134  AF82813C   SW V0, -32452(GP)
1045:                									}
1046:                								}
1047:                								else
1048:                								{
1049:                									SMTPClient.OtherHeaders.szRAM = TCPPutString(MySocket, SMTPClient.OtherHeaders.szRAM);
9D019140  93828025   LBU V0, -32731(GP)
9D019144  00401821   ADDU V1, V0, ZERO
9D019148  3C02A000   LUI V0, -24576
9D01914C  24420610   ADDIU V0, V0, 1552
9D019150  8C420020   LW V0, 32(V0)
9D019154  00602021   ADDU A0, V1, ZERO
9D019158  00402821   ADDU A1, V0, ZERO
9D01915C  0F4005FD   JAL TCPPutString
9D019160  00000000   NOP
9D019164  00401821   ADDU V1, V0, ZERO
9D019168  3C02A000   LUI V0, -24576
9D01916C  24420610   ADDIU V0, V0, 1552
9D019170  AC430020   SW V1, 32(V0)
1050:                									if(*SMTPClient.OtherHeaders.szRAM == 0u)
9D019174  3C02A000   LUI V0, -24576
9D019178  24420610   ADDIU V0, V0, 1552
9D01917C  8C420020   LW V0, 32(V0)
9D019180  90420000   LBU V0, 0(V0)
9D019184  14400032   BNE V0, ZERO, 0x9D019250
9D019188  00000000   NOP
1051:                									{
1052:                										TCPPutROMArray(MySocket, (ROM BYTE*)"\r\n", 2);
9D01918C  93828025   LBU V0, -32731(GP)
9D019190  00401821   ADDU V1, V0, ZERO
9D019194  3C029D03   LUI V0, -25341
9D019198  24425B04   ADDIU V0, V0, 23300
9D01919C  00602021   ADDU A0, V1, ZERO
9D0191A0  00402821   ADDU A1, V0, ZERO
9D0191A4  24060002   ADDIU A2, ZERO, 2
9D0191A8  0F4004E1   JAL TCPPutArray
9D0191AC  00000000   NOP
1053:                										PutHeadersState = PUTHEADERS_DONE;
9D0191B0  2402000A   ADDIU V0, ZERO, 10
9D0191B4  AF828140   SW V0, -32448(GP)
1054:                										SMTPState++;
9D0191B8  8F82813C   LW V0, -32452(GP)
9D0191BC  24420001   ADDIU V0, V0, 1
9D0191C0  AF82813C   SW V0, -32452(GP)
1055:                									}
1056:                								}
1057:                								break;
9D019138  0B406495   J 0x9D019254
9D01913C  00000000   NOP
9D0191C4  0B406495   J 0x9D019254
9D0191C8  00000000   NOP
9D019244  00000000   NOP
9D019248  0B406495   J 0x9D019254
9D01924C  00000000   NOP
9D019250  00000000   NOP
1058:                							
1059:                							// Default case needed to supress compiler diagnostics
1060:                							default:
1061:                								break;
9D0191D8  00000000   NOP
9D0191DC  0B406495   J 0x9D019254
9D0191E0  00000000   NOP
1062:                						}
1063:                					}
1064:                					TCPFlush(MySocket);
9D019280  93828025   LBU V0, -32731(GP)
9D019284  00402021   ADDU A0, V0, ZERO
9D019288  0F400366   JAL TCPFlush
9D01928C  00000000   NOP
1065:                					break;
9D019290  0B406550   J 0x9D019540
9D019294  00000000   NOP
1066:                		
1067:                				case SMTP_DATA_BODY_INIT:
1068:                					SMTPState++;
9D019298  8F82813C   LW V0, -32452(GP)
9D01929C  24420001   ADDIU V0, V0, 1
9D0192A0  AF82813C   SW V0, -32452(GP)
1069:                					RAMStrPtr = SMTPClient.Body.szRAM;
9D0192A4  3C02A000   LUI V0, -24576
9D0192A8  24420610   ADDIU V0, V0, 1552
9D0192AC  8C420024   LW V0, 36(V0)
9D0192B0  AF828158   SW V0, -32424(GP)
1070:                					ROMStrPtr2 = (ROM BYTE*)"\r\n.\r\n";
9D0192B4  3C029D03   LUI V0, -25341
9D0192B8  24425B50   ADDIU V0, V0, 23376
9D0192BC  AF828160   SW V0, -32416(GP)
1071:                					CRPeriod.Pos = NULL;
9D0192C0  AF808134   SW ZERO, -32460(GP)
1072:                					if(RAMStrPtr)
9D0192C4  8F828158   LW V0, -32424(GP)
9D0192C8  10400008   BEQ V0, ZERO, 0x9D0192EC
9D0192CC  00000000   NOP
1073:                						CRPeriod.Pos = (BYTE*)strstrrampgm((char*)RAMStrPtr, (ROM char*)"\r\n.");
9D0192D0  8F828158   LW V0, -32424(GP)
9D0192D4  00402021   ADDU A0, V0, ZERO
9D0192D8  3C029D03   LUI V0, -25341
9D0192DC  24455B58   ADDIU A1, V0, 23384
9D0192E0  0F40D666   JAL strstr
9D0192E4  00000000   NOP
9D0192E8  AF828134   SW V0, -32460(GP)
1074:                					// No break here
1075:                		
1076:                				case SMTP_DATA_BODY:
1077:                					if(SMTPClient.Body.szRAM || SMTPClient.Body.szROM)
9D0192EC  3C02A000   LUI V0, -24576
9D0192F0  24420610   ADDIU V0, V0, 1552
9D0192F4  8C420024   LW V0, 36(V0)
9D0192F8  14400006   BNE V0, ZERO, 0x9D019314
9D0192FC  00000000   NOP
9D019300  3C02A000   LUI V0, -24576
9D019304  24420610   ADDIU V0, V0, 1552
9D019308  8C420024   LW V0, 36(V0)
9D01930C  1040004F   BEQ V0, ZERO, 0x9D01944C
9D019310  00000000   NOP
1078:                					{
1079:                						if(*ROMStrPtr2)
9D019314  8F828160   LW V0, -32416(GP)
9D019318  90420000   LBU V0, 0(V0)
9D01931C  10400060   BEQ V0, ZERO, 0x9D0194A0
9D019320  00000000   NOP
9D019444  0B406528   J 0x9D0194A0
9D019448  00000000   NOP
1080:                						{
1081:                							// Put the application data, doing the transparancy replacement of "\r\n." with "\r\n.."
1082:                							while(CRPeriod.Pos)
9D019324  0B4064FA   J 0x9D0193E8
9D019328  00000000   NOP
9D0193E8  8F828134   LW V0, -32460(GP)
9D0193EC  1440FFCF   BNE V0, ZERO, 0x9D01932C
9D0193F0  00000000   NOP
1083:                							{
1084:                								CRPeriod.Pos += 3;
9D01932C  8F828134   LW V0, -32460(GP)
9D019330  24420003   ADDIU V0, V0, 3
9D019334  AF828134   SW V0, -32460(GP)
1085:                								RAMStrPtr += TCPPutArray(MySocket, RAMStrPtr, CRPeriod.Pos-RAMStrPtr);
9D019338  8F908158   LW S0, -32424(GP)
9D01933C  93828025   LBU V0, -32731(GP)
9D019340  00402021   ADDU A0, V0, ZERO
9D019344  8F838158   LW V1, -32424(GP)
9D019348  8F828134   LW V0, -32460(GP)
9D01934C  3045FFFF   ANDI A1, V0, -1
9D019350  8F828158   LW V0, -32424(GP)
9D019354  3042FFFF   ANDI V0, V0, -1
9D019358  00A21023   SUBU V0, A1, V0
9D01935C  3042FFFF   ANDI V0, V0, -1
9D019360  00602821   ADDU A1, V1, ZERO
9D019364  00403021   ADDU A2, V0, ZERO
9D019368  0F4004E1   JAL TCPPutArray
9D01936C  00000000   NOP
9D019370  02021021   ADDU V0, S0, V0
9D019374  AF828158   SW V0, -32424(GP)
1086:                								if(RAMStrPtr == CRPeriod.Pos)
9D019378  8F838134   LW V1, -32460(GP)
9D01937C  8F828158   LW V0, -32424(GP)
9D019380  1462000D   BNE V1, V0, 0x9D0193B8
9D019384  00000000   NOP
1087:                								{
1088:                									if(!TCPPut(MySocket, '.'))
9D019388  93828025   LBU V0, -32731(GP)
9D01938C  00402021   ADDU A0, V0, ZERO
9D019390  2405002E   ADDIU A1, ZERO, 46
9D019394  0F40040C   JAL TCPPut
9D019398  00000000   NOP
9D01939C  1440000B   BNE V0, ZERO, 0x9D0193CC
9D0193A0  00000000   NOP
1089:                									{
1090:                										CRPeriod.Pos -= 3;
9D0193A4  8F828134   LW V0, -32460(GP)
9D0193A8  2442FFFD   ADDIU V0, V0, -3
9D0193AC  AF828134   SW V0, -32460(GP)
1091:                										break;
9D0193B0  0B4064FD   J 0x9D0193F4
9D0193B4  00000000   NOP
1092:                									}
1093:                								}
1094:                								else
1095:                								{
1096:                									CRPeriod.Pos -= 3;
9D0193B8  8F828134   LW V0, -32460(GP)
9D0193BC  2442FFFD   ADDIU V0, V0, -3
9D0193C0  AF828134   SW V0, -32460(GP)
1097:                									break;
9D0193C4  0B4064FD   J 0x9D0193F4
9D0193C8  00000000   NOP
1098:                								}
1099:                								CRPeriod.Pos = (BYTE*)strstrrampgm((char*)RAMStrPtr, (ROM char*)"\r\n.");
9D0193CC  8F828158   LW V0, -32424(GP)
9D0193D0  00402021   ADDU A0, V0, ZERO
9D0193D4  3C029D03   LUI V0, -25341
9D0193D8  24455B58   ADDIU A1, V0, 23384
9D0193DC  0F40D666   JAL strstr
9D0193E0  00000000   NOP
9D0193E4  AF828134   SW V0, -32460(GP)
1100:                							}
1101:                							
1102:                							// If we get down here, either all replacements have been made or there is no remaining space in the TCP output buffer
1103:                							RAMStrPtr = TCPPutString(MySocket, RAMStrPtr);
9D0193F4  93828025   LBU V0, -32731(GP)
9D0193F8  00401821   ADDU V1, V0, ZERO
9D0193FC  8F828158   LW V0, -32424(GP)
9D019400  00602021   ADDU A0, V1, ZERO
9D019404  00402821   ADDU A1, V0, ZERO
9D019408  0F4005FD   JAL TCPPutString
9D01940C  00000000   NOP
9D019410  AF828158   SW V0, -32424(GP)
1104:                							ROMStrPtr2 = TCPPutROMString(MySocket, ROMStrPtr2);
9D019414  93828025   LBU V0, -32731(GP)
9D019418  00401821   ADDU V1, V0, ZERO
9D01941C  8F828160   LW V0, -32416(GP)
9D019420  00602021   ADDU A0, V1, ZERO
9D019424  00402821   ADDU A1, V0, ZERO
9D019428  0F4005FD   JAL TCPPutString
9D01942C  00000000   NOP
9D019430  AF828160   SW V0, -32416(GP)
1105:                							TCPFlush(MySocket);
9D019434  93828025   LBU V0, -32731(GP)
9D019438  00402021   ADDU A0, V0, ZERO
9D01943C  0F400366   JAL TCPFlush
9D019440  00000000   NOP
1106:                						}
1107:                					}
1108:                					else
1109:                					{
1110:                						if(SMTPFlags.bits.ReadyToFinish)
9D01944C  93828148   LBU V0, -32440(GP)
9D019450  30420010   ANDI V0, V0, 16
9D019454  304200FF   ANDI V0, V0, 255
9D019458  10400011   BEQ V0, ZERO, 0x9D0194A0
9D01945C  00000000   NOP
1111:                						{
1112:                							if(*ROMStrPtr2)
9D019460  8F828160   LW V0, -32416(GP)
9D019464  90420000   LBU V0, 0(V0)
9D019468  1040000D   BEQ V0, ZERO, 0x9D0194A0
9D01946C  00000000   NOP
1113:                							{
1114:                								ROMStrPtr2 = TCPPutROMString(MySocket, ROMStrPtr2);
9D019470  93828025   LBU V0, -32731(GP)
9D019474  00401821   ADDU V1, V0, ZERO
9D019478  8F828160   LW V0, -32416(GP)
9D01947C  00602021   ADDU A0, V1, ZERO
9D019480  00402821   ADDU A1, V0, ZERO
9D019484  0F4005FD   JAL TCPPutString
9D019488  00000000   NOP
9D01948C  AF828160   SW V0, -32416(GP)
1115:                								TCPFlush(MySocket);
9D019490  93828025   LBU V0, -32731(GP)
9D019494  00402021   ADDU A0, V0, ZERO
9D019498  0F400366   JAL TCPFlush
9D01949C  00000000   NOP
1116:                							}
1117:                		
1118:                						}
1119:                					}
1120:                
1121:                					if(*ROMStrPtr2 == 0u)
9D0194A0  8F828160   LW V0, -32416(GP)
9D0194A4  90420000   LBU V0, 0(V0)
9D0194A8  14400004   BNE V0, ZERO, 0x9D0194BC
9D0194AC  00000000   NOP
1122:                					{
1123:                						SMTPState++;
9D0194B0  8F82813C   LW V0, -32452(GP)
9D0194B4  24420001   ADDIU V0, V0, 1
9D0194B8  AF82813C   SW V0, -32452(GP)
1124:                					}
1125:                					break;
9D0194BC  0B406550   J 0x9D019540
9D0194C0  00000000   NOP
1126:                		
1127:                				case SMTP_QUIT_INIT:
1128:                					SMTPState++;
9D0194C4  8F82813C   LW V0, -32452(GP)
9D0194C8  24420001   ADDIU V0, V0, 1
9D0194CC  AF82813C   SW V0, -32452(GP)
1129:                					ROMStrPtr = (ROM BYTE*)"QUIT\r\n";
9D0194D0  3C029D03   LUI V0, -25341
9D0194D4  24425B5C   ADDIU V0, V0, 23388
9D0194D8  AF828154   SW V0, -32428(GP)
1130:                					// No break here
1131:                
1132:                				case SMTP_QUIT:
1133:                					if(*ROMStrPtr)
9D0194DC  8F828154   LW V0, -32428(GP)
9D0194E0  90420000   LBU V0, 0(V0)
9D0194E4  1040000D   BEQ V0, ZERO, 0x9D01951C
9D0194E8  00000000   NOP
1134:                					{
1135:                						ROMStrPtr = TCPPutROMString(MySocket, ROMStrPtr);
9D0194EC  93828025   LBU V0, -32731(GP)
9D0194F0  00401821   ADDU V1, V0, ZERO
9D0194F4  8F828154   LW V0, -32428(GP)
9D0194F8  00602021   ADDU A0, V1, ZERO
9D0194FC  00402821   ADDU A1, V0, ZERO
9D019500  0F4005FD   JAL TCPPutString
9D019504  00000000   NOP
9D019508  AF828154   SW V0, -32428(GP)
1136:                						TCPFlush(MySocket);
9D01950C  93828025   LBU V0, -32731(GP)
9D019510  00402021   ADDU A0, V0, ZERO
9D019514  0F400366   JAL TCPFlush
9D019518  00000000   NOP
1137:                					}
1138:                
1139:                					if(*ROMStrPtr == 0u)
9D01951C  8F828154   LW V0, -32428(GP)
9D019520  90420000   LBU V0, 0(V0)
9D019524  14400003   BNE V0, ZERO, 0x9D019534
9D019528  00000000   NOP
1140:                					{
1141:                						TransportState = TRANSPORT_CLOSE;
9D01952C  24020005   ADDIU V0, ZERO, 5
9D019530  AF828138   SW V0, -32456(GP)
1142:                					}
1143:                					break;
9D019534  0B406550   J 0x9D019540
9D019538  00000000   NOP
1144:                				
1145:                				// Default case needed to supress compiler diagnostics
1146:                				default:
1147:                					break;
9D01953C  00000000   NOP
1148:                			}
1149:                			break;
9D019540  0B40656F   J 0x9D0195BC
9D019544  00000000   NOP
1150:                
1151:                		case TRANSPORT_CLOSE:
1152:                			// Close the socket so it can be used by other modules
1153:                			TCPDisconnect(MySocket);
9D019548  93828025   LBU V0, -32731(GP)
9D01954C  00402021   ADDU A0, V0, ZERO
9D019550  0F400273   JAL TCPDisconnect
9D019554  00000000   NOP
1154:                			MySocket = INVALID_SOCKET;
9D019558  2402FFFE   ADDIU V0, ZERO, -2
9D01955C  A3828025   SB V0, -32731(GP)
1155:                
1156:                			// Go back to doing nothing
1157:                			TransportState = TRANSPORT_HOME;
9D019560  AF808138   SW ZERO, -32456(GP)
1158:                			break;
9D019564  00000000   NOP
9D019568  0B40656F   J 0x9D0195BC
9D01956C  00000000   NOP
1159:                	}
1160:                }
9D0195BC  03C0E821   ADDU SP, S8, ZERO
9D0195C0  8FBF0024   LW RA, 36(SP)
9D0195C4  8FBE0020   LW S8, 32(SP)
9D0195C8  8FB0001C   LW S0, 28(SP)
9D0195CC  27BD0028   ADDIU SP, SP, 40
9D0195D0  03E00008   JR RA
9D0195D4  00000000   NOP
1161:                
1162:                /*****************************************************************************
1163:                  Function:
1164:                	void SMTPSendMail(void)
1165:                
1166:                  Summary:
1167:                	Initializes the message sending process.
1168:                
1169:                  Description:
1170:                	This function starts the state machine that performs the actual
1171:                	transmission of the message.  Call this function after all the fields
1172:                	in SMTPClient have been set.
1173:                
1174:                  Precondition:
1175:                	SMTPBeginUsage returned TRUE on a previous call.
1176:                
1177:                  Parameters:
1178:                	None
1179:                
1180:                  Returns:
1181:                	None
1182:                  ***************************************************************************/
1183:                void SMTPSendMail(void)
1184:                {
9D0195D8  27BDFFF8   ADDIU SP, SP, -8
9D0195DC  AFBE0004   SW S8, 4(SP)
9D0195E0  03A0F021   ADDU S8, SP, ZERO
1185:                	SMTPFlags.bits.ReadyToStart = TRUE;
9D0195E4  93828148   LBU V0, -32440(GP)
9D0195E8  24030001   ADDIU V1, ZERO, 1
9D0195EC  7C6218C4   INS V0, V1, 3, 1
9D0195F0  A3828148   SB V0, -32440(GP)
1186:                }
9D0195F4  03C0E821   ADDU SP, S8, ZERO
9D0195F8  8FBE0004   LW S8, 4(SP)
9D0195FC  27BD0008   ADDIU SP, SP, 8
9D019600  03E00008   JR RA
9D019604  00000000   NOP
1187:                
1188:                /*****************************************************************************
1189:                  Function:
1190:                	BOOL SMTPIsBusy(void)
1191:                
1192:                  Summary:
1193:                	Determines if the SMTP client is busy.
1194:                
1195:                  Description:
1196:                	Call this function to determine if the SMTP client is busy performing
1197:                	background tasks.  This function should be called after any call to 
1198:                	SMTPSendMail, SMTPPutDone to determine if the stack has finished
1199:                	performing its internal tasks.  It should also be called prior to any
1200:                	call to SMTPIsPutReady to verify that the SMTP client has not
1201:                	prematurely disconnected.  When this function returns FALSE, the next
1202:                	call should be to SMTPEndUsage to release the module and obtain the
1203:                	status code for the operation.
1204:                
1205:                  Precondition:
1206:                	SMTPBeginUsage returned TRUE on a previous call.
1207:                
1208:                  Parameters:
1209:                	None
1210:                
1211:                  Return Values:
1212:                	TRUE - The SMTP Client is busy with internal tasks or sending an 
1213:                		on-the-fly message.
1214:                	FALSE - The SMTP Client is terminated and is ready to be released.
1215:                  ***************************************************************************/
1216:                BOOL SMTPIsBusy(void)
1217:                {
9D019608  27BDFFF8   ADDIU SP, SP, -8
9D01960C  AFBE0004   SW S8, 4(SP)
9D019610  03A0F021   ADDU S8, SP, ZERO
1218:                	return TransportState != TRANSPORT_HOME;
9D019614  8F828138   LW V0, -32456(GP)
9D019618  0002102B   SLTU V0, ZERO, V0
1219:                }
9D01961C  03C0E821   ADDU SP, S8, ZERO
9D019620  8FBE0004   LW S8, 4(SP)
9D019624  27BD0008   ADDIU SP, SP, 8
9D019628  03E00008   JR RA
9D01962C  00000000   NOP
1220:                
1221:                /*****************************************************************************
1222:                  Function:
1223:                	WORD SMTPIsPutReady(void)
1224:                
1225:                  Summary:
1226:                	Determines how much data can be written to the SMTP client.
1227:                
1228:                  Description:
1229:                	Use this function to determine how much data can be written to the SMTP 
1230:                	client when generating an on-the-fly message.
1231:                
1232:                  Precondition:
1233:                	SMTPBeginUsage returned TRUE on a previous call, and an on-the-fly 
1234:                	message is being generated.  This requires that SMTPSendMail was called
1235:                	with SMTPClient.Body set to NULL.
1236:                
1237:                  Parameters:
1238:                	None
1239:                
1240:                  Returns:
1241:                	The number of free bytes the SMTP TX FIFO.
1242:                
1243:                  Remarks:
1244:                	This function should only be called externally when the SMTP client is
1245:                	generating an on-the-fly message.  (That is, SMTPSendMail was called
1246:                	with SMTPClient.Body set to NULL.)
1247:                  ***************************************************************************/
1248:                WORD SMTPIsPutReady(void)
1249:                {
9D019630  27BDFFE8   ADDIU SP, SP, -24
9D019634  AFBF0014   SW RA, 20(SP)
9D019638  AFBE0010   SW S8, 16(SP)
9D01963C  03A0F021   ADDU S8, SP, ZERO
1250:                	if(SMTPState != SMTP_DATA_BODY)
9D019640  8F83813C   LW V1, -32452(GP)
9D019644  2402001B   ADDIU V0, ZERO, 27
9D019648  10620004   BEQ V1, V0, 0x9D01965C
9D01964C  00000000   NOP
1251:                		return 0;
9D019650  00001021   ADDU V0, ZERO, ZERO
9D019654  0B40659B   J 0x9D01966C
9D019658  00000000   NOP
1252:                
1253:                	return TCPIsPutReady(MySocket);	
9D01965C  93828025   LBU V0, -32731(GP)
9D019660  00402021   ADDU A0, V0, ZERO
9D019664  0F40038E   JAL TCPIsPutReady
9D019668  00000000   NOP
1254:                }
9D01966C  03C0E821   ADDU SP, S8, ZERO
9D019670  8FBF0014   LW RA, 20(SP)
9D019674  8FBE0010   LW S8, 16(SP)
9D019678  27BD0018   ADDIU SP, SP, 24
9D01967C  03E00008   JR RA
9D019680  00000000   NOP
1255:                
1256:                /*****************************************************************************
1257:                  Function:
1258:                	BOOL SMTPPut(BYTE c)
1259:                
1260:                  Description:
1261:                	Writes a single byte to the SMTP client.
1262:                
1263:                  Precondition:
1264:                	SMTPBeginUsage returned TRUE on a previous call.
1265:                
1266:                  Parameters:
1267:                	c - The byte to be written
1268:                
1269:                  Return Values:
1270:                	TRUE - The byte was successfully written
1271:                	FALSE - The byte was not written, most likely because the buffer was full
1272:                
1273:                  Remarks:
1274:                	This function should only be called externally when the SMTP client is
1275:                	generating an on-the-fly message.  (That is, SMTPSendMail was called
1276:                	with SMTPClient.Body set to NULL.)
1277:                  ***************************************************************************/
1278:                BOOL SMTPPut(BYTE c)
1279:                {
9D019684  27BDFFE8   ADDIU SP, SP, -24
9D019688  AFBF0014   SW RA, 20(SP)
9D01968C  AFBE0010   SW S8, 16(SP)
9D019690  03A0F021   ADDU S8, SP, ZERO
9D019694  00801021   ADDU V0, A0, ZERO
9D019698  A3C20018   SB V0, 24(S8)
1280:                	if(CRPeriod.State == CR_PERIOD_NEED_INSERTION)
9D01969C  8F838134   LW V1, -32460(GP)
9D0196A0  24020003   ADDIU V0, ZERO, 3
9D0196A4  1462000E   BNE V1, V0, 0x9D0196E0
9D0196A8  00000000   NOP
1281:                	{
1282:                		if(TCPPut(MySocket, '.'))
9D0196AC  93828025   LBU V0, -32731(GP)
9D0196B0  00402021   ADDU A0, V0, ZERO
9D0196B4  2405002E   ADDIU A1, ZERO, 46
9D0196B8  0F40040C   JAL TCPPut
9D0196BC  00000000   NOP
9D0196C0  10400004   BEQ V0, ZERO, 0x9D0196D4
9D0196C4  00000000   NOP
1283:                			CRPeriod.State = CR_PERIOD_SEEK_CR;
9D0196C8  AF808134   SW ZERO, -32460(GP)
9D0196CC  0B4065B8   J 0x9D0196E0
9D0196D0  00000000   NOP
1284:                		else
1285:                			return FALSE;
9D0196D4  00001021   ADDU V0, ZERO, ZERO
9D0196D8  0B406605   J 0x9D019814
9D0196DC  00000000   NOP
1286:                	}
1287:                
1288:                	switch(CRPeriod.State)
9D0196E0  8F828134   LW V0, -32460(GP)
9D0196E4  24030001   ADDIU V1, ZERO, 1
9D0196E8  10430012   BEQ V0, V1, 0x9D019734
9D0196EC  00000000   NOP
9D0196F0  2C430001   SLTIU V1, V0, 1
9D0196F4  14600006   BNE V1, ZERO, 0x9D019710
9D0196F8  00000000   NOP
9D0196FC  24030002   ADDIU V1, ZERO, 2
9D019700  1043001E   BEQ V0, V1, 0x9D01977C
9D019704  00000000   NOP
1289:                	{
1290:                		case CR_PERIOD_SEEK_CR:
1291:                			if(c == '\r')
9D019710  93C30018   LBU V1, 24(S8)
9D019714  2402000D   ADDIU V0, ZERO, 13
9D019718  1462002D   BNE V1, V0, 0x9D0197D0
9D01971C  00000000   NOP
1292:                				CRPeriod.State++;
9D019720  8F828134   LW V0, -32460(GP)
9D019724  24420001   ADDIU V0, V0, 1
9D019728  AF828134   SW V0, -32460(GP)
1293:                			break;
9D01972C  0B4065F8   J 0x9D0197E0
9D019730  00000000   NOP
9D0197D0  00000000   NOP
9D0197D4  0B4065F8   J 0x9D0197E0
9D0197D8  00000000   NOP
1294:                
1295:                		case CR_PERIOD_SEEK_LF:
1296:                			if(c == '\n')
9D019734  93C30018   LBU V1, 24(S8)
9D019738  2402000A   ADDIU V0, ZERO, 10
9D01973C  14620006   BNE V1, V0, 0x9D019758
9D019740  00000000   NOP
1297:                				CRPeriod.State++;
9D019744  8F828134   LW V0, -32460(GP)
9D019748  24420001   ADDIU V0, V0, 1
9D01974C  AF828134   SW V0, -32460(GP)
1298:                			else if(c != '\r')
9D019758  93C30018   LBU V1, 24(S8)
9D01975C  2402000D   ADDIU V0, ZERO, 13
9D019760  1062001E   BEQ V1, V0, 0x9D0197DC
9D019764  00000000   NOP
1299:                				CRPeriod.State--;
9D019768  8F828134   LW V0, -32460(GP)
9D01976C  2442FFFF   ADDIU V0, V0, -1
9D019770  AF828134   SW V0, -32460(GP)
1300:                			break;
9D019750  0B4065F8   J 0x9D0197E0
9D019754  00000000   NOP
9D019774  0B4065F8   J 0x9D0197E0
9D019778  00000000   NOP
9D0197DC  00000000   NOP
1301:                
1302:                		case CR_PERIOD_SEEK_PERIOD:
1303:                			if(c == '.')
9D01977C  93C30018   LBU V1, 24(S8)
9D019780  2402002E   ADDIU V0, ZERO, 46
9D019784  14620006   BNE V1, V0, 0x9D0197A0
9D019788  00000000   NOP
1304:                				CRPeriod.State++;	// CR_PERIOD_NEED_INSERTION
9D01978C  8F828134   LW V0, -32460(GP)
9D019790  24420001   ADDIU V0, V0, 1
9D019794  AF828134   SW V0, -32460(GP)
1305:                			else if(c == '\r')
9D0197A0  93C30018   LBU V1, 24(S8)
9D0197A4  2402000D   ADDIU V0, ZERO, 13
9D0197A8  14620006   BNE V1, V0, 0x9D0197C4
9D0197AC  00000000   NOP
1306:                				CRPeriod.State--;
9D0197B0  8F828134   LW V0, -32460(GP)
9D0197B4  2442FFFF   ADDIU V0, V0, -1
9D0197B8  AF828134   SW V0, -32460(GP)
1307:                			else
1308:                				CRPeriod.State = CR_PERIOD_SEEK_CR;
9D0197C4  AF808134   SW ZERO, -32460(GP)
1309:                			break;
9D019798  0B4065F8   J 0x9D0197E0
9D01979C  00000000   NOP
9D0197BC  0B4065F8   J 0x9D0197E0
9D0197C0  00000000   NOP
9D0197C8  0B4065F8   J 0x9D0197E0
9D0197CC  00000000   NOP
1310:                		
1311:                		// Default case needed to supress compiler diagnostics 
1312:                		// (CR_PERIOD_NEED_INSERTION state already handled above)
1313:                		default:
1314:                			break;
9D019708  0B4065F8   J 0x9D0197E0
9D01970C  00000000   NOP
1315:                	}
1316:                
1317:                	if(!TCPPut(MySocket, c))
9D0197E0  93828025   LBU V0, -32731(GP)
9D0197E4  00401821   ADDU V1, V0, ZERO
9D0197E8  93C20018   LBU V0, 24(S8)
9D0197EC  00602021   ADDU A0, V1, ZERO
9D0197F0  00402821   ADDU A1, V0, ZERO
9D0197F4  0F40040C   JAL TCPPut
9D0197F8  00000000   NOP
9D0197FC  14400004   BNE V0, ZERO, 0x9D019810
9D019800  00000000   NOP
1318:                		return FALSE;
9D019804  00001021   ADDU V0, ZERO, ZERO
9D019808  0B406605   J 0x9D019814
9D01980C  00000000   NOP
1319:                
1320:                	return TRUE;
9D019810  24020001   ADDIU V0, ZERO, 1
1321:                }
9D019814  03C0E821   ADDU SP, S8, ZERO
9D019818  8FBF0014   LW RA, 20(SP)
9D01981C  8FBE0010   LW S8, 16(SP)
9D019820  27BD0018   ADDIU SP, SP, 24
9D019824  03E00008   JR RA
9D019828  00000000   NOP
1322:                
1323:                /*****************************************************************************
1324:                  Function:
1325:                	WORD SMTPPutArray(BYTE* Data, WORD Len)
1326:                
1327:                  Description:
1328:                	Writes a series of bytes to the SMTP client.
1329:                
1330:                  Precondition:
1331:                	SMTPBeginUsage returned TRUE on a previous call.
1332:                
1333:                  Parameters:
1334:                	Data - The data to be written
1335:                	Len - How many bytes should be written
1336:                
1337:                  Returns:
1338:                	The number of bytes written.  If less than Len, then the TX FIFO became
1339:                	full before all bytes could be written.
1340:                	
1341:                  Remarks:
1342:                	This function should only be called externally when the SMTP client is
1343:                	generating an on-the-fly message.  (That is, SMTPSendMail was called
1344:                	with SMTPClient.Body set to NULL.)
1345:                	
1346:                  Internal:
1347:                	SMTPPut must be used instead of TCPPutArray because "\r\n." must be
1348:                	transparently replaced by "\r\n..".
1349:                  ***************************************************************************/
1350:                WORD SMTPPutArray(BYTE* Data, WORD Len)
1351:                {
9D01982C  27BDFFE0   ADDIU SP, SP, -32
9D019830  AFBF001C   SW RA, 28(SP)
9D019834  AFBE0018   SW S8, 24(SP)
9D019838  03A0F021   ADDU S8, SP, ZERO
9D01983C  AFC40020   SW A0, 32(S8)
9D019840  00A01021   ADDU V0, A1, ZERO
9D019844  A7C20024   SH V0, 36(S8)
1352:                	WORD result = 0;
9D019848  A7C00010   SH ZERO, 16(S8)
1353:                
1354:                	while(Len--)
9D01984C  0B406629   J 0x9D0198A4
9D019850  00000000   NOP
9D0198A4  97C20024   LHU V0, 36(S8)
9D0198A8  0002102B   SLTU V0, ZERO, V0
9D0198AC  304200FF   ANDI V0, V0, 255
9D0198B0  97C30024   LHU V1, 36(S8)
9D0198B4  2463FFFF   ADDIU V1, V1, -1
9D0198B8  A7C30024   SH V1, 36(S8)
9D0198BC  1440FFE5   BNE V0, ZERO, 0x9D019854
9D0198C0  00000000   NOP
1355:                	{
1356:                		if(SMTPPut(*Data++))
9D019854  8FC20020   LW V0, 32(S8)
9D019858  90420000   LBU V0, 0(V0)
9D01985C  8FC30020   LW V1, 32(S8)
9D019860  24630001   ADDIU V1, V1, 1
9D019864  AFC30020   SW V1, 32(S8)
9D019868  00402021   ADDU A0, V0, ZERO
9D01986C  0F4065A1   JAL SMTPPut
9D019870  00000000   NOP
9D019874  10400006   BEQ V0, ZERO, 0x9D019890
9D019878  00000000   NOP
1357:                		{
1358:                			result++;
9D01987C  97C20010   LHU V0, 16(S8)
9D019880  24420001   ADDIU V0, V0, 1
9D019884  A7C20010   SH V0, 16(S8)
9D019888  0B406629   J 0x9D0198A4
9D01988C  00000000   NOP
1359:                		}
1360:                		else
1361:                		{
1362:                			Data--;
9D019890  8FC20020   LW V0, 32(S8)
9D019894  2442FFFF   ADDIU V0, V0, -1
9D019898  AFC20020   SW V0, 32(S8)
1363:                			break;
9D01989C  0B406631   J 0x9D0198C4
9D0198A0  00000000   NOP
1364:                		}
1365:                	}
1366:                
1367:                	return result;
9D0198C4  97C20010   LHU V0, 16(S8)
1368:                }
9D0198C8  03C0E821   ADDU SP, S8, ZERO
9D0198CC  8FBF001C   LW RA, 28(SP)
9D0198D0  8FBE0018   LW S8, 24(SP)
9D0198D4  27BD0020   ADDIU SP, SP, 32
9D0198D8  03E00008   JR RA
9D0198DC  00000000   NOP
1369:                
1370:                /*****************************************************************************
1371:                  Function:
1372:                	WORD SMTPPutROMArray(ROM BYTE* Data, WORD Len)
1373:                
1374:                  Description:
1375:                	Writes a series of bytes from ROM to the SMTP client.
1376:                
1377:                  Precondition:
1378:                	SMTPBeginUsage returned TRUE on a previous call.
1379:                
1380:                  Parameters:
1381:                	Data - The data to be written
1382:                	Len - How many bytes should be written
1383:                
1384:                  Returns:
1385:                	The number of bytes written.  If less than Len, then the TX FIFO became
1386:                	full before all bytes could be written.
1387:                	
1388:                  Remarks:
1389:                	This function should only be called externally when the SMTP client is
1390:                	generating an on-the-fly message.  (That is, SMTPSendMail was called
1391:                	with SMTPClient.Body set to NULL.)
1392:                	
1393:                  	This function is aliased to SMTPPutArray on non-PIC18 platforms.
1394:                	
1395:                  Internal:
1396:                	SMTPPut must be used instead of TCPPutArray because "\r\n." must be
1397:                	transparently replaced by "\r\n..".
1398:                  ***************************************************************************/
1399:                #if defined(__18CXX)
1400:                WORD SMTPPutROMArray(ROM BYTE* Data, WORD Len)
1401:                {
1402:                	WORD result = 0;
1403:                
1404:                	while(Len--)
1405:                	{
1406:                		if(SMTPPut(*Data++))
1407:                		{
1408:                			result++;
1409:                		}
1410:                		else
1411:                		{
1412:                			Data--;
1413:                			break;
1414:                		}
1415:                	}
1416:                
1417:                	return result;
1418:                }
1419:                #endif
1420:                
1421:                /*****************************************************************************
1422:                  Function:
1423:                	WORD SMTPPutString(BYTE* Data)
1424:                
1425:                  Description:
1426:                	Writes a string to the SMTP client.
1427:                
1428:                  Precondition:
1429:                	SMTPBeginUsage returned TRUE on a previous call.
1430:                
1431:                  Parameters:
1432:                	Data - The data to be written
1433:                
1434:                  Returns:
1435:                	The number of bytes written.  If less than the length of Data, then the 
1436:                	TX FIFO became full before all bytes could be written.
1437:                	
1438:                  Remarks:
1439:                	This function should only be called externally when the SMTP client is
1440:                	generating an on-the-fly message.  (That is, SMTPSendMail was called
1441:                	with SMTPClient.Body set to NULL.)
1442:                	
1443:                  Internal:
1444:                	SMTPPut must be used instead of TCPPutString because "\r\n." must be
1445:                	transparently replaced by "\r\n..".
1446:                  ***************************************************************************/
1447:                WORD SMTPPutString(BYTE* Data)
1448:                {
9D0198E0  27BDFFE0   ADDIU SP, SP, -32
9D0198E4  AFBF001C   SW RA, 28(SP)
9D0198E8  AFBE0018   SW S8, 24(SP)
9D0198EC  03A0F021   ADDU S8, SP, ZERO
9D0198F0  AFC40020   SW A0, 32(S8)
1449:                	WORD result = 0;
9D0198F4  A7C00010   SH ZERO, 16(S8)
1450:                
1451:                	while(*Data)
9D0198F8  0B406654   J 0x9D019950
9D0198FC  00000000   NOP
9D019950  8FC20020   LW V0, 32(S8)
9D019954  90420000   LBU V0, 0(V0)
9D019958  1440FFE9   BNE V0, ZERO, 0x9D019900
9D01995C  00000000   NOP
1452:                	{
1453:                		if(SMTPPut(*Data++))
9D019900  8FC20020   LW V0, 32(S8)
9D019904  90420000   LBU V0, 0(V0)
9D019908  8FC30020   LW V1, 32(S8)
9D01990C  24630001   ADDIU V1, V1, 1
9D019910  AFC30020   SW V1, 32(S8)
9D019914  00402021   ADDU A0, V0, ZERO
9D019918  0F4065A1   JAL SMTPPut
9D01991C  00000000   NOP
9D019920  10400006   BEQ V0, ZERO, 0x9D01993C
9D019924  00000000   NOP
1454:                		{
1455:                			result++;
9D019928  97C20010   LHU V0, 16(S8)
9D01992C  24420001   ADDIU V0, V0, 1
9D019930  A7C20010   SH V0, 16(S8)
9D019934  0B406654   J 0x9D019950
9D019938  00000000   NOP
1456:                		}
1457:                		else
1458:                		{
1459:                			Data--;
9D01993C  8FC20020   LW V0, 32(S8)
9D019940  2442FFFF   ADDIU V0, V0, -1
9D019944  AFC20020   SW V0, 32(S8)
1460:                			break;
9D019948  0B406658   J 0x9D019960
9D01994C  00000000   NOP
1461:                		}
1462:                	}
1463:                
1464:                	return result;
9D019960  97C20010   LHU V0, 16(S8)
1465:                }
9D019964  03C0E821   ADDU SP, S8, ZERO
9D019968  8FBF001C   LW RA, 28(SP)
9D01996C  8FBE0018   LW S8, 24(SP)
9D019970  27BD0020   ADDIU SP, SP, 32
9D019974  03E00008   JR RA
9D019978  00000000   NOP
1466:                
1467:                /*****************************************************************************
1468:                  Function:
1469:                	WORD SMTPPutROMString(ROM BYTE* Data)
1470:                
1471:                  Description:
1472:                	Writes a string from ROM to the SMTP client.
1473:                
1474:                  Precondition:
1475:                	SMTPBeginUsage returned TRUE on a previous call.
1476:                
1477:                  Parameters:
1478:                	Data - The data to be written
1479:                
1480:                  Returns:
1481:                	The number of bytes written.  If less than the length of Data, then the 
1482:                	TX FIFO became full before all bytes could be written.
1483:                	
1484:                  Remarks:
1485:                	This function should only be called externally when the SMTP client is
1486:                	generating an on-the-fly message.  (That is, SMTPSendMail was called
1487:                	with SMTPClient.Body set to NULL.)
1488:                	
1489:                  	This function is aliased to SMTPPutString on non-PIC18 platforms.
1490:                	
1491:                  Internal:
1492:                	SMTPPut must be used instead of TCPPutString because "\r\n." must be
1493:                	transparently replaced by "\r\n..".
1494:                  ***************************************************************************/
1495:                #if defined(__18CXX)
1496:                WORD SMTPPutROMString(ROM BYTE* Data)
1497:                {
1498:                	WORD result = 0;
1499:                
1500:                	while(*Data)
1501:                	{
1502:                		if(SMTPPut(*Data++))
1503:                		{
1504:                			result++;
1505:                		}
1506:                		else
1507:                		{
1508:                			Data--;
1509:                			break;
1510:                		}
1511:                	}
1512:                
1513:                	return result;
1514:                }
1515:                #endif
1516:                
1517:                /*****************************************************************************
1518:                  Function:
1519:                	void SMTPFlush(void)
1520:                
1521:                  Description:
1522:                	Flushes the SMTP socket and forces all data to be sent.
1523:                
1524:                  Precondition:
1525:                	SMTPBeginUsage returned TRUE on a previous call.
1526:                
1527:                  Parameters:
1528:                	None
1529:                
1530:                  Returns:
1531:                	None
1532:                	
1533:                  Remarks:
1534:                	This function should only be called externally when the SMTP client is
1535:                	generating an on-the-fly message.  (That is, SMTPSendMail was called
1536:                	with SMTPClient.Body set to NULL.)
1537:                  ***************************************************************************/
1538:                void SMTPFlush(void)
1539:                {
9D01997C  27BDFFE8   ADDIU SP, SP, -24
9D019980  AFBF0014   SW RA, 20(SP)
9D019984  AFBE0010   SW S8, 16(SP)
9D019988  03A0F021   ADDU S8, SP, ZERO
1540:                	TCPFlush(MySocket);
9D01998C  93828025   LBU V0, -32731(GP)
9D019990  00402021   ADDU A0, V0, ZERO
9D019994  0F400366   JAL TCPFlush
9D019998  00000000   NOP
1541:                }
9D01999C  03C0E821   ADDU SP, S8, ZERO
9D0199A0  8FBF0014   LW RA, 20(SP)
9D0199A4  8FBE0010   LW S8, 16(SP)
9D0199A8  27BD0018   ADDIU SP, SP, 24
9D0199AC  03E00008   JR RA
9D0199B0  00000000   NOP
1542:                
1543:                /*****************************************************************************
1544:                  Function:
1545:                	void SMTPPutDone(void)
1546:                
1547:                  Description:
1548:                	Indicates that the on-the-fly message is complete.
1549:                
1550:                  Precondition:
1551:                	SMTPBeginUsage returned TRUE on a previous call, and the SMTP client is
1552:                	generated an on-the-fly message.  (That is, SMTPSendMail was called
1553:                	with SMTPClient.Body set to NULL.)
1554:                
1555:                  Parameters:
1556:                	None
1557:                
1558:                  Returns:
1559:                	None
1560:                  ***************************************************************************/
1561:                void SMTPPutDone(void)
1562:                {
9D0199B4  27BDFFF8   ADDIU SP, SP, -8
9D0199B8  AFBE0004   SW S8, 4(SP)
9D0199BC  03A0F021   ADDU S8, SP, ZERO
1563:                	SMTPFlags.bits.ReadyToFinish = TRUE;
9D0199C0  93828148   LBU V0, -32440(GP)
9D0199C4  24030001   ADDIU V1, ZERO, 1
9D0199C8  7C622104   INS V0, V1, 4, 1
9D0199CC  A3828148   SB V0, -32440(GP)
1564:                }
9D0199D0  03C0E821   ADDU SP, S8, ZERO
9D0199D4  8FBE0004   LW S8, 4(SP)
9D0199D8  27BD0008   ADDIU SP, SP, 8
9D0199DC  03E00008   JR RA
9D0199E0  00000000   NOP
1565:                
1566:                /*****************************************************************************
1567:                  Function:
1568:                	static BYTE *FindEmailAddress(BYTE *str, WORD *wLen)
1569:                
1570:                  Summary:
1571:                	Searches a string for an e-mail address.
1572:                
1573:                  Description:
1574:                	This function locates an e-mail address in a string.  It is used 
1575:                	internally by the SMTP client to parse out the actual address from
1576:                	the From and To strings so that the MAIL FROM and RCPT TO commands
1577:                	can be sent to the SMTP server.
1578:                
1579:                  Precondition:
1580:                	SMTPBeginUsage returned TRUE on a previous call.
1581:                
1582:                  Parameters:
1583:                	str - The string in which to search for an e-mail address
1584:                	wLen - the length of str
1585:                
1586:                  Returns:
1587:                	A pointer to the e-mail address
1588:                  ***************************************************************************/
1589:                static BYTE *FindEmailAddress(BYTE *str, WORD *wLen)
1590:                {
9D0199E4  27BDFFE8   ADDIU SP, SP, -24
9D0199E8  AFBE0014   SW S8, 20(SP)
9D0199EC  03A0F021   ADDU S8, SP, ZERO
9D0199F0  AFC40018   SW A0, 24(S8)
9D0199F4  AFC5001C   SW A1, 28(S8)
1591:                	BYTE *lpStart;
1592:                	BYTE c;
1593:                	union
1594:                	{
1595:                		BYTE Val;
1596:                		struct
1597:                		{
1598:                			BYTE FoundOpenBracket	: 1;
1599:                			BYTE FoundAt			: 1;
1600:                		} bits;
1601:                	} ParseStates;
1602:                
1603:                	lpStart = str;
9D0199F8  8FC20018   LW V0, 24(S8)
9D0199FC  AFC20000   SW V0, 0(S8)
1604:                	*wLen = 0x0000;
9D019A00  8FC2001C   LW V0, 28(S8)
9D019A04  A4400000   SH ZERO, 0(V0)
1605:                	ParseStates.Val = 0x00;
9D019A08  A3C00008   SB ZERO, 8(S8)
1606:                
1607:                	while((c = *str++))
9D019A0C  0B4066CA   J 0x9D019B28
9D019A10  00000000   NOP
9D019B28  8FC20018   LW V0, 24(S8)
9D019B2C  90420000   LBU V0, 0(V0)
9D019B30  A3C20004   SB V0, 4(S8)
9D019B34  93C20004   LBU V0, 4(S8)
9D019B38  0002102B   SLTU V0, ZERO, V0
9D019B3C  304200FF   ANDI V0, V0, 255
9D019B40  8FC30018   LW V1, 24(S8)
9D019B44  24630001   ADDIU V1, V1, 1
9D019B48  AFC30018   SW V1, 24(S8)
9D019B4C  1440FFB1   BNE V0, ZERO, 0x9D019A14
9D019B50  00000000   NOP
9D019B54  0B4066DB   J 0x9D019B6C
9D019B58  00000000   NOP
1608:                	{	
1609:                		if(c == '<')
9D019A14  93C30004   LBU V1, 4(S8)
9D019A18  2402003C   ADDIU V0, ZERO, 60
9D019A1C  1462000C   BNE V1, V0, 0x9D019A50
9D019A20  00000000   NOP
1610:                		{
1611:                			ParseStates.bits.FoundOpenBracket = 1;
9D019A24  93C20008   LBU V0, 8(S8)
9D019A28  24030001   ADDIU V1, ZERO, 1
9D019A2C  7C620004   INS V0, V1, 0, 1
9D019A30  A3C20008   SB V0, 8(S8)
1612:                			lpStart = str;
9D019A34  8FC20018   LW V0, 24(S8)
9D019A38  AFC20000   SW V0, 0(S8)
1613:                			*wLen = -1;
9D019A3C  8FC2001C   LW V0, 28(S8)
9D019A40  2403FFFF   ADDIU V1, ZERO, -1
9D019A44  A4430000   SH V1, 0(V0)
9D019A48  0B40669C   J 0x9D019A70
9D019A4C  00000000   NOP
1614:                		}
1615:                		else if(c == '@')
9D019A50  93C30004   LBU V1, 4(S8)
9D019A54  24020040   ADDIU V0, ZERO, 64
9D019A58  14620005   BNE V1, V0, 0x9D019A70
9D019A5C  00000000   NOP
1616:                			ParseStates.bits.FoundAt = 1;
9D019A60  93C20008   LBU V0, 8(S8)
9D019A64  24030001   ADDIU V1, ZERO, 1
9D019A68  7C620844   INS V0, V1, 1, 1
9D019A6C  A3C20008   SB V0, 8(S8)
1617:                
1618:                
1619:                		if(	!ParseStates.bits.FoundOpenBracket &&
9D019A70  93C20008   LBU V0, 8(S8)
9D019A74  30420001   ANDI V0, V0, 1
9D019A78  304200FF   ANDI V0, V0, 255
9D019A7C  14400012   BNE V0, ZERO, 0x9D019AC8
9D019A80  00000000   NOP
9D019A90  1440000D   BNE V0, ZERO, 0x9D019AC8
9D019A94  00000000   NOP
1620:                			!ParseStates.bits.FoundAt &&
9D019A84  93C20008   LBU V0, 8(S8)
9D019A88  30420002   ANDI V0, V0, 2
9D019A8C  304200FF   ANDI V0, V0, 255
9D019A98  93C30004   LBU V1, 4(S8)
9D019A9C  24020020   ADDIU V0, ZERO, 32
9D019AA0  10620005   BEQ V1, V0, 0x9D019AB8
9D019AA4  00000000   NOP
1621:                			(c == ' ' || c == ','))
9D019AA8  93C30004   LBU V1, 4(S8)
9D019AAC  2402002C   ADDIU V0, ZERO, 44
9D019AB0  14620005   BNE V1, V0, 0x9D019AC8
9D019AB4  00000000   NOP
1622:                		{
1623:                			lpStart = str;
9D019AB8  8FC20018   LW V0, 24(S8)
9D019ABC  AFC20000   SW V0, 0(S8)
1624:                			continue;
9D019AC0  0B4066CA   J 0x9D019B28
9D019AC4  00000000   NOP
1625:                		}
1626:                		else if(c == ',')
9D019AC8  93C30004   LBU V1, 4(S8)
9D019ACC  2402002C   ADDIU V0, ZERO, 44
9D019AD0  10620022   BEQ V1, V0, 0x9D019B5C
9D019AD4  00000000   NOP
1627:                			break;
9D019B5C  00000000   NOP
9D019B60  0B4066DB   J 0x9D019B6C
9D019B64  00000000   NOP
1628:                
1629:                		if(ParseStates.bits.FoundOpenBracket && ParseStates.bits.FoundAt)
9D019AD8  93C20008   LBU V0, 8(S8)
9D019ADC  30420001   ANDI V0, V0, 1
9D019AE0  304200FF   ANDI V0, V0, 255
9D019AE4  1040000A   BEQ V0, ZERO, 0x9D019B10
9D019AE8  00000000   NOP
9D019AEC  93C20008   LBU V0, 8(S8)
9D019AF0  30420002   ANDI V0, V0, 2
9D019AF4  304200FF   ANDI V0, V0, 255
9D019AF8  10400005   BEQ V0, ZERO, 0x9D019B10
9D019AFC  00000000   NOP
1630:                		{
1631:                			if(c == '>')
9D019B00  93C30004   LBU V1, 4(S8)
9D019B04  2402003E   ADDIU V0, ZERO, 62
9D019B08  10620017   BEQ V1, V0, 0x9D019B68
9D019B0C  00000000   NOP
1632:                				break;
9D019B68  00000000   NOP
1633:                		}
1634:                		
1635:                		// Advance to next character
1636:                		*wLen += 1;
9D019B10  8FC2001C   LW V0, 28(S8)
9D019B14  94420000   LHU V0, 0(V0)
9D019B18  24420001   ADDIU V0, V0, 1
9D019B1C  3043FFFF   ANDI V1, V0, -1
9D019B20  8FC2001C   LW V0, 28(S8)
9D019B24  A4430000   SH V1, 0(V0)
1637:                	}
1638:                
1639:                	if(!ParseStates.bits.FoundAt)
9D019B6C  93C20008   LBU V0, 8(S8)
9D019B70  30420002   ANDI V0, V0, 2
9D019B74  304200FF   ANDI V0, V0, 255
9D019B78  14400003   BNE V0, ZERO, 0x9D019B88
9D019B7C  00000000   NOP
1640:                		*wLen = 0;
9D019B80  8FC2001C   LW V0, 28(S8)
9D019B84  A4400000   SH ZERO, 0(V0)
1641:                
1642:                	return lpStart;
9D019B88  8FC20000   LW V0, 0(S8)
1643:                }
9D019B8C  03C0E821   ADDU SP, S8, ZERO
9D019B90  8FBE0014   LW S8, 20(SP)
9D019B94  27BD0018   ADDIU SP, SP, 24
9D019B98  03E00008   JR RA
9D019B9C  00000000   NOP
1644:                
1645:                /*****************************************************************************
1646:                  Function:
1647:                	static ROM BYTE *FindROMEmailAddress(ROM BYTE *str, WORD *wLen)
1648:                
1649:                  Summary:
1650:                	Searches a ROM string for an e-mail address.
1651:                
1652:                  Description:
1653:                	This function locates an e-mail address in a string.  It is used 
1654:                	internally by the SMTP client to parse out the actual address from
1655:                	the From and To strings so that the MAIL FROM and RCPT TO commands
1656:                	can be sent to the SMTP server.
1657:                
1658:                  Precondition:
1659:                	SMTPBeginUsage returned TRUE on a previous call.
1660:                
1661:                  Parameters:
1662:                	str - The ROM string in which to search for an e-mail address
1663:                	wLen - the length of str
1664:                
1665:                  Returns:
1666:                	A pointer to the e-mail address
1667:                  ***************************************************************************/
1668:                static ROM BYTE *FindROMEmailAddress(ROM BYTE *str, WORD *wLen)
1669:                {
9D019BA0  27BDFFE8   ADDIU SP, SP, -24
9D019BA4  AFBE0014   SW S8, 20(SP)
9D019BA8  03A0F021   ADDU S8, SP, ZERO
9D019BAC  AFC40018   SW A0, 24(S8)
9D019BB0  AFC5001C   SW A1, 28(S8)
1670:                	ROM BYTE *lpStart;
1671:                	BYTE c;
1672:                	union
1673:                	{
1674:                		BYTE Val;
1675:                		struct
1676:                		{
1677:                			BYTE FoundOpenBracket	: 1;
1678:                			BYTE FoundAt			: 1;
1679:                		} bits;
1680:                	} ParseStates;
1681:                
1682:                	lpStart = str;
9D019BB4  8FC20018   LW V0, 24(S8)
9D019BB8  AFC20000   SW V0, 0(S8)
1683:                	*wLen = 0x0000;
9D019BBC  8FC2001C   LW V0, 28(S8)
9D019BC0  A4400000   SH ZERO, 0(V0)
1684:                	ParseStates.Val = 0x00;
9D019BC4  A3C00008   SB ZERO, 8(S8)
1685:                
1686:                	while((c = *str++))
9D019BC8  0B406739   J 0x9D019CE4
9D019BCC  00000000   NOP
9D019CE4  8FC20018   LW V0, 24(S8)
9D019CE8  90420000   LBU V0, 0(V0)
9D019CEC  A3C20004   SB V0, 4(S8)
9D019CF0  93C20004   LBU V0, 4(S8)
9D019CF4  0002102B   SLTU V0, ZERO, V0
9D019CF8  304200FF   ANDI V0, V0, 255
9D019CFC  8FC30018   LW V1, 24(S8)
9D019D00  24630001   ADDIU V1, V1, 1
9D019D04  AFC30018   SW V1, 24(S8)
9D019D08  1440FFB1   BNE V0, ZERO, 0x9D019BD0
9D019D0C  00000000   NOP
9D019D10  0B40674A   J 0x9D019D28
9D019D14  00000000   NOP
1687:                	{	
1688:                		if(c == '<')
9D019BD0  93C30004   LBU V1, 4(S8)
9D019BD4  2402003C   ADDIU V0, ZERO, 60
9D019BD8  1462000C   BNE V1, V0, 0x9D019C0C
9D019BDC  00000000   NOP
1689:                		{
1690:                			ParseStates.bits.FoundOpenBracket = 1;
9D019BE0  93C20008   LBU V0, 8(S8)
9D019BE4  24030001   ADDIU V1, ZERO, 1
9D019BE8  7C620004   INS V0, V1, 0, 1
9D019BEC  A3C20008   SB V0, 8(S8)
1691:                			lpStart = str;
9D019BF0  8FC20018   LW V0, 24(S8)
9D019BF4  AFC20000   SW V0, 0(S8)
1692:                			*wLen = -1;
9D019BF8  8FC2001C   LW V0, 28(S8)
9D019BFC  2403FFFF   ADDIU V1, ZERO, -1
9D019C00  A4430000   SH V1, 0(V0)
9D019C04  0B40670B   J 0x9D019C2C
9D019C08  00000000   NOP
1693:                		}
1694:                		else if(c == '@')
9D019C0C  93C30004   LBU V1, 4(S8)
9D019C10  24020040   ADDIU V0, ZERO, 64
9D019C14  14620005   BNE V1, V0, 0x9D019C2C
9D019C18  00000000   NOP
1695:                			ParseStates.bits.FoundAt = 1;
9D019C1C  93C20008   LBU V0, 8(S8)
9D019C20  24030001   ADDIU V1, ZERO, 1
9D019C24  7C620844   INS V0, V1, 1, 1
9D019C28  A3C20008   SB V0, 8(S8)
1696:                
1697:                
1698:                		if(	!ParseStates.bits.FoundOpenBracket &&
9D019C2C  93C20008   LBU V0, 8(S8)
9D019C30  30420001   ANDI V0, V0, 1
9D019C34  304200FF   ANDI V0, V0, 255
9D019C38  14400012   BNE V0, ZERO, 0x9D019C84
9D019C3C  00000000   NOP
9D019C4C  1440000D   BNE V0, ZERO, 0x9D019C84
9D019C50  00000000   NOP
1699:                			!ParseStates.bits.FoundAt &&
9D019C40  93C20008   LBU V0, 8(S8)
9D019C44  30420002   ANDI V0, V0, 2
9D019C48  304200FF   ANDI V0, V0, 255
9D019C54  93C30004   LBU V1, 4(S8)
9D019C58  24020020   ADDIU V0, ZERO, 32
9D019C5C  10620005   BEQ V1, V0, 0x9D019C74
9D019C60  00000000   NOP
1700:                			(c == ' ' || c == ','))
9D019C64  93C30004   LBU V1, 4(S8)
9D019C68  2402002C   ADDIU V0, ZERO, 44
9D019C6C  14620005   BNE V1, V0, 0x9D019C84
9D019C70  00000000   NOP
1701:                		{
1702:                			lpStart = str;
9D019C74  8FC20018   LW V0, 24(S8)
9D019C78  AFC20000   SW V0, 0(S8)
1703:                			continue;
9D019C7C  0B406739   J 0x9D019CE4
9D019C80  00000000   NOP
1704:                		}
1705:                		else if(c == ',')
9D019C84  93C30004   LBU V1, 4(S8)
9D019C88  2402002C   ADDIU V0, ZERO, 44
9D019C8C  10620022   BEQ V1, V0, 0x9D019D18
9D019C90  00000000   NOP
1706:                			break;
9D019D18  00000000   NOP
9D019D1C  0B40674A   J 0x9D019D28
9D019D20  00000000   NOP
1707:                
1708:                		if(ParseStates.bits.FoundOpenBracket && ParseStates.bits.FoundAt)
9D019C94  93C20008   LBU V0, 8(S8)
9D019C98  30420001   ANDI V0, V0, 1
9D019C9C  304200FF   ANDI V0, V0, 255
9D019CA0  1040000A   BEQ V0, ZERO, 0x9D019CCC
9D019CA4  00000000   NOP
9D019CA8  93C20008   LBU V0, 8(S8)
9D019CAC  30420002   ANDI V0, V0, 2
9D019CB0  304200FF   ANDI V0, V0, 255
9D019CB4  10400005   BEQ V0, ZERO, 0x9D019CCC
9D019CB8  00000000   NOP
1709:                		{
1710:                			if(c == '>')
9D019CBC  93C30004   LBU V1, 4(S8)
9D019CC0  2402003E   ADDIU V0, ZERO, 62
9D019CC4  10620017   BEQ V1, V0, 0x9D019D24
9D019CC8  00000000   NOP
1711:                				break;
9D019D24  00000000   NOP
1712:                		}
1713:                		
1714:                		// Advance to next character
1715:                		*wLen += 1;
9D019CCC  8FC2001C   LW V0, 28(S8)
9D019CD0  94420000   LHU V0, 0(V0)
9D019CD4  24420001   ADDIU V0, V0, 1
9D019CD8  3043FFFF   ANDI V1, V0, -1
9D019CDC  8FC2001C   LW V0, 28(S8)
9D019CE0  A4430000   SH V1, 0(V0)
1716:                	}
1717:                
1718:                	if(!ParseStates.bits.FoundAt)
9D019D28  93C20008   LBU V0, 8(S8)
9D019D2C  30420002   ANDI V0, V0, 2
9D019D30  304200FF   ANDI V0, V0, 255
9D019D34  14400003   BNE V0, ZERO, 0x9D019D44
9D019D38  00000000   NOP
1719:                		*wLen = 0;
9D019D3C  8FC2001C   LW V0, 28(S8)
9D019D40  A4400000   SH ZERO, 0(V0)
1720:                
1721:                	return lpStart;
9D019D44  8FC20000   LW V0, 0(S8)
1722:                }
9D019D48  03C0E821   ADDU SP, S8, ZERO
9D019D4C  8FBE0014   LW S8, 20(SP)
9D019D50  27BD0018   ADDIU SP, SP, 24
9D019D54  03E00008   JR RA
9D019D58  00000000   NOP
1723:                
1724:                #endif //#if defined(STACK_USE_SMTP_CLIENT)
---  C:/Users/Diego/Documents/GitHub/pic32webFREERtos/Pic32Web.X/src/tcpip/src/Reboot.c  ----------------
1:                   /*********************************************************************
2:                    *
3:                    *	Reboot Module
4:                    *  Module for Microchip TCP/IP Stack
5:                    *	 -Remotely resets the PIC
6:                    *	 -Reference: Internet Bootloader documentation
7:                    *
8:                    *********************************************************************
9:                    * FileName:        Reboot.c
10:                   * Dependencies:    UDP
11:                   * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32
12:                   * Compiler:        Microchip C32 v1.05 or higher
13:                   *					Microchip C30 v3.12 or higher
14:                   *					Microchip C18 v3.30 or higher
15:                   *					HI-TECH PICC-18 PRO 9.63PL2 or higher
16:                   * Company:         Microchip Technology, Inc.
17:                   *
18:                   * Software License Agreement
19:                   *
20:                   * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights
21:                   * reserved.
22:                   *
23:                   * Microchip licenses to you the right to use, modify, copy, and
24:                   * distribute:
25:                   * (i)  the Software when embedded on a Microchip microcontroller or
26:                   *      digital signal controller product ("Device") which is
27:                   *      integrated into Licensee's product; or
28:                   * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h,
29:                   *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device
30:                   *		used in conjunction with a Microchip ethernet controller for
31:                   *		the sole purpose of interfacing with the ethernet controller.
32:                   *
33:                   * You should refer to the license agreement accompanying this
34:                   * Software for additional information regarding your rights and
35:                   * obligations.
36:                   *
37:                   * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT
38:                   * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT
39:                   * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A
40:                   * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL
41:                   * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR
42:                   * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF
43:                   * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS
44:                   * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE
45:                   * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER
46:                   * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT
47:                   * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE.
48:                   *
49:                   *
50:                   * Author               Date    	Comment
51:                   *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
52:                   * Howard Schlunder     02/22/07	Original
53:                   ********************************************************************/
54:                  #define __REBOOT_C
55:                  
56:                  #include "TCPIPConfig.h"
57:                  
58:                  #if defined(STACK_USE_REBOOT_SERVER)
59:                  
60:                  #include "TCPIP Stack/TCPIP.h"
61:                  
62:                  
63:                  #define REBOOT_PORT		69	// UDP TFTP port
64:                  
65:                  
66:                  // For improved security, you might want to limit reboot capabilities 
67:                  // to only users on the same IP subnet.  Define REBOOT_SAME_SUBNET_ONLY 
68:                  // to enable this access restriction.
69:                  #define REBOOT_SAME_SUBNET_ONLY
70:                  
71:                  
72:                  extern NODE_INFO remoteNode;
73:                  
74:                  /*********************************************************************
75:                   * Function:        void RebootTask(void)
76:                   *
77:                   * PreCondition:    Stack is initialized()
78:                   *
79:                   * Input:           None
80:                   *
81:                   * Output:          None
82:                   *
83:                   * Side Effects:    None
84:                   *
85:                   * Overview:        Checks for incomming traffic on port 69.  
86:                   *					Resets the PIC if a 'R' is received.
87:                   *
88:                   * Note:            This module is primarily for use with the 
89:                   *					Ethernet bootloader.  By resetting, the Ethernet 
90:                   *					bootloader can take control for a second and let
91:                   *					a firmware upgrade take place.
92:                   ********************************************************************/
93:                  void RebootTask(void)
94:                  {
9D034D30  27BDFFD8   ADDIU SP, SP, -40
9D034D34  AFBF0024   SW RA, 36(SP)
9D034D38  AFBE0020   SW S8, 32(SP)
9D034D3C  03A0F021   ADDU S8, SP, ZERO
95:                  	static UDP_SOCKET	MySocket = INVALID_UDP_SOCKET;
96:                  	struct
97:                  	{
98:                  		BYTE vMACAddress[6];
99:                  		DWORD dwIPAddress;
100:                 		WORD wChecksum;
101:                 	} BootloaderAddress;
102:                 	
103:                 	if(MySocket == INVALID_UDP_SOCKET)
9D034D40  93838024   LBU V1, -32732(GP)
9D034D44  240200FF   ADDIU V0, ZERO, 255
9D034D48  14620008   BNE V1, V0, 0x9D034D6C
9D034D4C  00000000   NOP
104:                 		MySocket = UDPOpenEx(0,UDP_OPEN_SERVER,REBOOT_PORT,INVALID_UDP_PORT);
9D034D50  00002021   ADDU A0, ZERO, ZERO
9D034D54  00002821   ADDU A1, ZERO, ZERO
9D034D58  24060045   ADDIU A2, ZERO, 69
9D034D5C  00003821   ADDU A3, ZERO, ZERO
9D034D60  0F40A0DD   JAL UDPOpenEx
9D034D64  00000000   NOP
9D034D68  A3828024   SB V0, -32732(GP)
105:                 //		MySocket = UDPOpen(REBOOT_PORT, NULL, INVALID_UDP_PORT);
106:                 
107:                 	if(MySocket == INVALID_UDP_SOCKET)
9D034D6C  93838024   LBU V1, -32732(GP)
9D034D70  240200FF   ADDIU V0, ZERO, 255
9D034D74  1062003A   BEQ V1, V0, 0x9D034E60
9D034D78  00000000   NOP
108:                 		return;
9D034E60  00000000   NOP
9D034E64  0B40D39C   J 0x9D034E70
9D034E68  00000000   NOP
109:                 
110:                 	// Do nothing if no data is waiting
111:                 	if(!UDPIsGetReady(MySocket))
9D034D7C  93828024   LBU V0, -32732(GP)
9D034D80  00402021   ADDU A0, V0, ZERO
9D034D84  0F40A3FD   JAL UDPIsGetReady
9D034D88  00000000   NOP
9D034D8C  10400037   BEQ V0, ZERO, 0x9D034E6C
9D034D90  00000000   NOP
112:                 		return;
9D034E6C  00000000   NOP
113:                 
114:                 	#if defined(REBOOT_SAME_SUBNET_ONLY)
115:                 		// Respond only to name requests sent to us from nodes on the same subnet
116:                      	if((remoteNode.IPAddr.Val & AppConfig.MyMask.Val) != (AppConfig.MyIPAddr.Val & AppConfig.MyMask.Val))
9D034D94  3C02A000   LUI V0, -24576
9D034D98  2443063C   ADDIU V1, V0, 1596
9D034D9C  88630003   LWL V1, 3(V1)
9D034DA0  9843063C   LWR V1, 1596(V0)
9D034DA4  3C02A000   LUI V0, -24576
9D034DA8  24440728   ADDIU A0, V0, 1832
9D034DAC  88840003   LWL A0, 3(A0)
9D034DB0  00802821   ADDU A1, A0, ZERO
9D034DB4  98450728   LWR A1, 1832(V0)
9D034DB8  00A01021   ADDU V0, A1, ZERO
9D034DBC  00621826   XOR V1, V1, V0
9D034DC0  3C02A000   LUI V0, -24576
9D034DC4  24420728   ADDIU V0, V0, 1832
9D034DC8  88440007   LWL A0, 7(V0)
9D034DCC  00802821   ADDU A1, A0, ZERO
9D034DD0  98450004   LWR A1, 4(V0)
9D034DD4  00A01021   ADDU V0, A1, ZERO
9D034DD8  00621024   AND V0, V1, V0
9D034DDC  10400006   BEQ V0, ZERO, 0x9D034DF8
9D034DE0  00000000   NOP
117:                 		{
118:                 			UDPDiscard();
9D034DE4  0F40A472   JAL UDPDiscard
9D034DE8  00000000   NOP
119:                 			return;
9D034DEC  00000000   NOP
9D034DF0  0B40D39C   J 0x9D034E70
9D034DF4  00000000   NOP
120:                 		}
121:                 	#endif
122:                 
123:                 	// Get our MAC address, IP address, and compute a checksum of them 
124:                 	memcpy((void*)&BootloaderAddress.vMACAddress[0], (void*)&AppConfig.MyMACAddr.v[0], sizeof(AppConfig.MyMACAddr));
9D034DF8  27C20010   ADDIU V0, S8, 16
9D034DFC  00402021   ADDU A0, V0, ZERO
9D034E00  3C02A000   LUI V0, -24576
9D034E04  24450755   ADDIU A1, V0, 1877
9D034E08  24060006   ADDIU A2, ZERO, 6
9D034E0C  0F40D298   JAL 0x9D034A60
9D034E10  00000000   NOP
125:                 	BootloaderAddress.dwIPAddress = AppConfig.MyIPAddr.Val;
9D034E14  3C02A000   LUI V0, -24576
9D034E18  24430728   ADDIU V1, V0, 1832
9D034E1C  88630003   LWL V1, 3(V1)
9D034E20  00602021   ADDU A0, V1, ZERO
9D034E24  98440728   LWR A0, 1832(V0)
9D034E28  00801021   ADDU V0, A0, ZERO
9D034E2C  AFC20018   SW V0, 24(S8)
126:                 	BootloaderAddress.wChecksum = CalcIPChecksum((BYTE*)&BootloaderAddress, sizeof(BootloaderAddress) - sizeof(BootloaderAddress.wChecksum));
9D034E30  27C20010   ADDIU V0, S8, 16
9D034E34  00402021   ADDU A0, V0, ZERO
9D034E38  2405000E   ADDIU A1, ZERO, 14
9D034E3C  0F409A63   JAL CalcIPChecksum
9D034E40  00000000   NOP
9D034E44  A7C2001C   SH V0, 28(S8)
127:                 	
128:                 	// To enter the bootloader, we need to clear the /POR bit in RCON.
129:                 	// Otherwise, the bootloader will immediately hand off execution 
130:                 	// to us.
131:                 	#if defined(USE_LCD)
132:                 		strcpypgm2ram((char*)LCDText, "Bootloader Reset");
133:                 		LCDUpdate();
134:                 	#endif
135:                 	RCONbits.POR = 0;
9D034E48  3C03BF81   LUI V1, -16511
9D034E4C  8C62F600   LW V0, -2560(V1)
9D034E50  7C020004   INS V0, ZERO, 0, 1
9D034E54  AC62F600   SW V0, -2560(V1)
136:                 	#if defined(__18CXX)
137:                 	{
138:                 		WORD_VAL wvPROD;
139:                 
140:                 		wvPROD.Val = ((WORD)&BootloaderAddress);
141:                 		PRODH = wvPROD.v[1];
142:                 		PRODL = wvPROD.v[0];
143:                 	}
144:                 	#endif
145:                 	Reset();
9D034E58  0F40D720   JAL SoftReset
9D034E5C  00000000   NOP
146:                 }
9D034E70  03C0E821   ADDU SP, S8, ZERO
9D034E74  8FBF0024   LW RA, 36(SP)
9D034E78  8FBE0020   LW S8, 32(SP)
9D034E7C  27BD0028   ADDIU SP, SP, 40
9D034E80  03E00008   JR RA
9D034E84  00000000   NOP
147:                 
148:                 #endif //#if defined(STACK_USE_REBOOT_SERVER)
---  C:/Users/Diego/Documents/GitHub/pic32webFREERtos/Pic32Web.X/src/tcpip/src/NBNS.c  ------------------
1:                   /*********************************************************************
2:                    *
3:                    *  NetBIOS Name Service (NBNS) Server
4:                    *  Module for Microchip TCP/IP Stack
5:                    *	 -Responds to NBNS name requests to allow human name assignment 
6:                    *	  to the board.  i.e. allows nodes on the same IP subnet to use a 
7:                    *    hostname to access the board instead of an IP address.
8:                    *	 -Reference: RFC 1002
9:                    *
10:                   *********************************************************************
11:                   * FileName:        NBNS.c
12:                   * Dependencies:    UDP
13:                   * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32
14:                   * Compiler:        Microchip C32 v1.05 or higher
15:                   *					Microchip C30 v3.12 or higher
16:                   *					Microchip C18 v3.30 or higher
17:                   *					HI-TECH PICC-18 PRO 9.63PL2 or higher
18:                   * Company:         Microchip Technology, Inc.
19:                   *
20:                   * Software License Agreement
21:                   *
22:                   * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights
23:                   * reserved.
24:                   *
25:                   * Microchip licenses to you the right to use, modify, copy, and
26:                   * distribute:
27:                   * (i)  the Software when embedded on a Microchip microcontroller or
28:                   *      digital signal controller product ("Device") which is
29:                   *      integrated into Licensee's product; or
30:                   * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h,
31:                   *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device
32:                   *		used in conjunction with a Microchip ethernet controller for
33:                   *		the sole purpose of interfacing with the ethernet controller.
34:                   *
35:                   * You should refer to the license agreement accompanying this
36:                   * Software for additional information regarding your rights and
37:                   * obligations.
38:                   *
39:                   * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT
40:                   * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT
41:                   * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A
42:                   * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL
43:                   * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR
44:                   * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF
45:                   * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS
46:                   * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE
47:                   * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER
48:                   * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT
49:                   * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE.
50:                   *
51:                   *
52:                   * Author               Date    Comment
53:                   *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
54:                   * Howard Schlunder     8/01/06	Original
55:                   ********************************************************************/
56:                  #define __NBNS_C
57:                  
58:                  #include "TCPIPConfig.h"
59:                  
60:                  #if defined(STACK_USE_NBNS)
61:                  
62:                  #include "TCPIP Stack/TCPIP.h"
63:                  
64:                  // NetBIOS Name Service port
65:                  #define NBNS_PORT		(137u)
66:                  
67:                  // NBNS Header structure
68:                  typedef struct _NBNS_HEADER
69:                  {
70:                  	WORD_VAL TransactionID;
71:                  	WORD_VAL Flags;
72:                  	WORD_VAL Questions;
73:                  	WORD_VAL Answers;
74:                  	WORD_VAL AuthoritativeRecords;
75:                  	WORD_VAL AdditionalRecords;
76:                  } NBNS_HEADER;
77:                  
78:                  static void NBNSPutName(BYTE *String);
79:                  static void NBNSGetName(BYTE *String);
80:                  
81:                  extern NODE_INFO remoteNode;
82:                  
83:                  
84:                  /*********************************************************************
85:                   * Function:        void NBNSTask(void)
86:                   *
87:                   * PreCondition:    None
88:                   *
89:                   * Input:           None
90:                   *
91:                   * Output:          None
92:                   *
93:                   * Side Effects:    None
94:                   *
95:                   * Overview:        Sends responses to NetBIOS name requests
96:                   *
97:                   * Note:            None
98:                   ********************************************************************/
99:                  void NBNSTask(void)
100:                 {
9D02F550  27BDFFC0   ADDIU SP, SP, -64
9D02F554  AFBF003C   SW RA, 60(SP)
9D02F558  AFBE0038   SW S8, 56(SP)
9D02F55C  03A0F021   ADDU S8, SP, ZERO
101:                 	static UDP_SOCKET	MySocket;
102:                 	BYTE 				i;
103:                 	WORD_VAL			Type, Class;
104:                 	NBNS_HEADER			NBNSHeader;
105:                 	BYTE				NameString[16];
106:                 	static enum
107:                 	{
108:                 		NBNS_HOME = 0,
109:                 		NBNS_OPEN_SOCKET,
110:                 		NBNS_LISTEN
111:                 	} smNBNS = NBNS_HOME;
112:                 
113:                 	switch(smNBNS)
9D02F560  8F828128   LW V0, -32472(GP)
9D02F564  24030001   ADDIU V1, ZERO, 1
9D02F568  1043000E   BEQ V0, V1, 0x9D02F5A4
9D02F56C  00000000   NOP
9D02F570  2C430001   SLTIU V1, V0, 1
9D02F574  14600006   BNE V1, ZERO, 0x9D02F590
9D02F578  00000000   NOP
9D02F57C  24030002   ADDIU V1, ZERO, 2
9D02F580  10430016   BEQ V0, V1, 0x9D02F5DC
9D02F584  00000000   NOP
9D02F588  0B40BE8D   J 0x9D02FA34
9D02F58C  00000000   NOP
114:                 	{
115:                 		case NBNS_HOME:
116:                 			smNBNS++;
9D02F590  8F828128   LW V0, -32472(GP)
9D02F594  24420001   ADDIU V0, V0, 1
9D02F598  AF828128   SW V0, -32472(GP)
117:                 			break;
9D02F59C  0B40BE8D   J 0x9D02FA34
9D02F5A0  00000000   NOP
118:                 
119:                 		case NBNS_OPEN_SOCKET:
120:                 			//MySocket = UDPOpen(NBNS_PORT, NULL, NBNS_PORT);
121:                 			
122:                 			MySocket = UDPOpenEx(0,UDP_OPEN_SERVER,NBNS_PORT,NBNS_PORT);
9D02F5A4  00002021   ADDU A0, ZERO, ZERO
9D02F5A8  00002821   ADDU A1, ZERO, ZERO
9D02F5AC  24060089   ADDIU A2, ZERO, 137
9D02F5B0  24070089   ADDIU A3, ZERO, 137
9D02F5B4  0F40A0DD   JAL UDPOpenEx
9D02F5B8  00000000   NOP
9D02F5BC  A382812C   SB V0, -32468(GP)
123:                 			if(MySocket == INVALID_UDP_SOCKET)
9D02F5C0  9383812C   LBU V1, -32468(GP)
9D02F5C4  240200FF   ADDIU V0, ZERO, 255
9D02F5C8  10620116   BEQ V1, V0, 0x9D02FA24
9D02F5CC  00000000   NOP
124:                 				break;
9D02FA24  00000000   NOP
9D02FA28  0B40BE8D   J 0x9D02FA34
9D02FA2C  00000000   NOP
125:                 
126:                 			smNBNS++;
9D02F5D0  8F828128   LW V0, -32472(GP)
9D02F5D4  24420001   ADDIU V0, V0, 1
9D02F5D8  AF828128   SW V0, -32472(GP)
127:                 
128:                 		case NBNS_LISTEN:
129:                 			if(!UDPIsGetReady(MySocket))
9D02F5DC  9382812C   LBU V0, -32468(GP)
9D02F5E0  00402021   ADDU A0, V0, ZERO
9D02F5E4  0F40A3FD   JAL UDPIsGetReady
9D02F5E8  00000000   NOP
9D02F5EC  10400110   BEQ V0, ZERO, 0x9D02FA30
9D02F5F0  00000000   NOP
130:                 				break;
9D02FA30  00000000   NOP
131:                 
132:                 			// Respond only to name requests sent to us from nodes on the same subnet
133:                 			// This prevents us from sending out the wrong IP address information if 
134:                 			// we haven't gotten a DHCP lease yet.
135:                         	if((remoteNode.IPAddr.Val & AppConfig.MyMask.Val) != (AppConfig.MyIPAddr.Val & AppConfig.MyMask.Val))
9D02F5F4  3C02A000   LUI V0, -24576
9D02F5F8  2443063C   ADDIU V1, V0, 1596
9D02F5FC  88630003   LWL V1, 3(V1)
9D02F600  9843063C   LWR V1, 1596(V0)
9D02F604  3C02A000   LUI V0, -24576
9D02F608  24440728   ADDIU A0, V0, 1832
9D02F60C  88840003   LWL A0, 3(A0)
9D02F610  00802821   ADDU A1, A0, ZERO
9D02F614  98450728   LWR A1, 1832(V0)
9D02F618  00A01021   ADDU V0, A1, ZERO
9D02F61C  00621826   XOR V1, V1, V0
9D02F620  3C02A000   LUI V0, -24576
9D02F624  24420728   ADDIU V0, V0, 1832
9D02F628  88440007   LWL A0, 7(V0)
9D02F62C  00802821   ADDU A1, A0, ZERO
9D02F630  98450004   LWR A1, 4(V0)
9D02F634  00A01021   ADDU V0, A1, ZERO
9D02F638  00621024   AND V0, V1, V0
9D02F63C  10400005   BEQ V0, ZERO, 0x9D02F654
9D02F640  00000000   NOP
136:                 			{
137:                 				UDPDiscard();
9D02F644  0F40A472   JAL UDPDiscard
9D02F648  00000000   NOP
138:                 				break;
9D02F64C  0B40BE8D   J 0x9D02FA34
9D02F650  00000000   NOP
139:                 			}
140:                 
141:                 			// Retrieve the NBNS header and de-big-endian it
142:                 			UDPGet(&NBNSHeader.TransactionID.v[1]);
9D02F654  27C2001C   ADDIU V0, S8, 28
9D02F658  24420001   ADDIU V0, V0, 1
9D02F65C  00402021   ADDU A0, V0, ZERO
9D02F660  0F40A421   JAL UDPGet
9D02F664  00000000   NOP
143:                 			UDPGet(&NBNSHeader.TransactionID.v[0]);
9D02F668  27C2001C   ADDIU V0, S8, 28
9D02F66C  00402021   ADDU A0, V0, ZERO
9D02F670  0F40A421   JAL UDPGet
9D02F674  00000000   NOP
144:                 			UDPGet(&NBNSHeader.Flags.v[1]);
9D02F678  27C2001C   ADDIU V0, S8, 28
9D02F67C  24420003   ADDIU V0, V0, 3
9D02F680  00402021   ADDU A0, V0, ZERO
9D02F684  0F40A421   JAL UDPGet
9D02F688  00000000   NOP
145:                 			UDPGet(&NBNSHeader.Flags.v[0]);
9D02F68C  27C2001C   ADDIU V0, S8, 28
9D02F690  24420002   ADDIU V0, V0, 2
9D02F694  00402021   ADDU A0, V0, ZERO
9D02F698  0F40A421   JAL UDPGet
9D02F69C  00000000   NOP
146:                 			UDPGet(&NBNSHeader.Questions.v[1]);
9D02F6A0  27C2001C   ADDIU V0, S8, 28
9D02F6A4  24420005   ADDIU V0, V0, 5
9D02F6A8  00402021   ADDU A0, V0, ZERO
9D02F6AC  0F40A421   JAL UDPGet
9D02F6B0  00000000   NOP
147:                 			UDPGet(&NBNSHeader.Questions.v[0]);
9D02F6B4  27C2001C   ADDIU V0, S8, 28
9D02F6B8  24420004   ADDIU V0, V0, 4
9D02F6BC  00402021   ADDU A0, V0, ZERO
9D02F6C0  0F40A421   JAL UDPGet
9D02F6C4  00000000   NOP
148:                 			UDPGet(&NBNSHeader.Answers.v[1]);
9D02F6C8  27C2001C   ADDIU V0, S8, 28
9D02F6CC  24420007   ADDIU V0, V0, 7
9D02F6D0  00402021   ADDU A0, V0, ZERO
9D02F6D4  0F40A421   JAL UDPGet
9D02F6D8  00000000   NOP
149:                 			UDPGet(&NBNSHeader.Answers.v[0]);
9D02F6DC  27C2001C   ADDIU V0, S8, 28
9D02F6E0  24420006   ADDIU V0, V0, 6
9D02F6E4  00402021   ADDU A0, V0, ZERO
9D02F6E8  0F40A421   JAL UDPGet
9D02F6EC  00000000   NOP
150:                 			UDPGet(&NBNSHeader.AuthoritativeRecords.v[1]);
9D02F6F0  27C2001C   ADDIU V0, S8, 28
9D02F6F4  24420009   ADDIU V0, V0, 9
9D02F6F8  00402021   ADDU A0, V0, ZERO
9D02F6FC  0F40A421   JAL UDPGet
9D02F700  00000000   NOP
151:                 			UDPGet(&NBNSHeader.AuthoritativeRecords.v[0]);
9D02F704  27C2001C   ADDIU V0, S8, 28
9D02F708  24420008   ADDIU V0, V0, 8
9D02F70C  00402021   ADDU A0, V0, ZERO
9D02F710  0F40A421   JAL UDPGet
9D02F714  00000000   NOP
152:                 			UDPGet(&NBNSHeader.AdditionalRecords.v[1]);
9D02F718  27C2001C   ADDIU V0, S8, 28
9D02F71C  2442000B   ADDIU V0, V0, 11
9D02F720  00402021   ADDU A0, V0, ZERO
9D02F724  0F40A421   JAL UDPGet
9D02F728  00000000   NOP
153:                 			UDPGet(&NBNSHeader.AdditionalRecords.v[0]);
9D02F72C  27C2001C   ADDIU V0, S8, 28
9D02F730  2442000A   ADDIU V0, V0, 10
9D02F734  00402021   ADDU A0, V0, ZERO
9D02F738  0F40A421   JAL UDPGet
9D02F73C  00000000   NOP
154:                 
155:                 			// Remove all questions
156:                 			while(NBNSHeader.Questions.Val--)
9D02F740  0B40BE7C   J 0x9D02F9F0
9D02F744  00000000   NOP
9D02F9F0  97C20020   LHU V0, 32(S8)
9D02F9F4  0002182B   SLTU V1, ZERO, V0
9D02F9F8  306300FF   ANDI V1, V1, 255
9D02F9FC  2442FFFF   ADDIU V0, V0, -1
9D02FA00  3042FFFF   ANDI V0, V0, -1
9D02FA04  A7C20020   SH V0, 32(S8)
9D02FA08  1460FF4F   BNE V1, ZERO, 0x9D02F748
9D02FA0C  00000000   NOP
157:                 			{
158:                 				NBNSGetName(NameString);
9D02F748  27C20028   ADDIU V0, S8, 40
9D02F74C  00402021   ADDU A0, V0, ZERO
9D02F750  0F40BEC4   JAL 0x9D02FB10
9D02F754  00000000   NOP
159:                 				UDPGet(&i);				// <??> Trailing character on string
9D02F758  27C20010   ADDIU V0, S8, 16
9D02F75C  00402021   ADDU A0, V0, ZERO
9D02F760  0F40A421   JAL UDPGet
9D02F764  00000000   NOP
160:                 				UDPGet(&Type.v[1]);		// Question type
9D02F768  27C20014   ADDIU V0, S8, 20
9D02F76C  24420001   ADDIU V0, V0, 1
9D02F770  00402021   ADDU A0, V0, ZERO
9D02F774  0F40A421   JAL UDPGet
9D02F778  00000000   NOP
161:                 				UDPGet(&Type.v[0]);
9D02F77C  27C20014   ADDIU V0, S8, 20
9D02F780  00402021   ADDU A0, V0, ZERO
9D02F784  0F40A421   JAL UDPGet
9D02F788  00000000   NOP
162:                 				UDPGet(&Class.v[1]);	// Question class
9D02F78C  27C20018   ADDIU V0, S8, 24
9D02F790  24420001   ADDIU V0, V0, 1
9D02F794  00402021   ADDU A0, V0, ZERO
9D02F798  0F40A421   JAL UDPGet
9D02F79C  00000000   NOP
163:                 				UDPGet(&Class.v[0]);
9D02F7A0  27C20018   ADDIU V0, S8, 24
9D02F7A4  00402021   ADDU A0, V0, ZERO
9D02F7A8  0F40A421   JAL UDPGet
9D02F7AC  00000000   NOP
164:                 				
165:                 				if(Type.Val == 0x0020u && Class.Val == 0x0001u && memcmp((void*)NameString, (void*)AppConfig.NetBIOSName, sizeof(AppConfig.NetBIOSName)) == 0)
9D02F7B0  97C30014   LHU V1, 20(S8)
9D02F7B4  24020020   ADDIU V0, ZERO, 32
9D02F7B8  1462008D   BNE V1, V0, 0x9D02F9F0
9D02F7BC  00000000   NOP
9D02F7C0  97C30018   LHU V1, 24(S8)
9D02F7C4  24020001   ADDIU V0, ZERO, 1
9D02F7C8  14620089   BNE V1, V0, 0x9D02F9F0
9D02F7CC  00000000   NOP
9D02F7D0  27C20028   ADDIU V0, S8, 40
9D02F7D4  00402021   ADDU A0, V0, ZERO
9D02F7D8  3C02A000   LUI V0, -24576
9D02F7DC  24450744   ADDIU A1, V0, 1860
9D02F7E0  24060010   ADDIU A2, ZERO, 16
9D02F7E4  0F40D6D9   JAL 0x9D035B64
9D02F7E8  00000000   NOP
9D02F7EC  14400080   BNE V0, ZERO, 0x9D02F9F0
9D02F7F0  00000000   NOP
166:                 				{
167:                 					while(!UDPIsPutReady(MySocket));
9D02F7F4  00000000   NOP
9D02F7F8  9382812C   LBU V0, -32468(GP)
9D02F7FC  00402021   ADDU A0, V0, ZERO
9D02F800  0F40A307   JAL UDPIsPutReady
9D02F804  00000000   NOP
9D02F808  1040FFFB   BEQ V0, ZERO, 0x9D02F7F8
9D02F80C  00000000   NOP
168:                 
169:                 					NBNSHeader.Flags.Val = 0x8400;
9D02F810  24028400   ADDIU V0, ZERO, -31744
9D02F814  A7C2001E   SH V0, 30(S8)
170:                 
171:                 					UDPPut(NBNSHeader.TransactionID.v[1]);
9D02F818  93C2001D   LBU V0, 29(S8)
9D02F81C  00402021   ADDU A0, V0, ZERO
9D02F820  0F40A32A   JAL UDPPut
9D02F824  00000000   NOP
172:                 					UDPPut(NBNSHeader.TransactionID.v[0]);
9D02F828  93C2001C   LBU V0, 28(S8)
9D02F82C  00402021   ADDU A0, V0, ZERO
9D02F830  0F40A32A   JAL UDPPut
9D02F834  00000000   NOP
173:                 					UDPPut(NBNSHeader.Flags.v[1]);
9D02F838  93C2001F   LBU V0, 31(S8)
9D02F83C  00402021   ADDU A0, V0, ZERO
9D02F840  0F40A32A   JAL UDPPut
9D02F844  00000000   NOP
174:                 					UDPPut(NBNSHeader.Flags.v[0]);
9D02F848  93C2001E   LBU V0, 30(S8)
9D02F84C  00402021   ADDU A0, V0, ZERO
9D02F850  0F40A32A   JAL UDPPut
9D02F854  00000000   NOP
175:                 					UDPPut(0x00);	// 0x0000 Questions
9D02F858  00002021   ADDU A0, ZERO, ZERO
9D02F85C  0F40A32A   JAL UDPPut
9D02F860  00000000   NOP
176:                 					UDPPut(0x00);
9D02F864  00002021   ADDU A0, ZERO, ZERO
9D02F868  0F40A32A   JAL UDPPut
9D02F86C  00000000   NOP
177:                 					UDPPut(0x00);	// 0x0001 Answers
9D02F870  00002021   ADDU A0, ZERO, ZERO
9D02F874  0F40A32A   JAL UDPPut
9D02F878  00000000   NOP
178:                 					UDPPut(0x01);
9D02F87C  24040001   ADDIU A0, ZERO, 1
9D02F880  0F40A32A   JAL UDPPut
9D02F884  00000000   NOP
179:                 					UDPPut(0x00);	// 0x0000 Athoritative records
9D02F888  00002021   ADDU A0, ZERO, ZERO
9D02F88C  0F40A32A   JAL UDPPut
9D02F890  00000000   NOP
180:                 					UDPPut(0x00);
9D02F894  00002021   ADDU A0, ZERO, ZERO
9D02F898  0F40A32A   JAL UDPPut
9D02F89C  00000000   NOP
181:                 					UDPPut(0x00);	// 0x0000 Additional records
9D02F8A0  00002021   ADDU A0, ZERO, ZERO
9D02F8A4  0F40A32A   JAL UDPPut
9D02F8A8  00000000   NOP
182:                 					UDPPut(0x00);
9D02F8AC  00002021   ADDU A0, ZERO, ZERO
9D02F8B0  0F40A32A   JAL UDPPut
9D02F8B4  00000000   NOP
183:                 
184:                 					NBNSPutName(AppConfig.NetBIOSName);
9D02F8B8  3C02A000   LUI V0, -24576
9D02F8BC  24440744   ADDIU A0, V0, 1860
9D02F8C0  0F40BE93   JAL 0x9D02FA4C
9D02F8C4  00000000   NOP
185:                 					UDPPut(0x00);	// 0x0020 Type: NetBIOS
9D02F8C8  00002021   ADDU A0, ZERO, ZERO
9D02F8CC  0F40A32A   JAL UDPPut
9D02F8D0  00000000   NOP
186:                 					UDPPut(0x20);
9D02F8D4  24040020   ADDIU A0, ZERO, 32
9D02F8D8  0F40A32A   JAL UDPPut
9D02F8DC  00000000   NOP
187:                 					UDPPut(0x00);	// 0x0001 Class: Internet
9D02F8E0  00002021   ADDU A0, ZERO, ZERO
9D02F8E4  0F40A32A   JAL UDPPut
9D02F8E8  00000000   NOP
188:                 					UDPPut(0x01);
9D02F8EC  24040001   ADDIU A0, ZERO, 1
9D02F8F0  0F40A32A   JAL UDPPut
9D02F8F4  00000000   NOP
189:                 					UDPPut(0x00);	// 0x00000000 Time To Live
9D02F8F8  00002021   ADDU A0, ZERO, ZERO
9D02F8FC  0F40A32A   JAL UDPPut
9D02F900  00000000   NOP
190:                 					UDPPut(0x00);
9D02F904  00002021   ADDU A0, ZERO, ZERO
9D02F908  0F40A32A   JAL UDPPut
9D02F90C  00000000   NOP
191:                 					UDPPut(0x00);
9D02F910  00002021   ADDU A0, ZERO, ZERO
9D02F914  0F40A32A   JAL UDPPut
9D02F918  00000000   NOP
192:                 					UDPPut(0x00);
9D02F91C  00002021   ADDU A0, ZERO, ZERO
9D02F920  0F40A32A   JAL UDPPut
9D02F924  00000000   NOP
193:                 
194:                 					UDPPut(0x00);	// 0x0006 Data length
9D02F928  00002021   ADDU A0, ZERO, ZERO
9D02F92C  0F40A32A   JAL UDPPut
9D02F930  00000000   NOP
195:                 					UDPPut(0x06);	
9D02F934  24040006   ADDIU A0, ZERO, 6
9D02F938  0F40A32A   JAL UDPPut
9D02F93C  00000000   NOP
196:                 					UDPPut(0x60);	// 0x6000 Flags: H-node, Unique
9D02F940  24040060   ADDIU A0, ZERO, 96
9D02F944  0F40A32A   JAL UDPPut
9D02F948  00000000   NOP
197:                 					UDPPut(0x00);
9D02F94C  00002021   ADDU A0, ZERO, ZERO
9D02F950  0F40A32A   JAL UDPPut
9D02F954  00000000   NOP
198:                 					UDPPut(AppConfig.MyIPAddr.v[0]);	// Put out IP address
9D02F958  3C02A000   LUI V0, -24576
9D02F95C  90420728   LBU V0, 1832(V0)
9D02F960  00402021   ADDU A0, V0, ZERO
9D02F964  0F40A32A   JAL UDPPut
9D02F968  00000000   NOP
199:                 					UDPPut(AppConfig.MyIPAddr.v[1]);
9D02F96C  3C02A000   LUI V0, -24576
9D02F970  24420728   ADDIU V0, V0, 1832
9D02F974  90420001   LBU V0, 1(V0)
9D02F978  00402021   ADDU A0, V0, ZERO
9D02F97C  0F40A32A   JAL UDPPut
9D02F980  00000000   NOP
200:                 					UDPPut(AppConfig.MyIPAddr.v[2]);
9D02F984  3C02A000   LUI V0, -24576
9D02F988  24420728   ADDIU V0, V0, 1832
9D02F98C  90420002   LBU V0, 2(V0)
9D02F990  00402021   ADDU A0, V0, ZERO
9D02F994  0F40A32A   JAL UDPPut
9D02F998  00000000   NOP
201:                 					UDPPut(AppConfig.MyIPAddr.v[3]);
9D02F99C  3C02A000   LUI V0, -24576
9D02F9A0  24420728   ADDIU V0, V0, 1832
9D02F9A4  90420003   LBU V0, 3(V0)
9D02F9A8  00402021   ADDU A0, V0, ZERO
9D02F9AC  0F40A32A   JAL UDPPut
9D02F9B0  00000000   NOP
202:                 
203:                 					// Change the destination address to the unicast address of the last received packet
204:                 		        	memcpy((void*)&UDPSocketInfo[MySocket].remote.remoteNode, (const void*)&remoteNode, sizeof(remoteNode));
9D02F9B4  9382812C   LBU V0, -32468(GP)
9D02F9B8  00401821   ADDU V1, V0, ZERO
9D02F9BC  2402001C   ADDIU V0, ZERO, 28
9D02F9C0  70621802   MUL V1, V1, V0
9D02F9C4  3C02A000   LUI V0, -24576
9D02F9C8  24420648   ADDIU V0, V0, 1608
9D02F9CC  00621021   ADDU V0, V1, V0
9D02F9D0  00402021   ADDU A0, V0, ZERO
9D02F9D4  3C02A000   LUI V0, -24576
9D02F9D8  2445063C   ADDIU A1, V0, 1596
9D02F9DC  2406000A   ADDIU A2, ZERO, 10
9D02F9E0  0F40D298   JAL 0x9D034A60
9D02F9E4  00000000   NOP
205:                 					UDPFlush();				
9D02F9E8  0F40A38D   JAL UDPFlush
9D02F9EC  00000000   NOP
206:                 				}
207:                 
208:                 			}
209:                 			
210:                 			UDPDiscard();
9D02FA10  0F40A472   JAL UDPDiscard
9D02FA14  00000000   NOP
211:                 
212:                 			break;
9D02FA18  00000000   NOP
9D02FA1C  0B40BE8D   J 0x9D02FA34
9D02FA20  00000000   NOP
213:                 	}
214:                 }
9D02FA34  03C0E821   ADDU SP, S8, ZERO
9D02FA38  8FBF003C   LW RA, 60(SP)
9D02FA3C  8FBE0038   LW S8, 56(SP)
9D02FA40  27BD0040   ADDIU SP, SP, 64
9D02FA44  03E00008   JR RA
9D02FA48  00000000   NOP
215:                 
216:                 /*********************************************************************
217:                  * Function:        static void NBNSPutName (BYTE *String)
218:                  *
219:                  * PreCondition:    None
220:                  *
221:                  * Input:           String: The name to transmit
222:                  *
223:                  * Output:          None
224:                  *
225:                  * Side Effects:    None
226:                  *
227:                  * Overview:        Transmits the NetBIOS name across an open UDP
228:                  *                  socket.
229:                  *
230:                  * Note:            None
231:                  ********************************************************************/
232:                 static void NBNSPutName(BYTE *String)
233:                 {
9D02FA4C  27BDFFE0   ADDIU SP, SP, -32
9D02FA50  AFBF001C   SW RA, 28(SP)
9D02FA54  AFBE0018   SW S8, 24(SP)
9D02FA58  03A0F021   ADDU S8, SP, ZERO
9D02FA5C  AFC40020   SW A0, 32(S8)
234:                 	BYTE i, j;
235:                 
236:                 	UDPPut(32);	// NetBIOS names are always 32 bytes long (16 decoded bytes)
9D02FA60  24040020   ADDIU A0, ZERO, 32
9D02FA64  0F40A32A   JAL UDPPut
9D02FA68  00000000   NOP
237:                 	for(i = 0; i < 16u; i++)
9D02FA6C  A3C00010   SB ZERO, 16(S8)
9D02FA70  0B40BEB7   J 0x9D02FADC
9D02FA74  00000000   NOP
9D02FAD0  93C20010   LBU V0, 16(S8)
9D02FAD4  24420001   ADDIU V0, V0, 1
9D02FAD8  A3C20010   SB V0, 16(S8)
9D02FADC  93C20010   LBU V0, 16(S8)
9D02FAE0  2C420010   SLTIU V0, V0, 16
9D02FAE4  1440FFE4   BNE V0, ZERO, 0x9D02FA78
9D02FAE8  00000000   NOP
238:                 	{
239:                 		j = *String++;
9D02FA78  8FC20020   LW V0, 32(S8)
9D02FA7C  90420000   LBU V0, 0(V0)
9D02FA80  A3C20011   SB V0, 17(S8)
9D02FA84  8FC20020   LW V0, 32(S8)
9D02FA88  24420001   ADDIU V0, V0, 1
9D02FA8C  AFC20020   SW V0, 32(S8)
240:                 		UDPPut((j>>4) + 'A');
9D02FA90  93C20011   LBU V0, 17(S8)
9D02FA94  00021102   SRL V0, V0, 4
9D02FA98  304200FF   ANDI V0, V0, 255
9D02FA9C  24420041   ADDIU V0, V0, 65
9D02FAA0  304200FF   ANDI V0, V0, 255
9D02FAA4  00402021   ADDU A0, V0, ZERO
9D02FAA8  0F40A32A   JAL UDPPut
9D02FAAC  00000000   NOP
241:                 		UDPPut((j & 0x0F) + 'A');
9D02FAB0  93C20011   LBU V0, 17(S8)
9D02FAB4  3042000F   ANDI V0, V0, 15
9D02FAB8  304200FF   ANDI V0, V0, 255
9D02FABC  24420041   ADDIU V0, V0, 65
9D02FAC0  304200FF   ANDI V0, V0, 255
9D02FAC4  00402021   ADDU A0, V0, ZERO
9D02FAC8  0F40A32A   JAL UDPPut
9D02FACC  00000000   NOP
242:                 	}
243:                 	
244:                 	UDPPut(0x00);
9D02FAEC  00002021   ADDU A0, ZERO, ZERO
9D02FAF0  0F40A32A   JAL UDPPut
9D02FAF4  00000000   NOP
245:                 }
9D02FAF8  03C0E821   ADDU SP, S8, ZERO
9D02FAFC  8FBF001C   LW RA, 28(SP)
9D02FB00  8FBE0018   LW S8, 24(SP)
9D02FB04  27BD0020   ADDIU SP, SP, 32
9D02FB08  03E00008   JR RA
9D02FB0C  00000000   NOP
246:                 
247:                 /*********************************************************************
248:                  * Function:        static void NBNSGetName (BYTE *String)
249:                  *
250:                  * PreCondition:    None
251:                  *
252:                  * Input:           String: Pointer to an array into which
253:                  *                  a received NetBIOS name should be copied.
254:                  *
255:                  * Output:          None
256:                  *
257:                  * Side Effects:    None
258:                  *
259:                  * Overview:        Reads the NetBIOS name from a UDP socket and
260:                  *                  copies it into a user-specified buffer.
261:                  *
262:                  * Note:            None
263:                  ********************************************************************/
264:                 static void NBNSGetName(BYTE *String)
265:                 {
9D02FB10  27BDFFE0   ADDIU SP, SP, -32
9D02FB14  AFBF001C   SW RA, 28(SP)
9D02FB18  AFBE0018   SW S8, 24(SP)
9D02FB1C  03A0F021   ADDU S8, SP, ZERO
9D02FB20  AFC40020   SW A0, 32(S8)
266:                 	BYTE i, j, k;
267:                 
268:                 	if(String == NULL)
9D02FB24  8FC20020   LW V0, 32(S8)
9D02FB28  14400015   BNE V0, ZERO, 0x9D02FB80
9D02FB2C  00000000   NOP
269:                 	{
270:                 		UDPGet(&i);
9D02FB30  27C20011   ADDIU V0, S8, 17
9D02FB34  00402021   ADDU A0, V0, ZERO
9D02FB38  0F40A421   JAL UDPGet
9D02FB3C  00000000   NOP
271:                 		while(i--)
9D02FB40  0B40BED6   J 0x9D02FB58
9D02FB44  00000000   NOP
9D02FB58  93C20011   LBU V0, 17(S8)
9D02FB5C  0002182B   SLTU V1, ZERO, V0
9D02FB60  306300FF   ANDI V1, V1, 255
9D02FB64  2442FFFF   ADDIU V0, V0, -1
9D02FB68  304200FF   ANDI V0, V0, 255
9D02FB6C  A3C20011   SB V0, 17(S8)
9D02FB70  1460FFF5   BNE V1, ZERO, 0x9D02FB48
9D02FB74  00000000   NOP
9D02FB78  0B40BF17   J 0x9D02FC5C
9D02FB7C  00000000   NOP
272:                 		{
273:                 			UDPGet(&j);
9D02FB48  27C20012   ADDIU V0, S8, 18
9D02FB4C  00402021   ADDU A0, V0, ZERO
9D02FB50  0F40A421   JAL UDPGet
9D02FB54  00000000   NOP
274:                 		}
275:                 	}
276:                 	else
277:                 	{
278:                 		UDPGet(&i);
9D02FB80  27C20011   ADDIU V0, S8, 17
9D02FB84  00402021   ADDU A0, V0, ZERO
9D02FB88  0F40A421   JAL UDPGet
9D02FB8C  00000000   NOP
279:                 		if(i != 32u)
9D02FB90  93C30011   LBU V1, 17(S8)
9D02FB94  24020020   ADDIU V0, ZERO, 32
9D02FB98  10620027   BEQ V1, V0, 0x9D02FC38
9D02FB9C  00000000   NOP
280:                 		{
281:                 			*String = 0;
9D02FBA0  8FC20020   LW V0, 32(S8)
9D02FBA4  A0400000   SB ZERO, 0(V0)
282:                 			return;
9D02FBA8  0B40BF17   J 0x9D02FC5C
9D02FBAC  00000000   NOP
283:                 		}
284:                 		while(i--)
9D02FC38  00000000   NOP
9D02FC3C  93C20011   LBU V0, 17(S8)
9D02FC40  0002182B   SLTU V1, ZERO, V0
9D02FC44  306300FF   ANDI V1, V1, 255
9D02FC48  2442FFFF   ADDIU V0, V0, -1
9D02FC4C  304200FF   ANDI V0, V0, 255
9D02FC50  A3C20011   SB V0, 17(S8)
9D02FC54  1460FFD6   BNE V1, ZERO, 0x9D02FBB0
9D02FC58  00000000   NOP
285:                 		{
286:                 			UDPGet(&j);
9D02FBB0  27C20012   ADDIU V0, S8, 18
9D02FBB4  00402021   ADDU A0, V0, ZERO
9D02FBB8  0F40A421   JAL UDPGet
9D02FBBC  00000000   NOP
287:                 			j -= 'A';
9D02FBC0  93C20012   LBU V0, 18(S8)
9D02FBC4  2442FFBF   ADDIU V0, V0, -65
9D02FBC8  304200FF   ANDI V0, V0, 255
9D02FBCC  A3C20012   SB V0, 18(S8)
288:                 			k = j<<4;
9D02FBD0  93C20012   LBU V0, 18(S8)
9D02FBD4  00021100   SLL V0, V0, 4
9D02FBD8  A3C20010   SB V0, 16(S8)
289:                 			i--;
9D02FBDC  93C20011   LBU V0, 17(S8)
9D02FBE0  2442FFFF   ADDIU V0, V0, -1
9D02FBE4  304200FF   ANDI V0, V0, 255
9D02FBE8  A3C20011   SB V0, 17(S8)
290:                 			UDPGet(&j);
9D02FBEC  27C20012   ADDIU V0, S8, 18
9D02FBF0  00402021   ADDU A0, V0, ZERO
9D02FBF4  0F40A421   JAL UDPGet
9D02FBF8  00000000   NOP
291:                 			j -= 'A';
9D02FBFC  93C20012   LBU V0, 18(S8)
9D02FC00  2442FFBF   ADDIU V0, V0, -65
9D02FC04  304200FF   ANDI V0, V0, 255
9D02FC08  A3C20012   SB V0, 18(S8)
292:                 			*String++ = k | j;
9D02FC0C  93C30012   LBU V1, 18(S8)
9D02FC10  93C20010   LBU V0, 16(S8)
9D02FC14  00621025   OR V0, V1, V0
9D02FC18  304300FF   ANDI V1, V0, 255
9D02FC1C  8FC20020   LW V0, 32(S8)
9D02FC20  A0430000   SB V1, 0(V0)
9D02FC24  8FC20020   LW V0, 32(S8)
9D02FC28  24420001   ADDIU V0, V0, 1
9D02FC2C  AFC20020   SW V0, 32(S8)
9D02FC30  0B40BF0F   J 0x9D02FC3C
9D02FC34  00000000   NOP
293:                 		}
294:                 	}
295:                 }
9D02FC5C  03C0E821   ADDU SP, S8, ZERO
9D02FC60  8FBF001C   LW RA, 28(SP)
9D02FC64  8FBE0018   LW S8, 24(SP)
9D02FC68  27BD0020   ADDIU SP, SP, 32
9D02FC6C  03E00008   JR RA
9D02FC70  00000000   NOP
296:                 
297:                 
298:                 #endif //#if defined(STACK_USE_NBNS)
---  C:/Users/Diego/Documents/GitHub/pic32webFREERtos/Pic32Web.X/src/tcpip/src/MPFS2.c  -----------------
1:                   /*********************************************************************
2:                    *
3:                    *	Microchip File System (MPFS) File Access API
4:                    *  Module for Microchip TCP/IP Stack
5:                    *	 -Provides single API for accessing web pages and other files 
6:                    *    from internal program memory or an external serial EEPROM memory
7:                    *	 -Reference: AN833
8:                    *
9:                    *********************************************************************
10:                   * FileName:        MPFS.c
11:                   * Dependencies:    SPIEEPROM.c, SPIFlash.c, or MPFSImg2.c/.s
12:                   * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32
13:                   * Compiler:        Microchip C32 v1.05 or higher
14:                   *					Microchip C30 v3.12 or higher
15:                   *					Microchip C18 v3.30 or higher
16:                   *					HI-TECH PICC-18 PRO 9.63PL2 or higher
17:                   * Company:         Microchip Technology, Inc.
18:                   *
19:                   * Software License Agreement
20:                   *
21:                   * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights
22:                   * reserved.
23:                   *
24:                   * Microchip licenses to you the right to use, modify, copy, and
25:                   * distribute:
26:                   * (i)  the Software when embedded on a Microchip microcontroller or
27:                   *      digital signal controller product ("Device") which is
28:                   *      integrated into Licensee's product; or
29:                   * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h,
30:                   *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device
31:                   *		used in conjunction with a Microchip ethernet controller for
32:                   *		the sole purpose of interfacing with the ethernet controller.
33:                   *
34:                   * You should refer to the license agreement accompanying this
35:                   * Software for additional information regarding your rights and
36:                   * obligations.
37:                   *
38:                   * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT
39:                   * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT
40:                   * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A
41:                   * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL
42:                   * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR
43:                   * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF
44:                   * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS
45:                   * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE
46:                   * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER
47:                   * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT
48:                   * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE.
49:                   *
50:                   *
51:                   * Author               Date        Comment
52:                   *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
53:                   * Elliott Wood			07/2007		Complete rewrite as MPFS2
54:                   * E. Wood				04/2008		Updated as MPFS2.1
55:                   ********************************************************************/
56:                  #define __MPFS2_C
57:                  
58:                  #include "TCPIP Stack/TCPIP.h"
59:                  
60:                  #if defined(STACK_USE_MPFS2)
61:                  
62:                  //Supports long file names to 64 characters
63:                  #define MAX_FILE_NAME_LEN   (64u)
64:                  
65:                  /*
66:                   * MPFS Structure:
67:                   *     [M][P][F][S]
68:                   *     [BYTE Ver Hi][BYTE Ver Lo][WORD Number of Files]
69:                   *     [Name Hash 0][Name Hash 1]...[Name Hash N]
70:                   *     [File Record 0][File Record 1]...[File Record N]
71:                   *     [String 0][String 1]...[String N]
72:                   *     [File Data 0][File Data 1]...[File Data N]
73:                   *
74:                   * Name Hash (2 bytes):
75:                   *     hash = 0
76:                   *     for each(byte in name)
77:                   *         hash += byte
78:                   *         hash <<= 1
79:                   *
80:                   *     Technically this means the hash only includes the 
81:                   *     final 15 characters of a name.
82:                   *
83:                   * File Record Structure (22 bytes):
84:                   *     [DWORD String Ptr][DWORD Data Ptr]
85:                   *     [DWORD Len][DWORD Timestamp][DWORD Microtime]
86:                   *     [WORD Flags]
87:                   *
88:                   *     Pointers are absolute addresses within the MPFS image.
89:                   *     Timestamp is the UNIX timestamp
90:                   *     Microtime is currently unimplemented
91:                   *
92:                   * String Structure (1 to 64 bytes):
93:                   *     ["path/to/file.ext"][0x00]
94:                   *
95:                   * File Data Structure (arbitrary length):
96:                   *		[File Data]
97:                   *
98:                   * Unlike previous versions, there are no delimiters.
99:                   *
100:                  * Name hash is calculated as follows:
101:                  *      hash = 0
102:                  *      for each(byte in name)
103:                  *          hash += byte, hash <<= 1
104:                  *
105:                  * When a file has an index, that index file has no file name,
106:                  * but is accessible as the file immediately following in the image.
107:                  *
108:                  * Current version is 2.1
109:                  */
110:                 
111:                 /****************************************************************************
112:                   Section:
113:                 	Module-Only Globals and Functions
114:                   ***************************************************************************/
115:                   
116:                 // Track the MPFS File Handles
117:                 // MPFSStubs[0] is reserved for internal use (FAT access)
118:                 static MPFS_STUB MPFSStubs[MAX_MPFS_HANDLES+1];
119:                 
120:                 // Allows the MPFS to be locked, preventing access during updates
121:                 static BOOL isMPFSLocked;
122:                 
123:                 // FAT record cache
124:                 static MPFS_FAT_RECORD fatCache;
125:                 
126:                 // ID of currently loaded fatCache
127:                 static WORD fatCacheID;
128:                 
129:                 // Number of files in this MPFS image
130:                 static WORD numFiles;
131:                 
132:                 
133:                 static void _LoadFATRecord(WORD fatID);
134:                 static void _Validate(void);
135:                 
136:                 /****************************************************************************
137:                   Section:
138:                 	EEPROM vs Flash Storage Settings
139:                   ***************************************************************************/
140:                   
141:                 #if defined(MPFS_USE_EEPROM)
142:                 
143:                 	// Beginning address of MPFS Image
144:                 	#define MPFS_HEAD		MPFS_RESERVE_BLOCK
145:                 
146:                 	// Track the last read address to prevent unnecessary
147:                 	// data overhead to switch locations.
148:                 	MPFS_PTR lastRead;
149:                 
150:                 
151:                 #elif defined(MPFS_USE_SPI_FLASH)
152:                 
153:                 	// Beginning address of MPFS Image
154:                 	#define MPFS_HEAD		MPFS_RESERVE_BLOCK
155:                 	
156:                 #else
157:                 
158:                 	// An address where MPFS data starts in program memory.
159:                     #if defined(__18CXX) || defined(__C32__)
160:                   		extern ROM BYTE MPFS_Start[];
161:                 	    #define MPFS_HEAD		((DWORD)(&MPFS_Start[0]))
162:                     #else
163:                 	  	extern DWORD MPFS_Start;
164:                 	  	#define MPFS_HEAD		MPFS_Start;
165:                     #endif
166:                     
167:                 #endif
168:                 
169:                 /****************************************************************************
170:                   Section:
171:                 	Stack-Level Functions
172:                   ***************************************************************************/
173:                 
174:                 /*****************************************************************************
175:                   Function:
176:                 	void MPFSInit(void)
177:                 
178:                   Summary:
179:                 	Initializes the MPFS module.
180:                 
181:                   Description:
182:                 	Sets all MPFS handles to closed, and initializes access to the EEPROM
183:                 	if necessary.
184:                 
185:                   Precondition:
186:                 	None
187:                 
188:                   Parameters:
189:                 	None
190:                 
191:                   Returns:
192:                 	None
193:                 	
194:                   Remarks:
195:                 	This function is called only one during lifetime of the application.
196:                   ***************************************************************************/
197:                 void MPFSInit(void)
198:                 {
9D026D98  27BDFFE0   ADDIU SP, SP, -32
9D026D9C  AFBF001C   SW RA, 28(SP)
9D026DA0  AFBE0018   SW S8, 24(SP)
9D026DA4  03A0F021   ADDU S8, SP, ZERO
199:                 	BYTE i;
200:                 	
201:                 	for(i = 1; i <= MAX_MPFS_HANDLES; i++)
9D026DA8  24020001   ADDIU V0, ZERO, 1
9D026DAC  A3C20010   SB V0, 16(S8)
9D026DB0  0B409B79   J 0x9D026DE4
9D026DB4  00000000   NOP
9D026DD8  93C20010   LBU V0, 16(S8)
9D026DDC  24420001   ADDIU V0, V0, 1
9D026DE0  A3C20010   SB V0, 16(S8)
9D026DE4  93C20010   LBU V0, 16(S8)
9D026DE8  2C420008   SLTIU V0, V0, 8
9D026DEC  1440FFF2   BNE V0, ZERO, 0x9D026DB8
9D026DF0  00000000   NOP
202:                 	{
203:                 		MPFSStubs[i].addr = MPFS_INVALID;
9D026DB8  93C40010   LBU A0, 16(S8)
9D026DBC  3C02A000   LUI V0, -24576
9D026DC0  2403000C   ADDIU V1, ZERO, 12
9D026DC4  70831802   MUL V1, A0, V1
9D026DC8  2442310C   ADDIU V0, V0, 12556
9D026DCC  00621021   ADDU V0, V1, V0
9D026DD0  2403FFFF   ADDIU V1, ZERO, -1
9D026DD4  AC430000   SW V1, 0(V0)
204:                 	}
205:                 	
206:                 	#if defined(MPFS_USE_EEPROM)
207:                     // Initialize the EEPROM access routines.
208:                     XEEInit();
209:                 	lastRead = MPFS_INVALID;
210:                 	#endif
211:                 	
212:                 	#if defined(MPFS_USE_SPI_FLASH)
213:                 	// Initialize SPI Flash access routines.
214:                 	SPIFlashInit();
215:                 	#endif
216:                 
217:                 	// Validate the image and load numFiles
218:                 	_Validate();
9D026DF4  0F40A096   JAL 0x9D028258
9D026DF8  00000000   NOP
219:                 
220:                 	isMPFSLocked = FALSE;
9D026DFC  AF808120   SW ZERO, -32480(GP)
221:                 
222:                 }
9D026E00  03C0E821   ADDU SP, S8, ZERO
9D026E04  8FBF001C   LW RA, 28(SP)
9D026E08  8FBE0018   LW S8, 24(SP)
9D026E0C  27BD0020   ADDIU SP, SP, 32
9D026E10  03E00008   JR RA
9D026E14  00000000   NOP
223:                 
224:                 /****************************************************************************
225:                   Section:
226:                 	Handle Management Functions
227:                   ***************************************************************************/
228:                 
229:                 /*****************************************************************************
230:                   Function:
231:                 	MPFS_HANDLE MPFSOpen(BYTE* cFile)
232:                 
233:                   Description:
234:                 	Opens a file in the MPFS2 file system.
235:                 	
236:                   Precondition:
237:                 	None
238:                 
239:                   Parameters:
240:                 	cFile - a null terminated file name to open
241:                 
242:                   Returns:
243:                 	An MPFS_HANDLE to the opened file if found, or MPFS_INVALID_HANDLE
244:                 	if the file could not be found or no free handles exist.
245:                   ***************************************************************************/
246:                 MPFS_HANDLE MPFSOpen(BYTE* cFile)
247:                 {
9D026E18  27BDFFC8   ADDIU SP, SP, -56
9D026E1C  AFBF0034   SW RA, 52(SP)
9D026E20  AFBE0030   SW S8, 48(SP)
9D026E24  03A0F021   ADDU S8, SP, ZERO
9D026E28  AFC40038   SW A0, 56(S8)
248:                 	MPFS_HANDLE hMPFS;
249:                 	WORD nameHash, i;
250:                 	WORD hashCache[8];
251:                 	BYTE *ptr, c;
252:                 	
253:                 	// Initialize c to avoid "may be used uninitialized" compiler warning
254:                 	c = 0;
9D026E2C  A3C0002C   SB ZERO, 44(S8)
255:                 	
256:                 	// Make sure MPFS is unlocked and we got a filename
257:                 	if(*cFile == '\0' || isMPFSLocked == TRUE)
9D026E30  8FC20038   LW V0, 56(S8)
9D026E34  90420000   LBU V0, 0(V0)
9D026E38  10400005   BEQ V0, ZERO, 0x9D026E50
9D026E3C  00000000   NOP
9D026E40  8F838120   LW V1, -32480(GP)
9D026E44  24020001   ADDIU V0, ZERO, 1
9D026E48  14620004   BNE V1, V0, 0x9D026E5C
9D026E4C  00000000   NOP
258:                 		return MPFS_INVALID_HANDLE;
9D026E50  240200FF   ADDIU V0, ZERO, 255
9D026E54  0B409C43   J 0x9D02710C
9D026E58  00000000   NOP
259:                 
260:                 	// Calculate the name hash to speed up searching
261:                 	for(nameHash = 0, ptr = cFile; *ptr != '\0'; ptr++)
9D026E5C  A7C00012   SH ZERO, 18(S8)
9D026E60  8FC20038   LW V0, 56(S8)
9D026E64  AFC20018   SW V0, 24(S8)
9D026E68  0B409BA8   J 0x9D026EA0
9D026E6C  00000000   NOP
9D026E94  8FC20018   LW V0, 24(S8)
9D026E98  24420001   ADDIU V0, V0, 1
9D026E9C  AFC20018   SW V0, 24(S8)
9D026EA0  8FC20018   LW V0, 24(S8)
9D026EA4  90420000   LBU V0, 0(V0)
9D026EA8  1440FFF1   BNE V0, ZERO, 0x9D026E70
9D026EAC  00000000   NOP
262:                 	{
263:                 		nameHash += *ptr;
9D026E70  8FC20018   LW V0, 24(S8)
9D026E74  90420000   LBU V0, 0(V0)
9D026E78  00401821   ADDU V1, V0, ZERO
9D026E7C  97C20012   LHU V0, 18(S8)
9D026E80  00621021   ADDU V0, V1, V0
9D026E84  A7C20012   SH V0, 18(S8)
264:                 		nameHash <<= 1;
9D026E88  97C20012   LHU V0, 18(S8)
9D026E8C  00021040   SLL V0, V0, 1
9D026E90  A7C20012   SH V0, 18(S8)
265:                 	}
266:                 	
267:                 	// Find a free file handle to use
268:                 	for(hMPFS = 1; hMPFS <= MAX_MPFS_HANDLES; hMPFS++)
9D026EB0  24020001   ADDIU V0, ZERO, 1
9D026EB4  A3C20010   SB V0, 16(S8)
9D026EB8  0B409BBD   J 0x9D026EF4
9D026EBC  00000000   NOP
9D026EE8  93C20010   LBU V0, 16(S8)
9D026EEC  24420001   ADDIU V0, V0, 1
9D026EF0  A3C20010   SB V0, 16(S8)
9D026EF4  93C20010   LBU V0, 16(S8)
9D026EF8  2C420008   SLTIU V0, V0, 8
9D026EFC  1440FFF0   BNE V0, ZERO, 0x9D026EC0
9D026F00  00000000   NOP
9D026F04  0B409BC4   J 0x9D026F10
9D026F08  00000000   NOP
269:                 		if(MPFSStubs[hMPFS].addr == MPFS_INVALID)
9D026EC0  93C40010   LBU A0, 16(S8)
9D026EC4  3C02A000   LUI V0, -24576
9D026EC8  2403000C   ADDIU V1, ZERO, 12
9D026ECC  70831802   MUL V1, A0, V1
9D026ED0  2442310C   ADDIU V0, V0, 12556
9D026ED4  00621021   ADDU V0, V1, V0
9D026ED8  8C430000   LW V1, 0(V0)
9D026EDC  2402FFFF   ADDIU V0, ZERO, -1
9D026EE0  1062000A   BEQ V1, V0, 0x9D026F0C
9D026EE4  00000000   NOP
270:                 			break;
9D026F0C  00000000   NOP
271:                 	if(hMPFS == MAX_MPFS_HANDLES)
9D026F10  93C30010   LBU V1, 16(S8)
9D026F14  24020007   ADDIU V0, ZERO, 7
9D026F18  14620004   BNE V1, V0, 0x9D026F2C
9D026F1C  00000000   NOP
272:                 		return MPFS_INVALID_HANDLE;
9D026F20  240200FF   ADDIU V0, ZERO, 255
9D026F24  0B409C43   J 0x9D02710C
9D026F28  00000000   NOP
273:                 		
274:                 	// Read in hashes, and check remainder on a match.  Store 8 in cache for performance
275:                 	for(i = 0; i < numFiles; i++)
9D026F2C  A7C00014   SH ZERO, 20(S8)
9D026F30  0B409C3D   J 0x9D0270F4
9D026F34  00000000   NOP
9D0270E8  97C20014   LHU V0, 20(S8)
9D0270EC  24420001   ADDIU V0, V0, 1
9D0270F0  A7C20014   SH V0, 20(S8)
9D0270F4  97828126   LHU V0, -32474(GP)
9D0270F8  97C30014   LHU V1, 20(S8)
9D0270FC  0062102B   SLTU V0, V1, V0
9D027100  1440FF8D   BNE V0, ZERO, 0x9D026F38
9D027104  00000000   NOP
276:                 	{
277:                 		// For new block of 8, read in data
278:                 		if((i & 0x07) == 0u)
9D026F38  97C20014   LHU V0, 20(S8)
9D026F3C  30420007   ANDI V0, V0, 7
9D026F40  14400011   BNE V0, ZERO, 0x9D026F88
9D026F44  00000000   NOP
279:                 		{
280:                 			MPFSStubs[0].addr = 8 + i*2;
9D026F48  97C20014   LHU V0, 20(S8)
9D026F4C  24420004   ADDIU V0, V0, 4
9D026F50  00021040   SLL V0, V0, 1
9D026F54  00401821   ADDU V1, V0, ZERO
9D026F58  3C02A000   LUI V0, -24576
9D026F5C  AC43310C   SW V1, 12556(V0)
281:                 			MPFSStubs[0].bytesRem = 16;
9D026F60  3C02A000   LUI V0, -24576
9D026F64  2442310C   ADDIU V0, V0, 12556
9D026F68  24030010   ADDIU V1, ZERO, 16
9D026F6C  AC430004   SW V1, 4(V0)
282:                 			MPFSGetArray(0, (BYTE*)hashCache, 16);
9D026F70  27C2001C   ADDIU V0, S8, 28
9D026F74  00002021   ADDU A0, ZERO, ZERO
9D026F78  00402821   ADDU A1, V0, ZERO
9D026F7C  24060010   ADDIU A2, ZERO, 16
9D026F80  0F409D30   JAL MPFSGetArray
9D026F84  00000000   NOP
283:                 		}
284:                 		
285:                 		// If the hash matches, compare the full filename
286:                 		if(hashCache[i&0x07] == nameHash)
9D026F88  97C20014   LHU V0, 20(S8)
9D026F8C  30420007   ANDI V0, V0, 7
9D026F90  00021040   SLL V0, V0, 1
9D026F94  27C30010   ADDIU V1, S8, 16
9D026F98  00621021   ADDU V0, V1, V0
9D026F9C  9442000C   LHU V0, 12(V0)
9D026FA0  97C30012   LHU V1, 18(S8)
9D026FA4  14620050   BNE V1, V0, 0x9D0270E8
9D026FA8  00000000   NOP
287:                 		{
288:                 			_LoadFATRecord(i);
9D026FAC  97C20014   LHU V0, 20(S8)
9D026FB0  00402021   ADDU A0, V0, ZERO
9D026FB4  0F409EC4   JAL 0x9D027B10
9D026FB8  00000000   NOP
289:                 			MPFSStubs[0].addr = fatCache.string;
9D026FBC  3C02A000   LUI V0, -24576
9D026FC0  8C43316C   LW V1, 12652(V0)
9D026FC4  3C02A000   LUI V0, -24576
9D026FC8  AC43310C   SW V1, 12556(V0)
290:                 			MPFSStubs[0].bytesRem = 255;
9D026FCC  3C02A000   LUI V0, -24576
9D026FD0  2442310C   ADDIU V0, V0, 12556
9D026FD4  240300FF   ADDIU V1, ZERO, 255
9D026FD8  AC430004   SW V1, 4(V0)
291:                 			
292:                 			// Loop over filename to perform comparison
293:                 			for(ptr = cFile; *ptr != '\0'; ptr++)
9D026FDC  8FC20038   LW V0, 56(S8)
9D026FE0  AFC20018   SW V0, 24(S8)
9D026FE4  0B409C08   J 0x9D027020
9D026FE8  00000000   NOP
9D027014  8FC20018   LW V0, 24(S8)
9D027018  24420001   ADDIU V0, V0, 1
9D02701C  AFC20018   SW V0, 24(S8)
9D027020  8FC20018   LW V0, 24(S8)
9D027024  90420000   LBU V0, 0(V0)
9D027028  1440FFF0   BNE V0, ZERO, 0x9D026FEC
9D02702C  00000000   NOP
9D027030  0B409C0F   J 0x9D02703C
9D027034  00000000   NOP
294:                 			{
295:                 				MPFSGet(0, &c);
9D026FEC  27C2002C   ADDIU V0, S8, 44
9D026FF0  00002021   ADDU A0, ZERO, ZERO
9D026FF4  00402821   ADDU A1, V0, ZERO
9D026FF8  0F409CBA   JAL MPFSGet
9D026FFC  00000000   NOP
296:                 				if(*ptr != c)
9D027000  8FC20018   LW V0, 24(S8)
9D027004  90430000   LBU V1, 0(V0)
9D027008  93C2002C   LBU V0, 44(S8)
9D02700C  1462000A   BNE V1, V0, 0x9D027038
9D027010  00000000   NOP
297:                 					break;
9D027038  00000000   NOP
298:                 			}
299:                 			
300:                 			MPFSGet(0, &c);
9D02703C  27C2002C   ADDIU V0, S8, 44
9D027040  00002021   ADDU A0, ZERO, ZERO
9D027044  00402821   ADDU A1, V0, ZERO
9D027048  0F409CBA   JAL MPFSGet
9D02704C  00000000   NOP
301:                 
302:                 			if(c == '\0' && *ptr == '\0')
9D027050  93C2002C   LBU V0, 44(S8)
9D027054  14400024   BNE V0, ZERO, 0x9D0270E8
9D027058  00000000   NOP
9D02705C  8FC20018   LW V0, 24(S8)
9D027060  90420000   LBU V0, 0(V0)
9D027064  14400020   BNE V0, ZERO, 0x9D0270E8
9D027068  00000000   NOP
303:                 			{// Filename matches, so return true
304:                 				MPFSStubs[hMPFS].addr = fatCache.data;
9D02706C  93C50010   LBU A1, 16(S8)
9D027070  3C02A000   LUI V0, -24576
9D027074  2442316C   ADDIU V0, V0, 12652
9D027078  8C430004   LW V1, 4(V0)
9D02707C  3C02A000   LUI V0, -24576
9D027080  2404000C   ADDIU A0, ZERO, 12
9D027084  70A42002   MUL A0, A1, A0
9D027088  2442310C   ADDIU V0, V0, 12556
9D02708C  00821021   ADDU V0, A0, V0
9D027090  AC430000   SW V1, 0(V0)
305:                 				MPFSStubs[hMPFS].bytesRem = fatCache.len;
9D027094  93C50010   LBU A1, 16(S8)
9D027098  3C02A000   LUI V0, -24576
9D02709C  2442316C   ADDIU V0, V0, 12652
9D0270A0  8C430008   LW V1, 8(V0)
9D0270A4  3C02A000   LUI V0, -24576
9D0270A8  2444310C   ADDIU A0, V0, 12556
9D0270AC  2402000C   ADDIU V0, ZERO, 12
9D0270B0  70A21002   MUL V0, A1, V0
9D0270B4  00821021   ADDU V0, A0, V0
9D0270B8  AC430004   SW V1, 4(V0)
306:                 				MPFSStubs[hMPFS].fatID = i;
9D0270BC  93C40010   LBU A0, 16(S8)
9D0270C0  3C02A000   LUI V0, -24576
9D0270C4  2403000C   ADDIU V1, ZERO, 12
9D0270C8  70831802   MUL V1, A0, V1
9D0270CC  2442310C   ADDIU V0, V0, 12556
9D0270D0  00621021   ADDU V0, V1, V0
9D0270D4  97C30014   LHU V1, 20(S8)
9D0270D8  A4430008   SH V1, 8(V0)
307:                 				return hMPFS;
9D0270DC  93C20010   LBU V0, 16(S8)
9D0270E0  0B409C43   J 0x9D02710C
9D0270E4  00000000   NOP
308:                 			}
309:                 		}
310:                 	}
311:                 	
312:                 	// No file name matched, so return nothing
313:                 	return MPFS_INVALID_HANDLE;
9D027108  240200FF   ADDIU V0, ZERO, 255
314:                 }
9D02710C  03C0E821   ADDU SP, S8, ZERO
9D027110  8FBF0034   LW RA, 52(SP)
9D027114  8FBE0030   LW S8, 48(SP)
9D027118  27BD0038   ADDIU SP, SP, 56
9D02711C  03E00008   JR RA
9D027120  00000000   NOP
315:                 
316:                 /*****************************************************************************
317:                   Function:
318:                 	MPFS_HANDLE MPFSOpenROM(ROM BYTE* cFile) 
319:                 
320:                   Description:
321:                 	Opens a file in the MPFS2 file system.
322:                 	
323:                   Precondition:
324:                 	None
325:                 
326:                   Parameters:
327:                 	cFile - a null terminated file name to open
328:                 
329:                   Returns:
330:                 	An MPFS_HANDLE to the opened file if found, or MPFS_INVALID_HANDLE
331:                 	if the file could not be found or no free handles exist.
332:                 
333:                   Remarks:
334:                 	This function is aliased to MPFSOpen on non-PIC18 platforms.
335:                   ***************************************************************************/
336:                 #if defined(__18CXX)
337:                 MPFS_HANDLE MPFSOpenROM(ROM BYTE* cFile) 
338:                 {
339:                 	MPFS_HANDLE hMPFS;
340:                 	WORD nameHash, i;
341:                 	WORD hashCache[8];
342:                 	ROM BYTE *ptr;
343:                 	BYTE c;
344:                 	
345:                 	// Make sure MPFS is unlocked and we got a filename
346:                 	if(*cFile == '\0' || isMPFSLocked == TRUE)
347:                 		return MPFS_INVALID_HANDLE;
348:                 
349:                 	// Calculate the name hash to speed up searching
350:                 	for(nameHash = 0, ptr = cFile; *ptr != '\0'; ptr++)
351:                 	{
352:                 		nameHash += *ptr;
353:                 		nameHash <<= 1;
354:                 	}
355:                 	
356:                 	// Find a free file handle to use
357:                 	for(hMPFS = 1; hMPFS <= MAX_MPFS_HANDLES; hMPFS++)
358:                 		if(MPFSStubs[hMPFS].addr == MPFS_INVALID)
359:                 			break;
360:                 	if(hMPFS == MAX_MPFS_HANDLES)
361:                 		return MPFS_INVALID_HANDLE;
362:                 		
363:                 	// Read in hashes, and check remainder on a match.  Store 8 in cache for performance
364:                 	for(i = 0; i < numFiles; i++)
365:                 	{
366:                 		// For new block of 8, read in data
367:                 		if((i & 0x07) == 0u)
368:                 		{
369:                 			MPFSStubs[0].addr = 8 + i*2;
370:                 			MPFSStubs[0].bytesRem = 16;
371:                 			MPFSGetArray(0, (BYTE*)hashCache, 16);
372:                 		}
373:                 		
374:                 		// If the hash matches, compare the full filename
375:                 		if(hashCache[i&0x07] == nameHash)
376:                 		{
377:                 			_LoadFATRecord(i);
378:                 			MPFSStubs[0].addr = fatCache.string;
379:                 			MPFSStubs[0].bytesRem = 255;
380:                 			
381:                 			// Loop over filename to perform comparison
382:                 			for(ptr = cFile; *ptr != '\0'; ptr++)
383:                 			{
384:                 				MPFSGet(0, &c);
385:                 				if(*ptr != c)
386:                 					break;
387:                 			}
388:                 			
389:                 			MPFSGet(0, &c);
390:                 
391:                 			if(c == '\0' && *ptr == '\0')
392:                 			{// Filename matches, so return true
393:                 				MPFSStubs[hMPFS].addr = fatCache.data;
394:                 				MPFSStubs[hMPFS].bytesRem = fatCache.len;
395:                 				MPFSStubs[hMPFS].fatID = i;
396:                 				return hMPFS;
397:                 			}
398:                 		}
399:                 	}
400:                 	
401:                 	// No file name matched, so return nothing
402:                 	return MPFS_INVALID_HANDLE;
403:                 }
404:                 #endif
405:                 
406:                 /*****************************************************************************
407:                   Function:
408:                 	MPFS_HANDLE MPFSOpenID(WORD hFatID)
409:                 
410:                   Summary:
411:                 	Quickly re-opens a file.
412:                 
413:                   Description:
414:                 	Quickly re-opens a file in the MPFS2 file system.  Use this function
415:                 	along with MPFSGetID() to quickly re-open a file without tying up
416:                 	a permanent MPFSStub.
417:                 	
418:                   Precondition:
419:                 	None
420:                 
421:                   Parameters:
422:                 	hFatID - the ID of a previous opened file in the FAT
423:                 
424:                   Returns:
425:                 	An MPFS_HANDLE to the opened file if found, or MPFS_INVALID_HANDLE
426:                 	if the file could not be found or no free handles exist.
427:                   ***************************************************************************/
428:                 MPFS_HANDLE MPFSOpenID(WORD hFatID)
429:                 {
9D027124  27BDFFE0   ADDIU SP, SP, -32
9D027128  AFBF001C   SW RA, 28(SP)
9D02712C  AFBE0018   SW S8, 24(SP)
9D027130  03A0F021   ADDU S8, SP, ZERO
9D027134  00801021   ADDU V0, A0, ZERO
9D027138  A7C20020   SH V0, 32(S8)
430:                 	MPFS_HANDLE hMPFS;
431:                 	
432:                 	// Make sure MPFS is unlocked and we got a valid id
433:                 	if(isMPFSLocked == TRUE || hFatID > numFiles)
9D02713C  8F838120   LW V1, -32480(GP)
9D027140  24020001   ADDIU V0, ZERO, 1
9D027144  10620006   BEQ V1, V0, 0x9D027160
9D027148  00000000   NOP
9D02714C  97828126   LHU V0, -32474(GP)
9D027150  97C30020   LHU V1, 32(S8)
9D027154  0043102B   SLTU V0, V0, V1
9D027158  10400004   BEQ V0, ZERO, 0x9D02716C
9D02715C  00000000   NOP
434:                 		return MPFS_INVALID_HANDLE;
9D027160  240200FF   ADDIU V0, ZERO, 255
9D027164  0B409C9B   J 0x9D02726C
9D027168  00000000   NOP
435:                 
436:                 	// Find a free file handle to use
437:                 	for(hMPFS = 1; hMPFS <= MAX_MPFS_HANDLES; hMPFS++)
9D02716C  24020001   ADDIU V0, ZERO, 1
9D027170  A3C20010   SB V0, 16(S8)
9D027174  0B409C6C   J 0x9D0271B0
9D027178  00000000   NOP
9D0271A4  93C20010   LBU V0, 16(S8)
9D0271A8  24420001   ADDIU V0, V0, 1
9D0271AC  A3C20010   SB V0, 16(S8)
9D0271B0  93C20010   LBU V0, 16(S8)
9D0271B4  2C420008   SLTIU V0, V0, 8
9D0271B8  1440FFF0   BNE V0, ZERO, 0x9D02717C
9D0271BC  00000000   NOP
9D0271C0  0B409C73   J 0x9D0271CC
9D0271C4  00000000   NOP
438:                 		if(MPFSStubs[hMPFS].addr == MPFS_INVALID)
9D02717C  93C40010   LBU A0, 16(S8)
9D027180  3C02A000   LUI V0, -24576
9D027184  2403000C   ADDIU V1, ZERO, 12
9D027188  70831802   MUL V1, A0, V1
9D02718C  2442310C   ADDIU V0, V0, 12556
9D027190  00621021   ADDU V0, V1, V0
9D027194  8C430000   LW V1, 0(V0)
9D027198  2402FFFF   ADDIU V0, ZERO, -1
9D02719C  1062000A   BEQ V1, V0, 0x9D0271C8
9D0271A0  00000000   NOP
439:                 			break;
9D0271C8  00000000   NOP
440:                 	if(hMPFS == MAX_MPFS_HANDLES)
9D0271CC  93C30010   LBU V1, 16(S8)
9D0271D0  24020007   ADDIU V0, ZERO, 7
9D0271D4  14620004   BNE V1, V0, 0x9D0271E8
9D0271D8  00000000   NOP
441:                 		return MPFS_INVALID_HANDLE;
9D0271DC  240200FF   ADDIU V0, ZERO, 255
9D0271E0  0B409C9B   J 0x9D02726C
9D0271E4  00000000   NOP
442:                 	
443:                 	// Load the FAT record
444:                 	_LoadFATRecord(hFatID);
9D0271E8  97C20020   LHU V0, 32(S8)
9D0271EC  00402021   ADDU A0, V0, ZERO
9D0271F0  0F409EC4   JAL 0x9D027B10
9D0271F4  00000000   NOP
445:                 		
446:                 	// Set up the file handle
447:                 	MPFSStubs[hMPFS].fatID = hFatID;
9D0271F8  93C40010   LBU A0, 16(S8)
9D0271FC  3C02A000   LUI V0, -24576
9D027200  2403000C   ADDIU V1, ZERO, 12
9D027204  70831802   MUL V1, A0, V1
9D027208  2442310C   ADDIU V0, V0, 12556
9D02720C  00621021   ADDU V0, V1, V0
9D027210  97C30020   LHU V1, 32(S8)
9D027214  A4430008   SH V1, 8(V0)
448:                 	MPFSStubs[hMPFS].addr = fatCache.data;
9D027218  93C50010   LBU A1, 16(S8)
9D02721C  3C02A000   LUI V0, -24576
9D027220  2442316C   ADDIU V0, V0, 12652
9D027224  8C430004   LW V1, 4(V0)
9D027228  3C02A000   LUI V0, -24576
9D02722C  2404000C   ADDIU A0, ZERO, 12
9D027230  70A42002   MUL A0, A1, A0
9D027234  2442310C   ADDIU V0, V0, 12556
9D027238  00821021   ADDU V0, A0, V0
9D02723C  AC430000   SW V1, 0(V0)
449:                 	MPFSStubs[hMPFS].bytesRem = fatCache.len;
9D027240  93C50010   LBU A1, 16(S8)
9D027244  3C02A000   LUI V0, -24576
9D027248  2442316C   ADDIU V0, V0, 12652
9D02724C  8C430008   LW V1, 8(V0)
9D027250  3C02A000   LUI V0, -24576
9D027254  2444310C   ADDIU A0, V0, 12556
9D027258  2402000C   ADDIU V0, ZERO, 12
9D02725C  70A21002   MUL V0, A1, V0
9D027260  00821021   ADDU V0, A0, V0
9D027264  AC430004   SW V1, 4(V0)
450:                 	
451:                 	return hMPFS;
9D027268  93C20010   LBU V0, 16(S8)
452:                 }
9D02726C  03C0E821   ADDU SP, S8, ZERO
9D027270  8FBF001C   LW RA, 28(SP)
9D027274  8FBE0018   LW S8, 24(SP)
9D027278  27BD0020   ADDIU SP, SP, 32
9D02727C  03E00008   JR RA
9D027280  00000000   NOP
453:                 
454:                 /*****************************************************************************
455:                   Function:
456:                 	void MPFSClose(MPFS_HANDLE hMPFS)
457:                 
458:                   Summary:
459:                 	Closes a file.
460:                 
461:                   Description:
462:                 	Closes a file and releases its stub back to the pool of available 
463:                 	handles.
464:                 	
465:                   Precondition:
466:                 	None
467:                 
468:                   Parameters:
469:                 	hMPFS - the file handle to be closed
470:                 
471:                   Returns:
472:                 	None
473:                   ***************************************************************************/
474:                 void MPFSClose(MPFS_HANDLE hMPFS)
475:                 {
9D027284  27BDFFF8   ADDIU SP, SP, -8
9D027288  AFBE0004   SW S8, 4(SP)
9D02728C  03A0F021   ADDU S8, SP, ZERO
9D027290  00801021   ADDU V0, A0, ZERO
9D027294  A3C20008   SB V0, 8(S8)
476:                 	if(hMPFS != 0u && hMPFS <= MAX_MPFS_HANDLES)
9D027298  93C20008   LBU V0, 8(S8)
9D02729C  1040000D   BEQ V0, ZERO, 0x9D0272D4
9D0272A0  00000000   NOP
9D0272A4  93C20008   LBU V0, 8(S8)
9D0272A8  2C420008   SLTIU V0, V0, 8
9D0272AC  10400009   BEQ V0, ZERO, 0x9D0272D4
9D0272B0  00000000   NOP
477:                 	    MPFSStubs[hMPFS].addr = MPFS_INVALID;
9D0272B4  93C40008   LBU A0, 8(S8)
9D0272B8  3C02A000   LUI V0, -24576
9D0272BC  2403000C   ADDIU V1, ZERO, 12
9D0272C0  70831802   MUL V1, A0, V1
9D0272C4  2442310C   ADDIU V0, V0, 12556
9D0272C8  00621021   ADDU V0, V1, V0
9D0272CC  2403FFFF   ADDIU V1, ZERO, -1
9D0272D0  AC430000   SW V1, 0(V0)
478:                 }
9D0272D4  03C0E821   ADDU SP, S8, ZERO
9D0272D8  8FBE0004   LW S8, 4(SP)
9D0272DC  27BD0008   ADDIU SP, SP, 8
9D0272E0  03E00008   JR RA
9D0272E4  00000000   NOP
479:                 
480:                 
481:                 /****************************************************************************
482:                   Section:
483:                 	Data Reading Functions
484:                   ***************************************************************************/
485:                 
486:                 /*****************************************************************************
487:                   Function:
488:                 	BOOL MPFSGet(MPFS_HANDLE hMPFS, BYTE* c)
489:                 
490:                   Description:
491:                 	Reads a byte from a file.
492:                 	
493:                   Precondition:
494:                 	The file handle referenced by hMPFS is already open.
495:                 
496:                   Parameters:
497:                 	hMPFS - the file handle from which to read
498:                 	c - Where to store the byte that was read
499:                 
500:                   Return Values:
501:                 	TRUE - The byte was successfully read
502:                 	FALSE - No byte was read because either the handle was invalid or
503:                 	        the end of the file has been reached.
504:                   ***************************************************************************/
505:                 BOOL MPFSGet(MPFS_HANDLE hMPFS, BYTE* c)
506:                 {
9D0272E8  27BDFFF0   ADDIU SP, SP, -16
9D0272EC  AFBE000C   SW S8, 12(SP)
9D0272F0  03A0F021   ADDU S8, SP, ZERO
9D0272F4  00801021   ADDU V0, A0, ZERO
9D0272F8  AFC50014   SW A1, 20(S8)
9D0272FC  A3C20010   SB V0, 16(S8)
507:                 	// Make sure we're reading a valid address
508:                 	if(hMPFS > MAX_MPFS_HANDLES)
9D027300  93C20010   LBU V0, 16(S8)
9D027304  2C420008   SLTIU V0, V0, 8
9D027308  14400004   BNE V0, ZERO, 0x9D02731C
9D02730C  00000000   NOP
509:                 		return FALSE;
9D027310  00001021   ADDU V0, ZERO, ZERO
9D027314  0B409D2B   J 0x9D0274AC
9D027318  00000000   NOP
510:                 	if(	MPFSStubs[hMPFS].addr == MPFS_INVALID ||
9D02731C  93C40010   LBU A0, 16(S8)
9D027320  3C02A000   LUI V0, -24576
9D027324  2403000C   ADDIU V1, ZERO, 12
9D027328  70831802   MUL V1, A0, V1
9D02732C  2442310C   ADDIU V0, V0, 12556
9D027330  00621021   ADDU V0, V1, V0
9D027334  8C430000   LW V1, 0(V0)
9D027338  2402FFFF   ADDIU V0, ZERO, -1
9D02733C  1062000A   BEQ V1, V0, 0x9D027368
9D027340  00000000   NOP
9D027360  14400004   BNE V0, ZERO, 0x9D027374
9D027364  00000000   NOP
511:                 		MPFSStubs[hMPFS].bytesRem == 0u)
9D027344  93C40010   LBU A0, 16(S8)
9D027348  3C02A000   LUI V0, -24576
9D02734C  2443310C   ADDIU V1, V0, 12556
9D027350  2402000C   ADDIU V0, ZERO, 12
9D027354  70821002   MUL V0, A0, V0
9D027358  00621021   ADDU V0, V1, V0
9D02735C  8C420004   LW V0, 4(V0)
512:                 		return FALSE;
9D027368  00001021   ADDU V0, ZERO, ZERO
9D02736C  0B409D2B   J 0x9D0274AC
9D027370  00000000   NOP
513:                 
514:                 	if(c == NULL)
9D027374  8FC20014   LW V0, 20(S8)
9D027378  14400020   BNE V0, ZERO, 0x9D0273FC
9D02737C  00000000   NOP
515:                 	{
516:                 		MPFSStubs[hMPFS].addr++;
9D027380  93C50010   LBU A1, 16(S8)
9D027384  3C02A000   LUI V0, -24576
9D027388  2403000C   ADDIU V1, ZERO, 12
9D02738C  70A31802   MUL V1, A1, V1
9D027390  2442310C   ADDIU V0, V0, 12556
9D027394  00621021   ADDU V0, V1, V0
9D027398  8C420000   LW V0, 0(V0)
9D02739C  24430001   ADDIU V1, V0, 1
9D0273A0  3C02A000   LUI V0, -24576
9D0273A4  2404000C   ADDIU A0, ZERO, 12
9D0273A8  70A42002   MUL A0, A1, A0
9D0273AC  2442310C   ADDIU V0, V0, 12556
9D0273B0  00821021   ADDU V0, A0, V0
9D0273B4  AC430000   SW V1, 0(V0)
517:                 		MPFSStubs[hMPFS].bytesRem--;
9D0273B8  93C50010   LBU A1, 16(S8)
9D0273BC  3C02A000   LUI V0, -24576
9D0273C0  2443310C   ADDIU V1, V0, 12556
9D0273C4  2402000C   ADDIU V0, ZERO, 12
9D0273C8  70A21002   MUL V0, A1, V0
9D0273CC  00621021   ADDU V0, V1, V0
9D0273D0  8C420004   LW V0, 4(V0)
9D0273D4  2443FFFF   ADDIU V1, V0, -1
9D0273D8  3C02A000   LUI V0, -24576
9D0273DC  2444310C   ADDIU A0, V0, 12556
9D0273E0  2402000C   ADDIU V0, ZERO, 12
9D0273E4  70A21002   MUL V0, A1, V0
9D0273E8  00821021   ADDU V0, A0, V0
9D0273EC  AC430004   SW V1, 4(V0)
518:                 		return TRUE;
9D0273F0  24020001   ADDIU V0, ZERO, 1
9D0273F4  0B409D2B   J 0x9D0274AC
9D0273F8  00000000   NOP
519:                 	}
520:                 
521:                 
522:                     // Read function for EEPROM
523:                     #if defined(MPFS_USE_EEPROM)
524:                 	    // For performance, cache the last read address
525:                 		if(MPFSStubs[hMPFS].addr != lastRead+1)
526:                 			XEEBeginRead(MPFSStubs[hMPFS].addr + MPFS_HEAD);
527:                 		*c = XEERead();
528:                 		lastRead = MPFSStubs[hMPFS].addr;
529:                 		MPFSStubs[hMPFS].addr++;
530:                 	#elif defined(MPFS_USE_SPI_FLASH)
531:                 		SPIFlashReadArray(MPFSStubs[hMPFS].addr + MPFS_HEAD, c, 1);
532:                 		MPFSStubs[hMPFS].addr++;
533:                 	#else
534:                 		#if defined(__C30__)
535:                 		{
536:                 			DWORD addr;
537:                 			DWORD_VAL read;
538:                 			BYTE i;
539:                 	
540:                 			// MPFS Images are addressed by the byte; Program memory by the word.
541:                 			//
542:                 			// Flash program memory is 24 bits wide and only even words are
543:                 			// implemented.  The upper byte of the upper word is read as 0x00.
544:                 			// Address in program memory of any given byte is (MPFSAddr * 2) / 3
545:                 			//
546:                 			// We will read 24 bits at a time, but need to support using only 
547:                 			// fractions of the first and last byte.
548:                 			
549:                 			// Find the beginning address in program memory.
550:                 			addr = (MPFSStubs[hMPFS].addr / 3) << 1;
551:                 			
552:                 			// Find where to start in that first 3 bytes
553:                 			read.Val = (addr * 3) >> 1;
554:                 			if(read.Val == MPFSStubs[hMPFS].addr)
555:                 				i = 0;
556:                 			else if(read.Val+1 == MPFSStubs[hMPFS].addr)
557:                 				i = 1;
558:                 			else
559:                 				i = 2;
560:                 	
561:                 			// Add in the MPFS starting address offset
562:                 			addr += MPFS_HEAD;
563:                 			
564:                 			// Update the MPFS Handle
565:                 			MPFSStubs[hMPFS].addr++;
566:                 			
567:                 			// Read the DWORD 
568:                 			read.Val = ReadProgramMemory(addr & 0x00FFFFFF);
569:                 			*c = read.v[i];
570:                 			
571:                 		}
572:                 		#else
573:                 		{
574:                 			DWORD dwHITECHWorkaround = MPFS_HEAD;
9D0273FC  3C029D01   LUI V0, -25343
9D027400  24428474   ADDIU V0, V0, -31628
9D027404  AFC20000   SW V0, 0(S8)
575:                 	  	*c = *((ROM BYTE*)(MPFSStubs[hMPFS].addr+dwHITECHWorkaround));
9D027408  93C40010   LBU A0, 16(S8)
9D02740C  3C02A000   LUI V0, -24576
9D027410  2403000C   ADDIU V1, ZERO, 12
9D027414  70831802   MUL V1, A0, V1
9D027418  2442310C   ADDIU V0, V0, 12556
9D02741C  00621021   ADDU V0, V1, V0
9D027420  8C430000   LW V1, 0(V0)
9D027424  8FC20000   LW V0, 0(S8)
9D027428  00621021   ADDU V0, V1, V0
9D02742C  90430000   LBU V1, 0(V0)
9D027430  8FC20014   LW V0, 20(S8)
9D027434  A0430000   SB V1, 0(V0)
576:                 		    MPFSStubs[hMPFS].addr++;
9D027438  93C50010   LBU A1, 16(S8)
9D02743C  3C02A000   LUI V0, -24576
9D027440  2403000C   ADDIU V1, ZERO, 12
9D027444  70A31802   MUL V1, A1, V1
9D027448  2442310C   ADDIU V0, V0, 12556
9D02744C  00621021   ADDU V0, V1, V0
9D027450  8C420000   LW V0, 0(V0)
9D027454  24430001   ADDIU V1, V0, 1
9D027458  3C02A000   LUI V0, -24576
9D02745C  2404000C   ADDIU A0, ZERO, 12
9D027460  70A42002   MUL A0, A1, A0
9D027464  2442310C   ADDIU V0, V0, 12556
9D027468  00821021   ADDU V0, A0, V0
9D02746C  AC430000   SW V1, 0(V0)
577:                 		}
578:                 		#endif
579:                 	#endif
580:                 	
581:                 	MPFSStubs[hMPFS].bytesRem--;
9D027470  93C50010   LBU A1, 16(S8)
9D027474  3C02A000   LUI V0, -24576
9D027478  2443310C   ADDIU V1, V0, 12556
9D02747C  2402000C   ADDIU V0, ZERO, 12
9D027480  70A21002   MUL V0, A1, V0
9D027484  00621021   ADDU V0, V1, V0
9D027488  8C420004   LW V0, 4(V0)
9D02748C  2443FFFF   ADDIU V1, V0, -1
9D027490  3C02A000   LUI V0, -24576
9D027494  2444310C   ADDIU A0, V0, 12556
9D027498  2402000C   ADDIU V0, ZERO, 12
9D02749C  70A21002   MUL V0, A1, V0
9D0274A0  00821021   ADDU V0, A0, V0
9D0274A4  AC430004   SW V1, 4(V0)
582:                 	return TRUE;
9D0274A8  24020001   ADDIU V0, ZERO, 1
583:                 }
9D0274AC  03C0E821   ADDU SP, S8, ZERO
9D0274B0  8FBE000C   LW S8, 12(SP)
9D0274B4  27BD0010   ADDIU SP, SP, 16
9D0274B8  03E00008   JR RA
9D0274BC  00000000   NOP
584:                 
585:                 /*****************************************************************************
586:                   Function:
587:                 	WORD MPFSGetArray(MPFS_HANDLE hMPFS, BYTE* cData, WORD wLen)
588:                 
589:                   Description:
590:                 	Reads a series of bytes from a file.
591:                 	
592:                   Precondition:
593:                 	The file handle referenced by hMPFS is already open.
594:                 
595:                   Parameters:
596:                 	hMPFS - the file handle from which to read
597:                 	cData - where to store the bytes that were read
598:                 	wLen - how many bytes to read
599:                 
600:                   Returns:
601:                 	The number of bytes successfully read.  If this is less than wLen, 
602:                 	an EOF occurred while attempting to read.
603:                   ***************************************************************************/
604:                 WORD MPFSGetArray(MPFS_HANDLE hMPFS, BYTE* cData, WORD wLen)
605:                 {	
9D0274C0  27BDFFE0   ADDIU SP, SP, -32
9D0274C4  AFBF001C   SW RA, 28(SP)
9D0274C8  AFBE0018   SW S8, 24(SP)
9D0274CC  03A0F021   ADDU S8, SP, ZERO
9D0274D0  00801821   ADDU V1, A0, ZERO
9D0274D4  AFC50024   SW A1, 36(S8)
9D0274D8  00C01021   ADDU V0, A2, ZERO
9D0274DC  A3C30020   SB V1, 32(S8)
9D0274E0  A7C20028   SH V0, 40(S8)
606:                 	// Make sure we're reading a valid address
607:                 	if(hMPFS > MAX_MPFS_HANDLES)
9D0274E4  93C20020   LBU V0, 32(S8)
9D0274E8  2C420008   SLTIU V0, V0, 8
9D0274EC  14400004   BNE V0, ZERO, 0x9D027500
9D0274F0  00000000   NOP
608:                 		return 0;
9D0274F4  00001021   ADDU V0, ZERO, ZERO
9D0274F8  0B409DBD   J 0x9D0276F4
9D0274FC  00000000   NOP
609:                 		
610:                 	// Determine how many we can actually read
611:                 	if(wLen > MPFSStubs[hMPFS].bytesRem)
9D027500  97C30028   LHU V1, 40(S8)
9D027504  93C50020   LBU A1, 32(S8)
9D027508  3C02A000   LUI V0, -24576
9D02750C  2444310C   ADDIU A0, V0, 12556
9D027510  2402000C   ADDIU V0, ZERO, 12
9D027514  70A21002   MUL V0, A1, V0
9D027518  00821021   ADDU V0, A0, V0
9D02751C  8C420004   LW V0, 4(V0)
9D027520  0043102B   SLTU V0, V0, V1
9D027524  10400009   BEQ V0, ZERO, 0x9D02754C
9D027528  00000000   NOP
612:                 		wLen = MPFSStubs[hMPFS].bytesRem;
9D02752C  93C40020   LBU A0, 32(S8)
9D027530  3C02A000   LUI V0, -24576
9D027534  2443310C   ADDIU V1, V0, 12556
9D027538  2402000C   ADDIU V0, ZERO, 12
9D02753C  70821002   MUL V0, A0, V0
9D027540  00621021   ADDU V0, V1, V0
9D027544  8C420004   LW V0, 4(V0)
9D027548  A7C20028   SH V0, 40(S8)
613:                 
614:                 	// Make sure we're reading a valid address
615:                 	if(MPFSStubs[hMPFS].addr == MPFS_INVALID || wLen == 0u)
9D02754C  93C40020   LBU A0, 32(S8)
9D027550  3C02A000   LUI V0, -24576
9D027554  2403000C   ADDIU V1, ZERO, 12
9D027558  70831802   MUL V1, A0, V1
9D02755C  2442310C   ADDIU V0, V0, 12556
9D027560  00621021   ADDU V0, V1, V0
9D027564  8C430000   LW V1, 0(V0)
9D027568  2402FFFF   ADDIU V0, ZERO, -1
9D02756C  10620004   BEQ V1, V0, 0x9D027580
9D027570  00000000   NOP
9D027574  97C20028   LHU V0, 40(S8)
9D027578  14400004   BNE V0, ZERO, 0x9D02758C
9D02757C  00000000   NOP
616:                 		return 0;
9D027580  00001021   ADDU V0, ZERO, ZERO
9D027584  0B409DBD   J 0x9D0276F4
9D027588  00000000   NOP
617:                 		
618:                 	if(cData == NULL)
9D02758C  8FC20024   LW V0, 36(S8)
9D027590  14400024   BNE V0, ZERO, 0x9D027624
9D027594  00000000   NOP
619:                 	{
620:                 		MPFSStubs[hMPFS].addr += wLen;
9D027598  93C50020   LBU A1, 32(S8)
9D02759C  93C40020   LBU A0, 32(S8)
9D0275A0  3C02A000   LUI V0, -24576
9D0275A4  2403000C   ADDIU V1, ZERO, 12
9D0275A8  70831802   MUL V1, A0, V1
9D0275AC  2442310C   ADDIU V0, V0, 12556
9D0275B0  00621021   ADDU V0, V1, V0
9D0275B4  8C430000   LW V1, 0(V0)
9D0275B8  97C20028   LHU V0, 40(S8)
9D0275BC  00621821   ADDU V1, V1, V0
9D0275C0  3C02A000   LUI V0, -24576
9D0275C4  2404000C   ADDIU A0, ZERO, 12
9D0275C8  70A42002   MUL A0, A1, A0
9D0275CC  2442310C   ADDIU V0, V0, 12556
9D0275D0  00821021   ADDU V0, A0, V0
9D0275D4  AC430000   SW V1, 0(V0)
621:                 		MPFSStubs[hMPFS].bytesRem -= wLen;
9D0275D8  93C50020   LBU A1, 32(S8)
9D0275DC  93C40020   LBU A0, 32(S8)
9D0275E0  3C02A000   LUI V0, -24576
9D0275E4  2443310C   ADDIU V1, V0, 12556
9D0275E8  2402000C   ADDIU V0, ZERO, 12
9D0275EC  70821002   MUL V0, A0, V0
9D0275F0  00621021   ADDU V0, V1, V0
9D0275F4  8C430004   LW V1, 4(V0)
9D0275F8  97C20028   LHU V0, 40(S8)
9D0275FC  00621823   SUBU V1, V1, V0
9D027600  3C02A000   LUI V0, -24576
9D027604  2444310C   ADDIU A0, V0, 12556
9D027608  2402000C   ADDIU V0, ZERO, 12
9D02760C  70A21002   MUL V0, A1, V0
9D027610  00821021   ADDU V0, A0, V0
9D027614  AC430004   SW V1, 4(V0)
622:                 		return wLen;
9D027618  97C20028   LHU V0, 40(S8)
9D02761C  0B409DBD   J 0x9D0276F4
9D027620  00000000   NOP
623:                 	}
624:                 	
625:                 	// Read the data
626:                 	#if defined(MPFS_USE_EEPROM)
627:                 		XEEReadArray(MPFSStubs[hMPFS].addr+MPFS_HEAD, cData, wLen);
628:                 		MPFSStubs[hMPFS].addr += wLen;
629:                 		MPFSStubs[hMPFS].bytesRem -= wLen;
630:                 		lastRead = MPFS_INVALID;
631:                 	#elif defined(MPFS_USE_SPI_FLASH)
632:                 		SPIFlashReadArray(MPFSStubs[hMPFS].addr+MPFS_HEAD, cData, wLen);
633:                 		MPFSStubs[hMPFS].addr += wLen;
634:                 		MPFSStubs[hMPFS].bytesRem -= wLen;
635:                 	#else
636:                 		#if defined(__C30__)
637:                 		{
638:                 			DWORD addr;
639:                 			DWORD_VAL read;
640:                 			WORD count;
641:                 			BYTE i;
642:                 	
643:                 			// MPFS Images are addressed by the byte; Program memory by the word.
644:                 			//
645:                 			// Flash program memory is 24 bits wide and only even words are
646:                 			// implemented.  The upper byte of the upper word is read as 0x00.
647:                 			// Address in program memory of any given byte is (MPFSAddr * 2) / 3
648:                 			//
649:                 			// We will read 24 bits at a time, but need to support using only 
650:                 			// fractions of the first and last byte.
651:                 			
652:                 			// Find the beginning address in program memory.
653:                 			addr = (MPFSStubs[hMPFS].addr / 3) << 1;
654:                 			
655:                 			// Find where to start in that first 3 bytes
656:                 			read.Val = (addr * 3) >> 1;
657:                 			if(read.Val == MPFSStubs[hMPFS].addr)
658:                 				i = 0;
659:                 			else if(read.Val+1 == MPFSStubs[hMPFS].addr)
660:                 				i = 1;
661:                 			else
662:                 				i = 2;
663:                 	
664:                 			// Add in the MPFS starting address offset
665:                 			addr += MPFS_HEAD;
666:                 			
667:                 			// Update the MPFS Handle
668:                 			MPFSStubs[hMPFS].addr += wLen;
669:                 			MPFSStubs[hMPFS].bytesRem -= wLen;
670:                 	
671:                 			// Read the first DWORD 
672:                 			read.Val = ReadProgramMemory(addr & 0x00FFFFFF);
673:                 			addr += 2;
674:                 	
675:                 			// Copy values as needed
676:                 			for(count = wLen; count > 0; cData++, count--)
677:                 			{
678:                 				// Copy the next value in
679:                 				*cData = read.v[i++];
680:                 				
681:                 				// Check if a new DWORD is needed
682:                 				if(i == 3 && count != 1)
683:                 				{// Read in a new DWORD
684:                 					read.Val = ReadProgramMemory(addr & 0x00FFFFFF);
685:                 					addr += 2;
686:                 					i = 0;
687:                 				}
688:                 			}
689:                 			
690:                 		}
691:                 		#else
692:                 		{
693:                 			DWORD dwHITECHWorkaround = MPFS_HEAD;
9D027624  3C029D01   LUI V0, -25343
9D027628  24428474   ADDIU V0, V0, -31628
9D02762C  AFC20010   SW V0, 16(S8)
694:                 			memcpypgm2ram(cData, (ROM void*)(MPFSStubs[hMPFS].addr + dwHITECHWorkaround), wLen);
9D027630  93C40020   LBU A0, 32(S8)
9D027634  3C02A000   LUI V0, -24576
9D027638  2403000C   ADDIU V1, ZERO, 12
9D02763C  70831802   MUL V1, A0, V1
9D027640  2442310C   ADDIU V0, V0, 12556
9D027644  00621021   ADDU V0, V1, V0
9D027648  8C430000   LW V1, 0(V0)
9D02764C  8FC20010   LW V0, 16(S8)
9D027650  00621021   ADDU V0, V1, V0
9D027654  00401821   ADDU V1, V0, ZERO
9D027658  97C20028   LHU V0, 40(S8)
9D02765C  8FC40024   LW A0, 36(S8)
9D027660  00602821   ADDU A1, V1, ZERO
9D027664  00403021   ADDU A2, V0, ZERO
9D027668  0F40D298   JAL 0x9D034A60
9D02766C  00000000   NOP
695:                 			MPFSStubs[hMPFS].addr += wLen;
9D027670  93C50020   LBU A1, 32(S8)
9D027674  93C40020   LBU A0, 32(S8)
9D027678  3C02A000   LUI V0, -24576
9D02767C  2403000C   ADDIU V1, ZERO, 12
9D027680  70831802   MUL V1, A0, V1
9D027684  2442310C   ADDIU V0, V0, 12556
9D027688  00621021   ADDU V0, V1, V0
9D02768C  8C430000   LW V1, 0(V0)
9D027690  97C20028   LHU V0, 40(S8)
9D027694  00621821   ADDU V1, V1, V0
9D027698  3C02A000   LUI V0, -24576
9D02769C  2404000C   ADDIU A0, ZERO, 12
9D0276A0  70A42002   MUL A0, A1, A0
9D0276A4  2442310C   ADDIU V0, V0, 12556
9D0276A8  00821021   ADDU V0, A0, V0
9D0276AC  AC430000   SW V1, 0(V0)
696:                 			MPFSStubs[hMPFS].bytesRem -= wLen;
9D0276B0  93C50020   LBU A1, 32(S8)
9D0276B4  93C40020   LBU A0, 32(S8)
9D0276B8  3C02A000   LUI V0, -24576
9D0276BC  2443310C   ADDIU V1, V0, 12556
9D0276C0  2402000C   ADDIU V0, ZERO, 12
9D0276C4  70821002   MUL V0, A0, V0
9D0276C8  00621021   ADDU V0, V1, V0
9D0276CC  8C430004   LW V1, 4(V0)
9D0276D0  97C20028   LHU V0, 40(S8)
9D0276D4  00621823   SUBU V1, V1, V0
9D0276D8  3C02A000   LUI V0, -24576
9D0276DC  2444310C   ADDIU A0, V0, 12556
9D0276E0  2402000C   ADDIU V0, ZERO, 12
9D0276E4  70A21002   MUL V0, A1, V0
9D0276E8  00821021   ADDU V0, A0, V0
9D0276EC  AC430004   SW V1, 4(V0)
697:                 		}
698:                 		#endif
699:                 	#endif
700:                 	
701:                 	return wLen;
9D0276F0  97C20028   LHU V0, 40(S8)
702:                 }
9D0276F4  03C0E821   ADDU SP, S8, ZERO
9D0276F8  8FBF001C   LW RA, 28(SP)
9D0276FC  8FBE0018   LW S8, 24(SP)
9D027700  27BD0020   ADDIU SP, SP, 32
9D027704  03E00008   JR RA
9D027708  00000000   NOP
703:                 
704:                 /*****************************************************************************
705:                   Function:
706:                 	BOOL MPFSGetLong(MPFS_HANDLE hMPFS, DWORD* ul)
707:                 
708:                   Description:
709:                 	Reads a DWORD or Long value from the MPFS.
710:                 	
711:                   Precondition:
712:                 	The file handle referenced by hMPFS is already open.
713:                 
714:                   Parameters:
715:                 	hMPFS - the file handle from which to read
716:                 	ul - where to store the DWORD or long value that was read
717:                 
718:                   Returns:
719:                 	TRUE - The byte was successfully read
720:                 	FALSE - No byte was read because either the handle was invalid or
721:                 	        the end of the file has been reached.
722:                   ***************************************************************************/
723:                 BOOL MPFSGetLong(MPFS_HANDLE hMPFS, DWORD* ul)
724:                 {
9D02770C  27BDFFE8   ADDIU SP, SP, -24
9D027710  AFBF0014   SW RA, 20(SP)
9D027714  AFBE0010   SW S8, 16(SP)
9D027718  03A0F021   ADDU S8, SP, ZERO
9D02771C  00801021   ADDU V0, A0, ZERO
9D027720  AFC5001C   SW A1, 28(S8)
9D027724  A3C20018   SB V0, 24(S8)
725:                 	return ( MPFSGetArray(hMPFS, (BYTE*)ul, 4) == 4u );
9D027728  93C30018   LBU V1, 24(S8)
9D02772C  8FC2001C   LW V0, 28(S8)
9D027730  00602021   ADDU A0, V1, ZERO
9D027734  00402821   ADDU A1, V0, ZERO
9D027738  24060004   ADDIU A2, ZERO, 4
9D02773C  0F409D30   JAL MPFSGetArray
9D027740  00000000   NOP
9D027744  38420004   XORI V0, V0, 4
9D027748  2C420001   SLTIU V0, V0, 1
726:                 }
9D02774C  03C0E821   ADDU SP, S8, ZERO
9D027750  8FBF0014   LW RA, 20(SP)
9D027754  8FBE0010   LW S8, 16(SP)
9D027758  27BD0018   ADDIU SP, SP, 24
9D02775C  03E00008   JR RA
9D027760  00000000   NOP
727:                 
728:                 /*****************************************************************************
729:                   Function:
730:                 	BOOL MPFSSeek(MPFS_HANDLE hMPFS, DWORD dwOffset, MPFS_SEEK_MODE tMode)
731:                 
732:                   Description:
733:                 	Moves the current read pointer to a new location.
734:                 	
735:                   Precondition:
736:                 	The file handle referenced by hMPFS is already open.
737:                 
738:                   Parameters:
739:                 	hMPFS - the file handle to seek with
740:                 	dwOffset - offset from the specified position in the specified direction
741:                 	tMode - one of the MPFS_SEEK_MODE constants
742:                 
743:                   Returns:
744:                 	TRUE - the seek was successful
745:                 	FALSE - either the new location or the handle itself was invalid
746:                   ***************************************************************************/
747:                 BOOL MPFSSeek(MPFS_HANDLE hMPFS, DWORD dwOffset, MPFS_SEEK_MODE tMode)
748:                 {
9D027764  27BDFFD8   ADDIU SP, SP, -40
9D027768  AFBF0024   SW RA, 36(SP)
9D02776C  AFBE0020   SW S8, 32(SP)
9D027770  AFB0001C   SW S0, 28(SP)
9D027774  03A0F021   ADDU S8, SP, ZERO
9D027778  00801021   ADDU V0, A0, ZERO
9D02777C  AFC5002C   SW A1, 44(S8)
9D027780  AFC60030   SW A2, 48(S8)
9D027784  A3C20028   SB V0, 40(S8)
749:                 	DWORD temp;
750:                 	
751:                 	// Make sure a valid file is open
752:                 	if(hMPFS > MAX_MPFS_HANDLES)
9D027788  93C20028   LBU V0, 40(S8)
9D02778C  2C420008   SLTIU V0, V0, 8
9D027790  14400004   BNE V0, ZERO, 0x9D0277A4
9D027794  00000000   NOP
753:                 		return FALSE;
9D027798  00001021   ADDU V0, ZERO, ZERO
9D02779C  0B409EBD   J 0x9D027AF4
9D0277A0  00000000   NOP
754:                 	if(MPFSStubs[hMPFS].addr == MPFS_INVALID)
9D0277A4  93C40028   LBU A0, 40(S8)
9D0277A8  3C02A000   LUI V0, -24576
9D0277AC  2403000C   ADDIU V1, ZERO, 12
9D0277B0  70831802   MUL V1, A0, V1
9D0277B4  2442310C   ADDIU V0, V0, 12556
9D0277B8  00621021   ADDU V0, V1, V0
9D0277BC  8C430000   LW V1, 0(V0)
9D0277C0  2402FFFF   ADDIU V0, ZERO, -1
9D0277C4  14620004   BNE V1, V0, 0x9D0277D8
9D0277C8  00000000   NOP
755:                 		return FALSE;
9D0277CC  00001021   ADDU V0, ZERO, ZERO
9D0277D0  0B409EBD   J 0x9D027AF4
9D0277D4  00000000   NOP
756:                 
757:                 	switch(tMode)
9D0277D8  8FC20030   LW V0, 48(S8)
9D0277DC  24030001   ADDIU V1, ZERO, 1
9D0277E0  1043009D   BEQ V0, V1, 0x9D027A58
9D0277E4  00000000   NOP
9D0277E8  2C430001   SLTIU V1, V0, 1
9D0277EC  14600009   BNE V1, ZERO, 0x9D027814
9D0277F0  00000000   NOP
9D0277F4  24030002   ADDIU V1, ZERO, 2
9D0277F8  1043002E   BEQ V0, V1, 0x9D0278B4
9D0277FC  00000000   NOP
9D027800  24030003   ADDIU V1, ZERO, 3
9D027804  1043005C   BEQ V0, V1, 0x9D027978
9D027808  00000000   NOP
9D02780C  0B409EBC   J 0x9D027AF0
9D027810  00000000   NOP
758:                 	{
759:                 		// Seek offset bytes from start
760:                 		case MPFS_SEEK_START:
761:                 			temp = MPFSGetSize(hMPFS);
9D027814  93C20028   LBU V0, 40(S8)
9D027818  00402021   ADDU A0, V0, ZERO
9D02781C  0F409F7D   JAL MPFSGetSize
9D027820  00000000   NOP
9D027824  AFC20010   SW V0, 16(S8)
762:                 			if(dwOffset > temp)
9D027828  8FC3002C   LW V1, 44(S8)
9D02782C  8FC20010   LW V0, 16(S8)
9D027830  0043102B   SLTU V0, V0, V1
9D027834  10400004   BEQ V0, ZERO, 0x9D027848
9D027838  00000000   NOP
763:                 				return FALSE;
9D02783C  00001021   ADDU V0, ZERO, ZERO
9D027840  0B409EBD   J 0x9D027AF4
9D027844  00000000   NOP
764:                 			
765:                 			MPFSStubs[hMPFS].addr = MPFSGetStartAddr(hMPFS) + dwOffset;
9D027848  93D00028   LBU S0, 40(S8)
9D02784C  93C20028   LBU V0, 40(S8)
9D027850  00402021   ADDU A0, V0, ZERO
9D027854  0F409FCF   JAL MPFSGetStartAddr
9D027858  00000000   NOP
9D02785C  00401821   ADDU V1, V0, ZERO
9D027860  8FC2002C   LW V0, 44(S8)
9D027864  00621821   ADDU V1, V1, V0
9D027868  3C02A000   LUI V0, -24576
9D02786C  2404000C   ADDIU A0, ZERO, 12
9D027870  72042002   MUL A0, S0, A0
9D027874  2442310C   ADDIU V0, V0, 12556
9D027878  00821021   ADDU V0, A0, V0
9D02787C  AC430000   SW V1, 0(V0)
766:                 			MPFSStubs[hMPFS].bytesRem = temp - dwOffset;
9D027880  93C50028   LBU A1, 40(S8)
9D027884  8FC30010   LW V1, 16(S8)
9D027888  8FC2002C   LW V0, 44(S8)
9D02788C  00621823   SUBU V1, V1, V0
9D027890  3C02A000   LUI V0, -24576
9D027894  2444310C   ADDIU A0, V0, 12556
9D027898  2402000C   ADDIU V0, ZERO, 12
9D02789C  70A21002   MUL V0, A1, V0
9D0278A0  00821021   ADDU V0, A0, V0
9D0278A4  AC430004   SW V1, 4(V0)
767:                 			return TRUE;
9D0278A8  24020001   ADDIU V0, ZERO, 1
9D0278AC  0B409EBD   J 0x9D027AF4
9D0278B0  00000000   NOP
768:                 		
769:                 		// Seek forwards offset bytes
770:                 		case MPFS_SEEK_FORWARD:
771:                 			if(dwOffset > MPFSStubs[hMPFS].bytesRem)
9D0278B4  93C40028   LBU A0, 40(S8)
9D0278B8  3C02A000   LUI V0, -24576
9D0278BC  2443310C   ADDIU V1, V0, 12556
9D0278C0  2402000C   ADDIU V0, ZERO, 12
9D0278C4  70821002   MUL V0, A0, V0
9D0278C8  00621021   ADDU V0, V1, V0
9D0278CC  8C430004   LW V1, 4(V0)
9D0278D0  8FC2002C   LW V0, 44(S8)
9D0278D4  0062102B   SLTU V0, V1, V0
9D0278D8  10400004   BEQ V0, ZERO, 0x9D0278EC
9D0278DC  00000000   NOP
772:                 				return FALSE;
9D0278E0  00001021   ADDU V0, ZERO, ZERO
9D0278E4  0B409EBD   J 0x9D027AF4
9D0278E8  00000000   NOP
773:                 			
774:                 			MPFSStubs[hMPFS].addr += dwOffset;
9D0278EC  93C50028   LBU A1, 40(S8)
9D0278F0  93C40028   LBU A0, 40(S8)
9D0278F4  3C02A000   LUI V0, -24576
9D0278F8  2403000C   ADDIU V1, ZERO, 12
9D0278FC  70831802   MUL V1, A0, V1
9D027900  2442310C   ADDIU V0, V0, 12556
9D027904  00621021   ADDU V0, V1, V0
9D027908  8C430000   LW V1, 0(V0)
9D02790C  8FC2002C   LW V0, 44(S8)
9D027910  00621821   ADDU V1, V1, V0
9D027914  3C02A000   LUI V0, -24576
9D027918  2404000C   ADDIU A0, ZERO, 12
9D02791C  70A42002   MUL A0, A1, A0
9D027920  2442310C   ADDIU V0, V0, 12556
9D027924  00821021   ADDU V0, A0, V0
9D027928  AC430000   SW V1, 0(V0)
775:                 			MPFSStubs[hMPFS].bytesRem -= dwOffset;
9D02792C  93C50028   LBU A1, 40(S8)
9D027930  93C40028   LBU A0, 40(S8)
9D027934  3C02A000   LUI V0, -24576
9D027938  2443310C   ADDIU V1, V0, 12556
9D02793C  2402000C   ADDIU V0, ZERO, 12
9D027940  70821002   MUL V0, A0, V0
9D027944  00621021   ADDU V0, V1, V0
9D027948  8C430004   LW V1, 4(V0)
9D02794C  8FC2002C   LW V0, 44(S8)
9D027950  00621823   SUBU V1, V1, V0
9D027954  3C02A000   LUI V0, -24576
9D027958  2444310C   ADDIU A0, V0, 12556
9D02795C  2402000C   ADDIU V0, ZERO, 12
9D027960  70A21002   MUL V0, A1, V0
9D027964  00821021   ADDU V0, A0, V0
9D027968  AC430004   SW V1, 4(V0)
776:                 			return TRUE;
9D02796C  24020001   ADDIU V0, ZERO, 1
9D027970  0B409EBD   J 0x9D027AF4
9D027974  00000000   NOP
777:                 		
778:                 		// Seek backwards offset bytes
779:                 		case MPFS_SEEK_REWIND:
780:                 			temp = MPFSGetStartAddr(hMPFS);
9D027978  93C20028   LBU V0, 40(S8)
9D02797C  00402021   ADDU A0, V0, ZERO
9D027980  0F409FCF   JAL MPFSGetStartAddr
9D027984  00000000   NOP
9D027988  AFC20010   SW V0, 16(S8)
781:                 			if(MPFSStubs[hMPFS].addr < temp + dwOffset)
9D02798C  93C40028   LBU A0, 40(S8)
9D027990  3C02A000   LUI V0, -24576
9D027994  2403000C   ADDIU V1, ZERO, 12
9D027998  70831802   MUL V1, A0, V1
9D02799C  2442310C   ADDIU V0, V0, 12556
9D0279A0  00621021   ADDU V0, V1, V0
9D0279A4  8C430000   LW V1, 0(V0)
9D0279A8  8FC40010   LW A0, 16(S8)
9D0279AC  8FC2002C   LW V0, 44(S8)
9D0279B0  00821021   ADDU V0, A0, V0
9D0279B4  0062102B   SLTU V0, V1, V0
9D0279B8  10400004   BEQ V0, ZERO, 0x9D0279CC
9D0279BC  00000000   NOP
782:                 				return FALSE;
9D0279C0  00001021   ADDU V0, ZERO, ZERO
9D0279C4  0B409EBD   J 0x9D027AF4
9D0279C8  00000000   NOP
783:                 			
784:                 			MPFSStubs[hMPFS].addr -= dwOffset;
9D0279CC  93C50028   LBU A1, 40(S8)
9D0279D0  93C40028   LBU A0, 40(S8)
9D0279D4  3C02A000   LUI V0, -24576
9D0279D8  2403000C   ADDIU V1, ZERO, 12
9D0279DC  70831802   MUL V1, A0, V1
9D0279E0  2442310C   ADDIU V0, V0, 12556
9D0279E4  00621021   ADDU V0, V1, V0
9D0279E8  8C430000   LW V1, 0(V0)
9D0279EC  8FC2002C   LW V0, 44(S8)
9D0279F0  00621823   SUBU V1, V1, V0
9D0279F4  3C02A000   LUI V0, -24576
9D0279F8  2404000C   ADDIU A0, ZERO, 12
9D0279FC  70A42002   MUL A0, A1, A0
9D027A00  2442310C   ADDIU V0, V0, 12556
9D027A04  00821021   ADDU V0, A0, V0
9D027A08  AC430000   SW V1, 0(V0)
785:                 			MPFSStubs[hMPFS].bytesRem += dwOffset;
9D027A0C  93C50028   LBU A1, 40(S8)
9D027A10  93C40028   LBU A0, 40(S8)
9D027A14  3C02A000   LUI V0, -24576
9D027A18  2443310C   ADDIU V1, V0, 12556
9D027A1C  2402000C   ADDIU V0, ZERO, 12
9D027A20  70821002   MUL V0, A0, V0
9D027A24  00621021   ADDU V0, V1, V0
9D027A28  8C430004   LW V1, 4(V0)
9D027A2C  8FC2002C   LW V0, 44(S8)
9D027A30  00621821   ADDU V1, V1, V0
9D027A34  3C02A000   LUI V0, -24576
9D027A38  2444310C   ADDIU A0, V0, 12556
9D027A3C  2402000C   ADDIU V0, ZERO, 12
9D027A40  70A21002   MUL V0, A1, V0
9D027A44  00821021   ADDU V0, A0, V0
9D027A48  AC430004   SW V1, 4(V0)
786:                 			return TRUE;
9D027A4C  24020001   ADDIU V0, ZERO, 1
9D027A50  0B409EBD   J 0x9D027AF4
9D027A54  00000000   NOP
787:                 		
788:                 		// Seek so that offset bytes remain in file
789:                 		case MPFS_SEEK_END:
790:                 			temp = MPFSGetSize(hMPFS);
9D027A58  93C20028   LBU V0, 40(S8)
9D027A5C  00402021   ADDU A0, V0, ZERO
9D027A60  0F409F7D   JAL MPFSGetSize
9D027A64  00000000   NOP
9D027A68  AFC20010   SW V0, 16(S8)
791:                 			if(dwOffset > temp)
9D027A6C  8FC3002C   LW V1, 44(S8)
9D027A70  8FC20010   LW V0, 16(S8)
9D027A74  0043102B   SLTU V0, V0, V1
9D027A78  10400004   BEQ V0, ZERO, 0x9D027A8C
9D027A7C  00000000   NOP
792:                 				return FALSE;
9D027A80  00001021   ADDU V0, ZERO, ZERO
9D027A84  0B409EBD   J 0x9D027AF4
9D027A88  00000000   NOP
793:                 			
794:                 			MPFSStubs[hMPFS].addr = MPFSGetEndAddr(hMPFS) - dwOffset;
9D027A8C  93D00028   LBU S0, 40(S8)
9D027A90  93C20028   LBU V0, 40(S8)
9D027A94  00402021   ADDU A0, V0, ZERO
9D027A98  0F409FFC   JAL MPFSGetEndAddr
9D027A9C  00000000   NOP
9D027AA0  00401821   ADDU V1, V0, ZERO
9D027AA4  8FC2002C   LW V0, 44(S8)
9D027AA8  00621823   SUBU V1, V1, V0
9D027AAC  3C02A000   LUI V0, -24576
9D027AB0  2404000C   ADDIU A0, ZERO, 12
9D027AB4  72042002   MUL A0, S0, A0
9D027AB8  2442310C   ADDIU V0, V0, 12556
9D027ABC  00821021   ADDU V0, A0, V0
9D027AC0  AC430000   SW V1, 0(V0)
795:                 			MPFSStubs[hMPFS].bytesRem = dwOffset;
9D027AC4  93C40028   LBU A0, 40(S8)
9D027AC8  3C02A000   LUI V0, -24576
9D027ACC  2443310C   ADDIU V1, V0, 12556
9D027AD0  2402000C   ADDIU V0, ZERO, 12
9D027AD4  70821002   MUL V0, A0, V0
9D027AD8  00621021   ADDU V0, V1, V0
9D027ADC  8FC3002C   LW V1, 44(S8)
9D027AE0  AC430004   SW V1, 4(V0)
796:                 			return TRUE;
9D027AE4  24020001   ADDIU V0, ZERO, 1
9D027AE8  0B409EBD   J 0x9D027AF4
9D027AEC  00000000   NOP
797:                 		
798:                 		default:
799:                 			return FALSE;
9D027AF0  00001021   ADDU V0, ZERO, ZERO
800:                 	}
801:                 }
9D027AF4  03C0E821   ADDU SP, S8, ZERO
9D027AF8  8FBF0024   LW RA, 36(SP)
9D027AFC  8FBE0020   LW S8, 32(SP)
9D027B00  8FB0001C   LW S0, 28(SP)
9D027B04  27BD0028   ADDIU SP, SP, 40
9D027B08  03E00008   JR RA
9D027B0C  00000000   NOP
802:                 
803:                 
804:                 /****************************************************************************
805:                   Section:
806:                 	Data Writing Functions
807:                   ***************************************************************************/
808:                 
809:                 /*****************************************************************************
810:                   Function:
811:                 	MPFS_HANDLE MPFSFormat(void)
812:                 	
813:                   Summary:
814:                 	Prepares the MPFS image for writing.
815:                 
816:                   Description:
817:                 	Prepares the MPFS image for writing and locks the image so that other
818:                 	processes may not access it.
819:                 	
820:                   Precondition:
821:                 	None
822:                 
823:                   Parameters:
824:                 	None
825:                 
826:                   Returns:
827:                 	An MPFS handle that can be used for MPFSPut commands, or 
828:                 	MPFS_INVALID_HANDLE when the EEPROM failed to initialize for writing.
829:                 
830:                   Remarks:
831:                 	In order to prevent misreads, the MPFS will be inaccessible until 
832:                 	MPFSClose is called.  This function is not available when the MPFS 
833:                 	is stored in internal Flash program memory.
834:                   ***************************************************************************/
835:                 #if defined(MPFS_USE_EEPROM) || defined(MPFS_USE_SPI_FLASH)
836:                 MPFS_HANDLE MPFSFormat(void)
837:                 {
838:                 
839:                 	BYTE i;
840:                 	
841:                 	// Close all files
842:                 	for(i = 0; i < MAX_MPFS_HANDLES; i++)
843:                 		MPFSStubs[i].addr = MPFS_INVALID;
844:                 	
845:                 	// Lock the image
846:                 	isMPFSLocked = TRUE;
847:                 	
848:                 	#if defined(MPFS_USE_EEPROM)
849:                 		// Set FAT ptr for writing
850:                 		MPFSStubs[0].addr = 0;
851:                 		MPFSStubs[0].fatID = 0xffff;
852:                 		MPFSStubs[0].bytesRem = MPFS_WRITE_PAGE_SIZE - ( ((BYTE)MPFSStubs[0].addr+MPFS_HEAD) & (MPFS_WRITE_PAGE_SIZE-1) );
853:                 		
854:                 		// Set up EEPROM for writing
855:                 		if( XEEBeginWrite(MPFSStubs[0].addr+MPFS_HEAD) == XEE_SUCCESS )
856:                 			return 0x00;
857:                 	
858:                 		return MPFS_INVALID_HANDLE;
859:                 	#else
860:                 		// Set up SPI Flash for writing
861:                 		SPIFlashBeginWrite(MPFS_HEAD);
862:                 		return 0x00;
863:                 	#endif
864:                 }
865:                 #endif
866:                 	
867:                 /*****************************************************************************
868:                   Function:
869:                 	WORD MPFSPutArray(MPFS_HANDLE hMPFS, BYTE *cData, WORD wLen)
870:                 
871:                   Description:
872:                 	Writes an array of data to the MPFS image.
873:                 	
874:                   Precondition:
875:                 	MPFSFormat was sucessfully called.
876:                 
877:                   Parameters:
878:                 	hMPFS - the file handle for writing
879:                 	cData - the array of bytes to write
880:                 	wLen - how many bytes to write
881:                 
882:                   Returns:
883:                 	The number of bytes successfully written.
884:                 
885:                   Remarks:
886:                 	For EEPROM, the actual write may not initialize until the internal write 
887:                 	page is full.  To ensure that previously written data gets stored, 
888:                 	MPFSPutEnd must be called after the last call to MPFSPutArray.
889:                   ***************************************************************************/
890:                 #if defined(MPFS_USE_EEPROM) || defined(MPFS_USE_SPI_FLASH)
891:                 WORD MPFSPutArray(MPFS_HANDLE hMPFS, BYTE* cData, WORD wLen)
892:                 {
893:                 	#if defined(MPFS_USE_EEPROM)
894:                 		// Write to the EEPROM
895:                 		WORD count;
896:                 		
897:                 		for(count = 0; count < wLen; count++)
898:                 		{
899:                 			XEEWrite(cData[count]);
900:                 			
901:                 			MPFSStubs[hMPFS].addr++;
902:                 			MPFSStubs[hMPFS].bytesRem--;
903:                 			
904:                 			if(MPFSStubs[hMPFS].bytesRem == 0u)
905:                 			{
906:                 				MPFSPutEnd(FALSE);
907:                 				isMPFSLocked = TRUE;
908:                 				XEEBeginWrite(MPFSStubs[hMPFS].addr+MPFS_HEAD);
909:                 				MPFSStubs[hMPFS].bytesRem = MPFS_WRITE_PAGE_SIZE;
910:                 			}
911:                 		}
912:                 		
913:                 		return count;
914:                 	
915:                 	#else
916:                 		// Write to the SPI Flash
917:                 		SPIFlashWriteArray(cData, wLen);
918:                 		return wLen;
919:                 	#endif
920:                 }
921:                 #endif
922:                 
923:                 /*****************************************************************************
924:                   Function:
925:                 	void MPFSPutEnd(void)
926:                 
927:                   Description:
928:                 	Finalizes an MPFS writing operation.
929:                 	
930:                   Precondition:
931:                 	MPFSFormat and MPFSPutArray were sucessfully called.
932:                 
933:                   Parameters:
934:                 	final - TRUE if the application is done writing, FALSE if MPFS2 called
935:                 		this function locally.
936:                 
937:                   Returns:
938:                 	None
939:                   ***************************************************************************/
940:                 #if defined(MPFS_USE_EEPROM) || defined(MPFS_USE_SPI_FLASH)
941:                 void MPFSPutEnd(BOOL final)
942:                 {
943:                 	isMPFSLocked = FALSE;
944:                 	
945:                 	#if defined(MPFS_USE_EEPROM)
946:                 	    XEEEndWrite();
947:                     	while(XEEIsBusy());
948:                     #endif
949:                     
950:                 	if(final)
951:                 		_Validate();
952:                 }
953:                 #endif
954:                 
955:                 
956:                 /****************************************************************************
957:                   Section:
958:                 	Meta Data Accessors
959:                   ***************************************************************************/
960:                 
961:                 /*****************************************************************************
962:                   Function:
963:                 	static void _LoadFATRecord(WORD fatID)
964:                 
965:                   Description:
966:                 	Loads the FAT record for a specified handle.
967:                 	
968:                   Precondition:
969:                 	None
970:                 
971:                   Parameters:
972:                 	fatID - the ID of the file whose FAT is to be loaded
973:                 
974:                   Returns:
975:                 	None
976:                 
977:                   Remarks:
978:                 	The FAT record will be stored in fatCache.
979:                   ***************************************************************************/
980:                 static void _LoadFATRecord(WORD fatID)
981:                 {
9D027B10  27BDFFE8   ADDIU SP, SP, -24
9D027B14  AFBF0014   SW RA, 20(SP)
9D027B18  AFBE0010   SW S8, 16(SP)
9D027B1C  03A0F021   ADDU S8, SP, ZERO
9D027B20  00801021   ADDU V0, A0, ZERO
9D027B24  A7C20018   SH V0, 24(S8)
982:                 	if(fatID == fatCacheID || fatID >= numFiles)
9D027B28  97828124   LHU V0, -32476(GP)
9D027B2C  97C30018   LHU V1, 24(S8)
9D027B30  1062001F   BEQ V1, V0, 0x9D027BB0
9D027B34  00000000   NOP
9D027B38  97828126   LHU V0, -32474(GP)
9D027B3C  97C30018   LHU V1, 24(S8)
9D027B40  0062102B   SLTU V0, V1, V0
9D027B44  1040001D   BEQ V0, ZERO, 0x9D027BBC
9D027B48  00000000   NOP
983:                 		return;
9D027BB0  00000000   NOP
9D027BB4  0B409EF0   J 0x9D027BC0
9D027BB8  00000000   NOP
9D027BBC  00000000   NOP
984:                 	
985:                 	// Read the FAT record to the cache
986:                 	MPFSStubs[0].bytesRem = 22;
9D027B4C  3C02A000   LUI V0, -24576
9D027B50  2442310C   ADDIU V0, V0, 12556
9D027B54  24030016   ADDIU V1, ZERO, 22
9D027B58  AC430004   SW V1, 4(V0)
987:                 	MPFSStubs[0].addr = 8 + numFiles*2 + fatID*22;
9D027B5C  97828126   LHU V0, -32474(GP)
9D027B60  24420004   ADDIU V0, V0, 4
9D027B64  97C40018   LHU A0, 24(S8)
9D027B68  2403000B   ADDIU V1, ZERO, 11
9D027B6C  70831802   MUL V1, A0, V1
9D027B70  00431021   ADDU V0, V0, V1
9D027B74  00021040   SLL V0, V0, 1
9D027B78  00401821   ADDU V1, V0, ZERO
9D027B7C  3C02A000   LUI V0, -24576
9D027B80  AC43310C   SW V1, 12556(V0)
988:                 	MPFSGetArray(0, (BYTE*)&fatCache, 22);
9D027B84  3C02A000   LUI V0, -24576
9D027B88  2442316C   ADDIU V0, V0, 12652
9D027B8C  00002021   ADDU A0, ZERO, ZERO
9D027B90  00402821   ADDU A1, V0, ZERO
9D027B94  24060016   ADDIU A2, ZERO, 22
9D027B98  0F409D30   JAL MPFSGetArray
9D027B9C  00000000   NOP
989:                 	fatCacheID = fatID;
9D027BA0  97C20018   LHU V0, 24(S8)
9D027BA4  A7828124   SH V0, -32476(GP)
9D027BA8  0B409EF0   J 0x9D027BC0
9D027BAC  00000000   NOP
990:                 }
9D027BC0  03C0E821   ADDU SP, S8, ZERO
9D027BC4  8FBF0014   LW RA, 20(SP)
9D027BC8  8FBE0010   LW S8, 16(SP)
9D027BCC  27BD0018   ADDIU SP, SP, 24
9D027BD0  03E00008   JR RA
9D027BD4  00000000   NOP
991:                 
992:                 /*****************************************************************************
993:                   Function:
994:                 	DWORD MPFSGetTimestamp(MPFS_HANDLE hMPFS)
995:                 
996:                   Description:
997:                 	Reads the timestamp for the specified file.
998:                 	
999:                   Precondition:
1000:                	The file handle referenced by hMPFS is already open.
1001:                
1002:                  Parameters:
1003:                	hMPFS - the file handle from which to read the metadata
1004:                
1005:                  Returns:
1006:                	The timestamp that was read as a DWORD
1007:                  ***************************************************************************/
1008:                DWORD MPFSGetTimestamp(MPFS_HANDLE hMPFS)
1009:                {
9D027BD8  27BDFFE8   ADDIU SP, SP, -24
9D027BDC  AFBF0014   SW RA, 20(SP)
9D027BE0  AFBE0010   SW S8, 16(SP)
9D027BE4  03A0F021   ADDU S8, SP, ZERO
9D027BE8  00801021   ADDU V0, A0, ZERO
9D027BEC  A3C20018   SB V0, 24(S8)
1010:                	// Make sure a valid file is open
1011:                	if(hMPFS > MAX_MPFS_HANDLES)
9D027BF0  93C20018   LBU V0, 24(S8)
9D027BF4  2C420008   SLTIU V0, V0, 8
9D027BF8  14400004   BNE V0, ZERO, 0x9D027C0C
9D027BFC  00000000   NOP
1012:                		return 0x00000000;
9D027C00  00001021   ADDU V0, ZERO, ZERO
9D027C04  0B409F1D   J 0x9D027C74
9D027C08  00000000   NOP
1013:                	if(MPFSStubs[hMPFS].addr == MPFS_INVALID)
9D027C0C  93C40018   LBU A0, 24(S8)
9D027C10  3C02A000   LUI V0, -24576
9D027C14  2403000C   ADDIU V1, ZERO, 12
9D027C18  70831802   MUL V1, A0, V1
9D027C1C  2442310C   ADDIU V0, V0, 12556
9D027C20  00621021   ADDU V0, V1, V0
9D027C24  8C430000   LW V1, 0(V0)
9D027C28  2402FFFF   ADDIU V0, ZERO, -1
9D027C2C  14620004   BNE V1, V0, 0x9D027C40
9D027C30  00000000   NOP
1014:                		return 0x00000000;
9D027C34  00001021   ADDU V0, ZERO, ZERO
9D027C38  0B409F1D   J 0x9D027C74
9D027C3C  00000000   NOP
1015:                	
1016:                	// Move to the point for reading
1017:                	_LoadFATRecord(MPFSStubs[hMPFS].fatID);
9D027C40  93C40018   LBU A0, 24(S8)
9D027C44  3C02A000   LUI V0, -24576
9D027C48  2403000C   ADDIU V1, ZERO, 12
9D027C4C  70831802   MUL V1, A0, V1
9D027C50  2442310C   ADDIU V0, V0, 12556
9D027C54  00621021   ADDU V0, V1, V0
9D027C58  94420008   LHU V0, 8(V0)
9D027C5C  00402021   ADDU A0, V0, ZERO
9D027C60  0F409EC4   JAL 0x9D027B10
9D027C64  00000000   NOP
1018:                	return fatCache.timestamp;
9D027C68  3C02A000   LUI V0, -24576
9D027C6C  2442316C   ADDIU V0, V0, 12652
9D027C70  8C42000C   LW V0, 12(V0)
1019:                }
9D027C74  03C0E821   ADDU SP, S8, ZERO
9D027C78  8FBF0014   LW RA, 20(SP)
9D027C7C  8FBE0010   LW S8, 16(SP)
9D027C80  27BD0018   ADDIU SP, SP, 24
9D027C84  03E00008   JR RA
9D027C88  00000000   NOP
1020:                
1021:                /*****************************************************************************
1022:                  Function:
1023:                	DWORD MPFSGetMicrotime(MPFS_HANDLE hMPFS)
1024:                
1025:                  Description:
1026:                	Reads the microtime portion of a file's timestamp.
1027:                	
1028:                  Precondition:
1029:                	The file handle referenced by hMPFS is already open.
1030:                
1031:                  Parameters:
1032:                	hMPFS - the file handle from which to read the metadata
1033:                
1034:                  Returns:
1035:                	The microtime that was read as a DWORD
1036:                  ***************************************************************************/
1037:                DWORD MPFSGetMicrotime(MPFS_HANDLE hMPFS)
1038:                {
9D027C8C  27BDFFE8   ADDIU SP, SP, -24
9D027C90  AFBF0014   SW RA, 20(SP)
9D027C94  AFBE0010   SW S8, 16(SP)
9D027C98  03A0F021   ADDU S8, SP, ZERO
9D027C9C  00801021   ADDU V0, A0, ZERO
9D027CA0  A3C20018   SB V0, 24(S8)
1039:                	// Make sure a valid file is open
1040:                	if(hMPFS > MAX_MPFS_HANDLES)
9D027CA4  93C20018   LBU V0, 24(S8)
9D027CA8  2C420008   SLTIU V0, V0, 8
9D027CAC  14400004   BNE V0, ZERO, 0x9D027CC0
9D027CB0  00000000   NOP
1041:                		return 0x00000000;
9D027CB4  00001021   ADDU V0, ZERO, ZERO
9D027CB8  0B409F4A   J 0x9D027D28
9D027CBC  00000000   NOP
1042:                	if(MPFSStubs[hMPFS].addr == MPFS_INVALID)
9D027CC0  93C40018   LBU A0, 24(S8)
9D027CC4  3C02A000   LUI V0, -24576
9D027CC8  2403000C   ADDIU V1, ZERO, 12
9D027CCC  70831802   MUL V1, A0, V1
9D027CD0  2442310C   ADDIU V0, V0, 12556
9D027CD4  00621021   ADDU V0, V1, V0
9D027CD8  8C430000   LW V1, 0(V0)
9D027CDC  2402FFFF   ADDIU V0, ZERO, -1
9D027CE0  14620004   BNE V1, V0, 0x9D027CF4
9D027CE4  00000000   NOP
1043:                		return 0x00000000;
9D027CE8  00001021   ADDU V0, ZERO, ZERO
9D027CEC  0B409F4A   J 0x9D027D28
9D027CF0  00000000   NOP
1044:                	
1045:                	// Move to the point for reading
1046:                	_LoadFATRecord(MPFSStubs[hMPFS].fatID);
9D027CF4  93C40018   LBU A0, 24(S8)
9D027CF8  3C02A000   LUI V0, -24576
9D027CFC  2403000C   ADDIU V1, ZERO, 12
9D027D00  70831802   MUL V1, A0, V1
9D027D04  2442310C   ADDIU V0, V0, 12556
9D027D08  00621021   ADDU V0, V1, V0
9D027D0C  94420008   LHU V0, 8(V0)
9D027D10  00402021   ADDU A0, V0, ZERO
9D027D14  0F409EC4   JAL 0x9D027B10
9D027D18  00000000   NOP
1047:                	return fatCache.microtime;
9D027D1C  3C02A000   LUI V0, -24576
9D027D20  2442316C   ADDIU V0, V0, 12652
9D027D24  8C420010   LW V0, 16(V0)
1048:                }
9D027D28  03C0E821   ADDU SP, S8, ZERO
9D027D2C  8FBF0014   LW RA, 20(SP)
9D027D30  8FBE0010   LW S8, 16(SP)
9D027D34  27BD0018   ADDIU SP, SP, 24
9D027D38  03E00008   JR RA
9D027D3C  00000000   NOP
1049:                
1050:                /*****************************************************************************
1051:                  Function:
1052:                	WORD MPFSGetFlags(MPFS_HANDLE hMPFS)
1053:                
1054:                  Description:
1055:                	Reads a file's flags.
1056:                	
1057:                  Precondition:
1058:                	The file handle referenced by hMPFS is already open.
1059:                
1060:                  Parameters:
1061:                	hMPFS - the file handle from which to read the metadata
1062:                
1063:                  Returns:
1064:                	The flags that were associated with the file
1065:                  ***************************************************************************/
1066:                WORD MPFSGetFlags(MPFS_HANDLE hMPFS)
1067:                {
9D027D40  27BDFFE8   ADDIU SP, SP, -24
9D027D44  AFBF0014   SW RA, 20(SP)
9D027D48  AFBE0010   SW S8, 16(SP)
9D027D4C  03A0F021   ADDU S8, SP, ZERO
9D027D50  00801021   ADDU V0, A0, ZERO
9D027D54  A3C20018   SB V0, 24(S8)
1068:                	// Make sure a valid file is open
1069:                	if(hMPFS > MAX_MPFS_HANDLES)
9D027D58  93C20018   LBU V0, 24(S8)
9D027D5C  2C420008   SLTIU V0, V0, 8
9D027D60  14400004   BNE V0, ZERO, 0x9D027D74
9D027D64  00000000   NOP
1070:                		return 0x0000;
9D027D68  00001021   ADDU V0, ZERO, ZERO
9D027D6C  0B409F77   J 0x9D027DDC
9D027D70  00000000   NOP
1071:                	if(MPFSStubs[hMPFS].addr == MPFS_INVALID)
9D027D74  93C40018   LBU A0, 24(S8)
9D027D78  3C02A000   LUI V0, -24576
9D027D7C  2403000C   ADDIU V1, ZERO, 12
9D027D80  70831802   MUL V1, A0, V1
9D027D84  2442310C   ADDIU V0, V0, 12556
9D027D88  00621021   ADDU V0, V1, V0
9D027D8C  8C430000   LW V1, 0(V0)
9D027D90  2402FFFF   ADDIU V0, ZERO, -1
9D027D94  14620004   BNE V1, V0, 0x9D027DA8
9D027D98  00000000   NOP
1072:                		return 0x0000;
9D027D9C  00001021   ADDU V0, ZERO, ZERO
9D027DA0  0B409F77   J 0x9D027DDC
9D027DA4  00000000   NOP
1073:                	
1074:                	//move to the point for reading
1075:                	_LoadFATRecord(MPFSStubs[hMPFS].fatID);
9D027DA8  93C40018   LBU A0, 24(S8)
9D027DAC  3C02A000   LUI V0, -24576
9D027DB0  2403000C   ADDIU V1, ZERO, 12
9D027DB4  70831802   MUL V1, A0, V1
9D027DB8  2442310C   ADDIU V0, V0, 12556
9D027DBC  00621021   ADDU V0, V1, V0
9D027DC0  94420008   LHU V0, 8(V0)
9D027DC4  00402021   ADDU A0, V0, ZERO
9D027DC8  0F409EC4   JAL 0x9D027B10
9D027DCC  00000000   NOP
1076:                	return fatCache.flags;
9D027DD0  3C02A000   LUI V0, -24576
9D027DD4  2442316C   ADDIU V0, V0, 12652
9D027DD8  94420014   LHU V0, 20(V0)
1077:                }
9D027DDC  03C0E821   ADDU SP, S8, ZERO
9D027DE0  8FBF0014   LW RA, 20(SP)
9D027DE4  8FBE0010   LW S8, 16(SP)
9D027DE8  27BD0018   ADDIU SP, SP, 24
9D027DEC  03E00008   JR RA
9D027DF0  00000000   NOP
1078:                
1079:                /*****************************************************************************
1080:                  Function:
1081:                	DWORD MPFSGetSize(MPFS_HANDLE hMPFS)
1082:                
1083:                  Description:
1084:                	Reads the size of a file.
1085:                	
1086:                  Precondition:
1087:                	The file handle referenced by hMPFS is already open.
1088:                
1089:                  Parameters:
1090:                	hMPFS - the file handle from which to read the metadata
1091:                
1092:                  Returns:
1093:                	The size that was read as a DWORD
1094:                  ***************************************************************************/
1095:                DWORD MPFSGetSize(MPFS_HANDLE hMPFS)
1096:                {
9D027DF4  27BDFFE8   ADDIU SP, SP, -24
9D027DF8  AFBF0014   SW RA, 20(SP)
9D027DFC  AFBE0010   SW S8, 16(SP)
9D027E00  03A0F021   ADDU S8, SP, ZERO
9D027E04  00801021   ADDU V0, A0, ZERO
9D027E08  A3C20018   SB V0, 24(S8)
1097:                	// Make sure a valid file is open
1098:                	if(hMPFS > MAX_MPFS_HANDLES)
9D027E0C  93C20018   LBU V0, 24(S8)
9D027E10  2C420008   SLTIU V0, V0, 8
9D027E14  14400004   BNE V0, ZERO, 0x9D027E28
9D027E18  00000000   NOP
1099:                		return 0x00000000;
9D027E1C  00001021   ADDU V0, ZERO, ZERO
9D027E20  0B409FA4   J 0x9D027E90
9D027E24  00000000   NOP
1100:                	if(MPFSStubs[hMPFS].addr == MPFS_INVALID)
9D027E28  93C40018   LBU A0, 24(S8)
9D027E2C  3C02A000   LUI V0, -24576
9D027E30  2403000C   ADDIU V1, ZERO, 12
9D027E34  70831802   MUL V1, A0, V1
9D027E38  2442310C   ADDIU V0, V0, 12556
9D027E3C  00621021   ADDU V0, V1, V0
9D027E40  8C430000   LW V1, 0(V0)
9D027E44  2402FFFF   ADDIU V0, ZERO, -1
9D027E48  14620004   BNE V1, V0, 0x9D027E5C
9D027E4C  00000000   NOP
1101:                		return 0x00000000;
9D027E50  00001021   ADDU V0, ZERO, ZERO
9D027E54  0B409FA4   J 0x9D027E90
9D027E58  00000000   NOP
1102:                	
1103:                	// Move to the point for reading
1104:                	_LoadFATRecord(MPFSStubs[hMPFS].fatID);
9D027E5C  93C40018   LBU A0, 24(S8)
9D027E60  3C02A000   LUI V0, -24576
9D027E64  2403000C   ADDIU V1, ZERO, 12
9D027E68  70831802   MUL V1, A0, V1
9D027E6C  2442310C   ADDIU V0, V0, 12556
9D027E70  00621021   ADDU V0, V1, V0
9D027E74  94420008   LHU V0, 8(V0)
9D027E78  00402021   ADDU A0, V0, ZERO
9D027E7C  0F409EC4   JAL 0x9D027B10
9D027E80  00000000   NOP
1105:                	return fatCache.len;
9D027E84  3C02A000   LUI V0, -24576
9D027E88  2442316C   ADDIU V0, V0, 12652
9D027E8C  8C420008   LW V0, 8(V0)
1106:                }
9D027E90  03C0E821   ADDU SP, S8, ZERO
9D027E94  8FBF0014   LW RA, 20(SP)
9D027E98  8FBE0010   LW S8, 16(SP)
9D027E9C  27BD0018   ADDIU SP, SP, 24
9D027EA0  03E00008   JR RA
9D027EA4  00000000   NOP
1107:                
1108:                /*****************************************************************************
1109:                  Function:
1110:                	DWORD MPFSGetBytesRem(MPFS_HANDLE hMPFS)
1111:                
1112:                  Description:
1113:                	Determines how many bytes remain to be read.
1114:                	
1115:                  Precondition:
1116:                	The file handle referenced by hMPFS is already open.
1117:                
1118:                  Parameters:
1119:                	hMPFS - the file handle from which to read the metadata
1120:                
1121:                  Returns:
1122:                	The number of bytes remaining in the file as a DWORD
1123:                  ***************************************************************************/
1124:                DWORD MPFSGetBytesRem(MPFS_HANDLE hMPFS)
1125:                {
9D027EA8  27BDFFF8   ADDIU SP, SP, -8
9D027EAC  AFBE0004   SW S8, 4(SP)
9D027EB0  03A0F021   ADDU S8, SP, ZERO
9D027EB4  00801021   ADDU V0, A0, ZERO
9D027EB8  A3C20008   SB V0, 8(S8)
1126:                	// Make sure a valid file is open
1127:                	if(hMPFS > MAX_MPFS_HANDLES)
9D027EBC  93C20008   LBU V0, 8(S8)
9D027EC0  2C420008   SLTIU V0, V0, 8
9D027EC4  14400004   BNE V0, ZERO, 0x9D027ED8
9D027EC8  00000000   NOP
1128:                		return 0x00000000;
9D027ECC  00001021   ADDU V0, ZERO, ZERO
9D027ED0  0B409FCA   J 0x9D027F28
9D027ED4  00000000   NOP
1129:                	if(MPFSStubs[hMPFS].addr == MPFS_INVALID)
9D027ED8  93C40008   LBU A0, 8(S8)
9D027EDC  3C02A000   LUI V0, -24576
9D027EE0  2403000C   ADDIU V1, ZERO, 12
9D027EE4  70831802   MUL V1, A0, V1
9D027EE8  2442310C   ADDIU V0, V0, 12556
9D027EEC  00621021   ADDU V0, V1, V0
9D027EF0  8C430000   LW V1, 0(V0)
9D027EF4  2402FFFF   ADDIU V0, ZERO, -1
9D027EF8  14620004   BNE V1, V0, 0x9D027F0C
9D027EFC  00000000   NOP
1130:                		return 0x00000000;
9D027F00  00001021   ADDU V0, ZERO, ZERO
9D027F04  0B409FCA   J 0x9D027F28
9D027F08  00000000   NOP
1131:                		
1132:                	return MPFSStubs[hMPFS].bytesRem;	
9D027F0C  93C40008   LBU A0, 8(S8)
9D027F10  3C02A000   LUI V0, -24576
9D027F14  2443310C   ADDIU V1, V0, 12556
9D027F18  2402000C   ADDIU V0, ZERO, 12
9D027F1C  70821002   MUL V0, A0, V0
9D027F20  00621021   ADDU V0, V1, V0
9D027F24  8C420004   LW V0, 4(V0)
1133:                }
9D027F28  03C0E821   ADDU SP, S8, ZERO
9D027F2C  8FBE0004   LW S8, 4(SP)
9D027F30  27BD0008   ADDIU SP, SP, 8
9D027F34  03E00008   JR RA
9D027F38  00000000   NOP
1134:                
1135:                /*****************************************************************************
1136:                  Function:
1137:                	MPFS_PTR MPFSGetStartAddr(MPFS_HANDLE hMPFS)
1138:                
1139:                  Description:
1140:                	Reads the starting address of a file.
1141:                	
1142:                  Precondition:
1143:                	The file handle referenced by hMPFS is already open.
1144:                
1145:                  Parameters:
1146:                	hMPFS - the file handle from which to read the metadata
1147:                
1148:                  Returns:
1149:                	The starting address of the file in the MPFS image
1150:                  ***************************************************************************/
1151:                MPFS_PTR MPFSGetStartAddr(MPFS_HANDLE hMPFS)
1152:                {
9D027F3C  27BDFFE8   ADDIU SP, SP, -24
9D027F40  AFBF0014   SW RA, 20(SP)
9D027F44  AFBE0010   SW S8, 16(SP)
9D027F48  03A0F021   ADDU S8, SP, ZERO
9D027F4C  00801021   ADDU V0, A0, ZERO
9D027F50  A3C20018   SB V0, 24(S8)
1153:                	// Make sure a valid file is open
1154:                	if(hMPFS > MAX_MPFS_HANDLES)
9D027F54  93C20018   LBU V0, 24(S8)
9D027F58  2C420008   SLTIU V0, V0, 8
9D027F5C  14400004   BNE V0, ZERO, 0x9D027F70
9D027F60  00000000   NOP
1155:                		return 0;
9D027F64  00001021   ADDU V0, ZERO, ZERO
9D027F68  0B409FF6   J 0x9D027FD8
9D027F6C  00000000   NOP
1156:                	if(MPFSStubs[hMPFS].addr == MPFS_INVALID)
9D027F70  93C40018   LBU A0, 24(S8)
9D027F74  3C02A000   LUI V0, -24576
9D027F78  2403000C   ADDIU V1, ZERO, 12
9D027F7C  70831802   MUL V1, A0, V1
9D027F80  2442310C   ADDIU V0, V0, 12556
9D027F84  00621021   ADDU V0, V1, V0
9D027F88  8C430000   LW V1, 0(V0)
9D027F8C  2402FFFF   ADDIU V0, ZERO, -1
9D027F90  14620004   BNE V1, V0, 0x9D027FA4
9D027F94  00000000   NOP
1157:                		return MPFS_INVALID;
9D027F98  2402FFFF   ADDIU V0, ZERO, -1
9D027F9C  0B409FF6   J 0x9D027FD8
9D027FA0  00000000   NOP
1158:                	
1159:                	// Move to the point for reading
1160:                	_LoadFATRecord(MPFSStubs[hMPFS].fatID);
9D027FA4  93C40018   LBU A0, 24(S8)
9D027FA8  3C02A000   LUI V0, -24576
9D027FAC  2403000C   ADDIU V1, ZERO, 12
9D027FB0  70831802   MUL V1, A0, V1
9D027FB4  2442310C   ADDIU V0, V0, 12556
9D027FB8  00621021   ADDU V0, V1, V0
9D027FBC  94420008   LHU V0, 8(V0)
9D027FC0  00402021   ADDU A0, V0, ZERO
9D027FC4  0F409EC4   JAL 0x9D027B10
9D027FC8  00000000   NOP
1161:                	return fatCache.data;
9D027FCC  3C02A000   LUI V0, -24576
9D027FD0  2442316C   ADDIU V0, V0, 12652
9D027FD4  8C420004   LW V0, 4(V0)
1162:                }
9D027FD8  03C0E821   ADDU SP, S8, ZERO
9D027FDC  8FBF0014   LW RA, 20(SP)
9D027FE0  8FBE0010   LW S8, 16(SP)
9D027FE4  27BD0018   ADDIU SP, SP, 24
9D027FE8  03E00008   JR RA
9D027FEC  00000000   NOP
1163:                
1164:                /*****************************************************************************
1165:                  Function:
1166:                	MPFS_PTR MPFSGetEndAddr(MPFS_HANDLE hMPFS)
1167:                
1168:                  Description:
1169:                	Determines the ending address of a file.
1170:                	
1171:                  Precondition:
1172:                	The file handle referenced by hMPFS is already open.
1173:                
1174:                  Parameters:
1175:                	hMPFS - the file handle from which to read the metadata
1176:                
1177:                  Returns:
1178:                	The address just after the file ends (start address of next file)
1179:                  ***************************************************************************/
1180:                MPFS_PTR MPFSGetEndAddr(MPFS_HANDLE hMPFS)
1181:                {
9D027FF0  27BDFFE8   ADDIU SP, SP, -24
9D027FF4  AFBF0014   SW RA, 20(SP)
9D027FF8  AFBE0010   SW S8, 16(SP)
9D027FFC  03A0F021   ADDU S8, SP, ZERO
9D028000  00801021   ADDU V0, A0, ZERO
9D028004  A3C20018   SB V0, 24(S8)
1182:                	// Make sure a valid file is open
1183:                	if(hMPFS > MAX_MPFS_HANDLES)
9D028008  93C20018   LBU V0, 24(S8)
9D02800C  2C420008   SLTIU V0, V0, 8
9D028010  14400004   BNE V0, ZERO, 0x9D028024
9D028014  00000000   NOP
1184:                		return MPFS_INVALID;
9D028018  2402FFFF   ADDIU V0, ZERO, -1
9D02801C  0B40A027   J 0x9D02809C
9D028020  00000000   NOP
1185:                	if(MPFSStubs[hMPFS].addr == MPFS_INVALID)
9D028024  93C40018   LBU A0, 24(S8)
9D028028  3C02A000   LUI V0, -24576
9D02802C  2403000C   ADDIU V1, ZERO, 12
9D028030  70831802   MUL V1, A0, V1
9D028034  2442310C   ADDIU V0, V0, 12556
9D028038  00621021   ADDU V0, V1, V0
9D02803C  8C430000   LW V1, 0(V0)
9D028040  2402FFFF   ADDIU V0, ZERO, -1
9D028044  14620004   BNE V1, V0, 0x9D028058
9D028048  00000000   NOP
1186:                		return MPFS_INVALID;
9D02804C  2402FFFF   ADDIU V0, ZERO, -1
9D028050  0B40A027   J 0x9D02809C
9D028054  00000000   NOP
1187:                	
1188:                	// Move to the point for reading
1189:                	_LoadFATRecord(MPFSStubs[hMPFS].fatID);
9D028058  93C40018   LBU A0, 24(S8)
9D02805C  3C02A000   LUI V0, -24576
9D028060  2403000C   ADDIU V1, ZERO, 12
9D028064  70831802   MUL V1, A0, V1
9D028068  2442310C   ADDIU V0, V0, 12556
9D02806C  00621021   ADDU V0, V1, V0
9D028070  94420008   LHU V0, 8(V0)
9D028074  00402021   ADDU A0, V0, ZERO
9D028078  0F409EC4   JAL 0x9D027B10
9D02807C  00000000   NOP
1190:                	return fatCache.data + fatCache.len;
9D028080  3C02A000   LUI V0, -24576
9D028084  2442316C   ADDIU V0, V0, 12652
9D028088  8C430004   LW V1, 4(V0)
9D02808C  3C02A000   LUI V0, -24576
9D028090  2442316C   ADDIU V0, V0, 12652
9D028094  8C420008   LW V0, 8(V0)
9D028098  00621021   ADDU V0, V1, V0
1191:                }
9D02809C  03C0E821   ADDU SP, S8, ZERO
9D0280A0  8FBF0014   LW RA, 20(SP)
9D0280A4  8FBE0010   LW S8, 16(SP)
9D0280A8  27BD0018   ADDIU SP, SP, 24
9D0280AC  03E00008   JR RA
9D0280B0  00000000   NOP
1192:                
1193:                /*****************************************************************************
1194:                  Function:
1195:                	BOOL MPFSGetFilename(MPFS_HANDLE hMPFS, BYTE* cName, WORD wLen)
1196:                
1197:                  Description:
1198:                	Reads the file name of a file that is already open.
1199:                	
1200:                  Precondition:
1201:                	The file handle referenced by hMPFS is already open.
1202:                
1203:                  Parameters:
1204:                	hMPFS - the file handle from which to determine the file name
1205:                	cName - where to store the name of the file
1206:                	wLen - the maximum length of data to store in cName
1207:                
1208:                  Return Values:
1209:                	TRUE - the file name was successfully located
1210:                	FALSE - the file handle provided is not currently open
1211:                  ***************************************************************************/
1212:                BOOL MPFSGetFilename(MPFS_HANDLE hMPFS, BYTE* cName, WORD wLen)
1213:                {
9D0280B4  27BDFFE0   ADDIU SP, SP, -32
9D0280B8  AFBF001C   SW RA, 28(SP)
9D0280BC  AFBE0018   SW S8, 24(SP)
9D0280C0  03A0F021   ADDU S8, SP, ZERO
9D0280C4  00801821   ADDU V1, A0, ZERO
9D0280C8  AFC50024   SW A1, 36(S8)
9D0280CC  00C01021   ADDU V0, A2, ZERO
9D0280D0  A3C30020   SB V1, 32(S8)
9D0280D4  A7C20028   SH V0, 40(S8)
1214:                	DWORD addr;
1215:                	
1216:                	// Make sure a valid file is open
1217:                	if(hMPFS > MAX_MPFS_HANDLES)
9D0280D8  93C20020   LBU V0, 32(S8)
9D0280DC  2C420008   SLTIU V0, V0, 8
9D0280E0  14400004   BNE V0, ZERO, 0x9D0280F4
9D0280E4  00000000   NOP
1218:                		return FALSE;
9D0280E8  00001021   ADDU V0, ZERO, ZERO
9D0280EC  0B40A065   J 0x9D028194
9D0280F0  00000000   NOP
1219:                	if(MPFSStubs[hMPFS].addr == MPFS_INVALID)
9D0280F4  93C40020   LBU A0, 32(S8)
9D0280F8  3C02A000   LUI V0, -24576
9D0280FC  2403000C   ADDIU V1, ZERO, 12
9D028100  70831802   MUL V1, A0, V1
9D028104  2442310C   ADDIU V0, V0, 12556
9D028108  00621021   ADDU V0, V1, V0
9D02810C  8C430000   LW V1, 0(V0)
9D028110  2402FFFF   ADDIU V0, ZERO, -1
9D028114  14620004   BNE V1, V0, 0x9D028128
9D028118  00000000   NOP
1220:                		return FALSE;
9D02811C  00001021   ADDU V0, ZERO, ZERO
9D028120  0B40A065   J 0x9D028194
9D028124  00000000   NOP
1221:                	
1222:                	// Move to the point for reading
1223:                	_LoadFATRecord(MPFSStubs[hMPFS].fatID);
9D028128  93C40020   LBU A0, 32(S8)
9D02812C  3C02A000   LUI V0, -24576
9D028130  2403000C   ADDIU V1, ZERO, 12
9D028134  70831802   MUL V1, A0, V1
9D028138  2442310C   ADDIU V0, V0, 12556
9D02813C  00621021   ADDU V0, V1, V0
9D028140  94420008   LHU V0, 8(V0)
9D028144  00402021   ADDU A0, V0, ZERO
9D028148  0F409EC4   JAL 0x9D027B10
9D02814C  00000000   NOP
1224:                	addr = fatCache.string;
9D028150  3C02A000   LUI V0, -24576
9D028154  8C42316C   LW V0, 12652(V0)
9D028158  AFC20010   SW V0, 16(S8)
1225:                	MPFSStubs[0].addr = addr;
9D02815C  3C02A000   LUI V0, -24576
9D028160  8FC30010   LW V1, 16(S8)
9D028164  AC43310C   SW V1, 12556(V0)
1226:                	MPFSStubs[0].bytesRem = 255;
9D028168  3C02A000   LUI V0, -24576
9D02816C  2442310C   ADDIU V0, V0, 12556
9D028170  240300FF   ADDIU V1, ZERO, 255
9D028174  AC430004   SW V1, 4(V0)
1227:                	
1228:                	// Read the value and return
1229:                	MPFSGetArray(0, cName, wLen);
9D028178  97C20028   LHU V0, 40(S8)
9D02817C  00002021   ADDU A0, ZERO, ZERO
9D028180  8FC50024   LW A1, 36(S8)
9D028184  00403021   ADDU A2, V0, ZERO
9D028188  0F409D30   JAL MPFSGetArray
9D02818C  00000000   NOP
1230:                	return TRUE;
9D028190  24020001   ADDIU V0, ZERO, 1
1231:                }
9D028194  03C0E821   ADDU SP, S8, ZERO
9D028198  8FBF001C   LW RA, 28(SP)
9D02819C  8FBE0018   LW S8, 24(SP)
9D0281A0  27BD0020   ADDIU SP, SP, 32
9D0281A4  03E00008   JR RA
9D0281A8  00000000   NOP
1232:                
1233:                /*****************************************************************************
1234:                  Function:
1235:                	DWORD MPFSGetPosition(MPFS_HANDLE hMPFS)
1236:                
1237:                  Description:
1238:                	Determines the current position in the file
1239:                	
1240:                  Precondition:
1241:                	The file handle referenced by hMPFS is already open.
1242:                
1243:                  Parameters:
1244:                	hMPFS - the file handle for which to determine position
1245:                
1246:                  Returns:
1247:                	The position in the file as a DWORD (or MPFS_PTR)
1248:                
1249:                  Remarks:
1250:                	Calling MPFSSeek(hMPFS, pos, MPFS_SEEK_START) will return the pointer
1251:                	to this position at a later time.  (Where pos is the value returned by
1252:                	this function.)
1253:                  ***************************************************************************/
1254:                DWORD MPFSGetPosition(MPFS_HANDLE hMPFS)
1255:                {
9D0281AC  27BDFFE0   ADDIU SP, SP, -32
9D0281B0  AFBF001C   SW RA, 28(SP)
9D0281B4  AFBE0018   SW S8, 24(SP)
9D0281B8  AFB00014   SW S0, 20(SP)
9D0281BC  03A0F021   ADDU S8, SP, ZERO
9D0281C0  00801021   ADDU V0, A0, ZERO
9D0281C4  A3C20020   SB V0, 32(S8)
1256:                	return MPFSStubs[hMPFS].addr - MPFSGetStartAddr(hMPFS);
9D0281C8  93C40020   LBU A0, 32(S8)
9D0281CC  3C02A000   LUI V0, -24576
9D0281D0  2403000C   ADDIU V1, ZERO, 12
9D0281D4  70831802   MUL V1, A0, V1
9D0281D8  2442310C   ADDIU V0, V0, 12556
9D0281DC  00621021   ADDU V0, V1, V0
9D0281E0  8C500000   LW S0, 0(V0)
9D0281E4  93C20020   LBU V0, 32(S8)
9D0281E8  00402021   ADDU A0, V0, ZERO
9D0281EC  0F409FCF   JAL MPFSGetStartAddr
9D0281F0  00000000   NOP
9D0281F4  02021023   SUBU V0, S0, V0
1257:                }
9D0281F8  03C0E821   ADDU SP, S8, ZERO
9D0281FC  8FBF001C   LW RA, 28(SP)
9D028200  8FBE0018   LW S8, 24(SP)
9D028204  8FB00014   LW S0, 20(SP)
9D028208  27BD0020   ADDIU SP, SP, 32
9D02820C  03E00008   JR RA
9D028210  00000000   NOP
1258:                
1259:                /*****************************************************************************
1260:                  Function:
1261:                	WORD MPFSGetID(MPFS_HANDLE hMPFS)
1262:                
1263:                  Description:
1264:                	Determines the ID in the FAT for a file.
1265:                	
1266:                  Precondition:
1267:                	The file handle referenced by hMPFS is already open.
1268:                
1269:                  Parameters:
1270:                	hMPFS - the file handle from which to read the metadata
1271:                
1272:                  Returns:
1273:                	The ID in the FAT for this file
1274:                
1275:                  Remarks:
1276:                	Use this function in association with MPFSOpenID to quickly access file
1277:                	without permanently reserving a file handle.
1278:                  ***************************************************************************/
1279:                WORD MPFSGetID(MPFS_HANDLE hMPFS)
1280:                {
9D028214  27BDFFF8   ADDIU SP, SP, -8
9D028218  AFBE0004   SW S8, 4(SP)
9D02821C  03A0F021   ADDU S8, SP, ZERO
9D028220  00801021   ADDU V0, A0, ZERO
9D028224  A3C20008   SB V0, 8(S8)
1281:                	return MPFSStubs[hMPFS].fatID;
9D028228  93C40008   LBU A0, 8(S8)
9D02822C  3C02A000   LUI V0, -24576
9D028230  2403000C   ADDIU V1, ZERO, 12
9D028234  70831802   MUL V1, A0, V1
9D028238  2442310C   ADDIU V0, V0, 12556
9D02823C  00621021   ADDU V0, V1, V0
9D028240  94420008   LHU V0, 8(V0)
1282:                }
9D028244  03C0E821   ADDU SP, S8, ZERO
9D028248  8FBE0004   LW S8, 4(SP)
9D02824C  27BD0008   ADDIU SP, SP, 8
9D028250  03E00008   JR RA
9D028254  00000000   NOP
1283:                
1284:                
1285:                /****************************************************************************
1286:                  Section:
1287:                	Utility Functions
1288:                  ***************************************************************************/
1289:                
1290:                /*****************************************************************************
1291:                  Function:
1292:                	void _Validate(void)
1293:                
1294:                  Summary:
1295:                	Validates the MPFS Image
1296:                
1297:                  Description:
1298:                	Verifies that the MPFS image is valid, and reads the number of 
1299:                	available files from the image header.  This function is called on
1300:                	boot, and again after any image is written.
1301:                
1302:                  Precondition:
1303:                	None
1304:                
1305:                  Parameters:
1306:                	None
1307:                
1308:                  Returns:
1309:                	None
1310:                  ***************************************************************************/
1311:                static void _Validate(void)
1312:                {
9D028258  27BDFFE8   ADDIU SP, SP, -24
9D02825C  AFBF0014   SW RA, 20(SP)
9D028260  AFBE0010   SW S8, 16(SP)
9D028264  03A0F021   ADDU S8, SP, ZERO
1313:                	// If this function causes an Address Error Exception on 16-bit
1314:                	// platforms with code stored in internal Flash, make sure your
1315:                	// compiler memory model settings are correct.
1316:                	//
1317:                	// In MPLAB, choose Project Menu > Build Options > Project.
1318:                	// Select the MPLAB C30 tab and change Cagetory to Memory Model.
1319:                	// Ensure that Large Code Model is selected, and that the remaining
1320:                	//   options are set to Default.
1321:                	
1322:                	// Validate the image and update numFiles
1323:                	MPFSStubs[0].addr = 0;
9D028268  3C02A000   LUI V0, -24576
9D02826C  AC40310C   SW ZERO, 12556(V0)
1324:                	MPFSStubs[0].bytesRem = 8;
9D028270  3C02A000   LUI V0, -24576
9D028274  2442310C   ADDIU V0, V0, 12556
9D028278  24030008   ADDIU V1, ZERO, 8
9D02827C  AC430004   SW V1, 4(V0)
1325:                	MPFSGetArray(0, (BYTE*)&fatCache, 6);
9D028280  3C02A000   LUI V0, -24576
9D028284  2442316C   ADDIU V0, V0, 12652
9D028288  00002021   ADDU A0, ZERO, ZERO
9D02828C  00402821   ADDU A1, V0, ZERO
9D028290  24060006   ADDIU A2, ZERO, 6
9D028294  0F409D30   JAL MPFSGetArray
9D028298  00000000   NOP
1326:                	if(!memcmppgm2ram((void*)&fatCache, (ROM void*)"MPFS\x02\x01", 6))
9D02829C  3C02A000   LUI V0, -24576
9D0282A0  2444316C   ADDIU A0, V0, 12652
9D0282A4  3C029D03   LUI V0, -25341
9D0282A8  24456268   ADDIU A1, V0, 25192
9D0282AC  24060006   ADDIU A2, ZERO, 6
9D0282B0  0F40D6D9   JAL 0x9D035B64
9D0282B4  00000000   NOP
9D0282B8  14400009   BNE V0, ZERO, 0x9D0282E0
9D0282BC  00000000   NOP
1327:                		MPFSGetArray(0, (BYTE*)&numFiles, 2);
9D0282C0  27828126   ADDIU V0, GP, -32474
9D0282C4  00002021   ADDU A0, ZERO, ZERO
9D0282C8  00402821   ADDU A1, V0, ZERO
9D0282CC  24060002   ADDIU A2, ZERO, 2
9D0282D0  0F409D30   JAL MPFSGetArray
9D0282D4  00000000   NOP
9D0282D8  0B40A0B9   J 0x9D0282E4
9D0282DC  00000000   NOP
1328:                	else
1329:                		numFiles = 0;
9D0282E0  A7808126   SH ZERO, -32474(GP)
1330:                	fatCacheID = MPFS_INVALID_FAT;
9D0282E4  2402FFFF   ADDIU V0, ZERO, -1
9D0282E8  A7828124   SH V0, -32476(GP)
1331:                }	
9D0282EC  03C0E821   ADDU SP, S8, ZERO
9D0282F0  8FBF0014   LW RA, 20(SP)
9D0282F4  8FBE0010   LW S8, 16(SP)
9D0282F8  27BD0018   ADDIU SP, SP, 24
9D0282FC  03E00008   JR RA
9D028300  00000000   NOP
1332:                #endif //#if defined(STACK_USE_MPFS2)
---  C:/Users/Diego/Documents/GitHub/pic32webFREERtos/Pic32Web.X/src/tcpip/src/IP.c  --------------------
1:                   /*********************************************************************
2:                    *
3:                    *  Internet Protocol (IP) Version 4 Communications Layer
4:                    *  Module for Microchip TCP/IP Stack
5:                    *   -Provides a transport for TCP, UDP, and ICMP messages
6:                    *	 -Reference: RFC 791
7:                    *
8:                    *********************************************************************
9:                    * FileName:        IP.c
10:                   * Dependencies:    Network Layer interface (ENC28J60.c, ETH97J60.c, 
11:                   *					ENCX24J600.c or WFMac.c)
12:                   * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32
13:                   * Compiler:        Microchip C32 v1.05 or higher
14:                   *					Microchip C30 v3.12 or higher
15:                   *					Microchip C18 v3.30 or higher
16:                   *					HI-TECH PICC-18 PRO 9.63PL2 or higher
17:                   * Company:         Microchip Technology, Inc.
18:                   *
19:                   * Software License Agreement
20:                   *
21:                   * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights
22:                   * reserved.
23:                   *
24:                   * Microchip licenses to you the right to use, modify, copy, and
25:                   * distribute:
26:                   * (i)  the Software when embedded on a Microchip microcontroller or
27:                   *      digital signal controller product ("Device") which is
28:                   *      integrated into Licensee's product; or
29:                   * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h,
30:                   *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device
31:                   *		used in conjunction with a Microchip ethernet controller for
32:                   *		the sole purpose of interfacing with the ethernet controller.
33:                   *
34:                   * You should refer to the license agreement accompanying this
35:                   * Software for additional information regarding your rights and
36:                   * obligations.
37:                   *
38:                   * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT
39:                   * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT
40:                   * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A
41:                   * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL
42:                   * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR
43:                   * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF
44:                   * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS
45:                   * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE
46:                   * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER
47:                   * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT
48:                   * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE.
49:                   *
50:                   *
51:                   * Author               Date    Comment
52:                   *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
53:                   * Nilesh Rajbharti     4/27/01 Original        (Rev 1.0)
54:                   * Nilesh Rajbharti     2/9/02  Cleanup
55:                   * Nilesh Rajbharti     5/22/02 Rev 2.0 (See version.log for detail)
56:                   * Howard Schlunder		8/31/04	Beta Rev 0.9 (See version.log for detail)
57:                   * Howard Schlunder		1/5/06	Improved DMA checksum efficiency
58:                   * Darren Rook			9/21/06	Corrected IPHeaderLen not being 
59:                   * 								initialized when NON_MCHP_MAC defined.
60:                   ********************************************************************/
61:                  #define __IP_C
62:                  
63:                  #include "TCPIP Stack/TCPIP.h"
64:                  
65:                  // This is left shifted by 4.  Actual value is 0x04.
66:                  #define IPv4                (0x40u)
67:                  #define IP_VERSION          IPv4
68:                  
69:                  // IHL (Internet Header Length) is # of DWORDs in a header.
70:                  // Since, we do not support options, our IP header length will be
71:                  // minimum i.e. 20 bytes : IHL = 20 / 4 = 5.
72:                  #define IP_IHL              (0x05)
73:                  
74:                  #define IP_SERVICE_NW_CTRL  (0x07)
75:                  #define IP_SERVICE_IN_CTRL  (0x06)
76:                  #define IP_SERVICE_ECP      (0x05)
77:                  #define IP_SERVICE_OVR      (0x04)
78:                  #define IP_SERVICE_FLASH    (0x03)
79:                  #define IP_SERVICE_IMM      (0x02)
80:                  #define IP_SERVICE_PRIOR    (0x01)
81:                  #define IP_SERVICE_ROUTINE  (0x00)
82:                  
83:                  #define IP_SERVICE_N_DELAY  (0x00)
84:                  #define IP_SERCICE_L_DELAY  (0x08)
85:                  #define IP_SERVICE_N_THRPT  (0x00)
86:                  #define IP_SERVICE_H_THRPT  (0x10)
87:                  #define IP_SERVICE_N_RELIB  (0x00)
88:                  #define IP_SERVICE_H_RELIB  (0x20)
89:                  
90:                  #define IP_SERVICE          (IP_SERVICE_ROUTINE | IP_SERVICE_N_DELAY)
91:                  
92:                  #if defined(STACK_USE_ZEROCONF_MDNS_SD)
93:                    #define MY_IP_TTL           (255)  // Time-To-Live in hops 
94:                    // IP TTL is set to 255 for Multicast DNS compatibility. See mDNS-draft-08, section 4.
95:                  #else
96:                    #define MY_IP_TTL           (100)  // Time-To-Live in hops
97:                  #endif
98:                  
99:                  
100:                 
101:                 static WORD _Identifier = 0;
102:                 static BYTE IPHeaderLen;
103:                 
104:                 
105:                 static void SwapIPHeader(IP_HEADER* h);
106:                 
107:                 
108:                 
109:                 
110:                 /*********************************************************************
111:                  * Function:        BOOL IPGetHeader( IP_ADDR    *localIP,
112:                  *                                    NODE_INFO  *remote,
113:                  *                                    BYTE        *Protocol,
114:                  *                                    WORD        *len)
115:                  *
116:                  * PreCondition:    MACGetHeader() == TRUE
117:                  *
118:                  * Input:           localIP     - Local node IP Address as received
119:                  *                                in current IP header.
120:                  *                                If this information is not required
121:                  *                                caller may pass NULL value.
122:                  *                  remote      - Remote node info
123:                  *                  Protocol    - Current packet protocol
124:                  *                  len         - Current packet data length
125:                  *
126:                  * Output:          TRUE, if valid packet was received
127:                  *                  FALSE otherwise
128:                  *
129:                  * Side Effects:    None
130:                  *
131:                  * Note:            Only one IP message can be received.
132:                  *                  Caller may not transmit and receive a message
133:                  *                  at the same time.
134:                  *
135:                  ********************************************************************/
136:                 BOOL IPGetHeader(IP_ADDR *localIP,
137:                                  NODE_INFO *remote,
138:                                  BYTE *protocol,
139:                                  WORD *len)
140:                 {
9D033958  27BDFFD0   ADDIU SP, SP, -48
9D03395C  AFBF002C   SW RA, 44(SP)
9D033960  AFBE0028   SW S8, 40(SP)
9D033964  03A0F021   ADDU S8, SP, ZERO
9D033968  AFC40030   SW A0, 48(S8)
9D03396C  AFC50034   SW A1, 52(S8)
9D033970  AFC60038   SW A2, 56(S8)
9D033974  AFC7003C   SW A3, 60(S8)
141:                     WORD_VAL    CalcChecksum;
142:                     IP_HEADER   header;
143:                 
144:                 #if defined(NON_MCHP_MAC)
145:                     WORD_VAL    ReceivedChecksum;
146:                     WORD        checksums[2];
147:                     BYTE        optionsLen;
148:                 	#define MAX_OPTIONS_LEN     (40u)            // As per RFC 791.
149:                     BYTE        options[MAX_OPTIONS_LEN];
150:                 #endif
151:                 
152:                     // Read IP header.
153:                     MACGetArray((BYTE*)&header, sizeof(header));
9D033978  27C20014   ADDIU V0, S8, 20
9D03397C  00402021   ADDU A0, V0, ZERO
9D033980  24050014   ADDIU A1, ZERO, 20
9D033984  0F407560   JAL MACGetArray
9D033988  00000000   NOP
154:                 
155:                     // Make sure that this is an IPv4 packet.
156:                     if((header.VersionIHL & 0xf0) != IP_VERSION)
9D03398C  93C20014   LBU V0, 20(S8)
9D033990  304300F0   ANDI V1, V0, 240
9D033994  24020040   ADDIU V0, ZERO, 64
9D033998  10620004   BEQ V1, V0, 0x9D0339AC
9D03399C  00000000   NOP
157:                     	return FALSE;
9D0339A0  00001021   ADDU V0, ZERO, ZERO
9D0339A4  0B40CEA0   J 0x9D033A80
9D0339A8  00000000   NOP
158:                 
159:                 	// Throw this packet away if it is a fragment.  
160:                 	// We don't have enough RAM for IP fragment reconstruction.
161:                 	if(header.FragmentInfo & 0xFF1F)
9D0339AC  97C2001A   LHU V0, 26(S8)
9D0339B0  3042FF1F   ANDI V0, V0, -225
9D0339B4  10400004   BEQ V0, ZERO, 0x9D0339C8
9D0339B8  00000000   NOP
162:                 		return FALSE;
9D0339BC  00001021   ADDU V0, ZERO, ZERO
9D0339C0  0B40CEA0   J 0x9D033A80
9D0339C4  00000000   NOP
163:                 
164:                 	IPHeaderLen = (header.VersionIHL & 0x0f) << 2;
9D0339C8  93C20014   LBU V0, 20(S8)
9D0339CC  3042000F   ANDI V0, V0, 15
9D0339D0  304200FF   ANDI V0, V0, 255
9D0339D4  00021080   SLL V0, V0, 2
9D0339D8  304200FF   ANDI V0, V0, 255
9D0339DC  A382811E   SB V0, -32482(GP)
165:                 
166:                 #if !defined(NON_MCHP_MAC)
167:                 	// Validate the IP header.  If it is correct, the checksum 
168:                 	// will come out to 0x0000 (because the header contains a 
169:                 	// precomputed checksum).  A corrupt header will have a 
170:                 	// nonzero checksum.
171:                 	CalcChecksum.Val = MACCalcRxChecksum(0, IPHeaderLen);
9D0339E0  9382811E   LBU V0, -32482(GP)
9D0339E4  00002021   ADDU A0, ZERO, ZERO
9D0339E8  00402821   ADDU A1, V0, ZERO
9D0339EC  0F40743C   JAL MACCalcRxChecksum
9D0339F0  00000000   NOP
9D0339F4  A7C20010   SH V0, 16(S8)
172:                 
173:                 	// Seek to the end of the IP header
174:                 	MACSetReadPtrInRx(IPHeaderLen);
9D0339F8  9382811E   LBU V0, -32482(GP)
9D0339FC  00402021   ADDU A0, V0, ZERO
9D033A00  0F4073F2   JAL MACSetReadPtrInRx
9D033A04  00000000   NOP
175:                 
176:                     if(CalcChecksum.Val)
9D033A08  97C20010   LHU V0, 16(S8)
9D033A0C  10400004   BEQ V0, ZERO, 0x9D033A20
9D033A10  00000000   NOP
177:                 #else
178:                     // Calculate options length in this header, if there is any.
179:                     // IHL is in terms of numbers of 32-bit DWORDs; i.e. actual
180:                     // length is 4 times IHL.
181:                     optionsLen = IPHeaderLen - sizeof(header);
182:                 
183:                     // If there is any option(s), read it so that we can include them
184:                     // in checksum calculation.
185:                     if ( optionsLen > MAX_OPTIONS_LEN )
186:                         return FALSE;
187:                 
188:                     if ( optionsLen > 0u )
189:                         MACGetArray(options, optionsLen);
190:                 
191:                     // Save header checksum; clear it and recalculate it ourselves.
192:                     ReceivedChecksum.Val = header.HeaderChecksum;
193:                     header.HeaderChecksum = 0;
194:                 
195:                     // Calculate checksum of header including options bytes.
196:                     checksums[0] = ~CalcIPChecksum((BYTE*)&header, sizeof(header));
197:                 
198:                     // Calculate Options checksum too, if they are present.
199:                     if ( optionsLen > 0u )
200:                         checksums[1] = ~CalcIPChecksum((BYTE*)options, optionsLen);
201:                     else
202:                         checksums[1] = 0;
203:                 
204:                     CalcChecksum.Val  = CalcIPChecksum((BYTE*)checksums,
205:                                                             2 * sizeof(WORD));
206:                 
207:                     // Make sure that checksum is correct
208:                     if ( ReceivedChecksum.Val != CalcChecksum.Val )
209:                 #endif
210:                     {
211:                         // Bad packet. The function caller will be notified by means of the FALSE 
212:                         // return value and it should discard the packet.
213:                         return FALSE;
9D033A14  00001021   ADDU V0, ZERO, ZERO
9D033A18  0B40CEA0   J 0x9D033A80
9D033A1C  00000000   NOP
214:                     }
215:                 
216:                     // Network to host conversion.
217:                     SwapIPHeader(&header);
9D033A20  27C20014   ADDIU V0, S8, 20
9D033A24  00402021   ADDU A0, V0, ZERO
9D033A28  0F40CF05   JAL 0x9D033C14
9D033A2C  00000000   NOP
218:                 
219:                     // If caller is intrested, return destination IP address
220:                     // as seen in this IP header.
221:                     if ( localIP )
9D033A30  8FC20030   LW V0, 48(S8)
9D033A34  10400004   BEQ V0, ZERO, 0x9D033A48
9D033A38  00000000   NOP
222:                         localIP->Val    = header.DestAddress.Val;
9D033A3C  8FC30024   LW V1, 36(S8)
9D033A40  8FC20030   LW V0, 48(S8)
9D033A44  AC430000   SW V1, 0(V0)
223:                 
224:                     remote->IPAddr.Val  = header.SourceAddress.Val;
9D033A48  8FC30020   LW V1, 32(S8)
9D033A4C  8FC20034   LW V0, 52(S8)
9D033A50  A8430003   SWL V1, 3(V0)
9D033A54  B8430000   SWR V1, 0(V0)
225:                     *protocol           = header.Protocol;
9D033A58  93C3001D   LBU V1, 29(S8)
9D033A5C  8FC20038   LW V0, 56(S8)
9D033A60  A0430000   SB V1, 0(V0)
226:                     *len 				= header.TotalLength - IPHeaderLen;
9D033A64  97C30016   LHU V1, 22(S8)
9D033A68  9382811E   LBU V0, -32482(GP)
9D033A6C  00621023   SUBU V0, V1, V0
9D033A70  3043FFFF   ANDI V1, V0, -1
9D033A74  8FC2003C   LW V0, 60(S8)
9D033A78  A4430000   SH V1, 0(V0)
227:                 
228:                     return TRUE;
9D033A7C  24020001   ADDIU V0, ZERO, 1
229:                 }
9D033A80  03C0E821   ADDU SP, S8, ZERO
9D033A84  8FBF002C   LW RA, 44(SP)
9D033A88  8FBE0028   LW S8, 40(SP)
9D033A8C  27BD0030   ADDIU SP, SP, 48
9D033A90  03E00008   JR RA
9D033A94  00000000   NOP
230:                 
231:                 
232:                 
233:                 
234:                 /*********************************************************************
235:                  * Function: WORD IPPutHeader(NODE_INFO *remote,
236:                  *           				  BYTE protocol,
237:                  *                			  WORD len)
238:                  *
239:                  * PreCondition:    IPIsTxReady() == TRUE
240:                  *
241:                  * Input:           *remote     - Destination node address
242:                  *                  protocol    - Current packet protocol
243:                  *                  len         - Current packet data length
244:                  *
245:                  * Output:          (WORD)0
246:                  *
247:                  * Side Effects:    None
248:                  *
249:                  * Note:            Only one IP message can be transmitted at any
250:                  *                  time.
251:                  ********************************************************************/
252:                 WORD IPPutHeader(NODE_INFO *remote,
253:                                  BYTE protocol,
254:                                  WORD len)
255:                 {
9D033A98  27BDFFD0   ADDIU SP, SP, -48
9D033A9C  AFBF002C   SW RA, 44(SP)
9D033AA0  AFBE0028   SW S8, 40(SP)
9D033AA4  03A0F021   ADDU S8, SP, ZERO
9D033AA8  AFC40030   SW A0, 48(S8)
9D033AAC  00A01821   ADDU V1, A1, ZERO
9D033AB0  00C01021   ADDU V0, A2, ZERO
9D033AB4  A3C30034   SB V1, 52(S8)
9D033AB8  A7C20038   SH V0, 56(S8)
256:                     IP_HEADER   header;
257:                     
258:                     IPHeaderLen = sizeof(IP_HEADER);
9D033ABC  24020014   ADDIU V0, ZERO, 20
9D033AC0  A382811E   SB V0, -32482(GP)
259:                 
260:                     header.VersionIHL       = IP_VERSION | IP_IHL;
9D033AC4  24020045   ADDIU V0, ZERO, 69
9D033AC8  A3C20010   SB V0, 16(S8)
261:                     header.TypeOfService    = IP_SERVICE;
9D033ACC  A3C00011   SB ZERO, 17(S8)
262:                     header.TotalLength      = sizeof(header) + len;
9D033AD0  97C20038   LHU V0, 56(S8)
9D033AD4  24420014   ADDIU V0, V0, 20
9D033AD8  3042FFFF   ANDI V0, V0, -1
9D033ADC  A7C20012   SH V0, 18(S8)
263:                     header.Identification   = ++_Identifier;
9D033AE0  9782811C   LHU V0, -32484(GP)
9D033AE4  24420001   ADDIU V0, V0, 1
9D033AE8  3042FFFF   ANDI V0, V0, -1
9D033AEC  A782811C   SH V0, -32484(GP)
9D033AF0  9782811C   LHU V0, -32484(GP)
9D033AF4  A7C20014   SH V0, 20(S8)
264:                     header.FragmentInfo     = 0;
9D033AF8  A7C00016   SH ZERO, 22(S8)
265:                     header.TimeToLive       = MY_IP_TTL;
9D033AFC  24020064   ADDIU V0, ZERO, 100
9D033B00  A3C20018   SB V0, 24(S8)
266:                     header.Protocol         = protocol;
9D033B04  93C20034   LBU V0, 52(S8)
9D033B08  A3C20019   SB V0, 25(S8)
267:                     header.HeaderChecksum   = 0;
9D033B0C  A7C0001A   SH ZERO, 26(S8)
268:                 	header.SourceAddress 	= AppConfig.MyIPAddr;
9D033B10  3C02A000   LUI V0, -24576
9D033B14  24430728   ADDIU V1, V0, 1832
9D033B18  88630003   LWL V1, 3(V1)
9D033B1C  00602021   ADDU A0, V1, ZERO
9D033B20  98440728   LWR A0, 1832(V0)
9D033B24  00801021   ADDU V0, A0, ZERO
9D033B28  AFC2001C   SW V0, 28(S8)
269:                 
270:                     header.DestAddress.Val = remote->IPAddr.Val;
9D033B2C  8FC20030   LW V0, 48(S8)
9D033B30  88430003   LWL V1, 3(V0)
9D033B34  00602021   ADDU A0, V1, ZERO
9D033B38  98440000   LWR A0, 0(V0)
9D033B3C  00801021   ADDU V0, A0, ZERO
9D033B40  AFC20020   SW V0, 32(S8)
271:                 
272:                     SwapIPHeader(&header);
9D033B44  27C20010   ADDIU V0, S8, 16
9D033B48  00402021   ADDU A0, V0, ZERO
9D033B4C  0F40CF05   JAL 0x9D033C14
9D033B50  00000000   NOP
273:                 
274:                     header.HeaderChecksum   = CalcIPChecksum((BYTE*)&header, sizeof(header));
9D033B54  27C20010   ADDIU V0, S8, 16
9D033B58  00402021   ADDU A0, V0, ZERO
9D033B5C  24050014   ADDIU A1, ZERO, 20
9D033B60  0F409A63   JAL CalcIPChecksum
9D033B64  00000000   NOP
9D033B68  A7C2001A   SH V0, 26(S8)
275:                 
276:                     MACPutHeader(&remote->MACAddr, MAC_IP, (sizeof(header)+len));
9D033B6C  8FC20030   LW V0, 48(S8)
9D033B70  24430004   ADDIU V1, V0, 4
9D033B74  97C20038   LHU V0, 56(S8)
9D033B78  24420014   ADDIU V0, V0, 20
9D033B7C  3042FFFF   ANDI V0, V0, -1
9D033B80  00602021   ADDU A0, V1, ZERO
9D033B84  00002821   ADDU A1, ZERO, ZERO
9D033B88  00403021   ADDU A2, V0, ZERO
9D033B8C  0F407380   JAL MACPutHeader
9D033B90  00000000   NOP
277:                     MACPutArray((BYTE*)&header, sizeof(header));
9D033B94  27C20010   ADDIU V0, S8, 16
9D033B98  00402021   ADDU A0, V0, ZERO
9D033B9C  24050014   ADDIU A1, ZERO, 20
9D033BA0  0F40759D   JAL MACPutArray
9D033BA4  00000000   NOP
278:                 
279:                     return 0x0000;
9D033BA8  00001021   ADDU V0, ZERO, ZERO
280:                 
281:                 }
9D033BAC  03C0E821   ADDU SP, S8, ZERO
9D033BB0  8FBF002C   LW RA, 44(SP)
9D033BB4  8FBE0028   LW S8, 40(SP)
9D033BB8  27BD0030   ADDIU SP, SP, 48
9D033BBC  03E00008   JR RA
9D033BC0  00000000   NOP
282:                 
283:                 /*********************************************************************
284:                  * Function:        IPSetRxBuffer(WORD Offset)
285:                  *
286:                  * PreCondition:    IPHeaderLen must have been intialized by 
287:                  *					IPGetHeader() or IPPutHeader()
288:                  *
289:                  * Input:           Offset from beginning of IP data field
290:                  *
291:                  * Output:          Next Read/Write access to receive buffer is
292:                  *                  set to Offset 
293:                  *
294:                  * Side Effects:    None
295:                  *
296:                  * Note:            None
297:                  *
298:                  ********************************************************************/
299:                 void IPSetRxBuffer(WORD Offset) 
300:                 {
9D033BC4  27BDFFE8   ADDIU SP, SP, -24
9D033BC8  AFBF0014   SW RA, 20(SP)
9D033BCC  AFBE0010   SW S8, 16(SP)
9D033BD0  03A0F021   ADDU S8, SP, ZERO
9D033BD4  00801021   ADDU V0, A0, ZERO
9D033BD8  A7C20018   SH V0, 24(S8)
301:                 	MACSetReadPtrInRx(Offset+IPHeaderLen);
9D033BDC  9382811E   LBU V0, -32482(GP)
9D033BE0  00401821   ADDU V1, V0, ZERO
9D033BE4  97C20018   LHU V0, 24(S8)
9D033BE8  00621021   ADDU V0, V1, V0
9D033BEC  3042FFFF   ANDI V0, V0, -1
9D033BF0  00402021   ADDU A0, V0, ZERO
9D033BF4  0F4073F2   JAL MACSetReadPtrInRx
9D033BF8  00000000   NOP
302:                 }
9D033BFC  03C0E821   ADDU SP, S8, ZERO
9D033C00  8FBF0014   LW RA, 20(SP)
9D033C04  8FBE0010   LW S8, 16(SP)
9D033C08  27BD0018   ADDIU SP, SP, 24
9D033C0C  03E00008   JR RA
9D033C10  00000000   NOP
303:                 
304:                 
305:                 
306:                 static void SwapIPHeader(IP_HEADER* h)
307:                 {
9D033C14  27BDFFE8   ADDIU SP, SP, -24
9D033C18  AFBF0014   SW RA, 20(SP)
9D033C1C  AFBE0010   SW S8, 16(SP)
9D033C20  03A0F021   ADDU S8, SP, ZERO
9D033C24  AFC40018   SW A0, 24(S8)
308:                     h->TotalLength      = swaps(h->TotalLength);
9D033C28  8FC20018   LW V0, 24(S8)
9D033C2C  94420002   LHU V0, 2(V0)
9D033C30  00402021   ADDU A0, V0, ZERO
9D033C34  0F409A16   JAL swaps
9D033C38  00000000   NOP
9D033C3C  00401821   ADDU V1, V0, ZERO
9D033C40  8FC20018   LW V0, 24(S8)
9D033C44  A4430002   SH V1, 2(V0)
309:                     h->Identification   = swaps(h->Identification);
9D033C48  8FC20018   LW V0, 24(S8)
9D033C4C  94420004   LHU V0, 4(V0)
9D033C50  00402021   ADDU A0, V0, ZERO
9D033C54  0F409A16   JAL swaps
9D033C58  00000000   NOP
9D033C5C  00401821   ADDU V1, V0, ZERO
9D033C60  8FC20018   LW V0, 24(S8)
9D033C64  A4430004   SH V1, 4(V0)
310:                     h->HeaderChecksum   = swaps(h->HeaderChecksum);
9D033C68  8FC20018   LW V0, 24(S8)
9D033C6C  9442000A   LHU V0, 10(V0)
9D033C70  00402021   ADDU A0, V0, ZERO
9D033C74  0F409A16   JAL swaps
9D033C78  00000000   NOP
9D033C7C  00401821   ADDU V1, V0, ZERO
9D033C80  8FC20018   LW V0, 24(S8)
9D033C84  A443000A   SH V1, 10(V0)
311:                 }
9D033C88  03C0E821   ADDU SP, S8, ZERO
9D033C8C  8FBF0014   LW RA, 20(SP)
9D033C90  8FBE0010   LW S8, 16(SP)
9D033C94  27BD0018   ADDIU SP, SP, 24
9D033C98  03E00008   JR RA
9D033C9C  00000000   NOP
---  C:/Users/Diego/Documents/GitHub/pic32webFREERtos/Pic32Web.X/src/tcpip/src/ICMP.c  ------------------
1:                   /*********************************************************************
2:                    *
3:                    *  Internet Control Message Protocol (ICMP) Server
4:                    *  Module for Microchip TCP/IP Stack
5:                    *   -Provides "ping" diagnostics
6:                    *	 -Reference: RFC 792
7:                    *
8:                    *********************************************************************
9:                    * FileName:        ICMP.c
10:                   * Dependencies:    IP, ARP
11:                   * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32
12:                   * Compiler:        Microchip C32 v1.05 or higher
13:                   *					Microchip C30 v3.12 or higher
14:                   *					Microchip C18 v3.30 or higher
15:                   *					HI-TECH PICC-18 PRO 9.63PL2 or higher
16:                   * Company:         Microchip Technology, Inc.
17:                   *
18:                   * Software License Agreement
19:                   *
20:                   * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights
21:                   * reserved.
22:                   *
23:                   * Microchip licenses to you the right to use, modify, copy, and
24:                   * distribute:
25:                   * (i)  the Software when embedded on a Microchip microcontroller or
26:                   *      digital signal controller product ("Device") which is
27:                   *      integrated into Licensee's product; or
28:                   * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h,
29:                   *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device
30:                   *		used in conjunction with a Microchip ethernet controller for
31:                   *		the sole purpose of interfacing with the ethernet controller.
32:                   *
33:                   * You should refer to the license agreement accompanying this
34:                   * Software for additional information regarding your rights and
35:                   * obligations.
36:                   *
37:                   * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT
38:                   * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT
39:                   * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A
40:                   * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL
41:                   * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR
42:                   * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF
43:                   * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS
44:                   * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE
45:                   * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER
46:                   * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT
47:                   * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE.
48:                   *
49:                   *
50:                   * Author               Date    	Comment
51:                   *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
52:                   * Howard Schlunder		03/16/07	Original
53:                   ********************************************************************/
54:                  #define __ICMP_C
55:                  
56:                  #include "TCPIP Stack/TCPIP.h"
57:                  
58:                  #if defined(STACK_USE_ICMP_SERVER) || defined(STACK_USE_ICMP_CLIENT)
59:                  
60:                  #if defined(STACK_USE_ICMP_CLIENT)
61:                  
62:                  // ICMP Timeout Value
63:                  #define ICMP_TIMEOUT	(4ul*TICK_SECOND)
64:                  
65:                  // ICMP Packet Structure
66:                  typedef struct
67:                  {
68:                  	BYTE vType;
69:                  	BYTE vCode;
70:                  	WORD wChecksum;
71:                  	WORD wIdentifier;
72:                  	WORD wSequenceNumber;
73:                  	WORD wData;
74:                  } ICMP_PACKET;
75:                  
76:                  // ICMP Sequence Number
77:                  static WORD wICMPSequenceNumber;
78:                  // ICMP tick timer variable
79:                  static DWORD ICMPTimer;
80:                  
81:                  // ICMP Flag structure
82:                  static struct
83:                  {
84:                  	unsigned char bICMPInUse:1;         // Indicates that the ICMP Client is in use
85:                  	unsigned char bReplyValid:1;        // Indicates that a correct Ping response to one of our pings was received
86:                  	unsigned char bRemoteHostIsROM:1;   // Indicates that a remote host name was passed as a ROM pointer argument
87:                  } ICMPFlags = {0x00};
88:                  
89:                  // ICMP Static Variables
90:                  static union
91:                  {
92:                  	union
93:                  	{
94:                  		ROM BYTE *szROM;
95:                  		BYTE *szRAM;
96:                  	} RemoteHost;
97:                  	NODE_INFO ICMPRemote;
98:                  } StaticVars;
99:                  
100:                 // ICMP State Machine Enumeration
101:                 static enum
102:                 {
103:                 	SM_IDLE = 0,
104:                 	SM_DNS_SEND_QUERY,
105:                 	SM_DNS_GET_RESPONSE,
106:                 	SM_ARP_SEND_QUERY,
107:                 	SM_ARP_GET_RESPONSE,
108:                 	SM_ICMP_SEND_ECHO_REQUEST,
109:                 	SM_ICMP_GET_ECHO_RESPONSE
110:                 } ICMPState;
111:                 
112:                 #endif
113:                 
114:                 /*********************************************************************
115:                  * Function:        void ICMPProcess(void)
116:                  *
117:                  * PreCondition:    MAC buffer contains ICMP type packet.
118:                  *
119:                  * Input:           *remote: Pointer to a NODE_INFO structure of the 
120:                  *					ping requester
121:                  *					len: Count of how many bytes the ping header and 
122:                  *					payload are in this IP packet
123:                  *
124:                  * Output:          Generates an echo reply, if requested
125:                  *					Validates and sets ICMPFlags.bReplyValid if a 
126:                  *					correct ping response to one of ours is received.
127:                  *
128:                  * Side Effects:    None
129:                  *
130:                  * Overview:        None
131:                  *
132:                  * Note:            None
133:                  ********************************************************************/
134:                 void ICMPProcess(NODE_INFO *remote, WORD len)
135:                 {
9D030344  27BDFFE0   ADDIU SP, SP, -32
9D030348  AFBF001C   SW RA, 28(SP)
9D03034C  AFBE0018   SW S8, 24(SP)
9D030350  03A0F021   ADDU S8, SP, ZERO
9D030354  AFC40020   SW A0, 32(S8)
9D030358  00A01021   ADDU V0, A1, ZERO
9D03035C  A7C20024   SH V0, 36(S8)
136:                 	DWORD_VAL dwVal;
137:                 
138:                     // Obtain the ICMP header Type, Code, and Checksum fields
139:                     MACGetArray((BYTE*)&dwVal, sizeof(dwVal));
9D030360  27C20010   ADDIU V0, S8, 16
9D030364  00402021   ADDU A0, V0, ZERO
9D030368  24050004   ADDIU A1, ZERO, 4
9D03036C  0F407560   JAL MACGetArray
9D030370  00000000   NOP
140:                 	
141:                 	// See if this is an ICMP echo (ping) request
142:                 	if(dwVal.w[0] == 0x0008u)
9D030374  97C30010   LHU V1, 16(S8)
9D030378  24020008   ADDIU V0, ZERO, 8
9D03037C  14620045   BNE V1, V0, 0x9D030494
9D030380  00000000   NOP
143:                 	{
144:                 		// Validate the checksum using the Microchip MAC's DMA module
145:                 		// The checksum data includes the precomputed checksum in the 
146:                 		// header, so a valid packet will always have a checksum of 
147:                 		// 0x0000 if the packet is not disturbed.
148:                 		if(MACCalcRxChecksum(0+sizeof(IP_HEADER), len))
9D030384  97C20024   LHU V0, 36(S8)
9D030388  24040014   ADDIU A0, ZERO, 20
9D03038C  00402821   ADDU A1, V0, ZERO
9D030390  0F40743C   JAL MACCalcRxChecksum
9D030394  00000000   NOP
9D030398  14400062   BNE V0, ZERO, 0x9D030524
9D03039C  00000000   NOP
149:                 			return;
9D030524  00000000   NOP
9D030528  0B40C153   J 0x9D03054C
9D03052C  00000000   NOP
150:                 	
151:                 		// Calculate new Type, Code, and Checksum values
152:                 		dwVal.v[0] = 0x00;	// Type: 0 (ICMP echo/ping reply)
9D0303A0  A3C00010   SB ZERO, 16(S8)
153:                 		dwVal.v[2] += 8;	// Subtract 0x0800 from the checksum
9D0303A4  93C20012   LBU V0, 18(S8)
9D0303A8  24420008   ADDIU V0, V0, 8
9D0303AC  304200FF   ANDI V0, V0, 255
9D0303B0  A3C20012   SB V0, 18(S8)
154:                 		if(dwVal.v[2] < 8u)
9D0303B4  93C20012   LBU V0, 18(S8)
9D0303B8  2C420008   SLTIU V0, V0, 8
9D0303BC  1040000E   BEQ V0, ZERO, 0x9D0303F8
9D0303C0  00000000   NOP
155:                 		{
156:                 			dwVal.v[3]++;
9D0303C4  93C20013   LBU V0, 19(S8)
9D0303C8  24420001   ADDIU V0, V0, 1
9D0303CC  304200FF   ANDI V0, V0, 255
9D0303D0  A3C20013   SB V0, 19(S8)
157:                 			if(dwVal.v[3] == 0u)
9D0303D4  93C20013   LBU V0, 19(S8)
9D0303D8  1440000A   BNE V0, ZERO, 0x9D030404
9D0303DC  00000000   NOP
158:                 				dwVal.v[2]++;
9D0303E0  93C20012   LBU V0, 18(S8)
9D0303E4  24420001   ADDIU V0, V0, 1
9D0303E8  304200FF   ANDI V0, V0, 255
9D0303EC  A3C20012   SB V0, 18(S8)
159:                 		}
160:                 	
161:                 	    // Wait for TX hardware to become available (finish transmitting 
162:                 	    // any previous packet)
163:                 	    while(!IPIsTxReady());
9D0303F0  0B40C102   J 0x9D030408
9D0303F4  00000000   NOP
9D0303F8  00000000   NOP
9D0303FC  0B40C102   J 0x9D030408
9D030400  00000000   NOP
9D030404  00000000   NOP
9D030408  0F40727E   JAL MACIsTxReady
9D03040C  00000000   NOP
9D030410  1040FFFD   BEQ V0, ZERO, 0x9D030408
9D030414  00000000   NOP
164:                 
165:                 		// Position the write pointer for the next IPPutHeader operation
166:                 		// NOTE: do not put this before the IPIsTxReady() call for WF compatbility
167:                 	    MACSetWritePtr(BASE_TX_ADDR + sizeof(ETHER_HEADER));
9D030418  2404000E   ADDIU A0, ZERO, 14
9D03041C  0F407410   JAL MACSetWritePtr
9D030420  00000000   NOP
168:                         	
169:                 		// Create IP header in TX memory
170:                 		IPPutHeader(remote, IP_PROT_ICMP, len);
9D030424  97C20024   LHU V0, 36(S8)
9D030428  8FC40020   LW A0, 32(S8)
9D03042C  24050001   ADDIU A1, ZERO, 1
9D030430  00403021   ADDU A2, V0, ZERO
9D030434  0F40CEA6   JAL IPPutHeader
9D030438  00000000   NOP
171:                 	
172:                 		// Copy ICMP response into the TX memory
173:                 		MACPutArray((BYTE*)&dwVal, sizeof(dwVal));
9D03043C  27C20010   ADDIU V0, S8, 16
9D030440  00402021   ADDU A0, V0, ZERO
9D030444  24050004   ADDIU A1, ZERO, 4
9D030448  0F40759D   JAL MACPutArray
9D03044C  00000000   NOP
174:                 		MACMemCopyAsync(-1, -1, len-4);
9D030450  97C20024   LHU V0, 36(S8)
9D030454  2442FFFC   ADDIU V0, V0, -4
9D030458  3042FFFF   ANDI V0, V0, -1
9D03045C  2404FFFF   ADDIU A0, ZERO, -1
9D030460  2405FFFF   ADDIU A1, ZERO, -1
9D030464  00403021   ADDU A2, V0, ZERO
9D030468  0F4074D3   JAL MACMemCopyAsync
9D03046C  00000000   NOP
175:                 		while(!MACIsMemCopyDone());
9D030470  00000000   NOP
9D030474  0F407532   JAL MACIsMemCopyDone
9D030478  00000000   NOP
9D03047C  1040FFFD   BEQ V0, ZERO, 0x9D030474
9D030480  00000000   NOP
176:                 	
177:                 		// Transmit the echo reply packet
178:                 	    MACFlush();
9D030484  0F4073B4   JAL MACFlush
9D030488  00000000   NOP
9D03048C  0B40C153   J 0x9D03054C
9D030490  00000000   NOP
179:                 	}
180:                 #if defined(STACK_USE_ICMP_CLIENT)
181:                 	else if(dwVal.w[0] == 0x0000u)	// See if this an ICMP Echo reply to our request
9D030494  97C20010   LHU V0, 16(S8)
9D030498  1440002C   BNE V0, ZERO, 0x9D03054C
9D03049C  00000000   NOP
182:                 	{
183:                 		// Get the sequence number and identifier fields
184:                 		MACGetArray((BYTE*)&dwVal, sizeof(dwVal));
9D0304A0  27C20010   ADDIU V0, S8, 16
9D0304A4  00402021   ADDU A0, V0, ZERO
9D0304A8  24050004   ADDIU A1, ZERO, 4
9D0304AC  0F407560   JAL MACGetArray
9D0304B0  00000000   NOP
185:                 		
186:                 		// See if the identifier matches the one we sent
187:                 		if(dwVal.w[0] != 0xEFBE)	
9D0304B4  97C30010   LHU V1, 16(S8)
9D0304B8  3402EFBE   ORI V0, ZERO, -4162
9D0304BC  1462001C   BNE V1, V0, 0x9D030530
9D0304C0  00000000   NOP
188:                 			return;
9D030530  00000000   NOP
9D030534  0B40C153   J 0x9D03054C
9D030538  00000000   NOP
189:                 	
190:                 		if(dwVal.w[1] != wICMPSequenceNumber)
9D0304C4  97C30012   LHU V1, 18(S8)
9D0304C8  9782810C   LHU V0, -32500(GP)
9D0304CC  1462001B   BNE V1, V0, 0x9D03053C
9D0304D0  00000000   NOP
191:                 			return;
9D03053C  00000000   NOP
9D030540  0B40C153   J 0x9D03054C
9D030544  00000000   NOP
192:                 
193:                 		// Validate the ICMP checksum field
194:                 	    IPSetRxBuffer(0);
9D0304D4  00002021   ADDU A0, ZERO, ZERO
9D0304D8  0F40CEF1   JAL IPSetRxBuffer
9D0304DC  00000000   NOP
195:                 		if(CalcIPBufferChecksum(sizeof(ICMP_PACKET)))	// Two bytes of payload were sent in the echo request
9D0304E0  2404000A   ADDIU A0, ZERO, 10
9D0304E4  0F40748E   JAL CalcIPBufferChecksum
9D0304E8  00000000   NOP
9D0304EC  14400016   BNE V0, ZERO, 0x9D030548
9D0304F0  00000000   NOP
196:                 			return;
9D030548  00000000   NOP
197:                 		
198:                 		// Flag that we received the response and stop the timer ticking
199:                 		ICMPFlags.bReplyValid = 1;
9D0304F4  93828114   LBU V0, -32492(GP)
9D0304F8  24030001   ADDIU V1, ZERO, 1
9D0304FC  7C620844   INS V0, V1, 1, 1
9D030500  A3828114   SB V0, -32492(GP)
200:                 		ICMPTimer = TickGet() - ICMPTimer;
9D030504  0F40CDD6   JAL TickGet
9D030508  00000000   NOP
9D03050C  00401821   ADDU V1, V0, ZERO
9D030510  8F828110   LW V0, -32496(GP)
9D030514  00621023   SUBU V0, V1, V0
9D030518  AF828110   SW V0, -32496(GP)
9D03051C  0B40C153   J 0x9D03054C
9D030520  00000000   NOP
201:                 	}
202:                 #endif
203:                 }
9D03054C  03C0E821   ADDU SP, S8, ZERO
9D030550  8FBF001C   LW RA, 28(SP)
9D030554  8FBE0018   LW S8, 24(SP)
9D030558  27BD0020   ADDIU SP, SP, 32
9D03055C  03E00008   JR RA
9D030560  00000000   NOP
204:                 
205:                 #if defined(STACK_USE_ICMP_CLIENT)
206:                 /*********************************************************************
207:                  * Function:        void ICMPSendPing(DWORD dwRemoteIP)
208:                  *
209:                  * PreCondition:    ICMPBeginUsage() returned TRUE
210:                  *
211:                  * Input:           dwRemoteIP: IP Address to ping.  Must be stored 
212:                  *								big endian.  Ex. 192.168.0.1 should be
213:                  *								passed as 0x0100A8C0.
214:                  *
215:                  * Output:          Begins the process of transmitting an ICMP echo 
216:                  *					request.  This normally involves an ARP 
217:                  *					resolution procedure first.
218:                  *
219:                  * Side Effects:    None
220:                  *
221:                  * Overview:        None
222:                  *
223:                  * Note:            None
224:                  ********************************************************************/
225:                 void ICMPSendPing(DWORD dwRemoteIP)
226:                 {
9D030564  27BDFFE8   ADDIU SP, SP, -24
9D030568  AFBF0014   SW RA, 20(SP)
9D03056C  AFBE0010   SW S8, 16(SP)
9D030570  03A0F021   ADDU S8, SP, ZERO
9D030574  AFC40018   SW A0, 24(S8)
227:                 	ICMPFlags.bReplyValid = 0;
9D030578  93828114   LBU V0, -32492(GP)
9D03057C  7C020844   INS V0, ZERO, 1, 1
9D030580  A3828114   SB V0, -32492(GP)
228:                 	ICMPTimer = TickGet();
9D030584  0F40CDD6   JAL TickGet
9D030588  00000000   NOP
9D03058C  AF828110   SW V0, -32496(GP)
229:                 	StaticVars.ICMPRemote.IPAddr.Val = dwRemoteIP;
9D030590  3C02A000   LUI V0, -24576
9D030594  8FC30018   LW V1, 24(S8)
9D030598  AC4332D0   SW V1, 13008(V0)
230:                 	ICMPState = SM_ARP_SEND_QUERY;
9D03059C  24020003   ADDIU V0, ZERO, 3
9D0305A0  AF828118   SW V0, -32488(GP)
231:                 }
9D0305A4  03C0E821   ADDU SP, S8, ZERO
9D0305A8  8FBF0014   LW RA, 20(SP)
9D0305AC  8FBE0010   LW S8, 16(SP)
9D0305B0  27BD0018   ADDIU SP, SP, 24
9D0305B4  03E00008   JR RA
9D0305B8  00000000   NOP
232:                 
233:                 #if defined(STACK_USE_DNS)
234:                 /*********************************************************************
235:                  * Function:        void ICMPSendPingToHost (BYTE * szRemoteHost)
236:                  *
237:                  * PreCondition:    ICMPBeginUsage() returned TRUE
238:                  *
239:                  * Input:           szRemoteHost: Host name to ping.  Must be stored 
240:                  *								  in RAM if being called by PIC18.
241:                  *								  Ex. www.microchip.com
242:                  *
243:                  * Output:          Begins the process of transmitting an ICMP echo 
244:                  *					request.  This normally involves an ARP 
245:                  *					resolution procedure first.
246:                  *
247:                  * Side Effects:    None
248:                  *
249:                  * Overview:        None
250:                  *
251:                  * Note:            None
252:                  ********************************************************************/
253:                 void ICMPSendPingToHost(BYTE * szRemoteHost)
254:                 {
9D0305BC  27BDFFE8   ADDIU SP, SP, -24
9D0305C0  AFBF0014   SW RA, 20(SP)
9D0305C4  AFBE0010   SW S8, 16(SP)
9D0305C8  03A0F021   ADDU S8, SP, ZERO
9D0305CC  AFC40018   SW A0, 24(S8)
255:                 	ICMPFlags.bReplyValid = 0;
9D0305D0  93828114   LBU V0, -32492(GP)
9D0305D4  7C020844   INS V0, ZERO, 1, 1
9D0305D8  A3828114   SB V0, -32492(GP)
256:                 	ICMPTimer = TickGet();
9D0305DC  0F40CDD6   JAL TickGet
9D0305E0  00000000   NOP
9D0305E4  AF828110   SW V0, -32496(GP)
257:                 	ICMPFlags.bRemoteHostIsROM = 0;
9D0305E8  93828114   LBU V0, -32492(GP)
9D0305EC  7C021084   INS V0, ZERO, 2, 1
9D0305F0  A3828114   SB V0, -32492(GP)
258:                 	StaticVars.RemoteHost.szRAM = szRemoteHost;
9D0305F4  3C02A000   LUI V0, -24576
9D0305F8  8FC30018   LW V1, 24(S8)
9D0305FC  AC4332D0   SW V1, 13008(V0)
259:                 	ICMPState = SM_DNS_SEND_QUERY;
9D030600  24020001   ADDIU V0, ZERO, 1
9D030604  AF828118   SW V0, -32488(GP)
260:                 }
9D030608  03C0E821   ADDU SP, S8, ZERO
9D03060C  8FBF0014   LW RA, 20(SP)
9D030610  8FBE0010   LW S8, 16(SP)
9D030614  27BD0018   ADDIU SP, SP, 24
9D030618  03E00008   JR RA
9D03061C  00000000   NOP
261:                 
262:                 #if defined(__18CXX)
263:                 
264:                 /*********************************************************************
265:                  * Function:        void ICMPSendPingToHostROM (ROM BYTE * szRemoteHost)
266:                  *
267:                  * PreCondition:    ICMPBeginUsage() returned TRUE
268:                  *
269:                  * Input:           szRemoteHost: Host name to ping.  Must be stored 
270:                  *								  in ROM. Should only be called by PIC18.
271:                  *								  Ex. www.microchip.com
272:                  *
273:                  * Output:          None
274:                  *
275:                  * Side Effects:    None
276:                  *
277:                  * Overview:        Begins the process of transmitting an ICMP echo 
278:                  *					request.  This normally involves an ARP 
279:                  *					resolution procedure first.
280:                  *
281:                  * Note:            None
282:                  ********************************************************************/
283:                 void ICMPSendPingToHostROM(ROM BYTE * szRemoteHost)
284:                 {
285:                 	ICMPFlags.bReplyValid = 0;
286:                 	ICMPTimer = TickGet();
287:                 	ICMPFlags.bRemoteHostIsROM = 1;
288:                 	StaticVars.RemoteHost.szROM = szRemoteHost;
289:                 	ICMPState = SM_DNS_SEND_QUERY;
290:                 }
291:                 
292:                 #endif
293:                 #endif
294:                 
295:                 /*********************************************************************
296:                  * Function:        LONG ICMPGetReply(void)
297:                  *
298:                  * PreCondition:    ICMPBeginUsage() returned TRUE and ICMPSendPing() 
299:                  *					was called
300:                  *
301:                  * Input:           None
302:                  *
303:                  * Output:          -3: Could not resolve hostname (DNS timeout or 
304:                  *			    	    hostname invalid)
305:                  *					-2: No response received yet
306:                  *					-1: Operation timed out (longer than ICMP_TIMEOUT) 
307:                  *						has elapsed.
308:                  *					>=0: Number of TICKs that elapsed between 
309:                  *						 initial ICMP transmission and reception of 
310:                  *						 a valid echo.
311:                  *
312:                  * Side Effects:    None
313:                  *
314:                  * Overview:        None
315:                  *
316:                  * Note:            None
317:                  ********************************************************************/
318:                 LONG ICMPGetReply(void)
319:                 {
9D030620  27BDFFD8   ADDIU SP, SP, -40
9D030624  AFBF0024   SW RA, 36(SP)
9D030628  AFBE0020   SW S8, 32(SP)
9D03062C  03A0F021   ADDU S8, SP, ZERO
320:                 	ICMP_PACKET ICMPPacket;
321:                 
322:                 	switch(ICMPState)
9D030630  8F828118   LW V0, -32488(GP)
9D030634  2C430007   SLTIU V1, V0, 7
9D030638  10600085   BEQ V1, ZERO, 0x9D030850
9D03063C  00000000   NOP
9D030640  00021880   SLL V1, V0, 2
9D030644  3C029D03   LUI V0, -25341
9D030648  2442065C   ADDIU V0, V0, 1628
9D03064C  00621021   ADDU V0, V1, V0
9D030650  8C420000   LW V0, 0(V0)
9D030654  00400008   JR V0
9D030658  00000000   NOP
323:                 	{
324:                 #if defined(STACK_USE_DNS)
325:                 		case SM_DNS_SEND_QUERY:
326:                 			// Obtain DNS module ownership
327:                 			if(!DNSBeginUsage())
9D030678  0F40A557   JAL DNSBeginUsage
9D03067C  00000000   NOP
9D030680  10400076   BEQ V0, ZERO, 0x9D03085C
9D030684  00000000   NOP
328:                 				break;
9D03085C  00000000   NOP
9D030860  0B40C224   J 0x9D030890
9D030864  00000000   NOP
329:                 			
330:                 			// Send DNS query
331:                 			if(ICMPFlags.bRemoteHostIsROM)
9D030688  93828114   LBU V0, -32492(GP)
9D03068C  30420004   ANDI V0, V0, 4
9D030690  304200FF   ANDI V0, V0, 255
9D030694  10400009   BEQ V0, ZERO, 0x9D0306BC
9D030698  00000000   NOP
332:                 				DNSResolveROM(StaticVars.RemoteHost.szROM, DNS_TYPE_A);
9D03069C  3C02A000   LUI V0, -24576
9D0306A0  8C4232D0   LW V0, 13008(V0)
9D0306A4  00402021   ADDU A0, V0, ZERO
9D0306A8  24050001   ADDIU A1, ZERO, 1
9D0306AC  0F40A588   JAL DNSResolve
9D0306B0  00000000   NOP
9D0306B4  0B40C1B5   J 0x9D0306D4
9D0306B8  00000000   NOP
333:                 			else
334:                 				DNSResolve(StaticVars.RemoteHost.szRAM, DNS_TYPE_A);
9D0306BC  3C02A000   LUI V0, -24576
9D0306C0  8C4232D0   LW V0, 13008(V0)
9D0306C4  00402021   ADDU A0, V0, ZERO
9D0306C8  24050001   ADDIU A1, ZERO, 1
9D0306CC  0F40A588   JAL DNSResolve
9D0306D0  00000000   NOP
335:                 			
336:                 			ICMPState = SM_DNS_GET_RESPONSE;
9D0306D4  24020002   ADDIU V0, ZERO, 2
9D0306D8  AF828118   SW V0, -32488(GP)
337:                 			break;
9D0306DC  0B40C224   J 0x9D030890
9D0306E0  00000000   NOP
338:                 				
339:                 		case SM_DNS_GET_RESPONSE:
340:                 			// See if DNS is done, and if so, get the remote IP address
341:                 			if(!DNSIsResolved(&StaticVars.ICMPRemote.IPAddr))
9D0306E4  3C02A000   LUI V0, -24576
9D0306E8  244432D0   ADDIU A0, V0, 13008
9D0306EC  0F40A5AD   JAL DNSIsResolved
9D0306F0  00000000   NOP
9D0306F4  1040005C   BEQ V0, ZERO, 0x9D030868
9D0306F8  00000000   NOP
342:                 				break;
9D030868  00000000   NOP
9D03086C  0B40C224   J 0x9D030890
9D030870  00000000   NOP
343:                 			
344:                 			// Free the DNS module
345:                 			DNSEndUsage();
9D0306FC  0F40A56C   JAL DNSEndUsage
9D030700  00000000   NOP
346:                 			
347:                 			// Return error code if the DNS query failed
348:                 			if(StaticVars.ICMPRemote.IPAddr.Val == 0x00000000ul)
9D030704  3C02A000   LUI V0, -24576
9D030708  8C4232D0   LW V0, 13008(V0)
9D03070C  14400005   BNE V0, ZERO, 0x9D030724
9D030710  00000000   NOP
349:                 			{
350:                 				ICMPState = SM_IDLE;
9D030714  AF808118   SW ZERO, -32488(GP)
351:                 				return -3;
9D030718  2402FFFD   ADDIU V0, ZERO, -3
9D03071C  0B40C239   J 0x9D0308E4
9D030720  00000000   NOP
352:                 			}
353:                 
354:                 			ICMPState = SM_ARP_SEND_QUERY;	
9D030724  24020003   ADDIU V0, ZERO, 3
9D030728  AF828118   SW V0, -32488(GP)
355:                 			// No break;	
356:                 #endif
357:                 
358:                 		case SM_ARP_SEND_QUERY:
359:                 			ARPResolve(&StaticVars.ICMPRemote.IPAddr);
9D03072C  3C02A000   LUI V0, -24576
9D030730  244432D0   ADDIU A0, V0, 13008
9D030734  0F40BCC0   JAL ARPResolve
9D030738  00000000   NOP
360:                 			ICMPState = SM_ARP_GET_RESPONSE;
9D03073C  24020004   ADDIU V0, ZERO, 4
9D030740  AF828118   SW V0, -32488(GP)
361:                 			break;
9D030744  0B40C224   J 0x9D030890
9D030748  00000000   NOP
362:                 			
363:                 		case SM_ARP_GET_RESPONSE:
364:                 			// See if the ARP reponse was successfully received
365:                 			if(!ARPIsResolved(&StaticVars.ICMPRemote.IPAddr, &StaticVars.ICMPRemote.MACAddr))
9D03074C  3C02A000   LUI V0, -24576
9D030750  244432D0   ADDIU A0, V0, 13008
9D030754  3C02A000   LUI V0, -24576
9D030758  244532D4   ADDIU A1, V0, 13012
9D03075C  0F40BCF9   JAL ARPIsResolved
9D030760  00000000   NOP
9D030764  10400043   BEQ V0, ZERO, 0x9D030874
9D030768  00000000   NOP
366:                 				break;
9D030874  00000000   NOP
9D030878  0B40C224   J 0x9D030890
9D03087C  00000000   NOP
367:                 			
368:                 			ICMPState = SM_ICMP_SEND_ECHO_REQUEST;
9D03076C  24020005   ADDIU V0, ZERO, 5
9D030770  AF828118   SW V0, -32488(GP)
369:                 			// No break; 
370:                 		
371:                 		case SM_ICMP_SEND_ECHO_REQUEST:
372:                 		    if(!IPIsTxReady())
9D030774  0F40727E   JAL MACIsTxReady
9D030778  00000000   NOP
9D03077C  10400040   BEQ V0, ZERO, 0x9D030880
9D030780  00000000   NOP
373:                 		    	break;
9D030880  00000000   NOP
9D030884  0B40C224   J 0x9D030890
9D030888  00000000   NOP
374:                 
375:                 			// Set up the ping packet
376:                 			ICMPPacket.vType = 0x08;	// 0x08: Echo (ping) request
9D030784  24020008   ADDIU V0, ZERO, 8
9D030788  A3C20010   SB V0, 16(S8)
377:                 			ICMPPacket.vCode = 0x00;
9D03078C  A3C00011   SB ZERO, 17(S8)
378:                 			ICMPPacket.wChecksum = 0x0000;
9D030790  A7C00012   SH ZERO, 18(S8)
379:                 			ICMPPacket.wIdentifier = 0xEFBE;
9D030794  2402EFBE   ADDIU V0, ZERO, -4162
9D030798  A7C20014   SH V0, 20(S8)
380:                 			wICMPSequenceNumber++; 
9D03079C  9782810C   LHU V0, -32500(GP)
9D0307A0  24420001   ADDIU V0, V0, 1
9D0307A4  3042FFFF   ANDI V0, V0, -1
9D0307A8  A782810C   SH V0, -32500(GP)
381:                 			ICMPPacket.wSequenceNumber = wICMPSequenceNumber;
9D0307AC  9782810C   LHU V0, -32500(GP)
9D0307B0  A7C20016   SH V0, 22(S8)
382:                 			ICMPPacket.wData = 0x2860;
9D0307B4  24022860   ADDIU V0, ZERO, 10336
9D0307B8  A7C20018   SH V0, 24(S8)
383:                 			ICMPPacket.wChecksum = CalcIPChecksum((BYTE*)&ICMPPacket, sizeof(ICMPPacket));
9D0307BC  27C20010   ADDIU V0, S8, 16
9D0307C0  00402021   ADDU A0, V0, ZERO
9D0307C4  2405000A   ADDIU A1, ZERO, 10
9D0307C8  0F409A63   JAL CalcIPChecksum
9D0307CC  00000000   NOP
9D0307D0  A7C20012   SH V0, 18(S8)
384:                 		
385:                 			// Record the current time.  This will be used as a basis for 
386:                 			// finding the echo response time, which exludes the ARP and DNS 
387:                 			// steps
388:                 			ICMPTimer = TickGet();
9D0307D4  0F40CDD6   JAL TickGet
9D0307D8  00000000   NOP
9D0307DC  AF828110   SW V0, -32496(GP)
389:                 
390:                 			// Position the write pointer for the next IPPutHeader operation
391:                 		    MACSetWritePtr(BASE_TX_ADDR + sizeof(ETHER_HEADER));
9D0307E0  2404000E   ADDIU A0, ZERO, 14
9D0307E4  0F407410   JAL MACSetWritePtr
9D0307E8  00000000   NOP
392:                 		
393:                 			// Create IP header in TX memory
394:                 			IPPutHeader(&StaticVars.ICMPRemote, IP_PROT_ICMP, sizeof(ICMPPacket));
9D0307EC  3C02A000   LUI V0, -24576
9D0307F0  244432D0   ADDIU A0, V0, 13008
9D0307F4  24050001   ADDIU A1, ZERO, 1
9D0307F8  2406000A   ADDIU A2, ZERO, 10
9D0307FC  0F40CEA6   JAL IPPutHeader
9D030800  00000000   NOP
395:                 			MACPutArray((BYTE*)&ICMPPacket, sizeof(ICMPPacket));
9D030804  27C20010   ADDIU V0, S8, 16
9D030808  00402021   ADDU A0, V0, ZERO
9D03080C  2405000A   ADDIU A1, ZERO, 10
9D030810  0F40759D   JAL MACPutArray
9D030814  00000000   NOP
396:                 			MACFlush();
9D030818  0F4073B4   JAL MACFlush
9D03081C  00000000   NOP
397:                 
398:                 			// Echo sent, advance state
399:                 			ICMPState = SM_ICMP_GET_ECHO_RESPONSE;
9D030820  24020006   ADDIU V0, ZERO, 6
9D030824  AF828118   SW V0, -32488(GP)
400:                 			break;
9D030828  0B40C224   J 0x9D030890
9D03082C  00000000   NOP
401:                 
402:                 		case SM_ICMP_GET_ECHO_RESPONSE:
403:                 			// See if the echo was successfully received
404:                 			if(ICMPFlags.bReplyValid)
9D030830  93828114   LBU V0, -32492(GP)
9D030834  30420002   ANDI V0, V0, 2
9D030838  304200FF   ANDI V0, V0, 255
9D03083C  10400013   BEQ V0, ZERO, 0x9D03088C
9D030840  00000000   NOP
405:                 				return (LONG)ICMPTimer;
9D030844  8F828110   LW V0, -32496(GP)
9D030848  0B40C239   J 0x9D0308E4
9D03084C  00000000   NOP
406:                 		
407:                 			break;
9D03088C  00000000   NOP
408:                 		
409:                 		// SM_IDLE or illegal/impossible state:
410:                 		default:
411:                 			return -1;
9D030850  2402FFFF   ADDIU V0, ZERO, -1
9D030854  0B40C239   J 0x9D0308E4
9D030858  00000000   NOP
412:                 	}
413:                 
414:                 	// See if the DNS/ARP/echo request timed out
415:                 	if(TickGet() - ICMPTimer > ICMP_TIMEOUT)
9D030890  0F40CDD6   JAL TickGet
9D030894  00000000   NOP
9D030898  00401821   ADDU V1, V0, ZERO
9D03089C  8F828110   LW V0, -32496(GP)
9D0308A0  00621823   SUBU V1, V1, V0
9D0308A4  3C020009   LUI V0, 9
9D0308A8  34428969   ORI V0, V0, -30359
9D0308AC  0062102B   SLTU V0, V1, V0
9D0308B0  1440000B   BNE V0, ZERO, 0x9D0308E0
9D0308B4  00000000   NOP
416:                 	{
417:                 		// Free DNS module if we have it in use
418:                 		#if defined(STACK_USE_DNS)
419:                 			if(ICMPState == SM_DNS_GET_RESPONSE)
9D0308B8  8F838118   LW V1, -32488(GP)
9D0308BC  24020002   ADDIU V0, ZERO, 2
9D0308C0  14620003   BNE V1, V0, 0x9D0308D0
9D0308C4  00000000   NOP
420:                 				DNSEndUsage();
9D0308C8  0F40A56C   JAL DNSEndUsage
9D0308CC  00000000   NOP
421:                 		#endif
422:                 		
423:                 		// Stop ICMP echo test and return error to caller
424:                 		ICMPState = SM_IDLE;
9D0308D0  AF808118   SW ZERO, -32488(GP)
425:                 		return -1;
9D0308D4  2402FFFF   ADDIU V0, ZERO, -1
9D0308D8  0B40C239   J 0x9D0308E4
9D0308DC  00000000   NOP
426:                 	}
427:                 
428:                 	// Still working.  No response to report yet.
429:                 	return -2;
9D0308E0  2402FFFE   ADDIU V0, ZERO, -2
430:                 }
9D0308E4  03C0E821   ADDU SP, S8, ZERO
9D0308E8  8FBF0024   LW RA, 36(SP)
9D0308EC  8FBE0020   LW S8, 32(SP)
9D0308F0  27BD0028   ADDIU SP, SP, 40
9D0308F4  03E00008   JR RA
9D0308F8  00000000   NOP
431:                 
432:                 
433:                 /*********************************************************************
434:                  * Function:        BOOL ICMPBeginUsage(void)
435:                  *
436:                  * PreCondition:    None
437:                  *
438:                  * Input:           None
439:                  *
440:                  * Output:          TRUE: You have successfully gained ownership of 
441:                  *						  the ICMP client module and can now use the 
442:                  *						  ICMPSendPing() and ICMPGetReply() functions.
443:                  *					FALSE: Some other application is using the ICMP 
444:                  *						   client module.  Calling ICMPSendPing() 
445:                  *						   will corrupt the other application's ping 
446:                  *						   result.
447:                  *
448:                  * Side Effects:    None
449:                  *
450:                  * Overview:        Claims ownership of the ICMP module.
451:                  *
452:                  * Note:            None
453:                  ********************************************************************/
454:                 BOOL ICMPBeginUsage(void)
455:                 {
9D0308FC  27BDFFF8   ADDIU SP, SP, -8
9D030900  AFBE0004   SW S8, 4(SP)
9D030904  03A0F021   ADDU S8, SP, ZERO
456:                 	if(ICMPFlags.bICMPInUse)
9D030908  93828114   LBU V0, -32492(GP)
9D03090C  30420001   ANDI V0, V0, 1
9D030910  304200FF   ANDI V0, V0, 255
9D030914  10400004   BEQ V0, ZERO, 0x9D030928
9D030918  00000000   NOP
457:                 		return FALSE;
9D03091C  00001021   ADDU V0, ZERO, ZERO
9D030920  0B40C24F   J 0x9D03093C
9D030924  00000000   NOP
458:                 
459:                 	ICMPFlags.bICMPInUse = TRUE;
9D030928  93828114   LBU V0, -32492(GP)
9D03092C  24030001   ADDIU V1, ZERO, 1
9D030930  7C620004   INS V0, V1, 0, 1
9D030934  A3828114   SB V0, -32492(GP)
460:                 	return TRUE;
9D030938  24020001   ADDIU V0, ZERO, 1
461:                 }
9D03093C  03C0E821   ADDU SP, S8, ZERO
9D030940  8FBE0004   LW S8, 4(SP)
9D030944  27BD0008   ADDIU SP, SP, 8
9D030948  03E00008   JR RA
9D03094C  00000000   NOP
462:                 
463:                 
464:                 /*********************************************************************
465:                  * Function:        void ICMPEndUsage(void)
466:                  *
467:                  * PreCondition:    ICMPBeginUsage() was called by you and it 
468:                  *					returned TRUE.
469:                  *
470:                  * Input:           None
471:                  *
472:                  * Output:          Your ownership of the ICMP module is released.  
473:                  *					You can no longer use ICMPSendPing().
474:                  *
475:                  * Side Effects:    None
476:                  *
477:                  * Overview:        Gives up ownership of the ICMP module.
478:                  *
479:                  * Note:            None
480:                  ********************************************************************/
481:                 void ICMPEndUsage(void)
482:                 {
9D030950  27BDFFF8   ADDIU SP, SP, -8
9D030954  AFBE0004   SW S8, 4(SP)
9D030958  03A0F021   ADDU S8, SP, ZERO
483:                 	ICMPFlags.bICMPInUse = FALSE;
9D03095C  93828114   LBU V0, -32492(GP)
9D030960  7C020004   INS V0, ZERO, 0, 1
9D030964  A3828114   SB V0, -32492(GP)
484:                 }
9D030968  03C0E821   ADDU SP, S8, ZERO
9D03096C  8FBE0004   LW S8, 4(SP)
9D030970  27BD0008   ADDIU SP, SP, 8
9D030974  03E00008   JR RA
9D030978  00000000   NOP
485:                 
486:                 #endif //#if defined(STACK_USE_ICMP_CLIENT)
487:                 
488:                 #endif //#if defined(STACK_USE_ICMP_SERVER) || defined(STACK_USE_ICMP_CLIENT)
---  C:/Users/Diego/Documents/GitHub/pic32webFREERtos/Pic32Web.X/src/tcpip/src/Helpers.c  ---------------
1:                   /*********************************************************************
2:                    
3:                    Helper Functions for Microchip TCPIP Stack
4:                    
5:                    FileName:      Helpers.c
6:                    Dependencies:  See INCLUDES section
7:                    Processor:     PIC18, PIC24, dsPIC, PIC32
8:                    Compiler:      Microchip C18, C30, C32
9:                    Company:       Microchip Technology, Inc.
10:                  
11:                   Software License Agreement
12:                  
13:                   Copyright (C) 2002-2011 Microchip Technology Inc.  All rights
14:                   reserved.
15:                  
16:                   Microchip licenses to you the right to use, modify, copy, and
17:                   distribute:
18:                   (i)  the Software when embedded on a Microchip microcontroller or
19:                        digital signal controller product ("Device") which is
20:                        integrated into Licensee's product; or
21:                   (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h,
22:                  		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device
23:                  		used in conjunction with a Microchip ethernet controller for
24:                  		the sole purpose of interfacing with the ethernet controller.
25:                  
26:                   You should refer to the license agreement accompanying this
27:                   Software for additional information regarding your rights and
28:                   obligations.
29:                  
30:                   THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT
31:                   WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT
32:                   LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A
33:                   PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL
34:                   MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR
35:                   CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF
36:                   PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS
37:                   BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE
38:                   THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER
39:                   SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT
40:                   (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE.
41:                  
42:                   ********************************************************************
43:                   File Description:
44:                   
45:                   Change History:
46:                   
47:                    Rev         Description
48:                    ----------  -------------------------------------------------------
49:                    1.0 - 5.31  Initial release; Rewritten CalcIPChecksum() to avoid
50:                                multi-byte shift operation; Added hexatob(),
51:                                btohexa_high(), and btohexa_low(); Optimized swapl();
52:                                Added leftRotateDWORD()
53:                    5.36        Updated compile time check for ultoa();
54:                  
55:                   ********************************************************************/
56:                  #define __HELPERS_C
57:                  
58:                  #include <stdarg.h>
59:                  #include "TCPIP Stack/TCPIP.h"
60:                  
61:                  
62:                  // Default Random Number Generator seed. 0x41FE9F9E corresponds to calling LFSRSeedRand(1)
63:                  static DWORD dwLFSRRandSeed = 0x41FE9F9E;
64:                  
65:                  /*****************************************************************************
66:                    Function:
67:                  	DWORD LFSRSeedRand(DWORD dwSeed)
68:                  
69:                    Summary:
70:                  	Seeds the LFSR random number generator invoked by the LFSRRand() function.  
71:                  	The prior seed is returned.
72:                  
73:                    Description:
74:                  	Seeds the LFSR random number generator invoked by the LFSRRand() function.  
75:                  	The prior seed is returned.
76:                  
77:                    Precondition:
78:                  	None
79:                  
80:                    Parameters:
81:                  	wSeed - The new 32-bit seed value to assign to the LFSR.
82:                  
83:                    Returns:
84:                    	The last seed in use.  This can be saved and restored by a subsequent call 
85:                  	to LFSRSeedRand() if you wish to use LFSRRand() in multiple contexts 
86:                  	without disrupting the random number sequence from the alternative 
87:                  	context.  For example, if App 1 needs a given sequence of random numbers 
88:                  	to perform a test, if you save and restore the seed in App 2, it is 
89:                  	possible for App 2 to not disrupt the random number sequence provided to 
90:                  	App 1, even if the number of times App 2 calls LFSRRand() varies.
91:                    	
92:                    Side Effects:
93:                  	None
94:                  	
95:                    Remarks:
96:                  	Upon initial power up, the internal seed is initialized to 0x1.  Using a 
97:                  	dwSeed value of 0x0 will return the same sequence of random numbers as 
98:                  	using the seed of 0x1.
99:                    ***************************************************************************/
100:                 DWORD LFSRSeedRand(DWORD dwSeed)
101:                 {
9D0257B0  27BDFFE0   ADDIU SP, SP, -32
9D0257B4  AFBF001C   SW RA, 28(SP)
9D0257B8  AFBE0018   SW S8, 24(SP)
9D0257BC  03A0F021   ADDU S8, SP, ZERO
9D0257C0  AFC40020   SW A0, 32(S8)
102:                 	DWORD dwOldSeed;
103:                 	BYTE i;
104:                 
105:                 	// Save original seed to be returned later
106:                 	dwOldSeed = dwLFSRRandSeed;
9D0257C4  8F828020   LW V0, -32736(GP)
9D0257C8  AFC20014   SW V0, 20(S8)
107:                 
108:                 	// Ensure zero isn't selected as a seed value, this would result in all 
109:                 	// 0x0000 output values from the LFSR
110:                 	if(dwSeed == 0u)
9D0257CC  8FC20020   LW V0, 32(S8)
9D0257D0  14400003   BNE V0, ZERO, 0x9D0257E0
9D0257D4  00000000   NOP
111:                 		dwSeed = 1;
9D0257D8  24020001   ADDIU V0, ZERO, 1
9D0257DC  AFC20020   SW V0, 32(S8)
112:                 		
113:                 	// Set the new seed
114:                 	dwLFSRRandSeed = dwSeed;
9D0257E0  8FC20020   LW V0, 32(S8)
9D0257E4  AF828020   SW V0, -32736(GP)
115:                 	
116:                 	// Run the LFSR a few times to get rid of obvious start up artifacts for 
117:                 	// seed values that don't have many set bits.
118:                 	for(i = 0; i < 16; i++)
9D0257E8  A3C00010   SB ZERO, 16(S8)
9D0257EC  0B409602   J 0x9D025808
9D0257F0  00000000   NOP
9D0257FC  93C20010   LBU V0, 16(S8)
9D025800  24420001   ADDIU V0, V0, 1
9D025804  A3C20010   SB V0, 16(S8)
9D025808  93C20010   LBU V0, 16(S8)
9D02580C  2C420010   SLTIU V0, V0, 16
9D025810  1440FFF8   BNE V0, ZERO, 0x9D0257F4
9D025814  00000000   NOP
119:                 		LFSRRand();
9D0257F4  0F40960D   JAL LFSRRand
9D0257F8  00000000   NOP
120:                 	
121:                 	// Return saved old seed
122:                 	return dwOldSeed;
9D025818  8FC20014   LW V0, 20(S8)
123:                 }
9D02581C  03C0E821   ADDU SP, S8, ZERO
9D025820  8FBF001C   LW RA, 28(SP)
9D025824  8FBE0018   LW S8, 24(SP)
9D025828  27BD0020   ADDIU SP, SP, 32
9D02582C  03E00008   JR RA
9D025830  00000000   NOP
124:                 
125:                 /*****************************************************************************
126:                   Function:
127:                 	WORD LFSRRand(void)
128:                 
129:                   Summary:
130:                 	Returns a pseudo-random 16-bit unsigned integer in the range from 0 
131:                 	to 65535 (0x0000 to 0xFFFF).
132:                 
133:                   Description:
134:                 	Returns a pseudo-random 16-bit unsigned integer in the range from 0 
135:                 	to 65535 (0x0000 to 0xFFFF).  The random number is generated using a 
136:                 	Linear Feedback Shift Register (LFSR) type pseudo-random number generator 
137:                 	algorithm.  The LFSR can be seeded by calling the LFSRSeedRand() function
138:                 	to generate the same sequence of random numbers as a prior string of calls.
139:                 	
140:                 	The internal LFSR will repeat after 2^32-1 iterations.
141:                 
142:                   Precondition:
143:                 	None
144:                 
145:                   Parameters:
146:                 	None
147:                 
148:                   Returns:
149:                   	Random 16-bit unsigned integer.
150:                   	
151:                   Side Effects:
152:                 	The internal LFSR seed is updated so that the next call to LFSRRand() 
153:                 	will return a different random number.
154:                 	
155:                   Remarks:
156:                 	None
157:                   ***************************************************************************/
158:                 WORD LFSRRand(void)
159:                 {
9D025834  27BDFFF0   ADDIU SP, SP, -16
9D025838  AFBE000C   SW S8, 12(SP)
9D02583C  03A0F021   ADDU S8, SP, ZERO
160:                 	BYTE i;
161:                 	
162:                 	// Taps: 32 31 29 1
163:                 	// Characteristic polynomial: x^32 + x^31 + x^29 + x + 1
164:                 	// Repeat 15 times to make the shift pattern less obvious
165:                 	for(i = 0; i < 15; i++)
9D025840  A3C00000   SB ZERO, 0(S8)
9D025844  0B409620   J 0x9D025880
9D025848  00000000   NOP
9D025874  93C20000   LBU V0, 0(S8)
9D025878  24420001   ADDIU V0, V0, 1
9D02587C  A3C20000   SB V0, 0(S8)
9D025880  93C20000   LBU V0, 0(S8)
9D025884  2C42000F   SLTIU V0, V0, 15
9D025888  1440FFF0   BNE V0, ZERO, 0x9D02584C
9D02588C  00000000   NOP
166:                 		dwLFSRRandSeed = (dwLFSRRandSeed >> 1) ^ ((0ul - (dwLFSRRandSeed & 1ul)) & 0xD0000001ul);
9D02584C  8F828020   LW V0, -32736(GP)
9D025850  00021842   SRL V1, V0, 1
9D025854  8F828020   LW V0, -32736(GP)
9D025858  30420001   ANDI V0, V0, 1
9D02585C  00022023   SUBU A0, ZERO, V0
9D025860  3C02D000   LUI V0, -12288
9D025864  34420001   ORI V0, V0, 1
9D025868  00821024   AND V0, A0, V0
9D02586C  00621026   XOR V0, V1, V0
9D025870  AF828020   SW V0, -32736(GP)
167:                 
168:                 	// Return 16-bits as pseudo-random number
169:                 	return (WORD)dwLFSRRandSeed;
9D025890  8F828020   LW V0, -32736(GP)
9D025894  3042FFFF   ANDI V0, V0, -1
170:                 }
9D025898  03C0E821   ADDU SP, S8, ZERO
9D02589C  8FBE000C   LW S8, 12(SP)
9D0258A0  27BD0010   ADDIU SP, SP, 16
9D0258A4  03E00008   JR RA
9D0258A8  00000000   NOP
171:                 
172:                 
173:                 /*****************************************************************************
174:                   Function:
175:                 	DWORD GenerateRandomDWORD(void)
176:                 
177:                   Summary:
178:                 	Generates a random DWORD.
179:                 
180:                   Description:
181:                 	This function generates a random 32-bit integer.  It collects
182:                 	randomness by comparing the A/D converter's internal R/C oscillator
183:                 	clock with our main system clock.  By passing collected entropy to the
184:                 	LFSRSeedRand()/LFSRRand() functions, the output is normalized (deskewed) 
185:                 	in the hopes of meeting statistical randomness tests.
186:                 
187:                   Precondition:
188:                 	None
189:                 
190:                   Parameters:
191:                 	None
192:                 
193:                   Returns:
194:                   	Random 32-bit number.
195:                   	
196:                   Side Effects:
197:                 	This function uses the A/D converter (and so you must disable 
198:                 	interrupts if you use the A/D converted in your ISR).  The LFSRRand() 
199:                 	function will be reseeded, and Timer0 (PIC18) and Timer1 (PIC24, 
200:                 	dsPIC, and PIC32) will be used.  TMR#H:TMR#L will have a new value.
201:                 	Note that this is the same timer used by the Tick module.
202:                 	
203:                   Remarks:
204:                 	This function times out after 1 second of attempting to generate the 
205:                 	random DWORD.  In such a case, the output may not be truly random.  
206:                 	Typically, this function executes in around 500,000 instruction cycles.
207:                 	
208:                 	The intent of this function is to produce statistically random and
209:                 	cryptographically secure random number.  Whether or not this is true on
210:                 	all (or any) devices/voltages/temperatures is not tested.
211:                   ***************************************************************************/
212:                 DWORD GenerateRandomDWORD(void)
213:                 {
9D0258AC  27BDFFC0   ADDIU SP, SP, -64
9D0258B0  AFBF003C   SW RA, 60(SP)
9D0258B4  AFBE0038   SW S8, 56(SP)
9D0258B8  AFB00034   SW S0, 52(SP)
9D0258BC  03A0F021   ADDU S8, SP, ZERO
214:                 	BYTE vBitCount;
215:                 	WORD w, wTime, wLastValue;
216:                 	DWORD dwTotalTime;
217:                 	union
218:                 	{
219:                 		DWORD	dw;
220:                 		WORD	w[2];
221:                 	} randomResult;
222:                 
223:                 #if defined __18CXX	
224:                 {
225:                 	BYTE ADCON0Save, ADCON2Save;
226:                 	BYTE T0CONSave, TMR0HSave, TMR0LSave;
227:                 
228:                 	// Save hardware SFRs
229:                 	ADCON0Save = ADCON0;
230:                 	ADCON2Save = ADCON2;
231:                 	T0CONSave = T0CON;
232:                 	TMR0LSave = TMR0L;
233:                 	TMR0HSave = TMR0H;
234:                 
235:                 	// Set up Timer and A/D converter module
236:                 	ADCON0 = 0x01;	// Turn on the A/D module
237:                 	ADCON2 = 0x3F;	// 20 Tad acquisition, Frc A/D clock used for conversion
238:                 	T0CON = 0x88;	// TMR0ON = 1, no prescalar
239:                 	vBitCount = 0;
240:                 	dwTotalTime = 0;
241:                 	wLastValue = 0;
242:                 	randomResult.dw = LFSRRand();
243:                 	while(1)
244:                 	{
245:                 		// Time the duration of an A/D acquisition and conversion
246:                 		TMR0H = 0x00;
247:                 		TMR0L = 0x00;
248:                 		ADCON0bits.GO = 1;
249:                 		ClrWdt();
250:                 		while(ADCON0bits.GO);
251:                 		((BYTE*)&wTime)[0] = TMR0L;
252:                 		((BYTE*)&wTime)[1] = TMR0H;
253:                 		w = LFSRRand();
254:                 	
255:                 		// Wait no longer than 1 second obtaining entropy
256:                 		dwTotalTime += wTime;
257:                 		if(dwTotalTime >= GetInstructionClock())
258:                 		{
259:                 			randomResult.w[0] ^= LFSRRand();
260:                 			randomResult.w[1] ^= LFSRRand();
261:                 			break;
262:                 		}
263:                 	
264:                 		// Keep sampling if minimal entropy was likely obtained this round
265:                 		if(wLastValue == wTime)
266:                 			continue;
267:                 	
268:                 		// Add this entropy into the pseudo random number generator by reseeding
269:                 		LFSRSeedRand(w + (wLastValue - wTime));
270:                 		wLastValue = wTime;
271:                 	
272:                 		// Accumulate at least 32 bits of randomness over time
273:                 		randomResult.dw <<= 1;
274:                 		if(LFSRRand() & 0x0080)
275:                 			randomResult.w[0] |= 0x1;
276:                 	
277:                 		// See if we've collected a fair amount of entropy and can quit early
278:                 		if(++vBitCount == 0u)
279:                 			break;
280:                 	}
281:                 
282:                 	// Restore hardware SFRs
283:                 	ADCON0 = ADCON0Save;
284:                 	ADCON2 = ADCON2Save;
285:                 	TMR0H = TMR0HSave;
286:                 	TMR0L = TMR0LSave;
287:                 	T0CON = T0CONSave;
288:                 }
289:                 #else
290:                 {
291:                 	WORD AD1CON1Save, AD1CON2Save, AD1CON3Save;
292:                 	WORD T1CONSave, PR1Save;
293:                 
294:                 	// Save hardware SFRs
295:                 	AD1CON1Save = AD1CON1;
9D0258C0  3C02BF81   LUI V0, -16511
9D0258C4  8C429000   LW V0, -28672(V0)
9D0258C8  A7C20018   SH V0, 24(S8)
296:                 	AD1CON2Save = AD1CON2;
9D0258CC  3C02BF81   LUI V0, -16511
9D0258D0  8C429010   LW V0, -28656(V0)
9D0258D4  A7C2001A   SH V0, 26(S8)
297:                 	AD1CON3Save = AD1CON3;
9D0258D8  3C02BF81   LUI V0, -16511
9D0258DC  8C429020   LW V0, -28640(V0)
9D0258E0  A7C2001C   SH V0, 28(S8)
298:                 	T1CONSave = T1CON;
9D0258E4  3C02BF80   LUI V0, -16512
9D0258E8  8C420600   LW V0, 1536(V0)
9D0258EC  A7C2001E   SH V0, 30(S8)
299:                 	PR1Save = PR1;
9D0258F0  3C02BF80   LUI V0, -16512
9D0258F4  8C420620   LW V0, 1568(V0)
9D0258F8  A7C20020   SH V0, 32(S8)
300:                 
301:                 	// Set up Timer and A/D converter module
302:                 	AD1CON1 = 0x0000;		// Turn off the ADC so we can write to it
9D0258FC  3C02BF81   LUI V0, -16511
9D025900  AC409000   SW ZERO, -28672(V0)
303:                 	AD1CON3 = 0x9F00;		// Frc A/D clock, 31 Tad acquisition
9D025904  3C02BF81   LUI V0, -16511
9D025908  34039F00   ORI V1, ZERO, -24832
9D02590C  AC439020   SW V1, -28640(V0)
304:                 	AD1CON2 = 0x003F;		// Interrupt after every 16th sample/convert
9D025910  3C02BF81   LUI V0, -16511
9D025914  2403003F   ADDIU V1, ZERO, 63
9D025918  AC439010   SW V1, -28656(V0)
305:                 	AD1CON1 = 0x80E4;		// Turn on the A/D module, auto-convert
9D02591C  3C02BF81   LUI V0, -16511
9D025920  340380E4   ORI V1, ZERO, -32540
9D025924  AC439000   SW V1, -28672(V0)
306:                 	T1CON = 0x8000;			// TON = 1, no prescalar
9D025928  3C02BF80   LUI V0, -16512
9D02592C  34038000   ORI V1, ZERO, -32768
9D025930  AC430600   SW V1, 1536(V0)
307:                 	PR1 = 0xFFFF;			// Don't clear timer early
9D025934  3C02BF80   LUI V0, -16512
9D025938  3403FFFF   ORI V1, ZERO, -1
9D02593C  AC430620   SW V1, 1568(V0)
308:                 	vBitCount = 0;
9D025940  A3C00010   SB ZERO, 16(S8)
309:                 	dwTotalTime = 0;
9D025944  AFC00014   SW ZERO, 20(S8)
310:                 	wLastValue = 0;
9D025948  A7C00012   SH ZERO, 18(S8)
311:                 	randomResult.dw = LFSRRand();
9D02594C  0F40960D   JAL LFSRRand
9D025950  00000000   NOP
9D025954  AFC20028   SW V0, 40(S8)
9D025958  0B409659   J 0x9D025964
9D02595C  00000000   NOP
312:                 	while(1)
313:                 	{
314:                 		ClrWdt();
9D025964  3C02BF80   LUI V0, -16512
9D025968  24030001   ADDIU V1, ZERO, 1
9D02596C  AC430008   SW V1, 8(V0)
315:                 		#if defined(__C30__)
316:                 			while(!IFS0bits.AD1IF);
317:                 		#else
318:                 			while(!IFS1bits.AD1IF);
9D025970  00000000   NOP
9D025974  3C02BF88   LUI V0, -16504
9D025978  8C421040   LW V0, 4160(V0)
9D02597C  30420002   ANDI V0, V0, 2
9D025980  1040FFFC   BEQ V0, ZERO, 0x9D025974
9D025984  00000000   NOP
319:                 		#endif
320:                 		wTime = TMR1;
9D025988  3C02BF80   LUI V0, -16512
9D02598C  8C420610   LW V0, 1552(V0)
9D025990  A7C20022   SH V0, 34(S8)
321:                 		TMR1 = 0x0000;
9D025994  3C02BF80   LUI V0, -16512
9D025998  AC400610   SW ZERO, 1552(V0)
322:                 
323:                 		#if defined(__C30__)
324:                 			IFS0bits.AD1IF = 0;
325:                 		#else
326:                 			IFS1CLR = _IFS1_AD1IF_MASK;
9D02599C  3C02BF88   LUI V0, -16504
9D0259A0  24030002   ADDIU V1, ZERO, 2
9D0259A4  AC431044   SW V1, 4164(V0)
327:                 		#endif
328:                 		w = LFSRRand();
9D0259A8  0F40960D   JAL LFSRRand
9D0259AC  00000000   NOP
9D0259B0  A7C20024   SH V0, 36(S8)
329:                 	
330:                 		// Wait no longer than 1 second obtaining entropy
331:                 		dwTotalTime += wTime;
9D0259B4  97C20022   LHU V0, 34(S8)
9D0259B8  8FC30014   LW V1, 20(S8)
9D0259BC  00621021   ADDU V0, V1, V0
9D0259C0  AFC20014   SW V0, 20(S8)
332:                 		if(dwTotalTime >= GetInstructionClock())
9D0259C4  8FC30014   LW V1, 20(S8)
9D0259C8  3C0204C4   LUI V0, 1220
9D0259CC  3442B400   ORI V0, V0, -19456
9D0259D0  0062102B   SLTU V0, V1, V0
9D0259D4  1440000F   BNE V0, ZERO, 0x9D025A14
9D0259D8  00000000   NOP
333:                 		{
334:                 			randomResult.w[0] ^= LFSRRand();
9D0259DC  97D00028   LHU S0, 40(S8)
9D0259E0  0F40960D   JAL LFSRRand
9D0259E4  00000000   NOP
9D0259E8  02021026   XOR V0, S0, V0
9D0259EC  3042FFFF   ANDI V0, V0, -1
9D0259F0  A7C20028   SH V0, 40(S8)
335:                 			randomResult.w[1] ^= LFSRRand();
9D0259F4  97D0002A   LHU S0, 42(S8)
9D0259F8  0F40960D   JAL LFSRRand
9D0259FC  00000000   NOP
9D025A00  02021026   XOR V0, S0, V0
9D025A04  3042FFFF   ANDI V0, V0, -1
9D025A08  A7C2002A   SH V0, 42(S8)
336:                 			break;
9D025A0C  0B4096A9   J 0x9D025AA4
9D025A10  00000000   NOP
337:                 		}
338:                 	
339:                 		// Keep sampling if minimal entropy was likely obtained this round
340:                 		if(wLastValue == wTime)
9D025A14  97C30012   LHU V1, 18(S8)
9D025A18  97C20022   LHU V0, 34(S8)
9D025A1C  14620004   BNE V1, V0, 0x9D025A30
9D025A20  00000000   NOP
341:                 			continue;
9D025A24  00000000   NOP
342:                 	
343:                 		// Add this entropy into the pseudo random number generator by reseeding
344:                 		LFSRSeedRand(w + (wLastValue - wTime));
9D025A30  97C30024   LHU V1, 36(S8)
9D025A34  97C40012   LHU A0, 18(S8)
9D025A38  97C20022   LHU V0, 34(S8)
9D025A3C  00821023   SUBU V0, A0, V0
9D025A40  00621021   ADDU V0, V1, V0
9D025A44  00402021   ADDU A0, V0, ZERO
9D025A48  0F4095EC   JAL LFSRSeedRand
9D025A4C  00000000   NOP
345:                 		wLastValue = wTime;
9D025A50  97C20022   LHU V0, 34(S8)
9D025A54  A7C20012   SH V0, 18(S8)
346:                 	
347:                 		// Accumulate at least 32 bits of randomness over time
348:                 		randomResult.dw <<= 1;
9D025A58  8FC20028   LW V0, 40(S8)
9D025A5C  00021040   SLL V0, V0, 1
9D025A60  AFC20028   SW V0, 40(S8)
349:                 		if(LFSRRand() & 0x0080)
9D025A64  0F40960D   JAL LFSRRand
9D025A68  00000000   NOP
9D025A6C  30420080   ANDI V0, V0, 128
9D025A70  10400005   BEQ V0, ZERO, 0x9D025A88
9D025A74  00000000   NOP
350:                 			randomResult.w[0] |= 0x1;
9D025A78  97C20028   LHU V0, 40(S8)
9D025A7C  34420001   ORI V0, V0, 1
9D025A80  3042FFFF   ANDI V0, V0, -1
9D025A84  A7C20028   SH V0, 40(S8)
351:                 	
352:                 		// See if we've collected a fair amount of entropy and can quit early
353:                 		if(++vBitCount == 0u)
9D025A88  93C20010   LBU V0, 16(S8)
9D025A8C  24420001   ADDIU V0, V0, 1
9D025A90  A3C20010   SB V0, 16(S8)
9D025A94  93C20010   LBU V0, 16(S8)
9D025A98  1440FFB1   BNE V0, ZERO, 0x9D025960
9D025A9C  00000000   NOP
354:                 			break;
9D025AA0  00000000   NOP
355:                 	}
9D025960  00000000   NOP
9D025A28  0B409659   J 0x9D025964
9D025A2C  00000000   NOP
356:                 
357:                 
358:                 	// Restore hardware SFRs
359:                 	AD1CON1 = 0x0000;		// Turn off the ADC so we can write to it
9D025AA4  3C02BF81   LUI V0, -16511
9D025AA8  AC409000   SW ZERO, -28672(V0)
360:                 	AD1CON3 = AD1CON3Save;
9D025AAC  97C3001C   LHU V1, 28(S8)
9D025AB0  3C02BF81   LUI V0, -16511
9D025AB4  AC439020   SW V1, -28640(V0)
361:                 	AD1CON2 = AD1CON2Save;
9D025AB8  97C3001A   LHU V1, 26(S8)
9D025ABC  3C02BF81   LUI V0, -16511
9D025AC0  AC439010   SW V1, -28656(V0)
362:                 	AD1CON1 = AD1CON1Save;
9D025AC4  97C30018   LHU V1, 24(S8)
9D025AC8  3C02BF81   LUI V0, -16511
9D025ACC  AC439000   SW V1, -28672(V0)
363:                 	T1CON = T1CONSave;
9D025AD0  97C3001E   LHU V1, 30(S8)
9D025AD4  3C02BF80   LUI V0, -16512
9D025AD8  AC430600   SW V1, 1536(V0)
364:                 	PR1 = PR1Save;
9D025ADC  97C30020   LHU V1, 32(S8)
9D025AE0  3C02BF80   LUI V0, -16512
9D025AE4  AC430620   SW V1, 1568(V0)
365:                 }
366:                 #endif
367:                 
368:                 	return randomResult.dw;
9D025AE8  8FC20028   LW V0, 40(S8)
369:                 }
9D025AEC  03C0E821   ADDU SP, S8, ZERO
9D025AF0  8FBF003C   LW RA, 60(SP)
9D025AF4  8FBE0038   LW S8, 56(SP)
9D025AF8  8FB00034   LW S0, 52(SP)
9D025AFC  27BD0040   ADDIU SP, SP, 64
9D025B00  03E00008   JR RA
9D025B04  00000000   NOP
370:                 
371:                 
372:                 #if defined(STACK_USE_HTTP_SERVER)
373:                 /*****************************************************************************
374:                   Function:
375:                 	void UnencodeURL(BYTE* URL)
376:                 
377:                   Summary:
378:                 	Decodes a URL-encoded string.
379:                 
380:                   Description:
381:                 	This function is deprecated except for use with HTTP Classic.  It
382:                 	attempts to decode a URL encoded string, converting all hex escape
383:                 	sequences into a literal byte.  However, it is inefficient over long
384:                 	strings and does not handle URL-encoded data strings ('&' and '=').
385:                 
386:                   Precondition:
387:                 	None
388:                 
389:                   Parameters:
390:                 	URL - the null-terminated string to decode
391:                 
392:                   Returns:
393:                   	None
394:                   ***************************************************************************/
395:                 void UnencodeURL(BYTE* URL)
396:                 {
397:                 	BYTE *Right, *Copy;
398:                 	WORD_VAL Number;
399:                 
400:                 	while((Right = (BYTE*)strchr((char*)URL, '%')))
401:                 	{
402:                 		// Make sure the string is long enough
403:                 		if(Right[1] == '\0')
404:                 			break;
405:                 		if(Right[2] == '\0')
406:                 			break;
407:                 
408:                 		// Update the string in place
409:                 		Number.v[0] = Right[2];
410:                 		Number.v[1] = Right[1];
411:                 		*Right++ = hexatob(Number);
412:                 		URL = Right;
413:                 
414:                 		// Remove two blank spots by shifting all remaining characters right two
415:                 		Copy = Right + 2;
416:                 		while((*Right++ = *Copy++));
417:                 	}
418:                 }		    
419:                 #endif
420:                 
421:                 
422:                 /*****************************************************************************
423:                   Function:
424:                 	BOOL StringToIPAddress(BYTE* str, IP_ADDR* IPAddress)
425:                 
426:                   Summary:
427:                 	Converts a string to an IP address
428:                 
429:                   Description:
430:                 	This function parses a dotted-quad decimal IP address string into an 
431:                 	IP_ADDR struct.  The output result is big-endian.
432:                 	
433:                   Precondition:
434:                 	None
435:                 
436:                   Parameters:
437:                 	str - Pointer to a dotted-quad IP address string
438:                 	IPAddress - Pointer to IP_ADDR in which to store the result
439:                 
440:                   Return Values:
441:                   	TRUE - an IP address was successfully decoded
442:                   	FALSE - no IP address could be found, or the format was incorrect
443:                   ***************************************************************************/
444:                 BOOL StringToIPAddress(BYTE* str, IP_ADDR* IPAddress)
445:                 {
9D025B08  27BDFFF0   ADDIU SP, SP, -16
9D025B0C  AFBE000C   SW S8, 12(SP)
9D025B10  03A0F021   ADDU S8, SP, ZERO
9D025B14  AFC40010   SW A0, 16(S8)
9D025B18  AFC50014   SW A1, 20(S8)
446:                 	DWORD_VAL dwVal;
447:                 	BYTE i, charLen, currentOctet;
448:                 
449:                 	charLen = 0;
9D025B1C  A3C00000   SB ZERO, 0(S8)
450:                 	currentOctet = 0;
9D025B20  A3C00001   SB ZERO, 1(S8)
451:                 	dwVal.Val = 0;
9D025B24  AFC00004   SW ZERO, 4(S8)
452:                 	while((i = *str++))
9D025B28  0B40973D   J 0x9D025CF4
9D025B2C  00000000   NOP
9D025CF4  8FC20010   LW V0, 16(S8)
9D025CF8  90420000   LBU V0, 0(V0)
9D025CFC  A3C20002   SB V0, 2(S8)
9D025D00  93C20002   LBU V0, 2(S8)
9D025D04  0002102B   SLTU V0, ZERO, V0
9D025D08  304200FF   ANDI V0, V0, 255
9D025D0C  8FC30010   LW V1, 16(S8)
9D025D10  24630001   ADDIU V1, V1, 1
9D025D14  AFC30010   SW V1, 16(S8)
9D025D18  1440FF85   BNE V0, ZERO, 0x9D025B30
9D025D1C  00000000   NOP
9D025D20  0B40974B   J 0x9D025D2C
9D025D24  00000000   NOP
453:                 	{
454:                 		if(currentOctet > 3u)
9D025B30  93C20001   LBU V0, 1(S8)
9D025B34  2C420004   SLTIU V0, V0, 4
9D025B38  1040007B   BEQ V0, ZERO, 0x9D025D28
9D025B3C  00000000   NOP
455:                 			break;
9D025D28  00000000   NOP
456:                 
457:                 		i -= '0';
9D025B40  93C20002   LBU V0, 2(S8)
9D025B44  2442FFD0   ADDIU V0, V0, -48
9D025B48  A3C20002   SB V0, 2(S8)
458:                 		
459:                 
460:                 		// Validate the character is a numerical digit or dot, depending on location
461:                 		if(charLen == 0u)
9D025B4C  93C20000   LBU V0, 0(S8)
9D025B50  14400008   BNE V0, ZERO, 0x9D025B74
9D025B54  00000000   NOP
462:                 		{
463:                 			if(i > 9u)
9D025B58  93C20002   LBU V0, 2(S8)
9D025B5C  2C42000A   SLTIU V0, V0, 10
9D025B60  1440005C   BNE V0, ZERO, 0x9D025CD4
9D025B64  00000000   NOP
464:                 				return FALSE;
9D025B68  00001021   ADDU V0, ZERO, ZERO
9D025B6C  0B409782   J 0x9D025E08
9D025B70  00000000   NOP
465:                 		}
466:                 		else if(charLen == 3u)
9D025B74  93C30000   LBU V1, 0(S8)
9D025B78  24020003   ADDIU V0, ZERO, 3
9D025B7C  14620029   BNE V1, V0, 0x9D025C24
9D025B80  00000000   NOP
467:                 		{
468:                 			if(i != (BYTE)('.' - '0'))
9D025B84  93C30002   LBU V1, 2(S8)
9D025B88  240200FE   ADDIU V0, ZERO, 254
9D025B8C  10620004   BEQ V1, V0, 0x9D025BA0
9D025B90  00000000   NOP
469:                 				return FALSE;
9D025B94  00001021   ADDU V0, ZERO, ZERO
9D025B98  0B409782   J 0x9D025E08
9D025B9C  00000000   NOP
470:                 
471:                 			if(dwVal.Val > 0x00020505ul)
9D025BA0  8FC30004   LW V1, 4(S8)
9D025BA4  3C020002   LUI V0, 2
9D025BA8  34420506   ORI V0, V0, 1286
9D025BAC  0062102B   SLTU V0, V1, V0
9D025BB0  14400004   BNE V0, ZERO, 0x9D025BC4
9D025BB4  00000000   NOP
472:                 				return FALSE;
9D025BB8  00001021   ADDU V0, ZERO, ZERO
9D025BBC  0B409782   J 0x9D025E08
9D025BC0  00000000   NOP
473:                 
474:                 			IPAddress->v[currentOctet++] = dwVal.v[2]*((BYTE)100) + dwVal.v[1]*((BYTE)10) + dwVal.v[0];
9D025BC4  93C20001   LBU V0, 1(S8)
9D025BC8  93C40006   LBU A0, 6(S8)
9D025BCC  24030064   ADDIU V1, ZERO, 100
9D025BD0  70831802   MUL V1, A0, V1
9D025BD4  306400FF   ANDI A0, V1, 255
9D025BD8  93C50005   LBU A1, 5(S8)
9D025BDC  2403000A   ADDIU V1, ZERO, 10
9D025BE0  70A31802   MUL V1, A1, V1
9D025BE4  306300FF   ANDI V1, V1, 255
9D025BE8  00831821   ADDU V1, A0, V1
9D025BEC  306400FF   ANDI A0, V1, 255
9D025BF0  93C30004   LBU V1, 4(S8)
9D025BF4  00831821   ADDU V1, A0, V1
9D025BF8  306300FF   ANDI V1, V1, 255
9D025BFC  8FC40014   LW A0, 20(S8)
9D025C00  00821021   ADDU V0, A0, V0
9D025C04  A0430000   SB V1, 0(V0)
9D025C08  93C20001   LBU V0, 1(S8)
9D025C0C  24420001   ADDIU V0, V0, 1
9D025C10  A3C20001   SB V0, 1(S8)
475:                 			charLen = 0;
9D025C14  A3C00000   SB ZERO, 0(S8)
476:                 			dwVal.Val = 0;
9D025C18  AFC00004   SW ZERO, 4(S8)
477:                 			continue;
9D025C1C  0B40973D   J 0x9D025CF4
9D025C20  00000000   NOP
478:                 		}
479:                 		else
480:                 		{
481:                 			if(i == (BYTE)('.' - '0'))
9D025C24  93C30002   LBU V1, 2(S8)
9D025C28  240200FE   ADDIU V0, ZERO, 254
9D025C2C  14620022   BNE V1, V0, 0x9D025CB8
9D025C30  00000000   NOP
482:                 			{
483:                 				if(dwVal.Val > 0x00020505ul)
9D025C34  8FC30004   LW V1, 4(S8)
9D025C38  3C020002   LUI V0, 2
9D025C3C  34420506   ORI V0, V0, 1286
9D025C40  0062102B   SLTU V0, V1, V0
9D025C44  14400004   BNE V0, ZERO, 0x9D025C58
9D025C48  00000000   NOP
484:                 					return FALSE;
9D025C4C  00001021   ADDU V0, ZERO, ZERO
9D025C50  0B409782   J 0x9D025E08
9D025C54  00000000   NOP
485:                 
486:                 				IPAddress->v[currentOctet++] = dwVal.v[2]*((BYTE)100) + dwVal.v[1]*((BYTE)10) + dwVal.v[0];
9D025C58  93C20001   LBU V0, 1(S8)
9D025C5C  93C40006   LBU A0, 6(S8)
9D025C60  24030064   ADDIU V1, ZERO, 100
9D025C64  70831802   MUL V1, A0, V1
9D025C68  306400FF   ANDI A0, V1, 255
9D025C6C  93C50005   LBU A1, 5(S8)
9D025C70  2403000A   ADDIU V1, ZERO, 10
9D025C74  70A31802   MUL V1, A1, V1
9D025C78  306300FF   ANDI V1, V1, 255
9D025C7C  00831821   ADDU V1, A0, V1
9D025C80  306400FF   ANDI A0, V1, 255
9D025C84  93C30004   LBU V1, 4(S8)
9D025C88  00831821   ADDU V1, A0, V1
9D025C8C  306300FF   ANDI V1, V1, 255
9D025C90  8FC40014   LW A0, 20(S8)
9D025C94  00821021   ADDU V0, A0, V0
9D025C98  A0430000   SB V1, 0(V0)
9D025C9C  93C20001   LBU V0, 1(S8)
9D025CA0  24420001   ADDIU V0, V0, 1
9D025CA4  A3C20001   SB V0, 1(S8)
487:                 				charLen = 0;
9D025CA8  A3C00000   SB ZERO, 0(S8)
488:                 				dwVal.Val = 0;
9D025CAC  AFC00004   SW ZERO, 4(S8)
489:                 				continue;
9D025CB0  0B40973D   J 0x9D025CF4
9D025CB4  00000000   NOP
490:                 			}
491:                 			if(i > 9u)
9D025CB8  93C20002   LBU V0, 2(S8)
9D025CBC  2C42000A   SLTIU V0, V0, 10
9D025CC0  14400004   BNE V0, ZERO, 0x9D025CD4
9D025CC4  00000000   NOP
492:                 				return FALSE;
9D025CC8  00001021   ADDU V0, ZERO, ZERO
9D025CCC  0B409782   J 0x9D025E08
9D025CD0  00000000   NOP
493:                 		}
494:                 
495:                 		charLen++;
9D025CD4  93C20000   LBU V0, 0(S8)
9D025CD8  24420001   ADDIU V0, V0, 1
9D025CDC  A3C20000   SB V0, 0(S8)
496:                 		dwVal.Val <<= 8;
9D025CE0  8FC20004   LW V0, 4(S8)
9D025CE4  00021200   SLL V0, V0, 8
9D025CE8  AFC20004   SW V0, 4(S8)
497:                 		dwVal.v[0] = i;
9D025CEC  93C20002   LBU V0, 2(S8)
9D025CF0  A3C20004   SB V0, 4(S8)
498:                 	}
499:                 
500:                 	// Make sure the very last character is a valid termination character 
501:                 	// (i.e., not more hostname, which could be legal and not an IP 
502:                 	// address as in "10.5.13.233.picsaregood.com"
503:                 	if(i != 0u && i != '/' && i != '\r' && i != '\n' && i != ' ' && i != '\t' && i != ':')
9D025D2C  93C20002   LBU V0, 2(S8)
9D025D30  1040001C   BEQ V0, ZERO, 0x9D025DA4
9D025D34  00000000   NOP
9D025D38  93C30002   LBU V1, 2(S8)
9D025D3C  2402002F   ADDIU V0, ZERO, 47
9D025D40  10620018   BEQ V1, V0, 0x9D025DA4
9D025D44  00000000   NOP
9D025D48  93C30002   LBU V1, 2(S8)
9D025D4C  2402000D   ADDIU V0, ZERO, 13
9D025D50  10620014   BEQ V1, V0, 0x9D025DA4
9D025D54  00000000   NOP
9D025D58  93C30002   LBU V1, 2(S8)
9D025D5C  2402000A   ADDIU V0, ZERO, 10
9D025D60  10620010   BEQ V1, V0, 0x9D025DA4
9D025D64  00000000   NOP
9D025D68  93C30002   LBU V1, 2(S8)
9D025D6C  24020020   ADDIU V0, ZERO, 32
9D025D70  1062000C   BEQ V1, V0, 0x9D025DA4
9D025D74  00000000   NOP
9D025D78  93C30002   LBU V1, 2(S8)
9D025D7C  24020009   ADDIU V0, ZERO, 9
9D025D80  10620008   BEQ V1, V0, 0x9D025DA4
9D025D84  00000000   NOP
9D025D88  93C30002   LBU V1, 2(S8)
9D025D8C  2402003A   ADDIU V0, ZERO, 58
9D025D90  10620004   BEQ V1, V0, 0x9D025DA4
9D025D94  00000000   NOP
504:                 		return FALSE;
9D025D98  00001021   ADDU V0, ZERO, ZERO
9D025D9C  0B409782   J 0x9D025E08
9D025DA0  00000000   NOP
505:                 
506:                 	// Verify and convert the last octet and return the result
507:                 	if(dwVal.Val > 0x00020505ul)
9D025DA4  8FC30004   LW V1, 4(S8)
9D025DA8  3C020002   LUI V0, 2
9D025DAC  34420506   ORI V0, V0, 1286
9D025DB0  0062102B   SLTU V0, V1, V0
9D025DB4  14400004   BNE V0, ZERO, 0x9D025DC8
9D025DB8  00000000   NOP
508:                 		return FALSE;
9D025DBC  00001021   ADDU V0, ZERO, ZERO
9D025DC0  0B409782   J 0x9D025E08
9D025DC4  00000000   NOP
509:                 
510:                 	IPAddress->v[3] = dwVal.v[2]*((BYTE)100) + dwVal.v[1]*((BYTE)10) + dwVal.v[0];
9D025DC8  93C30006   LBU V1, 6(S8)
9D025DCC  24020064   ADDIU V0, ZERO, 100
9D025DD0  70621002   MUL V0, V1, V0
9D025DD4  304300FF   ANDI V1, V0, 255
9D025DD8  93C40005   LBU A0, 5(S8)
9D025DDC  2402000A   ADDIU V0, ZERO, 10
9D025DE0  70821002   MUL V0, A0, V0
9D025DE4  304200FF   ANDI V0, V0, 255
9D025DE8  00621021   ADDU V0, V1, V0
9D025DEC  304300FF   ANDI V1, V0, 255
9D025DF0  93C20004   LBU V0, 4(S8)
9D025DF4  00621021   ADDU V0, V1, V0
9D025DF8  304300FF   ANDI V1, V0, 255
9D025DFC  8FC20014   LW V0, 20(S8)
9D025E00  A0430003   SB V1, 3(V0)
511:                 
512:                 	return TRUE;
9D025E04  24020001   ADDIU V0, ZERO, 1
513:                 }
9D025E08  03C0E821   ADDU SP, S8, ZERO
9D025E0C  8FBE000C   LW S8, 12(SP)
9D025E10  27BD0010   ADDIU SP, SP, 16
9D025E14  03E00008   JR RA
9D025E18  00000000   NOP
514:                 
515:                 /*****************************************************************************
516:                   Function:
517:                 	BOOL ROMStringToIPAddress(ROM BYTE* str, IP_ADDR* IPAddress)
518:                 
519:                   Summary:
520:                 	Converts a string to an IP address
521:                 
522:                   Description:
523:                 	This function parses a dotted-quad decimal IP address string into an 
524:                 	IP_ADDR struct.  The output result is big-endian.
525:                 	
526:                   Precondition:
527:                 	None
528:                 
529:                   Parameters:
530:                 	str - Pointer to a dotted-quad IP address string
531:                 	IPAddress - Pointer to IP_ADDR in which to store the result
532:                 
533:                   Return Values:
534:                   	TRUE - an IP address was successfully decoded
535:                   	FALSE - no IP address could be found, or the format was incorrect
536:                   
537:                   Remarks:
538:                 	This function is aliased to StringToIPAddress on non-PIC18 platforms.
539:                   ***************************************************************************/
540:                 #if defined(__18CXX)
541:                 BOOL ROMStringToIPAddress(ROM BYTE* str, IP_ADDR* IPAddress)
542:                 {
543:                 	DWORD_VAL dwVal;
544:                 	BYTE i, charLen, currentOctet;
545:                 
546:                 	charLen = 0;
547:                 	currentOctet = 0;
548:                 	dwVal.Val = 0;
549:                 	while(i = *str++)
550:                 	{
551:                 		if(currentOctet > 3u)
552:                 			break;
553:                 
554:                 		i -= '0';
555:                 		
556:                 
557:                 		// Validate the character is a numerical digit or dot, depending on location
558:                 		if(charLen == 0u)
559:                 		{
560:                 			if(i > 9u)
561:                 				return FALSE;
562:                 		}
563:                 		else if(charLen == 3u)
564:                 		{
565:                 			if(i != (BYTE)('.' - '0'))
566:                 				return FALSE;
567:                 
568:                 			if(dwVal.Val > 0x00020505ul)
569:                 				return FALSE;
570:                 
571:                 			IPAddress->v[currentOctet++] = dwVal.v[2]*((BYTE)100) + dwVal.v[1]*((BYTE)10) + dwVal.v[0];
572:                 			charLen = 0;
573:                 			dwVal.Val = 0;
574:                 			continue;
575:                 		}
576:                 		else
577:                 		{
578:                 			if(i == (BYTE)('.' - '0'))
579:                 			{
580:                 				if(dwVal.Val > 0x00020505ul)
581:                 					return FALSE;
582:                 
583:                 				IPAddress->v[currentOctet++] = dwVal.v[2]*((BYTE)100) + dwVal.v[1]*((BYTE)10) + dwVal.v[0];
584:                 				charLen = 0;
585:                 				dwVal.Val = 0;
586:                 				continue;
587:                 			}
588:                 			if(i > 9u)
589:                 				return FALSE;
590:                 		}
591:                 
592:                 		charLen++;
593:                 		dwVal.Val <<= 8;
594:                 		dwVal.v[0] = i;
595:                 	}
596:                 
597:                 	// Make sure the very last character is a valid termination character 
598:                 	// (i.e., not more hostname, which could be legal and not an IP 
599:                 	// address as in "10.5.13.233.picsaregood.com"
600:                 	if(i != 0u && i != '/' && i != '\r' && i != '\n' && i != ' ' && i != '\t')
601:                 		return FALSE;
602:                 
603:                 	// Verify and convert the last octet and return the result
604:                 	if(dwVal.Val > 0x00020505ul)
605:                 		return FALSE;
606:                 
607:                 	IPAddress->v[3] = dwVal.v[2]*((BYTE)100) + dwVal.v[1]*((BYTE)10) + dwVal.v[0];
608:                 
609:                 	return TRUE;
610:                 }
611:                 #endif
612:                 
613:                 
614:                 
615:                 /*****************************************************************************
616:                   Function:
617:                 	WORD Base64Decode(BYTE* cSourceData, WORD wSourceLen, 
618:                 						BYTE* cDestData, WORD wDestLen)
619:                 
620:                   Description:
621:                 	Decodes a Base-64 array to its literal representation.
622:                 	
623:                   Precondition:
624:                 	None
625:                 
626:                   Parameters:
627:                 	cSourceData - Pointer to a string of Base-64 encoded data
628:                 	wSourceLen	- Length of the Base-64 source data
629:                 	cDestData	- Pointer to write the decoded data
630:                 	wSourceLen	- Maximum length that can be written to cDestData
631:                 
632:                   Returns:
633:                   	Number of decoded bytes written to cDestData.
634:                   
635:                   Remarks:
636:                 	This function is binary safe and will ignore invalid characters (CR, LF, 
637:                 	etc).  If cSourceData is equal to cDestData, the data will be converted
638:                 	in-place.  If cSourceData is not equal to cDestData, but the regions 
639:                 	overlap, the behavior is undefined.
640:                 	
641:                 	Decoded data is always at least 1/4 smaller than the source data.
642:                   ***************************************************************************/
643:                 #if defined(STACK_USE_BASE64_DECODE)
644:                 WORD Base64Decode(BYTE* cSourceData, WORD wSourceLen, BYTE* cDestData, WORD wDestLen)
645:                 {
9D025E1C  27BDFFF0   ADDIU SP, SP, -16
9D025E20  AFBE000C   SW S8, 12(SP)
9D025E24  03A0F021   ADDU S8, SP, ZERO
9D025E28  AFC40010   SW A0, 16(S8)
9D025E2C  00A01821   ADDU V1, A1, ZERO
9D025E30  AFC60018   SW A2, 24(S8)
9D025E34  00E01021   ADDU V0, A3, ZERO
9D025E38  A7C30014   SH V1, 20(S8)
9D025E3C  A7C2001C   SH V0, 28(S8)
646:                 	BYTE i;
647:                 	BYTE vByteNumber;
648:                 	WORD wBytesOutput;
649:                 
650:                 	vByteNumber = 0;
9D025E40  A3C00001   SB ZERO, 1(S8)
651:                 	wBytesOutput = 0;
9D025E44  A7C00002   SH ZERO, 2(S8)
652:                 
653:                 	// Loop over all provided bytes
654:                 	while(wSourceLen--)
9D025E48  0B40983B   J 0x9D0260EC
9D025E4C  00000000   NOP
9D0260EC  97C20014   LHU V0, 20(S8)
9D0260F0  0002102B   SLTU V0, ZERO, V0
9D0260F4  304200FF   ANDI V0, V0, 255
9D0260F8  97C30014   LHU V1, 20(S8)
9D0260FC  2463FFFF   ADDIU V1, V1, -1
9D026100  A7C30014   SH V1, 20(S8)
9D026104  1440FF52   BNE V0, ZERO, 0x9D025E50
9D026108  00000000   NOP
9D02610C  0B40984C   J 0x9D026130
9D026110  00000000   NOP
655:                 	{
656:                 		// Fetch a Base64 byte and decode it to the original 6 bits
657:                 		i = *cSourceData++;
9D025E50  8FC20010   LW V0, 16(S8)
9D025E54  90420000   LBU V0, 0(V0)
9D025E58  A3C20000   SB V0, 0(S8)
9D025E5C  8FC20010   LW V0, 16(S8)
9D025E60  24420001   ADDIU V0, V0, 1
9D025E64  AFC20010   SW V0, 16(S8)
658:                 		if(i >= 'A' && i <= 'Z')	// Regular data
9D025E68  93C20000   LBU V0, 0(S8)
9D025E6C  2C420041   SLTIU V0, V0, 65
9D025E70  1440000A   BNE V0, ZERO, 0x9D025E9C
9D025E74  00000000   NOP
9D025E78  93C20000   LBU V0, 0(S8)
9D025E7C  2C42005B   SLTIU V0, V0, 91
9D025E80  10400006   BEQ V0, ZERO, 0x9D025E9C
9D025E84  00000000   NOP
659:                 			i -= 'A' - 0;
9D025E88  93C20000   LBU V0, 0(S8)
9D025E8C  2442FFBF   ADDIU V0, V0, -65
9D025E90  A3C20000   SB V0, 0(S8)
9D025E94  0B4097D7   J 0x9D025F5C
9D025E98  00000000   NOP
660:                 		else if(i >= 'a' && i <= 'z')
9D025E9C  93C20000   LBU V0, 0(S8)
9D025EA0  2C420061   SLTIU V0, V0, 97
9D025EA4  1440000A   BNE V0, ZERO, 0x9D025ED0
9D025EA8  00000000   NOP
9D025EAC  93C20000   LBU V0, 0(S8)
9D025EB0  2C42007B   SLTIU V0, V0, 123
9D025EB4  10400006   BEQ V0, ZERO, 0x9D025ED0
9D025EB8  00000000   NOP
661:                 			i -= 'a' - 26;
9D025EBC  93C20000   LBU V0, 0(S8)
9D025EC0  2442FFB9   ADDIU V0, V0, -71
9D025EC4  A3C20000   SB V0, 0(S8)
9D025EC8  0B4097D7   J 0x9D025F5C
9D025ECC  00000000   NOP
662:                 		else if(i >= '0' && i <= '9')
9D025ED0  93C20000   LBU V0, 0(S8)
9D025ED4  2C420030   SLTIU V0, V0, 48
9D025ED8  1440000A   BNE V0, ZERO, 0x9D025F04
9D025EDC  00000000   NOP
9D025EE0  93C20000   LBU V0, 0(S8)
9D025EE4  2C42003A   SLTIU V0, V0, 58
9D025EE8  10400006   BEQ V0, ZERO, 0x9D025F04
9D025EEC  00000000   NOP
663:                 			i -= '0' - 52;
9D025EF0  93C20000   LBU V0, 0(S8)
9D025EF4  24420004   ADDIU V0, V0, 4
9D025EF8  A3C20000   SB V0, 0(S8)
9D025EFC  0B4097D7   J 0x9D025F5C
9D025F00  00000000   NOP
664:                 		else if(i == '+' || i == '-')
9D025F04  93C30000   LBU V1, 0(S8)
9D025F08  2402002B   ADDIU V0, ZERO, 43
9D025F0C  10620005   BEQ V1, V0, 0x9D025F24
9D025F10  00000000   NOP
9D025F14  93C30000   LBU V1, 0(S8)
9D025F18  2402002D   ADDIU V0, ZERO, 45
9D025F1C  14620005   BNE V1, V0, 0x9D025F34
9D025F20  00000000   NOP
665:                 			i = 62;
9D025F24  2402003E   ADDIU V0, ZERO, 62
9D025F28  A3C20000   SB V0, 0(S8)
9D025F2C  0B4097D7   J 0x9D025F5C
9D025F30  00000000   NOP
666:                 		else if(i == '/' || i == '_')
9D025F34  93C30000   LBU V1, 0(S8)
9D025F38  2402002F   ADDIU V0, ZERO, 47
9D025F3C  10620005   BEQ V1, V0, 0x9D025F54
9D025F40  00000000   NOP
9D025F44  93C30000   LBU V1, 0(S8)
9D025F48  2402005F   ADDIU V0, ZERO, 95
9D025F4C  14620066   BNE V1, V0, 0x9D0260E8
9D025F50  00000000   NOP
667:                 			i = 63;
9D025F54  2402003F   ADDIU V0, ZERO, 63
9D025F58  A3C20000   SB V0, 0(S8)
668:                 		else 						// Skip all padding (=) and non-Base64 characters
669:                 			continue;
9D0260E8  00000000   NOP
670:                 
671:                 
672:                 		// Write the 6 bits to the correct destination location(s)
673:                 		if(vByteNumber == 0u)
9D025F5C  93C20001   LBU V0, 1(S8)
9D025F60  14400013   BNE V0, ZERO, 0x9D025FB0
9D025F64  00000000   NOP
674:                 		{
675:                 			vByteNumber++;
9D025F68  93C20001   LBU V0, 1(S8)
9D025F6C  24420001   ADDIU V0, V0, 1
9D025F70  A3C20001   SB V0, 1(S8)
676:                 			if(wBytesOutput >= wDestLen)
9D025F74  97C30002   LHU V1, 2(S8)
9D025F78  97C2001C   LHU V0, 28(S8)
9D025F7C  0062102B   SLTU V0, V1, V0
9D025F80  10400064   BEQ V0, ZERO, 0x9D026114
9D025F84  00000000   NOP
677:                 				break;
9D026114  00000000   NOP
9D026118  0B40984C   J 0x9D026130
9D02611C  00000000   NOP
678:                 			wBytesOutput++;
9D025F88  97C20002   LHU V0, 2(S8)
9D025F8C  24420001   ADDIU V0, V0, 1
9D025F90  A7C20002   SH V0, 2(S8)
679:                 			*cDestData = i << 2;
9D025F94  93C20000   LBU V0, 0(S8)
9D025F98  00021080   SLL V0, V0, 2
9D025F9C  304300FF   ANDI V1, V0, 255
9D025FA0  8FC20018   LW V0, 24(S8)
9D025FA4  A0430000   SB V1, 0(V0)
9D025FA8  0B40983B   J 0x9D0260EC
9D025FAC  00000000   NOP
680:                 		}
681:                 		else if(vByteNumber == 1u)
9D025FB0  93C30001   LBU V1, 1(S8)
9D025FB4  24020001   ADDIU V0, ZERO, 1
9D025FB8  1462001E   BNE V1, V0, 0x9D026034
9D025FBC  00000000   NOP
682:                 		{
683:                 			vByteNumber++;
9D025FC0  93C20001   LBU V0, 1(S8)
9D025FC4  24420001   ADDIU V0, V0, 1
9D025FC8  A3C20001   SB V0, 1(S8)
684:                 			*cDestData++ |= i >> 4;
9D025FCC  8FC20018   LW V0, 24(S8)
9D025FD0  90440000   LBU A0, 0(V0)
9D025FD4  93C30000   LBU V1, 0(S8)
9D025FD8  00031902   SRL V1, V1, 4
9D025FDC  306300FF   ANDI V1, V1, 255
9D025FE0  00831825   OR V1, A0, V1
9D025FE4  306300FF   ANDI V1, V1, 255
9D025FE8  A0430000   SB V1, 0(V0)
9D025FEC  8FC20018   LW V0, 24(S8)
9D025FF0  24420001   ADDIU V0, V0, 1
9D025FF4  AFC20018   SW V0, 24(S8)
685:                 			if(wBytesOutput >= wDestLen)
9D025FF8  97C30002   LHU V1, 2(S8)
9D025FFC  97C2001C   LHU V0, 28(S8)
9D026000  0062102B   SLTU V0, V1, V0
9D026004  10400046   BEQ V0, ZERO, 0x9D026120
9D026008  00000000   NOP
686:                 				break;
9D026120  00000000   NOP
9D026124  0B40984C   J 0x9D026130
9D026128  00000000   NOP
687:                 			wBytesOutput++;
9D02600C  97C20002   LHU V0, 2(S8)
9D026010  24420001   ADDIU V0, V0, 1
9D026014  A7C20002   SH V0, 2(S8)
688:                 			*cDestData = i << 4;
9D026018  93C20000   LBU V0, 0(S8)
9D02601C  00021100   SLL V0, V0, 4
9D026020  304300FF   ANDI V1, V0, 255
9D026024  8FC20018   LW V0, 24(S8)
9D026028  A0430000   SB V1, 0(V0)
9D02602C  0B40983B   J 0x9D0260EC
9D026030  00000000   NOP
689:                 		}
690:                 		else if(vByteNumber == 2u)
9D026034  93C30001   LBU V1, 1(S8)
9D026038  24020002   ADDIU V0, ZERO, 2
9D02603C  1462001E   BNE V1, V0, 0x9D0260B8
9D026040  00000000   NOP
691:                 		{
692:                 			vByteNumber++;
9D026044  93C20001   LBU V0, 1(S8)
9D026048  24420001   ADDIU V0, V0, 1
9D02604C  A3C20001   SB V0, 1(S8)
693:                 			*cDestData++ |= i >> 2;
9D026050  8FC20018   LW V0, 24(S8)
9D026054  90440000   LBU A0, 0(V0)
9D026058  93C30000   LBU V1, 0(S8)
9D02605C  00031882   SRL V1, V1, 2
9D026060  306300FF   ANDI V1, V1, 255
9D026064  00831825   OR V1, A0, V1
9D026068  306300FF   ANDI V1, V1, 255
9D02606C  A0430000   SB V1, 0(V0)
9D026070  8FC20018   LW V0, 24(S8)
9D026074  24420001   ADDIU V0, V0, 1
9D026078  AFC20018   SW V0, 24(S8)
694:                 			if(wBytesOutput >= wDestLen)
9D02607C  97C30002   LHU V1, 2(S8)
9D026080  97C2001C   LHU V0, 28(S8)
9D026084  0062102B   SLTU V0, V1, V0
9D026088  10400028   BEQ V0, ZERO, 0x9D02612C
9D02608C  00000000   NOP
695:                 				break;
9D02612C  00000000   NOP
696:                 			wBytesOutput++;
9D026090  97C20002   LHU V0, 2(S8)
9D026094  24420001   ADDIU V0, V0, 1
9D026098  A7C20002   SH V0, 2(S8)
697:                 			*cDestData = i << 6;
9D02609C  93C20000   LBU V0, 0(S8)
9D0260A0  00021180   SLL V0, V0, 6
9D0260A4  304300FF   ANDI V1, V0, 255
9D0260A8  8FC20018   LW V0, 24(S8)
9D0260AC  A0430000   SB V1, 0(V0)
9D0260B0  0B40983B   J 0x9D0260EC
9D0260B4  00000000   NOP
698:                 		}
699:                 		else
700:                 		{
701:                 			vByteNumber = 0;
9D0260B8  A3C00001   SB ZERO, 1(S8)
702:                 			*cDestData++ |= i;
9D0260BC  8FC20018   LW V0, 24(S8)
9D0260C0  90440000   LBU A0, 0(V0)
9D0260C4  93C30000   LBU V1, 0(S8)
9D0260C8  00831825   OR V1, A0, V1
9D0260CC  306300FF   ANDI V1, V1, 255
9D0260D0  A0430000   SB V1, 0(V0)
9D0260D4  8FC20018   LW V0, 24(S8)
9D0260D8  24420001   ADDIU V0, V0, 1
9D0260DC  AFC20018   SW V0, 24(S8)
9D0260E0  0B40983B   J 0x9D0260EC
9D0260E4  00000000   NOP
703:                 		}
704:                 	}
705:                 
706:                 	return wBytesOutput;
9D026130  97C20002   LHU V0, 2(S8)
707:                 }
9D026134  03C0E821   ADDU SP, S8, ZERO
9D026138  8FBE000C   LW S8, 12(SP)
9D02613C  27BD0010   ADDIU SP, SP, 16
9D026140  03E00008   JR RA
9D026144  00000000   NOP
708:                 #endif	// #if defined(STACK_USE_BASE64_DECODE)
709:                 
710:                 
711:                 /*****************************************************************************
712:                   Function:
713:                 	WORD Base64Encode(BYTE* cSourceData, WORD wSourceLen,
714:                 						BYTE* cDestData, WORD wDestLen)
715:                 
716:                   Description:
717:                 	Encodes a binary array to Base-64.
718:                 	
719:                   Precondition:
720:                 	None
721:                 
722:                   Parameters:
723:                 	cSourceData - Pointer to a string of binary data
724:                 	wSourceLen	- Length of the binary source data
725:                 	cDestData	- Pointer to write the Base-64 encoded data
726:                 	wSourceLen	- Maximum length that can be written to cDestData
727:                 
728:                   Returns:
729:                   	Number of encoded bytes written to cDestData.  This will always be
730:                   	a multiple of 4.
731:                   
732:                   Remarks:
733:                 	Encoding cannot be performed in-place.  If cSourceData overlaps with 
734:                 	cDestData, the behavior is undefined.
735:                 	
736:                 	Encoded data is always at least 1/3 larger than the source data.  It may
737:                 	be 1 or 2 bytes larger than that.
738:                   ***************************************************************************/
739:                 #if defined(STACK_USE_BASE64_ENCODE) || defined(STACK_USE_SMTP_CLIENT) || defined(STACK_USE_DYNAMICDNS_CLIENT)
740:                 WORD Base64Encode(BYTE* cSourceData, WORD wSourceLen, BYTE* cDestData, WORD wDestLen)
741:                 {
9D026148  27BDFFF0   ADDIU SP, SP, -16
9D02614C  AFBE000C   SW S8, 12(SP)
9D026150  03A0F021   ADDU S8, SP, ZERO
9D026154  AFC40010   SW A0, 16(S8)
9D026158  00A01821   ADDU V1, A1, ZERO
9D02615C  AFC60018   SW A2, 24(S8)
9D026160  00E01021   ADDU V0, A3, ZERO
9D026164  A7C30014   SH V1, 20(S8)
9D026168  A7C2001C   SH V0, 28(S8)
742:                 	BYTE i, j;
743:                 	BYTE vOutput[4];
744:                 	WORD wOutputLen;
745:                 
746:                 	wOutputLen = 0;
9D02616C  A7C00002   SH ZERO, 2(S8)
747:                 	while(wDestLen >= 4u)
9D026170  0B4098F3   J 0x9D0263CC
9D026174  00000000   NOP
9D0263CC  97C2001C   LHU V0, 28(S8)
9D0263D0  2C420004   SLTIU V0, V0, 4
9D0263D4  1040FF68   BEQ V0, ZERO, 0x9D026178
9D0263D8  00000000   NOP
9D0263DC  0B4098FA   J 0x9D0263E8
9D0263E0  00000000   NOP
748:                 	{
749:                 		// Start out treating the output as all padding
750:                 		vOutput[0] = 0xFF;
9D026178  2402FFFF   ADDIU V0, ZERO, -1
9D02617C  A3C20004   SB V0, 4(S8)
751:                 		vOutput[1] = 0xFF;
9D026180  2402FFFF   ADDIU V0, ZERO, -1
9D026184  A3C20005   SB V0, 5(S8)
752:                 		vOutput[2] = 0xFF;
9D026188  2402FFFF   ADDIU V0, ZERO, -1
9D02618C  A3C20006   SB V0, 6(S8)
753:                 		vOutput[3] = 0xFF;
9D026190  2402FFFF   ADDIU V0, ZERO, -1
9D026194  A3C20007   SB V0, 7(S8)
754:                 
755:                 		// Get 3 input octets and split them into 4 output hextets (6-bits each) 
756:                 		if(wSourceLen == 0u)
9D026198  97C20014   LHU V0, 20(S8)
9D02619C  10400091   BEQ V0, ZERO, 0x9D0263E4
9D0261A0  00000000   NOP
757:                 			break;
9D0263E4  00000000   NOP
758:                 		i = *cSourceData++;
9D0261A4  8FC20010   LW V0, 16(S8)
9D0261A8  90420000   LBU V0, 0(V0)
9D0261AC  A3C20000   SB V0, 0(S8)
9D0261B0  8FC20010   LW V0, 16(S8)
9D0261B4  24420001   ADDIU V0, V0, 1
9D0261B8  AFC20010   SW V0, 16(S8)
759:                 		wSourceLen--;
9D0261BC  97C20014   LHU V0, 20(S8)
9D0261C0  2442FFFF   ADDIU V0, V0, -1
9D0261C4  A7C20014   SH V0, 20(S8)
760:                 		vOutput[0] = (i & 0xFC)>>2;
9D0261C8  93C20000   LBU V0, 0(S8)
9D0261CC  00021082   SRL V0, V0, 2
9D0261D0  304200FF   ANDI V0, V0, 255
9D0261D4  A3C20004   SB V0, 4(S8)
761:                 		vOutput[1] = (i & 0x03)<<4;
9D0261D8  93C20000   LBU V0, 0(S8)
9D0261DC  30420003   ANDI V0, V0, 3
9D0261E0  304200FF   ANDI V0, V0, 255
9D0261E4  00021100   SLL V0, V0, 4
9D0261E8  304200FF   ANDI V0, V0, 255
9D0261EC  A3C20005   SB V0, 5(S8)
762:                 		if(wSourceLen)
9D0261F0  97C20014   LHU V0, 20(S8)
9D0261F4  1040002E   BEQ V0, ZERO, 0x9D0262B0
9D0261F8  00000000   NOP
763:                 		{
764:                 			i = *cSourceData++;
9D0261FC  8FC20010   LW V0, 16(S8)
9D026200  90420000   LBU V0, 0(V0)
9D026204  A3C20000   SB V0, 0(S8)
9D026208  8FC20010   LW V0, 16(S8)
9D02620C  24420001   ADDIU V0, V0, 1
9D026210  AFC20010   SW V0, 16(S8)
765:                 			wSourceLen--;
9D026214  97C20014   LHU V0, 20(S8)
9D026218  2442FFFF   ADDIU V0, V0, -1
9D02621C  A7C20014   SH V0, 20(S8)
766:                 			vOutput[1] |= (i & 0xF0)>>4;
9D026220  93C30005   LBU V1, 5(S8)
9D026224  93C20000   LBU V0, 0(S8)
9D026228  00021102   SRL V0, V0, 4
9D02622C  304200FF   ANDI V0, V0, 255
9D026230  00621025   OR V0, V1, V0
9D026234  304200FF   ANDI V0, V0, 255
9D026238  A3C20005   SB V0, 5(S8)
767:                 			vOutput[2] = (i & 0x0F)<<2;
9D02623C  93C20000   LBU V0, 0(S8)
9D026240  3042000F   ANDI V0, V0, 15
9D026244  304200FF   ANDI V0, V0, 255
9D026248  00021080   SLL V0, V0, 2
9D02624C  304200FF   ANDI V0, V0, 255
9D026250  A3C20006   SB V0, 6(S8)
768:                 			if(wSourceLen)
9D026254  97C20014   LHU V0, 20(S8)
9D026258  10400015   BEQ V0, ZERO, 0x9D0262B0
9D02625C  00000000   NOP
769:                 			{
770:                 				i = *cSourceData++;
9D026260  8FC20010   LW V0, 16(S8)
9D026264  90420000   LBU V0, 0(V0)
9D026268  A3C20000   SB V0, 0(S8)
9D02626C  8FC20010   LW V0, 16(S8)
9D026270  24420001   ADDIU V0, V0, 1
9D026274  AFC20010   SW V0, 16(S8)
771:                 				wSourceLen--;
9D026278  97C20014   LHU V0, 20(S8)
9D02627C  2442FFFF   ADDIU V0, V0, -1
9D026280  A7C20014   SH V0, 20(S8)
772:                 				vOutput[2] |= (i & 0xC0)>>6;
9D026284  93C30006   LBU V1, 6(S8)
9D026288  93C20000   LBU V0, 0(S8)
9D02628C  00021182   SRL V0, V0, 6
9D026290  304200FF   ANDI V0, V0, 255
9D026294  00621025   OR V0, V1, V0
9D026298  304200FF   ANDI V0, V0, 255
9D02629C  A3C20006   SB V0, 6(S8)
773:                 				vOutput[3] = i & 0x3F;
9D0262A0  93C20000   LBU V0, 0(S8)
9D0262A4  3042003F   ANDI V0, V0, 63
9D0262A8  304200FF   ANDI V0, V0, 255
9D0262AC  A3C20007   SB V0, 7(S8)
774:                 			}
775:                 		}
776:                 	
777:                 		// Convert hextets into Base 64 alphabet and store result
778:                 		for(i = 0; i < 4u; i++)
9D0262B0  A3C00000   SB ZERO, 0(S8)
9D0262B4  0B4098E9   J 0x9D0263A4
9D0262B8  00000000   NOP
9D026398  93C20000   LBU V0, 0(S8)
9D02639C  24420001   ADDIU V0, V0, 1
9D0263A0  A3C20000   SB V0, 0(S8)
9D0263A4  93C20000   LBU V0, 0(S8)
9D0263A8  2C420004   SLTIU V0, V0, 4
9D0263AC  1440FFC3   BNE V0, ZERO, 0x9D0262BC
9D0263B0  00000000   NOP
779:                 		{
780:                 			j = vOutput[i];
9D0262BC  93C20000   LBU V0, 0(S8)
9D0262C0  03C21021   ADDU V0, S8, V0
9D0262C4  90420004   LBU V0, 4(V0)
9D0262C8  A3C20001   SB V0, 1(S8)
781:                 
782:                 			if(j <= 25u)
9D0262CC  93C20001   LBU V0, 1(S8)
9D0262D0  2C42001A   SLTIU V0, V0, 26
9D0262D4  10400006   BEQ V0, ZERO, 0x9D0262F0
9D0262D8  00000000   NOP
783:                 				j += 'A' - 0;
9D0262DC  93C20001   LBU V0, 1(S8)
9D0262E0  24420041   ADDIU V0, V0, 65
9D0262E4  A3C20001   SB V0, 1(S8)
9D0262E8  0B4098E0   J 0x9D026380
9D0262EC  00000000   NOP
784:                 			else if(j <= 51u)
9D0262F0  93C20001   LBU V0, 1(S8)
9D0262F4  2C420034   SLTIU V0, V0, 52
9D0262F8  10400006   BEQ V0, ZERO, 0x9D026314
9D0262FC  00000000   NOP
785:                 				j += 'a' - 26;
9D026300  93C20001   LBU V0, 1(S8)
9D026304  24420047   ADDIU V0, V0, 71
9D026308  A3C20001   SB V0, 1(S8)
9D02630C  0B4098E0   J 0x9D026380
9D026310  00000000   NOP
786:                 			else if(j <= 61u)
9D026314  93C20001   LBU V0, 1(S8)
9D026318  2C42003E   SLTIU V0, V0, 62
9D02631C  10400006   BEQ V0, ZERO, 0x9D026338
9D026320  00000000   NOP
787:                 				j += '0' - 52;
9D026324  93C20001   LBU V0, 1(S8)
9D026328  2442FFFC   ADDIU V0, V0, -4
9D02632C  A3C20001   SB V0, 1(S8)
9D026330  0B4098E0   J 0x9D026380
9D026334  00000000   NOP
788:                 			else if(j == 62u)
9D026338  93C30001   LBU V1, 1(S8)
9D02633C  2402003E   ADDIU V0, ZERO, 62
9D026340  14620005   BNE V1, V0, 0x9D026358
9D026344  00000000   NOP
789:                 				j = '+';
9D026348  2402002B   ADDIU V0, ZERO, 43
9D02634C  A3C20001   SB V0, 1(S8)
9D026350  0B4098E0   J 0x9D026380
9D026354  00000000   NOP
790:                 			else if(j == 63u)
9D026358  93C30001   LBU V1, 1(S8)
9D02635C  2402003F   ADDIU V0, ZERO, 63
9D026360  14620005   BNE V1, V0, 0x9D026378
9D026364  00000000   NOP
791:                 				j = '/';
9D026368  2402002F   ADDIU V0, ZERO, 47
9D02636C  A3C20001   SB V0, 1(S8)
9D026370  0B4098E0   J 0x9D026380
9D026374  00000000   NOP
792:                 			else				// Padding
793:                 				j = '=';
9D026378  2402003D   ADDIU V0, ZERO, 61
9D02637C  A3C20001   SB V0, 1(S8)
794:                 
795:                 			*cDestData++ = j;
9D026380  8FC20018   LW V0, 24(S8)
9D026384  93C30001   LBU V1, 1(S8)
9D026388  A0430000   SB V1, 0(V0)
9D02638C  8FC20018   LW V0, 24(S8)
9D026390  24420001   ADDIU V0, V0, 1
9D026394  AFC20018   SW V0, 24(S8)
796:                 		}
797:                 
798:                 		// Update counters
799:                 		wDestLen -= 4;
9D0263B4  97C2001C   LHU V0, 28(S8)
9D0263B8  2442FFFC   ADDIU V0, V0, -4
9D0263BC  A7C2001C   SH V0, 28(S8)
800:                 		wOutputLen += 4;
9D0263C0  97C20002   LHU V0, 2(S8)
9D0263C4  24420004   ADDIU V0, V0, 4
9D0263C8  A7C20002   SH V0, 2(S8)
801:                 	}
802:                 
803:                 	return wOutputLen;
9D0263E8  97C20002   LHU V0, 2(S8)
804:                 }
9D0263EC  03C0E821   ADDU SP, S8, ZERO
9D0263F0  8FBE000C   LW S8, 12(SP)
9D0263F4  27BD0010   ADDIU SP, SP, 16
9D0263F8  03E00008   JR RA
9D0263FC  00000000   NOP
805:                 #endif // #if defined(STACK_USE_BASE64_ENCODE) || defined(STACK_USE_SMTP) || defined(STACK_USE_DYNAMICDNS_CLIENT)
806:                 
807:                 
808:                 /*****************************************************************************
809:                   Function:
810:                 	void uitoa(WORD Value, BYTE* Buffer)
811:                 
812:                   Summary:
813:                 	Converts an unsigned integer to a decimal string.
814:                 	
815:                   Description:
816:                 	Converts a 16-bit unsigned integer to a null-terminated decimal string.
817:                 	
818:                   Precondition:
819:                 	None
820:                 
821:                   Parameters:
822:                 	Value	- The number to be converted
823:                 	Buffer	- Pointer in which to store the converted string
824:                 
825:                   Returns:
826:                   	None
827:                   ***************************************************************************/
828:                 void uitoa(WORD Value, BYTE* Buffer)
829:                 {
9D026400  27BDFFE8   ADDIU SP, SP, -24
9D026404  AFBE0014   SW S8, 20(SP)
9D026408  03A0F021   ADDU S8, SP, ZERO
9D02640C  00801021   ADDU V0, A0, ZERO
9D026410  AFC5001C   SW A1, 28(S8)
9D026414  A7C20018   SH V0, 24(S8)
830:                 	BYTE i;
831:                 	WORD Digit;
832:                 	WORD Divisor;
833:                 	BOOL Printed = FALSE;
9D026418  AFC00004   SW ZERO, 4(S8)
834:                 
835:                 	if(Value)
9D02641C  97C20018   LHU V0, 24(S8)
9D026420  10400036   BEQ V0, ZERO, 0x9D0264FC
9D026424  00000000   NOP
836:                 	{
837:                 		for(i = 0, Divisor = 10000; i < 5u; i++)
9D026428  A3C00000   SB ZERO, 0(S8)
9D02642C  24022710   ADDIU V0, ZERO, 10000
9D026430  A7C20002   SH V0, 2(S8)
9D026434  0B409939   J 0x9D0264E4
9D026438  00000000   NOP
9D0264D8  93C20000   LBU V0, 0(S8)
9D0264DC  24420001   ADDIU V0, V0, 1
9D0264E0  A3C20000   SB V0, 0(S8)
9D0264E4  93C20000   LBU V0, 0(S8)
9D0264E8  2C420005   SLTIU V0, V0, 5
9D0264EC  1440FFD3   BNE V0, ZERO, 0x9D02643C
9D0264F0  00000000   NOP
9D0264F4  0B409945   J 0x9D026514
9D0264F8  00000000   NOP
838:                 		{
839:                 			Digit = Value/Divisor;
9D02643C  97C30018   LHU V1, 24(S8)
9D026440  97C20002   LHU V0, 2(S8)
9D026444  0062001B   DIVU V1, V0
9D026448  004001F4   TEQ V0, ZERO
9D02644C  00001810   MFHI V1, 0
9D026450  00001012   MFLO V0, 0
9D026454  A7C20008   SH V0, 8(S8)
840:                 			if(Digit || Printed)
9D026458  97C20008   LHU V0, 8(S8)
9D02645C  14400004   BNE V0, ZERO, 0x9D026470
9D026460  00000000   NOP
9D026464  8FC20004   LW V0, 4(S8)
9D026468  10400013   BEQ V0, ZERO, 0x9D0264B8
9D02646C  00000000   NOP
841:                 			{
842:                 				*Buffer++ = '0' + Digit;
9D026470  97C20008   LHU V0, 8(S8)
9D026474  304200FF   ANDI V0, V0, 255
9D026478  24420030   ADDIU V0, V0, 48
9D02647C  304300FF   ANDI V1, V0, 255
9D026480  8FC2001C   LW V0, 28(S8)
9D026484  A0430000   SB V1, 0(V0)
9D026488  8FC2001C   LW V0, 28(S8)
9D02648C  24420001   ADDIU V0, V0, 1
9D026490  AFC2001C   SW V0, 28(S8)
843:                 				Value -= Digit*Divisor;
9D026494  97C30008   LHU V1, 8(S8)
9D026498  97C20002   LHU V0, 2(S8)
9D02649C  70621002   MUL V0, V1, V0
9D0264A0  3042FFFF   ANDI V0, V0, -1
9D0264A4  97C30018   LHU V1, 24(S8)
9D0264A8  00621023   SUBU V0, V1, V0
9D0264AC  A7C20018   SH V0, 24(S8)
844:                 				Printed = TRUE;
9D0264B0  24020001   ADDIU V0, ZERO, 1
9D0264B4  AFC20004   SW V0, 4(S8)
845:                 			}
846:                 			Divisor /= 10;
9D0264B8  97C30002   LHU V1, 2(S8)
9D0264BC  3C02CCCC   LUI V0, -13108
9D0264C0  3442CCCD   ORI V0, V0, -13107
9D0264C4  00620019   MULTU 0, V1, V0
9D0264C8  00001012   MFLO V0, 0
9D0264CC  00001810   MFHI V1, 0
9D0264D0  000310C2   SRL V0, V1, 3
9D0264D4  A7C20002   SH V0, 2(S8)
847:                 		}
848:                 	}
849:                 	else
850:                 	{
851:                 		*Buffer++ = '0';
9D0264FC  8FC2001C   LW V0, 28(S8)
9D026500  24030030   ADDIU V1, ZERO, 48
9D026504  A0430000   SB V1, 0(V0)
9D026508  8FC2001C   LW V0, 28(S8)
9D02650C  24420001   ADDIU V0, V0, 1
9D026510  AFC2001C   SW V0, 28(S8)
852:                 	}
853:                 
854:                 	*Buffer = '\0';
9D026514  8FC2001C   LW V0, 28(S8)
9D026518  A0400000   SB ZERO, 0(V0)
855:                 }			    
9D02651C  03C0E821   ADDU SP, S8, ZERO
9D026520  8FBE0014   LW S8, 20(SP)
9D026524  27BD0018   ADDIU SP, SP, 24
9D026528  03E00008   JR RA
9D02652C  00000000   NOP
856:                 
857:                 /*****************************************************************************
858:                   Function:
859:                 	void ultoa(DWORD Value, BYTE* Buffer)
860:                 
861:                   Summary:
862:                 	Converts an unsigned integer to a decimal string.
863:                 	
864:                   Description:
865:                 	Converts a 32-bit unsigned integer to a null-terminated decimal string.
866:                 	
867:                   Precondition:
868:                 	None
869:                 
870:                   Parameters:
871:                 	Value	- The number to be converted
872:                 	Buffer	- Pointer in which to store the converted string
873:                 
874:                   Returns:
875:                   	None
876:                   ***************************************************************************/
877:                 // HI-TECH PICC-18 PRO 9.63, C30 v3.25, and C32 v1.12 already have a ultoa() library function
878:                 // C18 already has a ultoa() function that more-or-less matches this one
879:                 // C32 < 1.12 and C30 < v3.25 need this function
880:                 #if (defined(__PIC32MX__) && (__C32_VERSION__ < 112)) || (defined (__C30__) && (__C30_VERSION__ < 325)) || defined(__C30_LEGACY_LIBC__) || defined(__C32_LEGACY_LIBC__)
881:                 void ultoa(DWORD Value, BYTE* Buffer)
882:                 {
883:                 	BYTE i;
884:                 	DWORD Digit;
885:                 	DWORD Divisor;
886:                 	BOOL Printed = FALSE;
887:                 
888:                 	if(Value)
889:                 	{
890:                 		for(i = 0, Divisor = 1000000000; i < 10; i++)
891:                 		{
892:                 			Digit = Value/Divisor;
893:                 			if(Digit || Printed)
894:                 			{
895:                 				*Buffer++ = '0' + Digit;
896:                 				Value -= Digit*Divisor;
897:                 				Printed = TRUE;
898:                 			}
899:                 			Divisor /= 10;
900:                 		}
901:                 	}
902:                 	else
903:                 	{
904:                 		*Buffer++ = '0';
905:                 	}
906:                 
907:                 	*Buffer = '\0';
908:                 }
909:                 #endif
910:                 
911:                 /*****************************************************************************
912:                   Function:
913:                 	BYTE hexatob(WORD_VAL AsciiChars)
914:                 
915:                   Summary:
916:                 	Converts a hex string to a single byte.
917:                 	
918:                   Description:
919:                 	Converts a two-character ASCII hex string to a single packed byte.
920:                 	
921:                   Precondition:
922:                 	None
923:                 
924:                   Parameters:
925:                 	AsciiChars - WORD_VAL where .v[0] is the ASCII value for the lower nibble
926:                 					and .v[1] is the ASCII value for the upper nibble.  Each
927:                 					must range from '0'-'9', 'A'-'F', or 'a'-'f'.
928:                 
929:                   Returns:
930:                   	Resulting packed byte 0x00 - 0xFF.
931:                   ***************************************************************************/
932:                 BYTE hexatob(WORD_VAL AsciiChars)
933:                 {
9D026530  27BDFFF8   ADDIU SP, SP, -8
9D026534  AFBE0004   SW S8, 4(SP)
9D026538  03A0F021   ADDU S8, SP, ZERO
9D02653C  A7C40008   SH A0, 8(S8)
934:                 	// Convert lowercase to uppercase
935:                 	if(AsciiChars.v[1] > 'F')
9D026540  93C20009   LBU V0, 9(S8)
9D026544  2C420047   SLTIU V0, V0, 71
9D026548  14400005   BNE V0, ZERO, 0x9D026560
9D02654C  00000000   NOP
936:                 		AsciiChars.v[1] -= 'a'-'A';
9D026550  93C20009   LBU V0, 9(S8)
9D026554  2442FFE0   ADDIU V0, V0, -32
9D026558  304200FF   ANDI V0, V0, 255
9D02655C  A3C20009   SB V0, 9(S8)
937:                 	if(AsciiChars.v[0] > 'F')
9D026560  93C20008   LBU V0, 8(S8)
9D026564  2C420047   SLTIU V0, V0, 71
9D026568  14400005   BNE V0, ZERO, 0x9D026580
9D02656C  00000000   NOP
938:                 		AsciiChars.v[0] -= 'a'-'A';
9D026570  93C20008   LBU V0, 8(S8)
9D026574  2442FFE0   ADDIU V0, V0, -32
9D026578  304200FF   ANDI V0, V0, 255
9D02657C  A3C20008   SB V0, 8(S8)
939:                 
940:                 	// Convert 0-9, A-F to 0x0-0xF
941:                 	if(AsciiChars.v[1] > '9')
9D026580  93C20009   LBU V0, 9(S8)
9D026584  2C42003A   SLTIU V0, V0, 58
9D026588  14400007   BNE V0, ZERO, 0x9D0265A8
9D02658C  00000000   NOP
942:                 		AsciiChars.v[1] -= 'A' - 10;
9D026590  93C20009   LBU V0, 9(S8)
9D026594  2442FFC9   ADDIU V0, V0, -55
9D026598  304200FF   ANDI V0, V0, 255
9D02659C  A3C20009   SB V0, 9(S8)
9D0265A0  0B40996E   J 0x9D0265B8
9D0265A4  00000000   NOP
943:                 	else
944:                 		AsciiChars.v[1] -= '0';
9D0265A8  93C20009   LBU V0, 9(S8)
9D0265AC  2442FFD0   ADDIU V0, V0, -48
9D0265B0  304200FF   ANDI V0, V0, 255
9D0265B4  A3C20009   SB V0, 9(S8)
945:                 
946:                 	if(AsciiChars.v[0] > '9')
9D0265B8  93C20008   LBU V0, 8(S8)
9D0265BC  2C42003A   SLTIU V0, V0, 58
9D0265C0  14400007   BNE V0, ZERO, 0x9D0265E0
9D0265C4  00000000   NOP
947:                 		AsciiChars.v[0] -= 'A' - 10;
9D0265C8  93C20008   LBU V0, 8(S8)
9D0265CC  2442FFC9   ADDIU V0, V0, -55
9D0265D0  304200FF   ANDI V0, V0, 255
9D0265D4  A3C20008   SB V0, 8(S8)
9D0265D8  0B40997C   J 0x9D0265F0
9D0265DC  00000000   NOP
948:                 	else
949:                 		AsciiChars.v[0] -= '0';
9D0265E0  93C20008   LBU V0, 8(S8)
9D0265E4  2442FFD0   ADDIU V0, V0, -48
9D0265E8  304200FF   ANDI V0, V0, 255
9D0265EC  A3C20008   SB V0, 8(S8)
950:                 
951:                 	// Concatenate
952:                 	return (AsciiChars.v[1]<<4) |  AsciiChars.v[0];
9D0265F0  93C20009   LBU V0, 9(S8)
9D0265F4  00021100   SLL V0, V0, 4
9D0265F8  7C021C20   SEB V1, V0
9D0265FC  93C20008   LBU V0, 8(S8)
9D026600  7C021420   SEB V0, V0
9D026604  00621025   OR V0, V1, V0
9D026608  7C021420   SEB V0, V0
9D02660C  304200FF   ANDI V0, V0, 255
953:                 }
9D026610  03C0E821   ADDU SP, S8, ZERO
9D026614  8FBE0004   LW S8, 4(SP)
9D026618  27BD0008   ADDIU SP, SP, 8
9D02661C  03E00008   JR RA
9D026620  00000000   NOP
954:                 
955:                 /*****************************************************************************
956:                   Function:
957:                 	BYTE btohexa_high(BYTE b)
958:                 
959:                   Summary:
960:                 	Converts the upper nibble of a binary value to a hexadecimal ASCII byte.
961:                 
962:                   Description:
963:                 	Converts the upper nibble of a binary value to a hexadecimal ASCII byte.
964:                 	For example, btohexa_high(0xAE) will return 'A'.
965:                 
966:                   Precondition:
967:                 	None
968:                 
969:                   Parameters:
970:                 	b - the byte to convert
971:                 
972:                   Returns:
973:                   	The upper hexadecimal ASCII byte '0'-'9' or 'A'-'F'.
974:                   ***************************************************************************/
975:                 BYTE btohexa_high(BYTE b)
976:                 {
9D026624  27BDFFF8   ADDIU SP, SP, -8
9D026628  AFBE0004   SW S8, 4(SP)
9D02662C  03A0F021   ADDU S8, SP, ZERO
9D026630  00801021   ADDU V0, A0, ZERO
9D026634  A3C20008   SB V0, 8(S8)
977:                 	b >>= 4;
9D026638  93C20008   LBU V0, 8(S8)
9D02663C  00021102   SRL V0, V0, 4
9D026640  A3C20008   SB V0, 8(S8)
978:                 	return (b>0x9u) ? b+'A'-10:b+'0';
9D026644  93C20008   LBU V0, 8(S8)
9D026648  2C42000A   SLTIU V0, V0, 10
9D02664C  14400006   BNE V0, ZERO, 0x9D026668
9D026650  00000000   NOP
9D026654  93C20008   LBU V0, 8(S8)
9D026658  24420037   ADDIU V0, V0, 55
9D02665C  304200FF   ANDI V0, V0, 255
9D026660  0B40999D   J 0x9D026674
9D026664  00000000   NOP
9D026668  93C20008   LBU V0, 8(S8)
9D02666C  24420030   ADDIU V0, V0, 48
9D026670  304200FF   ANDI V0, V0, 255
979:                 }
9D026674  03C0E821   ADDU SP, S8, ZERO
9D026678  8FBE0004   LW S8, 4(SP)
9D02667C  27BD0008   ADDIU SP, SP, 8
9D026680  03E00008   JR RA
9D026684  00000000   NOP
980:                 
981:                 /*****************************************************************************
982:                   Function:
983:                 	BYTE btohexa_high(BYTE b)
984:                 
985:                   Summary:
986:                 	Converts the lower nibble of a binary value to a hexadecimal ASCII byte.
987:                 
988:                   Description:
989:                 	Converts the lower nibble of a binary value to a hexadecimal ASCII byte.
990:                 	For example, btohexa_high(0xAE) will return 'E'.
991:                 
992:                   Precondition:
993:                 	None
994:                 
995:                   Parameters:
996:                 	b - the byte to convert
997:                 
998:                   Returns:
999:                   	The lower hexadecimal ASCII byte '0'-'9' or 'A'-'F'.
1000:                  ***************************************************************************/
1001:                BYTE btohexa_low(BYTE b)
1002:                {
9D026688  27BDFFF8   ADDIU SP, SP, -8
9D02668C  AFBE0004   SW S8, 4(SP)
9D026690  03A0F021   ADDU S8, SP, ZERO
9D026694  00801021   ADDU V0, A0, ZERO
9D026698  A3C20008   SB V0, 8(S8)
1003:                	b &= 0x0F;
9D02669C  93C20008   LBU V0, 8(S8)
9D0266A0  3042000F   ANDI V0, V0, 15
9D0266A4  A3C20008   SB V0, 8(S8)
1004:                	return (b>9u) ? b+'A'-10:b+'0';
9D0266A8  93C20008   LBU V0, 8(S8)
9D0266AC  2C42000A   SLTIU V0, V0, 10
9D0266B0  14400006   BNE V0, ZERO, 0x9D0266CC
9D0266B4  00000000   NOP
9D0266B8  93C20008   LBU V0, 8(S8)
9D0266BC  24420037   ADDIU V0, V0, 55
9D0266C0  304200FF   ANDI V0, V0, 255
9D0266C4  0B4099B6   J 0x9D0266D8
9D0266C8  00000000   NOP
9D0266CC  93C20008   LBU V0, 8(S8)
9D0266D0  24420030   ADDIU V0, V0, 48
9D0266D4  304200FF   ANDI V0, V0, 255
1005:                }
9D0266D8  03C0E821   ADDU SP, S8, ZERO
9D0266DC  8FBE0004   LW S8, 4(SP)
9D0266E0  27BD0008   ADDIU SP, SP, 8
9D0266E4  03E00008   JR RA
9D0266E8  00000000   NOP
1006:                
1007:                /*****************************************************************************
1008:                  Function:
1009:                	signed char stricmppgm2ram(BYTE* a, ROM BYTE* b)
1010:                
1011:                  Summary:
1012:                	Case-insensitive comparison of a string in RAM to a string in ROM.
1013:                
1014:                  Description:
1015:                	Performs a case-insensitive comparison of a string in RAM to a string
1016:                	in ROM.  This function performs identically to strcmppgm2ram, except that
1017:                	the comparison is not case-sensitive.
1018:                
1019:                  Precondition:
1020:                	None
1021:                
1022:                  Parameters:
1023:                	a - Pinter to tring in RAM
1024:                	b - Pointer to string in ROM
1025:                
1026:                  Return Values:
1027:                  	\-1 - a < b
1028:                  	0	- a = b
1029:                  	1	- a > b
1030:                  ***************************************************************************/
1031:                signed char stricmppgm2ram(BYTE* a, ROM BYTE* b)
1032:                {
9D0266EC  27BDFFF0   ADDIU SP, SP, -16
9D0266F0  AFBE000C   SW S8, 12(SP)
9D0266F4  03A0F021   ADDU S8, SP, ZERO
9D0266F8  AFC40010   SW A0, 16(S8)
9D0266FC  AFC50014   SW A1, 20(S8)
1033:                	BYTE cA, cB;
1034:                	
1035:                	// Load first two characters
1036:                	cA = *a;
9D026700  8FC20010   LW V0, 16(S8)
9D026704  90420000   LBU V0, 0(V0)
9D026708  A3C20000   SB V0, 0(S8)
1037:                	cB = *b;
9D02670C  8FC20014   LW V0, 20(S8)
9D026710  90420000   LBU V0, 0(V0)
9D026714  A3C20001   SB V0, 1(S8)
1038:                	
1039:                	// Loop until one string terminates
1040:                	while(cA != '\0' && cB != '\0')
9D026718  0B4099FA   J 0x9D0267E8
9D02671C  00000000   NOP
9D0267E8  93C20000   LBU V0, 0(S8)
9D0267EC  10400004   BEQ V0, ZERO, 0x9D026800
9D0267F0  00000000   NOP
9D0267F4  93C20001   LBU V0, 1(S8)
9D0267F8  1440FFC9   BNE V0, ZERO, 0x9D026720
9D0267FC  00000000   NOP
1041:                	{
1042:                		// Shift case if necessary
1043:                		if(cA >= 'a' && cA <= 'z')
9D026720  93C20000   LBU V0, 0(S8)
9D026724  2C420061   SLTIU V0, V0, 97
9D026728  14400008   BNE V0, ZERO, 0x9D02674C
9D02672C  00000000   NOP
9D026730  93C20000   LBU V0, 0(S8)
9D026734  2C42007B   SLTIU V0, V0, 123
9D026738  10400004   BEQ V0, ZERO, 0x9D02674C
9D02673C  00000000   NOP
1044:                			cA -= 'a' - 'A';
9D026740  93C20000   LBU V0, 0(S8)
9D026744  2442FFE0   ADDIU V0, V0, -32
9D026748  A3C20000   SB V0, 0(S8)
1045:                		if(cB >= 'a' && cB <= 'z')
9D02674C  93C20001   LBU V0, 1(S8)
9D026750  2C420061   SLTIU V0, V0, 97
9D026754  14400008   BNE V0, ZERO, 0x9D026778
9D026758  00000000   NOP
9D02675C  93C20001   LBU V0, 1(S8)
9D026760  2C42007B   SLTIU V0, V0, 123
9D026764  10400004   BEQ V0, ZERO, 0x9D026778
9D026768  00000000   NOP
1046:                			cB -= 'a' - 'A';
9D02676C  93C20001   LBU V0, 1(S8)
9D026770  2442FFE0   ADDIU V0, V0, -32
9D026774  A3C20001   SB V0, 1(S8)
1047:                			
1048:                		// Compare
1049:                		if(cA > cB)
9D026778  93C30000   LBU V1, 0(S8)
9D02677C  93C20001   LBU V0, 1(S8)
9D026780  0043102B   SLTU V0, V0, V1
9D026784  10400004   BEQ V0, ZERO, 0x9D026798
9D026788  00000000   NOP
1050:                			return 1;
9D02678C  24020001   ADDIU V0, ZERO, 1
9D026790  0B409A11   J 0x9D026844
9D026794  00000000   NOP
1051:                		if(cA < cB)
9D026798  93C30000   LBU V1, 0(S8)
9D02679C  93C20001   LBU V0, 1(S8)
9D0267A0  0062102B   SLTU V0, V1, V0
9D0267A4  10400004   BEQ V0, ZERO, 0x9D0267B8
9D0267A8  00000000   NOP
1052:                			return -1;
9D0267AC  2402FFFF   ADDIU V0, ZERO, -1
9D0267B0  0B409A11   J 0x9D026844
9D0267B4  00000000   NOP
1053:                		
1054:                		// Characters matched, so continue
1055:                		a++;
9D0267B8  8FC20010   LW V0, 16(S8)
9D0267BC  24420001   ADDIU V0, V0, 1
9D0267C0  AFC20010   SW V0, 16(S8)
1056:                		b++;
9D0267C4  8FC20014   LW V0, 20(S8)
9D0267C8  24420001   ADDIU V0, V0, 1
9D0267CC  AFC20014   SW V0, 20(S8)
1057:                		cA = *a;
9D0267D0  8FC20010   LW V0, 16(S8)
9D0267D4  90420000   LBU V0, 0(V0)
9D0267D8  A3C20000   SB V0, 0(S8)
1058:                		cB = *b;
9D0267DC  8FC20014   LW V0, 20(S8)
9D0267E0  90420000   LBU V0, 0(V0)
9D0267E4  A3C20001   SB V0, 1(S8)
1059:                	}
1060:                	
1061:                	// See if one string terminated first
1062:                	if(cA > cB)
9D026800  93C30000   LBU V1, 0(S8)
9D026804  93C20001   LBU V0, 1(S8)
9D026808  0043102B   SLTU V0, V0, V1
9D02680C  10400004   BEQ V0, ZERO, 0x9D026820
9D026810  00000000   NOP
1063:                		return 1;
9D026814  24020001   ADDIU V0, ZERO, 1
9D026818  0B409A11   J 0x9D026844
9D02681C  00000000   NOP
1064:                	if(cA < cB)
9D026820  93C30000   LBU V1, 0(S8)
9D026824  93C20001   LBU V0, 1(S8)
9D026828  0062102B   SLTU V0, V1, V0
9D02682C  10400004   BEQ V0, ZERO, 0x9D026840
9D026830  00000000   NOP
1065:                		return -1;
9D026834  2402FFFF   ADDIU V0, ZERO, -1
9D026838  0B409A11   J 0x9D026844
9D02683C  00000000   NOP
1066:                		
1067:                	// Strings match
1068:                	return 0;
9D026840  00001021   ADDU V0, ZERO, ZERO
1069:                }
9D026844  03C0E821   ADDU SP, S8, ZERO
9D026848  8FBE000C   LW S8, 12(SP)
9D02684C  27BD0010   ADDIU SP, SP, 16
9D026850  03E00008   JR RA
9D026854  00000000   NOP
1070:                
1071:                /*****************************************************************************
1072:                  Function:
1073:                	WORD swaps(WORD v)
1074:                
1075:                  Description:
1076:                	Swaps the endian-ness of a WORD.
1077:                
1078:                  Precondition:
1079:                	None
1080:                
1081:                  Parameters:
1082:                	v - the WORD to swap
1083:                
1084:                  Returns:
1085:                	The swapped version of v.
1086:                  ***************************************************************************/
1087:                WORD swaps(WORD v)
1088:                {
9D026858  27BDFFF0   ADDIU SP, SP, -16
9D02685C  AFBE000C   SW S8, 12(SP)
9D026860  03A0F021   ADDU S8, SP, ZERO
9D026864  00801021   ADDU V0, A0, ZERO
9D026868  A7C20010   SH V0, 16(S8)
1089:                	WORD_VAL t;
1090:                	BYTE b;
1091:                
1092:                	t.Val   = v;
9D02686C  97C20010   LHU V0, 16(S8)
9D026870  A7C20004   SH V0, 4(S8)
1093:                	b       = t.v[1];
9D026874  93C20005   LBU V0, 5(S8)
9D026878  A3C20000   SB V0, 0(S8)
1094:                	t.v[1]  = t.v[0];
9D02687C  93C20004   LBU V0, 4(S8)
9D026880  A3C20005   SB V0, 5(S8)
1095:                	t.v[0]  = b;
9D026884  93C20000   LBU V0, 0(S8)
9D026888  A3C20004   SB V0, 4(S8)
1096:                
1097:                	return t.Val;
9D02688C  97C20004   LHU V0, 4(S8)
1098:                }
9D026890  03C0E821   ADDU SP, S8, ZERO
9D026894  8FBE000C   LW S8, 12(SP)
9D026898  27BD0010   ADDIU SP, SP, 16
9D02689C  03E00008   JR RA
9D0268A0  00000000   NOP
1099:                
1100:                /*****************************************************************************
1101:                  Function:
1102:                	DWORD swapl(DWORD v)
1103:                
1104:                  Description:
1105:                	Swaps the endian-ness of a DWORD.
1106:                
1107:                  Precondition:
1108:                	None
1109:                
1110:                  Parameters:
1111:                	v - the DWORD to swap
1112:                
1113:                  Returns:
1114:                	The swapped version of v.
1115:                  ***************************************************************************/
1116:                DWORD swapl(DWORD v)
1117:                {
9D0268A4  27BDFFF8   ADDIU SP, SP, -8
9D0268A8  AFBE0004   SW S8, 4(SP)
9D0268AC  03A0F021   ADDU S8, SP, ZERO
9D0268B0  AFC40008   SW A0, 8(S8)
1118:                	// Swap bytes 0 and 3
1119:                	((DWORD_VAL*)&v)->v[0] ^= ((DWORD_VAL*)&v)->v[3];
9D0268B4  27C20008   ADDIU V0, S8, 8
9D0268B8  27C30008   ADDIU V1, S8, 8
9D0268BC  90640000   LBU A0, 0(V1)
9D0268C0  27C30008   ADDIU V1, S8, 8
9D0268C4  90630003   LBU V1, 3(V1)
9D0268C8  00831826   XOR V1, A0, V1
9D0268CC  306300FF   ANDI V1, V1, 255
9D0268D0  A0430000   SB V1, 0(V0)
1120:                	((DWORD_VAL*)&v)->v[3] ^= ((DWORD_VAL*)&v)->v[0];
9D0268D4  27C20008   ADDIU V0, S8, 8
9D0268D8  27C30008   ADDIU V1, S8, 8
9D0268DC  90640003   LBU A0, 3(V1)
9D0268E0  27C30008   ADDIU V1, S8, 8
9D0268E4  90630000   LBU V1, 0(V1)
9D0268E8  00831826   XOR V1, A0, V1
9D0268EC  306300FF   ANDI V1, V1, 255
9D0268F0  A0430003   SB V1, 3(V0)
1121:                	((DWORD_VAL*)&v)->v[0] ^= ((DWORD_VAL*)&v)->v[3];
9D0268F4  27C20008   ADDIU V0, S8, 8
9D0268F8  27C30008   ADDIU V1, S8, 8
9D0268FC  90640000   LBU A0, 0(V1)
9D026900  27C30008   ADDIU V1, S8, 8
9D026904  90630003   LBU V1, 3(V1)
9D026908  00831826   XOR V1, A0, V1
9D02690C  306300FF   ANDI V1, V1, 255
9D026910  A0430000   SB V1, 0(V0)
1122:                
1123:                	// Swap bytes 1 and 2
1124:                	((DWORD_VAL*)&v)->v[1] ^= ((DWORD_VAL*)&v)->v[2];
9D026914  27C20008   ADDIU V0, S8, 8
9D026918  27C30008   ADDIU V1, S8, 8
9D02691C  90640001   LBU A0, 1(V1)
9D026920  27C30008   ADDIU V1, S8, 8
9D026924  90630002   LBU V1, 2(V1)
9D026928  00831826   XOR V1, A0, V1
9D02692C  306300FF   ANDI V1, V1, 255
9D026930  A0430001   SB V1, 1(V0)
1125:                	((DWORD_VAL*)&v)->v[2] ^= ((DWORD_VAL*)&v)->v[1];
9D026934  27C20008   ADDIU V0, S8, 8
9D026938  27C30008   ADDIU V1, S8, 8
9D02693C  90640002   LBU A0, 2(V1)
9D026940  27C30008   ADDIU V1, S8, 8
9D026944  90630001   LBU V1, 1(V1)
9D026948  00831826   XOR V1, A0, V1
9D02694C  306300FF   ANDI V1, V1, 255
9D026950  A0430002   SB V1, 2(V0)
1126:                	((DWORD_VAL*)&v)->v[1] ^= ((DWORD_VAL*)&v)->v[2];
9D026954  27C20008   ADDIU V0, S8, 8
9D026958  27C30008   ADDIU V1, S8, 8
9D02695C  90640001   LBU A0, 1(V1)
9D026960  27C30008   ADDIU V1, S8, 8
9D026964  90630002   LBU V1, 2(V1)
9D026968  00831826   XOR V1, A0, V1
9D02696C  306300FF   ANDI V1, V1, 255
9D026970  A0430001   SB V1, 1(V0)
1127:                
1128:                	return v;
9D026974  8FC20008   LW V0, 8(S8)
1129:                }
9D026978  03C0E821   ADDU SP, S8, ZERO
9D02697C  8FBE0004   LW S8, 4(SP)
9D026980  27BD0008   ADDIU SP, SP, 8
9D026984  03E00008   JR RA
9D026988  00000000   NOP
1130:                
1131:                
1132:                /*****************************************************************************
1133:                  Function:
1134:                	WORD CalcIPChecksum(BYTE* buffer, WORD count)
1135:                
1136:                  Summary:
1137:                	Calculates an IP checksum value.
1138:                
1139:                  Description:
1140:                	This function calculates an IP checksum over an array of input data.  The
1141:                	checksum is the 16-bit one's complement of one's complement sum of all 
1142:                	words in the data (with zero-padding if an odd number of bytes are 
1143:                	summed).  This checksum is defined in RFC 793.
1144:                
1145:                  Precondition:
1146:                	buffer is WORD aligned (even memory address) on 16- and 32-bit PICs.
1147:                
1148:                  Parameters:
1149:                	buffer - pointer to the data to be checksummed
1150:                	count  - number of bytes to be checksummed
1151:                
1152:                  Returns:
1153:                	The calculated checksum.
1154:                	
1155:                  Internal:
1156:                	This function could be improved to do 32-bit sums on PIC32 platforms.
1157:                  ***************************************************************************/
1158:                WORD CalcIPChecksum(BYTE* buffer, WORD count)
1159:                {
9D02698C  27BDFFE8   ADDIU SP, SP, -24
9D026990  AFBE0014   SW S8, 20(SP)
9D026994  03A0F021   ADDU S8, SP, ZERO
9D026998  AFC40018   SW A0, 24(S8)
9D02699C  00A01021   ADDU V0, A1, ZERO
9D0269A0  A7C2001C   SH V0, 28(S8)
1160:                	WORD i;
1161:                	WORD *val;
1162:                	union
1163:                	{
1164:                		WORD w[2];
1165:                		DWORD dw;
1166:                	} sum;
1167:                
1168:                	i = count >> 1;
9D0269A4  97C2001C   LHU V0, 28(S8)
9D0269A8  00021042   SRL V0, V0, 1
9D0269AC  A7C20000   SH V0, 0(S8)
1169:                	val = (WORD*)buffer;
9D0269B0  8FC20018   LW V0, 24(S8)
9D0269B4  AFC20004   SW V0, 4(S8)
1170:                
1171:                	// Calculate the sum of all words
1172:                	sum.dw = 0x00000000ul;
9D0269B8  AFC00008   SW ZERO, 8(S8)
1173:                	while(i--)
9D0269BC  0B409A79   J 0x9D0269E4
9D0269C0  00000000   NOP
9D0269E4  97C20000   LHU V0, 0(S8)
9D0269E8  0002102B   SLTU V0, ZERO, V0
9D0269EC  304200FF   ANDI V0, V0, 255
9D0269F0  97C30000   LHU V1, 0(S8)
9D0269F4  2463FFFF   ADDIU V1, V1, -1
9D0269F8  A7C30000   SH V1, 0(S8)
9D0269FC  1440FFF1   BNE V0, ZERO, 0x9D0269C4
9D026A00  00000000   NOP
1174:                		sum.dw += (DWORD)*val++;
9D0269C4  8FC30008   LW V1, 8(S8)
9D0269C8  8FC20004   LW V0, 4(S8)
9D0269CC  94420000   LHU V0, 0(V0)
9D0269D0  00621021   ADDU V0, V1, V0
9D0269D4  AFC20008   SW V0, 8(S8)
9D0269D8  8FC20004   LW V0, 4(S8)
9D0269DC  24420002   ADDIU V0, V0, 2
9D0269E0  AFC20004   SW V0, 4(S8)
1175:                
1176:                	// Add in the sum of the remaining byte, if present
1177:                	if(count & 0x1)
9D026A04  97C2001C   LHU V0, 28(S8)
9D026A08  30420001   ANDI V0, V0, 1
9D026A0C  304200FF   ANDI V0, V0, 255
9D026A10  10400006   BEQ V0, ZERO, 0x9D026A2C
9D026A14  00000000   NOP
1178:                		sum.dw += (DWORD)*(BYTE*)val;
9D026A18  8FC30008   LW V1, 8(S8)
9D026A1C  8FC20004   LW V0, 4(S8)
9D026A20  90420000   LBU V0, 0(V0)
9D026A24  00621021   ADDU V0, V1, V0
9D026A28  AFC20008   SW V0, 8(S8)
1179:                
1180:                	// Do an end-around carry (one's complement arrithmatic)
1181:                	sum.dw = (DWORD)sum.w[0] + (DWORD)sum.w[1];
9D026A2C  97C20008   LHU V0, 8(S8)
9D026A30  00401821   ADDU V1, V0, ZERO
9D026A34  97C2000A   LHU V0, 10(S8)
9D026A38  00621021   ADDU V0, V1, V0
9D026A3C  AFC20008   SW V0, 8(S8)
1182:                
1183:                	// Do another end-around carry in case if the prior add 
1184:                	// caused a carry out
1185:                	sum.w[0] += sum.w[1];
9D026A40  97C30008   LHU V1, 8(S8)
9D026A44  97C2000A   LHU V0, 10(S8)
9D026A48  00621021   ADDU V0, V1, V0
9D026A4C  3042FFFF   ANDI V0, V0, -1
9D026A50  A7C20008   SH V0, 8(S8)
1186:                
1187:                	// Return the resulting checksum
1188:                	return ~sum.w[0];
9D026A54  97C20008   LHU V0, 8(S8)
9D026A58  00021027   NOR V0, ZERO, V0
9D026A5C  3042FFFF   ANDI V0, V0, -1
1189:                }
9D026A60  03C0E821   ADDU SP, S8, ZERO
9D026A64  8FBE0014   LW S8, 20(SP)
9D026A68  27BD0018   ADDIU SP, SP, 24
9D026A6C  03E00008   JR RA
9D026A70  00000000   NOP
1190:                
1191:                
1192:                /*****************************************************************************
1193:                  Function:
1194:                	char* strupr(char* s)
1195:                
1196:                  Summary:
1197:                	Converts a string to uppercase.
1198:                
1199:                  Description:
1200:                	This function converts strings to uppercase on platforms that do not
1201:                	already have this function defined.  All lower-case characters are
1202:                	converted, an characters not included in 'a'-'z' are left as-is.
1203:                
1204:                  Precondition:
1205:                	None
1206:                
1207:                  Parameters:
1208:                	s - the null-terminated string to be converted.
1209:                
1210:                  Returns:
1211:                	Pointer to the initial string.
1212:                  ***************************************************************************/
1213:                #if !defined(__18CXX) || defined(HI_TECH_C)
1214:                char* strupr(char* s)
1215:                {
9D026A74  27BDFFF0   ADDIU SP, SP, -16
9D026A78  AFBE000C   SW S8, 12(SP)
9D026A7C  03A0F021   ADDU S8, SP, ZERO
9D026A80  AFC40010   SW A0, 16(S8)
1216:                	char c;
1217:                	char *t;
1218:                
1219:                	t = s;
9D026A84  8FC20010   LW V0, 16(S8)
9D026A88  AFC20000   SW V0, 0(S8)
1220:                	while( (c = *t) )
9D026A8C  0B409AB8   J 0x9D026AE0
9D026A90  00000000   NOP
9D026AE0  8FC20000   LW V0, 0(S8)
9D026AE4  90420000   LBU V0, 0(V0)
9D026AE8  A3C20004   SB V0, 4(S8)
9D026AEC  83C20004   LB V0, 4(S8)
9D026AF0  1440FFE8   BNE V0, ZERO, 0x9D026A94
9D026AF4  00000000   NOP
1221:                	{
1222:                		if(c >= 'a' && c <= 'z')
9D026A94  83C20004   LB V0, 4(S8)
9D026A98  28420061   SLTI V0, V0, 97
9D026A9C  1440000D   BNE V0, ZERO, 0x9D026AD4
9D026AA0  00000000   NOP
9D026AA4  83C20004   LB V0, 4(S8)
9D026AA8  2842007B   SLTI V0, V0, 123
9D026AAC  10400009   BEQ V0, ZERO, 0x9D026AD4
9D026AB0  00000000   NOP
1223:                		{
1224:                			*t -= ('a' - 'A');
9D026AB4  8FC20000   LW V0, 0(S8)
9D026AB8  80420000   LB V0, 0(V0)
9D026ABC  304200FF   ANDI V0, V0, 255
9D026AC0  2442FFE0   ADDIU V0, V0, -32
9D026AC4  304200FF   ANDI V0, V0, 255
9D026AC8  7C021C20   SEB V1, V0
9D026ACC  8FC20000   LW V0, 0(S8)
9D026AD0  A0430000   SB V1, 0(V0)
1225:                		}
1226:                		t++;
9D026AD4  8FC20000   LW V0, 0(S8)
9D026AD8  24420001   ADDIU V0, V0, 1
9D026ADC  AFC20000   SW V0, 0(S8)
1227:                	}
1228:                	return s;
9D026AF8  8FC20010   LW V0, 16(S8)
1229:                }
9D026AFC  03C0E821   ADDU SP, S8, ZERO
9D026B00  8FBE000C   LW S8, 12(SP)
9D026B04  27BD0010   ADDIU SP, SP, 16
9D026B08  03E00008   JR RA
9D026B0C  00000000   NOP
1230:                #endif
1231:                
1232:                #if defined(__18CXX)
1233:                // Make this variable global for the following function.
1234:                // Hi-Tech PICC18 cannot access local function variables from inline asm.
1235:                DWORD_VAL toRotate; 
1236:                #endif
1237:                
1238:                /*****************************************************************************
1239:                  Function:
1240:                	DWORD leftRotateDWORD(DWORD val, BYTE bits)
1241:                
1242:                  Summary:
1243:                	Left-rotates a DWORD.
1244:                
1245:                  Description:
1246:                	This function rotates the bits in a 32-bit DWORD left by a specific 
1247:                	number of bits.
1248:                
1249:                  Precondition:
1250:                	None
1251:                
1252:                  Parameters:
1253:                	val		- the DWORD to be rotated
1254:                	bits	- the number of bits by which to shift
1255:                
1256:                  Returns:
1257:                	Rotated DWORD value.
1258:                	
1259:                  Remarks:
1260:                	This function is only implemented on 8-bit platforms for now.  The 
1261:                	8-bit compilers generate excessive code for this function, while C30
1262:                	and C32 already generate compact code.  Those compilers are served
1263:                	by a macro defined in Helpers.h.
1264:                  ***************************************************************************/
1265:                #if defined(__18CXX)
1266:                DWORD leftRotateDWORD(DWORD val, BYTE bits)
1267:                {
1268:                	BYTE i, t;
1269:                	//DWORD_VAL toRotate;
1270:                	toRotate.Val = val;
1271:                	
1272:                	for(i = bits; i >= 8u; i -= 8)
1273:                	{
1274:                		t = toRotate.v[3];
1275:                		toRotate.v[3] = toRotate.v[2];
1276:                		toRotate.v[2] = toRotate.v[1];
1277:                		toRotate.v[1] = toRotate.v[0];
1278:                		toRotate.v[0] = t;
1279:                	}
1280:                	
1281:                	
1282:                	#if defined(HI_TECH_C)
1283:                	for(; i != 0; i--)
1284:                	{
1285:                		asm("movlb (_toRotate)>>8");
1286:                		//asm("bcf _STATUS,0,C");
1287:                		asm("bcf 0xFD8,0,C");		// HI-TECH PICC-18 PRO 9.63PL1 doesn't define _STATUS
1288:                		asm("btfsc (_toRotate)&0ffh+3,7,B");
1289:                		//asm("bsf _STATUS,0,C");
1290:                		asm("bsf 0xFD8,0,C");		// HI-TECH PICC-18 PRO 9.63PL1 doesn't define _STATUS
1291:                		asm("rlcf (_toRotate)&0ffh+0,F,B");
1292:                		asm("rlcf (_toRotate)&0ffh+1,F,B");
1293:                		asm("rlcf (_toRotate)&0ffh+2,F,B");
1294:                		asm("rlcf (_toRotate)&0ffh+3,F,B");
1295:                	}
1296:                	#else
1297:                	for(; i != 0u; i--)
1298:                	{
1299:                		_asm
1300:                		movlb toRotate
1301:                		bcf STATUS,0,0
1302:                		btfsc toRotate+3,7,1
1303:                		bsf STATUS,0,0
1304:                		rlcf toRotate+0,1,1
1305:                		rlcf toRotate+1,1,1
1306:                		rlcf toRotate+2,1,1
1307:                		rlcf toRotate+3,1,1
1308:                		_endasm
1309:                	}
1310:                	#endif
1311:                	
1312:                	return toRotate.Val;
1313:                }
1314:                #endif
1315:                
1316:                /*****************************************************************************
1317:                  Function:
1318:                	void FormatNetBIOSName(BYTE Name[])
1319:                
1320:                  Summary:
1321:                	Formats a string to a valid NetBIOS name.
1322:                
1323:                  Description:
1324:                	This function formats a string to a valid NetBIOS name.  Names will be
1325:                	exactly 16 characters, as defined by the NetBIOS spec.  The 16th 
1326:                	character will be a 0x00 byte, while the other 15 will be the 
1327:                	provided string, padded with spaces as necessary.
1328:                
1329:                  Precondition:
1330:                	None
1331:                
1332:                  Parameters:
1333:                	Name - the string to format as a NetBIOS name.  This parameter must have
1334:                	  at least 16 bytes allocated.
1335:                
1336:                  Returns:
1337:                	None
1338:                  ***************************************************************************/
1339:                void FormatNetBIOSName(BYTE Name[])
1340:                {
9D026B10  27BDFFE0   ADDIU SP, SP, -32
9D026B14  AFBF001C   SW RA, 28(SP)
9D026B18  AFBE0018   SW S8, 24(SP)
9D026B1C  03A0F021   ADDU S8, SP, ZERO
9D026B20  AFC40020   SW A0, 32(S8)
1341:                	BYTE i;
1342:                
1343:                	Name[15] = '\0';
9D026B24  8FC20020   LW V0, 32(S8)
9D026B28  2442000F   ADDIU V0, V0, 15
9D026B2C  A0400000   SB ZERO, 0(V0)
1344:                	strupr((char*)Name);
9D026B30  8FC20020   LW V0, 32(S8)
9D026B34  00402021   ADDU A0, V0, ZERO
9D026B38  0F409A9D   JAL strupr
9D026B3C  00000000   NOP
1345:                	i = 0;
9D026B40  A3C00010   SB ZERO, 16(S8)
1346:                	while(i < 15u)
9D026B44  0B409AEC   J 0x9D026BB0
9D026B48  00000000   NOP
9D026BB0  93C20010   LBU V0, 16(S8)
9D026BB4  2C42000F   SLTIU V0, V0, 15
9D026BB8  1440FFE4   BNE V0, ZERO, 0x9D026B4C
9D026BBC  00000000   NOP
1347:                	{
1348:                		if(Name[i] == '\0')
9D026B4C  93C20010   LBU V0, 16(S8)
9D026B50  8FC30020   LW V1, 32(S8)
9D026B54  00621021   ADDU V0, V1, V0
9D026B58  90420000   LBU V0, 0(V0)
9D026B5C  14400011   BNE V0, ZERO, 0x9D026BA4
9D026B60  00000000   NOP
1349:                		{
1350:                			while(i < 15u)
9D026B64  0B409AE3   J 0x9D026B8C
9D026B68  00000000   NOP
9D026B8C  93C20010   LBU V0, 16(S8)
9D026B90  2C42000F   SLTIU V0, V0, 15
9D026B94  1440FFF5   BNE V0, ZERO, 0x9D026B6C
9D026B98  00000000   NOP
1351:                			{
1352:                				Name[i++] = ' ';
9D026B6C  93C20010   LBU V0, 16(S8)
9D026B70  8FC30020   LW V1, 32(S8)
9D026B74  00621021   ADDU V0, V1, V0
9D026B78  24030020   ADDIU V1, ZERO, 32
9D026B7C  A0430000   SB V1, 0(V0)
9D026B80  93C20010   LBU V0, 16(S8)
9D026B84  24420001   ADDIU V0, V0, 1
9D026B88  A3C20010   SB V0, 16(S8)
1353:                			}
1354:                			break;
9D026B9C  0B409AF0   J 0x9D026BC0
9D026BA0  00000000   NOP
1355:                		}
1356:                		i++;
9D026BA4  93C20010   LBU V0, 16(S8)
9D026BA8  24420001   ADDIU V0, V0, 1
9D026BAC  A3C20010   SB V0, 16(S8)
1357:                	}
1358:                }
9D026BC0  03C0E821   ADDU SP, S8, ZERO
9D026BC4  8FBF001C   LW RA, 28(SP)
9D026BC8  8FBE0018   LW S8, 24(SP)
9D026BCC  27BD0020   ADDIU SP, SP, 32
9D026BD0  03E00008   JR RA
9D026BD4  00000000   NOP
1359:                
1360:                /*****************************************************************************
1361:                  Function:
1362:                	char * strnchr(const char *searchString, size_t count, char c)
1363:                
1364:                  Summary:
1365:                	Searches a string up to a specified number of characters for a specific 
1366:                	character.
1367:                
1368:                  Description:
1369:                	Searches a string up to a specified number of characters for a specific 
1370:                	character.  The string is searched forward and the first occurance 
1371:                	location is returned.  If the search character is not present in the 
1372:                	string, or if the maximum character count is reached first, then a NULL 
1373:                	pointer is returned.
1374:                
1375:                  Precondition:
1376:                	None
1377:                
1378:                  Parameters:
1379:                	searchString - Pointer to a null terminated string to search.  If count is 
1380:                		less than the string size, then the string need not be null terminated.
1381:                	count - Maximum number of characters to search before aborting.
1382:                	c - Character to search for
1383:                	
1384:                  Returns:
1385:                	Pointer to the first occurance of the character c in the string 
1386:                	searchString.  If the character is not found or the maximum count is 
1387:                	reached, a NULL pointer is returned.
1388:                  ***************************************************************************/
1389:                char * strnchr(const char *searchString, size_t count, char c)
1390:                {
9D026BD8  27BDFFF0   ADDIU SP, SP, -16
9D026BDC  AFBE000C   SW S8, 12(SP)
9D026BE0  03A0F021   ADDU S8, SP, ZERO
9D026BE4  AFC40010   SW A0, 16(S8)
9D026BE8  AFC50014   SW A1, 20(S8)
9D026BEC  00C01021   ADDU V0, A2, ZERO
9D026BF0  A3C20018   SB V0, 24(S8)
1391:                	char c2;
1392:                	
1393:                	while(count--)
9D026BF4  0B409B15   J 0x9D026C54
9D026BF8  00000000   NOP
9D026C54  8FC20014   LW V0, 20(S8)
9D026C58  0002102B   SLTU V0, ZERO, V0
9D026C5C  304200FF   ANDI V0, V0, 255
9D026C60  8FC30014   LW V1, 20(S8)
9D026C64  2463FFFF   ADDIU V1, V1, -1
9D026C68  AFC30014   SW V1, 20(S8)
9D026C6C  1440FFE3   BNE V0, ZERO, 0x9D026BFC
9D026C70  00000000   NOP
1394:                	{
1395:                		c2  = *searchString++;
9D026BFC  8FC20010   LW V0, 16(S8)
9D026C00  90420000   LBU V0, 0(V0)
9D026C04  A3C20000   SB V0, 0(S8)
9D026C08  8FC20010   LW V0, 16(S8)
9D026C0C  24420001   ADDIU V0, V0, 1
9D026C10  AFC20010   SW V0, 16(S8)
1396:                		if(c2 == 0u)
9D026C14  83C20000   LB V0, 0(S8)
9D026C18  14400004   BNE V0, ZERO, 0x9D026C2C
9D026C1C  00000000   NOP
1397:                			return NULL;
9D026C20  00001021   ADDU V0, ZERO, ZERO
9D026C24  0B409B1E   J 0x9D026C78
9D026C28  00000000   NOP
1398:                		if(c2 == c)
9D026C2C  83C30000   LB V1, 0(S8)
9D026C30  83C20018   LB V0, 24(S8)
9D026C34  14620007   BNE V1, V0, 0x9D026C54
9D026C38  00000000   NOP
1399:                			return (char*)--searchString;
9D026C3C  8FC20010   LW V0, 16(S8)
9D026C40  2442FFFF   ADDIU V0, V0, -1
9D026C44  AFC20010   SW V0, 16(S8)
9D026C48  8FC20010   LW V0, 16(S8)
9D026C4C  0B409B1E   J 0x9D026C78
9D026C50  00000000   NOP
1400:                	}
1401:                	return NULL;
9D026C74  00001021   ADDU V0, ZERO, ZERO
1402:                }
9D026C78  03C0E821   ADDU SP, S8, ZERO
9D026C7C  8FBE000C   LW S8, 12(SP)
9D026C80  27BD0010   ADDIU SP, SP, 16
9D026C84  03E00008   JR RA
9D026C88  00000000   NOP
1403:                
1404:                
1405:                /*****************************************************************************
1406:                  Function:
1407:                	char* strncpy_m(char* destStr, size_t destSize, int nStrings, ...)
1408:                
1409:                  Summary:
1410:                	Copies multiple strings to a destination
1411:                
1412:                  Description:
1413:                	Copies multiple strings to a destination
1414:                    but doesn't copy more than destSize characters.
1415:                    Useful where the destination is actually an array and an extra \0
1416:                    won't be appended to overflow the buffer
1417:                    
1418:                  Precondition:
1419:                	- valid string pointers
1420:                    - destSize should be > 0
1421:                
1422:                  Parameters:
1423:                	destStr - Pointer to a string to be initialized with the multiple strings provided as arguments.
1424:                
1425:                    destSize    - the maximum size of the destStr field, that cannot be exceeded.
1426:                                  An \0 won't be appended if the resulting size is > destSize
1427:                
1428:                    nStrings    - number of string parameters to be copied into destStr
1429:                
1430:                    ...         - variable number of arguments
1431:                    
1432:                	
1433:                  Returns:
1434:                	Length of the destination string, terminating \0 (if exists) not included
1435:                  ***************************************************************************/
1436:                size_t strncpy_m(char* destStr, size_t destSize, int nStrings, ...)
1437:                {
9D026C8C  27BDFFD8   ADDIU SP, SP, -40
9D026C90  AFBF0024   SW RA, 36(SP)
9D026C94  AFBE0020   SW S8, 32(SP)
9D026C98  03A0F021   ADDU S8, SP, ZERO
9D026C9C  AFC40028   SW A0, 40(S8)
9D026CA0  AFC5002C   SW A1, 44(S8)
9D026CA4  AFC70034   SW A3, 52(S8)
9D026CA8  AFC60030   SW A2, 48(S8)
1438:                    va_list     args;
1439:                    const char* str;
1440:                    char*       end;
1441:                    size_t      len;
1442:                
1443:                    destStr[0] = '\0';
9D026CAC  8FC20028   LW V0, 40(S8)
9D026CB0  A0400000   SB ZERO, 0(V0)
1444:                    end = destStr + destSize - 1;
9D026CB4  8FC2002C   LW V0, 44(S8)
9D026CB8  2442FFFF   ADDIU V0, V0, -1
9D026CBC  8FC30028   LW V1, 40(S8)
9D026CC0  00621021   ADDU V0, V1, V0
9D026CC4  AFC20014   SW V0, 20(S8)
1445:                    *end = '\0';
9D026CC8  8FC20014   LW V0, 20(S8)
9D026CCC  A0400000   SB ZERO, 0(V0)
1446:                    len = 0;
9D026CD0  AFC00010   SW ZERO, 16(S8)
1447:                    
1448:                    va_start( args, nStrings );
9D026CD4  27C20034   ADDIU V0, S8, 52
9D026CD8  AFC2001C   SW V0, 28(S8)
1449:                    
1450:                    while(nStrings--)
9D026CDC  0B409B57   J 0x9D026D5C
9D026CE0  00000000   NOP
9D026D5C  8FC20030   LW V0, 48(S8)
9D026D60  0002102B   SLTU V0, ZERO, V0
9D026D64  304200FF   ANDI V0, V0, 255
9D026D68  8FC30030   LW V1, 48(S8)
9D026D6C  2463FFFF   ADDIU V1, V1, -1
9D026D70  AFC30030   SW V1, 48(S8)
9D026D74  1440FFDB   BNE V0, ZERO, 0x9D026CE4
9D026D78  00000000   NOP
1451:                    {
1452:                        if(*end)
9D026CE4  8FC20014   LW V0, 20(S8)
9D026CE8  80420000   LB V0, 0(V0)
9D026CEC  10400005   BEQ V0, ZERO, 0x9D026D04
9D026CF0  00000000   NOP
1453:                        {   // if already full don't calculate strlen outside the string area
1454:                            len = destSize;
9D026CF4  8FC2002C   LW V0, 44(S8)
9D026CF8  AFC20010   SW V0, 16(S8)
1455:                            break;
9D026CFC  0B409B5F   J 0x9D026D7C
9D026D00  00000000   NOP
1456:                        }
1457:                        
1458:                        str = va_arg(args, const char*);
9D026D04  8FC2001C   LW V0, 28(S8)
9D026D08  24430004   ADDIU V1, V0, 4
9D026D0C  AFC3001C   SW V1, 28(S8)
9D026D10  8C420000   LW V0, 0(V0)
9D026D14  AFC20018   SW V0, 24(S8)
1459:                        strncpy(destStr + len, str, destSize - len);
9D026D18  8FC30028   LW V1, 40(S8)
9D026D1C  8FC20010   LW V0, 16(S8)
9D026D20  00621821   ADDU V1, V1, V0
9D026D24  8FC4002C   LW A0, 44(S8)
9D026D28  8FC20010   LW V0, 16(S8)
9D026D2C  00821023   SUBU V0, A0, V0
9D026D30  00602021   ADDU A0, V1, ZERO
9D026D34  8FC50018   LW A1, 24(S8)
9D026D38  00403021   ADDU A2, V0, ZERO
9D026D3C  0F40D78C   JAL strncpy
9D026D40  00000000   NOP
1460:                        len += strlen(str);
9D026D44  8FC40018   LW A0, 24(S8)
9D026D48  0F40D2F2   JAL 0x9D034BC8
9D026D4C  00000000   NOP
9D026D50  8FC30010   LW V1, 16(S8)
9D026D54  00621021   ADDU V0, V1, V0
9D026D58  AFC20010   SW V0, 16(S8)
1461:                    }
1462:                
1463:                    va_end( args );
1464:                    
1465:                    return len;
9D026D7C  8FC20010   LW V0, 16(S8)
1466:                }
9D026D80  03C0E821   ADDU SP, S8, ZERO
9D026D84  8FBF0024   LW RA, 36(SP)
9D026D88  8FBE0020   LW S8, 32(SP)
9D026D8C  27BD0028   ADDIU SP, SP, 40
9D026D90  03E00008   JR RA
9D026D94  00000000   NOP
1467:                
1468:                
1469:                /*****************************************************************************
1470:                  Function:
1471:                	BYTE ExtractURLFields(BYTE *vURL, 
1472:                						  PROTOCOLS *protocol, 
1473:                						  BYTE *vUsername, WORD *wUsernameLen, 
1474:                						  BYTE *vPassword, WORD *wPasswordLen, 
1475:                						  BYTE *vHostname, WORD *wHostnameLen, 
1476:                						  WORD *wPort, 
1477:                						  BYTE *vFilePath, WORD *wFilePathLen)
1478:                
1479:                  Summary:
1480:                	Extracts all parameters from an URL string (ex: 
1481:                	"http://admin:passwd@www.microchip.com:8080/myfile.gif" is split into 
1482:                	{PROTOCOL_HTTP, "admin", "passwd", "www.microchip.com", 8080, "/myfile.gif"}.
1483:                
1484:                  Description:
1485:                	Extracts all parameters from an URL string (ex: 
1486:                	"http://admin:passwd@www.microchip.com:8080/myfile.gif" is split into 
1487:                	{PROTOCOL_HTTP, "admin", "passwd", "www.microchip.com", 8080, "/myfile.gif"}.
1488:                	
1489:                	The URL string can be null terminated, or alternatively could be terminated 
1490:                	by a carriage return or line feed.
1491:                	
1492:                	If the protocol is unrecognized or the protocol is recognized but the URL 
1493:                	is malformed, than an error is safely returned.  For more information on 
1494:                	URL/URI interpretation see RFC 2396.
1495:                
1496:                  Precondition:
1497:                	This function is commented out by default to save code space because 
1498:                	it is not used by any current stack features.  However, if you want to use 
1499:                	it, go ahead and uncomment it.  It has been tested, so it (should) work 
1500:                	correctly.
1501:                
1502:                  Parameters:
1503:                	vURL -	Pointer to null terminated URL to decode and extract from.  This 
1504:                		parameter is required and needs to have the minimum RFC 1738 components 
1505:                		in it (protocol and hostname).
1506:                		
1507:                	protocol - Optional pointer to a PROTOCOLS enum to retrieve the decoded 
1508:                		protocol type.  If this parameter is unneeded, specify a NULL pointer.  
1509:                		The protocol is a required part of the URL, so it must always be 
1510:                		present.  The protocol also determines what scheme all other parameters 
1511:                		are decoded using, so the function will fail if an unrecognized 
1512:                		protocol is provided.  The PROTOCOLS enum members show all of the 
1513:                		currently supported protocols for this function.
1514:                		
1515:                		<p>For the example URL provided in the function description, 
1516:                		PROTOCOL_HTTP would be returned for this field.
1517:                		
1518:                	vUsername - Optional pointer to a buffer to write the decoded username 
1519:                		portion of the URL.  If the URL does not contain a username or a NULL 
1520:                		pointer is supplied, then this field is ignored.
1521:                
1522:                		<p>For the example URL provided in the function description, "admin" 
1523:                		would be returned for this field.
1524:                		
1525:                	wUsernameLen -
1526:                		On call\: Optional pointer to a WORD specifying the maximum length of 
1527:                		the vUsername buffer, including the null terminator character.
1528:                		
1529:                		<p>Upon return\: If wUsernameLen and vUsername are non-NULL, the 
1530:                		*wUsernameLen WORD is updated with the actual number of characters 
1531:                		written to the vUsername buffer, including the null terminator 
1532:                		character.  If vUsername is NULL but wUsernameLen is non-NULL, then no 
1533:                		characters are copied, but *wUsernameLen will return the number of 
1534:                		characters required to fit the full username string.  If wUsernameLen 
1535:                		is NULL, then the username field in the URL, if present, is ignored and 
1536:                		the vUsername pointer is not used.
1537:                		
1538:                		<p>If zero characters were written, this indicates that the URL did not 
1539:                		contain a username field.  If one character was written, this indicates 
1540:                		that a username field was present, but was a zero character string 
1541:                		(ex\: "").
1542:                		 
1543:                		<p>For the example URL provided in the function description, 6 (0x0006) 
1544:                		would be returned for this field.
1545:                		
1546:                	vPassword - Optional pointer to a buffer to write the decoded password 
1547:                		portion of the URL.  If the URL does not contain a password or a NULL 
1548:                		pointer is supplied, then this field is ignored.
1549:                
1550:                		<p>For the example URL provided in the function description, "passwd" 
1551:                		would be returned for this field.
1552:                		
1553:                	wPasswordLen -
1554:                		On call\: Optional pointer to a WORD specifying the maximum length of 
1555:                		the vPassword buffer, including the null terminator character.
1556:                		
1557:                		<p>Upon return\: If wPasswordLen and vPassword are non-NULL, the 
1558:                		*wPasswordLen WORD is updated with the actual number of characters 
1559:                		written to the vPassword buffer, including the null terminator 
1560:                		character.  If vPassword is NULL but wPasswordLen is non-NULL, then no 
1561:                		characters are copied, but *wPasswordLen will return the number of 
1562:                		characters required to fit the full password string.  If wPasswordLen 
1563:                		is NULL, then the password field in the URL, if present, is ignored and 
1564:                		the vPassword pointer is not used.
1565:                		
1566:                		<p>If zero characters were written, this indicates that the URL did not 
1567:                		contain a password field.  If one character was written, this indicates 
1568:                		that a password field was present, but was a zero character string 
1569:                		(ex\: "").
1570:                		 
1571:                		<p>For the example URL provided in the function description, 7 (0x0007) 
1572:                		would be returned for this field.
1573:                		
1574:                	vHostname - Optional pointer to a buffer to write the decoded hostname 
1575:                		portion of the URL.  All Internet URLs must contain a hostname or IP 
1576:                		address, however, if a NULL pointer is supplied, then this field is 
1577:                		ignored.
1578:                
1579:                		<p>For the example URL provided in the function description, 
1580:                		"www.microchip.com" would be returned for this field.  If the URL was 
1581:                		"http://192.168.0.1", then this field would be returned as 
1582:                		"192.168.0.1".	The IP address would not be decoded to a DWORD (use the 
1583:                		StringToIPAddress() helper function to do this).
1584:                		
1585:                	wHostnameLen -
1586:                		On call\: Optional pointer to a WORD specifying the maximum length of 
1587:                		the vHostname buffer, including the null terminator character.
1588:                		
1589:                		<p>Upon return\: If wHostnameLen and vHostname are non-NULL, the 
1590:                		*wHostnameLen WORD is updated with the actual number of characters 
1591:                		written to the vHostname buffer, including the null terminator 
1592:                		character.  If vHostname is NULL but wHostnameLen is non-NULL, then no 
1593:                		characters are copied, but *wHostnameLen will return the number of 
1594:                		characters required to fit the full hostname string.  If wHostnameLen 
1595:                		is NULL, then the hostname field in the URL, is ignored and the 
1596:                		vHostname pointer is not used.
1597:                		
1598:                		<p>For the example URL provided in the function description, 
1599:                		18 (0x0012) would be returned for this field.  If the URL was 
1600:                		"http://192.168.0.1", then this field would be returned as 12 (0x000C).
1601:                		
1602:                	wPort - Optional pointer to a WORD specifying the TCP or UDP port that the 
1603:                		server is listening on.  If the port field is absent from the URL, then 
1604:                		this parameter will specify the default port for the protocol.  For 
1605:                		example, "http://www.microchip.com" would result in 80 being return as 
1606:                		the specified port.
1607:                		 
1608:                		<p>If the wPort pointer is NULL, then the port field in the URL 
1609:                		is ignored, if present.
1610:                		
1611:                	vFilePath - Optional pointer to a buffer to write the decoded file path 
1612:                		portion of the URL.  If a NULL pointer is supplied, then this field is 
1613:                		ignored.  If a file path is not present in the URL, then "/" will be 
1614:                		returned in this field.  
1615:                
1616:                		<p>For the example URL provided in the function description, 
1617:                		"/myfile.gif" would be returned for this field.
1618:                		
1619:                	wFilePathLen -
1620:                		On call\: Optional pointer to a WORD specifying the maximum length of 
1621:                		the vFilePath buffer, including the null terminator character.
1622:                		
1623:                		<p>Upon return\: If wFilePathLen and vFilePath are non-NULL, the 
1624:                		*wFilePathLen WORD is updated with the actual number of characters 
1625:                		written to the vFilePath buffer, including the null terminator 
1626:                		character.  If vFilePath is NULL but wFilePathLen is non-NULL, then no 
1627:                		characters are copied, but *wFilePathLen will return the number of 
1628:                		characters required to fit the full file path string.  If wFilePathLen 
1629:                		is NULL, then the file path field in the URL, if present, is ignored and 
1630:                		the vFilePath pointer is not used.
1631:                		
1632:                		<p>This function always returns "/" if no file path is present, so
1633:                		*wFilePathLen will also be at least 2 characters ('/' and null 
1634:                		terminator) if the pointer is non-NULL.
1635:                	
1636:                		<p>For the example URL provided in the function description, 12 (0x000C) 
1637:                		would be returned for this field.
1638:                		
1639:                  Returns:
1640:                	Zero on success.  Nonzero indicates an error code.  If a nonzero error code 
1641:                	is returned, none of the returned buffers or pointer values should be 
1642:                	treated as valid, but some of them may have been written to.  The following 
1643:                	are all possible return values.
1644:                	<table>
1645:                		0   No error
1646:                		1   Protocol unknown (additional code needs to be added to 
1647:                			 ExtractURLFields() and the PROTOCOLS enum needs to be updated if 
1648:                			 you want to decode URLs of this protocol type.
1649:                		2   URL malformed. Illegal or unknown URL format encountered.
1650:                		3   Buffer too small.  One of the input buffer sizes is too small to 
1651:                			 contain the URL parameter.
1652:                	</table>
1653:                  ***************************************************************************/
1654:                #if 0	
1655:                BYTE ExtractURLFields(BYTE *vURL, PROTOCOLS *protocol, BYTE *vUsername, WORD *wUsernameLen, BYTE *vPassword, WORD *wPasswordLen, BYTE *vHostname, WORD *wHostnameLen, WORD *wPort, BYTE *vFilePath, WORD *wFilePathLen)
1656:                {
1657:                	// These two arrays must exactly match up each other and the PROTOCOLS enum 
1658:                	// elements.  The protocol name strings must also be specified in all 
1659:                	// lowercase.
1660:                	static ROM char * ROM	vProtocolNames[] = {"http", "https", "mms", "rtsp"};
1661:                	static ROM WORD 		wProtocolPorts[] = { 80,     443,     1755,  554};
1662:                	WORD w, w2;
1663:                	BYTE i, j;
1664:                	PROTOCOLS prot;
1665:                	BYTE *temp, *temp2;
1666:                	WORD wURLLen;
1667:                	WORD wLocalPort;
1668:                	
1669:                	
1670:                	// Calculate how long this URL is
1671:                	wURLLen = strlen((char*)vURL);
1672:                	temp = (BYTE*)strnchr((char*)vURL, wURLLen, '\r');
1673:                	if(temp)
1674:                		wURLLen = temp - vURL;
1675:                	temp = (BYTE*)strnchr((char*)vURL, wURLLen, '\n');
1676:                	if(temp)
1677:                		wURLLen = temp - vURL;
1678:                	
1679:                
1680:                	// Parse starting protocol field
1681:                	// Find out how long the protocol name field is
1682:                	temp = (BYTE*)strnchr((char*)vURL, wURLLen, ':');
1683:                	if(temp == NULL)
1684:                		return 2;
1685:                	
1686:                	// Search protocol list to see if this is a recognized protocol
1687:                	for(prot = 0; (BYTE)prot < sizeof(wProtocolPorts)/sizeof(wProtocolPorts[0]); prot++)
1688:                	{
1689:                		w = strlenpgm(vProtocolNames[prot]);
1690:                		if((WORD)(temp - vURL) == w)
1691:                		{
1692:                			w2 = 0;
1693:                			temp2 = vURL;
1694:                			while(w)
1695:                			{
1696:                				i = *temp2++;
1697:                				if((i >= 'A') && (i <= 'Z'))
1698:                					i += 'a' - 'A';
1699:                				if(i != (BYTE)vProtocolNames[prot][w2++])
1700:                					break;
1701:                				w--;
1702:                			}
1703:                			if(w == 0u)
1704:                			{
1705:                				if(protocol)
1706:                					*protocol = prot;
1707:                				break;
1708:                			}
1709:                		}
1710:                	}
1711:                
1712:                	// If we've search the whole list and didn't find a match, then 
1713:                	// this protocol is unknown and this URL cannot be parsed.
1714:                	if((BYTE)prot >= sizeof(wProtocolPorts)/sizeof(wProtocolPorts[0]))
1715:                		return 1;
1716:                	
1717:                	w = temp - vURL + 1;
1718:                	vURL += w;
1719:                	wURLLen -= w;
1720:                
1721:                	// Protocols using the authority field all must have a double 
1722:                	// slash "//" prefix
1723:                	if(wURLLen < 2u)
1724:                		return 2;
1725:                	for(j = 0; j < 2u; j++)
1726:                	{
1727:                		i = *vURL++;
1728:                		if(i != '/')
1729:                			return 2;
1730:                	}
1731:                	wURLLen -= 2;
1732:                	
1733:                
1734:                	// Parse username and password fields
1735:                	// See if there is a @ sign, indicating that there is at 
1736:                	// least a username and possibly a password in this URL
1737:                	temp = (BYTE*)strnchr((char*)vURL, wURLLen, '@');
1738:                	if(temp == NULL)
1739:                	{
1740:                		if(wUsernameLen)
1741:                			*wUsernameLen = 0;
1742:                		if(wPasswordLen)
1743:                			*wPasswordLen = 0;
1744:                	}
1745:                	else
1746:                	{
1747:                		// If we get down here, there is a user name present, let's 
1748:                		// see if a password is also present by searching for a 
1749:                		// colon between the current string position and the @ 
1750:                		// symbol.
1751:                		temp2 = (BYTE*)strnchr((char*)vURL, temp - vURL, ':');
1752:                		
1753:                		// Calculate username length and password length, including 
1754:                		// null terminator (if the field exists)
1755:                		if(temp2 == NULL)
1756:                		{
1757:                			w = temp - vURL + 1;	// Username
1758:                			w2 = 0;					// Password
1759:                		}
1760:                		else
1761:                		{
1762:                			w = temp2 - vURL + 1;	// Username
1763:                			w2 = temp - temp2;		// Password
1764:                		}
1765:                		
1766:                		if(wUsernameLen)
1767:                		{
1768:                			if(vUsername)
1769:                			{
1770:                				if(*wUsernameLen < w)
1771:                					return 3;
1772:                				memcpy((void*)vUsername, (void*)vURL, w - 1);
1773:                				vUsername[w-1] = 0;
1774:                			}
1775:                			*wUsernameLen = w;
1776:                		}
1777:                	
1778:                		if(wPasswordLen)
1779:                		{
1780:                			if(vPassword)
1781:                			{
1782:                				if(*wPasswordLen < w2)
1783:                					return 3;
1784:                				if(w2)
1785:                				{
1786:                					memcpy((void*)vPassword, (void*)temp2+1, w2 - 1);
1787:                					vPassword[w2-1] = 0;
1788:                				}
1789:                			}
1790:                			*wPasswordLen = w2;
1791:                		}
1792:                	
1793:                		vURL += w;
1794:                		wURLLen -= w;
1795:                		if(w2)
1796:                		{
1797:                			vURL += w2;
1798:                			wURLLen -= w2;
1799:                		}
1800:                	}
1801:                
1802:                
1803:                	// Parse hostname field
1804:                	// Find the length of the hostname, including NULL 
1805:                	// terminator
1806:                	temp = (BYTE*)strnchr((char*)vURL, wURLLen, ':');
1807:                	temp2 = (BYTE*)strnchr((char*)vURL, wURLLen, '/');
1808:                	if(temp && temp2)
1809:                	{
1810:                		if(temp > temp2)
1811:                			temp = NULL;
1812:                	}
1813:                	if(temp == NULL)
1814:                	{
1815:                		temp = temp2;
1816:                		if(temp2 == NULL)
1817:                			temp = vURL + wURLLen;
1818:                	}
1819:                	w = temp - vURL + 1;
1820:                	if(wHostnameLen)
1821:                	{
1822:                		if(vHostname)
1823:                		{
1824:                			if(*wHostnameLen < w)
1825:                				return 3;
1826:                			memcpy((void*)vHostname, (void*)vURL, w - 1);
1827:                			vHostname[w-1] = 0;
1828:                		}
1829:                		*wHostnameLen = w;
1830:                	}
1831:                	vURL += w - 1;
1832:                	wURLLen -= w - 1;
1833:                
1834:                
1835:                	// Parse port field
1836:                	if(*vURL == ':')
1837:                	{
1838:                		vURL++;
1839:                		wURLLen--;
1840:                		wLocalPort = 0;
1841:                		w = wURLLen;
1842:                		temp = (BYTE*)strnchr((char*)vURL, wURLLen, '/');
1843:                		if(temp != NULL)
1844:                			w = temp - vURL;
1845:                		w2 = w;
1846:                		if(wPort)
1847:                		{
1848:                			while(w--)
1849:                			{
1850:                				wLocalPort *= 10;
1851:                				wLocalPort += *vURL++ - '0';
1852:                			}
1853:                			*wPort = wLocalPort;
1854:                		}
1855:                		else
1856:                			vURL += w2;
1857:                		wURLLen -= w2;
1858:                	}
1859:                	else if(wPort)
1860:                		*wPort = wProtocolPorts[prot];
1861:                
1862:                
1863:                	// Parse file path field
1864:                	if(wFilePathLen)
1865:                	{
1866:                		w = ++wURLLen;
1867:                		if(wURLLen == 1u)
1868:                			w = 2;
1869:                		if(vFilePath)
1870:                		{
1871:                			if(*wFilePathLen < w)
1872:                				return 3;
1873:                			if(wURLLen == 1u)
1874:                				vFilePath[0] = '/';
1875:                			else
1876:                				memcpy((void*)vFilePath, (void*)vURL, wURLLen - 1);
1877:                			vFilePath[w - 1] = 0;
1878:                			*wFilePathLen = w;
1879:                			return 0;
1880:                		}
1881:                		*wFilePathLen = w;
1882:                	}
1883:                	return 0;
1884:                }
1885:                #endif
1886:                
1887:                
1888:                /*****************************************************************************
1889:                  Function:
1890:                	SHORT Replace(BYTE *vExpression, ROM BYTE *vFind, ROM BYTE *vReplacement, 
1891:                				  WORD wMaxLen, BOOL bSearchCaseInsensitive)
1892:                
1893:                  Summary:
1894:                	Replaces all instances of a particular substring with a new string
1895:                
1896:                  Description:
1897:                	Searches a string (vExpression) and replaces all instances of a particular 
1898:                	substring (vFind) with a new string (vReplacement).  The start offset to 
1899:                	being searching and a maximum number of replacements can be specified.  The 
1900:                	search can be performed in a case sensitive or case insensitive manner.
1901:                
1902:                  Precondition:
1903:                	This function is commented out by default to save code space because 
1904:                	it is not used by any current stack features.  However, if you want to use 
1905:                	it, go ahead and uncomment it.  It has been tested, so it (should) work 
1906:                	correctly.
1907:                
1908:                  Parameters:
1909:                	vExpression - Null terminated string to search and make replacements within.
1910:                	vFind - Null terminated string to search for.
1911:                	vReplacement - Null terminated string to replace all instances of vFind with.
1912:                	wMaxLen - Maximum length of the output vExpression string if string 
1913:                		expansion is going to occur (replacement length is longer than find 
1914:                		length).  If the replacements will cause this maximum string length to 
1915:                		be exceeded, then no replacements will be made and a negative result 
1916:                		will be returned, indicating failure.  If the replacement length is 
1917:                		shorter or equal to the search length, then this parameter is ignored.
1918:                	bSearchCaseInsensitive - Boolean indicating if the search should be 
1919:                		performed in a case insensitive manner.  Specify TRUE for case 
1920:                		insensitive searches (slower) or FALSE for case sensitive 
1921:                		searching (faster).
1922:                
1923:                  Remarks:
1924:                	If the replacement string length is shorter than or equal to the search 
1925:                	string length and the search string occurs in multiple overlapping 
1926:                	locations (ex\: expression is "aaa", find is "aa", and replacement is "bb") 
1927:                	then the first find match occuring when searching from left to right will 
1928:                	be replaced.  (ex\: output expression will be "bba").
1929:                	
1930:                	However, if the replacement string length is longer than the search string 
1931:                	length, the search will occur starting from the end of the string and 
1932:                	proceed to the beginning (right to left searching).  In this case if the 
1933:                	expression was "aaa", find was "aa", and replacement was "bbb", then the 
1934:                	final output expression will be "abbb".  
1935:                
1936:                  Returns:
1937:                	If zero or greater, indicates the count of how many replacements were made.  
1938:                	If less than zero (negative result), indicates that wMaxLen was too small 
1939:                	to make the necessary replacements.  In this case, no replacements were 
1940:                	made.
1941:                  ***************************************************************************/
1942:                #if 0
1943:                SHORT Replace(BYTE *vExpression, ROM BYTE *vFind, ROM BYTE *vReplacement, WORD wMaxLen, BOOL bSearchCaseInsensitive)
1944:                {
1945:                	WORD wExpressionLen, wFindLen, wFindLenMinusOne, wReplacementLen;
1946:                	WORD wFindCount, wReplacementsLeft;
1947:                	BYTE i, j;
1948:                	BYTE vFirstFindChar;
1949:                	WORD wBytesLeft;
1950:                	BYTE *vDest;
1951:                	BYTE *vExpressionCompare;
1952:                	ROM BYTE *vFindCompare;
1953:                	WORD w;
1954:                
1955:                	wFindLen = strlenpgm((ROM char*)vFind);
1956:                	if(wFindLen == 0u)
1957:                		return 0;
1958:                	
1959:                	wExpressionLen = strlen((char*)vExpression);
1960:                	wReplacementLen = strlenpgm((ROM char*)vReplacement);
1961:                
1962:                	wFindCount = 0;
1963:                	wFindLenMinusOne = wFindLen - 1;
1964:                	vFirstFindChar = *vFind++;
1965:                	if(bSearchCaseInsensitive)	// Convert to all lowercase if needed
1966:                		if((vFirstFindChar >= (BYTE)'A') && (vFirstFindChar <= (BYTE)'Z'))
1967:                			vFirstFindChar += 'a' - 'A';
1968:                
1969:                	// If the replacement string is the same length as the search string, then 
1970:                	// we can immediately do the needed replacements inline and return.
1971:                	if(wFindLen == wReplacementLen)
1972:                	{
1973:                		for(wBytesLeft = wExpressionLen; wBytesLeft; wBytesLeft--)
1974:                		{
1975:                			i = *vExpression++;
1976:                			if(bSearchCaseInsensitive)
1977:                			{
1978:                				if((i >= (BYTE)'A') && (i <= (BYTE)'Z'))
1979:                					i += 'a' - 'A';
1980:                				if(i != vFirstFindChar)
1981:                					continue;
1982:                				vExpressionCompare = vExpression;
1983:                				vFindCompare = vFind;
1984:                				w = wFindLenMinusOne;
1985:                				while(w)
1986:                				{
1987:                					i = *vExpressionCompare++;
1988:                					j = *vFindCompare++;
1989:                					if((i >= (BYTE)'A') && (i <= (BYTE)'Z'))
1990:                						i += 'a' - 'A';
1991:                					if((j >= (BYTE)'A') && (j <= (BYTE)'Z'))
1992:                						j += 'a' - 'A';
1993:                					if(i != j)
1994:                						break;
1995:                					w--;
1996:                				}
1997:                				if(w)
1998:                					continue;
1999:                			}
2000:                			else
2001:                			{
2002:                				if(i != vFirstFindChar)
2003:                					continue;
2004:                				if(memcmppgm2ram((void*)vExpression, (ROM void*)vFind, wFindLenMinusOne))
2005:                					continue;
2006:                			}
2007:                	
2008:                			memcpypgm2ram((void*)vExpression-1, (ROM void*)vReplacement, wReplacementLen);
2009:                			wFindCount++;
2010:                			vExpression += wFindLenMinusOne;
2011:                			wBytesLeft -= wFindLenMinusOne;
2012:                		}
2013:                		return wFindCount;
2014:                	}
2015:                	
2016:                	
2017:                	// If the replacement string is shorter than the search string, then we can 
2018:                	// search from left to right and move the string over as we find occurrences.
2019:                	if(wFindLen > wReplacementLen)
2020:                	{
2021:                		vDest = vExpression;
2022:                		for(wBytesLeft = wExpressionLen; wBytesLeft; wBytesLeft--)
2023:                		{
2024:                			i = *vExpression++;
2025:                			*vDest++ = i;
2026:                			if(bSearchCaseInsensitive)
2027:                			{
2028:                				if((i >= (BYTE)'A') && (i <= (BYTE)'Z'))
2029:                					i += 'a' - 'A';
2030:                				if(i != vFirstFindChar)
2031:                					continue;
2032:                				vExpressionCompare = vExpression;
2033:                				vFindCompare = vFind;
2034:                				w = wFindLenMinusOne;
2035:                				while(w)
2036:                				{
2037:                					i = *vExpressionCompare++;
2038:                					j = *vFindCompare++;
2039:                					if((i >= (BYTE)'A') && (i <= (BYTE)'Z'))
2040:                						i += 'a' - 'A';
2041:                					if((j >= (BYTE)'A') && (j <= (BYTE)'Z'))
2042:                						j += 'a' - 'A';
2043:                					if(i != j)
2044:                						break;
2045:                					w--;
2046:                				}
2047:                				if(w)
2048:                					continue;
2049:                			}
2050:                			else
2051:                			{
2052:                				if(i != vFirstFindChar)
2053:                					continue;
2054:                				if(memcmppgm2ram((void*)vExpression, (ROM void*)vFind, wFindLenMinusOne))
2055:                					continue;
2056:                			}
2057:                	
2058:                			memcpypgm2ram((void*)vDest-1, (ROM void*)vReplacement, wReplacementLen);
2059:                			vDest += wReplacementLen-1;
2060:                			wFindCount++;
2061:                			vExpression += wFindLenMinusOne;
2062:                			wBytesLeft -= wFindLenMinusOne;
2063:                		}
2064:                		*vDest = 0x00;	// Write new null terminator since the string may have shrunk
2065:                		return wFindCount;
2066:                	}
2067:                	
2068:                	// If the replacement string is longer than the search string, then we will 
2069:                	// take a two pass approach.  On the first pass, we will merely count how 
2070:                	// many replacements to make.  With this we can calculate how long the 
2071:                	// final string is going to be.  On the second pass, we will search from 
2072:                	// right to left and expand the string as needed.
2073:                
2074:                	// Pass 1: count how many occurrences of vFind are in vExpression
2075:                	for(wBytesLeft = wExpressionLen; wBytesLeft; wBytesLeft--)
2076:                	{
2077:                		i = *vExpression++;
2078:                		if(bSearchCaseInsensitive)
2079:                		{
2080:                			if((i >= (BYTE)'A') && (i <= (BYTE)'Z'))
2081:                				i += 'a' - 'A';
2082:                			if(i != vFirstFindChar)
2083:                				continue;
2084:                			vExpressionCompare = vExpression;
2085:                			vFindCompare = vFind;
2086:                			w = wFindLenMinusOne;
2087:                			while(w)
2088:                			{
2089:                				i = *vExpressionCompare++;
2090:                				j = *vFindCompare++;
2091:                				if((i >= (BYTE)'A') && (i <= (BYTE)'Z'))
2092:                					i += 'a' - 'A';
2093:                				if((j >= (BYTE)'A') && (j <= (BYTE)'Z'))
2094:                					j += 'a' - 'A';
2095:                				if(i != j)
2096:                					break;
2097:                				w--;
2098:                			}
2099:                			if(w)
2100:                				continue;
2101:                		}
2102:                		else
2103:                		{
2104:                			if(i != vFirstFindChar)
2105:                				continue;
2106:                			if(memcmppgm2ram((void*)vExpression, (ROM void*)vFind, wFindLenMinusOne))
2107:                				continue;
2108:                		}
2109:                
2110:                		wFindCount++;
2111:                		vExpression += wFindLenMinusOne;
2112:                		wBytesLeft -= wFindLenMinusOne;
2113:                	}
2114:                	
2115:                	// Return immediately if no replacements are needed
2116:                	if(wFindCount == 0u)
2117:                		return 0;
2118:                
2119:                	// Pass 2: make replacements and move string over
2120:                	vDest = vExpression + wFindCount * (wReplacementLen - wFindLen);
2121:                	if(vDest > vExpression - wExpressionLen + wMaxLen)
2122:                		return -1;
2123:                	*vDest-- = 0x00;	// Write new null terminator
2124:                	vExpression -= 1;
2125:                	vFind -= 1;
2126:                	vFirstFindChar = vFind[wFindLenMinusOne];
2127:                	if(bSearchCaseInsensitive)	// Convert to all lowercase if needed
2128:                		if((vFirstFindChar >= (BYTE)'A') && (vFirstFindChar <= (BYTE)'Z'))
2129:                			vFirstFindChar += 'a' - 'A';
2130:                	wReplacementsLeft = wFindCount;
2131:                	while(wReplacementsLeft)
2132:                	{
2133:                		i = *vExpression--;
2134:                		*vDest-- = i;
2135:                		if(bSearchCaseInsensitive)
2136:                		{
2137:                			if((i >= (BYTE)'A') && (i <= (BYTE)'Z'))
2138:                				i += 'a' - 'A';
2139:                			if(i != vFirstFindChar)
2140:                				continue;
2141:                			vExpressionCompare = vExpression;
2142:                			vFindCompare = &vFind[wFindLenMinusOne-1];
2143:                			w = wFindLenMinusOne;
2144:                			while(w)
2145:                			{
2146:                				i = *vExpressionCompare--;
2147:                				j = *vFindCompare--;
2148:                				if((i >= (BYTE)'A') && (i <= (BYTE)'Z'))
2149:                					i += 'a' - 'A';
2150:                				if((j >= (BYTE)'A') && (j <= (BYTE)'Z'))
2151:                					j += 'a' - 'A';
2152:                				if(i != j)
2153:                					break;
2154:                				w--;
2155:                			}
2156:                			if(w)
2157:                				continue;
2158:                		}
2159:                		else
2160:                		{
2161:                			if(i != vFirstFindChar)
2162:                				continue;
2163:                			if(memcmppgm2ram((void*)vExpression-wFindLenMinusOne, (ROM void*)vFind, wFindLenMinusOne))
2164:                				continue;
2165:                		}
2166:                		memcpypgm2ram((void*)vDest-wReplacementLen+2, (ROM void*)vReplacement, wReplacementLen);
2167:                		vDest -= wReplacementLen-1;
2168:                
2169:                		vExpression -= wFindLenMinusOne;
2170:                		wBytesLeft -= wFindLenMinusOne;
2171:                		wReplacementsLeft--;
2172:                	}
2173:                	return wFindCount;
2174:                }
2175:                #endif
---  C:/Users/Diego/Documents/GitHub/pic32webFREERtos/Pic32Web.X/src/tcpip/src/Hashes.c  ----------------
1:                   /*********************************************************************
2:                    *
3:                    *	Hash Function Library
4:                    *  Library for Microchip TCP/IP Stack
5:                    *	 -Calculates MD5 and SHA-1 Hashes
6:                    *	 -Reference: RFC 1321 (MD5), RFC 3174 and FIPS 180-1 (SHA-1)
7:                    *
8:                    *********************************************************************
9:                    * FileName:        Hashes.c
10:                   * Dependencies:    None
11:                   * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32
12:                   * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32
13:                   * Compiler:        Microchip C32 v1.05 or higher
14:                   *					Microchip C30 v3.12 or higher
15:                   *					Microchip C18 v3.30 or higher
16:                   *					HI-TECH PICC-18 PRO 9.63PL2 or higher
17:                   * Company:         Microchip Technology, Inc.
18:                   *
19:                   * Software License Agreement
20:                   *
21:                   * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights
22:                   * reserved.
23:                   *
24:                   * Microchip licenses to you the right to use, modify, copy, and
25:                   * distribute:
26:                   * (i)  the Software when embedded on a Microchip microcontroller or
27:                   *      digital signal controller product ("Device") which is
28:                   *      integrated into Licensee's product; or
29:                   * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h,
30:                   *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device
31:                   *		used in conjunction with a Microchip ethernet controller for
32:                   *		the sole purpose of interfacing with the ethernet controller.
33:                   *
34:                   * You should refer to the license agreement accompanying this
35:                   * Software for additional information regarding your rights and
36:                   * obligations.
37:                   *
38:                   * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT
39:                   * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT
40:                   * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A
41:                   * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL
42:                   * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR
43:                   * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF
44:                   * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS
45:                   * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE
46:                   * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER
47:                   * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT
48:                   * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE.
49:                   *
50:                   * IMPORTANT:  The implementation and use of third party algorithms, 
51:                   * specifications and/or other technology may require a license from 
52:                   * various third parties.  It is your responsibility to obtain 
53:                   * information regarding any applicable licensing obligations.
54:                   *
55:                   *
56:                   * Author               Date		Comment
57:                   *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
58:                   * Elliott Wood	        5/01/07		Original
59:                   * Elliott Wood			11/21/07	Greatly increased HashBlock speed
60:                   ********************************************************************/
61:                  #define __HASHES_C
62:                  
63:                  /*****************************************************************************
64:                    Internal:
65:                    	Performance Statistics are as follows:
66:                    	(Given in instructions per block = 512 bits = 64 bytes)
67:                  	
68:                  					MD5					SHA1
69:                  		C18			23k instr/block		50k instr/block
70:                  		Hi-Tech C	19k instr/block		50k instr/block
71:                  		C30			21k instr/block		17k instr/block
72:                  		
73:                    ***************************************************************************/
74:                  
75:                  #include "TCPIP Stack/TCPIP.h"
76:                  
77:                  /****************************************************************************
78:                    Section:
79:                  	Functions and variables required for both hash types
80:                    ***************************************************************************/
81:                  
82:                  #if defined(STACK_USE_MD5) || defined(STACK_USE_SHA1)
83:                  
84:                  // Stores a copy of the last block with the required padding
85:                  BYTE lastBlock[64];
86:                  
87:                  /*****************************************************************************
88:                    Function:
89:                  	void HashAddData(HASH_SUM* theSum, BYTE* data, WORD len)
90:                  
91:                    Description:
92:                  	Adds data to the hash sum.
93:                  
94:                    Precondition:
95:                  	The hash sum has already been initialized
96:                  
97:                    Parameters:
98:                  	theSum - hash context state
99:                  	data - the data to be added to the hash sum
100:                 	len - length of data
101:                 
102:                   Returns:
103:                   	None
104:                   	
105:                   Remarks:
106:                 	This function calls the appropriate hashing function based on the 
107:                 	hash typed defined in theSum.
108:                   ***************************************************************************/
109:                 void HashAddData(HASH_SUM* theSum, BYTE* data, WORD len)
110:                 {
9D02E68C  27BDFFE8   ADDIU SP, SP, -24
9D02E690  AFBF0014   SW RA, 20(SP)
9D02E694  AFBE0010   SW S8, 16(SP)
9D02E698  03A0F021   ADDU S8, SP, ZERO
9D02E69C  AFC40018   SW A0, 24(S8)
9D02E6A0  AFC5001C   SW A1, 28(S8)
9D02E6A4  00C01021   ADDU V0, A2, ZERO
9D02E6A8  A7C20020   SH V0, 32(S8)
111:                 	#if defined(STACK_USE_MD5)
112:                 	if(theSum->hashType == HASH_MD5)
9D02E6AC  8FC20018   LW V0, 24(S8)
9D02E6B0  8C420058   LW V0, 88(V0)
9D02E6B4  14400007   BNE V0, ZERO, 0x9D02E6D4
9D02E6B8  00000000   NOP
113:                 		MD5AddData(theSum, data, len);
9D02E6BC  97C20020   LHU V0, 32(S8)
9D02E6C0  8FC40018   LW A0, 24(S8)
9D02E6C4  8FC5001C   LW A1, 28(S8)
9D02E6C8  00403021   ADDU A2, V0, ZERO
9D02E6CC  0F40B9D8   JAL MD5AddData
9D02E6D0  00000000   NOP
114:                 	#endif
115:                 	#if defined(STACK_USE_SHA1)
116:                 	if(theSum->hashType == HASH_SHA1)
117:                 		SHA1AddData(theSum, data, len);
118:                 	#endif
119:                 }
9D02E6D4  03C0E821   ADDU SP, S8, ZERO
9D02E6D8  8FBF0014   LW RA, 20(SP)
9D02E6DC  8FBE0010   LW S8, 16(SP)
9D02E6E0  27BD0018   ADDIU SP, SP, 24
9D02E6E4  03E00008   JR RA
9D02E6E8  00000000   NOP
120:                 
121:                 /*****************************************************************************
122:                   Function:
123:                 	void HashAddROMData(HASH_SUM* theSum, ROM BYTE* data, WORD len)
124:                 
125:                   Description:
126:                 	Adds data to the hash sum.
127:                 
128:                   Precondition:
129:                 	The hash sum has already been initialized
130:                 
131:                   Parameters:
132:                 	theSum - hash context state
133:                 	data - the data to be added to the hash sum
134:                 	len - length of data
135:                 
136:                   Returns:
137:                   	None
138:                   	
139:                   Remarks:
140:                 	This function calls the appropriate hashing function based on the 
141:                 	hash typed defined in theSum.
142:                 	
143:                 	This function is aliased to HashAddData on non-PIC18 platforms.
144:                   ***************************************************************************/
145:                 #if defined(__18CXX)
146:                 void HashAddROMData(HASH_SUM* theSum, ROM BYTE* data, WORD len)
147:                 {
148:                 	#if defined(STACK_USE_MD5)
149:                 	if(theSum->hashType == HASH_MD5)
150:                 		MD5AddROMData(theSum, data, len);
151:                 	#endif
152:                 	#if defined(STACK_USE_SHA1)
153:                 	if(theSum->hashType == HASH_SHA1)
154:                 		SHA1AddROMData(theSum, data, len);
155:                 	#endif
156:                 }
157:                 #endif
158:                 
159:                 #endif
160:                 
161:                 
162:                 /****************************************************************************
163:                   Section:
164:                 	Functions and variables required for MD5
165:                   ***************************************************************************/
166:                 
167:                 #if defined(STACK_USE_MD5)
168:                 
169:                 // Array of pre-defined R vales for MD5
170:                 static ROM BYTE _MD5_r[64] = {7, 12, 17, 22,  7, 12, 17, 22,  7, 12, 17, 22,  7, 12, 17, 22,
171:                 				  5,  9, 14, 20,  5,  9, 14, 20,  5,  9, 14, 20,  5,  9, 14, 20,
172:                 				  4, 11, 16, 23,  4, 11, 16, 23,  4, 11, 16, 23,  4, 11, 16, 23,
173:                 				  6, 10, 15, 21,  6, 10, 15, 21,  6, 10, 15, 21,  6, 10, 15, 21};
174:                 
175:                 // Array of pre-defined K values for MD5
176:                 static ROM DWORD _MD5_k[64] = { 0xD76AA478, 0xE8C7B756, 0x242070DB, 0xC1BDCEEE, 0xF57C0FAF, 0x4787C62A, 0xA8304613, 0xFD469501, 
177:                 							0x698098D8, 0x8B44F7AF, 0xFFFF5BB1, 0x895CD7BE, 0x6B901122, 0xFD987193, 0xA679438E, 0x49B40821, 
178:                 							0xF61E2562, 0xC040B340, 0x265E5A51, 0xE9B6C7AA, 0xD62F105D, 0x02441453, 0xD8A1E681, 0xE7D3FBC8, 
179:                 							0x21E1CDE6, 0xC33707D6, 0xF4D50D87, 0x455A14ED, 0xA9E3E905, 0xFCEFA3F8, 0x676F02D9, 0x8D2A4C8A, 
180:                 							0xFFFA3942, 0x8771F681, 0x6D9D6122, 0xFDE5380C, 0xA4BEEA44, 0x4BDECFA9, 0xF6BB4B60, 0xBEBFBC70, 
181:                 							0x289B7EC6, 0xEAA127FA, 0xD4EF3085, 0x04881D05, 0xD9D4D039, 0xE6DB99E5, 0x1FA27CF8, 0xC4AC5665, 
182:                 							0xF4292244, 0x432AFF97, 0xAB9423A7, 0xFC93A039, 0x655B59C3, 0x8F0CCC92, 0xFFEFF47D, 0x85845DD1, 
183:                 							0x6FA87E4F, 0xFE2CE6E0, 0xA3014314, 0x4E0811A1, 0xF7537E82, 0xBD3AF235, 0x2AD7D2BB, 0xEB86D391 };
184:                 
185:                 static void MD5HashBlock(BYTE* data, DWORD* h0, DWORD* h1, DWORD* h2, DWORD* h3);
186:                 
187:                 /*****************************************************************************
188:                   Function:
189:                 	void MD5Initialize(HASH_SUM* theSum)
190:                 
191:                   Description:
192:                 	Initializes a new MD5 hash.
193:                 
194:                   Precondition:
195:                 	None
196:                 
197:                   Parameters:
198:                 	theSum - pointer to the allocated HASH_SUM object to initialize as MD5
199:                 
200:                   Returns:
201:                   	None
202:                   ***************************************************************************/
203:                 void MD5Initialize(HASH_SUM* theSum)
204:                 {
9D02E6EC  27BDFFF8   ADDIU SP, SP, -8
9D02E6F0  AFBE0004   SW S8, 4(SP)
9D02E6F4  03A0F021   ADDU S8, SP, ZERO
9D02E6F8  AFC40008   SW A0, 8(S8)
205:                 	theSum->h0 = 0x67452301;
9D02E6FC  8FC20008   LW V0, 8(S8)
9D02E700  3C036745   LUI V1, 26437
9D02E704  34632301   ORI V1, V1, 8961
9D02E708  AC430000   SW V1, 0(V0)
206:                 	theSum->h1 = 0xefcdab89;
9D02E70C  8FC20008   LW V0, 8(S8)
9D02E710  3C03EFCD   LUI V1, -4147
9D02E714  3463AB89   ORI V1, V1, -21623
9D02E718  AC430004   SW V1, 4(V0)
207:                 	theSum->h2 = 0x98badcfe;
9D02E71C  8FC20008   LW V0, 8(S8)
9D02E720  3C0398BA   LUI V1, -26438
9D02E724  3463DCFE   ORI V1, V1, -8962
9D02E728  AC430008   SW V1, 8(V0)
208:                 	theSum->h3 = 0x10325476;
9D02E72C  8FC20008   LW V0, 8(S8)
9D02E730  3C031032   LUI V1, 4146
9D02E734  34635476   ORI V1, V1, 21622
9D02E738  AC43000C   SW V1, 12(V0)
209:                 	theSum->bytesSoFar = 0;
9D02E73C  8FC20008   LW V0, 8(S8)
9D02E740  AC400014   SW ZERO, 20(V0)
210:                 	theSum->hashType = HASH_MD5;
9D02E744  8FC20008   LW V0, 8(S8)
9D02E748  AC400058   SW ZERO, 88(V0)
211:                 }
9D02E74C  03C0E821   ADDU SP, S8, ZERO
9D02E750  8FBE0004   LW S8, 4(SP)
9D02E754  27BD0008   ADDIU SP, SP, 8
9D02E758  03E00008   JR RA
9D02E75C  00000000   NOP
212:                 
213:                 /*****************************************************************************
214:                   Function:
215:                 	void MD5AddData(HASH_SUM* theSum, BYTE* data, WORD len)
216:                 
217:                   Description:
218:                 	Adds data to an MD5 hash calculation.
219:                 
220:                   Precondition:
221:                 	The hash context has already been initialized.
222:                 
223:                   Parameters:
224:                 	theSum - a pointer to the hash context structure
225:                 	data - the data to add to the hash
226:                 	len - the length of the data to add
227:                 
228:                   Returns:
229:                   	None
230:                   ***************************************************************************/
231:                 void MD5AddData(HASH_SUM* theSum, BYTE* data, WORD len)
232:                 {
9D02E760  27BDFFD8   ADDIU SP, SP, -40
9D02E764  AFBF0024   SW RA, 36(SP)
9D02E768  AFBE0020   SW S8, 32(SP)
9D02E76C  03A0F021   ADDU S8, SP, ZERO
9D02E770  AFC40028   SW A0, 40(S8)
9D02E774  AFC5002C   SW A1, 44(S8)
9D02E778  00C01021   ADDU V0, A2, ZERO
9D02E77C  A7C20030   SH V0, 48(S8)
233:                 	BYTE *blockPtr;
234:                 
235:                 	// Seek to the first free byte
236:                 	blockPtr = theSum->partialBlock + ( theSum->bytesSoFar & 0x3f );
9D02E780  8FC20028   LW V0, 40(S8)
9D02E784  24430018   ADDIU V1, V0, 24
9D02E788  8FC20028   LW V0, 40(S8)
9D02E78C  8C420014   LW V0, 20(V0)
9D02E790  3042003F   ANDI V0, V0, 63
9D02E794  00621021   ADDU V0, V1, V0
9D02E798  AFC20018   SW V0, 24(S8)
237:                 
238:                 	// Update the total number of bytes
239:                 	theSum->bytesSoFar += len;
9D02E79C  8FC20028   LW V0, 40(S8)
9D02E7A0  8C430014   LW V1, 20(V0)
9D02E7A4  97C20030   LHU V0, 48(S8)
9D02E7A8  00621821   ADDU V1, V1, V0
9D02E7AC  8FC20028   LW V0, 40(S8)
9D02E7B0  AC430014   SW V1, 20(V0)
240:                 
241:                 	// Copy data into the partial block
242:                 	while(len != 0u)
9D02E7B4  0B40BA13   J 0x9D02E84C
9D02E7B8  00000000   NOP
9D02E84C  97C20030   LHU V0, 48(S8)
9D02E850  1440FFDA   BNE V0, ZERO, 0x9D02E7BC
9D02E854  00000000   NOP
243:                 	{
244:                 		*blockPtr++ = *data++;
9D02E7BC  8FC2002C   LW V0, 44(S8)
9D02E7C0  90430000   LBU V1, 0(V0)
9D02E7C4  8FC20018   LW V0, 24(S8)
9D02E7C8  A0430000   SB V1, 0(V0)
9D02E7CC  8FC20018   LW V0, 24(S8)
9D02E7D0  24420001   ADDIU V0, V0, 1
9D02E7D4  AFC20018   SW V0, 24(S8)
9D02E7D8  8FC2002C   LW V0, 44(S8)
9D02E7DC  24420001   ADDIU V0, V0, 1
9D02E7E0  AFC2002C   SW V0, 44(S8)
245:                 
246:                 		// If the partial block is full, hash the data and start over
247:                 		if(blockPtr == theSum->partialBlock + 64)
9D02E7E4  8FC20028   LW V0, 40(S8)
9D02E7E8  24420018   ADDIU V0, V0, 24
9D02E7EC  24430040   ADDIU V1, V0, 64
9D02E7F0  8FC20018   LW V0, 24(S8)
9D02E7F4  14620012   BNE V1, V0, 0x9D02E840
9D02E7F8  00000000   NOP
248:                 		{
249:                 			MD5HashBlock(theSum->partialBlock, &theSum->h0, &theSum->h1, &theSum->h2, &theSum->h3);
9D02E7FC  8FC20028   LW V0, 40(S8)
9D02E800  24440018   ADDIU A0, V0, 24
9D02E804  8FC50028   LW A1, 40(S8)
9D02E808  8FC20028   LW V0, 40(S8)
9D02E80C  24430004   ADDIU V1, V0, 4
9D02E810  8FC20028   LW V0, 40(S8)
9D02E814  24420008   ADDIU V0, V0, 8
9D02E818  8FC60028   LW A2, 40(S8)
9D02E81C  24C6000C   ADDIU A2, A2, 12
9D02E820  AFA60010   SW A2, 16(SP)
9D02E824  00603021   ADDU A2, V1, ZERO
9D02E828  00403821   ADDU A3, V0, ZERO
9D02E82C  0F40BA1C   JAL 0x9D02E870
9D02E830  00000000   NOP
250:                 			blockPtr = theSum->partialBlock;
9D02E834  8FC20028   LW V0, 40(S8)
9D02E838  24420018   ADDIU V0, V0, 24
9D02E83C  AFC20018   SW V0, 24(S8)
251:                 		}
252:                 		
253:                 		len--;
9D02E840  97C20030   LHU V0, 48(S8)
9D02E844  2442FFFF   ADDIU V0, V0, -1
9D02E848  A7C20030   SH V0, 48(S8)
254:                 	}
255:                 	
256:                 }
9D02E858  03C0E821   ADDU SP, S8, ZERO
9D02E85C  8FBF0024   LW RA, 36(SP)
9D02E860  8FBE0020   LW S8, 32(SP)
9D02E864  27BD0028   ADDIU SP, SP, 40
9D02E868  03E00008   JR RA
9D02E86C  00000000   NOP
257:                 
258:                 /*****************************************************************************
259:                   Function:
260:                 	void MD5AddROMData(HASH_SUM* theSum, ROM BYTE* data, WORD len)
261:                 
262:                   Description:
263:                 	Adds data to an MD5 hash calculation.
264:                 
265:                   Precondition:
266:                 	The hash context has already been initialized.
267:                 
268:                   Parameters:
269:                 	theSum - a pointer to the hash context structure
270:                 	data - the data to add to the hash
271:                 	len - the length of the data to add
272:                 
273:                   Returns:
274:                   	None
275:                   	
276:                   Remarks:
277:                   	This function is aliased to MD5AddData on non-PIC18 platforms.
278:                   ***************************************************************************/
279:                 #if defined(__18CXX)
280:                 void MD5AddROMData(HASH_SUM* theSum, ROM BYTE* data, WORD len)
281:                 {
282:                 	BYTE *blockPtr;
283:                 
284:                 	// Seek to the first free byte
285:                 	blockPtr = theSum->partialBlock + ( theSum->bytesSoFar & 0x3f );
286:                 
287:                 	// Update the total number of bytes
288:                 	theSum->bytesSoFar += len;
289:                 
290:                 	// Copy data into the partial block
291:                 	while(len != 0u)
292:                 	{
293:                 		*blockPtr++ = *data++;
294:                 
295:                 		// If the partial block is full, hash the data and start over
296:                 		if(blockPtr == theSum->partialBlock + 64)
297:                 		{
298:                 			MD5HashBlock(theSum->partialBlock, &theSum->h0, &theSum->h1, &theSum->h2, &theSum->h3);
299:                 			blockPtr = theSum->partialBlock;
300:                 		}
301:                 		
302:                 		len--;
303:                 	}
304:                 	
305:                 }
306:                 #endif
307:                 
308:                 /*****************************************************************************
309:                   Function:
310:                 	static void MD5HashBlock(BYTE* data, DWORD* h0, DWORD* h1, 
311:                 								DWORD* h2, DWORD* h3)
312:                 
313:                   Summary:
314:                 	Calculates the MD5 hash sum of a block.
315:                 
316:                   Description:
317:                 	This function calculates the MD5 hash sum over a block and updates
318:                 	the values of h0-h3 with the next context.
319:                 
320:                   Precondition:
321:                 	The data pointer must be WORD aligned on 16-bit parts and DWORD
322:                 	aligned on 32-bit PICs.  If alignment is not correct, a memory alignment
323:                 	exception will occur.
324:                 
325:                   Parameters:
326:                 	data - The block of 64 bytes to hash
327:                 	h0 - the current hash context h0 value
328:                 	h1 - the current hash context h1 value
329:                 	h2 - the current hash context h2 value
330:                 	h3 - the current hash context h3 value
331:                 
332:                   Returns:
333:                   	None
334:                 
335:                   ***************************************************************************/
336:                 static void MD5HashBlock(BYTE* data, DWORD* h0, DWORD* h1, DWORD* h2, DWORD* h3)
337:                 {
9D02E870  27BDFFD8   ADDIU SP, SP, -40
9D02E874  AFBE0024   SW S8, 36(SP)
9D02E878  03A0F021   ADDU S8, SP, ZERO
9D02E87C  AFC40028   SW A0, 40(S8)
9D02E880  AFC5002C   SW A1, 44(S8)
9D02E884  AFC60030   SW A2, 48(S8)
9D02E888  AFC70034   SW A3, 52(S8)
338:                 	DWORD a, b, c, d, f, temp;
339:                 	BYTE i, j;
340:                 
341:                 	// Set up a, b, c, d
342:                 	a = *h0;
9D02E88C  8FC2002C   LW V0, 44(S8)
9D02E890  8C420000   LW V0, 0(V0)
9D02E894  AFC20000   SW V0, 0(S8)
343:                 	b = *h1;
9D02E898  8FC20030   LW V0, 48(S8)
9D02E89C  8C420000   LW V0, 0(V0)
9D02E8A0  AFC20004   SW V0, 4(S8)
344:                 	c = *h2;
9D02E8A4  8FC20034   LW V0, 52(S8)
9D02E8A8  8C420000   LW V0, 0(V0)
9D02E8AC  AFC20008   SW V0, 8(S8)
345:                 	d = *h3;
9D02E8B0  8FC20038   LW V0, 56(S8)
9D02E8B4  8C420000   LW V0, 0(V0)
9D02E8B8  AFC2000C   SW V0, 12(S8)
346:                 
347:                 	// Main mixer loop for 64 operations
348:                 	for(i = 0; i < 64u; i++)
9D02E8BC  A3C00014   SB ZERO, 20(S8)
9D02E8C0  0B40BAAA   J 0x9D02EAA8
9D02E8C4  00000000   NOP
9D02EA9C  93C20014   LBU V0, 20(S8)
9D02EAA0  24420001   ADDIU V0, V0, 1
9D02EAA4  A3C20014   SB V0, 20(S8)
9D02EAA8  93C20014   LBU V0, 20(S8)
9D02EAAC  2C420040   SLTIU V0, V0, 64
9D02EAB0  1440FF85   BNE V0, ZERO, 0x9D02E8C8
9D02EAB4  00000000   NOP
349:                 	{
350:                 		if(i <= 15u)
9D02E8C8  93C20014   LBU V0, 20(S8)
9D02E8CC  2C420010   SLTIU V0, V0, 16
9D02E8D0  1040000E   BEQ V0, ZERO, 0x9D02E90C
9D02E8D4  00000000   NOP
351:                 		{
352:                 			f = (b & c) | ((~b) & d);
9D02E8D8  8FC30004   LW V1, 4(S8)
9D02E8DC  8FC20008   LW V0, 8(S8)
9D02E8E0  00621824   AND V1, V1, V0
9D02E8E4  8FC20004   LW V0, 4(S8)
9D02E8E8  00022027   NOR A0, ZERO, V0
9D02E8EC  8FC2000C   LW V0, 12(S8)
9D02E8F0  00821024   AND V0, A0, V0
9D02E8F4  00621025   OR V0, V1, V0
9D02E8F8  AFC20010   SW V0, 16(S8)
353:                 			j = i;
9D02E8FC  93C20014   LBU V0, 20(S8)
9D02E900  A3C20015   SB V0, 21(S8)
9D02E904  0B40BA83   J 0x9D02EA0C
9D02E908  00000000   NOP
354:                 		}
355:                 		else if(i > 15u && i <= 31u)
9D02E90C  93C20014   LBU V0, 20(S8)
9D02E910  2C420010   SLTIU V0, V0, 16
9D02E914  14400018   BNE V0, ZERO, 0x9D02E978
9D02E918  00000000   NOP
9D02E91C  93C20014   LBU V0, 20(S8)
9D02E920  2C420020   SLTIU V0, V0, 32
9D02E924  10400014   BEQ V0, ZERO, 0x9D02E978
9D02E928  00000000   NOP
356:                 		{
357:                 			f = (d & b) | ((~d) & c);
9D02E92C  8FC3000C   LW V1, 12(S8)
9D02E930  8FC20004   LW V0, 4(S8)
9D02E934  00621824   AND V1, V1, V0
9D02E938  8FC2000C   LW V0, 12(S8)
9D02E93C  00022027   NOR A0, ZERO, V0
9D02E940  8FC20008   LW V0, 8(S8)
9D02E944  00821024   AND V0, A0, V0
9D02E948  00621025   OR V0, V1, V0
9D02E94C  AFC20010   SW V0, 16(S8)
358:                 			j = (5 * i + 1) & 0x0f;
9D02E950  93C30014   LBU V1, 20(S8)
9D02E954  24020005   ADDIU V0, ZERO, 5
9D02E958  70621002   MUL V0, V1, V0
9D02E95C  304200FF   ANDI V0, V0, 255
9D02E960  24420001   ADDIU V0, V0, 1
9D02E964  304200FF   ANDI V0, V0, 255
9D02E968  3042000F   ANDI V0, V0, 15
9D02E96C  A3C20015   SB V0, 21(S8)
9D02E970  0B40BA83   J 0x9D02EA0C
9D02E974  00000000   NOP
359:                 		}
360:                 		else if(i > 31u && i <= 47u)
9D02E978  93C20014   LBU V0, 20(S8)
9D02E97C  2C420020   SLTIU V0, V0, 32
9D02E980  14400015   BNE V0, ZERO, 0x9D02E9D8
9D02E984  00000000   NOP
9D02E988  93C20014   LBU V0, 20(S8)
9D02E98C  2C420030   SLTIU V0, V0, 48
9D02E990  10400011   BEQ V0, ZERO, 0x9D02E9D8
9D02E994  00000000   NOP
361:                 		{
362:                 			f = (b ^ c ^ d);
9D02E998  8FC30004   LW V1, 4(S8)
9D02E99C  8FC20008   LW V0, 8(S8)
9D02E9A0  00621826   XOR V1, V1, V0
9D02E9A4  8FC2000C   LW V0, 12(S8)
9D02E9A8  00621026   XOR V0, V1, V0
9D02E9AC  AFC20010   SW V0, 16(S8)
363:                 			j = (3 * i + 5) & 0x0f;
9D02E9B0  93C30014   LBU V1, 20(S8)
9D02E9B4  24020003   ADDIU V0, ZERO, 3
9D02E9B8  70621002   MUL V0, V1, V0
9D02E9BC  304200FF   ANDI V0, V0, 255
9D02E9C0  24420005   ADDIU V0, V0, 5
9D02E9C4  304200FF   ANDI V0, V0, 255
9D02E9C8  3042000F   ANDI V0, V0, 15
9D02E9CC  A3C20015   SB V0, 21(S8)
9D02E9D0  0B40BA83   J 0x9D02EA0C
9D02E9D4  00000000   NOP
364:                 		}
365:                 		else
366:                 		{
367:                 			f = c ^ (b | (~d));
9D02E9D8  8FC2000C   LW V0, 12(S8)
9D02E9DC  00021827   NOR V1, ZERO, V0
9D02E9E0  8FC20004   LW V0, 4(S8)
9D02E9E4  00621825   OR V1, V1, V0
9D02E9E8  8FC20008   LW V0, 8(S8)
9D02E9EC  00621026   XOR V0, V1, V0
9D02E9F0  AFC20010   SW V0, 16(S8)
368:                 			j = (7 * i) & 0x0f;
9D02E9F4  93C30014   LBU V1, 20(S8)
9D02E9F8  24020007   ADDIU V0, ZERO, 7
9D02E9FC  70621002   MUL V0, V1, V0
9D02EA00  304200FF   ANDI V0, V0, 255
9D02EA04  3042000F   ANDI V0, V0, 15
9D02EA08  A3C20015   SB V0, 21(S8)
369:                 		}
370:                 		
371:                 		// Calculate the new mixer values
372:                 		temp = d;
9D02EA0C  8FC2000C   LW V0, 12(S8)
9D02EA10  AFC20018   SW V0, 24(S8)
373:                 		d = c;
9D02EA14  8FC20008   LW V0, 8(S8)
9D02EA18  AFC2000C   SW V0, 12(S8)
374:                 		c = b;
9D02EA1C  8FC20004   LW V0, 4(S8)
9D02EA20  AFC20008   SW V0, 8(S8)
375:                 		j *= 4;
9D02EA24  93C20015   LBU V0, 21(S8)
9D02EA28  00021080   SLL V0, V0, 2
9D02EA2C  A3C20015   SB V0, 21(S8)
376:                 		b = leftRotateDWORD(a+f+_MD5_k[i]+(*(DWORD*)&data[j]),_MD5_r[i]) + b;
9D02EA30  8FC30000   LW V1, 0(S8)
9D02EA34  8FC20010   LW V0, 16(S8)
9D02EA38  00621821   ADDU V1, V1, V0
9D02EA3C  93C40014   LBU A0, 20(S8)
9D02EA40  3C029D03   LUI V0, -25341
9D02EA44  00042080   SLL A0, A0, 2
9D02EA48  24424EC8   ADDIU V0, V0, 20168
9D02EA4C  00821021   ADDU V0, A0, V0
9D02EA50  8C420000   LW V0, 0(V0)
9D02EA54  00621821   ADDU V1, V1, V0
9D02EA58  8FC40028   LW A0, 40(S8)
9D02EA5C  93C20015   LBU V0, 21(S8)
9D02EA60  00821021   ADDU V0, A0, V0
9D02EA64  8C420000   LW V0, 0(V0)
9D02EA68  00621821   ADDU V1, V1, V0
9D02EA6C  93C40014   LBU A0, 20(S8)
9D02EA70  3C029D03   LUI V0, -25341
9D02EA74  24424E88   ADDIU V0, V0, 20104
9D02EA78  00821021   ADDU V0, A0, V0
9D02EA7C  90420000   LBU V0, 0(V0)
9D02EA80  00021023   SUBU V0, ZERO, V0
9D02EA84  00431046   ROTRV V0, V1, V0
9D02EA88  8FC30004   LW V1, 4(S8)
9D02EA8C  00621021   ADDU V0, V1, V0
9D02EA90  AFC20004   SW V0, 4(S8)
377:                 		a = temp;
9D02EA94  8FC20018   LW V0, 24(S8)
9D02EA98  AFC20000   SW V0, 0(S8)
378:                 	}
379:                 
380:                 	// Add the new hash to the sum
381:                 	*h0 += a;
9D02EAB8  8FC2002C   LW V0, 44(S8)
9D02EABC  8C430000   LW V1, 0(V0)
9D02EAC0  8FC20000   LW V0, 0(S8)
9D02EAC4  00621821   ADDU V1, V1, V0
9D02EAC8  8FC2002C   LW V0, 44(S8)
9D02EACC  AC430000   SW V1, 0(V0)
382:                 	*h1 += b;
9D02EAD0  8FC20030   LW V0, 48(S8)
9D02EAD4  8C430000   LW V1, 0(V0)
9D02EAD8  8FC20004   LW V0, 4(S8)
9D02EADC  00621821   ADDU V1, V1, V0
9D02EAE0  8FC20030   LW V0, 48(S8)
9D02EAE4  AC430000   SW V1, 0(V0)
383:                 	*h2 += c;
9D02EAE8  8FC20034   LW V0, 52(S8)
9D02EAEC  8C430000   LW V1, 0(V0)
9D02EAF0  8FC20008   LW V0, 8(S8)
9D02EAF4  00621821   ADDU V1, V1, V0
9D02EAF8  8FC20034   LW V0, 52(S8)
9D02EAFC  AC430000   SW V1, 0(V0)
384:                 	*h3 += d;
9D02EB00  8FC20038   LW V0, 56(S8)
9D02EB04  8C430000   LW V1, 0(V0)
9D02EB08  8FC2000C   LW V0, 12(S8)
9D02EB0C  00621821   ADDU V1, V1, V0
9D02EB10  8FC20038   LW V0, 56(S8)
9D02EB14  AC430000   SW V1, 0(V0)
385:                 
386:                 }
9D02EB18  03C0E821   ADDU SP, S8, ZERO
9D02EB1C  8FBE0024   LW S8, 36(SP)
9D02EB20  27BD0028   ADDIU SP, SP, 40
9D02EB24  03E00008   JR RA
9D02EB28  00000000   NOP
387:                 
388:                 /*****************************************************************************
389:                   Function:
390:                 	void MD5Calculate(HASH_SUM* theSum, BYTE* result)
391:                 
392:                   Summary:
393:                 	Calculates an MD5 hash
394:                 
395:                   Description:
396:                 	This function calculates the hash sum of all input data so far.  It is
397:                 	non-destructive to the hash context, so more data may be added after
398:                 	this function is called.
399:                 
400:                   Precondition:
401:                 	The hash context has been properly initialized.
402:                 
403:                   Parameters:
404:                 	theSum - the current hash context
405:                 	result - 16 byte array in which to store the resulting hash
406:                 
407:                   Returns:
408:                   	None
409:                   ***************************************************************************/
410:                 void MD5Calculate(HASH_SUM* theSum, BYTE* result)
411:                 {
9D02EB2C  27BDFFC0   ADDIU SP, SP, -64
9D02EB30  AFBF003C   SW RA, 60(SP)
9D02EB34  AFBE0038   SW S8, 56(SP)
9D02EB38  03A0F021   ADDU S8, SP, ZERO
9D02EB3C  AFC40040   SW A0, 64(S8)
9D02EB40  AFC50044   SW A1, 68(S8)
412:                 	DWORD h0, h1, h2, h3;
413:                 	BYTE i, *partPtr, *endPtr;
414:                 
415:                 	// Initialize the hash variables
416:                 	h0 = theSum->h0;
9D02EB44  8FC20040   LW V0, 64(S8)
9D02EB48  8C420000   LW V0, 0(V0)
9D02EB4C  AFC20024   SW V0, 36(S8)
417:                 	h1 = theSum->h1;
9D02EB50  8FC20040   LW V0, 64(S8)
9D02EB54  8C420004   LW V0, 4(V0)
9D02EB58  AFC20028   SW V0, 40(S8)
418:                 	h2 = theSum->h2;
9D02EB5C  8FC20040   LW V0, 64(S8)
9D02EB60  8C420008   LW V0, 8(V0)
9D02EB64  AFC2002C   SW V0, 44(S8)
419:                 	h3 = theSum->h3;
9D02EB68  8FC20040   LW V0, 64(S8)
9D02EB6C  8C42000C   LW V0, 12(V0)
9D02EB70  AFC20030   SW V0, 48(S8)
420:                 
421:                 	// Find out how far along we are in the partial block and copy to last block
422:                 	partPtr = theSum->partialBlock;
9D02EB74  8FC20040   LW V0, 64(S8)
9D02EB78  24420018   ADDIU V0, V0, 24
9D02EB7C  AFC2001C   SW V0, 28(S8)
423:                 	endPtr = partPtr + ( theSum->bytesSoFar & 0x3f );
9D02EB80  8FC20040   LW V0, 64(S8)
9D02EB84  8C420014   LW V0, 20(V0)
9D02EB88  3042003F   ANDI V0, V0, 63
9D02EB8C  8FC3001C   LW V1, 28(S8)
9D02EB90  00621021   ADDU V0, V1, V0
9D02EB94  AFC20020   SW V0, 32(S8)
424:                 	for(i = 0; partPtr != endPtr; i++)
9D02EB98  A3C00018   SB ZERO, 24(S8)
9D02EB9C  0B40BAF6   J 0x9D02EBD8
9D02EBA0  00000000   NOP
9D02EBCC  93C20018   LBU V0, 24(S8)
9D02EBD0  24420001   ADDIU V0, V0, 1
9D02EBD4  A3C20018   SB V0, 24(S8)
9D02EBD8  8FC3001C   LW V1, 28(S8)
9D02EBDC  8FC20020   LW V0, 32(S8)
9D02EBE0  1462FFF0   BNE V1, V0, 0x9D02EBA4
9D02EBE4  00000000   NOP
425:                 	{
426:                 		lastBlock[i] = *partPtr++;
9D02EBA4  93C40018   LBU A0, 24(S8)
9D02EBA8  8FC2001C   LW V0, 28(S8)
9D02EBAC  90430000   LBU V1, 0(V0)
9D02EBB0  3C02A000   LUI V0, -24576
9D02EBB4  24420534   ADDIU V0, V0, 1332
9D02EBB8  00821021   ADDU V0, A0, V0
9D02EBBC  A0430000   SB V1, 0(V0)
9D02EBC0  8FC2001C   LW V0, 28(S8)
9D02EBC4  24420001   ADDIU V0, V0, 1
9D02EBC8  AFC2001C   SW V0, 28(S8)
427:                 	}
428:                 
429:                 	// Add one more 1 bit and 7 zeros
430:                 	lastBlock[i++] = 0x80;
9D02EBE8  93C30018   LBU V1, 24(S8)
9D02EBEC  3C02A000   LUI V0, -24576
9D02EBF0  24420534   ADDIU V0, V0, 1332
9D02EBF4  00621021   ADDU V0, V1, V0
9D02EBF8  2403FF80   ADDIU V1, ZERO, -128
9D02EBFC  A0430000   SB V1, 0(V0)
9D02EC00  93C20018   LBU V0, 24(S8)
9D02EC04  24420001   ADDIU V0, V0, 1
9D02EC08  A3C20018   SB V0, 24(S8)
431:                 
432:                 	// If there's 8 or more bytes left to 64, then this is the last block
433:                 	if(i > 56u)
9D02EC0C  93C20018   LBU V0, 24(S8)
9D02EC10  2C420039   SLTIU V0, V0, 57
9D02EC14  14400025   BNE V0, ZERO, 0x9D02ECAC
9D02EC18  00000000   NOP
434:                 	{// If there's not enough space, then zero fill this and add a new block
435:                 		// Zero pad the remainder
436:                 		for( ; i < 64u; lastBlock[i++] = 0x00);
9D02EC1C  0B40BB11   J 0x9D02EC44
9D02EC20  00000000   NOP
9D02EC24  93C30018   LBU V1, 24(S8)
9D02EC28  3C02A000   LUI V0, -24576
9D02EC2C  24420534   ADDIU V0, V0, 1332
9D02EC30  00621021   ADDU V0, V1, V0
9D02EC34  A0400000   SB ZERO, 0(V0)
9D02EC38  93C20018   LBU V0, 24(S8)
9D02EC3C  24420001   ADDIU V0, V0, 1
9D02EC40  A3C20018   SB V0, 24(S8)
9D02EC44  93C20018   LBU V0, 24(S8)
9D02EC48  2C420040   SLTIU V0, V0, 64
9D02EC4C  1440FFF5   BNE V0, ZERO, 0x9D02EC24
9D02EC50  00000000   NOP
437:                 
438:                 		// Calculate a hash on this block and add it to the sum
439:                 		MD5HashBlock(lastBlock, &h0, &h1, &h2, &h3);
9D02EC54  27C50024   ADDIU A1, S8, 36
9D02EC58  27C30028   ADDIU V1, S8, 40
9D02EC5C  27C2002C   ADDIU V0, S8, 44
9D02EC60  27C40030   ADDIU A0, S8, 48
9D02EC64  AFA40010   SW A0, 16(SP)
9D02EC68  3C04A000   LUI A0, -24576
9D02EC6C  24840534   ADDIU A0, A0, 1332
9D02EC70  00603021   ADDU A2, V1, ZERO
9D02EC74  00403821   ADDU A3, V0, ZERO
9D02EC78  0F40BA1C   JAL 0x9D02E870
9D02EC7C  00000000   NOP
440:                 
441:                 		// Create a new block for the size
442:                 		i = 0;
9D02EC80  A3C00018   SB ZERO, 24(S8)
443:                 	}
444:                 
445:                 	// Zero fill the rest of the block
446:                 	for( ; i < 56u; lastBlock[i++] = 0x00);
9D02EC84  0B40BB2B   J 0x9D02ECAC
9D02EC88  00000000   NOP
9D02EC8C  93C30018   LBU V1, 24(S8)
9D02EC90  3C02A000   LUI V0, -24576
9D02EC94  24420534   ADDIU V0, V0, 1332
9D02EC98  00621021   ADDU V0, V1, V0
9D02EC9C  A0400000   SB ZERO, 0(V0)
9D02ECA0  93C20018   LBU V0, 24(S8)
9D02ECA4  24420001   ADDIU V0, V0, 1
9D02ECA8  A3C20018   SB V0, 24(S8)
9D02ECAC  93C20018   LBU V0, 24(S8)
9D02ECB0  2C420038   SLTIU V0, V0, 56
9D02ECB4  1440FFF5   BNE V0, ZERO, 0x9D02EC8C
9D02ECB8  00000000   NOP
447:                 
448:                 	// Fill in the size, in bits, in little-endian
449:                 	lastBlock[56] = theSum->bytesSoFar << 3;
9D02ECBC  8FC20040   LW V0, 64(S8)
9D02ECC0  8C420014   LW V0, 20(V0)
9D02ECC4  304200FF   ANDI V0, V0, 255
9D02ECC8  000210C0   SLL V0, V0, 3
9D02ECCC  304300FF   ANDI V1, V0, 255
9D02ECD0  3C02A000   LUI V0, -24576
9D02ECD4  24420534   ADDIU V0, V0, 1332
9D02ECD8  A0430038   SB V1, 56(V0)
450:                 	lastBlock[57] = theSum->bytesSoFar >> 5;
9D02ECDC  8FC20040   LW V0, 64(S8)
9D02ECE0  8C420014   LW V0, 20(V0)
9D02ECE4  00021142   SRL V0, V0, 5
9D02ECE8  304300FF   ANDI V1, V0, 255
9D02ECEC  3C02A000   LUI V0, -24576
9D02ECF0  24420534   ADDIU V0, V0, 1332
9D02ECF4  A0430039   SB V1, 57(V0)
451:                 	lastBlock[58] = theSum->bytesSoFar >> 13;
9D02ECF8  8FC20040   LW V0, 64(S8)
9D02ECFC  8C420014   LW V0, 20(V0)
9D02ED00  00021342   SRL V0, V0, 13
9D02ED04  304300FF   ANDI V1, V0, 255
9D02ED08  3C02A000   LUI V0, -24576
9D02ED0C  24420534   ADDIU V0, V0, 1332
9D02ED10  A043003A   SB V1, 58(V0)
452:                 	lastBlock[59] = theSum->bytesSoFar >> 21;
9D02ED14  8FC20040   LW V0, 64(S8)
9D02ED18  8C420014   LW V0, 20(V0)
9D02ED1C  00021542   SRL V0, V0, 21
9D02ED20  304300FF   ANDI V1, V0, 255
9D02ED24  3C02A000   LUI V0, -24576
9D02ED28  24420534   ADDIU V0, V0, 1332
9D02ED2C  A043003B   SB V1, 59(V0)
453:                 	lastBlock[60] = theSum->bytesSoFar >> 29;
9D02ED30  8FC20040   LW V0, 64(S8)
9D02ED34  8C420014   LW V0, 20(V0)
9D02ED38  00021742   SRL V0, V0, 29
9D02ED3C  304300FF   ANDI V1, V0, 255
9D02ED40  3C02A000   LUI V0, -24576
9D02ED44  24420534   ADDIU V0, V0, 1332
9D02ED48  A043003C   SB V1, 60(V0)
454:                 	lastBlock[61] = 0;
9D02ED4C  3C02A000   LUI V0, -24576
9D02ED50  24420534   ADDIU V0, V0, 1332
9D02ED54  A040003D   SB ZERO, 61(V0)
455:                 	lastBlock[62] = 0;
9D02ED58  3C02A000   LUI V0, -24576
9D02ED5C  24420534   ADDIU V0, V0, 1332
9D02ED60  A040003E   SB ZERO, 62(V0)
456:                 	lastBlock[63] = 0;
9D02ED64  3C02A000   LUI V0, -24576
9D02ED68  24420534   ADDIU V0, V0, 1332
9D02ED6C  A040003F   SB ZERO, 63(V0)
457:                 
458:                 	// Calculate a hash on this final block and add it to the sum
459:                 	MD5HashBlock(lastBlock, &h0, &h1, &h2, &h3);
9D02ED70  27C50024   ADDIU A1, S8, 36
9D02ED74  27C30028   ADDIU V1, S8, 40
9D02ED78  27C2002C   ADDIU V0, S8, 44
9D02ED7C  27C40030   ADDIU A0, S8, 48
9D02ED80  AFA40010   SW A0, 16(SP)
9D02ED84  3C04A000   LUI A0, -24576
9D02ED88  24840534   ADDIU A0, A0, 1332
9D02ED8C  00603021   ADDU A2, V1, ZERO
9D02ED90  00403821   ADDU A3, V0, ZERO
9D02ED94  0F40BA1C   JAL 0x9D02E870
9D02ED98  00000000   NOP
460:                 	
461:                 	// Format the result in little-endian format
462:                 	memcpy((void*)result,(void*)&h0,4);
9D02ED9C  27C20024   ADDIU V0, S8, 36
9D02EDA0  8FC40044   LW A0, 68(S8)
9D02EDA4  00402821   ADDU A1, V0, ZERO
9D02EDA8  24060004   ADDIU A2, ZERO, 4
9D02EDAC  0F40D298   JAL 0x9D034A60
9D02EDB0  00000000   NOP
463:                 	memcpy((void*)&result[4],(void*)&h1,4);
9D02EDB4  8FC20044   LW V0, 68(S8)
9D02EDB8  24430004   ADDIU V1, V0, 4
9D02EDBC  27C20028   ADDIU V0, S8, 40
9D02EDC0  00602021   ADDU A0, V1, ZERO
9D02EDC4  00402821   ADDU A1, V0, ZERO
9D02EDC8  24060004   ADDIU A2, ZERO, 4
9D02EDCC  0F40D298   JAL 0x9D034A60
9D02EDD0  00000000   NOP
464:                 	memcpy((void*)&result[8],(void*)&h2,4);
9D02EDD4  8FC20044   LW V0, 68(S8)
9D02EDD8  24430008   ADDIU V1, V0, 8
9D02EDDC  27C2002C   ADDIU V0, S8, 44
9D02EDE0  00602021   ADDU A0, V1, ZERO
9D02EDE4  00402821   ADDU A1, V0, ZERO
9D02EDE8  24060004   ADDIU A2, ZERO, 4
9D02EDEC  0F40D298   JAL 0x9D034A60
9D02EDF0  00000000   NOP
465:                 	memcpy((void*)&result[12],(void*)&h3,4);
9D02EDF4  8FC20044   LW V0, 68(S8)
9D02EDF8  2443000C   ADDIU V1, V0, 12
9D02EDFC  27C20030   ADDIU V0, S8, 48
9D02EE00  00602021   ADDU A0, V1, ZERO
9D02EE04  00402821   ADDU A1, V0, ZERO
9D02EE08  24060004   ADDIU A2, ZERO, 4
9D02EE0C  0F40D298   JAL 0x9D034A60
9D02EE10  00000000   NOP
466:                 }
9D02EE14  03C0E821   ADDU SP, S8, ZERO
9D02EE18  8FBF003C   LW RA, 60(SP)
9D02EE1C  8FBE0038   LW S8, 56(SP)
9D02EE20  27BD0040   ADDIU SP, SP, 64
9D02EE24  03E00008   JR RA
9D02EE28  00000000   NOP
467:                 
468:                 #endif //ends MD5
469:                 
470:                 /****************************************************************************
471:                   Section:
472:                 	Functions and variables required for SHA-1
473:                   ***************************************************************************/
474:                 
475:                 #if defined(STACK_USE_SHA1)
476:                 
477:                 static void SHA1HashBlock(BYTE* data, DWORD* h0, DWORD* h1, DWORD* h2, DWORD* h3, DWORD* h4);
478:                 
479:                 /*****************************************************************************
480:                   Function:
481:                 	void SHA1Initialize(HASH_SUM* theSum)
482:                 
483:                   Description:
484:                 	Initializes a new SHA-1 hash.
485:                 
486:                   Precondition:
487:                 	None
488:                 
489:                   Parameters:
490:                 	theSum - pointer to the allocated HASH_SUM object to initialize as SHA-1
491:                 
492:                   Returns:
493:                   	None
494:                   ***************************************************************************/
495:                 void SHA1Initialize(HASH_SUM* theSum)
496:                 {
497:                 	theSum->h0 = 0x67452301;
498:                 	theSum->h1 = 0xEFCDAB89;
499:                 	theSum->h2 = 0x98BADCFE;
500:                 	theSum->h3 = 0x10325476;
501:                 	theSum->h4 = 0xC3D2E1F0;
502:                 	theSum->bytesSoFar = 0;
503:                 	theSum->hashType = HASH_SHA1;
504:                 }
505:                 
506:                 /*****************************************************************************
507:                   Function:
508:                 	void SHA1AddData(HASH_SUM* theSum, BYTE* data, WORD len)
509:                 
510:                   Description:
511:                 	Adds data to a SHA-1 hash calculation.
512:                 
513:                   Precondition:
514:                 	The hash context has already been initialized.
515:                 
516:                   Parameters:
517:                 	theSum - a pointer to the hash context structure
518:                 	data - the data to add to the hash
519:                 	len - the length of the data to add
520:                 
521:                   Returns:
522:                   	None
523:                   ***************************************************************************/
524:                 void SHA1AddData(HASH_SUM* theSum, BYTE* data, WORD len)
525:                 {
526:                 	BYTE *blockPtr;
527:                 
528:                 	// Seek to the first free byte
529:                 	blockPtr = theSum->partialBlock + ( theSum->bytesSoFar & 0x3f );
530:                 
531:                 	// Update the total number of bytes
532:                 	theSum->bytesSoFar += len;
533:                 
534:                 	// Copy data into the partial block
535:                 	while(len != 0u)
536:                 	{
537:                 		*blockPtr++ = *data++;
538:                 
539:                 		// If the partial block is full, hash the data and start over
540:                 		if(blockPtr == theSum->partialBlock + 64)
541:                 		{
542:                 			SHA1HashBlock(theSum->partialBlock, &theSum->h0, &theSum->h1,
543:                 							 &theSum->h2, &theSum->h3, &theSum->h4);
544:                 			blockPtr = theSum->partialBlock;
545:                 		}
546:                 		
547:                 		len--;
548:                 	}
549:                 	
550:                 }
551:                 
552:                 /*****************************************************************************
553:                   Function:
554:                 	void SHA1AddROMData(HASH_SUM* theSum, ROM BYTE* data, WORD len)
555:                 
556:                   Description:
557:                 	Adds data to a SHA-1 hash calculation.
558:                 
559:                   Precondition:
560:                 	The hash context has already been initialized.
561:                 
562:                   Parameters:
563:                 	theSum - a pointer to the hash context structure
564:                 	data - the data to add to the hash
565:                 	len - the length of the data to add
566:                 
567:                   Returns:
568:                   	None
569:                   	
570:                   Remarks:
571:                   	This function is aliased to SHA1AddData on non-PIC18 platforms.
572:                   ***************************************************************************/
573:                 #if defined(__18CXX)
574:                 void SHA1AddROMData(HASH_SUM* theSum, ROM BYTE* data, WORD len)
575:                 {
576:                 	BYTE *blockPtr;
577:                 
578:                 	// Seek to the first free byte
579:                 	blockPtr = theSum->partialBlock + ( theSum->bytesSoFar & 0x3f );
580:                 
581:                 	// Update the total number of bytes
582:                 	theSum->bytesSoFar += len;
583:                 
584:                 	// Copy data into the partial block
585:                 	while(len != 0u)
586:                 	{
587:                 		*blockPtr++ = *data++;
588:                 
589:                 		// If the partial block is full, hash the data and start over
590:                 		if(blockPtr == theSum->partialBlock + 64)
591:                 		{
592:                 			SHA1HashBlock(theSum->partialBlock, &theSum->h0, &theSum->h1,
593:                 							 &theSum->h2, &theSum->h3, &theSum->h4);
594:                 			blockPtr = theSum->partialBlock;
595:                 		}
596:                 		
597:                 		len--;
598:                 	}
599:                 	
600:                 }
601:                 #endif
602:                 
603:                 /*****************************************************************************
604:                   Function:
605:                 	static void SHA1HashBlock(BYTE* data, DWORD* h0, DWORD* h1, 
606:                 								DWORD* h2, DWORD* h3, DWORD* h4)
607:                 
608:                   Summary:
609:                 	Calculates the SHA-1 hash sum of a block.
610:                 
611:                   Description:
612:                 	This function calculates the SHA-1 hash sum over a block and updates
613:                 	the values of h0-h3 with the next context.
614:                 
615:                   Precondition:
616:                 	The data pointer must be WORD aligned on 16-bit parts and DWORD
617:                 	aligned on 32-bit PICs.  If alignment is not correct, a memory alignment
618:                 	exception will occur.
619:                 
620:                   Parameters:
621:                 	data - The block of 64 bytes to hash
622:                 	h0 - the current hash context h0 value
623:                 	h1 - the current hash context h1 value
624:                 	h2 - the current hash context h2 value
625:                 	h3 - the current hash context h3 value
626:                 	h4 - the current hash context h4 value
627:                 
628:                   Returns:
629:                   	None
630:                 
631:                   ***************************************************************************/
632:                 static void SHA1HashBlock(BYTE* data, DWORD* h0, DWORD* h1, DWORD* h2, 
633:                 							DWORD* h3, DWORD* h4)
634:                 {
635:                 	DWORD a, b, c, d, e, f, k, temp;
636:                 	DWORD_VAL *w = (DWORD_VAL*)lastBlock;
637:                 	BYTE i, back3, back8, back14;
638:                 
639:                 	// Set up a, b, c, d, e
640:                 	a = *h0;
641:                 	b = *h1;
642:                 	c = *h2;
643:                 	d = *h3;
644:                 	e = *h4;
645:                 
646:                 	// Set up the w[] vector
647:                 	if(lastBlock == data)
648:                 	{// If they're the same, just swap endian-ness
649:                 		for(i = 0; i < 16u; i++)
650:                 		{
651:                 			back3 = data[3];
652:                 			data[3] = data[0];
653:                 			data[0] = back3;
654:                 			back3 = data[1];
655:                 			data[1] = data[2];
656:                 			data[2] = back3;
657:                 			data += 4;
658:                 		}
659:                 	}
660:                 	else
661:                 	{// Otherwise, copy values in swaping endian-ness as we go
662:                 		for(i = 0; i < 16u; i++)
663:                 		{
664:                 			w[i].v[3] = *data++;
665:                 			w[i].v[2] = *data++;
666:                 			w[i].v[1] = *data++;
667:                 			w[i].v[0] = *data++;
668:                 		}
669:                 	}
670:                 	back3 = 13;
671:                 	back8 = 8;
672:                 	back14 = 2;
673:                 
674:                 	// Main mixer loop for 80 operations
675:                 	for(i = 0; i < 80u; i++)
676:                 	{
677:                 		if(i <= 19u)
678:                 		{
679:                 			f = (b & c) | ((~b) & d);
680:                 			k = 0x5A827999;
681:                 		}
682:                 		else if(i >= 20u && i <= 39u)
683:                 		{
684:                 			f = b ^ c ^ d;
685:                 			k = 0x6ED9EBA1;
686:                 		}
687:                 		else if(i >= 40u && i <= 59u)
688:                 		{
689:                 			f = (b & c) | (b & d) | (c & d);
690:                 			k = 0x8F1BBCDC;
691:                 		}
692:                 		else
693:                 		{
694:                 			f = b ^ c ^ d;
695:                 			k = 0xCA62C1D6;
696:                 		}
697:                 
698:                 		// Calculate the w[] value and store it in the array for future use
699:                 		if(i >= 16u)
700:                 		{
701:                 			#if defined(HI_TECH_C)
702:                 			// This section is unrolled for HI_TECH_C because it cannot parse
703:                 			// the expression used by the other compilers
704:                 			DWORD temp2;
705:                 			temp = w[back3].Val;
706:                 			temp2 = w[back8].Val;
707:                 			temp ^= temp2;
708:                 			temp2 = w[back14].Val;
709:                 			temp ^= temp2;
710:                 			temp2 = w[i&0x0f].Val;
711:                 			temp ^= temp2;
712:                 			w[i&0x0f].Val = leftRotateDWORD(temp, 1);
713:                 			#else
714:                 			w[i&0x0f].Val = leftRotateDWORD( ( w[back3].Val ^ w[back8].Val ^
715:                 											w[back14].Val ^ w[i&0x0f].Val), 1);
716:                 			#endif
717:                 			back3 += 1;
718:                 			back8 += 1;
719:                 			back14 += 1;
720:                 			back3 &= 0x0f;
721:                 			back8 &= 0x0f;
722:                 			back14 &= 0x0f;
723:                 		}
724:                 		
725:                 		// Calculate the new mixers
726:                 		temp = leftRotateDWORD(a, 5) + f + e + k + w[i & 0x0f].Val;
727:                 		e = d;
728:                 		d = c;
729:                 		c = leftRotateDWORD(b, 30);
730:                 		b = a;
731:                 		a = temp;
732:                 	}
733:                 
734:                 	// Add the new hash to the sum
735:                 	*h0 += a;
736:                 	*h1 += b;
737:                 	*h2 += c;
738:                 	*h3 += d;
739:                 	*h4 += e;
740:                 
741:                 }
742:                 
743:                 /*****************************************************************************
744:                   Function:
745:                 	void SHA1Calculate(HASH_SUM* theSum, BYTE* result)
746:                 
747:                   Summary:
748:                 	Calculates a SHA-1 hash
749:                 
750:                   Description:
751:                 	This function calculates the hash sum of all input data so far.  It is
752:                 	non-destructive to the hash context, so more data may be added after
753:                 	this function is called.
754:                 
755:                   Precondition:
756:                 	The hash context has been properly initialized.
757:                 
758:                   Parameters:
759:                 	theSum - the current hash context
760:                 	result - 20 byte array in which to store the resulting hash
761:                 
762:                   Returns:
763:                   	None
764:                   ***************************************************************************/
765:                 void SHA1Calculate(HASH_SUM* theSum, BYTE* result)
766:                 {
767:                 	DWORD h0, h1, h2, h3, h4;
768:                 	BYTE i, *partPtr, *endPtr;
769:                 
770:                 	// Initialize the hash variables
771:                 	h0 = theSum->h0;
772:                 	h1 = theSum->h1;
773:                 	h2 = theSum->h2;
774:                 	h3 = theSum->h3;
775:                 	h4 = theSum->h4;
776:                 
777:                 	// Find out how far along we are in the partial block and copy to last block
778:                 	partPtr = theSum->partialBlock;
779:                 	endPtr = partPtr + ( theSum->bytesSoFar & 0x3f );
780:                 	for(i = 0; partPtr != endPtr; i++)
781:                 	{
782:                 		lastBlock[i] = *partPtr++;
783:                 	}
784:                 
785:                 	// Add one more bit and 7 zeros
786:                 	lastBlock[i++] = 0x80;
787:                 
788:                 	// If there's 8 or more bytes left to 64, then this is the last block
789:                 	if(i > 56u)
790:                 	{// If there's not enough space, then zero fill this and add a new block
791:                 		// Zero pad the remainder
792:                 		for( ; i < 64u; lastBlock[i++] = 0x00);
793:                 
794:                 		// Calculate a hash on this block and add it to the sum
795:                 		SHA1HashBlock(lastBlock, &h0, &h1, &h2, &h3, &h4);
796:                 
797:                 		//create a new block for the size
798:                 		i = 0;
799:                 	}
800:                 
801:                 	// Zero fill the rest of the block
802:                 	for( ; i < 56u; lastBlock[i++] = 0x00);
803:                 
804:                 	// Fill in the size, in bits, in big-endian
805:                 	lastBlock[63] = theSum->bytesSoFar << 3;
806:                 	lastBlock[62] = theSum->bytesSoFar >> 5;
807:                 	lastBlock[61] = theSum->bytesSoFar >> 13;
808:                 	lastBlock[60] = theSum->bytesSoFar >> 21;
809:                 	lastBlock[59] = theSum->bytesSoFar >> 29;
810:                 	lastBlock[58] = 0;
811:                 	lastBlock[57] = 0;
812:                 	lastBlock[56] = 0;
813:                 
814:                 	// Calculate a hash on this final block and add it to the sum
815:                 	SHA1HashBlock(lastBlock, &h0, &h1, &h2, &h3, &h4);
816:                 	
817:                 	// Format the result in big-endian format
818:                 	*result++ = ((BYTE*)&h0)[3];
819:                 	*result++ = ((BYTE*)&h0)[2];
820:                 	*result++ = ((BYTE*)&h0)[1];
821:                 	*result++ = ((BYTE*)&h0)[0];
822:                 	*result++ = ((BYTE*)&h1)[3];
823:                 	*result++ = ((BYTE*)&h1)[2];
824:                 	*result++ = ((BYTE*)&h1)[1];
825:                 	*result++ = ((BYTE*)&h1)[0];
826:                 	*result++ = ((BYTE*)&h2)[3];
827:                 	*result++ = ((BYTE*)&h2)[2];
828:                 	*result++ = ((BYTE*)&h2)[1];
829:                 	*result++ = ((BYTE*)&h2)[0];
830:                 	*result++ = ((BYTE*)&h3)[3];
831:                 	*result++ = ((BYTE*)&h3)[2];
832:                 	*result++ = ((BYTE*)&h3)[1];
833:                 	*result++ = ((BYTE*)&h3)[0];
834:                 	*result++ = ((BYTE*)&h4)[3];
835:                 	*result++ = ((BYTE*)&h4)[2];
836:                 	*result++ = ((BYTE*)&h4)[1];
837:                 	*result++ = ((BYTE*)&h4)[0];
838:                 }
839:                 
840:                 #endif	//#end SHA-1
---  C:/Users/Diego/Documents/GitHub/pic32webFREERtos/Pic32Web.X/src/tcpip/src/HTTP2.c  -----------------
1:                   /*********************************************************************
2:                    *
3:                    *  HyperText Transfer Protocol (HTTP) Server
4:                    *  Module for Microchip TCP/IP Stack
5:                    *   -Serves dynamic pages to web browsers such as Microsoft Internet 
6:                    *    Explorer, Mozilla Firefox, etc.
7:                    *	 -Reference: RFC 2616
8:                    *
9:                    **********************************************************************
10:                   * FileName:        HTTP2.c
11:                   * Dependencies:    TCP, MPFS2, Tick, CustomHTTPApp.c callbacks
12:                   * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32
13:                   * Compiler:        Microchip C32 v1.05 or higher
14:                   *					Microchip C30 v3.12 or higher
15:                   *					Microchip C18 v3.30 or higher
16:                   *					HI-TECH PICC-18 PRO 9.63PL2 or higher
17:                   * Company:         Microchip Technology, Inc.
18:                   *
19:                   * Software License Agreement
20:                   *
21:                   * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights
22:                   * reserved.
23:                   *
24:                   * Microchip licenses to you the right to use, modify, copy, and
25:                   * distribute:
26:                   * (i)  the Software when embedded on a Microchip microcontroller or
27:                   *      digital signal controller product ("Device") which is
28:                   *      integrated into Licensee's product; or
29:                   * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h,
30:                   *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device
31:                   *		used in conjunction with a Microchip ethernet controller for
32:                   *		the sole purpose of interfacing with the ethernet controller.
33:                   *
34:                   * You should refer to the license agreement accompanying this
35:                   * Software for additional information regarding your rights and
36:                   * obligations.
37:                   *
38:                   * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT
39:                   * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT
40:                   * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A
41:                   * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL
42:                   * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR
43:                   * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF
44:                   * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS
45:                   * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE
46:                   * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER
47:                   * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT
48:                   * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE.
49:                   *
50:                   *
51:                   * Author               Date        Comment
52:                   *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
53:                   * Nilesh Rajbharti     8/14/01     Original
54:                   * Elliott Wood			6/4/07		Complete rewrite, known as HTTP2
55:                   ********************************************************************/
56:                  
57:                  #define __HTTP2_C
58:                  
59:                  #include "TCPIP Stack/TCPIP.h"
60:                  
61:                  #if defined(STACK_USE_HTTP2_SERVER)
62:                  
63:                  #include "HTTPPrint.h"
64:                  
65:                  /****************************************************************************
66:                    Section:
67:                  	String Constants
68:                    ***************************************************************************/
69:                  	static ROM BYTE HTTP_CRLF[] = "\r\n";	// New line sequence
70:                  	#define HTTP_CRLF_LEN	2				// Length of above string
71:                  		
72:                  /****************************************************************************
73:                    Section:
74:                  	File and Content Type Settings
75:                    ***************************************************************************/
76:                  	// File type extensions corresponding to HTTP_FILE_TYPE
77:                  	static ROM char * ROM httpFileExtensions[HTTP_UNKNOWN+1] =
78:                  	{
79:                  	    "txt",          // HTTP_TXT
80:                  	    "htm",          // HTTP_HTM
81:                  	    "html",         // HTTP_HTML
82:                  	    "cgi",          // HTTP_CGI
83:                  	    "xml",          // HTTP_XML
84:                  	    "css",          // HTTP_CSS
85:                  	    "gif",          // HTTP_GIF
86:                  	    "png",          // HTTP_PNG
87:                  	    "jpg",          // HTTP_JPG
88:                  	    "cla",          // HTTP_JAVA
89:                  	    "wav",          // HTTP_WAV
90:                  		"\0\0\0"		// HTTP_UNKNOWN
91:                  	};
92:                  	
93:                  	// Content-type strings corresponding to HTTP_FILE_TYPE
94:                  	static ROM char * ROM httpContentTypes[HTTP_UNKNOWN+1] =
95:                  	{
96:                  	    "text/plain",            // HTTP_TXT
97:                  	    "text/html",             // HTTP_HTM
98:                  	    "text/html",             // HTTP_HTML
99:                  	    "text/html",             // HTTP_CGI
100:                 	    "text/xml",              // HTTP_XML
101:                 	    "text/css",              // HTTP_CSS
102:                 	    "image/gif",             // HTTP_GIF
103:                 	    "image/png",             // HTTP_PNG
104:                 	    "image/jpeg",            // HTTP_JPG
105:                 	    "application/java-vm",   // HTTP_JAVA
106:                 	    "audio/x-wave",          // HTTP_WAV
107:                 		""						 // HTTP_UNKNOWN
108:                 	};
109:                 		
110:                 /****************************************************************************
111:                   Section:
112:                 	Commands and Server Responses
113:                   ***************************************************************************/
114:                 
115:                 	// Initial response strings (Corresponding to HTTP_STATUS)
116:                 	static ROM char * ROM HTTPResponseHeaders[] =
117:                 	{
118:                 		"HTTP/1.1 200 OK\r\nConnection: close\r\n",
119:                 		"HTTP/1.1 200 OK\r\nConnection: close\r\n",
120:                 		"HTTP/1.1 400 Bad Request\r\nConnection: close\r\n\r\n400 Bad Request: can't handle Content-Length\r\n",
121:                 		"HTTP/1.1 401 Unauthorized\r\nWWW-Authenticate: Basic realm=\"Protected\"\r\nConnection: close\r\n\r\n401 Unauthorized: Password required\r\n",
122:                 		#if defined(HTTP_MPFS_UPLOAD)
123:                 		"HTTP/1.1 404 Not found\r\nConnection: close\r\nContent-Type: text/html\r\n\r\n404: File not found<br>Use <a href=\"/" HTTP_MPFS_UPLOAD "\">MPFS Upload</a> to program web pages\r\n",
124:                 		#else		
125:                 		"HTTP/1.1 404 Not found\r\nConnection: close\r\n\r\n404: File not found\r\n",
126:                 		#endif
127:                 		"HTTP/1.1 414 Request-URI Too Long\r\nConnection: close\r\n\r\n414 Request-URI Too Long: Buffer overflow detected\r\n",
128:                 		"HTTP/1.1 500 Internal Server Error\r\nConnection: close\r\n\r\n500 Internal Server Error: Expected data not present\r\n",
129:                 		"HTTP/1.1 501 Not Implemented\r\nConnection: close\r\n\r\n501 Not Implemented: Only GET and POST supported\r\n",
130:                 		#if defined(HTTP_MPFS_UPLOAD)
131:                 		"HTTP/1.1 200 OK\r\nConnection: close\r\nContent-Type: text/html\r\n\r\n<html><body style=\"margin:100px\"><form method=post action=\"/" HTTP_MPFS_UPLOAD "\" enctype=\"multipart/form-data\"><b>MPFS Image Upload</b><p><input type=file name=i size=40> &nbsp; <input type=submit value=\"Upload\"></form></body></html>",
132:                 		"",
133:                 		"HTTP/1.1 200 OK\r\nConnection: close\r\nContent-Type: text/html\r\n\r\n<html><body style=\"margin:100px\"><b>MPFS Update Successful</b><p><a href=\"/\">Site main page</a></body></html>",
134:                 		"HTTP/1.1 500 Internal Server Error\r\nConnection: close\r\nContent-Type: text/html\r\n\r\n<html><body style=\"margin:100px\"><b>MPFS Image Corrupt or Wrong Version</b><p><a href=\"/" HTTP_MPFS_UPLOAD "\">Try again?</a></body></html>",
135:                 		#endif
136:                 		"HTTP/1.1 302 Found\r\nConnection: close\r\nLocation: ",
137:                 		"HTTP/1.1 403 Forbidden\r\nConnection: close\r\n\r\n403 Forbidden: SSL Required - use HTTPS\r\n"
138:                 	};
139:                 	
140:                 /****************************************************************************
141:                   Section:
142:                 	Header Parsing Configuration
143:                   ***************************************************************************/
144:                 	
145:                 	// Header strings for which we'd like to parse
146:                 	static ROM char * ROM HTTPRequestHeaders[] =
147:                 	{
148:                 		"Cookie:",
149:                 		"Authorization:",
150:                 		"Content-Length:"
151:                 	};
152:                 	
153:                 	// Set to length of longest string above
154:                 	#define HTTP_MAX_HEADER_LEN		(15u)
155:                 
156:                 /****************************************************************************
157:                   Section:
158:                 	HTTP Connection State Global Variables
159:                   ***************************************************************************/
160:                 	#if defined(__18CXX) && !defined(HI_TECH_C)	
161:                 		#pragma udata HTTP_CONNECTION_STATES
162:                 	#endif
163:                 	#if defined(HTTP_SAVE_CONTEXT_IN_PIC_RAM)
164:                 		HTTP_CONN					HTTPControlBlocks[MAX_HTTP_CONNECTIONS];
165:                 		#define HTTPLoadConn(a)		do{curHTTPID = (a);}while(0)
166:                 	#else
167:                 		HTTP_CONN curHTTP;							// Current HTTP connection state
168:                 		static void HTTPLoadConn(BYTE hHTTP);
169:                 	#endif
170:                 	HTTP_STUB httpStubs[MAX_HTTP_CONNECTIONS];	// HTTP stubs with state machine and socket
171:                 	BYTE curHTTPID;								// ID of the currently loaded HTTP_CONN
172:                 	#if defined(__18CXX) && !defined(HI_TECH_C)	
173:                 		#pragma udata
174:                 	#endif
175:                 
176:                 /****************************************************************************
177:                   Section:
178:                 	Function Prototypes
179:                   ***************************************************************************/
180:                 	static void HTTPHeaderParseLookup(BYTE i);
181:                 	#if defined(HTTP_USE_COOKIES)
182:                 	static void HTTPHeaderParseCookie(void);
183:                 	#endif
184:                 	#if defined(HTTP_USE_AUTHENTICATION)
185:                 	static void HTTPHeaderParseAuthorization(void);
186:                 	#endif
187:                 	#if defined(HTTP_USE_POST)
188:                 	static void HTTPHeaderParseContentLength(void);
189:                 	static HTTP_READ_STATUS HTTPReadTo(BYTE delim, BYTE* buf, WORD len);
190:                 	#endif
191:                 	
192:                 	static void HTTPProcess(void);
193:                 	static BOOL HTTPSendFile(void);
194:                 
195:                 	#if defined(HTTP_MPFS_UPLOAD)
196:                 	static HTTP_IO_RESULT HTTPMPFSUpload(void);
197:                 	#endif
198:                 
199:                 	#define mMIN(a, b)	((a<b)?a:b)
200:                 	#define smHTTP		httpStubs[curHTTPID].sm			// Access the current state machine
201:                 
202:                 /*****************************************************************************
203:                   Function:
204:                 	void HTTPInit(void)
205:                 
206:                   Summary:
207:                 	Initializes the HTTP server module.
208:                 
209:                   Description:
210:                 	Sets all HTTP sockets to the listening state, and initializes the
211:                 	state machine and file handles for each connection.  If SSL is
212:                 	enabled, opens a socket on that port as well.
213:                 
214:                   Precondition:
215:                 	TCP must already be initialized.
216:                 
217:                   Parameters:
218:                 	None
219:                 
220:                   Returns:
221:                   	None
222:                   	
223:                   Remarks:
224:                 	This function is called only one during lifetime of the application.
225:                   ***************************************************************************/
226:                 void HTTPInit(void)
227:                 {
9D010DE4  27BDFFD8   ADDIU SP, SP, -40
9D010DE8  AFBF0024   SW RA, 36(SP)
9D010DEC  AFBE0020   SW S8, 32(SP)
9D010DF0  AFB0001C   SW S0, 28(SP)
9D010DF4  03A0F021   ADDU S8, SP, ZERO
228:                     for(curHTTPID = 0; curHTTPID < MAX_HTTP_CONNECTIONS; curHTTPID++)
9D010DF8  A38081E8   SB ZERO, -32280(GP)
9D010DFC  0B4043B4   J 0x9D010ED0
9D010E00  00000000   NOP
9D010EC0  938281E8   LBU V0, -32280(GP)
9D010EC4  24420001   ADDIU V0, V0, 1
9D010EC8  304200FF   ANDI V0, V0, 255
9D010ECC  A38281E8   SB V0, -32280(GP)
9D010ED0  938281E8   LBU V0, -32280(GP)
9D010ED4  2C420002   SLTIU V0, V0, 2
9D010ED8  1440FFCA   BNE V0, ZERO, 0x9D010E04
9D010EDC  00000000   NOP
229:                     {
230:                 		smHTTP = SM_HTTP_IDLE;
9D010E04  938281E8   LBU V0, -32280(GP)
9D010E08  00401821   ADDU V1, V0, ZERO
9D010E0C  3C02A000   LUI V0, -24576
9D010E10  000318C0   SLL V1, V1, 3
9D010E14  24420600   ADDIU V0, V0, 1536
9D010E18  00621021   ADDU V0, V1, V0
9D010E1C  AC400000   SW ZERO, 0(V0)
231:                 		sktHTTP = TCPOpen(0, TCP_OPEN_SERVER, HTTP_PORT, TCP_PURPOSE_HTTP_SERVER);
9D010E20  938281E8   LBU V0, -32280(GP)
9D010E24  00408021   ADDU S0, V0, ZERO
9D010E28  00002021   ADDU A0, ZERO, ZERO
9D010E2C  00002821   ADDU A1, ZERO, ZERO
9D010E30  24060050   ADDIU A2, ZERO, 80
9D010E34  24070008   ADDIU A3, ZERO, 8
9D010E38  0F400109   JAL TCPOpen
9D010E3C  00000000   NOP
9D010E40  00401821   ADDU V1, V0, ZERO
9D010E44  3C02A000   LUI V0, -24576
9D010E48  001020C0   SLL A0, S0, 3
9D010E4C  24420600   ADDIU V0, V0, 1536
9D010E50  00821021   ADDU V0, A0, V0
9D010E54  A0430004   SB V1, 4(V0)
232:                 		#if defined(STACK_USE_SSL_SERVER)
233:                 		TCPAddSSLListener(sktHTTP, HTTPS_PORT);
234:                 		#endif
235:                 		
236:                 	    // Save the default record (just invalid file handles)
237:                 		curHTTP.file = MPFS_INVALID_HANDLE;
9D010E58  3C02A000   LUI V0, -24576
9D010E5C  24420574   ADDIU V0, V0, 1396
9D010E60  2403FFFF   ADDIU V1, ZERO, -1
9D010E64  A0430018   SB V1, 24(V0)
238:                 		curHTTP.offsets = MPFS_INVALID_HANDLE;
9D010E68  3C02A000   LUI V0, -24576
9D010E6C  24420574   ADDIU V0, V0, 1396
9D010E70  2403FFFF   ADDIU V1, ZERO, -1
9D010E74  A0430019   SB V1, 25(V0)
239:                 		#if !defined(HTTP_SAVE_CONTEXT_IN_PIC_RAM)
240:                 		{
241:                 			PTR_BASE oldPtr;
242:                 
243:                 			oldPtr = MACSetWritePtr(BASE_HTTPB_ADDR + curHTTPID*sizeof(HTTP_CONN));
9D010E78  938281E8   LBU V0, -32280(GP)
9D010E7C  00401821   ADDU V1, V0, ZERO
9D010E80  2402008C   ADDIU V0, ZERO, 140
9D010E84  70621002   MUL V0, V1, V0
9D010E88  244245EE   ADDIU V0, V0, 17902
9D010E8C  00402021   ADDU A0, V0, ZERO
9D010E90  0F407410   JAL MACSetWritePtr
9D010E94  00000000   NOP
9D010E98  AFC20010   SW V0, 16(S8)
244:                 			MACPutArray((BYTE*)&curHTTP, sizeof(HTTP_CONN));
9D010E9C  3C02A000   LUI V0, -24576
9D010EA0  24420574   ADDIU V0, V0, 1396
9D010EA4  00402021   ADDU A0, V0, ZERO
9D010EA8  2405008C   ADDIU A1, ZERO, 140
9D010EAC  0F40759D   JAL MACPutArray
9D010EB0  00000000   NOP
245:                 			MACSetWritePtr(oldPtr);
9D010EB4  8FC40010   LW A0, 16(S8)
9D010EB8  0F407410   JAL MACSetWritePtr
9D010EBC  00000000   NOP
246:                 		}
247:                 		#endif
248:                     }
249:                 
250:                 	// Set curHTTPID to zero so that first call to HTTPLoadConn() doesn't write 
251:                 	// dummy data outside reserved HTTP memory.
252:                     curHTTPID = 0;	
9D010EE0  A38081E8   SB ZERO, -32280(GP)
253:                 }
9D010EE4  03C0E821   ADDU SP, S8, ZERO
9D010EE8  8FBF0024   LW RA, 36(SP)
9D010EEC  8FBE0020   LW S8, 32(SP)
9D010EF0  8FB0001C   LW S0, 28(SP)
9D010EF4  27BD0028   ADDIU SP, SP, 40
9D010EF8  03E00008   JR RA
9D010EFC  00000000   NOP
254:                 
255:                 
256:                 /*****************************************************************************
257:                   Function:
258:                 	void HTTPServer(void)
259:                 
260:                   Summary:
261:                 	Performs periodic tasks for the HTTP2 module.
262:                 
263:                   Description:
264:                 	Browses through each open connection and attempts to process any
265:                 	pending operations.
266:                 
267:                   Precondition:
268:                 	HTTPInit() must already be called.
269:                 
270:                   Parameters:
271:                 	None
272:                 
273:                   Returns:
274:                   	None
275:                   	
276:                   Remarks:
277:                 	This function acts as a task (similar to one in an RTOS).  It
278:                 	performs its task in a co-operative manner, and the main application
279:                 	must call this function repeatedly to ensure that all open or new
280:                 	connections are served in a timely fashion.
281:                   ***************************************************************************/
282:                 void HTTPServer(void)
283:                 {
9D010F00  27BDFFE0   ADDIU SP, SP, -32
9D010F04  AFBF001C   SW RA, 28(SP)
9D010F08  AFBE0018   SW S8, 24(SP)
9D010F0C  03A0F021   ADDU S8, SP, ZERO
284:                 	BYTE conn;
285:                 
286:                 	for(conn = 0; conn < MAX_HTTP_CONNECTIONS; conn++)
9D010F10  A3C00010   SB ZERO, 16(S8)
9D010F14  0B404432   J 0x9D0110C8
9D010F18  00000000   NOP
9D0110BC  93C20010   LBU V0, 16(S8)
9D0110C0  24420001   ADDIU V0, V0, 1
9D0110C4  A3C20010   SB V0, 16(S8)
9D0110C8  93C20010   LBU V0, 16(S8)
9D0110CC  2C420002   SLTIU V0, V0, 2
9D0110D0  1440FF92   BNE V0, ZERO, 0x9D010F1C
9D0110D4  00000000   NOP
287:                 	{
288:                 		if(httpStubs[conn].socket == INVALID_SOCKET)
9D010F1C  93C30010   LBU V1, 16(S8)
9D010F20  3C02A000   LUI V0, -24576
9D010F24  000318C0   SLL V1, V1, 3
9D010F28  24420600   ADDIU V0, V0, 1536
9D010F2C  00621021   ADDU V0, V1, V0
9D010F30  90430004   LBU V1, 4(V0)
9D010F34  240200FE   ADDIU V0, ZERO, 254
9D010F38  1062005F   BEQ V1, V0, 0x9D0110B8
9D010F3C  00000000   NOP
289:                 			continue;
9D0110B8  00000000   NOP
290:                 		
291:                 		// If a socket is disconnected at any time 
292:                 		// forget about it and return to idle state.
293:                 		// Must do this here, otherwise we will wait until a new
294:                 		// connection arrives, which causes problems with Linux and with SSL
295:                 		if(TCPWasReset(httpStubs[conn].socket))
9D010F40  93C30010   LBU V1, 16(S8)
9D010F44  3C02A000   LUI V0, -24576
9D010F48  000318C0   SLL V1, V1, 3
9D010F4C  24420600   ADDIU V0, V0, 1536
9D010F50  00621021   ADDU V0, V1, V0
9D010F54  90420004   LBU V0, 4(V0)
9D010F58  00402021   ADDU A0, V0, ZERO
9D010F5C  0F400229   JAL TCPWasReset
9D010F60  00000000   NOP
9D010F64  10400039   BEQ V0, ZERO, 0x9D01104C
9D010F68  00000000   NOP
296:                 		{
297:                 			HTTPLoadConn(conn);
9D010F6C  93C20010   LBU V0, 16(S8)
9D010F70  00402021   ADDU A0, V0, ZERO
9D010F74  0F40443C   JAL 0x9D0110F0
9D010F78  00000000   NOP
298:                 			smHTTP = SM_HTTP_IDLE;
9D010F7C  938281E8   LBU V0, -32280(GP)
9D010F80  00401821   ADDU V1, V0, ZERO
9D010F84  3C02A000   LUI V0, -24576
9D010F88  000318C0   SLL V1, V1, 3
9D010F8C  24420600   ADDIU V0, V0, 1536
9D010F90  00621021   ADDU V0, V1, V0
9D010F94  AC400000   SW ZERO, 0(V0)
299:                 
300:                 			// Make sure any opened files are closed
301:                 			if(curHTTP.file != MPFS_INVALID_HANDLE)
9D010F98  3C02A000   LUI V0, -24576
9D010F9C  24420574   ADDIU V0, V0, 1396
9D010FA0  90430018   LBU V1, 24(V0)
9D010FA4  240200FF   ADDIU V0, ZERO, 255
9D010FA8  1062000B   BEQ V1, V0, 0x9D010FD8
9D010FAC  00000000   NOP
302:                 			{
303:                 				MPFSClose(curHTTP.file);
9D010FB0  3C02A000   LUI V0, -24576
9D010FB4  24420574   ADDIU V0, V0, 1396
9D010FB8  90420018   LBU V0, 24(V0)
9D010FBC  00402021   ADDU A0, V0, ZERO
9D010FC0  0F409CA1   JAL MPFSClose
9D010FC4  00000000   NOP
304:                 				curHTTP.file = MPFS_INVALID_HANDLE;
9D010FC8  3C02A000   LUI V0, -24576
9D010FCC  24420574   ADDIU V0, V0, 1396
9D010FD0  2403FFFF   ADDIU V1, ZERO, -1
9D010FD4  A0430018   SB V1, 24(V0)
305:                 			}
306:                 			if(curHTTP.offsets != MPFS_INVALID_HANDLE)
9D010FD8  3C02A000   LUI V0, -24576
9D010FDC  24420574   ADDIU V0, V0, 1396
9D010FE0  90430019   LBU V1, 25(V0)
9D010FE4  240200FF   ADDIU V0, ZERO, 255
9D010FE8  1062000B   BEQ V1, V0, 0x9D011018
9D010FEC  00000000   NOP
307:                 			{
308:                 				MPFSClose(curHTTP.offsets);
9D010FF0  3C02A000   LUI V0, -24576
9D010FF4  24420574   ADDIU V0, V0, 1396
9D010FF8  90420019   LBU V0, 25(V0)
9D010FFC  00402021   ADDU A0, V0, ZERO
9D011000  0F409CA1   JAL MPFSClose
9D011004  00000000   NOP
309:                 				curHTTP.offsets = MPFS_INVALID_HANDLE;
9D011008  3C02A000   LUI V0, -24576
9D01100C  24420574   ADDIU V0, V0, 1396
9D011010  2403FFFF   ADDIU V1, ZERO, -1
9D011014  A0430019   SB V1, 25(V0)
310:                 			}
311:                 
312:                 			// Adjust FIFO sizes to half and half.  Default state must remain
313:                 			// here so that SSL handshakes, if required, can proceed
314:                 			TCPAdjustFIFOSize(sktHTTP, 1, 0, TCP_ADJUST_PRESERVE_RX);
9D011018  938281E8   LBU V0, -32280(GP)
9D01101C  00401821   ADDU V1, V0, ZERO
9D011020  3C02A000   LUI V0, -24576
9D011024  000318C0   SLL V1, V1, 3
9D011028  24420600   ADDIU V0, V0, 1536
9D01102C  00621021   ADDU V0, V1, V0
9D011030  90420004   LBU V0, 4(V0)
9D011034  00402021   ADDU A0, V0, ZERO
9D011038  24050001   ADDIU A1, ZERO, 1
9D01103C  00003021   ADDU A2, ZERO, ZERO
9D011040  24070004   ADDIU A3, ZERO, 4
9D011044  0F401EEC   JAL TCPAdjustFIFOSize
9D011048  00000000   NOP
315:                 		}
316:                 		
317:                 		// Determine if this connection is eligible for processing
318:                 		if(httpStubs[conn].sm != SM_HTTP_IDLE || TCPIsGetReady(httpStubs[conn].socket))
9D01104C  93C30010   LBU V1, 16(S8)
9D011050  3C02A000   LUI V0, -24576
9D011054  000318C0   SLL V1, V1, 3
9D011058  24420600   ADDIU V0, V0, 1536
9D01105C  00621021   ADDU V0, V1, V0
9D011060  8C420000   LW V0, 0(V0)
9D011064  1440000C   BNE V0, ZERO, 0x9D011098
9D011068  00000000   NOP
9D01106C  93C30010   LBU V1, 16(S8)
9D011070  3C02A000   LUI V0, -24576
9D011074  000318C0   SLL V1, V1, 3
9D011078  24420600   ADDIU V0, V0, 1536
9D01107C  00621021   ADDU V0, V1, V0
9D011080  90420004   LBU V0, 4(V0)
9D011084  00402021   ADDU A0, V0, ZERO
9D011088  0F400675   JAL TCPIsGetReady
9D01108C  00000000   NOP
9D011090  1040000A   BEQ V0, ZERO, 0x9D0110BC
9D011094  00000000   NOP
319:                 		{
320:                 			HTTPLoadConn(conn);
9D011098  93C20010   LBU V0, 16(S8)
9D01109C  00402021   ADDU A0, V0, ZERO
9D0110A0  0F40443C   JAL 0x9D0110F0
9D0110A4  00000000   NOP
321:                 			HTTPProcess();
9D0110A8  0F404476   JAL 0x9D0111D8
9D0110AC  00000000   NOP
9D0110B0  0B40442F   J 0x9D0110BC
9D0110B4  00000000   NOP
322:                 		}
323:                 	}
324:                 }
9D0110D8  03C0E821   ADDU SP, S8, ZERO
9D0110DC  8FBF001C   LW RA, 28(SP)
9D0110E0  8FBE0018   LW S8, 24(SP)
9D0110E4  27BD0020   ADDIU SP, SP, 32
9D0110E8  03E00008   JR RA
9D0110EC  00000000   NOP
325:                 
326:                 /*****************************************************************************
327:                   Function:
328:                 	static void HTTPLoadConn(BYTE hHTTP)
329:                 
330:                   Summary:
331:                 	Switches the currently loaded connection for the HTTP2 module.
332:                 
333:                   Description:
334:                 	Saves the currently loaded HTTP connection back to Ethernet buffer
335:                 	RAM, then loads the selected connection into curHTTP in local RAM
336:                 	for processing.
337:                 
338:                   Precondition:
339:                 	None
340:                 
341:                   Parameters:
342:                 	hHTTP - the connection ID to load
343:                 
344:                   Returns:
345:                   	None
346:                   ***************************************************************************/
347:                 #if !defined(HTTP_SAVE_CONTEXT_IN_PIC_RAM)
348:                 static void HTTPLoadConn(BYTE hHTTP)
349:                 {
9D0110F0  27BDFFE0   ADDIU SP, SP, -32
9D0110F4  AFBF001C   SW RA, 28(SP)
9D0110F8  AFBE0018   SW S8, 24(SP)
9D0110FC  03A0F021   ADDU S8, SP, ZERO
9D011100  00801021   ADDU V0, A0, ZERO
9D011104  A3C20020   SB V0, 32(S8)
350:                     WORD oldPtr;
351:                     
352:                     // Return if already loaded
353:                     if(hHTTP == curHTTPID)
9D011108  938281E8   LBU V0, -32280(GP)
9D01110C  93C30020   LBU V1, 32(S8)
9D011110  1062002A   BEQ V1, V0, 0x9D0111BC
9D011114  00000000   NOP
354:                     	return;
9D0111BC  00000000   NOP
355:                     
356:                     // Save the old one
357:                     oldPtr = MACSetWritePtr(BASE_HTTPB_ADDR + curHTTPID*sizeof(HTTP_CONN));
9D011118  938281E8   LBU V0, -32280(GP)
9D01111C  00401821   ADDU V1, V0, ZERO
9D011120  2402008C   ADDIU V0, ZERO, 140
9D011124  70621002   MUL V0, V1, V0
9D011128  244245EE   ADDIU V0, V0, 17902
9D01112C  00402021   ADDU A0, V0, ZERO
9D011130  0F407410   JAL MACSetWritePtr
9D011134  00000000   NOP
9D011138  A7C20010   SH V0, 16(S8)
358:                 	MACPutArray((BYTE*)&curHTTP, sizeof(HTTP_CONN));
9D01113C  3C02A000   LUI V0, -24576
9D011140  24420574   ADDIU V0, V0, 1396
9D011144  00402021   ADDU A0, V0, ZERO
9D011148  2405008C   ADDIU A1, ZERO, 140
9D01114C  0F40759D   JAL MACPutArray
9D011150  00000000   NOP
359:                 	MACSetWritePtr(oldPtr);
9D011154  97C20010   LHU V0, 16(S8)
9D011158  00402021   ADDU A0, V0, ZERO
9D01115C  0F407410   JAL MACSetWritePtr
9D011160  00000000   NOP
360:                 	
361:                 	// Load the new one
362:                     oldPtr = MACSetReadPtr(BASE_HTTPB_ADDR + hHTTP*sizeof(HTTP_CONN));
9D011164  93C30020   LBU V1, 32(S8)
9D011168  2402008C   ADDIU V0, ZERO, 140
9D01116C  70621002   MUL V0, V1, V0
9D011170  244245EE   ADDIU V0, V0, 17902
9D011174  00402021   ADDU A0, V0, ZERO
9D011178  0F407426   JAL MACSetReadPtr
9D01117C  00000000   NOP
9D011180  A7C20010   SH V0, 16(S8)
363:                 	MACGetArray((BYTE*)&curHTTP, sizeof(HTTP_CONN));
9D011184  3C02A000   LUI V0, -24576
9D011188  24420574   ADDIU V0, V0, 1396
9D01118C  00402021   ADDU A0, V0, ZERO
9D011190  2405008C   ADDIU A1, ZERO, 140
9D011194  0F407560   JAL MACGetArray
9D011198  00000000   NOP
364:                 	MACSetReadPtr(oldPtr);
9D01119C  97C20010   LHU V0, 16(S8)
9D0111A0  00402021   ADDU A0, V0, ZERO
9D0111A4  0F407426   JAL MACSetReadPtr
9D0111A8  00000000   NOP
365:                 	
366:                 	// Remember which one is loaded
367:                 	curHTTPID = hHTTP;
9D0111AC  93C20020   LBU V0, 32(S8)
9D0111B0  A38281E8   SB V0, -32280(GP)
9D0111B4  0B404470   J 0x9D0111C0
9D0111B8  00000000   NOP
368:                 			
369:                 }
9D0111C0  03C0E821   ADDU SP, S8, ZERO
9D0111C4  8FBF001C   LW RA, 28(SP)
9D0111C8  8FBE0018   LW S8, 24(SP)
9D0111CC  27BD0020   ADDIU SP, SP, 32
9D0111D0  03E00008   JR RA
9D0111D4  00000000   NOP
370:                 #endif
371:                 
372:                 /*****************************************************************************
373:                   Function:
374:                 	static void HTTPProcess(void)
375:                 
376:                   Description:
377:                 	Performs any pending operations for the currently loaded HTTP connection.
378:                 
379:                   Precondition:
380:                 	HTTPInit() and HTTPLoadConn() have been called.
381:                 
382:                   Parameters:
383:                 	None
384:                 
385:                   Returns:
386:                   	None
387:                   ***************************************************************************/
388:                 static void HTTPProcess(void)
389:                 {
9D0111D8  27BDFFB0   ADDIU SP, SP, -80
9D0111DC  AFBF004C   SW RA, 76(SP)
9D0111E0  AFBE0048   SW S8, 72(SP)
9D0111E4  AFB00044   SW S0, 68(SP)
9D0111E8  03A0F021   ADDU S8, SP, ZERO
390:                     WORD lenA, lenB;
391:                 	BYTE c, i;
392:                     BOOL isDone;
393:                 	BYTE *ext;
394:                 	BYTE buffer[HTTP_MAX_HEADER_LEN+1];
395:                 
396:                     do
397:                     {
398:                         isDone = TRUE;
9D0111EC  24020001   ADDIU V0, ZERO, 1
9D0111F0  AFC20020   SW V0, 32(S8)
399:                 
400:                         switch(smHTTP)
9D0111F4  938281E8   LBU V0, -32280(GP)
9D0111F8  00401821   ADDU V1, V0, ZERO
9D0111FC  3C02A000   LUI V0, -24576
9D011200  000318C0   SLL V1, V1, 3
9D011204  24420600   ADDIU V0, V0, 1536
9D011208  00621021   ADDU V0, V1, V0
9D01120C  8C420000   LW V0, 0(V0)
9D011210  2C43000C   SLTIU V1, V0, 12
9D011214  10600772   BEQ V1, ZERO, 0x9D012FE0
9D011218  00000000   NOP
9D01121C  00021880   SLL V1, V0, 2
9D011220  3C029D01   LUI V0, -25343
9D011224  24421238   ADDIU V0, V0, 4664
9D011228  00621021   ADDU V0, V1, V0
9D01122C  8C420000   LW V0, 0(V0)
9D011230  00400008   JR V0
9D011234  00000000   NOP
401:                         {
402:                 
403:                         case SM_HTTP_IDLE:
404:                 
405:                 			// Check how much data is waiting
406:                 			lenA = TCPIsGetReady(sktHTTP);
9D011268  938281E8   LBU V0, -32280(GP)
9D01126C  00401821   ADDU V1, V0, ZERO
9D011270  3C02A000   LUI V0, -24576
9D011274  000318C0   SLL V1, V1, 3
9D011278  24420600   ADDIU V0, V0, 1536
9D01127C  00621021   ADDU V0, V1, V0
9D011280  90420004   LBU V0, 4(V0)
9D011284  00402021   ADDU A0, V0, ZERO
9D011288  0F400675   JAL TCPIsGetReady
9D01128C  00000000   NOP
9D011290  A7C20018   SH V0, 24(S8)
407:                 
408:                 			// If a connection has been made, then process the request
409:                             if(lenA)
9D011294  97C20018   LHU V0, 24(S8)
9D011298  1040073E   BEQ V0, ZERO, 0x9D012F94
9D01129C  00000000   NOP
410:                             {// Clear out state info and move to next state
411:                 				curHTTP.ptrData = curHTTP.data;
9D0112A0  3C02A000   LUI V0, -24576
9D0112A4  24420574   ADDIU V0, V0, 1396
9D0112A8  3C03A000   LUI V1, -24576
9D0112AC  24630598   ADDIU V1, V1, 1432
9D0112B0  AC430010   SW V1, 16(V0)
412:                 				smHTTP = SM_HTTP_PARSE_REQUEST;
9D0112B4  938281E8   LBU V0, -32280(GP)
9D0112B8  00401821   ADDU V1, V0, ZERO
9D0112BC  3C02A000   LUI V0, -24576
9D0112C0  000318C0   SLL V1, V1, 3
9D0112C4  24420600   ADDIU V0, V0, 1536
9D0112C8  00621021   ADDU V0, V1, V0
9D0112CC  24030001   ADDIU V1, ZERO, 1
9D0112D0  AC430000   SW V1, 0(V0)
413:                 				curHTTP.isAuthorized = 0xff;
9D0112D4  3C02A000   LUI V0, -24576
9D0112D8  24420574   ADDIU V0, V0, 1396
9D0112DC  2403FFFF   ADDIU V1, ZERO, -1
9D0112E0  A043001B   SB V1, 27(V0)
414:                 				curHTTP.hasArgs = FALSE;
9D0112E4  3C02A000   LUI V0, -24576
9D0112E8  24420574   ADDIU V0, V0, 1396
9D0112EC  A040001A   SB ZERO, 26(V0)
415:                 				curHTTP.callbackID = TickGet() + HTTP_TIMEOUT*TICK_SECOND;
9D0112F0  0F40CDD6   JAL TickGet
9D0112F4  00000000   NOP
9D0112F8  00401821   ADDU V1, V0, ZERO
9D0112FC  3C02006B   LUI V0, 107
9D011300  344249D2   ORI V0, V0, 18898
9D011304  00621821   ADDU V1, V1, V0
9D011308  3C02A000   LUI V0, -24576
9D01130C  24420574   ADDIU V0, V0, 1396
9D011310  AC430008   SW V1, 8(V0)
416:                 				curHTTP.callbackPos = 0xffffffff;
9D011314  3C02A000   LUI V0, -24576
9D011318  24420574   ADDIU V0, V0, 1396
9D01131C  2403FFFF   ADDIU V1, ZERO, -1
9D011320  AC43000C   SW V1, 12(V0)
417:                 				curHTTP.byteCount = 0;
9D011324  3C02A000   LUI V0, -24576
9D011328  AC400574   SW ZERO, 1396(V0)
418:                 				#if defined(HTTP_USE_POST)
419:                 				curHTTP.smPost = 0x00;
9D01132C  3C02A000   LUI V0, -24576
9D011330  24420574   ADDIU V0, V0, 1396
9D011334  A0400088   SB ZERO, 136(V0)
420:                 				#endif
421:                 				
422:                 				// Adjust the TCP FIFOs for optimal reception of 
423:                 				// the next HTTP request from the browser
424:                 				TCPAdjustFIFOSize(sktHTTP, 1, 0, TCP_ADJUST_PRESERVE_RX | TCP_ADJUST_GIVE_REST_TO_RX);
9D011338  938281E8   LBU V0, -32280(GP)
9D01133C  00401821   ADDU V1, V0, ZERO
9D011340  3C02A000   LUI V0, -24576
9D011344  000318C0   SLL V1, V1, 3
9D011348  24420600   ADDIU V0, V0, 1536
9D01134C  00621021   ADDU V0, V1, V0
9D011350  90420004   LBU V0, 4(V0)
9D011354  00402021   ADDU A0, V0, ZERO
9D011358  24050001   ADDIU A1, ZERO, 1
9D01135C  00003021   ADDU A2, ZERO, ZERO
9D011360  24070005   ADDIU A3, ZERO, 5
9D011364  0F401EEC   JAL TCPAdjustFIFOSize
9D011368  00000000   NOP
425:                  			}
426:                  			else
427:                  				// Don't break for new connections.  There may be 
428:                  				// an entire request in the buffer already.
429:                  				break;
9D012F94  00000000   NOP
9D012F98  0B404BF8   J 0x9D012FE0
9D012F9C  00000000   NOP
430:                 
431:                 		case SM_HTTP_PARSE_REQUEST:
432:                 
433:                 			// Verify the entire first line is in the FIFO
434:                 			if(TCPFind(sktHTTP, '\n', 0, FALSE) == 0xffff)
9D01136C  938281E8   LBU V0, -32280(GP)
9D011370  00401821   ADDU V1, V0, ZERO
9D011374  3C02A000   LUI V0, -24576
9D011378  000318C0   SLL V1, V1, 3
9D01137C  24420600   ADDIU V0, V0, 1536
9D011380  00621021   ADDU V0, V1, V0
9D011384  90420004   LBU V0, 4(V0)
9D011388  AFA00010   SW ZERO, 16(SP)
9D01138C  00402021   ADDU A0, V0, ZERO
9D011390  2405000A   ADDIU A1, ZERO, 10
9D011394  00003021   ADDU A2, ZERO, ZERO
9D011398  00003821   ADDU A3, ZERO, ZERO
9D01139C  0F400AEB   JAL TCPFindEx
9D0113A0  00000000   NOP
9D0113A4  00401821   ADDU V1, V0, ZERO
9D0113A8  3402FFFF   ORI V0, ZERO, -1
9D0113AC  14620038   BNE V1, V0, 0x9D011490
9D0113B0  00000000   NOP
435:                 			{// First line isn't here yet
436:                 				if(TCPGetRxFIFOFree(sktHTTP) == 0u)
9D0113B4  938281E8   LBU V0, -32280(GP)
9D0113B8  00401821   ADDU V1, V0, ZERO
9D0113BC  3C02A000   LUI V0, -24576
9D0113C0  000318C0   SLL V1, V1, 3
9D0113C4  24420600   ADDIU V0, V0, 1536
9D0113C8  00621021   ADDU V0, V1, V0
9D0113CC  90420004   LBU V0, 4(V0)
9D0113D0  00402021   ADDU A0, V0, ZERO
9D0113D4  0F400868   JAL TCPGetRxFIFOFree
9D0113D8  00000000   NOP
9D0113DC  1440000E   BNE V0, ZERO, 0x9D011418
9D0113E0  00000000   NOP
437:                 				{// If the FIFO is full, we overflowed
438:                 					curHTTP.httpStatus = HTTP_OVERFLOW;
9D0113E4  3C02A000   LUI V0, -24576
9D0113E8  24420574   ADDIU V0, V0, 1396
9D0113EC  24030005   ADDIU V1, ZERO, 5
9D0113F0  AC43001C   SW V1, 28(V0)
439:                 					smHTTP = SM_HTTP_SERVE_HEADERS;
9D0113F4  938281E8   LBU V0, -32280(GP)
9D0113F8  00401821   ADDU V1, V0, ZERO
9D0113FC  3C02A000   LUI V0, -24576
9D011400  000318C0   SLL V1, V1, 3
9D011404  24420600   ADDIU V0, V0, 1536
9D011408  00621021   ADDU V0, V1, V0
9D01140C  24030007   ADDIU V1, ZERO, 7
9D011410  AC430000   SW V1, 0(V0)
440:                 					isDone = FALSE;
9D011414  AFC00020   SW ZERO, 32(S8)
441:                 				}
442:                 				if((LONG)(TickGet() - curHTTP.callbackID) > (LONG)0)
9D011418  0F40CDD6   JAL TickGet
9D01141C  00000000   NOP
9D011420  00401821   ADDU V1, V0, ZERO
9D011424  3C02A000   LUI V0, -24576
9D011428  24420574   ADDIU V0, V0, 1396
9D01142C  8C420008   LW V0, 8(V0)
9D011430  00621023   SUBU V0, V1, V0
9D011434  184006DA   BLEZ V0, 0x9D012FA0
9D011438  00000000   NOP
443:                 				{// A timeout has occurred
444:                 					TCPDisconnect(sktHTTP);
9D01143C  938281E8   LBU V0, -32280(GP)
9D011440  00401821   ADDU V1, V0, ZERO
9D011444  3C02A000   LUI V0, -24576
9D011448  000318C0   SLL V1, V1, 3
9D01144C  24420600   ADDIU V0, V0, 1536
9D011450  00621021   ADDU V0, V1, V0
9D011454  90420004   LBU V0, 4(V0)
9D011458  00402021   ADDU A0, V0, ZERO
9D01145C  0F400273   JAL TCPDisconnect
9D011460  00000000   NOP
445:                 					smHTTP = SM_HTTP_DISCONNECT;
9D011464  938281E8   LBU V0, -32280(GP)
9D011468  00401821   ADDU V1, V0, ZERO
9D01146C  3C02A000   LUI V0, -24576
9D011470  000318C0   SLL V1, V1, 3
9D011474  24420600   ADDIU V0, V0, 1536
9D011478  00621021   ADDU V0, V1, V0
9D01147C  2403000B   ADDIU V1, ZERO, 11
9D011480  AC430000   SW V1, 0(V0)
446:                 					isDone = FALSE;
9D011484  AFC00020   SW ZERO, 32(S8)
447:                 				}
448:                 				break;
9D011488  0B404BF8   J 0x9D012FE0
9D01148C  00000000   NOP
9D012FA0  00000000   NOP
9D012FA4  0B404BF8   J 0x9D012FE0
9D012FA8  00000000   NOP
449:                 			}
450:                 
451:                 			// Reset the watchdog timer
452:                 			curHTTP.callbackID = TickGet() + HTTP_TIMEOUT*TICK_SECOND;
9D011490  0F40CDD6   JAL TickGet
9D011494  00000000   NOP
9D011498  00401821   ADDU V1, V0, ZERO
9D01149C  3C02006B   LUI V0, 107
9D0114A0  344249D2   ORI V0, V0, 18898
9D0114A4  00621821   ADDU V1, V1, V0
9D0114A8  3C02A000   LUI V0, -24576
9D0114AC  24420574   ADDIU V0, V0, 1396
9D0114B0  AC430008   SW V1, 8(V0)
453:                 
454:                 			// Determine the request method
455:                 			lenA = TCPFind(sktHTTP, ' ', 0, FALSE);
9D0114B4  938281E8   LBU V0, -32280(GP)
9D0114B8  00401821   ADDU V1, V0, ZERO
9D0114BC  3C02A000   LUI V0, -24576
9D0114C0  000318C0   SLL V1, V1, 3
9D0114C4  24420600   ADDIU V0, V0, 1536
9D0114C8  00621021   ADDU V0, V1, V0
9D0114CC  90420004   LBU V0, 4(V0)
9D0114D0  AFA00010   SW ZERO, 16(SP)
9D0114D4  00402021   ADDU A0, V0, ZERO
9D0114D8  24050020   ADDIU A1, ZERO, 32
9D0114DC  00003021   ADDU A2, ZERO, ZERO
9D0114E0  00003821   ADDU A3, ZERO, ZERO
9D0114E4  0F400AEB   JAL TCPFindEx
9D0114E8  00000000   NOP
9D0114EC  A7C20018   SH V0, 24(S8)
456:                 			if(lenA > 5u)
9D0114F0  97C20018   LHU V0, 24(S8)
9D0114F4  2C420006   SLTIU V0, V0, 6
9D0114F8  14400003   BNE V0, ZERO, 0x9D011508
9D0114FC  00000000   NOP
457:                 				lenA = 5;
9D011500  24020005   ADDIU V0, ZERO, 5
9D011504  A7C20018   SH V0, 24(S8)
458:                 			TCPGetArray(sktHTTP, curHTTP.data, lenA+1);
9D011508  938281E8   LBU V0, -32280(GP)
9D01150C  00401821   ADDU V1, V0, ZERO
9D011510  3C02A000   LUI V0, -24576
9D011514  000318C0   SLL V1, V1, 3
9D011518  24420600   ADDIU V0, V0, 1536
9D01151C  00621021   ADDU V0, V1, V0
9D011520  90420004   LBU V0, 4(V0)
9D011524  00401821   ADDU V1, V0, ZERO
9D011528  97C20018   LHU V0, 24(S8)
9D01152C  24420001   ADDIU V0, V0, 1
9D011530  3042FFFF   ANDI V0, V0, -1
9D011534  00602021   ADDU A0, V1, ZERO
9D011538  3C03A000   LUI V1, -24576
9D01153C  24650598   ADDIU A1, V1, 1432
9D011540  00403021   ADDU A2, V0, ZERO
9D011544  0F40077A   JAL TCPGetArray
9D011548  00000000   NOP
459:                 
460:                 		    if ( memcmppgm2ram(curHTTP.data, (ROM void*)"GET", 3) == 0)
9D01154C  3C02A000   LUI V0, -24576
9D011550  24440598   ADDIU A0, V0, 1432
9D011554  3C029D03   LUI V0, -25341
9D011558  24451440   ADDIU A1, V0, 5184
9D01155C  24060003   ADDIU A2, ZERO, 3
9D011560  0F40D6D9   JAL 0x9D035B64
9D011564  00000000   NOP
9D011568  14400006   BNE V0, ZERO, 0x9D011584
9D01156C  00000000   NOP
461:                 			    curHTTP.httpStatus = HTTP_GET;
9D011570  3C02A000   LUI V0, -24576
9D011574  24420574   ADDIU V0, V0, 1396
9D011578  AC40001C   SW ZERO, 28(V0)
9D01157C  0B40457F   J 0x9D0115FC
9D011580  00000000   NOP
462:                 			#if defined(HTTP_USE_POST)
463:                 		    else if ( memcmppgm2ram(curHTTP.data, (ROM void*)"POST", 4) == 0)
9D011584  3C02A000   LUI V0, -24576
9D011588  24440598   ADDIU A0, V0, 1432
9D01158C  3C029D03   LUI V0, -25341
9D011590  24451444   ADDIU A1, V0, 5188
9D011594  24060004   ADDIU A2, ZERO, 4
9D011598  0F40D6D9   JAL 0x9D035B64
9D01159C  00000000   NOP
9D0115A0  14400007   BNE V0, ZERO, 0x9D0115C0
9D0115A4  00000000   NOP
464:                 			    curHTTP.httpStatus = HTTP_POST;
9D0115A8  3C02A000   LUI V0, -24576
9D0115AC  24420574   ADDIU V0, V0, 1396
9D0115B0  24030001   ADDIU V1, ZERO, 1
9D0115B4  AC43001C   SW V1, 28(V0)
9D0115B8  0B40457F   J 0x9D0115FC
9D0115BC  00000000   NOP
465:                 			#endif
466:                 		    else
467:                 			{// Unrecognized method, so return not implemented
468:                 		        curHTTP.httpStatus = HTTP_NOT_IMPLEMENTED;
9D0115C0  3C02A000   LUI V0, -24576
9D0115C4  24420574   ADDIU V0, V0, 1396
9D0115C8  24030007   ADDIU V1, ZERO, 7
9D0115CC  AC43001C   SW V1, 28(V0)
469:                 				smHTTP = SM_HTTP_SERVE_HEADERS;
9D0115D0  938281E8   LBU V0, -32280(GP)
9D0115D4  00401821   ADDU V1, V0, ZERO
9D0115D8  3C02A000   LUI V0, -24576
9D0115DC  000318C0   SLL V1, V1, 3
9D0115E0  24420600   ADDIU V0, V0, 1536
9D0115E4  00621021   ADDU V0, V1, V0
9D0115E8  24030007   ADDIU V1, ZERO, 7
9D0115EC  AC430000   SW V1, 0(V0)
470:                 				isDone = FALSE;
9D0115F0  AFC00020   SW ZERO, 32(S8)
471:                 				break;
9D0115F4  0B404BF8   J 0x9D012FE0
9D0115F8  00000000   NOP
472:                 			}
473:                 
474:                 			// Find end of filename
475:                 			lenA = TCPFind(sktHTTP, ' ', 0, FALSE);
9D0115FC  938281E8   LBU V0, -32280(GP)
9D011600  00401821   ADDU V1, V0, ZERO
9D011604  3C02A000   LUI V0, -24576
9D011608  000318C0   SLL V1, V1, 3
9D01160C  24420600   ADDIU V0, V0, 1536
9D011610  00621021   ADDU V0, V1, V0
9D011614  90420004   LBU V0, 4(V0)
9D011618  AFA00010   SW ZERO, 16(SP)
9D01161C  00402021   ADDU A0, V0, ZERO
9D011620  24050020   ADDIU A1, ZERO, 32
9D011624  00003021   ADDU A2, ZERO, ZERO
9D011628  00003821   ADDU A3, ZERO, ZERO
9D01162C  0F400AEB   JAL TCPFindEx
9D011630  00000000   NOP
9D011634  A7C20018   SH V0, 24(S8)
476:                 			lenB = TCPFindEx(sktHTTP, '?', 0, lenA, FALSE);
9D011638  938281E8   LBU V0, -32280(GP)
9D01163C  00401821   ADDU V1, V0, ZERO
9D011640  3C02A000   LUI V0, -24576
9D011644  000318C0   SLL V1, V1, 3
9D011648  24420600   ADDIU V0, V0, 1536
9D01164C  00621021   ADDU V0, V1, V0
9D011650  90420004   LBU V0, 4(V0)
9D011654  00401821   ADDU V1, V0, ZERO
9D011658  97C20018   LHU V0, 24(S8)
9D01165C  AFA00010   SW ZERO, 16(SP)
9D011660  00602021   ADDU A0, V1, ZERO
9D011664  2405003F   ADDIU A1, ZERO, 63
9D011668  00003021   ADDU A2, ZERO, ZERO
9D01166C  00403821   ADDU A3, V0, ZERO
9D011670  0F400AEB   JAL TCPFindEx
9D011674  00000000   NOP
9D011678  A7C2001A   SH V0, 26(S8)
477:                 			lenA = mMIN(lenA, lenB);
9D01167C  97C30018   LHU V1, 24(S8)
9D011680  97C2001A   LHU V0, 26(S8)
9D011684  3045FFFF   ANDI A1, V0, -1
9D011688  3064FFFF   ANDI A0, V1, -1
9D01168C  0085202B   SLTU A0, A0, A1
9D011690  10800002   BEQ A0, ZERO, 0x9D01169C
9D011694  00000000   NOP
9D011698  00601021   ADDU V0, V1, ZERO
9D01169C  A7C20018   SH V0, 24(S8)
478:                 			
479:                 			// If the file name is too long, then reject the request
480:                 			if(lenA > HTTP_MAX_DATA_LEN - HTTP_DEFAULT_LEN - 1)
9D0116A0  97C20018   LHU V0, 24(S8)
9D0116A4  2C42005A   SLTIU V0, V0, 90
9D0116A8  14400010   BNE V0, ZERO, 0x9D0116EC
9D0116AC  00000000   NOP
481:                 			{
482:                 				curHTTP.httpStatus = HTTP_OVERFLOW;
9D0116B0  3C02A000   LUI V0, -24576
9D0116B4  24420574   ADDIU V0, V0, 1396
9D0116B8  24030005   ADDIU V1, ZERO, 5
9D0116BC  AC43001C   SW V1, 28(V0)
483:                 				smHTTP = SM_HTTP_SERVE_HEADERS;
9D0116C0  938281E8   LBU V0, -32280(GP)
9D0116C4  00401821   ADDU V1, V0, ZERO
9D0116C8  3C02A000   LUI V0, -24576
9D0116CC  000318C0   SLL V1, V1, 3
9D0116D0  24420600   ADDIU V0, V0, 1536
9D0116D4  00621021   ADDU V0, V1, V0
9D0116D8  24030007   ADDIU V1, ZERO, 7
9D0116DC  AC430000   SW V1, 0(V0)
484:                 				isDone = FALSE;
9D0116E0  AFC00020   SW ZERO, 32(S8)
485:                 				break;
9D0116E4  0B404BF8   J 0x9D012FE0
9D0116E8  00000000   NOP
486:                 			}
487:                 
488:                 			// Read in the filename and decode
489:                 			lenB = TCPGetArray(sktHTTP, curHTTP.data, lenA);
9D0116EC  938281E8   LBU V0, -32280(GP)
9D0116F0  00401821   ADDU V1, V0, ZERO
9D0116F4  3C02A000   LUI V0, -24576
9D0116F8  000318C0   SLL V1, V1, 3
9D0116FC  24420600   ADDIU V0, V0, 1536
9D011700  00621021   ADDU V0, V1, V0
9D011704  90420004   LBU V0, 4(V0)
9D011708  00401821   ADDU V1, V0, ZERO
9D01170C  97C20018   LHU V0, 24(S8)
9D011710  00602021   ADDU A0, V1, ZERO
9D011714  3C03A000   LUI V1, -24576
9D011718  24650598   ADDIU A1, V1, 1432
9D01171C  00403021   ADDU A2, V0, ZERO
9D011720  0F40077A   JAL TCPGetArray
9D011724  00000000   NOP
9D011728  A7C2001A   SH V0, 26(S8)
490:                 			curHTTP.data[lenB] = '\0';
9D01172C  97C3001A   LHU V1, 26(S8)
9D011730  3C02A000   LUI V0, -24576
9D011734  24420574   ADDIU V0, V0, 1396
9D011738  00621021   ADDU V0, V1, V0
9D01173C  A0400024   SB ZERO, 36(V0)
491:                 			HTTPURLDecode(curHTTP.data);
9D011740  3C02A000   LUI V0, -24576
9D011744  24440598   ADDIU A0, V0, 1432
9D011748  0F404E46   JAL HTTPURLDecode
9D01174C  00000000   NOP
492:                 
493:                 			// Decode may have changed the string length - update it here
494:                 			lenB = strlen((char*)curHTTP.data);
9D011750  3C02A000   LUI V0, -24576
9D011754  24420598   ADDIU V0, V0, 1432
9D011758  00402021   ADDU A0, V0, ZERO
9D01175C  0F40D2F2   JAL 0x9D034BC8
9D011760  00000000   NOP
9D011764  A7C2001A   SH V0, 26(S8)
495:                 
496:                 			// Check if this is an MPFS Upload
497:                 			#if defined(HTTP_MPFS_UPLOAD)
498:                 			if(memcmppgm2ram(&curHTTP.data[1], HTTP_MPFS_UPLOAD, sizeof(HTTP_MPFS_UPLOAD)) == 0)
499:                 			{// Read remainder of line, and bypass all file opening, etc.
500:                 				#if defined(HTTP_USE_AUTHENTICATION)
501:                 				curHTTP.isAuthorized = HTTPNeedsAuth(&curHTTP.data[1]);
502:                 				#endif
503:                 				if(curHTTP.httpStatus == HTTP_GET)
504:                 					curHTTP.httpStatus = HTTP_MPFS_FORM;
505:                 				else
506:                 					curHTTP.httpStatus = HTTP_MPFS_UP;
507:                 
508:                 				smHTTP = SM_HTTP_PARSE_HEADERS;
509:                 				isDone = FALSE;
510:                 				break;
511:                 			}
512:                 			#endif
513:                 			
514:                 			// If the last character is a not a directory delimiter, then try to open the file
515:                 			// String starts at 2nd character, because the first is always a '/'
516:                 			if(curHTTP.data[lenB-1] != '/')
9D011768  97C2001A   LHU V0, 26(S8)
9D01176C  2443FFFF   ADDIU V1, V0, -1
9D011770  3C02A000   LUI V0, -24576
9D011774  24420574   ADDIU V0, V0, 1396
9D011778  00621021   ADDU V0, V1, V0
9D01177C  90430024   LBU V1, 36(V0)
9D011780  2402002F   ADDIU V0, ZERO, 47
9D011784  10620009   BEQ V1, V0, 0x9D0117AC
9D011788  00000000   NOP
517:                 				curHTTP.file = MPFSOpen(&curHTTP.data[1]);
9D01178C  3C02A000   LUI V0, -24576
9D011790  24440599   ADDIU A0, V0, 1433
9D011794  0F409B86   JAL MPFSOpen
9D011798  00000000   NOP
9D01179C  00401821   ADDU V1, V0, ZERO
9D0117A0  3C02A000   LUI V0, -24576
9D0117A4  24420574   ADDIU V0, V0, 1396
9D0117A8  A0430018   SB V1, 24(V0)
518:                 				
519:                 			// If the open fails, then add our default name and try again
520:                 			if(curHTTP.file == MPFS_INVALID_HANDLE)
9D0117AC  3C02A000   LUI V0, -24576
9D0117B0  24420574   ADDIU V0, V0, 1396
9D0117B4  90430018   LBU V1, 24(V0)
9D0117B8  240200FF   ADDIU V0, ZERO, 255
9D0117BC  14620028   BNE V1, V0, 0x9D011860
9D0117C0  00000000   NOP
521:                 			{
522:                 				// Add the directory delimiter if needed
523:                 				if(curHTTP.data[lenB-1] != '/')
9D0117C4  97C2001A   LHU V0, 26(S8)
9D0117C8  2443FFFF   ADDIU V1, V0, -1
9D0117CC  3C02A000   LUI V0, -24576
9D0117D0  24420574   ADDIU V0, V0, 1396
9D0117D4  00621021   ADDU V0, V1, V0
9D0117D8  90430024   LBU V1, 36(V0)
9D0117DC  2402002F   ADDIU V0, ZERO, 47
9D0117E0  1062000A   BEQ V1, V0, 0x9D01180C
9D0117E4  00000000   NOP
524:                 					curHTTP.data[lenB++] = '/';
9D0117E8  97C3001A   LHU V1, 26(S8)
9D0117EC  3C02A000   LUI V0, -24576
9D0117F0  24420574   ADDIU V0, V0, 1396
9D0117F4  00621021   ADDU V0, V1, V0
9D0117F8  2403002F   ADDIU V1, ZERO, 47
9D0117FC  A0430024   SB V1, 36(V0)
9D011800  97C2001A   LHU V0, 26(S8)
9D011804  24420001   ADDIU V0, V0, 1
9D011808  A7C2001A   SH V0, 26(S8)
525:                 				
526:                 				// Add our default file name			
527:                 				#if defined(STACK_USE_SSL_SERVER)
528:                 				if(TCPIsSSL(sktHTTP))
529:                 				{
530:                 					strcpypgm2ram((void*)&curHTTP.data[lenB], HTTPS_DEFAULT_FILE);
531:                 					lenB += strlenpgm(HTTPS_DEFAULT_FILE);
532:                 				}
533:                 				else
534:                 				#endif
535:                 				{
536:                 					strcpypgm2ram((void*)&curHTTP.data[lenB], HTTP_DEFAULT_FILE);
9D01180C  3C02A000   LUI V0, -24576
9D011810  24430598   ADDIU V1, V0, 1432
9D011814  97C2001A   LHU V0, 26(S8)
9D011818  00621021   ADDU V0, V1, V0
9D01181C  00402021   ADDU A0, V0, ZERO
9D011820  3C029D03   LUI V0, -25341
9D011824  2445144C   ADDIU A1, V0, 5196
9D011828  2406000A   ADDIU A2, ZERO, 10
9D01182C  0F40D298   JAL 0x9D034A60
9D011830  00000000   NOP
537:                 					lenB += strlenpgm(HTTP_DEFAULT_FILE);
9D011834  97C2001A   LHU V0, 26(S8)
9D011838  24420009   ADDIU V0, V0, 9
9D01183C  A7C2001A   SH V0, 26(S8)
538:                 				}
539:                 					
540:                 				// Try to open again
541:                 				curHTTP.file = MPFSOpen(&curHTTP.data[1]);
9D011840  3C02A000   LUI V0, -24576
9D011844  24440599   ADDIU A0, V0, 1433
9D011848  0F409B86   JAL MPFSOpen
9D01184C  00000000   NOP
9D011850  00401821   ADDU V1, V0, ZERO
9D011854  3C02A000   LUI V0, -24576
9D011858  24420574   ADDIU V0, V0, 1396
9D01185C  A0430018   SB V1, 24(V0)
542:                 			}
543:                 			
544:                 			// Find the extension in the filename
545:                 			for(ext = curHTTP.data + lenB-1; ext != curHTTP.data; ext--)
9D011860  97C2001A   LHU V0, 26(S8)
9D011864  2443FFFF   ADDIU V1, V0, -1
9D011868  3C02A000   LUI V0, -24576
9D01186C  24420598   ADDIU V0, V0, 1432
9D011870  00621021   ADDU V0, V1, V0
9D011874  AFC20024   SW V0, 36(S8)
9D011878  0B404628   J 0x9D0118A0
9D01187C  00000000   NOP
9D011894  8FC20024   LW V0, 36(S8)
9D011898  2442FFFF   ADDIU V0, V0, -1
9D01189C  AFC20024   SW V0, 36(S8)
9D0118A0  8FC30024   LW V1, 36(S8)
9D0118A4  3C02A000   LUI V0, -24576
9D0118A8  24420598   ADDIU V0, V0, 1432
9D0118AC  1462FFF4   BNE V1, V0, 0x9D011880
9D0118B0  00000000   NOP
9D0118B4  0B404630   J 0x9D0118C0
9D0118B8  00000000   NOP
546:                 				if(*ext == '.')
9D011880  8FC20024   LW V0, 36(S8)
9D011884  90430000   LBU V1, 0(V0)
9D011888  2402002E   ADDIU V0, ZERO, 46
9D01188C  1062000B   BEQ V1, V0, 0x9D0118BC
9D011890  00000000   NOP
547:                 					break;
9D0118BC  00000000   NOP
548:                 					
549:                 			// Compare to known extensions to determine Content-Type
550:                 			ext++;
9D0118C0  8FC20024   LW V0, 36(S8)
9D0118C4  24420001   ADDIU V0, V0, 1
9D0118C8  AFC20024   SW V0, 36(S8)
551:                 			for(curHTTP.fileType = HTTP_TXT; curHTTP.fileType < HTTP_UNKNOWN; curHTTP.fileType++)
9D0118CC  3C02A000   LUI V0, -24576
9D0118D0  24420574   ADDIU V0, V0, 1396
9D0118D4  AC400020   SW ZERO, 32(V0)
9D0118D8  0B40464D   J 0x9D011934
9D0118DC  00000000   NOP
9D011918  3C02A000   LUI V0, -24576
9D01191C  24420574   ADDIU V0, V0, 1396
9D011920  8C420020   LW V0, 32(V0)
9D011924  24430001   ADDIU V1, V0, 1
9D011928  3C02A000   LUI V0, -24576
9D01192C  24420574   ADDIU V0, V0, 1396
9D011930  AC430020   SW V1, 32(V0)
9D011934  3C02A000   LUI V0, -24576
9D011938  24420574   ADDIU V0, V0, 1396
9D01193C  8C420020   LW V0, 32(V0)
9D011940  2C42000B   SLTIU V0, V0, 11
9D011944  1440FFE6   BNE V0, ZERO, 0x9D0118E0
9D011948  00000000   NOP
9D01194C  0B404656   J 0x9D011958
9D011950  00000000   NOP
552:                 				if(!stricmppgm2ram(ext, (ROM void*)httpFileExtensions[curHTTP.fileType]))
9D0118E0  3C02A000   LUI V0, -24576
9D0118E4  24420574   ADDIU V0, V0, 1396
9D0118E8  8C430020   LW V1, 32(V0)
9D0118EC  3C029D03   LUI V0, -25341
9D0118F0  00031880   SLL V1, V1, 2
9D0118F4  24420FE4   ADDIU V0, V0, 4068
9D0118F8  00621021   ADDU V0, V1, V0
9D0118FC  8C420000   LW V0, 0(V0)
9D011900  8FC40024   LW A0, 36(S8)
9D011904  00402821   ADDU A1, V0, ZERO
9D011908  0F4099BB   JAL stricmppgm2ram
9D01190C  00000000   NOP
9D011910  10400010   BEQ V0, ZERO, 0x9D011954
9D011914  00000000   NOP
553:                 					break;
9D011954  00000000   NOP
554:                 			
555:                 			// Perform first round authentication (pass file name only)
556:                 			#if defined(HTTP_USE_AUTHENTICATION)
557:                 			curHTTP.isAuthorized = HTTPNeedsAuth(&curHTTP.data[1]);
9D011958  3C02A000   LUI V0, -24576
9D01195C  24440599   ADDIU A0, V0, 1433
9D011960  0F4050A8   JAL HTTPNeedsAuth
9D011964  00000000   NOP
9D011968  00401821   ADDU V1, V0, ZERO
9D01196C  3C02A000   LUI V0, -24576
9D011970  24420574   ADDIU V0, V0, 1396
9D011974  A043001B   SB V1, 27(V0)
558:                 			#endif
559:                 			
560:                 			// If the file was found, see if it has an index
561:                 			if(curHTTP.file != MPFS_INVALID_HANDLE &&
9D011978  3C02A000   LUI V0, -24576
9D01197C  24420574   ADDIU V0, V0, 1396
9D011980  90430018   LBU V1, 24(V0)
9D011984  240200FF   ADDIU V0, ZERO, 255
9D011988  10620019   BEQ V1, V0, 0x9D0119F0
9D01198C  00000000   NOP
9D0119AC  10400010   BEQ V0, ZERO, 0x9D0119F0
9D0119B0  00000000   NOP
562:                 				(MPFSGetFlags(curHTTP.file) & MPFS2_FLAG_HASINDEX) )
9D011990  3C02A000   LUI V0, -24576
9D011994  24420574   ADDIU V0, V0, 1396
9D011998  90420018   LBU V0, 24(V0)
9D01199C  00402021   ADDU A0, V0, ZERO
9D0119A0  0F409F50   JAL MPFSGetFlags
9D0119A4  00000000   NOP
9D0119A8  30420002   ANDI V0, V0, 2
563:                 			{
564:                 				curHTTP.offsets = MPFSOpenID(MPFSGetID(curHTTP.file) + 1);
9D0119B4  3C02A000   LUI V0, -24576
9D0119B8  24420574   ADDIU V0, V0, 1396
9D0119BC  90420018   LBU V0, 24(V0)
9D0119C0  00402021   ADDU A0, V0, ZERO
9D0119C4  0F40A085   JAL MPFSGetID
9D0119C8  00000000   NOP
9D0119CC  24420001   ADDIU V0, V0, 1
9D0119D0  3042FFFF   ANDI V0, V0, -1
9D0119D4  00402021   ADDU A0, V0, ZERO
9D0119D8  0F409C49   JAL MPFSOpenID
9D0119DC  00000000   NOP
9D0119E0  00401821   ADDU V1, V0, ZERO
9D0119E4  3C02A000   LUI V0, -24576
9D0119E8  24420574   ADDIU V0, V0, 1396
9D0119EC  A0430019   SB V1, 25(V0)
565:                 			}
566:                 
567:                 			// Read GET args, up to buffer size - 1
568:                 			lenA = TCPFind(sktHTTP, ' ', 0, FALSE);
9D0119F0  938281E8   LBU V0, -32280(GP)
9D0119F4  00401821   ADDU V1, V0, ZERO
9D0119F8  3C02A000   LUI V0, -24576
9D0119FC  000318C0   SLL V1, V1, 3
9D011A00  24420600   ADDIU V0, V0, 1536
9D011A04  00621021   ADDU V0, V1, V0
9D011A08  90420004   LBU V0, 4(V0)
9D011A0C  AFA00010   SW ZERO, 16(SP)
9D011A10  00402021   ADDU A0, V0, ZERO
9D011A14  24050020   ADDIU A1, ZERO, 32
9D011A18  00003021   ADDU A2, ZERO, ZERO
9D011A1C  00003821   ADDU A3, ZERO, ZERO
9D011A20  0F400AEB   JAL TCPFindEx
9D011A24  00000000   NOP
9D011A28  A7C20018   SH V0, 24(S8)
569:                 			if(lenA != 0u)
9D011A2C  97C20018   LHU V0, 24(S8)
9D011A30  10400047   BEQ V0, ZERO, 0x9D011B50
9D011A34  00000000   NOP
570:                 			{
571:                 				curHTTP.hasArgs = TRUE;
9D011A38  3C02A000   LUI V0, -24576
9D011A3C  24420574   ADDIU V0, V0, 1396
9D011A40  24030001   ADDIU V1, ZERO, 1
9D011A44  A043001A   SB V1, 26(V0)
572:                 				
573:                 				// Trash the '?'
574:                 				TCPGet(sktHTTP, &c);
9D011A48  938281E8   LBU V0, -32280(GP)
9D011A4C  00401821   ADDU V1, V0, ZERO
9D011A50  3C02A000   LUI V0, -24576
9D011A54  000318C0   SLL V1, V1, 3
9D011A58  24420600   ADDIU V0, V0, 1536
9D011A5C  00621021   ADDU V0, V1, V0
9D011A60  90420004   LBU V0, 4(V0)
9D011A64  00401821   ADDU V1, V0, ZERO
9D011A68  27C20028   ADDIU V0, S8, 40
9D011A6C  00602021   ADDU A0, V1, ZERO
9D011A70  00402821   ADDU A1, V0, ZERO
9D011A74  0F4006DD   JAL TCPGet
9D011A78  00000000   NOP
575:                 
576:                 				// Verify there's enough space
577:                 				lenA--;
9D011A7C  97C20018   LHU V0, 24(S8)
9D011A80  2442FFFF   ADDIU V0, V0, -1
9D011A84  A7C20018   SH V0, 24(S8)
578:                 				if(lenA >= HTTP_MAX_DATA_LEN - 2)
9D011A88  97C20018   LHU V0, 24(S8)
9D011A8C  2C420062   SLTIU V0, V0, 98
9D011A90  14400010   BNE V0, ZERO, 0x9D011AD4
9D011A94  00000000   NOP
579:                 				{
580:                 			        curHTTP.httpStatus = HTTP_OVERFLOW;
9D011A98  3C02A000   LUI V0, -24576
9D011A9C  24420574   ADDIU V0, V0, 1396
9D011AA0  24030005   ADDIU V1, ZERO, 5
9D011AA4  AC43001C   SW V1, 28(V0)
581:                 					smHTTP = SM_HTTP_SERVE_HEADERS;
9D011AA8  938281E8   LBU V0, -32280(GP)
9D011AAC  00401821   ADDU V1, V0, ZERO
9D011AB0  3C02A000   LUI V0, -24576
9D011AB4  000318C0   SLL V1, V1, 3
9D011AB8  24420600   ADDIU V0, V0, 1536
9D011ABC  00621021   ADDU V0, V1, V0
9D011AC0  24030007   ADDIU V1, ZERO, 7
9D011AC4  AC430000   SW V1, 0(V0)
582:                 					isDone = FALSE;
9D011AC8  AFC00020   SW ZERO, 32(S8)
583:                 					break;
9D011ACC  0B404BF8   J 0x9D012FE0
9D011AD0  00000000   NOP
584:                 				}
585:                 
586:                 				// Read in the arguments and '&'-terminate in anticipation of cookies
587:                 				curHTTP.ptrData += TCPGetArray(sktHTTP, curHTTP.data, lenA);
9D011AD4  3C02A000   LUI V0, -24576
9D011AD8  24420574   ADDIU V0, V0, 1396
9D011ADC  8C500010   LW S0, 16(V0)
9D011AE0  938281E8   LBU V0, -32280(GP)
9D011AE4  00401821   ADDU V1, V0, ZERO
9D011AE8  3C02A000   LUI V0, -24576
9D011AEC  000318C0   SLL V1, V1, 3
9D011AF0  24420600   ADDIU V0, V0, 1536
9D011AF4  00621021   ADDU V0, V1, V0
9D011AF8  90420004   LBU V0, 4(V0)
9D011AFC  00401821   ADDU V1, V0, ZERO
9D011B00  97C20018   LHU V0, 24(S8)
9D011B04  00602021   ADDU A0, V1, ZERO
9D011B08  3C03A000   LUI V1, -24576
9D011B0C  24650598   ADDIU A1, V1, 1432
9D011B10  00403021   ADDU A2, V0, ZERO
9D011B14  0F40077A   JAL TCPGetArray
9D011B18  00000000   NOP
9D011B1C  02021821   ADDU V1, S0, V0
9D011B20  3C02A000   LUI V0, -24576
9D011B24  24420574   ADDIU V0, V0, 1396
9D011B28  AC430010   SW V1, 16(V0)
588:                 				*(curHTTP.ptrData++) = '&';
9D011B2C  3C02A000   LUI V0, -24576
9D011B30  24420574   ADDIU V0, V0, 1396
9D011B34  8C420010   LW V0, 16(V0)
9D011B38  24030026   ADDIU V1, ZERO, 38
9D011B3C  A0430000   SB V1, 0(V0)
9D011B40  24430001   ADDIU V1, V0, 1
9D011B44  3C02A000   LUI V0, -24576
9D011B48  24420574   ADDIU V0, V0, 1396
9D011B4C  AC430010   SW V1, 16(V0)
589:                 
590:                 			}
591:                 
592:                 			// Clear the rest of the line
593:                 			lenA = TCPFind(sktHTTP, '\n', 0, FALSE);
9D011B50  938281E8   LBU V0, -32280(GP)
9D011B54  00401821   ADDU V1, V0, ZERO
9D011B58  3C02A000   LUI V0, -24576
9D011B5C  000318C0   SLL V1, V1, 3
9D011B60  24420600   ADDIU V0, V0, 1536
9D011B64  00621021   ADDU V0, V1, V0
9D011B68  90420004   LBU V0, 4(V0)
9D011B6C  AFA00010   SW ZERO, 16(SP)
9D011B70  00402021   ADDU A0, V0, ZERO
9D011B74  2405000A   ADDIU A1, ZERO, 10
9D011B78  00003021   ADDU A2, ZERO, ZERO
9D011B7C  00003821   ADDU A3, ZERO, ZERO
9D011B80  0F400AEB   JAL TCPFindEx
9D011B84  00000000   NOP
9D011B88  A7C20018   SH V0, 24(S8)
594:                 			TCPGetArray(sktHTTP, NULL, lenA + 1);
9D011B8C  938281E8   LBU V0, -32280(GP)
9D011B90  00401821   ADDU V1, V0, ZERO
9D011B94  3C02A000   LUI V0, -24576
9D011B98  000318C0   SLL V1, V1, 3
9D011B9C  24420600   ADDIU V0, V0, 1536
9D011BA0  00621021   ADDU V0, V1, V0
9D011BA4  90420004   LBU V0, 4(V0)
9D011BA8  00401821   ADDU V1, V0, ZERO
9D011BAC  97C20018   LHU V0, 24(S8)
9D011BB0  24420001   ADDIU V0, V0, 1
9D011BB4  3042FFFF   ANDI V0, V0, -1
9D011BB8  00602021   ADDU A0, V1, ZERO
9D011BBC  00002821   ADDU A1, ZERO, ZERO
9D011BC0  00403021   ADDU A2, V0, ZERO
9D011BC4  0F40077A   JAL TCPGetArray
9D011BC8  00000000   NOP
595:                 
596:                 			// Move to parsing the headers
597:                 			smHTTP = SM_HTTP_PARSE_HEADERS;
9D011BCC  938281E8   LBU V0, -32280(GP)
9D011BD0  00401821   ADDU V1, V0, ZERO
9D011BD4  3C02A000   LUI V0, -24576
9D011BD8  000318C0   SLL V1, V1, 3
9D011BDC  24420600   ADDIU V0, V0, 1536
9D011BE0  00621021   ADDU V0, V1, V0
9D011BE4  24030002   ADDIU V1, ZERO, 2
9D011BE8  AC430000   SW V1, 0(V0)
598:                 			
599:                 			// No break, continue to parsing headers
600:                 
601:                 		case SM_HTTP_PARSE_HEADERS:
602:                 
603:                 			// Loop over all the headers
604:                 			while(1)
605:                 			{
606:                 				// Make sure entire line is in the FIFO
607:                 				lenA = TCPFind(sktHTTP, '\n', 0, FALSE);
9D011BEC  938281E8   LBU V0, -32280(GP)
9D011BF0  00401821   ADDU V1, V0, ZERO
9D011BF4  3C02A000   LUI V0, -24576
9D011BF8  000318C0   SLL V1, V1, 3
9D011BFC  24420600   ADDIU V0, V0, 1536
9D011C00  00621021   ADDU V0, V1, V0
9D011C04  90420004   LBU V0, 4(V0)
9D011C08  AFA00010   SW ZERO, 16(SP)
9D011C0C  00402021   ADDU A0, V0, ZERO
9D011C10  2405000A   ADDIU A1, ZERO, 10
9D011C14  00003021   ADDU A2, ZERO, ZERO
9D011C18  00003821   ADDU A3, ZERO, ZERO
9D011C1C  0F400AEB   JAL TCPFindEx
9D011C20  00000000   NOP
9D011C24  A7C20018   SH V0, 24(S8)
608:                 				if(lenA == 0xffff)
9D011C28  97C30018   LHU V1, 24(S8)
9D011C2C  3402FFFF   ORI V0, ZERO, -1
9D011C30  14620038   BNE V1, V0, 0x9D011D14
9D011C34  00000000   NOP
609:                 				{// If not, make sure we can receive more data
610:                 					if(TCPGetRxFIFOFree(sktHTTP) == 0u)
9D011C38  938281E8   LBU V0, -32280(GP)
9D011C3C  00401821   ADDU V1, V0, ZERO
9D011C40  3C02A000   LUI V0, -24576
9D011C44  000318C0   SLL V1, V1, 3
9D011C48  24420600   ADDIU V0, V0, 1536
9D011C4C  00621021   ADDU V0, V1, V0
9D011C50  90420004   LBU V0, 4(V0)
9D011C54  00402021   ADDU A0, V0, ZERO
9D011C58  0F400868   JAL TCPGetRxFIFOFree
9D011C5C  00000000   NOP
9D011C60  1440000E   BNE V0, ZERO, 0x9D011C9C
9D011C64  00000000   NOP
611:                 					{// Overflow
612:                 						curHTTP.httpStatus = HTTP_OVERFLOW;
9D011C68  3C02A000   LUI V0, -24576
9D011C6C  24420574   ADDIU V0, V0, 1396
9D011C70  24030005   ADDIU V1, ZERO, 5
9D011C74  AC43001C   SW V1, 28(V0)
613:                 						smHTTP = SM_HTTP_SERVE_HEADERS;
9D011C78  938281E8   LBU V0, -32280(GP)
9D011C7C  00401821   ADDU V1, V0, ZERO
9D011C80  3C02A000   LUI V0, -24576
9D011C84  000318C0   SLL V1, V1, 3
9D011C88  24420600   ADDIU V0, V0, 1536
9D011C8C  00621021   ADDU V0, V1, V0
9D011C90  24030007   ADDIU V1, ZERO, 7
9D011C94  AC430000   SW V1, 0(V0)
614:                 						isDone = FALSE;
9D011C98  AFC00020   SW ZERO, 32(S8)
615:                 					}
616:                 					if((LONG)(TickGet() - curHTTP.callbackID) > (LONG)0)
9D011C9C  0F40CDD6   JAL TickGet
9D011CA0  00000000   NOP
9D011CA4  00401821   ADDU V1, V0, ZERO
9D011CA8  3C02A000   LUI V0, -24576
9D011CAC  24420574   ADDIU V0, V0, 1396
9D011CB0  8C420008   LW V0, 8(V0)
9D011CB4  00621023   SUBU V0, V1, V0
9D011CB8  18400014   BLEZ V0, 0x9D011D0C
9D011CBC  00000000   NOP
617:                 					{// A timeout has occured
618:                 						TCPDisconnect(sktHTTP);
9D011CC0  938281E8   LBU V0, -32280(GP)
9D011CC4  00401821   ADDU V1, V0, ZERO
9D011CC8  3C02A000   LUI V0, -24576
9D011CCC  000318C0   SLL V1, V1, 3
9D011CD0  24420600   ADDIU V0, V0, 1536
9D011CD4  00621021   ADDU V0, V1, V0
9D011CD8  90420004   LBU V0, 4(V0)
9D011CDC  00402021   ADDU A0, V0, ZERO
9D011CE0  0F400273   JAL TCPDisconnect
9D011CE4  00000000   NOP
619:                 						smHTTP = SM_HTTP_DISCONNECT;
9D011CE8  938281E8   LBU V0, -32280(GP)
9D011CEC  00401821   ADDU V1, V0, ZERO
9D011CF0  3C02A000   LUI V0, -24576
9D011CF4  000318C0   SLL V1, V1, 3
9D011CF8  24420600   ADDIU V0, V0, 1536
9D011CFC  00621021   ADDU V0, V1, V0
9D011D00  2403000B   ADDIU V1, ZERO, 11
9D011D04  AC430000   SW V1, 0(V0)
620:                 						isDone = FALSE;
9D011D08  AFC00020   SW ZERO, 32(S8)
621:                 					}
622:                 					break;
9D011D0C  0B4047ED   J 0x9D011FB4
9D011D10  00000000   NOP
623:                 				}
624:                 				
625:                 				// Reset the watchdog timer
626:                 				curHTTP.callbackID = TickGet() + HTTP_TIMEOUT*TICK_SECOND;
9D011D14  0F40CDD6   JAL TickGet
9D011D18  00000000   NOP
9D011D1C  00401821   ADDU V1, V0, ZERO
9D011D20  3C02006B   LUI V0, 107
9D011D24  344249D2   ORI V0, V0, 18898
9D011D28  00621821   ADDU V1, V1, V0
9D011D2C  3C02A000   LUI V0, -24576
9D011D30  24420574   ADDIU V0, V0, 1396
9D011D34  AC430008   SW V1, 8(V0)
627:                 				
628:                 				// If a CRLF is immediate, then headers are done
629:                 				if(lenA == 1u)
9D011D38  97C30018   LHU V1, 24(S8)
9D011D3C  24020001   ADDIU V0, ZERO, 1
9D011D40  14620018   BNE V1, V0, 0x9D011DA4
9D011D44  00000000   NOP
630:                 				{// Remove the CRLF and move to next state
631:                 					TCPGetArray(sktHTTP, NULL, 2);
9D011D48  938281E8   LBU V0, -32280(GP)
9D011D4C  00401821   ADDU V1, V0, ZERO
9D011D50  3C02A000   LUI V0, -24576
9D011D54  000318C0   SLL V1, V1, 3
9D011D58  24420600   ADDIU V0, V0, 1536
9D011D5C  00621021   ADDU V0, V1, V0
9D011D60  90420004   LBU V0, 4(V0)
9D011D64  00402021   ADDU A0, V0, ZERO
9D011D68  00002821   ADDU A1, ZERO, ZERO
9D011D6C  24060002   ADDIU A2, ZERO, 2
9D011D70  0F40077A   JAL TCPGetArray
9D011D74  00000000   NOP
632:                 					smHTTP = SM_HTTP_AUTHENTICATE;
9D011D78  938281E8   LBU V0, -32280(GP)
9D011D7C  00401821   ADDU V1, V0, ZERO
9D011D80  3C02A000   LUI V0, -24576
9D011D84  000318C0   SLL V1, V1, 3
9D011D88  24420600   ADDIU V0, V0, 1536
9D011D8C  00621021   ADDU V0, V1, V0
9D011D90  24030003   ADDIU V1, ZERO, 3
9D011D94  AC430000   SW V1, 0(V0)
633:                 					isDone = FALSE;
9D011D98  AFC00020   SW ZERO, 32(S8)
634:                 					break;
9D011D9C  0B4047ED   J 0x9D011FB4
9D011DA0  00000000   NOP
635:                 				}
636:                 	
637:                 				// Find the header name, and use isDone as a flag to indicate a match
638:                 				lenB = TCPFindEx(sktHTTP, ':', 0, lenA, FALSE) + 2;
9D011DA4  938281E8   LBU V0, -32280(GP)
9D011DA8  00401821   ADDU V1, V0, ZERO
9D011DAC  3C02A000   LUI V0, -24576
9D011DB0  000318C0   SLL V1, V1, 3
9D011DB4  24420600   ADDIU V0, V0, 1536
9D011DB8  00621021   ADDU V0, V1, V0
9D011DBC  90420004   LBU V0, 4(V0)
9D011DC0  00401821   ADDU V1, V0, ZERO
9D011DC4  97C20018   LHU V0, 24(S8)
9D011DC8  AFA00010   SW ZERO, 16(SP)
9D011DCC  00602021   ADDU A0, V1, ZERO
9D011DD0  2405003A   ADDIU A1, ZERO, 58
9D011DD4  00003021   ADDU A2, ZERO, ZERO
9D011DD8  00403821   ADDU A3, V0, ZERO
9D011DDC  0F400AEB   JAL TCPFindEx
9D011DE0  00000000   NOP
9D011DE4  24420002   ADDIU V0, V0, 2
9D011DE8  A7C2001A   SH V0, 26(S8)
639:                 				isDone = FALSE;
9D011DEC  AFC00020   SW ZERO, 32(S8)
640:                 	
641:                 				// If name is too long or this line isn't a header, ignore it
642:                 				if(lenB > sizeof(buffer))
9D011DF0  97C2001A   LHU V0, 26(S8)
9D011DF4  2C420011   SLTIU V0, V0, 17
9D011DF8  14400014   BNE V0, ZERO, 0x9D011E4C
9D011DFC  00000000   NOP
643:                 				{
644:                 					TCPGetArray(sktHTTP, NULL, lenA+1);
9D011E00  938281E8   LBU V0, -32280(GP)
9D011E04  00401821   ADDU V1, V0, ZERO
9D011E08  3C02A000   LUI V0, -24576
9D011E0C  000318C0   SLL V1, V1, 3
9D011E10  24420600   ADDIU V0, V0, 1536
9D011E14  00621021   ADDU V0, V1, V0
9D011E18  90420004   LBU V0, 4(V0)
9D011E1C  00401821   ADDU V1, V0, ZERO
9D011E20  97C20018   LHU V0, 24(S8)
9D011E24  24420001   ADDIU V0, V0, 1
9D011E28  3042FFFF   ANDI V0, V0, -1
9D011E2C  00602021   ADDU A0, V1, ZERO
9D011E30  00002821   ADDU A1, ZERO, ZERO
9D011E34  00403021   ADDU A2, V0, ZERO
9D011E38  0F40077A   JAL TCPGetArray
9D011E3C  00000000   NOP
645:                 					continue;
9D011E40  00000000   NOP
646:                 				}
647:                 				
648:                 				// Read in the header name
649:                 				TCPGetArray(sktHTTP, buffer, lenB);
9D011E4C  938281E8   LBU V0, -32280(GP)
9D011E50  00401821   ADDU V1, V0, ZERO
9D011E54  3C02A000   LUI V0, -24576
9D011E58  000318C0   SLL V1, V1, 3
9D011E5C  24420600   ADDIU V0, V0, 1536
9D011E60  00621021   ADDU V0, V1, V0
9D011E64  90420004   LBU V0, 4(V0)
9D011E68  00402021   ADDU A0, V0, ZERO
9D011E6C  97C2001A   LHU V0, 26(S8)
9D011E70  27C3002C   ADDIU V1, S8, 44
9D011E74  00602821   ADDU A1, V1, ZERO
9D011E78  00403021   ADDU A2, V0, ZERO
9D011E7C  0F40077A   JAL TCPGetArray
9D011E80  00000000   NOP
650:                 				buffer[lenB-1] = '\0';
9D011E84  97C2001A   LHU V0, 26(S8)
9D011E88  2442FFFF   ADDIU V0, V0, -1
9D011E8C  27C30018   ADDIU V1, S8, 24
9D011E90  00621021   ADDU V0, V1, V0
9D011E94  A0400014   SB ZERO, 20(V0)
651:                 				lenA -= lenB;
9D011E98  97C30018   LHU V1, 24(S8)
9D011E9C  97C2001A   LHU V0, 26(S8)
9D011EA0  00621023   SUBU V0, V1, V0
9D011EA4  A7C20018   SH V0, 24(S8)
652:                 		
653:                 				// Compare header read to ones we're interested in
654:                 				for(i = 0; i < sizeof(HTTPRequestHeaders)/sizeof(HTTPRequestHeaders[0]); i++)
9D011EA8  A3C0001C   SB ZERO, 28(S8)
9D011EAC  0B4047C5   J 0x9D011F14
9D011EB0  00000000   NOP
9D011F08  93C2001C   LBU V0, 28(S8)
9D011F0C  24420001   ADDIU V0, V0, 1
9D011F10  A3C2001C   SB V0, 28(S8)
9D011F14  93C2001C   LBU V0, 28(S8)
9D011F18  2C420003   SLTIU V0, V0, 3
9D011F1C  1440FFE5   BNE V0, ZERO, 0x9D011EB4
9D011F20  00000000   NOP
655:                 				{
656:                 					if(strcmppgm2ram((char*)buffer, (ROM char *)HTTPRequestHeaders[i]) == 0)
9D011EB4  27C3002C   ADDIU V1, S8, 44
9D011EB8  93C4001C   LBU A0, 28(S8)
9D011EBC  3C029D03   LUI V0, -25341
9D011EC0  00042080   SLL A0, A0, 2
9D011EC4  24421434   ADDIU V0, V0, 5172
9D011EC8  00821021   ADDU V0, A0, V0
9D011ECC  8C420000   LW V0, 0(V0)
9D011ED0  00602021   ADDU A0, V1, ZERO
9D011ED4  00402821   ADDU A1, V0, ZERO
9D011ED8  0F40D48D   JAL 0x9D035234
9D011EDC  00000000   NOP
9D011EE0  14400009   BNE V0, ZERO, 0x9D011F08
9D011EE4  00000000   NOP
657:                 					{// Parse the header and stop the loop
658:                 						HTTPHeaderParseLookup(i);
9D011EE8  93C2001C   LBU V0, 28(S8)
9D011EEC  00402021   ADDU A0, V0, ZERO
9D011EF0  0F404CAB   JAL 0x9D0132AC
9D011EF4  00000000   NOP
659:                 						isDone = TRUE;
9D011EF8  24020001   ADDIU V0, ZERO, 1
9D011EFC  AFC20020   SW V0, 32(S8)
660:                 						break;
9D011F00  0B4047C9   J 0x9D011F24
9D011F04  00000000   NOP
661:                 					}
662:                 				}
663:                 				
664:                 				// Clear the rest of the line, and call the loop again
665:                 				if(isDone)
9D011F24  8FC20020   LW V0, 32(S8)
9D011F28  10400010   BEQ V0, ZERO, 0x9D011F6C
9D011F2C  00000000   NOP
666:                 				{// We already know how much to remove unless a header was found
667:                 					lenA = TCPFind(sktHTTP, '\n', 0, FALSE);
9D011F30  938281E8   LBU V0, -32280(GP)
9D011F34  00401821   ADDU V1, V0, ZERO
9D011F38  3C02A000   LUI V0, -24576
9D011F3C  000318C0   SLL V1, V1, 3
9D011F40  24420600   ADDIU V0, V0, 1536
9D011F44  00621021   ADDU V0, V1, V0
9D011F48  90420004   LBU V0, 4(V0)
9D011F4C  AFA00010   SW ZERO, 16(SP)
9D011F50  00402021   ADDU A0, V0, ZERO
9D011F54  2405000A   ADDIU A1, ZERO, 10
9D011F58  00003021   ADDU A2, ZERO, ZERO
9D011F5C  00003821   ADDU A3, ZERO, ZERO
9D011F60  0F400AEB   JAL TCPFindEx
9D011F64  00000000   NOP
9D011F68  A7C20018   SH V0, 24(S8)
668:                 				}
669:                 				TCPGetArray(sktHTTP, NULL, lenA+1);
9D011F6C  938281E8   LBU V0, -32280(GP)
9D011F70  00401821   ADDU V1, V0, ZERO
9D011F74  3C02A000   LUI V0, -24576
9D011F78  000318C0   SLL V1, V1, 3
9D011F7C  24420600   ADDIU V0, V0, 1536
9D011F80  00621021   ADDU V0, V1, V0
9D011F84  90420004   LBU V0, 4(V0)
9D011F88  00401821   ADDU V1, V0, ZERO
9D011F8C  97C20018   LHU V0, 24(S8)
9D011F90  24420001   ADDIU V0, V0, 1
9D011F94  3042FFFF   ANDI V0, V0, -1
9D011F98  00602021   ADDU A0, V1, ZERO
9D011F9C  00002821   ADDU A1, ZERO, ZERO
9D011FA0  00403021   ADDU A2, V0, ZERO
9D011FA4  0F40077A   JAL TCPGetArray
9D011FA8  00000000   NOP
670:                 			}
9D011E44  0B4046FB   J 0x9D011BEC
9D011E48  00000000   NOP
9D011FAC  0B4046FB   J 0x9D011BEC
9D011FB0  00000000   NOP
671:                 			
672:                 			break;
9D011FB4  0B404BF8   J 0x9D012FE0
9D011FB8  00000000   NOP
673:                 
674:                 		case SM_HTTP_AUTHENTICATE:
675:                 		
676:                 			#if defined(HTTP_USE_AUTHENTICATION)
677:                 			// Check current authorization state
678:                 			if(curHTTP.isAuthorized < 0x80)
9D011FBC  3C02A000   LUI V0, -24576
9D011FC0  24420574   ADDIU V0, V0, 1396
9D011FC4  9042001B   LBU V0, 27(V0)
9D011FC8  7C021420   SEB V0, V0
9D011FCC  04400010   BLTZ V0, 0x9D012010
9D011FD0  00000000   NOP
679:                 			{// 401 error
680:                 				curHTTP.httpStatus = HTTP_UNAUTHORIZED;
9D011FD4  3C02A000   LUI V0, -24576
9D011FD8  24420574   ADDIU V0, V0, 1396
9D011FDC  24030003   ADDIU V1, ZERO, 3
9D011FE0  AC43001C   SW V1, 28(V0)
681:                 				smHTTP = SM_HTTP_SERVE_HEADERS;
9D011FE4  938281E8   LBU V0, -32280(GP)
9D011FE8  00401821   ADDU V1, V0, ZERO
9D011FEC  3C02A000   LUI V0, -24576
9D011FF0  000318C0   SLL V1, V1, 3
9D011FF4  24420600   ADDIU V0, V0, 1536
9D011FF8  00621021   ADDU V0, V1, V0
9D011FFC  24030007   ADDIU V1, ZERO, 7
9D012000  AC430000   SW V1, 0(V0)
682:                 				isDone = FALSE;
9D012004  AFC00020   SW ZERO, 32(S8)
683:                 				
684:                 				#if defined(HTTP_NO_AUTH_WITHOUT_SSL)
685:                 				if(!TCPIsSSL(sktHTTP))
686:                 					curHTTP.httpStatus = HTTP_SSL_REQUIRED;
687:                 				#endif
688:                 
689:                 				break;
9D012008  0B404BF8   J 0x9D012FE0
9D01200C  00000000   NOP
690:                 			}
691:                 			#endif
692:                 
693:                 			// Parse the args string
694:                 			*curHTTP.ptrData = '\0';
9D012010  3C02A000   LUI V0, -24576
9D012014  24420574   ADDIU V0, V0, 1396
9D012018  8C420010   LW V0, 16(V0)
9D01201C  A0400000   SB ZERO, 0(V0)
695:                 			curHTTP.ptrData = HTTPURLDecode(curHTTP.data);
9D012020  3C02A000   LUI V0, -24576
9D012024  24440598   ADDIU A0, V0, 1432
9D012028  0F404E46   JAL HTTPURLDecode
9D01202C  00000000   NOP
9D012030  00401821   ADDU V1, V0, ZERO
9D012034  3C02A000   LUI V0, -24576
9D012038  24420574   ADDIU V0, V0, 1396
9D01203C  AC430010   SW V1, 16(V0)
696:                 
697:                 			// If this is an MPFS upload form request, bypass to headers
698:                 			#if defined(HTTP_MPFS_UPLOAD)
699:                 			if(curHTTP.httpStatus == HTTP_MPFS_FORM)
700:                 			{
701:                 				smHTTP = SM_HTTP_SERVE_HEADERS;
702:                 				isDone = FALSE;
703:                 				break;
704:                 			}
705:                 			#endif
706:                 			
707:                 			// Move on to GET args, unless there are none
708:                 			smHTTP = SM_HTTP_PROCESS_GET;
9D012040  938281E8   LBU V0, -32280(GP)
9D012044  00401821   ADDU V1, V0, ZERO
9D012048  3C02A000   LUI V0, -24576
9D01204C  000318C0   SLL V1, V1, 3
9D012050  24420600   ADDIU V0, V0, 1536
9D012054  00621021   ADDU V0, V1, V0
9D012058  24030004   ADDIU V1, ZERO, 4
9D01205C  AC430000   SW V1, 0(V0)
709:                 			if(!curHTTP.hasArgs)
9D012060  3C02A000   LUI V0, -24576
9D012064  24420574   ADDIU V0, V0, 1396
9D012068  9042001A   LBU V0, 26(V0)
9D01206C  14400009   BNE V0, ZERO, 0x9D012094
9D012070  00000000   NOP
710:                 				smHTTP = SM_HTTP_PROCESS_POST;
9D012074  938281E8   LBU V0, -32280(GP)
9D012078  00401821   ADDU V1, V0, ZERO
9D01207C  3C02A000   LUI V0, -24576
9D012080  000318C0   SLL V1, V1, 3
9D012084  24420600   ADDIU V0, V0, 1536
9D012088  00621021   ADDU V0, V1, V0
9D01208C  24030005   ADDIU V1, ZERO, 5
9D012090  AC430000   SW V1, 0(V0)
711:                 			isDone = FALSE;
9D012094  AFC00020   SW ZERO, 32(S8)
712:                 			curHTTP.hasArgs = FALSE;
9D012098  3C02A000   LUI V0, -24576
9D01209C  24420574   ADDIU V0, V0, 1396
9D0120A0  A040001A   SB ZERO, 26(V0)
713:                 			break;
9D0120A4  0B404BF8   J 0x9D012FE0
9D0120A8  00000000   NOP
714:                 
715:                 		case SM_HTTP_PROCESS_GET:
716:                 
717:                 			// Run the application callback HTTPExecuteGet()
718:                 			if(HTTPExecuteGet() == HTTP_IO_WAITING)
9D0120AC  0F4050EA   JAL HTTPExecuteGet
9D0120B0  00000000   NOP
9D0120B4  00401821   ADDU V1, V0, ZERO
9D0120B8  24020002   ADDIU V0, ZERO, 2
9D0120BC  106203BB   BEQ V1, V0, 0x9D012FAC
9D0120C0  00000000   NOP
719:                 			{// If waiting for asynchronous process, return to main app
720:                 				break;
9D012FAC  00000000   NOP
9D012FB0  0B404BF8   J 0x9D012FE0
9D012FB4  00000000   NOP
721:                 			}
722:                 
723:                 			// Move on to POST data
724:                 			smHTTP = SM_HTTP_PROCESS_POST;
9D0120C4  938281E8   LBU V0, -32280(GP)
9D0120C8  00401821   ADDU V1, V0, ZERO
9D0120CC  3C02A000   LUI V0, -24576
9D0120D0  000318C0   SLL V1, V1, 3
9D0120D4  24420600   ADDIU V0, V0, 1536
9D0120D8  00621021   ADDU V0, V1, V0
9D0120DC  24030005   ADDIU V1, ZERO, 5
9D0120E0  AC430000   SW V1, 0(V0)
725:                 
726:                 		case SM_HTTP_PROCESS_POST:
727:                 
728:                 			#if defined(HTTP_USE_POST)
729:                 			
730:                 			// See if we have any new data
731:                 			if(TCPIsGetReady(sktHTTP) == curHTTP.callbackPos)
9D0120E4  938281E8   LBU V0, -32280(GP)
9D0120E8  00401821   ADDU V1, V0, ZERO
9D0120EC  3C02A000   LUI V0, -24576
9D0120F0  000318C0   SLL V1, V1, 3
9D0120F4  24420600   ADDIU V0, V0, 1536
9D0120F8  00621021   ADDU V0, V1, V0
9D0120FC  90420004   LBU V0, 4(V0)
9D012100  00402021   ADDU A0, V0, ZERO
9D012104  0F400675   JAL TCPIsGetReady
9D012108  00000000   NOP
9D01210C  00401821   ADDU V1, V0, ZERO
9D012110  3C02A000   LUI V0, -24576
9D012114  24420574   ADDIU V0, V0, 1396
9D012118  8C42000C   LW V0, 12(V0)
9D01211C  1462001F   BNE V1, V0, 0x9D01219C
9D012120  00000000   NOP
732:                 			{
733:                 				if((LONG)(TickGet() - curHTTP.callbackID) > (LONG)0)
9D012124  0F40CDD6   JAL TickGet
9D012128  00000000   NOP
9D01212C  00401821   ADDU V1, V0, ZERO
9D012130  3C02A000   LUI V0, -24576
9D012134  24420574   ADDIU V0, V0, 1396
9D012138  8C420008   LW V0, 8(V0)
9D01213C  00621023   SUBU V0, V1, V0
9D012140  18400016   BLEZ V0, 0x9D01219C
9D012144  00000000   NOP
734:                 				{// If a timeout has occured, disconnect
735:                 					TCPDisconnect(sktHTTP);
9D012148  938281E8   LBU V0, -32280(GP)
9D01214C  00401821   ADDU V1, V0, ZERO
9D012150  3C02A000   LUI V0, -24576
9D012154  000318C0   SLL V1, V1, 3
9D012158  24420600   ADDIU V0, V0, 1536
9D01215C  00621021   ADDU V0, V1, V0
9D012160  90420004   LBU V0, 4(V0)
9D012164  00402021   ADDU A0, V0, ZERO
9D012168  0F400273   JAL TCPDisconnect
9D01216C  00000000   NOP
736:                 					smHTTP = SM_HTTP_DISCONNECT;
9D012170  938281E8   LBU V0, -32280(GP)
9D012174  00401821   ADDU V1, V0, ZERO
9D012178  3C02A000   LUI V0, -24576
9D01217C  000318C0   SLL V1, V1, 3
9D012180  24420600   ADDIU V0, V0, 1536
9D012184  00621021   ADDU V0, V1, V0
9D012188  2403000B   ADDIU V1, ZERO, 11
9D01218C  AC430000   SW V1, 0(V0)
737:                 					isDone = FALSE;
9D012190  AFC00020   SW ZERO, 32(S8)
738:                 					break;
9D012194  0B404BF8   J 0x9D012FE0
9D012198  00000000   NOP
739:                 				}
740:                 			}
741:                 			
742:                 			if(curHTTP.httpStatus == HTTP_POST 
9D01219C  3C02A000   LUI V0, -24576
9D0121A0  24420574   ADDIU V0, V0, 1396
9D0121A4  8C43001C   LW V1, 28(V0)
9D0121A8  24020001   ADDIU V0, ZERO, 1
9D0121AC  14620058   BNE V1, V0, 0x9D012310
9D0121B0  00000000   NOP
743:                 				#if defined(HTTP_MPFS_UPLOAD)
744:                 				|| (curHTTP.httpStatus >= HTTP_MPFS_UP && curHTTP.httpStatus <= HTTP_MPFS_ERROR)
745:                 				#endif
746:                 				 )
747:                 			{
748:                 				// Run the application callback HTTPExecutePost()
749:                 				#if defined(HTTP_MPFS_UPLOAD)
750:                 				if(curHTTP.httpStatus >= HTTP_MPFS_UP && curHTTP.httpStatus <= HTTP_MPFS_ERROR)
751:                 				{
752:                 					c = HTTPMPFSUpload();
753:                 					if(c == (BYTE)HTTP_IO_DONE)
754:                 					{
755:                 						smHTTP = SM_HTTP_SERVE_HEADERS;
756:                 						isDone = FALSE;
757:                 						break;
758:                 					}
759:                 				}
760:                 				else
761:                 				#endif
762:                 				c = HTTPExecutePost();
9D0121B4  0F4051EF   JAL HTTPExecutePost
9D0121B8  00000000   NOP
9D0121BC  304200FF   ANDI V0, V0, 255
9D0121C0  A3C20028   SB V0, 40(S8)
763:                 				
764:                 				// If waiting for asynchronous process, return to main app
765:                 				if(c == (BYTE)HTTP_IO_WAITING)
9D0121C4  93C30028   LBU V1, 40(S8)
9D0121C8  24020002   ADDIU V0, ZERO, 2
9D0121CC  14620012   BNE V1, V0, 0x9D012218
9D0121D0  00000000   NOP
766:                 				{// return to main app and make sure we don't get stuck by the watchdog
767:                 					curHTTP.callbackPos = TCPIsGetReady(sktHTTP) - 1;
9D0121D4  938281E8   LBU V0, -32280(GP)
9D0121D8  00401821   ADDU V1, V0, ZERO
9D0121DC  3C02A000   LUI V0, -24576
9D0121E0  000318C0   SLL V1, V1, 3
9D0121E4  24420600   ADDIU V0, V0, 1536
9D0121E8  00621021   ADDU V0, V1, V0
9D0121EC  90420004   LBU V0, 4(V0)
9D0121F0  00402021   ADDU A0, V0, ZERO
9D0121F4  0F400675   JAL TCPIsGetReady
9D0121F8  00000000   NOP
9D0121FC  2442FFFF   ADDIU V0, V0, -1
9D012200  00401821   ADDU V1, V0, ZERO
9D012204  3C02A000   LUI V0, -24576
9D012208  24420574   ADDIU V0, V0, 1396
9D01220C  AC43000C   SW V1, 12(V0)
768:                 					break;
9D012210  0B404BF8   J 0x9D012FE0
9D012214  00000000   NOP
769:                 				}
770:                 				else if(c == (BYTE)HTTP_IO_NEED_DATA)
9D012218  93C30028   LBU V1, 40(S8)
9D01221C  24020001   ADDIU V0, ZERO, 1
9D012220  1462003B   BNE V1, V0, 0x9D012310
9D012224  00000000   NOP
771:                 				{// If waiting for more data
772:                 					curHTTP.callbackPos = TCPIsGetReady(sktHTTP);
9D012228  938281E8   LBU V0, -32280(GP)
9D01222C  00401821   ADDU V1, V0, ZERO
9D012230  3C02A000   LUI V0, -24576
9D012234  000318C0   SLL V1, V1, 3
9D012238  24420600   ADDIU V0, V0, 1536
9D01223C  00621021   ADDU V0, V1, V0
9D012240  90420004   LBU V0, 4(V0)
9D012244  00402021   ADDU A0, V0, ZERO
9D012248  0F400675   JAL TCPIsGetReady
9D01224C  00000000   NOP
9D012250  00401821   ADDU V1, V0, ZERO
9D012254  3C02A000   LUI V0, -24576
9D012258  24420574   ADDIU V0, V0, 1396
9D01225C  AC43000C   SW V1, 12(V0)
773:                 					curHTTP.callbackID = TickGet() + HTTP_TIMEOUT*TICK_SECOND;
9D012260  0F40CDD6   JAL TickGet
9D012264  00000000   NOP
9D012268  00401821   ADDU V1, V0, ZERO
9D01226C  3C02006B   LUI V0, 107
9D012270  344249D2   ORI V0, V0, 18898
9D012274  00621821   ADDU V1, V1, V0
9D012278  3C02A000   LUI V0, -24576
9D01227C  24420574   ADDIU V0, V0, 1396
9D012280  AC430008   SW V1, 8(V0)
774:                 					
775:                 					// If more is expected and space is available, return to main app
776:                 					if(curHTTP.byteCount > curHTTP.callbackPos && TCPGetRxFIFOFree(sktHTTP) != 0u)
9D012284  3C02A000   LUI V0, -24576
9D012288  8C430574   LW V1, 1396(V0)
9D01228C  3C02A000   LUI V0, -24576
9D012290  24420574   ADDIU V0, V0, 1396
9D012294  8C42000C   LW V0, 12(V0)
9D012298  0043102B   SLTU V0, V0, V1
9D01229C  1040000D   BEQ V0, ZERO, 0x9D0122D4
9D0122A0  00000000   NOP
9D0122A4  938281E8   LBU V0, -32280(GP)
9D0122A8  00401821   ADDU V1, V0, ZERO
9D0122AC  3C02A000   LUI V0, -24576
9D0122B0  000318C0   SLL V1, V1, 3
9D0122B4  24420600   ADDIU V0, V0, 1536
9D0122B8  00621021   ADDU V0, V1, V0
9D0122BC  90420004   LBU V0, 4(V0)
9D0122C0  00402021   ADDU A0, V0, ZERO
9D0122C4  0F400868   JAL TCPGetRxFIFOFree
9D0122C8  00000000   NOP
9D0122CC  1440033A   BNE V0, ZERO, 0x9D012FB8
9D0122D0  00000000   NOP
777:                 						break;
9D012FB8  00000000   NOP
9D012FBC  0B404BF8   J 0x9D012FE0
9D012FC0  00000000   NOP
778:                 					
779:                 					// Handle cases where application ran out of data or buffer space
780:                 					curHTTP.httpStatus = HTTP_INTERNAL_SERVER_ERROR;
9D0122D4  3C02A000   LUI V0, -24576
9D0122D8  24420574   ADDIU V0, V0, 1396
9D0122DC  24030006   ADDIU V1, ZERO, 6
9D0122E0  AC43001C   SW V1, 28(V0)
781:                 					smHTTP = SM_HTTP_SERVE_HEADERS;
9D0122E4  938281E8   LBU V0, -32280(GP)
9D0122E8  00401821   ADDU V1, V0, ZERO
9D0122EC  3C02A000   LUI V0, -24576
9D0122F0  000318C0   SLL V1, V1, 3
9D0122F4  24420600   ADDIU V0, V0, 1536
9D0122F8  00621021   ADDU V0, V1, V0
9D0122FC  24030007   ADDIU V1, ZERO, 7
9D012300  AC430000   SW V1, 0(V0)
782:                 					isDone = FALSE;
9D012304  AFC00020   SW ZERO, 32(S8)
783:                 					break;	
9D012308  0B404BF8   J 0x9D012FE0
9D01230C  00000000   NOP
784:                 				}
785:                 			}
786:                 			#endif
787:                 
788:                 			// We're done with POST
789:                 			smHTTP = SM_HTTP_PROCESS_REQUEST;
9D012310  938281E8   LBU V0, -32280(GP)
9D012314  00401821   ADDU V1, V0, ZERO
9D012318  3C02A000   LUI V0, -24576
9D01231C  000318C0   SLL V1, V1, 3
9D012320  24420600   ADDIU V0, V0, 1536
9D012324  00621021   ADDU V0, V1, V0
9D012328  24030006   ADDIU V1, ZERO, 6
9D01232C  AC430000   SW V1, 0(V0)
790:                 			// No break, continue to sending request
791:                 
792:                 		case SM_HTTP_PROCESS_REQUEST:
793:                 
794:                 			// Check for 404
795:                             if(curHTTP.file == MPFS_INVALID_HANDLE)
9D012330  3C02A000   LUI V0, -24576
9D012334  24420574   ADDIU V0, V0, 1396
9D012338  90430018   LBU V1, 24(V0)
9D01233C  240200FF   ADDIU V0, ZERO, 255
9D012340  14620010   BNE V1, V0, 0x9D012384
9D012344  00000000   NOP
796:                             {
797:                                 curHTTP.httpStatus = HTTP_NOT_FOUND;
9D012348  3C02A000   LUI V0, -24576
9D01234C  24420574   ADDIU V0, V0, 1396
9D012350  24030004   ADDIU V1, ZERO, 4
9D012354  AC43001C   SW V1, 28(V0)
798:                                 smHTTP = SM_HTTP_SERVE_HEADERS;
9D012358  938281E8   LBU V0, -32280(GP)
9D01235C  00401821   ADDU V1, V0, ZERO
9D012360  3C02A000   LUI V0, -24576
9D012364  000318C0   SLL V1, V1, 3
9D012368  24420600   ADDIU V0, V0, 1536
9D01236C  00621021   ADDU V0, V1, V0
9D012370  24030007   ADDIU V1, ZERO, 7
9D012374  AC430000   SW V1, 0(V0)
799:                                 isDone = FALSE;
9D012378  AFC00020   SW ZERO, 32(S8)
800:                                 break;
9D01237C  0B404BF8   J 0x9D012FE0
9D012380  00000000   NOP
801:                             }
802:                 
803:                 			// Set up the dynamic substitutions
804:                 			curHTTP.byteCount = 0;
9D012384  3C02A000   LUI V0, -24576
9D012388  AC400574   SW ZERO, 1396(V0)
805:                 			if(curHTTP.offsets == MPFS_INVALID_HANDLE)
9D01238C  3C02A000   LUI V0, -24576
9D012390  24420574   ADDIU V0, V0, 1396
9D012394  90430019   LBU V1, 25(V0)
9D012398  240200FF   ADDIU V0, ZERO, 255
9D01239C  14620007   BNE V1, V0, 0x9D0123BC
9D0123A0  00000000   NOP
806:                             {// If no index file, then set next offset to huge
807:                 	            curHTTP.nextCallback = 0xffffffff;
9D0123A4  3C02A000   LUI V0, -24576
9D0123A8  24420574   ADDIU V0, V0, 1396
9D0123AC  2403FFFF   ADDIU V1, ZERO, -1
9D0123B0  AC430004   SW V1, 4(V0)
9D0123B4  0B4048F7   J 0x9D0123DC
9D0123B8  00000000   NOP
808:                             }
809:                             else
810:                             {// Read in the next callback index
811:                 	            MPFSGetLong(curHTTP.offsets, &(curHTTP.nextCallback));
9D0123BC  3C02A000   LUI V0, -24576
9D0123C0  24420574   ADDIU V0, V0, 1396
9D0123C4  90420019   LBU V0, 25(V0)
9D0123C8  00402021   ADDU A0, V0, ZERO
9D0123CC  3C02A000   LUI V0, -24576
9D0123D0  24450578   ADDIU A1, V0, 1400
9D0123D4  0F409DC3   JAL MPFSGetLong
9D0123D8  00000000   NOP
812:                 			}
813:                 			
814:                 			// Move to next state
815:                 			smHTTP = SM_HTTP_SERVE_HEADERS;
9D0123DC  938281E8   LBU V0, -32280(GP)
9D0123E0  00401821   ADDU V1, V0, ZERO
9D0123E4  3C02A000   LUI V0, -24576
9D0123E8  000318C0   SLL V1, V1, 3
9D0123EC  24420600   ADDIU V0, V0, 1536
9D0123F0  00621021   ADDU V0, V1, V0
9D0123F4  24030007   ADDIU V1, ZERO, 7
9D0123F8  AC430000   SW V1, 0(V0)
816:                 
817:                 		case SM_HTTP_SERVE_HEADERS:
818:                 
819:                 			// We're in write mode now:
820:                 			// Adjust the TCP FIFOs for optimal transmission of 
821:                 			// the HTTP response to the browser
822:                 			TCPAdjustFIFOSize(sktHTTP, 1, 0, TCP_ADJUST_GIVE_REST_TO_TX);
9D0123FC  938281E8   LBU V0, -32280(GP)
9D012400  00401821   ADDU V1, V0, ZERO
9D012404  3C02A000   LUI V0, -24576
9D012408  000318C0   SLL V1, V1, 3
9D01240C  24420600   ADDIU V0, V0, 1536
9D012410  00621021   ADDU V0, V1, V0
9D012414  90420004   LBU V0, 4(V0)
9D012418  00402021   ADDU A0, V0, ZERO
9D01241C  24050001   ADDIU A1, ZERO, 1
9D012420  00003021   ADDU A2, ZERO, ZERO
9D012424  24070002   ADDIU A3, ZERO, 2
9D012428  0F401EEC   JAL TCPAdjustFIFOSize
9D01242C  00000000   NOP
823:                 				
824:                 			// Send headers
825:                 			TCPPutROMString(sktHTTP, (ROM BYTE*)HTTPResponseHeaders[curHTTP.httpStatus]);
9D012430  938281E8   LBU V0, -32280(GP)
9D012434  00401821   ADDU V1, V0, ZERO
9D012438  3C02A000   LUI V0, -24576
9D01243C  000318C0   SLL V1, V1, 3
9D012440  24420600   ADDIU V0, V0, 1536
9D012444  00621021   ADDU V0, V1, V0
9D012448  90420004   LBU V0, 4(V0)
9D01244C  00401821   ADDU V1, V0, ZERO
9D012450  3C02A000   LUI V0, -24576
9D012454  24420574   ADDIU V0, V0, 1396
9D012458  8C44001C   LW A0, 28(V0)
9D01245C  3C029D03   LUI V0, -25341
9D012460  00042080   SLL A0, A0, 2
9D012464  244213E4   ADDIU V0, V0, 5092
9D012468  00821021   ADDU V0, A0, V0
9D01246C  8C420000   LW V0, 0(V0)
9D012470  00602021   ADDU A0, V1, ZERO
9D012474  00402821   ADDU A1, V0, ZERO
9D012478  0F4005FD   JAL TCPPutString
9D01247C  00000000   NOP
826:                 			
827:                 			// If this is a redirect, print the rest of the Location: header			   
828:                 			if(curHTTP.httpStatus == HTTP_REDIRECT)
9D012480  3C02A000   LUI V0, -24576
9D012484  24420574   ADDIU V0, V0, 1396
9D012488  8C43001C   LW V1, 28(V0)
9D01248C  24020008   ADDIU V0, ZERO, 8
9D012490  14620033   BNE V1, V0, 0x9D012560
9D012494  00000000   NOP
829:                 			{
830:                 				TCPPutString(sktHTTP, curHTTP.data);
9D012498  938281E8   LBU V0, -32280(GP)
9D01249C  00401821   ADDU V1, V0, ZERO
9D0124A0  3C02A000   LUI V0, -24576
9D0124A4  000318C0   SLL V1, V1, 3
9D0124A8  24420600   ADDIU V0, V0, 1536
9D0124AC  00621021   ADDU V0, V1, V0
9D0124B0  90420004   LBU V0, 4(V0)
9D0124B4  00402021   ADDU A0, V0, ZERO
9D0124B8  3C02A000   LUI V0, -24576
9D0124BC  24450598   ADDIU A1, V0, 1432
9D0124C0  0F4005FD   JAL TCPPutString
9D0124C4  00000000   NOP
831:                 				TCPPutROMString(sktHTTP, (ROM BYTE*)"\r\n\r\n304 Redirect: ");
9D0124C8  938281E8   LBU V0, -32280(GP)
9D0124CC  00401821   ADDU V1, V0, ZERO
9D0124D0  3C02A000   LUI V0, -24576
9D0124D4  000318C0   SLL V1, V1, 3
9D0124D8  24420600   ADDIU V0, V0, 1536
9D0124DC  00621021   ADDU V0, V1, V0
9D0124E0  90420004   LBU V0, 4(V0)
9D0124E4  00401821   ADDU V1, V0, ZERO
9D0124E8  3C029D03   LUI V0, -25341
9D0124EC  24421458   ADDIU V0, V0, 5208
9D0124F0  00602021   ADDU A0, V1, ZERO
9D0124F4  00402821   ADDU A1, V0, ZERO
9D0124F8  0F4005FD   JAL TCPPutString
9D0124FC  00000000   NOP
832:                 				TCPPutString(sktHTTP, curHTTP.data);
9D012500  938281E8   LBU V0, -32280(GP)
9D012504  00401821   ADDU V1, V0, ZERO
9D012508  3C02A000   LUI V0, -24576
9D01250C  000318C0   SLL V1, V1, 3
9D012510  24420600   ADDIU V0, V0, 1536
9D012514  00621021   ADDU V0, V1, V0
9D012518  90420004   LBU V0, 4(V0)
9D01251C  00402021   ADDU A0, V0, ZERO
9D012520  3C02A000   LUI V0, -24576
9D012524  24450598   ADDIU A1, V0, 1432
9D012528  0F4005FD   JAL TCPPutString
9D01252C  00000000   NOP
833:                 				TCPPutROMString(sktHTTP, (ROM BYTE*)HTTP_CRLF);
9D012530  938281E8   LBU V0, -32280(GP)
9D012534  00401821   ADDU V1, V0, ZERO
9D012538  3C02A000   LUI V0, -24576
9D01253C  000318C0   SLL V1, V1, 3
9D012540  24420600   ADDIU V0, V0, 1536
9D012544  00621021   ADDU V0, V1, V0
9D012548  90420004   LBU V0, 4(V0)
9D01254C  00402021   ADDU A0, V0, ZERO
9D012550  3C029D03   LUI V0, -25341
9D012554  24450FAC   ADDIU A1, V0, 4012
9D012558  0F4005FD   JAL TCPPutString
9D01255C  00000000   NOP
834:                 			}
835:                 
836:                 			// If not GET or POST, we're done
837:                 			if(curHTTP.httpStatus != HTTP_GET && curHTTP.httpStatus != HTTP_POST)
9D012560  3C02A000   LUI V0, -24576
9D012564  24420574   ADDIU V0, V0, 1396
9D012568  8C42001C   LW V0, 28(V0)
9D01256C  10400011   BEQ V0, ZERO, 0x9D0125B4
9D012570  00000000   NOP
9D012574  3C02A000   LUI V0, -24576
9D012578  24420574   ADDIU V0, V0, 1396
9D01257C  8C43001C   LW V1, 28(V0)
9D012580  24020001   ADDIU V0, ZERO, 1
9D012584  1062000B   BEQ V1, V0, 0x9D0125B4
9D012588  00000000   NOP
838:                 			{// Disconnect
839:                 				smHTTP = SM_HTTP_DISCONNECT;
9D01258C  938281E8   LBU V0, -32280(GP)
9D012590  00401821   ADDU V1, V0, ZERO
9D012594  3C02A000   LUI V0, -24576
9D012598  000318C0   SLL V1, V1, 3
9D01259C  24420600   ADDIU V0, V0, 1536
9D0125A0  00621021   ADDU V0, V1, V0
9D0125A4  2403000B   ADDIU V1, ZERO, 11
9D0125A8  AC430000   SW V1, 0(V0)
840:                 				break;
9D0125AC  0B404BF8   J 0x9D012FE0
9D0125B0  00000000   NOP
841:                 			}
842:                 
843:                 			// Output the content type, if known
844:                 			if(curHTTP.fileType != HTTP_UNKNOWN)
9D0125B4  3C02A000   LUI V0, -24576
9D0125B8  24420574   ADDIU V0, V0, 1396
9D0125BC  8C430020   LW V1, 32(V0)
9D0125C0  2402000B   ADDIU V0, ZERO, 11
9D0125C4  1062002F   BEQ V1, V0, 0x9D012684
9D0125C8  00000000   NOP
845:                 			{
846:                 				TCPPutROMString(sktHTTP, (ROM BYTE*)"Content-Type: ");
9D0125CC  938281E8   LBU V0, -32280(GP)
9D0125D0  00401821   ADDU V1, V0, ZERO
9D0125D4  3C02A000   LUI V0, -24576
9D0125D8  000318C0   SLL V1, V1, 3
9D0125DC  24420600   ADDIU V0, V0, 1536
9D0125E0  00621021   ADDU V0, V1, V0
9D0125E4  90420004   LBU V0, 4(V0)
9D0125E8  00401821   ADDU V1, V0, ZERO
9D0125EC  3C029D03   LUI V0, -25341
9D0125F0  2442146C   ADDIU V0, V0, 5228
9D0125F4  00602021   ADDU A0, V1, ZERO
9D0125F8  00402821   ADDU A1, V0, ZERO
9D0125FC  0F4005FD   JAL TCPPutString
9D012600  00000000   NOP
847:                 				TCPPutROMString(sktHTTP, (ROM BYTE*)httpContentTypes[curHTTP.fileType]);
9D012604  938281E8   LBU V0, -32280(GP)
9D012608  00401821   ADDU V1, V0, ZERO
9D01260C  3C02A000   LUI V0, -24576
9D012610  000318C0   SLL V1, V1, 3
9D012614  24420600   ADDIU V0, V0, 1536
9D012618  00621021   ADDU V0, V1, V0
9D01261C  90420004   LBU V0, 4(V0)
9D012620  00401821   ADDU V1, V0, ZERO
9D012624  3C02A000   LUI V0, -24576
9D012628  24420574   ADDIU V0, V0, 1396
9D01262C  8C440020   LW A0, 32(V0)
9D012630  3C029D03   LUI V0, -25341
9D012634  00042080   SLL A0, A0, 2
9D012638  24421090   ADDIU V0, V0, 4240
9D01263C  00821021   ADDU V0, A0, V0
9D012640  8C420000   LW V0, 0(V0)
9D012644  00602021   ADDU A0, V1, ZERO
9D012648  00402821   ADDU A1, V0, ZERO
9D01264C  0F4005FD   JAL TCPPutString
9D012650  00000000   NOP
848:                 				TCPPutROMString(sktHTTP, HTTP_CRLF);
9D012654  938281E8   LBU V0, -32280(GP)
9D012658  00401821   ADDU V1, V0, ZERO
9D01265C  3C02A000   LUI V0, -24576
9D012660  000318C0   SLL V1, V1, 3
9D012664  24420600   ADDIU V0, V0, 1536
9D012668  00621021   ADDU V0, V1, V0
9D01266C  90420004   LBU V0, 4(V0)
9D012670  00402021   ADDU A0, V0, ZERO
9D012674  3C029D03   LUI V0, -25341
9D012678  24450FAC   ADDIU A1, V0, 4012
9D01267C  0F4005FD   JAL TCPPutString
9D012680  00000000   NOP
849:                 			}
850:                 			
851:                 			// Output the gzip encoding header if needed
852:                 			if(MPFSGetFlags(curHTTP.file) & MPFS2_FLAG_ISZIPPED)
9D012684  3C02A000   LUI V0, -24576
9D012688  24420574   ADDIU V0, V0, 1396
9D01268C  90420018   LBU V0, 24(V0)
9D012690  00402021   ADDU A0, V0, ZERO
9D012694  0F409F50   JAL MPFSGetFlags
9D012698  00000000   NOP
9D01269C  30420001   ANDI V0, V0, 1
9D0126A0  304200FF   ANDI V0, V0, 255
9D0126A4  1040000F   BEQ V0, ZERO, 0x9D0126E4
9D0126A8  00000000   NOP
853:                 			{
854:                 				TCPPutROMString(sktHTTP, (ROM BYTE*)"Content-Encoding: gzip\r\n");
9D0126AC  938281E8   LBU V0, -32280(GP)
9D0126B0  00401821   ADDU V1, V0, ZERO
9D0126B4  3C02A000   LUI V0, -24576
9D0126B8  000318C0   SLL V1, V1, 3
9D0126BC  24420600   ADDIU V0, V0, 1536
9D0126C0  00621021   ADDU V0, V1, V0
9D0126C4  90420004   LBU V0, 4(V0)
9D0126C8  00401821   ADDU V1, V0, ZERO
9D0126CC  3C029D03   LUI V0, -25341
9D0126D0  2442147C   ADDIU V0, V0, 5244
9D0126D4  00602021   ADDU A0, V1, ZERO
9D0126D8  00402821   ADDU A1, V0, ZERO
9D0126DC  0F4005FD   JAL TCPPutString
9D0126E0  00000000   NOP
855:                 			}
856:                 						
857:                 			// Output the cache-control
858:                 			TCPPutROMString(sktHTTP, (ROM BYTE*)"Cache-Control: ");
9D0126E4  938281E8   LBU V0, -32280(GP)
9D0126E8  00401821   ADDU V1, V0, ZERO
9D0126EC  3C02A000   LUI V0, -24576
9D0126F0  000318C0   SLL V1, V1, 3
9D0126F4  24420600   ADDIU V0, V0, 1536
9D0126F8  00621021   ADDU V0, V1, V0
9D0126FC  90420004   LBU V0, 4(V0)
9D012700  00401821   ADDU V1, V0, ZERO
9D012704  3C029D03   LUI V0, -25341
9D012708  24421498   ADDIU V0, V0, 5272
9D01270C  00602021   ADDU A0, V1, ZERO
9D012710  00402821   ADDU A1, V0, ZERO
9D012714  0F4005FD   JAL TCPPutString
9D012718  00000000   NOP
859:                 			if(curHTTP.httpStatus == HTTP_POST || curHTTP.nextCallback != 0xffffffff)
9D01271C  3C02A000   LUI V0, -24576
9D012720  24420574   ADDIU V0, V0, 1396
9D012724  8C43001C   LW V1, 28(V0)
9D012728  24020001   ADDIU V0, ZERO, 1
9D01272C  10620007   BEQ V1, V0, 0x9D01274C
9D012730  00000000   NOP
9D012734  3C02A000   LUI V0, -24576
9D012738  24420574   ADDIU V0, V0, 1396
9D01273C  8C430004   LW V1, 4(V0)
9D012740  2402FFFF   ADDIU V0, ZERO, -1
9D012744  10620011   BEQ V1, V0, 0x9D01278C
9D012748  00000000   NOP
860:                 			{// This is a dynamic page or a POST request, so no cache
861:                 				TCPPutROMString(sktHTTP, (ROM BYTE*)"no-cache");
9D01274C  938281E8   LBU V0, -32280(GP)
9D012750  00401821   ADDU V1, V0, ZERO
9D012754  3C02A000   LUI V0, -24576
9D012758  000318C0   SLL V1, V1, 3
9D01275C  24420600   ADDIU V0, V0, 1536
9D012760  00621021   ADDU V0, V1, V0
9D012764  90420004   LBU V0, 4(V0)
9D012768  00401821   ADDU V1, V0, ZERO
9D01276C  3C029D03   LUI V0, -25341
9D012770  244214A8   ADDIU V0, V0, 5288
9D012774  00602021   ADDU A0, V1, ZERO
9D012778  00402821   ADDU A1, V0, ZERO
9D01277C  0F4005FD   JAL TCPPutString
9D012780  00000000   NOP
9D012784  0B4049FF   J 0x9D0127FC
9D012788  00000000   NOP
862:                 			}
863:                 			else
864:                 			{// This is a static page, so save it for the specified amount of time
865:                 				TCPPutROMString(sktHTTP, (ROM BYTE*)"max-age=");
9D01278C  938281E8   LBU V0, -32280(GP)
9D012790  00401821   ADDU V1, V0, ZERO
9D012794  3C02A000   LUI V0, -24576
9D012798  000318C0   SLL V1, V1, 3
9D01279C  24420600   ADDIU V0, V0, 1536
9D0127A0  00621021   ADDU V0, V1, V0
9D0127A4  90420004   LBU V0, 4(V0)
9D0127A8  00401821   ADDU V1, V0, ZERO
9D0127AC  3C029D03   LUI V0, -25341
9D0127B0  244214B4   ADDIU V0, V0, 5300
9D0127B4  00602021   ADDU A0, V1, ZERO
9D0127B8  00402821   ADDU A1, V0, ZERO
9D0127BC  0F4005FD   JAL TCPPutString
9D0127C0  00000000   NOP
866:                 				TCPPutROMString(sktHTTP, (ROM BYTE*)HTTP_CACHE_LEN);
9D0127C4  938281E8   LBU V0, -32280(GP)
9D0127C8  00401821   ADDU V1, V0, ZERO
9D0127CC  3C02A000   LUI V0, -24576
9D0127D0  000318C0   SLL V1, V1, 3
9D0127D4  24420600   ADDIU V0, V0, 1536
9D0127D8  00621021   ADDU V0, V1, V0
9D0127DC  90420004   LBU V0, 4(V0)
9D0127E0  00401821   ADDU V1, V0, ZERO
9D0127E4  3C029D03   LUI V0, -25341
9D0127E8  244214C0   ADDIU V0, V0, 5312
9D0127EC  00602021   ADDU A0, V1, ZERO
9D0127F0  00402821   ADDU A1, V0, ZERO
9D0127F4  0F4005FD   JAL TCPPutString
9D0127F8  00000000   NOP
867:                 			}
868:                 			TCPPutROMString(sktHTTP, HTTP_CRLF);
9D0127FC  938281E8   LBU V0, -32280(GP)
9D012800  00401821   ADDU V1, V0, ZERO
9D012804  3C02A000   LUI V0, -24576
9D012808  000318C0   SLL V1, V1, 3
9D01280C  24420600   ADDIU V0, V0, 1536
9D012810  00621021   ADDU V0, V1, V0
9D012814  90420004   LBU V0, 4(V0)
9D012818  00402021   ADDU A0, V0, ZERO
9D01281C  3C029D03   LUI V0, -25341
9D012820  24450FAC   ADDIU A1, V0, 4012
9D012824  0F4005FD   JAL TCPPutString
9D012828  00000000   NOP
869:                 			
870:                 			// Check if we should output cookies
871:                 			if(curHTTP.hasArgs)
9D01282C  3C02A000   LUI V0, -24576
9D012830  24420574   ADDIU V0, V0, 1396
9D012834  9042001A   LBU V0, 26(V0)
9D012838  1040000B   BEQ V0, ZERO, 0x9D012868
9D01283C  00000000   NOP
872:                 				smHTTP = SM_HTTP_SERVE_COOKIES;
9D012840  938281E8   LBU V0, -32280(GP)
9D012844  00401821   ADDU V1, V0, ZERO
9D012848  3C02A000   LUI V0, -24576
9D01284C  000318C0   SLL V1, V1, 3
9D012850  24420600   ADDIU V0, V0, 1536
9D012854  00621021   ADDU V0, V1, V0
9D012858  24030008   ADDIU V1, ZERO, 8
9D01285C  AC430000   SW V1, 0(V0)
9D012860  0B404A2E   J 0x9D0128B8
9D012864  00000000   NOP
873:                 			else
874:                 			{// Terminate the headers
875:                 				TCPPutROMString(sktHTTP, HTTP_CRLF);
9D012868  938281E8   LBU V0, -32280(GP)
9D01286C  00401821   ADDU V1, V0, ZERO
9D012870  3C02A000   LUI V0, -24576
9D012874  000318C0   SLL V1, V1, 3
9D012878  24420600   ADDIU V0, V0, 1536
9D01287C  00621021   ADDU V0, V1, V0
9D012880  90420004   LBU V0, 4(V0)
9D012884  00402021   ADDU A0, V0, ZERO
9D012888  3C029D03   LUI V0, -25341
9D01288C  24450FAC   ADDIU A1, V0, 4012
9D012890  0F4005FD   JAL TCPPutString
9D012894  00000000   NOP
876:                 				smHTTP = SM_HTTP_SERVE_BODY;
9D012898  938281E8   LBU V0, -32280(GP)
9D01289C  00401821   ADDU V1, V0, ZERO
9D0128A0  3C02A000   LUI V0, -24576
9D0128A4  000318C0   SLL V1, V1, 3
9D0128A8  24420600   ADDIU V0, V0, 1536
9D0128AC  00621021   ADDU V0, V1, V0
9D0128B0  24030009   ADDIU V1, ZERO, 9
9D0128B4  AC430000   SW V1, 0(V0)
877:                 			}
878:                 	
879:                 			// Move to next stage
880:                 			isDone = FALSE;
9D0128B8  AFC00020   SW ZERO, 32(S8)
881:                 			break;
9D0128BC  0B404BF8   J 0x9D012FE0
9D0128C0  00000000   NOP
882:                 
883:                 		case SM_HTTP_SERVE_COOKIES:
884:                 
885:                 			#if defined(HTTP_USE_COOKIES)
886:                 			// If the TX FIFO runs out of space, the client will never get CRLFCRLF
887:                 			// Avoid writing huge cookies - keep it under a hundred bytes max
888:                 
889:                 			// Write cookies one at a time as space permits
890:                 			for(curHTTP.ptrRead = curHTTP.data; curHTTP.hasArgs != 0u; curHTTP.hasArgs--)
9D0128C4  3C02A000   LUI V0, -24576
9D0128C8  24420574   ADDIU V0, V0, 1396
9D0128CC  3C03A000   LUI V1, -24576
9D0128D0  24630598   ADDIU V1, V1, 1432
9D0128D4  AC430014   SW V1, 20(V0)
9D0128D8  0B404B4B   J 0x9D012D2C
9D0128DC  00000000   NOP
9D012D0C  3C02A000   LUI V0, -24576
9D012D10  24420574   ADDIU V0, V0, 1396
9D012D14  9042001A   LBU V0, 26(V0)
9D012D18  2442FFFF   ADDIU V0, V0, -1
9D012D1C  304300FF   ANDI V1, V0, 255
9D012D20  3C02A000   LUI V0, -24576
9D012D24  24420574   ADDIU V0, V0, 1396
9D012D28  A043001A   SB V1, 26(V0)
9D012D2C  3C02A000   LUI V0, -24576
9D012D30  24420574   ADDIU V0, V0, 1396
9D012D34  9042001A   LBU V0, 26(V0)
9D012D38  1440FEE9   BNE V0, ZERO, 0x9D0128E0
9D012D3C  00000000   NOP
891:                 			{
892:                 				// Write the header
893:                 				TCPPutROMString(sktHTTP, (ROM BYTE*)"Set-Cookie: ");
9D0128E0  938281E8   LBU V0, -32280(GP)
9D0128E4  00401821   ADDU V1, V0, ZERO
9D0128E8  3C02A000   LUI V0, -24576
9D0128EC  000318C0   SLL V1, V1, 3
9D0128F0  24420600   ADDIU V0, V0, 1536
9D0128F4  00621021   ADDU V0, V1, V0
9D0128F8  90420004   LBU V0, 4(V0)
9D0128FC  00401821   ADDU V1, V0, ZERO
9D012900  3C029D03   LUI V0, -25341
9D012904  244214C4   ADDIU V0, V0, 5316
9D012908  00602021   ADDU A0, V1, ZERO
9D01290C  00402821   ADDU A1, V0, ZERO
9D012910  0F4005FD   JAL TCPPutString
9D012914  00000000   NOP
894:                 
895:                 				// Write the name, URL encoded, one character at a time
896:                 				while((c = *(curHTTP.ptrRead++)))
9D012918  0B404AAB   J 0x9D012AAC
9D01291C  00000000   NOP
9D012AAC  3C02A000   LUI V0, -24576
9D012AB0  24420574   ADDIU V0, V0, 1396
9D012AB4  8C420014   LW V0, 20(V0)
9D012AB8  90430000   LBU V1, 0(V0)
9D012ABC  A3C30028   SB V1, 40(S8)
9D012AC0  93C30028   LBU V1, 40(S8)
9D012AC4  0003182B   SLTU V1, ZERO, V1
9D012AC8  306300FF   ANDI V1, V1, 255
9D012ACC  24440001   ADDIU A0, V0, 1
9D012AD0  3C02A000   LUI V0, -24576
9D012AD4  24420574   ADDIU V0, V0, 1396
9D012AD8  AC440014   SW A0, 20(V0)
9D012ADC  1460FF90   BNE V1, ZERO, 0x9D012920
9D012AE0  00000000   NOP
897:                 				{
898:                 					if(c == ' ')
9D012920  93C30028   LBU V1, 40(S8)
9D012924  24020020   ADDIU V0, ZERO, 32
9D012928  1462000E   BNE V1, V0, 0x9D012964
9D01292C  00000000   NOP
899:                 						TCPPut(sktHTTP, '+');
9D012930  938281E8   LBU V0, -32280(GP)
9D012934  00401821   ADDU V1, V0, ZERO
9D012938  3C02A000   LUI V0, -24576
9D01293C  000318C0   SLL V1, V1, 3
9D012940  24420600   ADDIU V0, V0, 1536
9D012944  00621021   ADDU V0, V1, V0
9D012948  90420004   LBU V0, 4(V0)
9D01294C  00402021   ADDU A0, V0, ZERO
9D012950  2405002B   ADDIU A1, ZERO, 43
9D012954  0F40040C   JAL TCPPut
9D012958  00000000   NOP
9D01295C  0B404AAB   J 0x9D012AAC
9D012960  00000000   NOP
900:                 					else if(c < '0' || (c > '9' && c < 'A') || (c > 'Z' && c < 'a') || c > 'z')
9D012964  93C20028   LBU V0, 40(S8)
9D012968  2C420030   SLTIU V0, V0, 48
9D01296C  14400015   BNE V0, ZERO, 0x9D0129C4
9D012970  00000000   NOP
9D012974  93C20028   LBU V0, 40(S8)
9D012978  2C42003A   SLTIU V0, V0, 58
9D01297C  14400005   BNE V0, ZERO, 0x9D012994
9D012980  00000000   NOP
9D012984  93C20028   LBU V0, 40(S8)
9D012988  2C420041   SLTIU V0, V0, 65
9D01298C  1440000D   BNE V0, ZERO, 0x9D0129C4
9D012990  00000000   NOP
9D012994  93C20028   LBU V0, 40(S8)
9D012998  2C42005B   SLTIU V0, V0, 91
9D01299C  14400005   BNE V0, ZERO, 0x9D0129B4
9D0129A0  00000000   NOP
9D0129A4  93C20028   LBU V0, 40(S8)
9D0129A8  2C420061   SLTIU V0, V0, 97
9D0129AC  14400005   BNE V0, ZERO, 0x9D0129C4
9D0129B0  00000000   NOP
9D0129B4  93C20028   LBU V0, 40(S8)
9D0129B8  2C42007B   SLTIU V0, V0, 123
9D0129BC  1440002E   BNE V0, ZERO, 0x9D012A78
9D0129C0  00000000   NOP
901:                 					{
902:                 						TCPPut(sktHTTP, '%');
9D0129C4  938281E8   LBU V0, -32280(GP)
9D0129C8  00401821   ADDU V1, V0, ZERO
9D0129CC  3C02A000   LUI V0, -24576
9D0129D0  000318C0   SLL V1, V1, 3
9D0129D4  24420600   ADDIU V0, V0, 1536
9D0129D8  00621021   ADDU V0, V1, V0
9D0129DC  90420004   LBU V0, 4(V0)
9D0129E0  00402021   ADDU A0, V0, ZERO
9D0129E4  24050025   ADDIU A1, ZERO, 37
9D0129E8  0F40040C   JAL TCPPut
9D0129EC  00000000   NOP
903:                 						TCPPut(sktHTTP, btohexa_high(c));
9D0129F0  938281E8   LBU V0, -32280(GP)
9D0129F4  00401821   ADDU V1, V0, ZERO
9D0129F8  3C02A000   LUI V0, -24576
9D0129FC  000318C0   SLL V1, V1, 3
9D012A00  24420600   ADDIU V0, V0, 1536
9D012A04  00621021   ADDU V0, V1, V0
9D012A08  90420004   LBU V0, 4(V0)
9D012A0C  00408021   ADDU S0, V0, ZERO
9D012A10  93C20028   LBU V0, 40(S8)
9D012A14  00402021   ADDU A0, V0, ZERO
9D012A18  0F409989   JAL btohexa_high
9D012A1C  00000000   NOP
9D012A20  02002021   ADDU A0, S0, ZERO
9D012A24  00402821   ADDU A1, V0, ZERO
9D012A28  0F40040C   JAL TCPPut
9D012A2C  00000000   NOP
904:                 						TCPPut(sktHTTP, btohexa_low(c));
9D012A30  938281E8   LBU V0, -32280(GP)
9D012A34  00401821   ADDU V1, V0, ZERO
9D012A38  3C02A000   LUI V0, -24576
9D012A3C  000318C0   SLL V1, V1, 3
9D012A40  24420600   ADDIU V0, V0, 1536
9D012A44  00621021   ADDU V0, V1, V0
9D012A48  90420004   LBU V0, 4(V0)
9D012A4C  00408021   ADDU S0, V0, ZERO
9D012A50  93C20028   LBU V0, 40(S8)
9D012A54  00402021   ADDU A0, V0, ZERO
9D012A58  0F4099A2   JAL btohexa_low
9D012A5C  00000000   NOP
9D012A60  02002021   ADDU A0, S0, ZERO
9D012A64  00402821   ADDU A1, V0, ZERO
9D012A68  0F40040C   JAL TCPPut
9D012A6C  00000000   NOP
9D012A70  0B404AAB   J 0x9D012AAC
9D012A74  00000000   NOP
905:                 					}
906:                 					else
907:                 						TCPPut(sktHTTP, c);
9D012A78  938281E8   LBU V0, -32280(GP)
9D012A7C  00401821   ADDU V1, V0, ZERO
9D012A80  3C02A000   LUI V0, -24576
9D012A84  000318C0   SLL V1, V1, 3
9D012A88  24420600   ADDIU V0, V0, 1536
9D012A8C  00621021   ADDU V0, V1, V0
9D012A90  90420004   LBU V0, 4(V0)
9D012A94  00401821   ADDU V1, V0, ZERO
9D012A98  93C20028   LBU V0, 40(S8)
9D012A9C  00602021   ADDU A0, V1, ZERO
9D012AA0  00402821   ADDU A1, V0, ZERO
9D012AA4  0F40040C   JAL TCPPut
9D012AA8  00000000   NOP
908:                 				}
909:                 				
910:                 				TCPPut(sktHTTP, '=');
9D012AE4  938281E8   LBU V0, -32280(GP)
9D012AE8  00401821   ADDU V1, V0, ZERO
9D012AEC  3C02A000   LUI V0, -24576
9D012AF0  000318C0   SLL V1, V1, 3
9D012AF4  24420600   ADDIU V0, V0, 1536
9D012AF8  00621021   ADDU V0, V1, V0
9D012AFC  90420004   LBU V0, 4(V0)
9D012B00  00402021   ADDU A0, V0, ZERO
9D012B04  2405003D   ADDIU A1, ZERO, 61
9D012B08  0F40040C   JAL TCPPut
9D012B0C  00000000   NOP
911:                 				
912:                 				// Write the value, URL encoded, one character at a time
913:                 				while((c = *(curHTTP.ptrRead++)))
9D012B10  0B404B29   J 0x9D012CA4
9D012B14  00000000   NOP
9D012CA4  3C02A000   LUI V0, -24576
9D012CA8  24420574   ADDIU V0, V0, 1396
9D012CAC  8C420014   LW V0, 20(V0)
9D012CB0  90430000   LBU V1, 0(V0)
9D012CB4  A3C30028   SB V1, 40(S8)
9D012CB8  93C30028   LBU V1, 40(S8)
9D012CBC  0003182B   SLTU V1, ZERO, V1
9D012CC0  306300FF   ANDI V1, V1, 255
9D012CC4  24440001   ADDIU A0, V0, 1
9D012CC8  3C02A000   LUI V0, -24576
9D012CCC  24420574   ADDIU V0, V0, 1396
9D012CD0  AC440014   SW A0, 20(V0)
9D012CD4  1460FF90   BNE V1, ZERO, 0x9D012B18
9D012CD8  00000000   NOP
914:                 				{
915:                 					if(c == ' ')
9D012B18  93C30028   LBU V1, 40(S8)
9D012B1C  24020020   ADDIU V0, ZERO, 32
9D012B20  1462000E   BNE V1, V0, 0x9D012B5C
9D012B24  00000000   NOP
916:                 						TCPPut(sktHTTP, '+');
9D012B28  938281E8   LBU V0, -32280(GP)
9D012B2C  00401821   ADDU V1, V0, ZERO
9D012B30  3C02A000   LUI V0, -24576
9D012B34  000318C0   SLL V1, V1, 3
9D012B38  24420600   ADDIU V0, V0, 1536
9D012B3C  00621021   ADDU V0, V1, V0
9D012B40  90420004   LBU V0, 4(V0)
9D012B44  00402021   ADDU A0, V0, ZERO
9D012B48  2405002B   ADDIU A1, ZERO, 43
9D012B4C  0F40040C   JAL TCPPut
9D012B50  00000000   NOP
9D012B54  0B404B29   J 0x9D012CA4
9D012B58  00000000   NOP
917:                 					else if(c < '0' || (c > '9' && c < 'A') || (c > 'Z' && c < 'a') || c > 'z')
9D012B5C  93C20028   LBU V0, 40(S8)
9D012B60  2C420030   SLTIU V0, V0, 48
9D012B64  14400015   BNE V0, ZERO, 0x9D012BBC
9D012B68  00000000   NOP
9D012B6C  93C20028   LBU V0, 40(S8)
9D012B70  2C42003A   SLTIU V0, V0, 58
9D012B74  14400005   BNE V0, ZERO, 0x9D012B8C
9D012B78  00000000   NOP
9D012B7C  93C20028   LBU V0, 40(S8)
9D012B80  2C420041   SLTIU V0, V0, 65
9D012B84  1440000D   BNE V0, ZERO, 0x9D012BBC
9D012B88  00000000   NOP
9D012B8C  93C20028   LBU V0, 40(S8)
9D012B90  2C42005B   SLTIU V0, V0, 91
9D012B94  14400005   BNE V0, ZERO, 0x9D012BAC
9D012B98  00000000   NOP
9D012B9C  93C20028   LBU V0, 40(S8)
9D012BA0  2C420061   SLTIU V0, V0, 97
9D012BA4  14400005   BNE V0, ZERO, 0x9D012BBC
9D012BA8  00000000   NOP
9D012BAC  93C20028   LBU V0, 40(S8)
9D012BB0  2C42007B   SLTIU V0, V0, 123
9D012BB4  1440002E   BNE V0, ZERO, 0x9D012C70
9D012BB8  00000000   NOP
918:                 					{
919:                 						TCPPut(sktHTTP, '%');
9D012BBC  938281E8   LBU V0, -32280(GP)
9D012BC0  00401821   ADDU V1, V0, ZERO
9D012BC4  3C02A000   LUI V0, -24576
9D012BC8  000318C0   SLL V1, V1, 3
9D012BCC  24420600   ADDIU V0, V0, 1536
9D012BD0  00621021   ADDU V0, V1, V0
9D012BD4  90420004   LBU V0, 4(V0)
9D012BD8  00402021   ADDU A0, V0, ZERO
9D012BDC  24050025   ADDIU A1, ZERO, 37
9D012BE0  0F40040C   JAL TCPPut
9D012BE4  00000000   NOP
920:                 						TCPPut(sktHTTP, btohexa_high(c));
9D012BE8  938281E8   LBU V0, -32280(GP)
9D012BEC  00401821   ADDU V1, V0, ZERO
9D012BF0  3C02A000   LUI V0, -24576
9D012BF4  000318C0   SLL V1, V1, 3
9D012BF8  24420600   ADDIU V0, V0, 1536
9D012BFC  00621021   ADDU V0, V1, V0
9D012C00  90420004   LBU V0, 4(V0)
9D012C04  00408021   ADDU S0, V0, ZERO
9D012C08  93C20028   LBU V0, 40(S8)
9D012C0C  00402021   ADDU A0, V0, ZERO
9D012C10  0F409989   JAL btohexa_high
9D012C14  00000000   NOP
9D012C18  02002021   ADDU A0, S0, ZERO
9D012C1C  00402821   ADDU A1, V0, ZERO
9D012C20  0F40040C   JAL TCPPut
9D012C24  00000000   NOP
921:                 						TCPPut(sktHTTP, btohexa_low(c));
9D012C28  938281E8   LBU V0, -32280(GP)
9D012C2C  00401821   ADDU V1, V0, ZERO
9D012C30  3C02A000   LUI V0, -24576
9D012C34  000318C0   SLL V1, V1, 3
9D012C38  24420600   ADDIU V0, V0, 1536
9D012C3C  00621021   ADDU V0, V1, V0
9D012C40  90420004   LBU V0, 4(V0)
9D012C44  00408021   ADDU S0, V0, ZERO
9D012C48  93C20028   LBU V0, 40(S8)
9D012C4C  00402021   ADDU A0, V0, ZERO
9D012C50  0F4099A2   JAL btohexa_low
9D012C54  00000000   NOP
9D012C58  02002021   ADDU A0, S0, ZERO
9D012C5C  00402821   ADDU A1, V0, ZERO
9D012C60  0F40040C   JAL TCPPut
9D012C64  00000000   NOP
9D012C68  0B404B29   J 0x9D012CA4
9D012C6C  00000000   NOP
922:                 					}
923:                 					else
924:                 						TCPPut(sktHTTP, c);
9D012C70  938281E8   LBU V0, -32280(GP)
9D012C74  00401821   ADDU V1, V0, ZERO
9D012C78  3C02A000   LUI V0, -24576
9D012C7C  000318C0   SLL V1, V1, 3
9D012C80  24420600   ADDIU V0, V0, 1536
9D012C84  00621021   ADDU V0, V1, V0
9D012C88  90420004   LBU V0, 4(V0)
9D012C8C  00401821   ADDU V1, V0, ZERO
9D012C90  93C20028   LBU V0, 40(S8)
9D012C94  00602021   ADDU A0, V1, ZERO
9D012C98  00402821   ADDU A1, V0, ZERO
9D012C9C  0F40040C   JAL TCPPut
9D012CA0  00000000   NOP
925:                 				}
926:                 				
927:                 				// Finish the line
928:                 				TCPPutROMString(sktHTTP, HTTP_CRLF);
9D012CDC  938281E8   LBU V0, -32280(GP)
9D012CE0  00401821   ADDU V1, V0, ZERO
9D012CE4  3C02A000   LUI V0, -24576
9D012CE8  000318C0   SLL V1, V1, 3
9D012CEC  24420600   ADDIU V0, V0, 1536
9D012CF0  00621021   ADDU V0, V1, V0
9D012CF4  90420004   LBU V0, 4(V0)
9D012CF8  00402021   ADDU A0, V0, ZERO
9D012CFC  3C029D03   LUI V0, -25341
9D012D00  24450FAC   ADDIU A1, V0, 4012
9D012D04  0F4005FD   JAL TCPPutString
9D012D08  00000000   NOP
929:                 
930:                 			}
931:                 			#endif
932:                 
933:                 			// We're done, move to next state
934:                 			TCPPutROMString(sktHTTP, HTTP_CRLF);
9D012D40  938281E8   LBU V0, -32280(GP)
9D012D44  00401821   ADDU V1, V0, ZERO
9D012D48  3C02A000   LUI V0, -24576
9D012D4C  000318C0   SLL V1, V1, 3
9D012D50  24420600   ADDIU V0, V0, 1536
9D012D54  00621021   ADDU V0, V1, V0
9D012D58  90420004   LBU V0, 4(V0)
9D012D5C  00402021   ADDU A0, V0, ZERO
9D012D60  3C029D03   LUI V0, -25341
9D012D64  24450FAC   ADDIU A1, V0, 4012
9D012D68  0F4005FD   JAL TCPPutString
9D012D6C  00000000   NOP
935:                 			smHTTP = SM_HTTP_SERVE_BODY;
9D012D70  938281E8   LBU V0, -32280(GP)
9D012D74  00401821   ADDU V1, V0, ZERO
9D012D78  3C02A000   LUI V0, -24576
9D012D7C  000318C0   SLL V1, V1, 3
9D012D80  24420600   ADDIU V0, V0, 1536
9D012D84  00621021   ADDU V0, V1, V0
9D012D88  24030009   ADDIU V1, ZERO, 9
9D012D8C  AC430000   SW V1, 0(V0)
936:                 
937:                 		case SM_HTTP_SERVE_BODY:
938:                 
939:                 			isDone = FALSE;
9D012D90  AFC00020   SW ZERO, 32(S8)
940:                 
941:                 			// Try to send next packet
942:                 			if(HTTPSendFile())
9D012D94  0F404C02   JAL 0x9D013008
9D012D98  00000000   NOP
9D012D9C  10400015   BEQ V0, ZERO, 0x9D012DF4
9D012DA0  00000000   NOP
943:                 			{// If EOF, then we're done so close and disconnect
944:                 				MPFSClose(curHTTP.file);
9D012DA4  3C02A000   LUI V0, -24576
9D012DA8  24420574   ADDIU V0, V0, 1396
9D012DAC  90420018   LBU V0, 24(V0)
9D012DB0  00402021   ADDU A0, V0, ZERO
9D012DB4  0F409CA1   JAL MPFSClose
9D012DB8  00000000   NOP
945:                 				curHTTP.file = MPFS_INVALID_HANDLE;
9D012DBC  3C02A000   LUI V0, -24576
9D012DC0  24420574   ADDIU V0, V0, 1396
9D012DC4  2403FFFF   ADDIU V1, ZERO, -1
9D012DC8  A0430018   SB V1, 24(V0)
946:                 				smHTTP = SM_HTTP_DISCONNECT;
9D012DCC  938281E8   LBU V0, -32280(GP)
9D012DD0  00401821   ADDU V1, V0, ZERO
9D012DD4  3C02A000   LUI V0, -24576
9D012DD8  000318C0   SLL V1, V1, 3
9D012DDC  24420600   ADDIU V0, V0, 1536
9D012DE0  00621021   ADDU V0, V1, V0
9D012DE4  2403000B   ADDIU V1, ZERO, 11
9D012DE8  AC430000   SW V1, 0(V0)
947:                 				isDone = TRUE;
9D012DEC  24020001   ADDIU V0, ZERO, 1
9D012DF0  AFC20020   SW V0, 32(S8)
948:                 			}
949:                 			
950:                 			// If the TX FIFO is full, then return to main app loop
951:                 			if(TCPIsPutReady(sktHTTP) == 0u)
9D012DF4  938281E8   LBU V0, -32280(GP)
9D012DF8  00401821   ADDU V1, V0, ZERO
9D012DFC  3C02A000   LUI V0, -24576
9D012E00  000318C0   SLL V1, V1, 3
9D012E04  24420600   ADDIU V0, V0, 1536
9D012E08  00621021   ADDU V0, V1, V0
9D012E0C  90420004   LBU V0, 4(V0)
9D012E10  00402021   ADDU A0, V0, ZERO
9D012E14  0F40038E   JAL TCPIsPutReady
9D012E18  00000000   NOP
9D012E1C  14400069   BNE V0, ZERO, 0x9D012FC4
9D012E20  00000000   NOP
952:                 				isDone = TRUE;
9D012E24  24020001   ADDIU V0, ZERO, 1
9D012E28  AFC20020   SW V0, 32(S8)
953:                             break;
9D012E2C  0B404BF8   J 0x9D012FE0
9D012E30  00000000   NOP
9D012FC4  00000000   NOP
9D012FC8  0B404BF8   J 0x9D012FE0
9D012FCC  00000000   NOP
954:                 
955:                 		case SM_HTTP_SEND_FROM_CALLBACK:
956:                 
957:                 			isDone = TRUE;
9D012E34  24020001   ADDIU V0, ZERO, 1
9D012E38  AFC20020   SW V0, 32(S8)
958:                 
959:                 			// Check that at least the minimum bytes are free
960:                 			if(TCPIsPutReady(sktHTTP) < HTTP_MIN_CALLBACK_FREE)
9D012E3C  938281E8   LBU V0, -32280(GP)
9D012E40  00401821   ADDU V1, V0, ZERO
9D012E44  3C02A000   LUI V0, -24576
9D012E48  000318C0   SLL V1, V1, 3
9D012E4C  24420600   ADDIU V0, V0, 1536
9D012E50  00621021   ADDU V0, V1, V0
9D012E54  90420004   LBU V0, 4(V0)
9D012E58  00402021   ADDU A0, V0, ZERO
9D012E5C  0F40038E   JAL TCPIsPutReady
9D012E60  00000000   NOP
9D012E64  2C420010   SLTIU V0, V0, 16
9D012E68  14400059   BNE V0, ZERO, 0x9D012FD0
9D012E6C  00000000   NOP
961:                 				break;
9D012FD0  00000000   NOP
9D012FD4  0B404BF8   J 0x9D012FE0
9D012FD8  00000000   NOP
962:                 
963:                 			// Fill TX FIFO from callback
964:                 			HTTPPrint(curHTTP.callbackID);
9D012E70  3C02A000   LUI V0, -24576
9D012E74  24420574   ADDIU V0, V0, 1396
9D012E78  8C420008   LW V0, 8(V0)
9D012E7C  00402021   ADDU A0, V0, ZERO
9D012E80  0F404231   JAL HTTPPrint
9D012E84  00000000   NOP
965:                 			
966:                 			if(curHTTP.callbackPos == 0u)
9D012E88  3C02A000   LUI V0, -24576
9D012E8C  24420574   ADDIU V0, V0, 1396
9D012E90  8C42000C   LW V0, 12(V0)
9D012E94  14400051   BNE V0, ZERO, 0x9D012FDC
9D012E98  00000000   NOP
967:                 			{// Callback finished its output, so move on
968:                 				isDone = FALSE;
9D012E9C  AFC00020   SW ZERO, 32(S8)
969:                 				smHTTP = SM_HTTP_SERVE_BODY;
9D012EA0  938281E8   LBU V0, -32280(GP)
9D012EA4  00401821   ADDU V1, V0, ZERO
9D012EA8  3C02A000   LUI V0, -24576
9D012EAC  000318C0   SLL V1, V1, 3
9D012EB0  24420600   ADDIU V0, V0, 1536
9D012EB4  00621021   ADDU V0, V1, V0
9D012EB8  24030009   ADDIU V1, ZERO, 9
9D012EBC  AC430000   SW V1, 0(V0)
970:                 			}// Otherwise, callback needs more buffer space, so return and wait
971:                 			
972:                 			break;
9D012EC0  0B404BF8   J 0x9D012FE0
9D012EC4  00000000   NOP
9D012FDC  00000000   NOP
973:                 
974:                 		case SM_HTTP_DISCONNECT:
975:                 			// Make sure any opened files are closed
976:                 			if(curHTTP.file != MPFS_INVALID_HANDLE)
9D012EC8  3C02A000   LUI V0, -24576
9D012ECC  24420574   ADDIU V0, V0, 1396
9D012ED0  90430018   LBU V1, 24(V0)
9D012ED4  240200FF   ADDIU V0, ZERO, 255
9D012ED8  1062000B   BEQ V1, V0, 0x9D012F08
9D012EDC  00000000   NOP
977:                 			{
978:                 				MPFSClose(curHTTP.file);
9D012EE0  3C02A000   LUI V0, -24576
9D012EE4  24420574   ADDIU V0, V0, 1396
9D012EE8  90420018   LBU V0, 24(V0)
9D012EEC  00402021   ADDU A0, V0, ZERO
9D012EF0  0F409CA1   JAL MPFSClose
9D012EF4  00000000   NOP
979:                 				curHTTP.file = MPFS_INVALID_HANDLE;
9D012EF8  3C02A000   LUI V0, -24576
9D012EFC  24420574   ADDIU V0, V0, 1396
9D012F00  2403FFFF   ADDIU V1, ZERO, -1
9D012F04  A0430018   SB V1, 24(V0)
980:                 			}
981:                 			if(curHTTP.offsets != MPFS_INVALID_HANDLE)
9D012F08  3C02A000   LUI V0, -24576
9D012F0C  24420574   ADDIU V0, V0, 1396
9D012F10  90430019   LBU V1, 25(V0)
9D012F14  240200FF   ADDIU V0, ZERO, 255
9D012F18  1062000B   BEQ V1, V0, 0x9D012F48
9D012F1C  00000000   NOP
982:                 			{
983:                 				MPFSClose(curHTTP.offsets);
9D012F20  3C02A000   LUI V0, -24576
9D012F24  24420574   ADDIU V0, V0, 1396
9D012F28  90420019   LBU V0, 25(V0)
9D012F2C  00402021   ADDU A0, V0, ZERO
9D012F30  0F409CA1   JAL MPFSClose
9D012F34  00000000   NOP
984:                 				curHTTP.offsets = MPFS_INVALID_HANDLE;
9D012F38  3C02A000   LUI V0, -24576
9D012F3C  24420574   ADDIU V0, V0, 1396
9D012F40  2403FFFF   ADDIU V1, ZERO, -1
9D012F44  A0430019   SB V1, 25(V0)
985:                 			}
986:                 
987:                 			TCPDisconnect(sktHTTP);
9D012F48  938281E8   LBU V0, -32280(GP)
9D012F4C  00401821   ADDU V1, V0, ZERO
9D012F50  3C02A000   LUI V0, -24576
9D012F54  000318C0   SLL V1, V1, 3
9D012F58  24420600   ADDIU V0, V0, 1536
9D012F5C  00621021   ADDU V0, V1, V0
9D012F60  90420004   LBU V0, 4(V0)
9D012F64  00402021   ADDU A0, V0, ZERO
9D012F68  0F400273   JAL TCPDisconnect
9D012F6C  00000000   NOP
988:                             smHTTP = SM_HTTP_IDLE;
9D012F70  938281E8   LBU V0, -32280(GP)
9D012F74  00401821   ADDU V1, V0, ZERO
9D012F78  3C02A000   LUI V0, -24576
9D012F7C  000318C0   SLL V1, V1, 3
9D012F80  24420600   ADDIU V0, V0, 1536
9D012F84  00621021   ADDU V0, V1, V0
9D012F88  AC400000   SW ZERO, 0(V0)
989:                             break;
9D012F8C  0B404BF8   J 0x9D012FE0
9D012F90  00000000   NOP
990:                 		}
991:                 	} while(!isDone);
9D012FE0  8FC20020   LW V0, 32(S8)
9D012FE4  1040F881   BEQ V0, ZERO, 0x9D0111EC
9D012FE8  00000000   NOP
992:                 
993:                 }
9D012FEC  03C0E821   ADDU SP, S8, ZERO
9D012FF0  8FBF004C   LW RA, 76(SP)
9D012FF4  8FBE0048   LW S8, 72(SP)
9D012FF8  8FB00044   LW S0, 68(SP)
9D012FFC  27BD0050   ADDIU SP, SP, 80
9D013000  03E00008   JR RA
9D013004  00000000   NOP
994:                 
995:                 
996:                 /*****************************************************************************
997:                   Function:
998:                 	static BOOL HTTPSendFile(void)
999:                 
1000:                  Description:
1001:                	Serves up the next chunk of curHTTP's file, up to a) available TX FIFO
1002:                	space or b) the next callback index, whichever comes first.
1003:                
1004:                  Precondition:
1005:                	curHTTP.file and curHTTP.offsets have both been opened for reading.
1006:                
1007:                  Parameters:
1008:                	None
1009:                
1010:                  Return Values:
1011:                	TRUE - the end of the file was reached and reading is done
1012:                	FALSE - more data remains to be read
1013:                  ***************************************************************************/
1014:                static BOOL HTTPSendFile(void)
1015:                {
9D013008  27BDFFA0   ADDIU SP, SP, -96
9D01300C  AFBF005C   SW RA, 92(SP)
9D013010  AFBE0058   SW S8, 88(SP)
9D013014  03A0F021   ADDU S8, SP, ZERO
1016:                	WORD numBytes, len;
1017:                	BYTE c, data[64];
1018:                	
1019:                	// Determine how many bytes we can read right now
1020:                	len = TCPIsPutReady(sktHTTP);
9D013018  938281E8   LBU V0, -32280(GP)
9D01301C  00401821   ADDU V1, V0, ZERO
9D013020  3C02A000   LUI V0, -24576
9D013024  000318C0   SLL V1, V1, 3
9D013028  24420600   ADDIU V0, V0, 1536
9D01302C  00621021   ADDU V0, V1, V0
9D013030  90420004   LBU V0, 4(V0)
9D013034  00402021   ADDU A0, V0, ZERO
9D013038  0F40038E   JAL TCPIsPutReady
9D01303C  00000000   NOP
9D013040  A7C20012   SH V0, 18(S8)
1021:                	numBytes = mMIN(len, curHTTP.nextCallback - curHTTP.byteCount);
9D013044  3C02A000   LUI V0, -24576
9D013048  24420574   ADDIU V0, V0, 1396
9D01304C  8C430004   LW V1, 4(V0)
9D013050  3C02A000   LUI V0, -24576
9D013054  8C420574   LW V0, 1396(V0)
9D013058  00621823   SUBU V1, V1, V0
9D01305C  97C20012   LHU V0, 18(S8)
9D013060  0043202B   SLTU A0, V0, V1
9D013064  0064100A   MOVZ V0, V1, A0
9D013068  A7C20010   SH V0, 16(S8)
1022:                	
1023:                	// Get/put as many bytes as possible
1024:                	curHTTP.byteCount += numBytes;
9D01306C  3C02A000   LUI V0, -24576
9D013070  8C430574   LW V1, 1396(V0)
9D013074  97C20010   LHU V0, 16(S8)
9D013078  00621821   ADDU V1, V1, V0
9D01307C  3C02A000   LUI V0, -24576
9D013080  AC430574   SW V1, 1396(V0)
1025:                	while(numBytes > 0u)
9D013084  0B404C4C   J 0x9D013130
9D013088  00000000   NOP
9D013130  97C20010   LHU V0, 16(S8)
9D013134  1440FFD5   BNE V0, ZERO, 0x9D01308C
9D013138  00000000   NOP
1026:                	{
1027:                		len = MPFSGetArray(curHTTP.file, data, mMIN(numBytes, sizeof(data)));
9D01308C  3C02A000   LUI V0, -24576
9D013090  24420574   ADDIU V0, V0, 1396
9D013094  90420018   LBU V0, 24(V0)
9D013098  00402021   ADDU A0, V0, ZERO
9D01309C  97C20010   LHU V0, 16(S8)
9D0130A0  3043FFFF   ANDI V1, V0, -1
9D0130A4  2C630041   SLTIU V1, V1, 65
9D0130A8  14600002   BNE V1, ZERO, 0x9D0130B4
9D0130AC  00000000   NOP
9D0130B0  24020040   ADDIU V0, ZERO, 64
9D0130B4  3042FFFF   ANDI V0, V0, -1
9D0130B8  27C30018   ADDIU V1, S8, 24
9D0130BC  00602821   ADDU A1, V1, ZERO
9D0130C0  00403021   ADDU A2, V0, ZERO
9D0130C4  0F409D30   JAL MPFSGetArray
9D0130C8  00000000   NOP
9D0130CC  A7C20012   SH V0, 18(S8)
1028:                		if(len == 0u)
9D0130D0  97C20012   LHU V0, 18(S8)
9D0130D4  14400004   BNE V0, ZERO, 0x9D0130E8
9D0130D8  00000000   NOP
1029:                			return TRUE;
9D0130DC  24020001   ADDIU V0, ZERO, 1
9D0130E0  0B404CA5   J 0x9D013294
9D0130E4  00000000   NOP
1030:                		else
1031:                			TCPPutArray(sktHTTP, data, len);
9D0130E8  938281E8   LBU V0, -32280(GP)
9D0130EC  00401821   ADDU V1, V0, ZERO
9D0130F0  3C02A000   LUI V0, -24576
9D0130F4  000318C0   SLL V1, V1, 3
9D0130F8  24420600   ADDIU V0, V0, 1536
9D0130FC  00621021   ADDU V0, V1, V0
9D013100  90420004   LBU V0, 4(V0)
9D013104  00402021   ADDU A0, V0, ZERO
9D013108  97C20012   LHU V0, 18(S8)
9D01310C  27C30018   ADDIU V1, S8, 24
9D013110  00602821   ADDU A1, V1, ZERO
9D013114  00403021   ADDU A2, V0, ZERO
9D013118  0F4004E1   JAL TCPPutArray
9D01311C  00000000   NOP
1032:                		numBytes -= len;
9D013120  97C30010   LHU V1, 16(S8)
9D013124  97C20012   LHU V0, 18(S8)
9D013128  00621023   SUBU V0, V1, V0
9D01312C  A7C20010   SH V0, 16(S8)
1033:                	}
1034:                	
1035:                	// Check if a callback index was reached
1036:                	if(curHTTP.byteCount == curHTTP.nextCallback)
9D01313C  3C02A000   LUI V0, -24576
9D013140  8C430574   LW V1, 1396(V0)
9D013144  3C02A000   LUI V0, -24576
9D013148  24420574   ADDIU V0, V0, 1396
9D01314C  8C420004   LW V0, 4(V0)
9D013150  1462004F   BNE V1, V0, 0x9D013290
9D013154  00000000   NOP
1037:                	{
1038:                		// Update the state machine
1039:                		smHTTP = SM_HTTP_SEND_FROM_CALLBACK;
9D013158  938281E8   LBU V0, -32280(GP)
9D01315C  00401821   ADDU V1, V0, ZERO
9D013160  3C02A000   LUI V0, -24576
9D013164  000318C0   SLL V1, V1, 3
9D013168  24420600   ADDIU V0, V0, 1536
9D01316C  00621021   ADDU V0, V1, V0
9D013170  2403000A   ADDIU V1, ZERO, 10
9D013174  AC430000   SW V1, 0(V0)
1040:                		curHTTP.callbackPos = 0;
9D013178  3C02A000   LUI V0, -24576
9D01317C  24420574   ADDIU V0, V0, 1396
9D013180  AC40000C   SW ZERO, 12(V0)
1041:                
1042:                		// Read past the variable name and close the MPFS
1043:                		MPFSGet(curHTTP.file, NULL);
9D013184  3C02A000   LUI V0, -24576
9D013188  24420574   ADDIU V0, V0, 1396
9D01318C  90420018   LBU V0, 24(V0)
9D013190  00402021   ADDU A0, V0, ZERO
9D013194  00002821   ADDU A1, ZERO, ZERO
9D013198  0F409CBA   JAL MPFSGet
9D01319C  00000000   NOP
1044:                		do
1045:                		{
1046:                			if(!MPFSGet(curHTTP.file, &c))
9D0131A0  3C02A000   LUI V0, -24576
9D0131A4  24420574   ADDIU V0, V0, 1396
9D0131A8  90420018   LBU V0, 24(V0)
9D0131AC  00401821   ADDU V1, V0, ZERO
9D0131B0  27C20014   ADDIU V0, S8, 20
9D0131B4  00602021   ADDU A0, V1, ZERO
9D0131B8  00402821   ADDU A1, V0, ZERO
9D0131BC  0F409CBA   JAL MPFSGet
9D0131C0  00000000   NOP
9D0131C4  1040000C   BEQ V0, ZERO, 0x9D0131F8
9D0131C8  00000000   NOP
1047:                				break;
9D0131F8  00000000   NOP
1048:                			curHTTP.byteCount++;
9D0131CC  3C02A000   LUI V0, -24576
9D0131D0  8C420574   LW V0, 1396(V0)
9D0131D4  24430001   ADDIU V1, V0, 1
9D0131D8  3C02A000   LUI V0, -24576
9D0131DC  AC430574   SW V1, 1396(V0)
1049:                		} while(c != '~');
9D0131E0  93C30014   LBU V1, 20(S8)
9D0131E4  2402007E   ADDIU V0, ZERO, 126
9D0131E8  1462FFED   BNE V1, V0, 0x9D0131A0
9D0131EC  00000000   NOP
9D0131F0  0B404C7F   J 0x9D0131FC
9D0131F4  00000000   NOP
1050:                		curHTTP.byteCount++;
9D0131FC  3C02A000   LUI V0, -24576
9D013200  8C420574   LW V0, 1396(V0)
9D013204  24430001   ADDIU V1, V0, 1
9D013208  3C02A000   LUI V0, -24576
9D01320C  AC430574   SW V1, 1396(V0)
1051:                		
1052:                		// Read in the callback address and next offset
1053:                		MPFSGetLong(curHTTP.offsets, &(curHTTP.callbackID));
9D013210  3C02A000   LUI V0, -24576
9D013214  24420574   ADDIU V0, V0, 1396
9D013218  90420019   LBU V0, 25(V0)
9D01321C  00402021   ADDU A0, V0, ZERO
9D013220  3C02A000   LUI V0, -24576
9D013224  2445057C   ADDIU A1, V0, 1404
9D013228  0F409DC3   JAL MPFSGetLong
9D01322C  00000000   NOP
1054:                		if(!MPFSGetLong(curHTTP.offsets, &(curHTTP.nextCallback)))
9D013230  3C02A000   LUI V0, -24576
9D013234  24420574   ADDIU V0, V0, 1396
9D013238  90420019   LBU V0, 25(V0)
9D01323C  00402021   ADDU A0, V0, ZERO
9D013240  3C02A000   LUI V0, -24576
9D013244  24450578   ADDIU A1, V0, 1400
9D013248  0F409DC3   JAL MPFSGetLong
9D01324C  00000000   NOP
9D013250  1440000F   BNE V0, ZERO, 0x9D013290
9D013254  00000000   NOP
1055:                		{
1056:                			curHTTP.nextCallback = 0xffffffff;
9D013258  3C02A000   LUI V0, -24576
9D01325C  24420574   ADDIU V0, V0, 1396
9D013260  2403FFFF   ADDIU V1, ZERO, -1
9D013264  AC430004   SW V1, 4(V0)
1057:                			MPFSClose(curHTTP.offsets);
9D013268  3C02A000   LUI V0, -24576
9D01326C  24420574   ADDIU V0, V0, 1396
9D013270  90420019   LBU V0, 25(V0)
9D013274  00402021   ADDU A0, V0, ZERO
9D013278  0F409CA1   JAL MPFSClose
9D01327C  00000000   NOP
1058:                			curHTTP.offsets = MPFS_INVALID_HANDLE;
9D013280  3C02A000   LUI V0, -24576
9D013284  24420574   ADDIU V0, V0, 1396
9D013288  2403FFFF   ADDIU V1, ZERO, -1
9D01328C  A0430019   SB V1, 25(V0)
1059:                		}
1060:                	}
1061:                
1062:                    // We are not done sending a file yet...
1063:                    return FALSE;
9D013290  00001021   ADDU V0, ZERO, ZERO
1064:                }
9D013294  03C0E821   ADDU SP, S8, ZERO
9D013298  8FBF005C   LW RA, 92(SP)
9D01329C  8FBE0058   LW S8, 88(SP)
9D0132A0  27BD0060   ADDIU SP, SP, 96
9D0132A4  03E00008   JR RA
9D0132A8  00000000   NOP
1065:                
1066:                /*****************************************************************************
1067:                  Function:
1068:                	static void HTTPHeaderParseLookup(BYTE i)
1069:                
1070:                  Description:
1071:                	Calls the appropriate header parser based on the index of the header
1072:                	that was read from the request.
1073:                
1074:                  Precondition:
1075:                	None
1076:                
1077:                  Parameters:
1078:                	i - the index of the string found in HTTPRequestHeaders
1079:                
1080:                  Return Values:
1081:                	TRUE - the end of the file was reached and reading is done
1082:                	FALSE - more data remains to be read
1083:                  ***************************************************************************/
1084:                static void HTTPHeaderParseLookup(BYTE i)
1085:                {
9D0132AC  27BDFFE8   ADDIU SP, SP, -24
9D0132B0  AFBF0014   SW RA, 20(SP)
9D0132B4  AFBE0010   SW S8, 16(SP)
9D0132B8  03A0F021   ADDU S8, SP, ZERO
9D0132BC  00801021   ADDU V0, A0, ZERO
9D0132C0  A3C20018   SB V0, 24(S8)
1086:                	// i corresponds to an index in HTTPRequestHeaders
1087:                	
1088:                	#if defined(HTTP_USE_COOKIES)
1089:                	if(i == 0u)
9D0132C4  93C20018   LBU V0, 24(S8)
9D0132C8  14400005   BNE V0, ZERO, 0x9D0132E0
9D0132CC  00000000   NOP
1090:                	{
1091:                		HTTPHeaderParseCookie();
9D0132D0  0F404D51   JAL 0x9D013544
9D0132D4  00000000   NOP
1092:                		return;
9D0132D8  0B404CC7   J 0x9D01331C
9D0132DC  00000000   NOP
1093:                	}
1094:                	#endif
1095:                	
1096:                	#if defined(HTTP_USE_AUTHENTICATION)	
1097:                	if(i == 1u)
9D0132E0  93C30018   LBU V1, 24(S8)
9D0132E4  24020001   ADDIU V0, ZERO, 1
9D0132E8  14620005   BNE V1, V0, 0x9D013300
9D0132EC  00000000   NOP
1098:                	{
1099:                		HTTPHeaderParseAuthorization();
9D0132F0  0F404CCD   JAL 0x9D013334
9D0132F4  00000000   NOP
1100:                		return;
9D0132F8  0B404CC7   J 0x9D01331C
9D0132FC  00000000   NOP
1101:                	}
1102:                	#endif
1103:                	
1104:                	#if defined(HTTP_USE_POST)
1105:                	if(i == 2u)
9D013300  93C30018   LBU V1, 24(S8)
9D013304  24020002   ADDIU V0, ZERO, 2
9D013308  14620004   BNE V1, V0, 0x9D01331C
9D01330C  00000000   NOP
1106:                	{
1107:                		HTTPHeaderParseContentLength();
9D013310  0F404E05   JAL 0x9D013814
9D013314  00000000   NOP
1108:                		return;
9D013318  00000000   NOP
1109:                	}
1110:                	#endif
1111:                }
9D01331C  03C0E821   ADDU SP, S8, ZERO
9D013320  8FBF0014   LW RA, 20(SP)
9D013324  8FBE0010   LW S8, 16(SP)
9D013328  27BD0018   ADDIU SP, SP, 24
9D01332C  03E00008   JR RA
9D013330  00000000   NOP
1112:                
1113:                /*****************************************************************************
1114:                  Function:
1115:                	static void HTTPHeaderParseAuthorization(void)
1116:                
1117:                  Summary:
1118:                	Parses the "Authorization:" header for a request and verifies the
1119:                	credentials.
1120:                
1121:                  Description:
1122:                	Parses the "Authorization:" header for a request.  For example, 
1123:                	"BASIC YWRtaW46cGFzc3dvcmQ=" is decoded to a user name of "admin" and
1124:                	a password of "password".  Once read, HTTPCheckAuth is called from
1125:                	CustomHTTPApp.c to determine if the credentials are acceptable.
1126:                
1127:                	The return value of HTTPCheckAuth is saved in curHTTP.isAuthorized for
1128:                	later use by the application.
1129:                
1130:                  Precondition:
1131:                	None
1132:                
1133:                  Parameters:
1134:                	None
1135:                
1136:                  Returns:
1137:                	None
1138:                
1139:                  Remarks:
1140:                	This function is ony available when HTTP_USE_AUTHENTICATION is defined.
1141:                  ***************************************************************************/
1142:                #if defined(HTTP_USE_AUTHENTICATION)
1143:                static void HTTPHeaderParseAuthorization(void)
1144:                {
9D013334  27BDFFB0   ADDIU SP, SP, -80
9D013338  AFBF004C   SW RA, 76(SP)
9D01333C  AFBE0048   SW S8, 72(SP)
9D013340  03A0F021   ADDU S8, SP, ZERO
1145:                    WORD len;
1146:                    BYTE buf[40];
1147:                	BYTE *ptrBuf;
1148:                	
1149:                	// If auth processing is not required, return
1150:                	if(curHTTP.isAuthorized & 0x80)
9D013344  3C02A000   LUI V0, -24576
9D013348  24420574   ADDIU V0, V0, 1396
9D01334C  9042001B   LBU V0, 27(V0)
9D013350  7C021420   SEB V0, V0
9D013354  04400074   BLTZ V0, 0x9D013528
9D013358  00000000   NOP
1151:                		return;
9D013528  00000000   NOP
1152:                
1153:                	// Clear the auth type ("BASIC ")
1154:                	TCPGetArray(sktHTTP, NULL, 6);
9D01335C  938281E8   LBU V0, -32280(GP)
9D013360  00401821   ADDU V1, V0, ZERO
9D013364  3C02A000   LUI V0, -24576
9D013368  000318C0   SLL V1, V1, 3
9D01336C  24420600   ADDIU V0, V0, 1536
9D013370  00621021   ADDU V0, V1, V0
9D013374  90420004   LBU V0, 4(V0)
9D013378  00402021   ADDU A0, V0, ZERO
9D01337C  00002821   ADDU A1, ZERO, ZERO
9D013380  24060006   ADDIU A2, ZERO, 6
9D013384  0F40077A   JAL TCPGetArray
9D013388  00000000   NOP
1155:                
1156:                	// Find the terminating CRLF and make sure it's a multiple of four
1157:                	len = TCPFindROMArray(sktHTTP, HTTP_CRLF, HTTP_CRLF_LEN, 0, FALSE);
9D01338C  938281E8   LBU V0, -32280(GP)
9D013390  00401821   ADDU V1, V0, ZERO
9D013394  3C02A000   LUI V0, -24576
9D013398  000318C0   SLL V1, V1, 3
9D01339C  24420600   ADDIU V0, V0, 1536
9D0133A0  00621021   ADDU V0, V1, V0
9D0133A4  90420004   LBU V0, 4(V0)
9D0133A8  AFA00010   SW ZERO, 16(SP)
9D0133AC  AFA00014   SW ZERO, 20(SP)
9D0133B0  00402021   ADDU A0, V0, ZERO
9D0133B4  3C029D03   LUI V0, -25341
9D0133B8  24450FAC   ADDIU A1, V0, 4012
9D0133BC  24060002   ADDIU A2, ZERO, 2
9D0133C0  00003821   ADDU A3, ZERO, ZERO
9D0133C4  0F400960   JAL TCPFindArrayEx
9D0133C8  00000000   NOP
9D0133CC  A7C20018   SH V0, 24(S8)
1158:                	len += 3;
9D0133D0  97C20018   LHU V0, 24(S8)
9D0133D4  24420003   ADDIU V0, V0, 3
9D0133D8  A7C20018   SH V0, 24(S8)
1159:                	len &= 0xfc;
9D0133DC  97C20018   LHU V0, 24(S8)
9D0133E0  304200FC   ANDI V0, V0, 252
9D0133E4  A7C20018   SH V0, 24(S8)
1160:                	len = mMIN(len, sizeof(buf)-4);
9D0133E8  97C20018   LHU V0, 24(S8)
9D0133EC  3043FFFF   ANDI V1, V0, -1
9D0133F0  2C630025   SLTIU V1, V1, 37
9D0133F4  14600002   BNE V1, ZERO, 0x9D013400
9D0133F8  00000000   NOP
9D0133FC  24020024   ADDIU V0, ZERO, 36
9D013400  A7C20018   SH V0, 24(S8)
1161:                	
1162:                	// Read in 4 bytes at a time and decode (slower, but saves RAM)
1163:                	for(ptrBuf = buf; len > 0u; len-=4, ptrBuf+=3)
9D013404  27C20020   ADDIU V0, S8, 32
9D013408  AFC2001C   SW V0, 28(S8)
9D01340C  0B404D1D   J 0x9D013474
9D013410  00000000   NOP
9D01345C  97C20018   LHU V0, 24(S8)
9D013460  2442FFFC   ADDIU V0, V0, -4
9D013464  A7C20018   SH V0, 24(S8)
9D013468  8FC2001C   LW V0, 28(S8)
9D01346C  24420003   ADDIU V0, V0, 3
9D013470  AFC2001C   SW V0, 28(S8)
9D013474  97C20018   LHU V0, 24(S8)
9D013478  1440FFE6   BNE V0, ZERO, 0x9D013414
9D01347C  00000000   NOP
1164:                	{
1165:                		TCPGetArray(sktHTTP, ptrBuf, 4);
9D013414  938281E8   LBU V0, -32280(GP)
9D013418  00401821   ADDU V1, V0, ZERO
9D01341C  3C02A000   LUI V0, -24576
9D013420  000318C0   SLL V1, V1, 3
9D013424  24420600   ADDIU V0, V0, 1536
9D013428  00621021   ADDU V0, V1, V0
9D01342C  90420004   LBU V0, 4(V0)
9D013430  00402021   ADDU A0, V0, ZERO
9D013434  8FC5001C   LW A1, 28(S8)
9D013438  24060004   ADDIU A2, ZERO, 4
9D01343C  0F40077A   JAL TCPGetArray
9D013440  00000000   NOP
1166:                		Base64Decode(ptrBuf, 4, ptrBuf, 3);
9D013444  8FC4001C   LW A0, 28(S8)
9D013448  24050004   ADDIU A1, ZERO, 4
9D01344C  8FC6001C   LW A2, 28(S8)
9D013450  24070003   ADDIU A3, ZERO, 3
9D013454  0F409787   JAL Base64Decode
9D013458  00000000   NOP
1167:                	}
1168:                
1169:                	// Null terminate both, and make sure there's at least two terminators
1170:                	*ptrBuf = '\0';
9D013480  8FC2001C   LW V0, 28(S8)
9D013484  A0400000   SB ZERO, 0(V0)
1171:                	for(len = 0, ptrBuf = buf; len < sizeof(buf); len++, ptrBuf++)
9D013488  A7C00018   SH ZERO, 24(S8)
9D01348C  27C20020   ADDIU V0, S8, 32
9D013490  AFC2001C   SW V0, 28(S8)
9D013494  0B404D32   J 0x9D0134C8
9D013498  00000000   NOP
9D0134B0  97C20018   LHU V0, 24(S8)
9D0134B4  24420001   ADDIU V0, V0, 1
9D0134B8  A7C20018   SH V0, 24(S8)
9D0134BC  8FC2001C   LW V0, 28(S8)
9D0134C0  24420001   ADDIU V0, V0, 1
9D0134C4  AFC2001C   SW V0, 28(S8)
9D0134C8  97C20018   LHU V0, 24(S8)
9D0134CC  2C420028   SLTIU V0, V0, 40
9D0134D0  1440FFF2   BNE V0, ZERO, 0x9D01349C
9D0134D4  00000000   NOP
9D0134D8  0B404D39   J 0x9D0134E4
9D0134DC  00000000   NOP
1172:                		if(*ptrBuf == ':')
9D01349C  8FC2001C   LW V0, 28(S8)
9D0134A0  90430000   LBU V1, 0(V0)
9D0134A4  2402003A   ADDIU V0, ZERO, 58
9D0134A8  1062000D   BEQ V1, V0, 0x9D0134E0
9D0134AC  00000000   NOP
1173:                			break;
9D0134E0  00000000   NOP
1174:                	*(ptrBuf++) = '\0';
9D0134E4  8FC2001C   LW V0, 28(S8)
9D0134E8  A0400000   SB ZERO, 0(V0)
9D0134EC  8FC2001C   LW V0, 28(S8)
9D0134F0  24420001   ADDIU V0, V0, 1
9D0134F4  AFC2001C   SW V0, 28(S8)
1175:                	
1176:                	// Verify credentials
1177:                	curHTTP.isAuthorized = HTTPCheckAuth(buf, ptrBuf);
9D0134F8  27C20020   ADDIU V0, S8, 32
9D0134FC  00402021   ADDU A0, V0, ZERO
9D013500  8FC5001C   LW A1, 28(S8)
9D013504  0F4050CA   JAL HTTPCheckAuth
9D013508  00000000   NOP
9D01350C  00401821   ADDU V1, V0, ZERO
9D013510  3C02A000   LUI V0, -24576
9D013514  24420574   ADDIU V0, V0, 1396
9D013518  A043001B   SB V1, 27(V0)
1178:                
1179:                	return;
9D01351C  00000000   NOP
9D013520  0B404D4B   J 0x9D01352C
9D013524  00000000   NOP
1180:                }
9D01352C  03C0E821   ADDU SP, S8, ZERO
9D013530  8FBF004C   LW RA, 76(SP)
9D013534  8FBE0048   LW S8, 72(SP)
9D013538  27BD0050   ADDIU SP, SP, 80
9D01353C  03E00008   JR RA
9D013540  00000000   NOP
1181:                #endif
1182:                
1183:                /*****************************************************************************
1184:                  Function:
1185:                	static void HTTPHeaderParseCookie(void)
1186:                
1187:                  Summary:
1188:                	Parses the "Cookie:" headers for a request and stores them as GET
1189:                	variables.
1190:                
1191:                  Description:
1192:                	Parses the "Cookie:" headers for a request.  For example, 
1193:                 	"Cookie: name=Wile+E.+Coyote; order=ROCKET_LAUNCHER" is decoded to 
1194:                	"name=Wile+E.+Coyote&order=ROCKET_LAUNCHER&" and stored as any other 
1195:                	GET variable in curHTTP.data.
1196:                
1197:                	The user application can easily access these values later using the
1198:                	HTTPGetArg() and HTTPGetROMArg() functions.
1199:                
1200:                  Precondition:
1201:                	None
1202:                
1203:                  Parameters:
1204:                	None
1205:                
1206:                  Returns:
1207:                	None
1208:                
1209:                  Remarks:
1210:                	This function is ony available when HTTP_USE_COOKIES is defined.
1211:                  ***************************************************************************/
1212:                #if defined(HTTP_USE_COOKIES)
1213:                static void HTTPHeaderParseCookie(void)
1214:                {
9D013544  27BDFFD0   ADDIU SP, SP, -48
9D013548  AFBF002C   SW RA, 44(SP)
9D01354C  AFBE0028   SW S8, 40(SP)
9D013550  AFB00024   SW S0, 36(SP)
9D013554  03A0F021   ADDU S8, SP, ZERO
1215:                	WORD lenA, lenB;
1216:                
1217:                	// Verify there's enough space
1218:                	lenB = TCPFindROMArray(sktHTTP, HTTP_CRLF, HTTP_CRLF_LEN, 0, FALSE);
9D013558  938281E8   LBU V0, -32280(GP)
9D01355C  00401821   ADDU V1, V0, ZERO
9D013560  3C02A000   LUI V0, -24576
9D013564  000318C0   SLL V1, V1, 3
9D013568  24420600   ADDIU V0, V0, 1536
9D01356C  00621021   ADDU V0, V1, V0
9D013570  90420004   LBU V0, 4(V0)
9D013574  AFA00010   SW ZERO, 16(SP)
9D013578  AFA00014   SW ZERO, 20(SP)
9D01357C  00402021   ADDU A0, V0, ZERO
9D013580  3C029D03   LUI V0, -25341
9D013584  24450FAC   ADDIU A1, V0, 4012
9D013588  24060002   ADDIU A2, ZERO, 2
9D01358C  00003821   ADDU A3, ZERO, ZERO
9D013590  0F400960   JAL TCPFindArrayEx
9D013594  00000000   NOP
9D013598  A7C20018   SH V0, 24(S8)
1219:                	if(lenB >= (WORD)(curHTTP.data + HTTP_MAX_DATA_LEN - curHTTP.ptrData - 2))
9D01359C  3C02A000   LUI V0, -24576
9D0135A0  24420574   ADDIU V0, V0, 1396
9D0135A4  8C420010   LW V0, 16(V0)
9D0135A8  3042FFFF   ANDI V0, V0, -1
9D0135AC  00021023   SUBU V0, ZERO, V0
9D0135B0  3043FFFF   ANDI V1, V0, -1
9D0135B4  3C02A000   LUI V0, -24576
9D0135B8  244205FC   ADDIU V0, V0, 1532
9D0135BC  3042FFFF   ANDI V0, V0, -1
9D0135C0  2442FFFE   ADDIU V0, V0, -2
9D0135C4  3042FFFF   ANDI V0, V0, -1
9D0135C8  00621021   ADDU V0, V1, V0
9D0135CC  3042FFFF   ANDI V0, V0, -1
9D0135D0  97C30018   LHU V1, 24(S8)
9D0135D4  0062102B   SLTU V0, V1, V0
9D0135D8  14400083   BNE V0, ZERO, 0x9D0137E8
9D0135DC  00000000   NOP
1220:                	{// If not, overflow
1221:                		curHTTP.httpStatus = HTTP_OVERFLOW;
9D0135E0  3C02A000   LUI V0, -24576
9D0135E4  24420574   ADDIU V0, V0, 1396
9D0135E8  24030005   ADDIU V1, ZERO, 5
9D0135EC  AC43001C   SW V1, 28(V0)
1222:                		smHTTP = SM_HTTP_SERVE_HEADERS;
9D0135F0  938281E8   LBU V0, -32280(GP)
9D0135F4  00401821   ADDU V1, V0, ZERO
9D0135F8  3C02A000   LUI V0, -24576
9D0135FC  000318C0   SLL V1, V1, 3
9D013600  24420600   ADDIU V0, V0, 1536
9D013604  00621021   ADDU V0, V1, V0
9D013608  24030007   ADDIU V1, ZERO, 7
9D01360C  AC430000   SW V1, 0(V0)
1223:                		return;
9D013610  0B404DFE   J 0x9D0137F8
9D013614  00000000   NOP
1224:                	}
1225:                
1226:                	// While a CRLF is not immediate, grab a cookie value
1227:                	while(lenB != 0u)
9D0137E8  97C20018   LHU V0, 24(S8)
9D0137EC  1440FF8A   BNE V0, ZERO, 0x9D013618
9D0137F0  00000000   NOP
1228:                	{
1229:                		// Look for a ';' and use the shorter of that or a CRLF
1230:                		lenA = TCPFind(sktHTTP, ';', 0, FALSE);
9D013618  938281E8   LBU V0, -32280(GP)
9D01361C  00401821   ADDU V1, V0, ZERO
9D013620  3C02A000   LUI V0, -24576
9D013624  000318C0   SLL V1, V1, 3
9D013628  24420600   ADDIU V0, V0, 1536
9D01362C  00621021   ADDU V0, V1, V0
9D013630  90420004   LBU V0, 4(V0)
9D013634  AFA00010   SW ZERO, 16(SP)
9D013638  00402021   ADDU A0, V0, ZERO
9D01363C  2405003B   ADDIU A1, ZERO, 59
9D013640  00003021   ADDU A2, ZERO, ZERO
9D013644  00003821   ADDU A3, ZERO, ZERO
9D013648  0F400AEB   JAL TCPFindEx
9D01364C  00000000   NOP
9D013650  A7C2001A   SH V0, 26(S8)
1231:                		
1232:                		// Read to the terminator
1233:                		curHTTP.ptrData += TCPGetArray(sktHTTP, curHTTP.ptrData, mMIN(lenA, lenB));
9D013654  3C02A000   LUI V0, -24576
9D013658  24420574   ADDIU V0, V0, 1396
9D01365C  8C500010   LW S0, 16(V0)
9D013660  938281E8   LBU V0, -32280(GP)
9D013664  00401821   ADDU V1, V0, ZERO
9D013668  3C02A000   LUI V0, -24576
9D01366C  000318C0   SLL V1, V1, 3
9D013670  24420600   ADDIU V0, V0, 1536
9D013674  00621021   ADDU V0, V1, V0
9D013678  90420004   LBU V0, 4(V0)
9D01367C  00402021   ADDU A0, V0, ZERO
9D013680  3C02A000   LUI V0, -24576
9D013684  24420574   ADDIU V0, V0, 1396
9D013688  8C450010   LW A1, 16(V0)
9D01368C  97C3001A   LHU V1, 26(S8)
9D013690  97C20018   LHU V0, 24(S8)
9D013694  3047FFFF   ANDI A3, V0, -1
9D013698  3066FFFF   ANDI A2, V1, -1
9D01369C  00C7302B   SLTU A2, A2, A3
9D0136A0  10C00002   BEQ A2, ZERO, 0x9D0136AC
9D0136A4  00000000   NOP
9D0136A8  00601021   ADDU V0, V1, ZERO
9D0136AC  3042FFFF   ANDI V0, V0, -1
9D0136B0  00403021   ADDU A2, V0, ZERO
9D0136B4  0F40077A   JAL TCPGetArray
9D0136B8  00000000   NOP
9D0136BC  02021821   ADDU V1, S0, V0
9D0136C0  3C02A000   LUI V0, -24576
9D0136C4  24420574   ADDIU V0, V0, 1396
9D0136C8  AC430010   SW V1, 16(V0)
1234:                		
1235:                		// Insert an & to anticipate another cookie
1236:                		*(curHTTP.ptrData++) = '&';
9D0136CC  3C02A000   LUI V0, -24576
9D0136D0  24420574   ADDIU V0, V0, 1396
9D0136D4  8C420010   LW V0, 16(V0)
9D0136D8  24030026   ADDIU V1, ZERO, 38
9D0136DC  A0430000   SB V1, 0(V0)
9D0136E0  24430001   ADDIU V1, V0, 1
9D0136E4  3C02A000   LUI V0, -24576
9D0136E8  24420574   ADDIU V0, V0, 1396
9D0136EC  AC430010   SW V1, 16(V0)
1237:                		
1238:                		// If semicolon, trash it and whitespace
1239:                		if(lenA < lenB)
9D0136F0  97C3001A   LHU V1, 26(S8)
9D0136F4  97C20018   LHU V0, 24(S8)
9D0136F8  0062102B   SLTU V0, V1, V0
9D0136FC  10400029   BEQ V0, ZERO, 0x9D0137A4
9D013700  00000000   NOP
1240:                		{
1241:                			TCPGet(sktHTTP, NULL);
9D013704  938281E8   LBU V0, -32280(GP)
9D013708  00401821   ADDU V1, V0, ZERO
9D01370C  3C02A000   LUI V0, -24576
9D013710  000318C0   SLL V1, V1, 3
9D013714  24420600   ADDIU V0, V0, 1536
9D013718  00621021   ADDU V0, V1, V0
9D01371C  90420004   LBU V0, 4(V0)
9D013720  00402021   ADDU A0, V0, ZERO
9D013724  00002821   ADDU A1, ZERO, ZERO
9D013728  0F4006DD   JAL TCPGet
9D01372C  00000000   NOP
1242:                			while(TCPFind(sktHTTP, ' ', 0, FALSE) == 0u)
9D013730  0B404DD9   J 0x9D013764
9D013734  00000000   NOP
9D013764  938281E8   LBU V0, -32280(GP)
9D013768  00401821   ADDU V1, V0, ZERO
9D01376C  3C02A000   LUI V0, -24576
9D013770  000318C0   SLL V1, V1, 3
9D013774  24420600   ADDIU V0, V0, 1536
9D013778  00621021   ADDU V0, V1, V0
9D01377C  90420004   LBU V0, 4(V0)
9D013780  AFA00010   SW ZERO, 16(SP)
9D013784  00402021   ADDU A0, V0, ZERO
9D013788  24050020   ADDIU A1, ZERO, 32
9D01378C  00003021   ADDU A2, ZERO, ZERO
9D013790  00003821   ADDU A3, ZERO, ZERO
9D013794  0F400AEB   JAL TCPFindEx
9D013798  00000000   NOP
9D01379C  1040FFE6   BEQ V0, ZERO, 0x9D013738
9D0137A0  00000000   NOP
1243:                				TCPGet(sktHTTP, NULL);
9D013738  938281E8   LBU V0, -32280(GP)
9D01373C  00401821   ADDU V1, V0, ZERO
9D013740  3C02A000   LUI V0, -24576
9D013744  000318C0   SLL V1, V1, 3
9D013748  24420600   ADDIU V0, V0, 1536
9D01374C  00621021   ADDU V0, V1, V0
9D013750  90420004   LBU V0, 4(V0)
9D013754  00402021   ADDU A0, V0, ZERO
9D013758  00002821   ADDU A1, ZERO, ZERO
9D01375C  0F4006DD   JAL TCPGet
9D013760  00000000   NOP
1244:                		}
1245:                		
1246:                		// Find the new distance to the CRLF
1247:                		lenB = TCPFindROMArray(sktHTTP, HTTP_CRLF, HTTP_CRLF_LEN, 0, FALSE);
9D0137A4  938281E8   LBU V0, -32280(GP)
9D0137A8  00401821   ADDU V1, V0, ZERO
9D0137AC  3C02A000   LUI V0, -24576
9D0137B0  000318C0   SLL V1, V1, 3
9D0137B4  24420600   ADDIU V0, V0, 1536
9D0137B8  00621021   ADDU V0, V1, V0
9D0137BC  90420004   LBU V0, 4(V0)
9D0137C0  AFA00010   SW ZERO, 16(SP)
9D0137C4  AFA00014   SW ZERO, 20(SP)
9D0137C8  00402021   ADDU A0, V0, ZERO
9D0137CC  3C029D03   LUI V0, -25341
9D0137D0  24450FAC   ADDIU A1, V0, 4012
9D0137D4  24060002   ADDIU A2, ZERO, 2
9D0137D8  00003821   ADDU A3, ZERO, ZERO
9D0137DC  0F400960   JAL TCPFindArrayEx
9D0137E0  00000000   NOP
9D0137E4  A7C20018   SH V0, 24(S8)
1248:                	}
1249:                
1250:                	return;
9D0137F4  00000000   NOP
1251:                
1252:                }
9D0137F8  03C0E821   ADDU SP, S8, ZERO
9D0137FC  8FBF002C   LW RA, 44(SP)
9D013800  8FBE0028   LW S8, 40(SP)
9D013804  8FB00024   LW S0, 36(SP)
9D013808  27BD0030   ADDIU SP, SP, 48
9D01380C  03E00008   JR RA
9D013810  00000000   NOP
1253:                #endif
1254:                
1255:                /*****************************************************************************
1256:                  Function:
1257:                	static void HTTPHeaderParseContentLength(void)
1258:                
1259:                  Summary:
1260:                	Parses the "Content-Length:" header for a request.
1261:                
1262:                  Description:
1263:                	Parses the "Content-Length:" header to determine how many bytes of
1264:                	POST data to expect after the request.  This value is stored in 
1265:                	curHTTP.byteCount.
1266:                
1267:                  Precondition:
1268:                	None
1269:                
1270:                  Parameters:
1271:                	None
1272:                
1273:                  Returns:
1274:                	None
1275:                
1276:                  Remarks:
1277:                	This function is ony available when HTTP_USE_POST is defined.
1278:                  ***************************************************************************/
1279:                #if defined(HTTP_USE_POST)
1280:                static void HTTPHeaderParseContentLength(void)
1281:                {
9D013814  27BDFFD0   ADDIU SP, SP, -48
9D013818  AFBF002C   SW RA, 44(SP)
9D01381C  AFBE0028   SW S8, 40(SP)
9D013820  03A0F021   ADDU S8, SP, ZERO
1282:                	WORD len;
1283:                	BYTE buf[10];
1284:                
1285:                	// Read up to the CRLF (max 9 bytes or ~1GB)
1286:                	len = TCPFindROMArray(sktHTTP, HTTP_CRLF, HTTP_CRLF_LEN, 0, FALSE);
9D013824  938281E8   LBU V0, -32280(GP)
9D013828  00401821   ADDU V1, V0, ZERO
9D01382C  3C02A000   LUI V0, -24576
9D013830  000318C0   SLL V1, V1, 3
9D013834  24420600   ADDIU V0, V0, 1536
9D013838  00621021   ADDU V0, V1, V0
9D01383C  90420004   LBU V0, 4(V0)
9D013840  AFA00010   SW ZERO, 16(SP)
9D013844  AFA00014   SW ZERO, 20(SP)
9D013848  00402021   ADDU A0, V0, ZERO
9D01384C  3C029D03   LUI V0, -25341
9D013850  24450FAC   ADDIU A1, V0, 4012
9D013854  24060002   ADDIU A2, ZERO, 2
9D013858  00003821   ADDU A3, ZERO, ZERO
9D01385C  0F400960   JAL TCPFindArrayEx
9D013860  00000000   NOP
9D013864  A7C20018   SH V0, 24(S8)
1287:                	if(len >= sizeof(buf))
9D013868  97C20018   LHU V0, 24(S8)
9D01386C  2C42000A   SLTIU V0, V0, 10
9D013870  14400009   BNE V0, ZERO, 0x9D013898
9D013874  00000000   NOP
1288:                	{
1289:                		curHTTP.httpStatus = HTTP_BAD_REQUEST;
9D013878  3C02A000   LUI V0, -24576
9D01387C  24420574   ADDIU V0, V0, 1396
9D013880  24030002   ADDIU V1, ZERO, 2
9D013884  AC43001C   SW V1, 28(V0)
1290:                		curHTTP.byteCount = 0;
9D013888  3C02A000   LUI V0, -24576
9D01388C  AC400574   SW ZERO, 1396(V0)
1291:                		return;
9D013890  0B404E40   J 0x9D013900
9D013894  00000000   NOP
1292:                	}	
1293:                	len = TCPGetArray(sktHTTP, buf, len);
9D013898  938281E8   LBU V0, -32280(GP)
9D01389C  00401821   ADDU V1, V0, ZERO
9D0138A0  3C02A000   LUI V0, -24576
9D0138A4  000318C0   SLL V1, V1, 3
9D0138A8  24420600   ADDIU V0, V0, 1536
9D0138AC  00621021   ADDU V0, V1, V0
9D0138B0  90420004   LBU V0, 4(V0)
9D0138B4  00402021   ADDU A0, V0, ZERO
9D0138B8  97C20018   LHU V0, 24(S8)
9D0138BC  27C3001C   ADDIU V1, S8, 28
9D0138C0  00602821   ADDU A1, V1, ZERO
9D0138C4  00403021   ADDU A2, V0, ZERO
9D0138C8  0F40077A   JAL TCPGetArray
9D0138CC  00000000   NOP
9D0138D0  A7C20018   SH V0, 24(S8)
1294:                	buf[len] = '\0';
9D0138D4  97C20018   LHU V0, 24(S8)
9D0138D8  27C30018   ADDIU V1, S8, 24
9D0138DC  00621021   ADDU V0, V1, V0
9D0138E0  A0400004   SB ZERO, 4(V0)
1295:                	
1296:                	curHTTP.byteCount = atol((char*)buf);
9D0138E4  27C2001C   ADDIU V0, S8, 28
9D0138E8  00402021   ADDU A0, V0, ZERO
9D0138EC  0F40D63E   JAL atol
9D0138F0  00000000   NOP
9D0138F4  00401821   ADDU V1, V0, ZERO
9D0138F8  3C02A000   LUI V0, -24576
9D0138FC  AC430574   SW V1, 1396(V0)
1297:                }
9D013900  03C0E821   ADDU SP, S8, ZERO
9D013904  8FBF002C   LW RA, 44(SP)
9D013908  8FBE0028   LW S8, 40(SP)
9D01390C  27BD0030   ADDIU SP, SP, 48
9D013910  03E00008   JR RA
9D013914  00000000   NOP
1298:                #endif
1299:                
1300:                /*****************************************************************************
1301:                  Function:
1302:                	BYTE* HTTPURLDecode(BYTE* cData)
1303:                
1304:                  Summary:
1305:                	Parses a string from URL encoding to plain-text.
1306:                
1307:                  Description:
1308:                	Parses a string from URL encoding to plain-text.  The following
1309:                	conversions are made: ?=? to ?\0?, ?&? to ?\0?, ?+? to ? ?, and
1310:                	?%xx? to a single hex byte.
1311:                 
1312:                	After completion, the data has been decoded and a null terminator
1313:                	signifies the end of a name or value.  A second null terminator (or a
1314:                	null name parameter) indicates the end of all the data.
1315:                
1316:                  Precondition:
1317:                	The data parameter is null terminated and has at least one extra
1318:                	byte free.
1319:                
1320:                  Parameters:
1321:                	cData - The string which is to be decoded in place.
1322:                
1323:                  Returns:
1324:                	A pointer to the last null terminator in data, which is also the
1325:                	first free byte for new data.
1326:                
1327:                  Remarks:
1328:                	This function is called by the stack to parse GET arguments and 
1329:                	cookie data.  User applications can use this function to decode POST
1330:                	data, but first need to verify that the string is null-terminated.
1331:                  ***************************************************************************/
1332:                BYTE* HTTPURLDecode(BYTE* cData)
1333:                {
9D013918  27BDFFD8   ADDIU SP, SP, -40
9D01391C  AFBF0024   SW RA, 36(SP)
9D013920  AFBE0020   SW S8, 32(SP)
9D013924  03A0F021   ADDU S8, SP, ZERO
9D013928  AFC40028   SW A0, 40(S8)
1334:                	BYTE *pRead, *pWrite;
1335:                	WORD wLen;
1336:                	BYTE c;
1337:                	WORD hex;
1338:                	 
1339:                	// Determine length of input
1340:                	wLen = strlen((char*)cData);
9D01392C  8FC20028   LW V0, 40(S8)
9D013930  00402021   ADDU A0, V0, ZERO
9D013934  0F40D2F2   JAL 0x9D034BC8
9D013938  00000000   NOP
9D01393C  A7C20018   SH V0, 24(S8)
1341:                	 
1342:                	// Read all characters in the string
1343:                	for(pRead = pWrite = cData; wLen != 0u; )
9D013940  8FC20028   LW V0, 40(S8)
9D013944  AFC20014   SW V0, 20(S8)
9D013948  8FC20014   LW V0, 20(S8)
9D01394C  AFC20010   SW V0, 16(S8)
9D013950  0B404EAC   J 0x9D013AB0
9D013954  00000000   NOP
9D013AB0  97C20018   LHU V0, 24(S8)
9D013AB4  1440FFA8   BNE V0, ZERO, 0x9D013958
9D013AB8  00000000   NOP
1344:                	{
1345:                		c = *pRead++;
9D013958  8FC20010   LW V0, 16(S8)
9D01395C  90420000   LBU V0, 0(V0)
9D013960  A3C2001A   SB V0, 26(S8)
9D013964  8FC20010   LW V0, 16(S8)
9D013968  24420001   ADDIU V0, V0, 1
9D01396C  AFC20010   SW V0, 16(S8)
1346:                		wLen--;
9D013970  97C20018   LHU V0, 24(S8)
9D013974  2442FFFF   ADDIU V0, V0, -1
9D013978  A7C20018   SH V0, 24(S8)
1347:                		
1348:                		if(c == '=' || c == '&')
9D01397C  93C3001A   LBU V1, 26(S8)
9D013980  2402003D   ADDIU V0, ZERO, 61
9D013984  10620005   BEQ V1, V0, 0x9D01399C
9D013988  00000000   NOP
9D01398C  93C3001A   LBU V1, 26(S8)
9D013990  24020026   ADDIU V0, ZERO, 38
9D013994  14620008   BNE V1, V0, 0x9D0139B8
9D013998  00000000   NOP
1349:                			*pWrite++ = '\0';
9D01399C  8FC20014   LW V0, 20(S8)
9D0139A0  A0400000   SB ZERO, 0(V0)
9D0139A4  8FC20014   LW V0, 20(S8)
9D0139A8  24420001   ADDIU V0, V0, 1
9D0139AC  AFC20014   SW V0, 20(S8)
9D0139B0  0B404EAC   J 0x9D013AB0
9D0139B4  00000000   NOP
1350:                		else if(c == '+')
9D0139B8  93C3001A   LBU V1, 26(S8)
9D0139BC  2402002B   ADDIU V0, ZERO, 43
9D0139C0  14620009   BNE V1, V0, 0x9D0139E8
9D0139C4  00000000   NOP
1351:                			*pWrite++ = ' ';
9D0139C8  8FC20014   LW V0, 20(S8)
9D0139CC  24030020   ADDIU V1, ZERO, 32
9D0139D0  A0430000   SB V1, 0(V0)
9D0139D4  8FC20014   LW V0, 20(S8)
9D0139D8  24420001   ADDIU V0, V0, 1
9D0139DC  AFC20014   SW V0, 20(S8)
9D0139E0  0B404EAC   J 0x9D013AB0
9D0139E4  00000000   NOP
1352:                		else if(c == '%')
9D0139E8  93C3001A   LBU V1, 26(S8)
9D0139EC  24020025   ADDIU V0, ZERO, 37
9D0139F0  14620029   BNE V1, V0, 0x9D013A98
9D0139F4  00000000   NOP
1353:                		{
1354:                			if(wLen < 2u)
9D0139F8  97C20018   LHU V0, 24(S8)
9D0139FC  2C420002   SLTIU V0, V0, 2
9D013A00  10400004   BEQ V0, ZERO, 0x9D013A14
9D013A04  00000000   NOP
1355:                				wLen = 0;
9D013A08  A7C00018   SH ZERO, 24(S8)
9D013A0C  0B404EAC   J 0x9D013AB0
9D013A10  00000000   NOP
1356:                			else
1357:                			{
1358:                				((BYTE*)&hex)[1] = *pRead++;
9D013A14  27C2001C   ADDIU V0, S8, 28
9D013A18  24420001   ADDIU V0, V0, 1
9D013A1C  8FC30010   LW V1, 16(S8)
9D013A20  90630000   LBU V1, 0(V1)
9D013A24  A0430000   SB V1, 0(V0)
9D013A28  8FC20010   LW V0, 16(S8)
9D013A2C  24420001   ADDIU V0, V0, 1
9D013A30  AFC20010   SW V0, 16(S8)
1359:                				((BYTE*)&hex)[0] = *pRead++;
9D013A34  27C2001C   ADDIU V0, S8, 28
9D013A38  8FC30010   LW V1, 16(S8)
9D013A3C  90630000   LBU V1, 0(V1)
9D013A40  A0430000   SB V1, 0(V0)
9D013A44  8FC20010   LW V0, 16(S8)
9D013A48  24420001   ADDIU V0, V0, 1
9D013A4C  AFC20010   SW V0, 16(S8)
1360:                				wLen--;
9D013A50  97C20018   LHU V0, 24(S8)
9D013A54  2442FFFF   ADDIU V0, V0, -1
9D013A58  A7C20018   SH V0, 24(S8)
1361:                				wLen--;
9D013A5C  97C20018   LHU V0, 24(S8)
9D013A60  2442FFFF   ADDIU V0, V0, -1
9D013A64  A7C20018   SH V0, 24(S8)
1362:                				*pWrite++ = hexatob(*((WORD_VAL*)&hex));
9D013A68  27C2001C   ADDIU V0, S8, 28
9D013A6C  94440000   LHU A0, 0(V0)
9D013A70  0F40994C   JAL hexatob
9D013A74  00000000   NOP
9D013A78  00401821   ADDU V1, V0, ZERO
9D013A7C  8FC20014   LW V0, 20(S8)
9D013A80  A0430000   SB V1, 0(V0)
9D013A84  8FC20014   LW V0, 20(S8)
9D013A88  24420001   ADDIU V0, V0, 1
9D013A8C  AFC20014   SW V0, 20(S8)
9D013A90  0B404EAC   J 0x9D013AB0
9D013A94  00000000   NOP
1363:                			}
1364:                		}
1365:                		else
1366:                			*pWrite++ = c;
9D013A98  8FC20014   LW V0, 20(S8)
9D013A9C  93C3001A   LBU V1, 26(S8)
9D013AA0  A0430000   SB V1, 0(V0)
9D013AA4  8FC20014   LW V0, 20(S8)
9D013AA8  24420001   ADDIU V0, V0, 1
9D013AAC  AFC20014   SW V0, 20(S8)
1367:                	}
1368:                	
1369:                	// Double null terminate the last value
1370:                	*pWrite++ = '\0';
9D013ABC  8FC20014   LW V0, 20(S8)
9D013AC0  A0400000   SB ZERO, 0(V0)
9D013AC4  8FC20014   LW V0, 20(S8)
9D013AC8  24420001   ADDIU V0, V0, 1
9D013ACC  AFC20014   SW V0, 20(S8)
1371:                	*pWrite = '\0';
9D013AD0  8FC20014   LW V0, 20(S8)
9D013AD4  A0400000   SB ZERO, 0(V0)
1372:                	
1373:                	return pWrite;
9D013AD8  8FC20014   LW V0, 20(S8)
1374:                }
9D013ADC  03C0E821   ADDU SP, S8, ZERO
9D013AE0  8FBF0024   LW RA, 36(SP)
9D013AE4  8FBE0020   LW S8, 32(SP)
9D013AE8  27BD0028   ADDIU SP, SP, 40
9D013AEC  03E00008   JR RA
9D013AF0  00000000   NOP
1375:                
1376:                /*****************************************************************************
1377:                  Function:
1378:                	BYTE* HTTPGetArg(BYTE* cData, BYTE* cArg)
1379:                
1380:                  Summary:
1381:                	Locates a form field value in a given data array.
1382:                
1383:                  Description:
1384:                	Searches through a data array to find the value associated with a
1385:                	given argument.  It can be used to find form field values in data
1386:                	received over GET or POST.
1387:                	
1388:                	The end of data is assumed to be reached when a null name parameter is
1389:                	encountered.  This requires the string to have an even number of 
1390:                	null-terminated strings, followed by an additional null terminator.
1391:                
1392:                  Precondition:
1393:                	The data array has a valid series of null terminated name/value pairs.
1394:                
1395:                  Parameters:
1396:                	data - the buffer to search
1397:                	arg - the name of the argument to find
1398:                
1399:                  Returns:
1400:                	A pointer to the argument value, or NULL if not found.
1401:                  ***************************************************************************/
1402:                BYTE* HTTPGetArg(BYTE* cData, BYTE* cArg)
1403:                {
9D013AF4  27BDFFE8   ADDIU SP, SP, -24
9D013AF8  AFBF0014   SW RA, 20(SP)
9D013AFC  AFBE0010   SW S8, 16(SP)
9D013B00  03A0F021   ADDU S8, SP, ZERO
9D013B04  AFC40018   SW A0, 24(S8)
9D013B08  AFC5001C   SW A1, 28(S8)
1404:                	// Search through the array while bytes remain
1405:                	while(*cData != '\0')
9D013B0C  0B404EE6   J 0x9D013B98
9D013B10  00000000   NOP
9D013B98  8FC20018   LW V0, 24(S8)
9D013B9C  90420000   LBU V0, 0(V0)
9D013BA0  1440FFDC   BNE V0, ZERO, 0x9D013B14
9D013BA4  00000000   NOP
1406:                	{ 
1407:                		// Look for arg at current position
1408:                		if(!strcmp((char*)cArg, (char*)cData))
9D013B14  8FC3001C   LW V1, 28(S8)
9D013B18  8FC20018   LW V0, 24(S8)
9D013B1C  00602021   ADDU A0, V1, ZERO
9D013B20  00402821   ADDU A1, V0, ZERO
9D013B24  0F40D48D   JAL 0x9D035234
9D013B28  00000000   NOP
9D013B2C  1440000A   BNE V0, ZERO, 0x9D013B58
9D013B30  00000000   NOP
1409:                		{// Found it, so return parameter
1410:                			return cData + strlen((char*)cArg) + 1;
9D013B34  8FC2001C   LW V0, 28(S8)
9D013B38  00402021   ADDU A0, V0, ZERO
9D013B3C  0F40D2F2   JAL 0x9D034BC8
9D013B40  00000000   NOP
9D013B44  24420001   ADDIU V0, V0, 1
9D013B48  8FC30018   LW V1, 24(S8)
9D013B4C  00621021   ADDU V0, V1, V0
9D013B50  0B404EEB   J 0x9D013BAC
9D013B54  00000000   NOP
1411:                		}
1412:                		
1413:                		// Skip past two strings (NUL bytes)
1414:                		cData += strlen((char*)cData) + 1;
9D013B58  8FC20018   LW V0, 24(S8)
9D013B5C  00402021   ADDU A0, V0, ZERO
9D013B60  0F40D2F2   JAL 0x9D034BC8
9D013B64  00000000   NOP
9D013B68  24420001   ADDIU V0, V0, 1
9D013B6C  8FC30018   LW V1, 24(S8)
9D013B70  00621021   ADDU V0, V1, V0
9D013B74  AFC20018   SW V0, 24(S8)
1415:                		cData += strlen((char*)cData) + 1;
9D013B78  8FC20018   LW V0, 24(S8)
9D013B7C  00402021   ADDU A0, V0, ZERO
9D013B80  0F40D2F2   JAL 0x9D034BC8
9D013B84  00000000   NOP
9D013B88  24420001   ADDIU V0, V0, 1
9D013B8C  8FC30018   LW V1, 24(S8)
9D013B90  00621021   ADDU V0, V1, V0
9D013B94  AFC20018   SW V0, 24(S8)
1416:                	}
1417:                	 	
1418:                	// Return NULL if not found
1419:                	return NULL;
9D013BA8  00001021   ADDU V0, ZERO, ZERO
1420:                }
9D013BAC  03C0E821   ADDU SP, S8, ZERO
9D013BB0  8FBF0014   LW RA, 20(SP)
9D013BB4  8FBE0010   LW S8, 16(SP)
9D013BB8  27BD0018   ADDIU SP, SP, 24
9D013BBC  03E00008   JR RA
9D013BC0  00000000   NOP
1421:                
1422:                /*****************************************************************************
1423:                  Function:
1424:                	BYTE* HTTPGetROMArg(BYTE* cData, ROM BYTE* cArg)
1425:                
1426:                  Summary:
1427:                	Locates a form field value in a given data array.
1428:                
1429:                  Description:
1430:                	Searches through a data array to find the value associated with a
1431:                	given argument.  It can be used to find form field values in data
1432:                	received over GET or POST.
1433:                	
1434:                	The end of data is assumed to be reached when a null name parameter is
1435:                	encountered.  This requires the string to have an even number of 
1436:                	null-terminated strings, followed by an additional null terminator.
1437:                
1438:                  Precondition:
1439:                	The data array has a valid series of null terminated name/value pairs.
1440:                
1441:                  Parameters:
1442:                	data - the buffer to search
1443:                	arg - the name of the argument to find
1444:                
1445:                  Returns:
1446:                	A pointer to the argument value, or NULL if not found.
1447:                
1448:                  Remarks:
1449:                  	This function is aliased to HTTPGetArg on non-PIC18 platforms.
1450:                  ***************************************************************************/
1451:                #if defined(__18CXX)
1452:                BYTE* HTTPGetROMArg(BYTE* cData, ROM BYTE* cArg)
1453:                {
1454:                	// Search through the array while bytes remain
1455:                	while(*cData != '\0')
1456:                	{
1457:                		// Look for arg at current position
1458:                		if(!memcmppgm2ram(cData, (ROM void*)cArg, strlenpgm((ROM char*)cArg) + 1))
1459:                		{// Found it, so skip to next string
1460:                			return cData + strlenpgm((ROM char*)cArg) + 1;
1461:                		}
1462:                		
1463:                		// Skip past two strings (NUL bytes)
1464:                		cData += strlen((char*)cData) + 1;
1465:                		cData += strlen((char*)cData) + 1;
1466:                	}
1467:                	 	
1468:                	// Return NULL if not found
1469:                	return NULL;
1470:                }
1471:                #endif
1472:                
1473:                /*****************************************************************************
1474:                  Function:
1475:                	HTTP_READ_STATUS HTTPReadPostName(BYTE* cData, WORD wLen)
1476:                
1477:                  Summary:
1478:                	Reads a name from a URL encoded string in the TCP buffer.
1479:                
1480:                  Description:
1481:                	Reads a name from a URL encoded string in the TCP buffer.  This function
1482:                	is meant to be called from an HTTPExecutePost callback to facilitate
1483:                	easier parsing of incoming data.  This function also prevents buffer
1484:                	overflows by forcing the programmer to indicate how many bytes are
1485:                	expected.  At least 2 extra bytes are needed in cData over the maximum
1486:                	length of data expected to be read.
1487:                	
1488:                	This function will read until the next '=' character, which indicates the
1489:                	end of a name parameter.  It assumes that the front of the buffer is
1490:                	the beginning of the name paramter to be read.
1491:                	
1492:                	This function properly updates curHTTP.byteCount by decrementing it
1493:                	by the number of bytes read.  It also removes the delimiting '=' from
1494:                	the buffer.
1495:                
1496:                  Precondition:
1497:                	Front of TCP buffer is the beginning of a name parameter, and the rest of
1498:                	the TCP buffer contains a URL-encoded string with a name parameter 
1499:                	terminated by a '=' character.
1500:                
1501:                  Parameters:
1502:                	cData - where to store the name once it is read
1503:                	wLen - how many bytes can be written to cData
1504:                
1505:                  Return Values:
1506:                	HTTP_READ_OK - name was successfully read
1507:                	HTTP_READ_TRUNCTATED - entire name could not fit in the buffer, so the
1508:                							value was truncated and data has been lost
1509:                	HTTP_READ_INCOMPLETE - entire name was not yet in the buffer, so call
1510:                							this function again later to retrieve
1511:                  ***************************************************************************/
1512:                #if defined(HTTP_USE_POST)
1513:                HTTP_READ_STATUS HTTPReadPostName(BYTE* cData, WORD wLen)
1514:                {
9D013BC4  27BDFFE0   ADDIU SP, SP, -32
9D013BC8  AFBF001C   SW RA, 28(SP)
9D013BCC  AFBE0018   SW S8, 24(SP)
9D013BD0  03A0F021   ADDU S8, SP, ZERO
9D013BD4  AFC40020   SW A0, 32(S8)
9D013BD8  00A01021   ADDU V0, A1, ZERO
9D013BDC  A7C20024   SH V0, 36(S8)
1515:                	HTTP_READ_STATUS status;
1516:                	
1517:                	status = HTTPReadTo('=', cData, wLen);
9D013BE0  97C20024   LHU V0, 36(S8)
9D013BE4  2404003D   ADDIU A0, ZERO, 61
9D013BE8  8FC50020   LW A1, 32(S8)
9D013BEC  00403021   ADDU A2, V0, ZERO
9D013BF0  0F404F4A   JAL 0x9D013D28
9D013BF4  00000000   NOP
9D013BF8  AFC20010   SW V0, 16(S8)
1518:                
1519:                	// Decode the data (if not reading to null or blank) and return
1520:                	if(cData && *cData)
9D013BFC  8FC20020   LW V0, 32(S8)
9D013C00  10400008   BEQ V0, ZERO, 0x9D013C24
9D013C04  00000000   NOP
9D013C08  8FC20020   LW V0, 32(S8)
9D013C0C  90420000   LBU V0, 0(V0)
9D013C10  10400004   BEQ V0, ZERO, 0x9D013C24
9D013C14  00000000   NOP
1521:                		HTTPURLDecode(cData);
9D013C18  8FC40020   LW A0, 32(S8)
9D013C1C  0F404E46   JAL HTTPURLDecode
9D013C20  00000000   NOP
1522:                	return status;
9D013C24  8FC20010   LW V0, 16(S8)
1523:                }	
9D013C28  03C0E821   ADDU SP, S8, ZERO
9D013C2C  8FBF001C   LW RA, 28(SP)
9D013C30  8FBE0018   LW S8, 24(SP)
9D013C34  27BD0020   ADDIU SP, SP, 32
9D013C38  03E00008   JR RA
9D013C3C  00000000   NOP
1524:                #endif
1525:                
1526:                /*****************************************************************************
1527:                  Function:
1528:                	HTTP_READ_STATUS HTTPReadPostValue(BYTE* cData, WORD wLen)
1529:                
1530:                  Summary:
1531:                	Reads a value from a URL encoded string in the TCP buffer.
1532:                
1533:                  Description:
1534:                	Reads a value from a URL encoded string in the TCP buffer.  This function
1535:                	is meant to be called from an HTTPExecutePost callback to facilitate
1536:                	easier parsing of incoming data.  This function also prevents buffer
1537:                	overflows by forcing the programmer to indicate how many bytes are
1538:                	expected.  At least 2 extra bytes are needed in cData above the maximum
1539:                	length of data expected to be read.
1540:                	
1541:                	This function will read until the next '&' character, which indicates the
1542:                	end of a value parameter.  It assumes that the front of the buffer is
1543:                	the beginning of the value paramter to be read.  If curHTTP.byteCount
1544:                	indicates that all expected bytes are in the buffer, it assumes that 
1545:                	all remaining data is the value and acts accordingly.
1546:                	
1547:                	This function properly updates curHTTP.byteCount by decrementing it
1548:                	by the number of bytes read.  The terminating '&' character is also 
1549:                	removed from the buffer.
1550:                	
1551:                  Precondition:
1552:                	Front of TCP buffer is the beginning of a name parameter, and the rest of
1553:                	the TCP buffer contains a URL-encoded string with a name parameter 
1554:                	terminated by a '=' character.
1555:                
1556:                  Parameters:
1557:                	cData - where to store the value once it is read
1558:                	wLen - how many bytes can be written to cData
1559:                
1560:                  Return Values:
1561:                	HTTP_READ_OK - value was successfully read
1562:                	HTTP_READ_TRUNCTATED - entire value could not fit in the buffer, so the
1563:                							value was truncated and data has been lost
1564:                	HTTP_READ_INCOMPLETE - entire value was not yet in the buffer, so call
1565:                							this function again later to retrieve
1566:                  ***************************************************************************/
1567:                #if defined(HTTP_USE_POST)
1568:                HTTP_READ_STATUS HTTPReadPostValue(BYTE* cData, WORD wLen)
1569:                {
9D013C40  27BDFFD8   ADDIU SP, SP, -40
9D013C44  AFBF0024   SW RA, 36(SP)
9D013C48  AFBE0020   SW S8, 32(SP)
9D013C4C  AFB0001C   SW S0, 28(SP)
9D013C50  03A0F021   ADDU S8, SP, ZERO
9D013C54  AFC40028   SW A0, 40(S8)
9D013C58  00A01021   ADDU V0, A1, ZERO
9D013C5C  A7C2002C   SH V0, 44(S8)
1570:                	HTTP_READ_STATUS status;
1571:                	
1572:                	// Try to read the value
1573:                	status = HTTPReadTo('&', cData, wLen);
9D013C60  97C2002C   LHU V0, 44(S8)
9D013C64  24040026   ADDIU A0, ZERO, 38
9D013C68  8FC50028   LW A1, 40(S8)
9D013C6C  00403021   ADDU A2, V0, ZERO
9D013C70  0F404F4A   JAL 0x9D013D28
9D013C74  00000000   NOP
9D013C78  AFC20010   SW V0, 16(S8)
1574:                	
1575:                	// If read was incomplete, check if we're at the end
1576:                	if(status == HTTP_READ_INCOMPLETE)
9D013C7C  8FC30010   LW V1, 16(S8)
9D013C80  24020002   ADDIU V0, ZERO, 2
9D013C84  14620016   BNE V1, V0, 0x9D013CE0
9D013C88  00000000   NOP
1577:                	{
1578:                		// If all data has arrived, read all remaining data
1579:                		if(curHTTP.byteCount == TCPIsGetReady(sktHTTP))
9D013C8C  3C02A000   LUI V0, -24576
9D013C90  8C500574   LW S0, 1396(V0)
9D013C94  938281E8   LBU V0, -32280(GP)
9D013C98  00401821   ADDU V1, V0, ZERO
9D013C9C  3C02A000   LUI V0, -24576
9D013CA0  000318C0   SLL V1, V1, 3
9D013CA4  24420600   ADDIU V0, V0, 1536
9D013CA8  00621021   ADDU V0, V1, V0
9D013CAC  90420004   LBU V0, 4(V0)
9D013CB0  00402021   ADDU A0, V0, ZERO
9D013CB4  0F400675   JAL TCPIsGetReady
9D013CB8  00000000   NOP
9D013CBC  16020008   BNE S0, V0, 0x9D013CE0
9D013CC0  00000000   NOP
1580:                			status = HTTPReadTo('\0', cData, wLen);
9D013CC4  97C2002C   LHU V0, 44(S8)
9D013CC8  00002021   ADDU A0, ZERO, ZERO
9D013CCC  8FC50028   LW A1, 40(S8)
9D013CD0  00403021   ADDU A2, V0, ZERO
9D013CD4  0F404F4A   JAL 0x9D013D28
9D013CD8  00000000   NOP
9D013CDC  AFC20010   SW V0, 16(S8)
1581:                	}
1582:                		
1583:                	// Decode the data (if not reading to null or blank) and return
1584:                	if(cData && *cData)
9D013CE0  8FC20028   LW V0, 40(S8)
9D013CE4  10400008   BEQ V0, ZERO, 0x9D013D08
9D013CE8  00000000   NOP
9D013CEC  8FC20028   LW V0, 40(S8)
9D013CF0  90420000   LBU V0, 0(V0)
9D013CF4  10400004   BEQ V0, ZERO, 0x9D013D08
9D013CF8  00000000   NOP
1585:                		HTTPURLDecode(cData);
9D013CFC  8FC40028   LW A0, 40(S8)
9D013D00  0F404E46   JAL HTTPURLDecode
9D013D04  00000000   NOP
1586:                	return status;
9D013D08  8FC20010   LW V0, 16(S8)
1587:                }	
9D013D0C  03C0E821   ADDU SP, S8, ZERO
9D013D10  8FBF0024   LW RA, 36(SP)
9D013D14  8FBE0020   LW S8, 32(SP)
9D013D18  8FB0001C   LW S0, 28(SP)
9D013D1C  27BD0028   ADDIU SP, SP, 40
9D013D20  03E00008   JR RA
9D013D24  00000000   NOP
1588:                #endif
1589:                
1590:                /*****************************************************************************
1591:                  Function:
1592:                	static HTTP_READ_STATUS HTTPReadTo(BYTE cDelim, BYTE* cData, WORD wLen)
1593:                
1594:                  Summary:
1595:                	Reads to a buffer until a specified delimiter character.
1596:                
1597:                  Description:
1598:                	Reads from the TCP buffer to cData until either cDelim is reached, or
1599:                	until wLen - 2 bytes have been read.  The value read is saved to cData and 
1600:                	null terminated.  (wLen - 2 is used so that the value can be passed to
1601:                	HTTPURLDecode later, which requires a null terminator plus one extra free
1602:                	byte.)
1603:                	
1604:                	The delimiter character is removed from the buffer, but not saved to 
1605:                	cData. If all data cannot fit into cData, it will still be removed from 
1606:                	the buffer but will not be saved anywhere.
1607:                
1608:                	This function properly updates curHTTP.byteCount by decrementing it
1609:                	by the number of bytes read. 
1610:                
1611:                  Precondition:
1612:                	None
1613:                
1614:                  Parameters:
1615:                  	cDelim - the character at which to stop reading, or NULL to read to
1616:                  			 the end of the buffer
1617:                	cData - where to store the data being read
1618:                	wLen - how many bytes can be written to cData
1619:                
1620:                  Return Values:
1621:                	HTTP_READ_OK - data was successfully read
1622:                	HTTP_READ_TRUNCTATED - entire data could not fit in the buffer, so the
1623:                							data was truncated and data has been lost
1624:                	HTTP_READ_INCOMPLETE - delimiter character was not found
1625:                  ***************************************************************************/
1626:                #if defined(HTTP_USE_POST)
1627:                static HTTP_READ_STATUS HTTPReadTo(BYTE cDelim, BYTE* cData, WORD wLen)
1628:                {
9D013D28  27BDFFD0   ADDIU SP, SP, -48
9D013D2C  AFBF002C   SW RA, 44(SP)
9D013D30  AFBE0028   SW S8, 40(SP)
9D013D34  AFB00024   SW S0, 36(SP)
9D013D38  03A0F021   ADDU S8, SP, ZERO
9D013D3C  00801821   ADDU V1, A0, ZERO
9D013D40  AFC50034   SW A1, 52(S8)
9D013D44  00C01021   ADDU V0, A2, ZERO
9D013D48  A3C30030   SB V1, 48(S8)
9D013D4C  A7C20038   SH V0, 56(S8)
1629:                	HTTP_READ_STATUS status;
1630:                	WORD wPos;
1631:                	
1632:                	// Either look for delimiter, or read all available data
1633:                	if(cDelim)
9D013D50  93C20030   LBU V0, 48(S8)
9D013D54  10400014   BEQ V0, ZERO, 0x9D013DA8
9D013D58  00000000   NOP
1634:                		wPos = TCPFind(sktHTTP, cDelim, 0, FALSE);
9D013D5C  938281E8   LBU V0, -32280(GP)
9D013D60  00401821   ADDU V1, V0, ZERO
9D013D64  3C02A000   LUI V0, -24576
9D013D68  000318C0   SLL V1, V1, 3
9D013D6C  24420600   ADDIU V0, V0, 1536
9D013D70  00621021   ADDU V0, V1, V0
9D013D74  90420004   LBU V0, 4(V0)
9D013D78  00401821   ADDU V1, V0, ZERO
9D013D7C  93C20030   LBU V0, 48(S8)
9D013D80  AFA00010   SW ZERO, 16(SP)
9D013D84  00602021   ADDU A0, V1, ZERO
9D013D88  00402821   ADDU A1, V0, ZERO
9D013D8C  00003021   ADDU A2, ZERO, ZERO
9D013D90  00003821   ADDU A3, ZERO, ZERO
9D013D94  0F400AEB   JAL TCPFindEx
9D013D98  00000000   NOP
9D013D9C  A7C2001C   SH V0, 28(S8)
9D013DA0  0B404F75   J 0x9D013DD4
9D013DA4  00000000   NOP
1635:                	else
1636:                		wPos = TCPIsGetReady(sktHTTP);
9D013DA8  938281E8   LBU V0, -32280(GP)
9D013DAC  00401821   ADDU V1, V0, ZERO
9D013DB0  3C02A000   LUI V0, -24576
9D013DB4  000318C0   SLL V1, V1, 3
9D013DB8  24420600   ADDIU V0, V0, 1536
9D013DBC  00621021   ADDU V0, V1, V0
9D013DC0  90420004   LBU V0, 4(V0)
9D013DC4  00402021   ADDU A0, V0, ZERO
9D013DC8  0F400675   JAL TCPIsGetReady
9D013DCC  00000000   NOP
9D013DD0  A7C2001C   SH V0, 28(S8)
1637:                	
1638:                	// If not found, return incomplete
1639:                	if(wPos == 0xffff)
9D013DD4  97C3001C   LHU V1, 28(S8)
9D013DD8  3402FFFF   ORI V0, ZERO, -1
9D013DDC  14620004   BNE V1, V0, 0x9D013DF0
9D013DE0  00000000   NOP
1640:                		return HTTP_READ_INCOMPLETE;
9D013DE4  24020002   ADDIU V0, ZERO, 2
9D013DE8  0B40501B   J 0x9D01406C
9D013DEC  00000000   NOP
1641:                	
1642:                	// Read the value
1643:                	if(wLen < 2u && cData != NULL)
9D013DF0  97C20038   LHU V0, 56(S8)
9D013DF4  2C420002   SLTIU V0, V0, 2
9D013DF8  1040001B   BEQ V0, ZERO, 0x9D013E68
9D013DFC  00000000   NOP
9D013E00  8FC20034   LW V0, 52(S8)
9D013E04  10400018   BEQ V0, ZERO, 0x9D013E68
9D013E08  00000000   NOP
1644:                	{// Buffer is too small, so read to NULL instead
1645:                		curHTTP.byteCount -= TCPGetArray(sktHTTP, NULL, wPos);
9D013E0C  3C02A000   LUI V0, -24576
9D013E10  8C500574   LW S0, 1396(V0)
9D013E14  938281E8   LBU V0, -32280(GP)
9D013E18  00401821   ADDU V1, V0, ZERO
9D013E1C  3C02A000   LUI V0, -24576
9D013E20  000318C0   SLL V1, V1, 3
9D013E24  24420600   ADDIU V0, V0, 1536
9D013E28  00621021   ADDU V0, V1, V0
9D013E2C  90420004   LBU V0, 4(V0)
9D013E30  00401821   ADDU V1, V0, ZERO
9D013E34  97C2001C   LHU V0, 28(S8)
9D013E38  00602021   ADDU A0, V1, ZERO
9D013E3C  00002821   ADDU A1, ZERO, ZERO
9D013E40  00403021   ADDU A2, V0, ZERO
9D013E44  0F40077A   JAL TCPGetArray
9D013E48  00000000   NOP
9D013E4C  02021823   SUBU V1, S0, V0
9D013E50  3C02A000   LUI V0, -24576
9D013E54  AC430574   SW V1, 1396(V0)
1646:                		status = HTTP_READ_TRUNCATED;
9D013E58  24020001   ADDIU V0, ZERO, 1
9D013E5C  AFC20018   SW V0, 24(S8)
9D013E60  0B405007   J 0x9D01401C
9D013E64  00000000   NOP
1647:                	}
1648:                	else if(cData == NULL)
9D013E68  8FC20034   LW V0, 52(S8)
9D013E6C  14400017   BNE V0, ZERO, 0x9D013ECC
9D013E70  00000000   NOP
1649:                	{// Just remove the data
1650:                		curHTTP.byteCount -= TCPGetArray(sktHTTP, NULL, wPos);
9D013E74  3C02A000   LUI V0, -24576
9D013E78  8C500574   LW S0, 1396(V0)
9D013E7C  938281E8   LBU V0, -32280(GP)
9D013E80  00401821   ADDU V1, V0, ZERO
9D013E84  3C02A000   LUI V0, -24576
9D013E88  000318C0   SLL V1, V1, 3
9D013E8C  24420600   ADDIU V0, V0, 1536
9D013E90  00621021   ADDU V0, V1, V0
9D013E94  90420004   LBU V0, 4(V0)
9D013E98  00401821   ADDU V1, V0, ZERO
9D013E9C  97C2001C   LHU V0, 28(S8)
9D013EA0  00602021   ADDU A0, V1, ZERO
9D013EA4  00002821   ADDU A1, ZERO, ZERO
9D013EA8  00403021   ADDU A2, V0, ZERO
9D013EAC  0F40077A   JAL TCPGetArray
9D013EB0  00000000   NOP
9D013EB4  02021823   SUBU V1, S0, V0
9D013EB8  3C02A000   LUI V0, -24576
9D013EBC  AC430574   SW V1, 1396(V0)
1651:                		status = HTTP_READ_OK;
9D013EC0  AFC00018   SW ZERO, 24(S8)
9D013EC4  0B405007   J 0x9D01401C
9D013EC8  00000000   NOP
1652:                	}
1653:                	else if(wPos > wLen - 2)
9D013ECC  97C3001C   LHU V1, 28(S8)
9D013ED0  97C20038   LHU V0, 56(S8)
9D013ED4  2442FFFE   ADDIU V0, V0, -2
9D013ED8  0043102A   SLT V0, V0, V1
9D013EDC  10400037   BEQ V0, ZERO, 0x9D013FBC
9D013EE0  00000000   NOP
1654:                	{// Read data, but truncate at max length
1655:                		curHTTP.byteCount -= TCPGetArray(sktHTTP, cData, wLen - 2);
9D013EE4  3C02A000   LUI V0, -24576
9D013EE8  8C500574   LW S0, 1396(V0)
9D013EEC  938281E8   LBU V0, -32280(GP)
9D013EF0  00401821   ADDU V1, V0, ZERO
9D013EF4  3C02A000   LUI V0, -24576
9D013EF8  000318C0   SLL V1, V1, 3
9D013EFC  24420600   ADDIU V0, V0, 1536
9D013F00  00621021   ADDU V0, V1, V0
9D013F04  90420004   LBU V0, 4(V0)
9D013F08  00401821   ADDU V1, V0, ZERO
9D013F0C  97C20038   LHU V0, 56(S8)
9D013F10  2442FFFE   ADDIU V0, V0, -2
9D013F14  3042FFFF   ANDI V0, V0, -1
9D013F18  00602021   ADDU A0, V1, ZERO
9D013F1C  8FC50034   LW A1, 52(S8)
9D013F20  00403021   ADDU A2, V0, ZERO
9D013F24  0F40077A   JAL TCPGetArray
9D013F28  00000000   NOP
9D013F2C  02021823   SUBU V1, S0, V0
9D013F30  3C02A000   LUI V0, -24576
9D013F34  AC430574   SW V1, 1396(V0)
1656:                		curHTTP.byteCount -= TCPGetArray(sktHTTP, NULL, wPos - (wLen - 2));
9D013F38  3C02A000   LUI V0, -24576
9D013F3C  8C500574   LW S0, 1396(V0)
9D013F40  938281E8   LBU V0, -32280(GP)
9D013F44  00401821   ADDU V1, V0, ZERO
9D013F48  3C02A000   LUI V0, -24576
9D013F4C  000318C0   SLL V1, V1, 3
9D013F50  24420600   ADDIU V0, V0, 1536
9D013F54  00621021   ADDU V0, V1, V0
9D013F58  90420004   LBU V0, 4(V0)
9D013F5C  00401821   ADDU V1, V0, ZERO
9D013F60  97C4001C   LHU A0, 28(S8)
9D013F64  97C20038   LHU V0, 56(S8)
9D013F68  00821023   SUBU V0, A0, V0
9D013F6C  3042FFFF   ANDI V0, V0, -1
9D013F70  24420002   ADDIU V0, V0, 2
9D013F74  3042FFFF   ANDI V0, V0, -1
9D013F78  00602021   ADDU A0, V1, ZERO
9D013F7C  00002821   ADDU A1, ZERO, ZERO
9D013F80  00403021   ADDU A2, V0, ZERO
9D013F84  0F40077A   JAL TCPGetArray
9D013F88  00000000   NOP
9D013F8C  02021823   SUBU V1, S0, V0
9D013F90  3C02A000   LUI V0, -24576
9D013F94  AC430574   SW V1, 1396(V0)
1657:                		cData[wLen - 2] = '\0';
9D013F98  97C20038   LHU V0, 56(S8)
9D013F9C  2442FFFE   ADDIU V0, V0, -2
9D013FA0  8FC30034   LW V1, 52(S8)
9D013FA4  00621021   ADDU V0, V1, V0
9D013FA8  A0400000   SB ZERO, 0(V0)
1658:                		status = HTTP_READ_TRUNCATED;
9D013FAC  24020001   ADDIU V0, ZERO, 1
9D013FB0  AFC20018   SW V0, 24(S8)
9D013FB4  0B405007   J 0x9D01401C
9D013FB8  00000000   NOP
1659:                	}
1660:                	else
1661:                	{// Read the data normally
1662:                		curHTTP.byteCount -= TCPGetArray(sktHTTP, cData, wPos);
9D013FBC  3C02A000   LUI V0, -24576
9D013FC0  8C500574   LW S0, 1396(V0)
9D013FC4  938281E8   LBU V0, -32280(GP)
9D013FC8  00401821   ADDU V1, V0, ZERO
9D013FCC  3C02A000   LUI V0, -24576
9D013FD0  000318C0   SLL V1, V1, 3
9D013FD4  24420600   ADDIU V0, V0, 1536
9D013FD8  00621021   ADDU V0, V1, V0
9D013FDC  90420004   LBU V0, 4(V0)
9D013FE0  00401821   ADDU V1, V0, ZERO
9D013FE4  97C2001C   LHU V0, 28(S8)
9D013FE8  00602021   ADDU A0, V1, ZERO
9D013FEC  8FC50034   LW A1, 52(S8)
9D013FF0  00403021   ADDU A2, V0, ZERO
9D013FF4  0F40077A   JAL TCPGetArray
9D013FF8  00000000   NOP
9D013FFC  02021823   SUBU V1, S0, V0
9D014000  3C02A000   LUI V0, -24576
9D014004  AC430574   SW V1, 1396(V0)
1663:                		cData[wPos] = '\0';
9D014008  97C2001C   LHU V0, 28(S8)
9D01400C  8FC30034   LW V1, 52(S8)
9D014010  00621021   ADDU V0, V1, V0
9D014014  A0400000   SB ZERO, 0(V0)
1664:                		status = HTTP_READ_OK;
9D014018  AFC00018   SW ZERO, 24(S8)
1665:                	}
1666:                	
1667:                	// Remove the delimiter
1668:                	if(cDelim)
9D01401C  93C20030   LBU V0, 48(S8)
9D014020  10400011   BEQ V0, ZERO, 0x9D014068
9D014024  00000000   NOP
1669:                		curHTTP.byteCount -= TCPGet(sktHTTP, NULL);
9D014028  3C02A000   LUI V0, -24576
9D01402C  8C500574   LW S0, 1396(V0)
9D014030  938281E8   LBU V0, -32280(GP)
9D014034  00401821   ADDU V1, V0, ZERO
9D014038  3C02A000   LUI V0, -24576
9D01403C  000318C0   SLL V1, V1, 3
9D014040  24420600   ADDIU V0, V0, 1536
9D014044  00621021   ADDU V0, V1, V0
9D014048  90420004   LBU V0, 4(V0)
9D01404C  00402021   ADDU A0, V0, ZERO
9D014050  00002821   ADDU A1, ZERO, ZERO
9D014054  0F4006DD   JAL TCPGet
9D014058  00000000   NOP
9D01405C  02021823   SUBU V1, S0, V0
9D014060  3C02A000   LUI V0, -24576
9D014064  AC430574   SW V1, 1396(V0)
1670:                	
1671:                	return status;
9D014068  8FC20018   LW V0, 24(S8)
1672:                }	
9D01406C  03C0E821   ADDU SP, S8, ZERO
9D014070  8FBF002C   LW RA, 44(SP)
9D014074  8FBE0028   LW S8, 40(SP)
9D014078  8FB00024   LW S0, 36(SP)
9D01407C  27BD0030   ADDIU SP, SP, 48
9D014080  03E00008   JR RA
9D014084  00000000   NOP
1673:                #endif
1674:                
1675:                /*****************************************************************************
1676:                  Function:
1677:                	HTTP_IO_RESULT HTTPMPFSUpload(void)
1678:                
1679:                  Summary:
1680:                	Saves a file uploaded via POST as the new MPFS image in EEPROM or 
1681:                	external Flash.
1682:                
1683:                  Description:
1684:                	Allows the MPFS image in EEPROM or external Flash to be updated via a 
1685:                	web page by accepting a file upload and storing it to the external memory.
1686:                
1687:                  Precondition:
1688:                	MPFSFormat() has been called.
1689:                
1690:                  Parameters:
1691:                	None
1692:                
1693:                  Return Values:
1694:                	HTTP_IO_DONE - on success
1695:                	HTTP_IO_NEED_DATA - if more data is still expected
1696:                
1697:                  Remarks:
1698:                	This function is only available when MPFS uploads are enabled and
1699:                	the MPFS image is stored in EEPROM.
1700:                
1701:                  Internal:
1702:                	After the headers, the first line from the form will be the MIME
1703:                	separator.  Following that is more headers about the file, which
1704:                	are discarded.  After another CRLFCRLF pair the file data begins,
1705:                	which is read 16 bytes at a time and written to external memory.
1706:                  ***************************************************************************/
1707:                #if defined(HTTP_MPFS_UPLOAD)
1708:                static HTTP_IO_RESULT HTTPMPFSUpload(void)
1709:                {
1710:                	BYTE c[16];
1711:                	WORD lenA, lenB;
1712:                	
1713:                	switch(curHTTP.httpStatus)
1714:                	{
1715:                		// New upload, so look for the CRLFCRLF
1716:                		case HTTP_MPFS_UP:
1717:                		
1718:                			lenA = TCPFindROMArray(sktHTTP, (ROM BYTE*)"\r\n\r\n", 4, 0, FALSE);
1719:                		
1720:                			if(lenA != 0xffff)
1721:                			{// Found it, so remove all data up to and including
1722:                				lenA = TCPGetArray(sktHTTP, NULL, lenA);
1723:                				curHTTP.byteCount -= lenA;
1724:                				
1725:                				// Make sure first 6 bytes are also in
1726:                				if(TCPIsGetReady(sktHTTP) < (4u + 6u) )
1727:                				{
1728:                					lenA++;
1729:                					return HTTP_IO_NEED_DATA;
1730:                				}
1731:                				
1732:                				// Make sure it's an MPFS of the correct version
1733:                				lenA = TCPGetArray(sktHTTP, c, 10);
1734:                				curHTTP.byteCount -= lenA;
1735:                				if(memcmppgm2ram(c, (ROM void*)"\r\n\r\nMPFS\x02\x01", 10) == 0)
1736:                				{// Read as Ver 2.1
1737:                					curHTTP.httpStatus = HTTP_MPFS_OK;
1738:                					
1739:                					// Format MPFS storage and put 6 byte tag
1740:                					curHTTP.file = MPFSFormat();
1741:                					MPFSPutArray(curHTTP.file, &c[4], 6);
1742:                				}
1743:                				else
1744:                				{// Version is wrong
1745:                					curHTTP.httpStatus = HTTP_MPFS_ERROR;
1746:                				}
1747:                				
1748:                				return HTTP_IO_WAITING;
1749:                			}
1750:                			else
1751:                			{// Otherwise, remove as much as possible
1752:                				lenA = TCPGetArray(sktHTTP, NULL, TCPIsGetReady(sktHTTP) - 4);
1753:                				curHTTP.byteCount -= lenA;
1754:                			}
1755:                			
1756:                			break;
1757:                		
1758:                		// Received file is invalid
1759:                		case HTTP_MPFS_ERROR:
1760:                			curHTTP.byteCount -= TCPIsGetReady(sktHTTP);
1761:                			TCPDiscard(sktHTTP);
1762:                			if(curHTTP.byteCount < 100u || curHTTP.byteCount > 0x80000000u)
1763:                			{// If almost all data was read, or if we overflowed, then return
1764:                				smHTTP = SM_HTTP_SERVE_HEADERS;
1765:                				return HTTP_IO_DONE;
1766:                			}
1767:                			break;
1768:                		
1769:                		// File is verified, so write the data
1770:                		case HTTP_MPFS_OK:
1771:                			// Determine how much to read
1772:                			lenA = TCPIsGetReady(sktHTTP);
1773:                			if(lenA > curHTTP.byteCount)
1774:                				lenA = curHTTP.byteCount;
1775:                				
1776:                			while(lenA > 0u)
1777:                			{
1778:                				lenB = TCPGetArray(sktHTTP, c, mMIN(lenA,16u));
1779:                				curHTTP.byteCount -= lenB;
1780:                				lenA -= lenB;
1781:                				MPFSPutArray(curHTTP.file, c, lenB);
1782:                			}
1783:                				
1784:                			// If we've read all the data
1785:                			if(curHTTP.byteCount == 0u)
1786:                			{
1787:                				MPFSPutEnd(TRUE);
1788:                				smHTTP = SM_HTTP_SERVE_HEADERS;
1789:                				return HTTP_IO_DONE;
1790:                			}
1791:                			
1792:                		// Other states are not valid here
1793:                		default:
1794:                			break;
1795:                	}
1796:                		
1797:                	// Ask for more data
1798:                	return HTTP_IO_NEED_DATA;
1799:                	
1800:                }
1801:                #endif
1802:                
1803:                /*****************************************************************************
1804:                  Function:
1805:                	void HTTPIncFile(ROM BYTE* cFile)
1806:                
1807:                  Summary:
1808:                	Writes a file byte-for-byte to the currently loaded TCP socket.
1809:                
1810:                  Description:
1811:                	Allows an entire file to be included as a dynamic variable, providing
1812:                	a basic templating system for HTML web pages.  This reduces unneeded
1813:                	duplication of visual elements such as headers, menus, etc.
1814:                
1815:                	When curHTTP.callbackPos is 0, the file is opened and as many bytes
1816:                	as possible are written.  The current position is then saved to 
1817:                	curHTTP.callbackPos and the file is closed.  On subsequent calls, 
1818:                	reading begins at the saved location and continues.  Once the end of
1819:                	the input file is reached, curHTTP.callbackPos is set back to 0 to 
1820:                	indicate completion.
1821:                
1822:                  Precondition:
1823:                	None
1824:                
1825:                  Parameters:
1826:                	cFile - the name of the file to be sent
1827:                
1828:                  Returns:
1829:                  	None
1830:                  	
1831:                  Remarks:
1832:                	Users should not call this function directly, but should instead add
1833:                	dynamic variables in the form of ~inc:filename.ext~ in their HTML code
1834:                	to include (for example) the file "filename.ext" at that specified
1835:                	location.  The MPFS2 Generator utility will handle the rest.
1836:                  ***************************************************************************/
1837:                void HTTPIncFile(ROM BYTE* cFile)
1838:                {
9D014088  27BDFF98   ADDIU SP, SP, -104
9D01408C  AFBF0064   SW RA, 100(SP)
9D014090  AFBE0060   SW S8, 96(SP)
9D014094  AFB0005C   SW S0, 92(SP)
9D014098  03A0F021   ADDU S8, SP, ZERO
9D01409C  AFC40068   SW A0, 104(S8)
1839:                	WORD wCount, wLen;
1840:                	BYTE data[64];
1841:                	MPFS_HANDLE fp;
1842:                	
1843:                	// Check if this is a first round call
1844:                	if(curHTTP.callbackPos == 0x00u)
9D0140A0  3C02A000   LUI V0, -24576
9D0140A4  24420574   ADDIU V0, V0, 1396
9D0140A8  8C42000C   LW V0, 12(V0)
9D0140AC  14400012   BNE V0, ZERO, 0x9D0140F8
9D0140B0  00000000   NOP
1845:                	{// On initial call, open the file and save its ID
1846:                		fp = MPFSOpenROM(cFile);
9D0140B4  8FC40068   LW A0, 104(S8)
9D0140B8  0F409B86   JAL MPFSOpen
9D0140BC  00000000   NOP
9D0140C0  A3C20012   SB V0, 18(S8)
1847:                		if(fp == MPFS_INVALID_HANDLE)
9D0140C4  93C30012   LBU V1, 18(S8)
9D0140C8  240200FF   ADDIU V0, ZERO, 255
9D0140CC  10620069   BEQ V1, V0, 0x9D014274
9D0140D0  00000000   NOP
1848:                		{// File not found, so abort
1849:                			return;
9D014274  00000000   NOP
9D014278  0B4050A1   J 0x9D014284
9D01427C  00000000   NOP
1850:                		}
1851:                		((DWORD_VAL*)&curHTTP.callbackPos)->w[0] = MPFSGetID(fp);
9D0140D4  3C02A000   LUI V0, -24576
9D0140D8  24500580   ADDIU S0, V0, 1408
9D0140DC  93C20012   LBU V0, 18(S8)
9D0140E0  00402021   ADDU A0, V0, ZERO
9D0140E4  0F40A085   JAL MPFSGetID
9D0140E8  00000000   NOP
9D0140EC  A6020000   SH V0, 0(S0)
9D0140F0  0B405052   J 0x9D014148
9D0140F4  00000000   NOP
1852:                	}
1853:                	else
1854:                	{// The file was already opened, so load up its ID and seek
1855:                		fp = MPFSOpenID(((DWORD_VAL*)&curHTTP.callbackPos)->w[0]);
9D0140F8  3C02A000   LUI V0, -24576
9D0140FC  24420580   ADDIU V0, V0, 1408
9D014100  94420000   LHU V0, 0(V0)
9D014104  00402021   ADDU A0, V0, ZERO
9D014108  0F409C49   JAL MPFSOpenID
9D01410C  00000000   NOP
9D014110  A3C20012   SB V0, 18(S8)
1856:                		if(fp == MPFS_INVALID_HANDLE)
9D014114  93C30012   LBU V1, 18(S8)
9D014118  240200FF   ADDIU V0, ZERO, 255
9D01411C  10620058   BEQ V1, V0, 0x9D014280
9D014120  00000000   NOP
1857:                		{// No file handles available, so wait for now
1858:                			return;
9D014280  00000000   NOP
1859:                		}
1860:                		MPFSSeek(fp, ((DWORD_VAL*)&curHTTP.callbackPos)->w[1], MPFS_SEEK_FORWARD);
9D014124  93C30012   LBU V1, 18(S8)
9D014128  3C02A000   LUI V0, -24576
9D01412C  24420580   ADDIU V0, V0, 1408
9D014130  94420002   LHU V0, 2(V0)
9D014134  00602021   ADDU A0, V1, ZERO
9D014138  00402821   ADDU A1, V0, ZERO
9D01413C  24060002   ADDIU A2, ZERO, 2
9D014140  0F409DD9   JAL MPFSSeek
9D014144  00000000   NOP
1861:                	}
1862:                	
1863:                	// Get/put as many bytes as possible
1864:                	wCount = TCPIsPutReady(sktHTTP);
9D014148  938281E8   LBU V0, -32280(GP)
9D01414C  00401821   ADDU V1, V0, ZERO
9D014150  3C02A000   LUI V0, -24576
9D014154  000318C0   SLL V1, V1, 3
9D014158  24420600   ADDIU V0, V0, 1536
9D01415C  00621021   ADDU V0, V1, V0
9D014160  90420004   LBU V0, 4(V0)
9D014164  00402021   ADDU A0, V0, ZERO
9D014168  0F40038E   JAL TCPIsPutReady
9D01416C  00000000   NOP
9D014170  A7C20010   SH V0, 16(S8)
1865:                	while(wCount > 0u)
9D014174  0B40508B   J 0x9D01422C
9D014178  00000000   NOP
9D01422C  97C20010   LHU V0, 16(S8)
9D014230  1440FFD2   BNE V0, ZERO, 0x9D01417C
9D014234  00000000   NOP
1866:                	{
1867:                		wLen = MPFSGetArray(fp, data, mMIN(wCount, sizeof(data)));
9D01417C  93C40012   LBU A0, 18(S8)
9D014180  97C20010   LHU V0, 16(S8)
9D014184  3043FFFF   ANDI V1, V0, -1
9D014188  2C630041   SLTIU V1, V1, 65
9D01418C  14600002   BNE V1, ZERO, 0x9D014198
9D014190  00000000   NOP
9D014194  24020040   ADDIU V0, ZERO, 64
9D014198  3042FFFF   ANDI V0, V0, -1
9D01419C  27C30018   ADDIU V1, S8, 24
9D0141A0  00602821   ADDU A1, V1, ZERO
9D0141A4  00403021   ADDU A2, V0, ZERO
9D0141A8  0F409D30   JAL MPFSGetArray
9D0141AC  00000000   NOP
9D0141B0  A7C20014   SH V0, 20(S8)
1868:                		if(wLen == 0u)
9D0141B4  97C20014   LHU V0, 20(S8)
9D0141B8  1440000A   BNE V0, ZERO, 0x9D0141E4
9D0141BC  00000000   NOP
1869:                		{// If no bytes were read, an EOF was reached
1870:                			MPFSClose(fp);
9D0141C0  93C20012   LBU V0, 18(S8)
9D0141C4  00402021   ADDU A0, V0, ZERO
9D0141C8  0F409CA1   JAL MPFSClose
9D0141CC  00000000   NOP
1871:                			curHTTP.callbackPos = 0x00;
9D0141D0  3C02A000   LUI V0, -24576
9D0141D4  24420574   ADDIU V0, V0, 1396
9D0141D8  AC40000C   SW ZERO, 12(V0)
1872:                			return;
9D0141DC  0B4050A1   J 0x9D014284
9D0141E0  00000000   NOP
1873:                		}
1874:                		else
1875:                		{// Write the bytes to the socket
1876:                			TCPPutArray(sktHTTP, data, wLen);
9D0141E4  938281E8   LBU V0, -32280(GP)
9D0141E8  00401821   ADDU V1, V0, ZERO
9D0141EC  3C02A000   LUI V0, -24576
9D0141F0  000318C0   SLL V1, V1, 3
9D0141F4  24420600   ADDIU V0, V0, 1536
9D0141F8  00621021   ADDU V0, V1, V0
9D0141FC  90420004   LBU V0, 4(V0)
9D014200  00402021   ADDU A0, V0, ZERO
9D014204  97C20014   LHU V0, 20(S8)
9D014208  27C30018   ADDIU V1, S8, 24
9D01420C  00602821   ADDU A1, V1, ZERO
9D014210  00403021   ADDU A2, V0, ZERO
9D014214  0F4004E1   JAL TCPPutArray
9D014218  00000000   NOP
1877:                			wCount -= wLen;
9D01421C  97C30010   LHU V1, 16(S8)
9D014220  97C20014   LHU V0, 20(S8)
9D014224  00621023   SUBU V0, V1, V0
9D014228  A7C20010   SH V0, 16(S8)
1878:                		}
1879:                	}
1880:                	
1881:                	// Save the new address and close the file
1882:                	((DWORD_VAL*)&curHTTP.callbackPos)->w[1] = MPFSTell(fp);
9D014238  3C02A000   LUI V0, -24576
9D01423C  24500580   ADDIU S0, V0, 1408
9D014240  93C20012   LBU V0, 18(S8)
9D014244  00402021   ADDU A0, V0, ZERO
9D014248  0F40A06B   JAL MPFSGetPosition
9D01424C  00000000   NOP
9D014250  3042FFFF   ANDI V0, V0, -1
9D014254  A6020002   SH V0, 2(S0)
1883:                	MPFSClose(fp);
9D014258  93C20012   LBU V0, 18(S8)
9D01425C  00402021   ADDU A0, V0, ZERO
9D014260  0F409CA1   JAL MPFSClose
9D014264  00000000   NOP
1884:                	
1885:                	return;
9D014268  00000000   NOP
9D01426C  0B4050A1   J 0x9D014284
9D014270  00000000   NOP
1886:                }
9D014284  03C0E821   ADDU SP, S8, ZERO
9D014288  8FBF0064   LW RA, 100(SP)
9D01428C  8FBE0060   LW S8, 96(SP)
9D014290  8FB0005C   LW S0, 92(SP)
9D014294  27BD0068   ADDIU SP, SP, 104
9D014298  03E00008   JR RA
9D01429C  00000000   NOP
1887:                
1888:                
1889:                #endif
---  C:/Users/Diego/Documents/GitHub/pic32webFREERtos/Pic32Web.X/src/tcpip/src/ENCX24J600.c  ------------
1:                   /*********************************************************************
2:                    *
3:                    *	Medium Access Control (MAC) Layer for Microchip ENC624J600/424J600
4:                    *  Module for Microchip TCP/IP Stack
5:                    *	 -Provides access to ENC424J600/624J600 Ethernet controller
6:                    *	 -Reference: ENC424J600/624J600 Data sheet (DS39935), IEEE 802.3 
7:                    *    Standard
8:                    *
9:                    *********************************************************************
10:                   * FileName:        ENCX24J600.c
11:                   * Dependencies:    ENCX24J600.h
12:                   *					MAC.h
13:                   *					string.h
14:                   *                  Helpers.h
15:                   *					Delay.h
16:                   * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32
17:                   * Compiler:        Microchip C32 v1.05 or higher
18:                   *					Microchip C30 v3.12 or higher
19:                   *					Microchip C18 v3.30 or higher
20:                   *					HI-TECH PICC-18 PRO 9.63PL2 or higher
21:                   * Company:         Microchip Technology, Inc.
22:                   *
23:                   * Software License Agreement
24:                   *
25:                   * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights
26:                   * reserved.
27:                   *
28:                   * Microchip licenses to you the right to use, modify, copy, and
29:                   * distribute:
30:                   * (i)  the Software when embedded on a Microchip microcontroller or
31:                   *      digital signal controller product ("Device") which is
32:                   *      integrated into Licensee's product; or
33:                   * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h,
34:                   *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device
35:                   *		used in conjunction with a Microchip ethernet controller for
36:                   *		the sole purpose of interfacing with the ethernet controller.
37:                   *
38:                   * You should refer to the license agreement accompanying this
39:                   * Software for additional information regarding your rights and
40:                   * obligations.
41:                   *
42:                   * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT
43:                   * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT
44:                   * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A
45:                   * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL
46:                   * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR
47:                   * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF
48:                   * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS
49:                   * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE
50:                   * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER
51:                   * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT
52:                   * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE.
53:                   *
54:                   *
55:                   * Author               Date   		Comment
56:                   *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
57:                   * Howard Schlunder		12/07/07	Original
58:                   ********************************************************************/
59:                  #define __ENCX24J600_C
60:                  
61:                  #include "HardwareProfile.h"
62:                  
63:                  // Make sure that this hardware profile has an ENC424J600/624J600 in it
64:                  #if defined(ENC100_INTERFACE_MODE)
65:                  
66:                  #include "TCPIP Stack/TCPIP.h"
67:                  #include "TCPIP Stack/ENCX24J600.h"
68:                  
69:                  #include <stdarg.h>
70:                  
71:                  /** D E F I N I T I O N S ****************************************************/
72:                  #define ENC100_MAX_SPI_FREQ		(14000000ul)	// Hz
73:                  
74:                  // Configuration constants for diagnostics only.  If you don't define any of 
75:                  // these constants, auto-negotiation will be used (strongly recommended).
76:                  //#define ENC100_FORCE_10MBPS_HALF_DUPLEX
77:                  //#define ENC100_FORCE_10MBPS_FULL_DUPLEX
78:                  //#define ENC100_FORCE_100MBPS_HALF_DUPLEX
79:                  //#define ENC100_FORCE_100MBPS_FULL_DUPLEX
80:                  
81:                  
82:                  // Pseudo Functions - these should not need changing unless porting to a new 
83:                  // processor type or speed.
84:                  // DelaySetupHold() should wait at least 75ns to meet Tpsp2 (RD to Data Valid)
85:                  #define DelaySetupHold()		do{Nop();Nop();}while(0)
86:                  #if (GetInstructionClock() > 16000000ul)
87:                  	#undef DelaySetupHold
88:                  	#define DelaySetupHold()	do{Nop();Nop();Nop();}while(0)
89:                  #endif
90:                  #if (GetInstructionClock() > 32000000ul)
91:                  	#undef DelaySetupHold
92:                  	#define DelaySetupHold()	do{Nop();Nop();Nop();Nop();}while(0)
93:                  #endif
94:                  #if (GetInstructionClock() > 48000000ul)
95:                  	#undef DelaySetupHold
96:                  	#define DelaySetupHold()	do{Nop();Nop();Nop();Nop();Nop();}while(0)
97:                  #endif
98:                  #if (GetInstructionClock() > 64000000ul)
99:                  	#undef DelaySetupHold
100:                 	#define DelaySetupHold()	do{Nop();Nop();Nop();Nop();Nop();Nop();}while(0)
101:                 #endif
102:                 
103:                 #if defined(__PIC32MX__)
104:                 	#define PMDIN1		PMDIN
105:                 #endif
106:                 #if (ENC100_INTERFACE_MODE >= 1)	// Parallel mode
107:                 	#if defined(ENC100_CS_TRIS)
108:                 		#define AssertChipSelect()		do{ENC100_CS_IO = 1;}while(0)
109:                 		#define DeassertChipSelect()	do{ENC100_CS_IO = 0;}while(0)
110:                 	#else
111:                 		#define AssertChipSelect()
112:                 		#define DeassertChipSelect()
113:                 	#endif
114:                 #else						// SPI mode
115:                 	#define AssertChipSelect()			do{ENC100_CS_IO = 0;}while(0)
116:                 	#define DeassertChipSelect()		do{ENC100_CS_IO = 1;}while(0)
117:                 
118:                 	#if defined (__18CXX)
119:                 	    #define ClearSPIDoneFlag()  do{ENC100_SPI_IF = 0;}while(0)
120:                 	    #define WaitForDataByte()   do{while(!ENC100_SPI_IF); ENC100_SPI_IF = 0;}while(0)
121:                 	#elif defined(__C30__)
122:                 	    #define ClearSPIDoneFlag()
123:                 	    static inline __attribute__((__always_inline__)) void WaitForDataByte(void)
124:                 	    {
125:                 	        while ((ENC100_SPISTATbits.SPITBF == 1) || (ENC100_SPISTATbits.SPIRBF == 0));
126:                 	    }
127:                 	#elif defined( __PIC32MX__ )
128:                 	    #define ClearSPIDoneFlag()
129:                 	    static inline __attribute__((__always_inline__)) void WaitForDataByte(void)
130:                 	    {
131:                 	        while (!ENC100_SPISTATbits.SPITBE || !ENC100_SPISTATbits.SPIRBF);
9D01DCA0  3C02BF80   LUI V0, -16512
9D01DCA4  8C425A10   LW V0, 23056(V0)
9D01DCA8  30420008   ANDI V0, V0, 8
9D01DCAC  1040FFFC   BEQ V0, ZERO, 0x9D01DCA0
9D01DCB0  00000000   NOP
9D01DCB4  3C02BF80   LUI V0, -16512
9D01DCB8  8C425A10   LW V0, 23056(V0)
9D01DCBC  30420001   ANDI V0, V0, 1
9D01DCC0  1040FFF7   BEQ V0, ZERO, 0x9D01DCA0
9D01DCC4  00000000   NOP
9D01DD7C  3C02BF80   LUI V0, -16512
9D01DD80  8C425A10   LW V0, 23056(V0)
9D01DD84  30420008   ANDI V0, V0, 8
9D01DD88  1040FFFC   BEQ V0, ZERO, 0x9D01DD7C
9D01DD8C  00000000   NOP
9D01DD90  3C02BF80   LUI V0, -16512
9D01DD94  8C425A10   LW V0, 23056(V0)
9D01DD98  30420001   ANDI V0, V0, 1
9D01DD9C  1040FFF7   BEQ V0, ZERO, 0x9D01DD7C
9D01DDA0  00000000   NOP
9D01DDCC  3C02BF80   LUI V0, -16512
9D01DDD0  8C425A10   LW V0, 23056(V0)
9D01DDD4  30420008   ANDI V0, V0, 8
9D01DDD8  1040FFFC   BEQ V0, ZERO, 0x9D01DDCC
9D01DDDC  00000000   NOP
9D01DDE0  3C02BF80   LUI V0, -16512
9D01DDE4  8C425A10   LW V0, 23056(V0)
9D01DDE8  30420001   ANDI V0, V0, 1
9D01DDEC  1040FFF7   BEQ V0, ZERO, 0x9D01DDCC
9D01DDF0  00000000   NOP
9D01DE20  3C02BF80   LUI V0, -16512
9D01DE24  8C425A10   LW V0, 23056(V0)
9D01DE28  30420008   ANDI V0, V0, 8
9D01DE2C  1040FFFC   BEQ V0, ZERO, 0x9D01DE20
9D01DE30  00000000   NOP
9D01DE34  3C02BF80   LUI V0, -16512
9D01DE38  8C425A10   LW V0, 23056(V0)
9D01DE3C  30420001   ANDI V0, V0, 1
9D01DE40  1040FFF7   BEQ V0, ZERO, 0x9D01DE20
9D01DE44  00000000   NOP
9D01DF14  3C02BF80   LUI V0, -16512
9D01DF18  8C425A10   LW V0, 23056(V0)
9D01DF1C  30420008   ANDI V0, V0, 8
9D01DF20  1040FFFC   BEQ V0, ZERO, 0x9D01DF14
9D01DF24  00000000   NOP
9D01DF28  3C02BF80   LUI V0, -16512
9D01DF2C  8C425A10   LW V0, 23056(V0)
9D01DF30  30420001   ANDI V0, V0, 1
9D01DF34  1040FFF7   BEQ V0, ZERO, 0x9D01DF14
9D01DF38  00000000   NOP
9D01DF64  3C02BF80   LUI V0, -16512
9D01DF68  8C425A10   LW V0, 23056(V0)
9D01DF6C  30420008   ANDI V0, V0, 8
9D01DF70  1040FFFC   BEQ V0, ZERO, 0x9D01DF64
9D01DF74  00000000   NOP
9D01DF78  3C02BF80   LUI V0, -16512
9D01DF7C  8C425A10   LW V0, 23056(V0)
9D01DF80  30420001   ANDI V0, V0, 1
9D01DF84  1040FFF7   BEQ V0, ZERO, 0x9D01DF64
9D01DF88  00000000   NOP
9D01DFB8  3C02BF80   LUI V0, -16512
9D01DFBC  8C425A10   LW V0, 23056(V0)
9D01DFC0  30420008   ANDI V0, V0, 8
9D01DFC4  1040FFFC   BEQ V0, ZERO, 0x9D01DFB8
9D01DFC8  00000000   NOP
9D01DFCC  3C02BF80   LUI V0, -16512
9D01DFD0  8C425A10   LW V0, 23056(V0)
9D01DFD4  30420001   ANDI V0, V0, 1
9D01DFD8  1040FFF7   BEQ V0, ZERO, 0x9D01DFB8
9D01DFDC  00000000   NOP
9D01E010  3C02BF80   LUI V0, -16512
9D01E014  8C425A10   LW V0, 23056(V0)
9D01E018  30420008   ANDI V0, V0, 8
9D01E01C  1040FFFC   BEQ V0, ZERO, 0x9D01E010
9D01E020  00000000   NOP
9D01E024  3C02BF80   LUI V0, -16512
9D01E028  8C425A10   LW V0, 23056(V0)
9D01E02C  30420001   ANDI V0, V0, 1
9D01E030  1040FFF7   BEQ V0, ZERO, 0x9D01E010
9D01E034  00000000   NOP
9D01E0FC  3C02BF80   LUI V0, -16512
9D01E100  8C425A10   LW V0, 23056(V0)
9D01E104  30420008   ANDI V0, V0, 8
9D01E108  1040FFFC   BEQ V0, ZERO, 0x9D01E0FC
9D01E10C  00000000   NOP
9D01E110  3C02BF80   LUI V0, -16512
9D01E114  8C425A10   LW V0, 23056(V0)
9D01E118  30420001   ANDI V0, V0, 1
9D01E11C  1040FFF7   BEQ V0, ZERO, 0x9D01E0FC
9D01E120  00000000   NOP
9D01E144  3C02BF80   LUI V0, -16512
9D01E148  8C425A10   LW V0, 23056(V0)
9D01E14C  30420008   ANDI V0, V0, 8
9D01E150  1040FFFC   BEQ V0, ZERO, 0x9D01E144
9D01E154  00000000   NOP
9D01E158  3C02BF80   LUI V0, -16512
9D01E15C  8C425A10   LW V0, 23056(V0)
9D01E160  30420001   ANDI V0, V0, 1
9D01E164  1040FFF7   BEQ V0, ZERO, 0x9D01E144
9D01E168  00000000   NOP
9D01E254  3C02BF80   LUI V0, -16512
9D01E258  8C425A10   LW V0, 23056(V0)
9D01E25C  30420008   ANDI V0, V0, 8
9D01E260  1040FFFC   BEQ V0, ZERO, 0x9D01E254
9D01E264  00000000   NOP
9D01E268  3C02BF80   LUI V0, -16512
9D01E26C  8C425A10   LW V0, 23056(V0)
9D01E270  30420001   ANDI V0, V0, 1
9D01E274  1040FFF7   BEQ V0, ZERO, 0x9D01E254
9D01E278  00000000   NOP
9D01E2B4  3C02BF80   LUI V0, -16512
9D01E2B8  8C425A10   LW V0, 23056(V0)
9D01E2BC  30420008   ANDI V0, V0, 8
9D01E2C0  1040FFFC   BEQ V0, ZERO, 0x9D01E2B4
9D01E2C4  00000000   NOP
9D01E2C8  3C02BF80   LUI V0, -16512
9D01E2CC  8C425A10   LW V0, 23056(V0)
9D01E2D0  30420001   ANDI V0, V0, 1
9D01E2D4  1040FFF7   BEQ V0, ZERO, 0x9D01E2B4
9D01E2D8  00000000   NOP
132:                 	    }
133:                 	#else
134:                 	    #error Determine SPI flag mechanism
135:                 	#endif
136:                 #endif
137:                 
138:                 
139:                 // Binary constant identifiers for ReadMemoryWindow() and WriteMemoryWindow() 
140:                 // functions
141:                 #define UDA_WINDOW		(0x1)
142:                 #define GP_WINDOW		(0x2)
143:                 #define RX_WINDOW		(0x4)
144:                 
145:                 
146:                 #define ETHER_IP		((WORD)0x00)
147:                 #define ETHER_ARP		((WORD)0x06)
148:                 
149:                 
150:                 // A header appended at the start of all RX frames by the hardware
151:                 typedef struct  __attribute__((aligned(2), packed))
152:                 {
153:                     WORD			NextPacketPointer;
154:                     RXSTATUS		StatusVector;
155:                 
156:                     MAC_ADDR        DestMACAddr;
157:                     MAC_ADDR        SourceMACAddr;
158:                     WORD_VAL        Type;
159:                 } ENC100_PREAMBLE;
160:                 
161:                 
162:                 
163:                 // Internal MAC level variables and flags.
164:                 static BYTE vCurrentBank;
165:                 static WORD wCurrentPacketPointer;
166:                 static WORD wNextPacketPointer;
167:                 static struct
168:                 {
169:                 	unsigned char bWasDiscarded:1;		// Status tracking bit indicating if the last received packet has been discarded via MACDiscardRx() or not.
170:                 	unsigned char PoweredDown:1;		// Local cached bit indicating CRYPTEN == ETHEN == 0 and PSLEEP == 1
171:                 	unsigned char CryptoEnabled:1;		// Local cached bit indicating CRYPTEN == 1
172:                 } ENC100Flags;
173:                 
174:                 
175:                 // Internal MAC level functions
176:                 void ENC100DumpState(void);
177:                 static void SendSystemReset(void);
178:                 static void ToggleCRYPTEN(void);
179:                 static WORD ReadReg(WORD wAddress);
180:                 static void WriteReg(WORD wAddress, WORD wValue);
181:                 static void BFSReg(WORD wAddress, WORD wBitMask);
182:                 static void BFCReg(WORD wAddress, WORD wBitMask);
183:                 static void ReadMemoryWindow(BYTE vWindow, BYTE *vData, WORD wLength);
184:                 static void WriteMemoryWindow(BYTE vWindow, BYTE *vData, WORD wLength);
185:                 #if ENC100_INTERFACE_MODE == 0
186:                 	static void Execute0(BYTE vOpcode);
187:                 	//static BYTE Execute1(BYTE vOpcode, BYTE wDataIn);	// Not currently used
188:                 	static WORD Execute2(BYTE vOpcode, WORD wDataIn);
189:                 	static DWORD Execute3(BYTE vOpcode, DWORD dwDataIn);
190:                 	static void ReadN(BYTE vOpcode, BYTE* vData, WORD wDataLen);
191:                 	static void WriteN(BYTE vOpcode, BYTE* vData, WORD wDataLen);
192:                 #else
193:                 	static void ReadMemory(WORD wAddress, BYTE *vData, WORD wLength);
194:                 	static void WriteMemory(WORD wAddress, BYTE *vData, WORD wLength);
195:                 #endif
196:                 
197:                 
198:                 
199:                 // Compute some PMP register values
200:                 #if   ENC100_INTERFACE_MODE == 1	// Parallel Mode 1: 8-bit demultiplexed (RD/WR)
201:                 	#define PMP_ADRMUX		0x0			// Full demuxing of address and data
202:                 	#define PMP_MODE16		0			// 8 bit
203:                 	#define PMP_MODE		0x2			// Master mode 2: PMRD & PMWR, not PMRD/PMWR & PMENB
204:                 	#define PMP_ADR_PINS	ENC100_TRANSLATE_TO_PIN_ADDR(0x7FFF)
205:                 #elif ENC100_INTERFACE_MODE == 2	// Parallel Mode 2: 8-bit demultiplexed (RW/EN)
206:                 	#define PMP_ADRMUX		0x0			// Full demuxing of address and data
207:                 	#define PMP_MODE16		0			// 8 bit
208:                 	#define PMP_MODE		0x3			// Master mode 1: PMRD/PMWR & PMENB, not PMRD & PMWR
209:                 	#define PMP_ADR_PINS	ENC100_TRANSLATE_TO_PIN_ADDR(0x7FFF)
210:                 #elif ENC100_INTERFACE_MODE == 3	// Parallel Mode 3: 16-bit demultiplexed (RD/WR)
211:                 	#define PMP_ADRMUX		0x0			// Full demuxing of address and data
212:                 	#define PMP_MODE16		1			// 16 bit
213:                 	#define PMP_MODE		0x2			// Master mode 2: PMRD & PMWR, not PMRD/PMWR & PMENB
214:                 	#define PMP_ADR_PINS	ENC100_TRANSLATE_TO_PIN_ADDR(0x3FFF)
215:                 #elif ENC100_INTERFACE_MODE == 4	// Parallel Mode 4: 16-bit demultiplexed (RW/EN)
216:                 	#define PMP_ADRMUX		0x0			// Full demuxing of address and data
217:                 	#define PMP_MODE16		1			// 16 bit
218:                 	#define PMP_MODE		0x3			// Master mode 1: PMRD/PMWR & PMENB, not PMRD & PMWR
219:                 	#define PMP_ADR_PINS	ENC100_TRANSLATE_TO_PIN_ADDR(0x3FFF)
220:                 #elif ENC100_INTERFACE_MODE == 5	// Parallel Mode 5: 8-bit multiplexed (RD/WR)
221:                 	#define PMP_ADRMUX		0x1			// Partially multiplexed address and data
222:                 	#define PMP_MODE16		0			// 8 bit
223:                 	#define PMP_MODE		0x2			// Master mode 2: PMRD & PMWR, not PMRD/PMWR & PMENB
224:                 	#define PMP_ADR_PINS	(ENC100_TRANSLATE_TO_PIN_ADDR(0x7F00) | 0x0001)
225:                 #elif ENC100_INTERFACE_MODE == 6	// Parallel Mode 6: 8-bit multiplexed (RW/EN)
226:                 	#define PMP_ADRMUX		0x1			// Partially multiplexed address and data
227:                 	#define PMP_MODE16		0			// 8 bit
228:                 	#define PMP_MODE		0x3			// Master mode 1: PMRD/PMWR & PMENB, not PMRD & PMWR
229:                 	#define PMP_ADR_PINS	(ENC100_TRANSLATE_TO_PIN_ADDR(0x7F00) | 0x0001)
230:                 #elif ENC100_INTERFACE_MODE == 9	// Parallel Mode 9: 16-bit multiplexed (RD/WR)
231:                 	#define PMP_ADRMUX		0x3			// Fully multiplexed address and data
232:                 	#define PMP_MODE16		1			// 16 bit
233:                 	#define PMP_MODE		0x2			// Master mode 2: PMRD & PMWR, not PMRD/PMWR & PMENB
234:                 	#define PMP_ADR_PINS	0x0001
235:                 #elif ENC100_INTERFACE_MODE == 10	// Parallel Mode 10: 16-bit multiplexed (RW/EN)
236:                 	#define PMP_ADRMUX		0x3			// Fully multiplexed address and data
237:                 	#define PMP_MODE16		1			// 16 bit
238:                 	#define PMP_MODE		0x3			// Master mode 1: PMRD/PMWR & PMENB, not PMRD & PMWR
239:                 	#define PMP_ADR_PINS	0x0001
240:                 #endif
241:                 
242:                 // Calculate the minimum number of wait states to ensure a 75ns or longer pulse width for READ and WRITE strobes
243:                 #if defined(__PIC32MX__)	// PIC32 is offset by one (i.e. 0 = one wait state)
244:                 	#define OPTIMAL_PMP_WAIT_STATES ((BYTE)((double)GetPeripheralClock()*0.000000075))
245:                 #else
246:                 	#define OPTIMAL_PMP_WAIT_STATES ((BYTE)((double)GetPeripheralClock()*0.000000075 + 0.9999))
247:                 #endif
248:                 
249:                 #if ((ENC100_INTERFACE_MODE == 3) || (ENC100_INTERFACE_MODE == 4) || (ENC100_INTERFACE_MODE == 9) || (ENC100_INTERFACE_MODE == 10)) && !defined(ENC100_BIT_BANG_PMP)
250:                 	#if !defined(__PIC32MX__)
251:                 		#error "16-bit PMP mode is only available on PIC32.  Use big bang mode or ENC100_INTERFACE_MODE of 1, 2, 5, or 6 (8-bit) instead."
252:                 	#endif
253:                 #endif
254:                 
255:                 	
256:                 
257:                 // Compute optimal SPI speed and define the ConfigureSPIModule() macro function 
258:                 // to load it up quickly whenever we want to use the SPI
259:                 #if defined(__18CXX)
260:                 	#define OPTIMAL_PRESCALE	0x00	// Default to divide by 4 setting
261:                 	#if GetPeripheralClock() > ENC100_MAX_SPI_FREQ
262:                 		#undef OPTIMAL_PRESCALE
263:                 		#define OPTIMAL_PRESCALE 0x01	// Use divide by 16 setting
264:                 	#endif	
265:                 	#if GetPeripheralClock()/16 > ENC100_MAX_SPI_FREQ
266:                 		#undef OPTIMAL_PRESCALE
267:                 		#define OPTIMAL_PRESCALE 0x02	// Use divide by 64 setting
268:                 	#endif
269:                 	#define ConfigureSPIModule()	do{																				\
270:                 										ENC100_SPICON1 = 0;							/* SSPEN = 0 */					\
271:                 										ENC100_SPISTAT = 0x40;						/* CKE = 1 (transmit data on rising edge), SMP = 0 (sample at middle of output time) */ \
272:                 										ENC100_SPICON1 = OPTIMAL_PRESCALE | 0x20;	/* SSPEN = 1, set clock speed */\
273:                 									}while(0)
274:                 	#define PMCONbits	PMCONHbits	// Remap for PMPEN bit accessed inline
275:                 	#define ConfigurePMPModule()	do{																				\
276:                 										PMCONHbits.PMPEN = 0;														\
277:                 										PMCONH = (PMP_ADRMUX<<3) | 0x03;	/* PTWREN = 1, PTRDEN = 1 */			\
278:                 										PMCONL = 0x23;						/* ALP = 1, WRSP = 1, RDSP = 1 */		\
279:                 										PMMODEH = (PMP_MODE16<<2) | (PMP_MODE);										\
280:                 										PMMODEL = (OPTIMAL_PMP_WAIT_STATES<<2);										\
281:                 										PMAENH = ((BYTE)(PMP_ADR_PINS>>8));											\
282:                 										PMAENL = ((BYTE)PMP_ADR_PINS);												\
283:                 										PMCONHbits.PMPEN = 1;														\
284:                 									}while(0)
285:                 #elif defined(__C30__)
286:                 	// Ensure SPI doesn't exceed processor limit
287:                 	#if (defined(__PIC24F__) || defined(__PIC24FK__) || defined(__PIC24H__) || defined(__dsPIC33F__)) && ENC100_MAX_SPI_FREQ > 8000000
288:                 		#undef ENC100_MAX_SPI_FREQ
289:                 		#define ENC100_MAX_SPI_FREQ	8000000
290:                 	#endif
291:                 	#if defined(__dsPIC30F__) && ENC100_MAX_SPI_FREQ > 10000000
292:                 		#undef ENC100_MAX_SPI_FREQ
293:                 		#define ENC100_MAX_SPI_FREQ	10000000
294:                 	#endif
295:                     
296:                     // Calculate optimal primary and secondary prescalers to make an SPI clock no faster than ENC100_MAX_SPI_FREQ
297:                    	#define OPTIMAL_PRESCALE		((((~((GetPeripheralClock()/64+ENC100_MAX_SPI_FREQ-1)/ENC100_MAX_SPI_FREQ - 1)) & 0x7)<<2) | 0x0)
298:                     #if GetPeripheralClock()/8/16 <= ENC100_MAX_SPI_FREQ
299:                     	#undef OPTIMAL_PRESCALE
300:                     	#define OPTIMAL_PRESCALE	((((~((GetPeripheralClock()/16+ENC100_MAX_SPI_FREQ-1)/ENC100_MAX_SPI_FREQ - 1)) & 0x7)<<2) | 0x1)
301:                     #endif
302:                     #if GetPeripheralClock()/8/4 <= ENC100_MAX_SPI_FREQ
303:                     	#undef OPTIMAL_PRESCALE
304:                    		#define OPTIMAL_PRESCALE	((((~((GetPeripheralClock()/4+ENC100_MAX_SPI_FREQ-1)/ENC100_MAX_SPI_FREQ - 1)) & 0x7)<<2) | 0x2)
305:                     #endif
306:                     #if GetPeripheralClock()/8/1 <= ENC100_MAX_SPI_FREQ
307:                     	#undef OPTIMAL_PRESCALE
308:                     	#define OPTIMAL_PRESCALE	((((~((GetPeripheralClock()/1+ENC100_MAX_SPI_FREQ-1)/ENC100_MAX_SPI_FREQ - 1)) & 0x7)<<2) | 0x3)
309:                     #endif
310:                 
311:                 	// Work around 1:1, 1:1 SPI errata on early PIC24FJ128GA010, PIC24HJ256GP610, dsPIC33FJ256GP710, etc. silicon where SCK stops running
312:                 	#if (defined(__PIC24F__) || defined(__PIC24H__) || defined(__dsPIC33F__)) && (OPTIMAL_PRESCALE == 0x1F)
313:                 		#undef OPTIMAL_PRESCALE
314:                 		#define OPTIMAL_PRESCALE	0x1B
315:                 	#endif
316:                 
317:                 
318:                 	#define ConfigureSPIModule()	do{																									\
319:                 										ENC100_SPISTAT = 0;										/* Turn off SPI */						\
320:                 										ENC100_SPICON1 = OPTIMAL_PRESCALE | 0x0100 | 0x0020;	/* CKE = 1, MSTEN = 1 */				\
321:                 									    ENC100_SPICON2 = 0;										/* Legacy non enhanced buffering */		\
322:                 									    ENC100_SPISTAT = 0x8000;								/* Turn on SPI */						\
323:                 									}while(0)
324:                 
325:                 	#define ConfigurePMPModule()	do{																									\
326:                 										PMCONbits.PMPEN = 0;																			\
327:                 										PMCON = (PMP_ADRMUX<<11) | 0x0323;	/* PTWREN = 1, PTRDEN = 1, ALP = 1, WRSP = 1, RDSP = 1 */	\
328:                 										PMMODE = (PMP_MODE16<<10) | (PMP_MODE<<8) | (OPTIMAL_PMP_WAIT_STATES<<2);						\
329:                 										PMAEN = PMP_ADR_PINS;																			\
330:                 										PADCFG1bits.PMPTTL = 0;				/* Use schmitt trigger input buffers */						\
331:                 										PMCONbits.PMPEN = 1;																			\
332:                 									}while(0)
333:                 #elif defined(__C32__)
334:                 	#define ConfigureSPIModule()	do{																									\
335:                 										ENC100_SPICON1 = 0;					/* Turn off SPI */											\
336:                 										ENC100_SPIBRG = (GetPeripheralClock()-1ul)/2ul/ENC100_MAX_SPI_FREQ;								\
337:                 										ENC100_SPICON1 = 0x00008320;		/* ON = 1, SMP = 1, CKE = 1, MSTEN = 1 */					\
338:                 									}while(0)
339:                 	#define ConfigurePMPModule()	do{																									\
340:                 										PMCONbits.PMPEN = 0;																			\
341:                 										PMCON = (PMP_ADRMUX<<11) | 0x0323;	/* PMPTTL = 0, PTWREN = 1, PTRDEN = 1, ALP = 1, WRSP = 1, RDSP = 1 */	\
342:                 										PMMODE = (PMP_MODE16<<10) | (PMP_MODE<<8) | (OPTIMAL_PMP_WAIT_STATES<<2);						\
343:                 										PMAEN = PMP_ADR_PINS;																			\
344:                 										PMCONbits.PMPEN = 1;																			\
345:                 									}while(0)
346:                 #endif
347:                 
348:                 /******************************************************************************
349:                  * Function:        void ENC100Init(void)
350:                  *
351:                  * PreCondition:    None
352:                  *
353:                  * Input:           None
354:                  *
355:                  * Output:          None
356:                  *
357:                  * Side Effects:    None
358:                  *
359:                  * Overview:        MACInit sets up the PIC's SPI module and all the 
360:                  *					registers in the ENCX24J600 so that normal operation can 
361:                  *					begin.
362:                  *
363:                  * Note:            None
364:                  *****************************************************************************/
365:                 void MACInit(void)
366:                 {
9D01C5F8  27BDFFE0   ADDIU SP, SP, -32
9D01C5FC  AFBF001C   SW RA, 28(SP)
9D01C600  AFBE0018   SW S8, 24(SP)
9D01C604  03A0F021   ADDU S8, SP, ZERO
367:                 	WORD w;
368:                 
369:                 	#if defined(ENC100_INT_TRIS)	// Interrupt output from ENCx24J600
370:                 		ENC100_INT_TRIS = 1;
9D01C608  3C03BF88   LUI V1, -16504
9D01C60C  8C626100   LW V0, 24832(V1)
9D01C610  24040001   ADDIU A0, ZERO, 1
9D01C614  7C824A44   INS V0, A0, 9, 1
9D01C618  AC626100   SW V0, 24832(V1)
371:                 	#endif
372:                 	#if defined(ENC100_MDIX_TRIS)	// MDIX control pin from PIC
373:                 		ENC100_MDIX_TRIS = 0;
9D01C61C  3C03BF88   LUI V1, -16504
9D01C620  8C626040   LW V0, 24640(V1)
9D01C624  7C0218C4   INS V0, ZERO, 3, 1
9D01C628  AC626040   SW V0, 24640(V1)
374:                 		ENC100_MDIX_IO = 0;
9D01C62C  3C03BF88   LUI V1, -16504
9D01C630  8C626060   LW V0, 24672(V1)
9D01C634  7C0218C4   INS V0, ZERO, 3, 1
9D01C638  AC626060   SW V0, 24672(V1)
375:                 	#endif
376:                 
377:                 	#if defined(ENC100_CS_TRIS)		// Chip Select line from PIC
378:                 		DeassertChipSelect();
9D01C63C  3C03BF88   LUI V1, -16504
9D01C640  8C626160   LW V0, 24928(V1)
9D01C644  24040001   ADDIU A0, ZERO, 1
9D01C648  7C826304   INS V0, A0, 12, 1
9D01C64C  AC626160   SW V0, 24928(V1)
379:                 		ENC100_CS_TRIS = 0;
9D01C650  3C03BF88   LUI V1, -16504
9D01C654  8C626140   LW V0, 24896(V1)
9D01C658  7C026304   INS V0, ZERO, 12, 1
9D01C65C  AC626140   SW V0, 24896(V1)
380:                 	#endif
381:                 
382:                 	#if (ENC100_INTERFACE_MODE >= 1) && defined(ENC100_BIT_BANG_PMP)	// Parallel bit-bang mode needs I/O pins to be configured.  PMP will control pins automatically.
383:                 		ENC100_SO_WR_B0SEL_EN_IO = 0;
384:                 		ENC100_SO_WR_B0SEL_EN_TRIS = 0;
385:                 		ENC100_SI_RD_RW_IO = 0;
386:                 		ENC100_SI_RD_RW_TRIS = 0;
387:                 		#if ENC100_INTERFACE_MODE >= 5	// If PSP address bus is multiplexed, then set Address Latch TRIS bit to output
388:                 			ENC100_SCK_AL_IO = 0;
389:                 			ENC100_SCK_AL_TRIS = 0;
390:                 		#endif
391:                 		#if (ENC100_INTERFACE_MODE == 3) || (ENC100_INTERFACE_MODE == 4) || (ENC100_INTERFACE_MODE == 9) || (ENC100_INTERFACE_MODE == 10)	// If PSP data width is 16-bits, set Write High/Byte 1 select as output
392:                 			ENC100_WRH_B1SEL_IO = 0;
393:                 			ENC100_WRH_B1SEL_TRIS = 0;
394:                 		#endif
395:                 
396:                 		ENC100_INIT_PSP_BIT_BANG();
397:                 	#elif (ENC100_INTERFACE_MODE == 0)	// Use SPI interface
398:                 		vCurrentBank = 0;			// Needed for SPI only
9D01C660  A3808100   SB ZERO, -32512(GP)
399:                 
400:                 	    // Set up SPI pins on PIC18s
401:                 		#if defined(__18CXX)
402:                 			ENC100_SCK_AL_TRIS = 0;
403:                 			ENC100_SI_RD_RW_TRIS = 0;
404:                 			ENC100_SO_WR_B0SEL_EN_TRIS = 1;
405:                 			ENC100_SPI_IF = 0;
406:                 		#endif
407:                 
408:                 		ConfigureSPIModule();
9D01C664  3C02BF80   LUI V0, -16512
9D01C668  AC405A00   SW ZERO, 23040(V0)
9D01C66C  3C02BF80   LUI V0, -16512
9D01C670  24030001   ADDIU V1, ZERO, 1
9D01C674  AC435A30   SW V1, 23088(V0)
9D01C678  3C02BF80   LUI V0, -16512
9D01C67C  34038320   ORI V1, ZERO, -31968
9D01C680  AC435A00   SW V1, 23040(V0)
409:                 	#endif
410:                 
411:                 	// Perform a reliable reset
412:                 	SendSystemReset();
9D01C684  0F407654   JAL 0x9D01D950
9D01C688  00000000   NOP
413:                 
414:                 	// Initialize RX tracking variables and other control state flags
415:                 	wNextPacketPointer = RXSTART;
9D01C68C  24024786   ADDIU V0, ZERO, 18310
9D01C690  A7828104   SH V0, -32508(GP)
416:                 	wCurrentPacketPointer = 0x0000;
9D01C694  A7808102   SH ZERO, -32510(GP)
417:                 	ENC100Flags.bWasDiscarded = 1;
9D01C698  93828108   LBU V0, -32504(GP)
9D01C69C  24030001   ADDIU V1, ZERO, 1
9D01C6A0  7C620004   INS V0, V1, 0, 1
9D01C6A4  A3828108   SB V0, -32504(GP)
418:                 	ENC100Flags.PoweredDown = 0;
9D01C6A8  93828108   LBU V0, -32504(GP)
9D01C6AC  7C020844   INS V0, ZERO, 1, 1
9D01C6B0  A3828108   SB V0, -32504(GP)
419:                 	ENC100Flags.CryptoEnabled = 0;
9D01C6B4  93828108   LBU V0, -32504(GP)
9D01C6B8  7C021084   INS V0, ZERO, 2, 1
9D01C6BC  A3828108   SB V0, -32504(GP)
420:                 
421:                 	// Set up TX/RX/UDA buffer addresses
422:                 	WriteReg(ETXST, TXSTART);
9D01C6C0  00002021   ADDU A0, ZERO, ZERO
9D01C6C4  00002821   ADDU A1, ZERO, ZERO
9D01C6C8  0F40792D   JAL 0x9D01E4B4
9D01C6CC  00000000   NOP
423:                 	WriteReg(ERXST, RXSTART);
9D01C6D0  24040004   ADDIU A0, ZERO, 4
9D01C6D4  24054786   ADDIU A1, ZERO, 18310
9D01C6D8  0F40792D   JAL 0x9D01E4B4
9D01C6DC  00000000   NOP
424:                 	WriteReg(ERXTAIL, ENC100_RAM_SIZE-2);
9D01C6E0  24040006   ADDIU A0, ZERO, 6
9D01C6E4  24055FFE   ADDIU A1, ZERO, 24574
9D01C6E8  0F40792D   JAL 0x9D01E4B4
9D01C6EC  00000000   NOP
425:                 	WriteReg(EUDAST, ENC100_RAM_SIZE);
9D01C6F0  24040016   ADDIU A0, ZERO, 22
9D01C6F4  24056000   ADDIU A1, ZERO, 24576
9D01C6F8  0F40792D   JAL 0x9D01E4B4
9D01C6FC  00000000   NOP
426:                 	WriteReg(EUDAND, ENC100_RAM_SIZE+1);
9D01C700  24040018   ADDIU A0, ZERO, 24
9D01C704  24056001   ADDIU A1, ZERO, 24577
9D01C708  0F40792D   JAL 0x9D01E4B4
9D01C70C  00000000   NOP
427:                 
428:                 	// Use ENCx24J600 preprogrammed MAC address, if AppConfig is not already set
429:                 	if(((AppConfig.MyMACAddr.v[0] == 0x00u) && (AppConfig.MyMACAddr.v[1] == 0x04u) && (AppConfig.MyMACAddr.v[2] == 0xA3u) && (AppConfig.MyMACAddr.v[3] == 0x00u) && (AppConfig.MyMACAddr.v[4] == 0x00u) && (AppConfig.MyMACAddr.v[5] == 0x00u)) ||
9D01C710  3C02A000   LUI V0, -24576
9D01C714  24420728   ADDIU V0, V0, 1832
9D01C718  9042002D   LBU V0, 45(V0)
9D01C71C  1440001C   BNE V0, ZERO, 0x9D01C790
9D01C720  00000000   NOP
9D01C724  3C02A000   LUI V0, -24576
9D01C728  24420728   ADDIU V0, V0, 1832
9D01C72C  9043002E   LBU V1, 46(V0)
9D01C730  24020004   ADDIU V0, ZERO, 4
9D01C734  14620016   BNE V1, V0, 0x9D01C790
9D01C738  00000000   NOP
9D01C73C  3C02A000   LUI V0, -24576
9D01C740  24420728   ADDIU V0, V0, 1832
9D01C744  9043002F   LBU V1, 47(V0)
9D01C748  240200A3   ADDIU V0, ZERO, 163
9D01C74C  14620010   BNE V1, V0, 0x9D01C790
9D01C750  00000000   NOP
9D01C754  3C02A000   LUI V0, -24576
9D01C758  24420728   ADDIU V0, V0, 1832
9D01C75C  90420030   LBU V0, 48(V0)
9D01C760  1440000B   BNE V0, ZERO, 0x9D01C790
9D01C764  00000000   NOP
9D01C768  3C02A000   LUI V0, -24576
9D01C76C  24420728   ADDIU V0, V0, 1832
9D01C770  90420031   LBU V0, 49(V0)
9D01C774  14400006   BNE V0, ZERO, 0x9D01C790
9D01C778  00000000   NOP
9D01C77C  3C02A000   LUI V0, -24576
9D01C780  24420728   ADDIU V0, V0, 1832
9D01C784  90420032   LBU V0, 50(V0)
9D01C788  1040001F   BEQ V0, ZERO, 0x9D01C808
9D01C78C  00000000   NOP
9D01C800  14400030   BNE V0, ZERO, 0x9D01C8C4
9D01C804  00000000   NOP
430:                 		((AppConfig.MyMACAddr.v[0] | AppConfig.MyMACAddr.v[1] | AppConfig.MyMACAddr.v[2] | AppConfig.MyMACAddr.v[3] | AppConfig.MyMACAddr.v[4] | AppConfig.MyMACAddr.v[5]) == 0x00u))
9D01C790  3C02A000   LUI V0, -24576
9D01C794  24420728   ADDIU V0, V0, 1832
9D01C798  9043002D   LBU V1, 45(V0)
9D01C79C  3C02A000   LUI V0, -24576
9D01C7A0  24420728   ADDIU V0, V0, 1832
9D01C7A4  9042002E   LBU V0, 46(V0)
9D01C7A8  00621025   OR V0, V1, V0
9D01C7AC  304300FF   ANDI V1, V0, 255
9D01C7B0  3C02A000   LUI V0, -24576
9D01C7B4  24420728   ADDIU V0, V0, 1832
9D01C7B8  9042002F   LBU V0, 47(V0)
9D01C7BC  00621025   OR V0, V1, V0
9D01C7C0  304300FF   ANDI V1, V0, 255
9D01C7C4  3C02A000   LUI V0, -24576
9D01C7C8  24420728   ADDIU V0, V0, 1832
9D01C7CC  90420030   LBU V0, 48(V0)
9D01C7D0  00621025   OR V0, V1, V0
9D01C7D4  304300FF   ANDI V1, V0, 255
9D01C7D8  3C02A000   LUI V0, -24576
9D01C7DC  24420728   ADDIU V0, V0, 1832
9D01C7E0  90420031   LBU V0, 49(V0)
9D01C7E4  00621025   OR V0, V1, V0
9D01C7E8  304300FF   ANDI V1, V0, 255
9D01C7EC  3C02A000   LUI V0, -24576
9D01C7F0  24420728   ADDIU V0, V0, 1832
9D01C7F4  90420032   LBU V0, 50(V0)
9D01C7F8  00621025   OR V0, V1, V0
9D01C7FC  304200FF   ANDI V0, V0, 255
431:                 	{
432:                 		w = ReadReg(MAADR1);
9D01C808  24040064   ADDIU A0, ZERO, 100
9D01C80C  0F4078D5   JAL 0x9D01E354
9D01C810  00000000   NOP
9D01C814  A7C20010   SH V0, 16(S8)
433:                 		AppConfig.MyMACAddr.v[0] = ((BYTE*)&w)[0];
9D01C818  27C20010   ADDIU V0, S8, 16
9D01C81C  90430000   LBU V1, 0(V0)
9D01C820  3C02A000   LUI V0, -24576
9D01C824  24420728   ADDIU V0, V0, 1832
9D01C828  A043002D   SB V1, 45(V0)
434:                 		AppConfig.MyMACAddr.v[1] = ((BYTE*)&w)[1];
9D01C82C  27C20010   ADDIU V0, S8, 16
9D01C830  24420001   ADDIU V0, V0, 1
9D01C834  90430000   LBU V1, 0(V0)
9D01C838  3C02A000   LUI V0, -24576
9D01C83C  24420728   ADDIU V0, V0, 1832
9D01C840  A043002E   SB V1, 46(V0)
435:                 		w = ReadReg(MAADR2);
9D01C844  24040062   ADDIU A0, ZERO, 98
9D01C848  0F4078D5   JAL 0x9D01E354
9D01C84C  00000000   NOP
9D01C850  A7C20010   SH V0, 16(S8)
436:                 		AppConfig.MyMACAddr.v[2] = ((BYTE*)&w)[0];
9D01C854  27C20010   ADDIU V0, S8, 16
9D01C858  90430000   LBU V1, 0(V0)
9D01C85C  3C02A000   LUI V0, -24576
9D01C860  24420728   ADDIU V0, V0, 1832
9D01C864  A043002F   SB V1, 47(V0)
437:                 		AppConfig.MyMACAddr.v[3] = ((BYTE*)&w)[1];
9D01C868  27C20010   ADDIU V0, S8, 16
9D01C86C  24420001   ADDIU V0, V0, 1
9D01C870  90430000   LBU V1, 0(V0)
9D01C874  3C02A000   LUI V0, -24576
9D01C878  24420728   ADDIU V0, V0, 1832
9D01C87C  A0430030   SB V1, 48(V0)
438:                 		w = ReadReg(MAADR3);
9D01C880  24040060   ADDIU A0, ZERO, 96
9D01C884  0F4078D5   JAL 0x9D01E354
9D01C888  00000000   NOP
9D01C88C  A7C20010   SH V0, 16(S8)
439:                 		AppConfig.MyMACAddr.v[4] = ((BYTE*)&w)[0];
9D01C890  27C20010   ADDIU V0, S8, 16
9D01C894  90430000   LBU V1, 0(V0)
9D01C898  3C02A000   LUI V0, -24576
9D01C89C  24420728   ADDIU V0, V0, 1832
9D01C8A0  A0430031   SB V1, 49(V0)
440:                 		AppConfig.MyMACAddr.v[5] = ((BYTE*)&w)[1];
9D01C8A4  27C20010   ADDIU V0, S8, 16
9D01C8A8  24420001   ADDIU V0, V0, 1
9D01C8AC  90430000   LBU V1, 0(V0)
9D01C8B0  3C02A000   LUI V0, -24576
9D01C8B4  24420728   ADDIU V0, V0, 1832
9D01C8B8  A0430032   SB V1, 50(V0)
9D01C8BC  0B407261   J 0x9D01C984
9D01C8C0  00000000   NOP
441:                 	}
442:                 	else
443:                 	{		
444:                 		((BYTE*)&w)[0] = AppConfig.MyMACAddr.v[0];
9D01C8C4  27C20010   ADDIU V0, S8, 16
9D01C8C8  3C03A000   LUI V1, -24576
9D01C8CC  24630728   ADDIU V1, V1, 1832
9D01C8D0  9063002D   LBU V1, 45(V1)
9D01C8D4  A0430000   SB V1, 0(V0)
445:                 		((BYTE*)&w)[1] = AppConfig.MyMACAddr.v[1];
9D01C8D8  27C20010   ADDIU V0, S8, 16
9D01C8DC  24420001   ADDIU V0, V0, 1
9D01C8E0  3C03A000   LUI V1, -24576
9D01C8E4  24630728   ADDIU V1, V1, 1832
9D01C8E8  9063002E   LBU V1, 46(V1)
9D01C8EC  A0430000   SB V1, 0(V0)
446:                 		WriteReg(MAADR1, w);
9D01C8F0  97C20010   LHU V0, 16(S8)
9D01C8F4  24040064   ADDIU A0, ZERO, 100
9D01C8F8  00402821   ADDU A1, V0, ZERO
9D01C8FC  0F40792D   JAL 0x9D01E4B4
9D01C900  00000000   NOP
447:                 		((BYTE*)&w)[0] = AppConfig.MyMACAddr.v[2];
9D01C904  27C20010   ADDIU V0, S8, 16
9D01C908  3C03A000   LUI V1, -24576
9D01C90C  24630728   ADDIU V1, V1, 1832
9D01C910  9063002F   LBU V1, 47(V1)
9D01C914  A0430000   SB V1, 0(V0)
448:                 		((BYTE*)&w)[1] = AppConfig.MyMACAddr.v[3];
9D01C918  27C20010   ADDIU V0, S8, 16
9D01C91C  24420001   ADDIU V0, V0, 1
9D01C920  3C03A000   LUI V1, -24576
9D01C924  24630728   ADDIU V1, V1, 1832
9D01C928  90630030   LBU V1, 48(V1)
9D01C92C  A0430000   SB V1, 0(V0)
449:                 		WriteReg(MAADR2, w);
9D01C930  97C20010   LHU V0, 16(S8)
9D01C934  24040062   ADDIU A0, ZERO, 98
9D01C938  00402821   ADDU A1, V0, ZERO
9D01C93C  0F40792D   JAL 0x9D01E4B4
9D01C940  00000000   NOP
450:                 		((BYTE*)&w)[0] = AppConfig.MyMACAddr.v[4];
9D01C944  27C20010   ADDIU V0, S8, 16
9D01C948  3C03A000   LUI V1, -24576
9D01C94C  24630728   ADDIU V1, V1, 1832
9D01C950  90630031   LBU V1, 49(V1)
9D01C954  A0430000   SB V1, 0(V0)
451:                 		((BYTE*)&w)[1] = AppConfig.MyMACAddr.v[5];
9D01C958  27C20010   ADDIU V0, S8, 16
9D01C95C  24420001   ADDIU V0, V0, 1
9D01C960  3C03A000   LUI V1, -24576
9D01C964  24630728   ADDIU V1, V1, 1832
9D01C968  90630032   LBU V1, 50(V1)
9D01C96C  A0430000   SB V1, 0(V0)
452:                 		WriteReg(MAADR3, w);
9D01C970  97C20010   LHU V0, 16(S8)
9D01C974  24040060   ADDIU A0, ZERO, 96
9D01C978  00402821   ADDU A1, V0, ZERO
9D01C97C  0F40792D   JAL 0x9D01E4B4
9D01C980  00000000   NOP
453:                 	}
454:                 
455:                 	// Set PHY Auto-negotiation to support 10BaseT Half duplex, 
456:                 	// 10BaseT Full duplex, 100BaseTX Half Duplex, 100BaseTX Full Duplex,
457:                 	// and symmetric PAUSE capability
458:                 	WritePHYReg(PHANA, PHANA_ADPAUS0 | PHANA_AD10FD | PHANA_AD10 | PHANA_AD100FD | PHANA_AD100 | PHANA_ADIEEE0);
9D01C984  24040004   ADDIU A0, ZERO, 4
9D01C988  240505E1   ADDIU A1, ZERO, 1505
9D01C98C  0F407A44   JAL WritePHYReg
9D01C990  00000000   NOP
459:                 	
460:                 	// Force operating mode, for debugging only.  If none of these statements 
461:                 	// are executed, auto-negotiation/parallel detection is used which will 
462:                 	// always select the proper mode.
463:                 	#if defined(ENC100_FORCE_10MBPS_HALF_DUPLEX)
464:                 		WritePHYReg(PHCON1, 0x0000);
465:                 	#elif defined(ENC100_FORCE_10MBPS_FULL_DUPLEX)
466:                 		WritePHYReg(PHCON1, PHCON1_PFULDPX);
467:                 	#elif defined(ENC100_FORCE_100MBPS_HALF_DUPLEX)
468:                 		WritePHYReg(PHCON1, PHCON1_SPD100);
469:                 	#elif defined(ENC100_FORCE_100MBPS_FULL_DUPLEX)
470:                 		WritePHYReg(PHCON1, PHCON1_SPD100 | PHCON1_PFULDPX);
471:                 	#endif
472:                 
473:                 	// Enable RX packet reception
474:                 	BFSReg(ECON1, ECON1_RXEN);
9D01C994  2404001E   ADDIU A0, ZERO, 30
9D01C998  24050001   ADDIU A1, ZERO, 1
9D01C99C  0F40798D   JAL 0x9D01E634
9D01C9A0  00000000   NOP
475:                 }//end MACInit
9D01C9A4  03C0E821   ADDU SP, S8, ZERO
9D01C9A8  8FBF001C   LW RA, 28(SP)
9D01C9AC  8FBE0018   LW S8, 24(SP)
9D01C9B0  27BD0020   ADDIU SP, SP, 32
9D01C9B4  03E00008   JR RA
9D01C9B8  00000000   NOP
476:                 
477:                 
478:                 /******************************************************************************
479:                  * Function:        BOOL MACIsLinked(void)
480:                  *
481:                  * PreCondition:    None
482:                  *
483:                  * Input:           None
484:                  *
485:                  * Output:          TRUE: An Ethernet link is established
486:                  *					FALSE: Ethernet link is not established
487:                  *
488:                  * Side Effects:    None
489:                  *
490:                  * Overview:        Returns the ESTAT<PHYLNK> bit.
491:                  *
492:                  * Note:            None
493:                  *****************************************************************************/
494:                 BOOL MACIsLinked(void)
495:                 {
9D01C9BC  27BDFFE8   ADDIU SP, SP, -24
9D01C9C0  AFBF0014   SW RA, 20(SP)
9D01C9C4  AFBE0010   SW S8, 16(SP)
9D01C9C8  03A0F021   ADDU S8, SP, ZERO
496:                 	return (ReadReg(ESTAT) & ESTAT_PHYLNK) != 0u;
9D01C9CC  2404001A   ADDIU A0, ZERO, 26
9D01C9D0  0F4078D5   JAL 0x9D01E354
9D01C9D4  00000000   NOP
9D01C9D8  30420100   ANDI V0, V0, 256
9D01C9DC  0002102B   SLTU V0, ZERO, V0
497:                 }
9D01C9E0  03C0E821   ADDU SP, S8, ZERO
9D01C9E4  8FBF0014   LW RA, 20(SP)
9D01C9E8  8FBE0010   LW S8, 16(SP)
9D01C9EC  27BD0018   ADDIU SP, SP, 24
9D01C9F0  03E00008   JR RA
9D01C9F4  00000000   NOP
498:                 
499:                 /******************************************************************************
500:                  * Function:        BOOL MACIsTxReady(void)
501:                  *
502:                  * PreCondition:    None
503:                  *
504:                  * Input:           None
505:                  *
506:                  * Output:          TRUE: If no Ethernet transmission is in progress
507:                  *					FALSE: If a previous transmission was started, and it has 
508:                  *						   not completed yet.  While FALSE, the data in the 
509:                  *						   transmit buffer and the TXST/TXLEN pointers must not
510:                  *						   be changed.
511:                  *
512:                  * Side Effects:    None
513:                  *
514:                  * Overview:        Returns the ECON1<TXRTS> bit
515:                  *
516:                  * Note:            None
517:                  *****************************************************************************/
518:                 BOOL MACIsTxReady(void)
519:                 {
9D01C9F8  27BDFFE8   ADDIU SP, SP, -24
9D01C9FC  AFBF0014   SW RA, 20(SP)
9D01CA00  AFBE0010   SW S8, 16(SP)
9D01CA04  03A0F021   ADDU S8, SP, ZERO
520:                 	return !(ReadReg(ECON1) & ECON1_TXRTS);
9D01CA08  2404001E   ADDIU A0, ZERO, 30
9D01CA0C  0F4078D5   JAL 0x9D01E354
9D01CA10  00000000   NOP
9D01CA14  30420002   ANDI V0, V0, 2
9D01CA18  2C420001   SLTIU V0, V0, 1
521:                 }
9D01CA1C  03C0E821   ADDU SP, S8, ZERO
9D01CA20  8FBF0014   LW RA, 20(SP)
9D01CA24  8FBE0010   LW S8, 16(SP)
9D01CA28  27BD0018   ADDIU SP, SP, 24
9D01CA2C  03E00008   JR RA
9D01CA30  00000000   NOP
522:                 
523:                 
524:                 /******************************************************************************
525:                  * Function:        void MACDiscardRx(void)
526:                  *
527:                  * PreCondition:    None
528:                  *
529:                  * Input:           None
530:                  *
531:                  * Output:          None
532:                  *
533:                  * Side Effects:    None
534:                  *
535:                  * Overview:        Marks the last received packet (obtained using 
536:                  *					MACGetHeader())as being processed and frees the buffer 
537:                  *					memory associated with it
538:                  *
539:                  * Note:            Is is safe to call this function multiple times between 
540:                  *					MACGetHeader() calls.  Extra packets won't be thrown away 
541:                  *					until MACGetHeader() makes it available.
542:                  *****************************************************************************/
543:                 void MACDiscardRx(void)
544:                 {
9D01CA34  27BDFFE0   ADDIU SP, SP, -32
9D01CA38  AFBF001C   SW RA, 28(SP)
9D01CA3C  AFBE0018   SW S8, 24(SP)
9D01CA40  03A0F021   ADDU S8, SP, ZERO
545:                 	WORD wNewRXTail;
546:                 
547:                 	// Make sure the current packet was not already discarded
548:                 	if(ENC100Flags.bWasDiscarded)
9D01CA44  93828108   LBU V0, -32504(GP)
9D01CA48  30420001   ANDI V0, V0, 1
9D01CA4C  304200FF   ANDI V0, V0, 255
9D01CA50  14400019   BNE V0, ZERO, 0x9D01CAB8
9D01CA54  00000000   NOP
549:                 		return;
9D01CAB8  00000000   NOP
550:                 	ENC100Flags.bWasDiscarded = 1;
9D01CA58  93828108   LBU V0, -32504(GP)
9D01CA5C  24030001   ADDIU V1, ZERO, 1
9D01CA60  7C620004   INS V0, V1, 0, 1
9D01CA64  A3828108   SB V0, -32504(GP)
551:                 	
552:                 	// Decrement the next packet pointer before writing it into 
553:                 	// the ERXRDPT registers. RX buffer wrapping must be taken into account if the 
554:                 	// NextPacketLocation is precisely RXSTART.
555:                 	wNewRXTail = wNextPacketPointer - 2;
9D01CA68  97828104   LHU V0, -32508(GP)
9D01CA6C  2442FFFE   ADDIU V0, V0, -2
9D01CA70  A7C20010   SH V0, 16(S8)
556:                 	if(wNextPacketPointer == RXSTART)
9D01CA74  97838104   LHU V1, -32508(GP)
9D01CA78  24024786   ADDIU V0, ZERO, 18310
9D01CA7C  14620003   BNE V1, V0, 0x9D01CA8C
9D01CA80  00000000   NOP
557:                 		wNewRXTail = ENC100_RAM_SIZE - 2;
9D01CA84  24025FFE   ADDIU V0, ZERO, 24574
9D01CA88  A7C20010   SH V0, 16(S8)
558:                 
559:                 	// Decrement the RX packet counter register, EPKTCNT
560:                 	BFSReg(ECON1, ECON1_PKTDEC);
9D01CA8C  2404001E   ADDIU A0, ZERO, 30
9D01CA90  24050100   ADDIU A1, ZERO, 256
9D01CA94  0F40798D   JAL 0x9D01E634
9D01CA98  00000000   NOP
561:                 
562:                 	// Move the receive read pointer to unwrite-protect the memory used by the 
563:                 	// last packet.  The writing order is important: set the low byte first, 
564:                 	// high byte last (handled automatically in WriteReg()).
565:                 	WriteReg(ERXTAIL, wNewRXTail);
9D01CA9C  97C20010   LHU V0, 16(S8)
9D01CAA0  24040006   ADDIU A0, ZERO, 6
9D01CAA4  00402821   ADDU A1, V0, ZERO
9D01CAA8  0F40792D   JAL 0x9D01E4B4
9D01CAAC  00000000   NOP
9D01CAB0  0B4072AF   J 0x9D01CABC
9D01CAB4  00000000   NOP
566:                 }
9D01CABC  03C0E821   ADDU SP, S8, ZERO
9D01CAC0  8FBF001C   LW RA, 28(SP)
9D01CAC4  8FBE0018   LW S8, 24(SP)
9D01CAC8  27BD0020   ADDIU SP, SP, 32
9D01CACC  03E00008   JR RA
9D01CAD0  00000000   NOP
567:                 
568:                 
569:                 /******************************************************************************
570:                  * Function:        WORD MACGetFreeRxSize(void)
571:                  *
572:                  * PreCondition:    None
573:                  *
574:                  * Input:           None
575:                  *
576:                  * Output:          A WORD estimate of how much RX buffer space is free at 
577:                  *					the present time.
578:                  *
579:                  * Side Effects:    None
580:                  *
581:                  * Overview:        None
582:                  *
583:                  * Note:            None
584:                  *****************************************************************************/
585:                 WORD MACGetFreeRxSize(void)
586:                 {
9D01CAD4  27BDFFE0   ADDIU SP, SP, -32
9D01CAD8  AFBF001C   SW RA, 28(SP)
9D01CADC  AFBE0018   SW S8, 24(SP)
9D01CAE0  03A0F021   ADDU S8, SP, ZERO
587:                 	WORD wHeadPtr;
588:                 
589:                 	wHeadPtr = ReadReg(ERXHEAD);
9D01CAE4  24040008   ADDIU A0, ZERO, 8
9D01CAE8  0F4078D5   JAL 0x9D01E354
9D01CAEC  00000000   NOP
9D01CAF0  A7C20010   SH V0, 16(S8)
590:                 	
591:                 	// Calculate the difference between the pointers, taking care to account 
592:                 	// for buffer wrapping conditions
593:                 	if(wHeadPtr > wCurrentPacketPointer)
9D01CAF4  97828102   LHU V0, -32510(GP)
9D01CAF8  97C30010   LHU V1, 16(S8)
9D01CAFC  0043102B   SLTU V0, V0, V1
9D01CB00  10400009   BEQ V0, ZERO, 0x9D01CB28
9D01CB04  00000000   NOP
594:                 		return (RXSTOP - RXSTART) - (wHeadPtr - wCurrentPacketPointer);
9D01CB08  97838102   LHU V1, -32510(GP)
9D01CB0C  97C20010   LHU V0, 16(S8)
9D01CB10  00621023   SUBU V0, V1, V0
9D01CB14  3042FFFF   ANDI V0, V0, -1
9D01CB18  24421879   ADDIU V0, V0, 6265
9D01CB1C  3042FFFF   ANDI V0, V0, -1
9D01CB20  0B4072D0   J 0x9D01CB40
9D01CB24  00000000   NOP
595:                 		
596:                 	return wCurrentPacketPointer - wHeadPtr - 2;
9D01CB28  97838102   LHU V1, -32510(GP)
9D01CB2C  97C20010   LHU V0, 16(S8)
9D01CB30  00621023   SUBU V0, V1, V0
9D01CB34  3042FFFF   ANDI V0, V0, -1
9D01CB38  2442FFFE   ADDIU V0, V0, -2
9D01CB3C  3042FFFF   ANDI V0, V0, -1
597:                 }
9D01CB40  03C0E821   ADDU SP, S8, ZERO
9D01CB44  8FBF001C   LW RA, 28(SP)
9D01CB48  8FBE0018   LW S8, 24(SP)
9D01CB4C  27BD0020   ADDIU SP, SP, 32
9D01CB50  03E00008   JR RA
9D01CB54  00000000   NOP
598:                 
599:                 
600:                 /******************************************************************************
601:                  * Function:        BOOL MACGetHeader(MAC_ADDR *remote, BYTE* type)
602:                  *
603:                  * PreCondition:    None
604:                  *
605:                  * Input:           *remote: Location to store the Source MAC address of the 
606:                  *							 received frame.
607:                  *					*type: Location of a BYTE to store the constant 
608:                  *						   MAC_UNKNOWN, ETHER_IP, or ETHER_ARP, representing 
609:                  *						   the contents of the Ethernet type field.
610:                  *
611:                  * Output:          TRUE: If a packet was waiting in the RX buffer.  The 
612:                  *						  remote, and type values are updated.
613:                  *					FALSE: If a packet was not pending.  remote and type are 
614:                  *						   not changed.
615:                  *
616:                  * Side Effects:    Last packet is discarded if MACDiscardRx() hasn't already
617:                  *					been called.
618:                  *
619:                  * Overview:        None
620:                  *
621:                  * Note:            None
622:                  *****************************************************************************/
623:                 BOOL MACGetHeader(MAC_ADDR *remote, BYTE* type)
624:                 {
9D01CB58  27BDFFC0   ADDIU SP, SP, -64
9D01CB5C  AFBF003C   SW RA, 60(SP)
9D01CB60  AFBE0038   SW S8, 56(SP)
9D01CB64  AFB20034   SW S2, 52(SP)
9D01CB68  AFB10030   SW S1, 48(SP)
9D01CB6C  AFB0002C   SW S0, 44(SP)
9D01CB70  03A0F021   ADDU S8, SP, ZERO
9D01CB74  AFC40040   SW A0, 64(S8)
9D01CB78  AFC50044   SW A1, 68(S8)
625:                 	ENC100_PREAMBLE header;
626:                 
627:                 	// Test if at least one packet has been received and is waiting
628:                 	if(!(ReadReg(EIR) & EIR_PKTIF))
9D01CB7C  0F4078D5   JAL 0x9D01E354
9D01CB80  2404001C   ADDIU A0, ZERO, 28
9D01CB84  30420040   ANDI V0, V0, 64
9D01CB88  1440003D   BNE V0, ZERO, 0x9D01CC80
9D01CB8C  00000000   NOP
629:                 	{
630:                 		// No packets are waiting.  See if we are unlinked and need to process 
631:                 		// auto crossover timers.
632:                 		#if defined(ENC100_MDIX_TRIS)
633:                 		{
634:                 			static WORD wMDIXTimer = 0;
635:                 			
636:                 			// See if it is time to swap MDI mode
637:                 			if((WORD)(wMDIXTimer - (WORD)TickGetDiv256()) > (WORD)(2u*TICK_SECOND/256u))
9D01CB90  0F40CDE4   JAL TickGetDiv256
9D01CB94  9792810A   LHU S2, -32502(GP)
9D01CB98  3042FFFF   ANDI V0, V0, -1
9D01CB9C  02421023   SUBU V0, S2, V0
9D01CBA0  3042FFFF   ANDI V0, V0, -1
9D01CBA4  2C4204C5   SLTIU V0, V0, 1221
9D01CBA8  14400033   BNE V0, ZERO, 0x9D01CC78
9D01CBAC  00000000   NOP
638:                 			{
639:                 				// If we are linked, then we should simply reset the timer to a 
640:                 				// max of 1.3 seconds and do nothing
641:                 				if(MACIsLinked())
9D01CBB0  0F40726F   JAL MACIsLinked
9D01CBB4  00000000   NOP
9D01CBB8  10400008   BEQ V0, ZERO, 0x9D01CBDC
9D01CBBC  00000000   NOP
642:                 				{
643:                 					wMDIXTimer = (WORD)TickGetDiv256() + (WORD)(13u*TICK_SECOND/256u/10u);
9D01CBC0  0F40CDE4   JAL TickGetDiv256
9D01CBC4  00000000   NOP
9D01CBC8  3042FFFF   ANDI V0, V0, -1
9D01CBCC  24420319   ADDIU V0, V0, 793
9D01CBD0  3042FFFF   ANDI V0, V0, -1
9D01CBD4  0B40731E   J 0x9D01CC78
9D01CBD8  A782810A   SH V0, -32502(GP)
644:                 				}
645:                 				else
646:                 				{
647:                 					// We are unlinked and the MDI-X timer expired, lets swap MDI mode
648:                 					ENC100_MDIX_IO ^= 1;
9D01CBDC  3C02BF88   LUI V0, -16504
9D01CBE0  8C426060   LW V0, 24672(V0)
9D01CBE4  7C4200C0   EXT V0, V0, 3, 1
9D01CBE8  304200FF   ANDI V0, V0, 255
9D01CBEC  38420001   XORI V0, V0, 1
9D01CBF0  304200FF   ANDI V0, V0, 255
9D01CBF4  30420001   ANDI V0, V0, 1
9D01CBF8  304400FF   ANDI A0, V0, 255
9D01CBFC  3C03BF88   LUI V1, -16504
9D01CC00  8C626060   LW V0, 24672(V1)
9D01CC04  7C8218C4   INS V0, A0, 3, 1
9D01CC08  0F40CDE4   JAL TickGetDiv256
649:                 					
650:                 					// Set up new timer to expire sometime randomly between 1.0
651:                 					// seconds and 1.55 seconds in the future.  This needs to 
652:                 					// have randomness so that if you plug two similar devices 
653:                 					// into each other, you don't have a lock-step switching 
654:                 					// problem in which both devices swap MDI mode 
655:                 					// simultaneously and never link up.
656:                 					wMDIXTimer = (WORD)TickGetDiv256() + (WORD)(TICK_SECOND/256u) + (WORD)(55ul*TICK_SECOND/256ul/100ul*(DWORD)LFSRRand()/65535ul);
9D01CC0C  AC626060   SW V0, 24672(V1)
9D01CC10  0F40960D   JAL LFSRRand
9D01CC14  3052FFFF   ANDI S2, V0, -1
9D01CC18  00408021   ADDU S0, V0, ZERO
9D01CC1C  00008821   ADDU S1, ZERO, ZERO
9D01CC20  2402014F   ADDIU V0, ZERO, 335
9D01CC24  72222002   MUL A0, S1, V0
9D01CC28  00001021   ADDU V0, ZERO, ZERO
9D01CC2C  72021002   MUL V0, S0, V0
9D01CC30  00822021   ADDU A0, A0, V0
9D01CC34  2402014F   ADDIU V0, ZERO, 335
9D01CC38  02020019   MULTU 0, S0, V0
9D01CC3C  00001012   MFLO V0, 0
9D01CC40  00001810   MFHI V1, 0
9D01CC44  00832021   ADDU A0, A0, V1
9D01CC48  00801821   ADDU V1, A0, ZERO
9D01CC4C  00402021   ADDU A0, V0, ZERO
9D01CC50  00602821   ADDU A1, V1, ZERO
9D01CC54  3406FFFF   ORI A2, ZERO, -1
9D01CC58  0F40C887   JAL __udivdi3
9D01CC5C  00003821   ADDU A3, ZERO, ZERO
9D01CC60  3042FFFF   ANDI V0, V0, -1
9D01CC64  02421021   ADDU V0, S2, V0
9D01CC68  3042FFFF   ANDI V0, V0, -1
9D01CC6C  24420262   ADDIU V0, V0, 610
9D01CC70  3042FFFF   ANDI V0, V0, -1
9D01CC74  A782810A   SH V0, -32502(GP)
657:                 
658:                 					//// Restart auto-negotiation
659:                 					//WritePHYReg(PHCON1, PHCON1_ANEN | PHCON1_RENEG);
660:                 				}
661:                 			}
662:                 		}
663:                 		#endif
664:                 
665:                 		return FALSE;
9D01CC78  0B407378   J 0x9D01CDE0
9D01CC7C  00001021   ADDU V0, ZERO, ZERO
666:                 	}
667:                 
668:                 	// Discard the last packet, if the user application hasn't done so already
669:                 	if(!ENC100Flags.bWasDiscarded)
9D01CC80  93828108   LBU V0, -32504(GP)
9D01CC84  30420001   ANDI V0, V0, 1
9D01CC88  304200FF   ANDI V0, V0, 255
9D01CC8C  1440000A   BNE V0, ZERO, 0x9D01CCB8
9D01CC90  00000000   NOP
670:                 	{
671:                 		MACDiscardRx();
9D01CC94  0F40728D   JAL MACDiscardRx
9D01CC98  00000000   NOP
672:                 
673:                 		// Test again if at least one packet has been received and is waiting
674:                 		if(!(ReadReg(EIR) & EIR_PKTIF))
9D01CC9C  0F4078D5   JAL 0x9D01E354
9D01CCA0  2404001C   ADDIU A0, ZERO, 28
9D01CCA4  30420040   ANDI V0, V0, 64
9D01CCA8  14400003   BNE V0, ZERO, 0x9D01CCB8
9D01CCAC  00000000   NOP
675:                 			return FALSE;
9D01CCB0  0B407378   J 0x9D01CDE0
9D01CCB4  00001021   ADDU V0, ZERO, ZERO
676:                 	}
677:                 
678:                 	// Set the RX Read Pointer to the beginning of the next unprocessed packet
679:                 	wCurrentPacketPointer = wNextPacketPointer;
9D01CCB8  97828104   LHU V0, -32508(GP)
9D01CCBC  A7828102   SH V0, -32510(GP)
680:                 	WriteReg(ERXRDPT, wCurrentPacketPointer);
9D01CCC0  97828102   LHU V0, -32510(GP)
9D01CCC4  2404008A   ADDIU A0, ZERO, 138
9D01CCC8  0F40792D   JAL 0x9D01E4B4
9D01CCCC  00402821   ADDU A1, V0, ZERO
681:                 
682:                 	// Obtain the MAC header from the Ethernet buffer
683:                 	ReadMemoryWindow(RX_WINDOW, (BYTE*)&header, sizeof(header));
9D01CCD0  27C20010   ADDIU V0, S8, 16
9D01CCD4  24040004   ADDIU A0, ZERO, 4
9D01CCD8  00402821   ADDU A1, V0, ZERO
9D01CCDC  0F4076D8   JAL 0x9D01DB60
9D01CCE0  24060016   ADDIU A2, ZERO, 22
684:                 
685:                 	// The EtherType field, like most items transmitted on the Ethernet medium
686:                 	// are in big endian.
687:                 	header.Type.Val = swaps(header.Type.Val);
9D01CCE4  97C20024   LHU V0, 36(S8)
9D01CCE8  0F409A16   JAL swaps
9D01CCEC  00402021   ADDU A0, V0, ZERO
9D01CCF0  A7C20024   SH V0, 36(S8)
688:                 
689:                 	// Validate the data returned from the ENC624J600 Family device.  Random 
690:                 	// data corruption, such as if a single SPI/PSP bit error occurs while 
691:                 	// communicating or a momentary power glitch could cause this to occur 
692:                 	// in rare circumstances.  Also, certain hardware bugs such as violations 
693:                 	// of the absolute maximum electrical specs can cause this.  For example,
694:                 	// if an MCU with a high slew rate were to access the interface, parasitic 
695:                 	// inductance in the traces could cause excessive voltage undershoot.  
696:                 	// If the voltage goes too far below ground, the ENCx24J600's internal
697:                 	// ESD structure may activate and disrupt the communication.  To prevent 
698:                 	// this, ensure that you have a clean board layout and consider adding 
699:                 	// resistors in series with the MCU output pins to limit the slew rate 
700:                 	// of signals going to the ENCx24J600. 100 Ohm resistors is a good value 
701:                 	// to start testing with.
702:                 	if(header.NextPacketPointer > RXSTOP || ((BYTE_VAL*)(&header.NextPacketPointer))->bits.b0 ||
9D01CCF4  97C20010   LHU V0, 16(S8)
9D01CCF8  2C426000   SLTIU V0, V0, 24576
9D01CCFC  10400018   BEQ V0, ZERO, 0x9D01CD60
9D01CD00  00000000   NOP
9D01CD04  27C20010   ADDIU V0, S8, 16
9D01CD08  90420000   LBU V0, 0(V0)
9D01CD0C  30420001   ANDI V0, V0, 1
9D01CD10  304200FF   ANDI V0, V0, 255
9D01CD14  14400012   BNE V0, ZERO, 0x9D01CD60
9D01CD18  00000000   NOP
9D01CD20  1440000F   BNE V0, ZERO, 0x9D01CD60
9D01CD24  00000000   NOP
703:                 	   header.StatusVector.bits.Zero || header.StatusVector.bits.ZeroH || 
9D01CD1C  93C20017   LBU V0, 23(S8)
9D01CD28  97C20016   LHU V0, 22(S8)
9D01CD2C  30420080   ANDI V0, V0, 128
9D01CD30  3042FFFF   ANDI V0, V0, -1
9D01CD34  1440000A   BNE V0, ZERO, 0x9D01CD60
9D01CD38  00000000   NOP
9D01CD3C  97C20014   LHU V0, 20(S8)
9D01CD40  30420010   ANDI V0, V0, 16
9D01CD44  3042FFFF   ANDI V0, V0, -1
9D01CD48  14400005   BNE V0, ZERO, 0x9D01CD60
9D01CD4C  00000000   NOP
704:                 	   header.StatusVector.bits.CRCError ||
9D01CD54  2C4205F3   SLTIU V0, V0, 1523
9D01CD58  14400004   BNE V0, ZERO, 0x9D01CD6C
9D01CD5C  00000000   NOP
705:                 	   header.StatusVector.bits.ByteCount > 1522u)
9D01CD50  97C20012   LHU V0, 18(S8)
706:                 	{
707:                 		//ENC100DumpState();
708:                 		Nop();
9D01CD60  00000040   SSNOP
709:                 		
710:                 		Reset();
9D01CD64  0F40D720   JAL SoftReset
9D01CD68  00000000   NOP
711:                 	}
712:                 
713:                 	// Save the location where the hardware will write the next packet to
714:                 	wNextPacketPointer = header.NextPacketPointer;
9D01CD6C  97C20010   LHU V0, 16(S8)
9D01CD70  A7828104   SH V0, -32508(GP)
715:                 
716:                 	// Return the Ethernet frame's Source MAC address field to the caller
717:                 	// This parameter is useful for replying to requests without requiring an 
718:                 	// ARP cycle.
719:                     memcpy((void*)remote->v, (void*)header.SourceMACAddr.v, sizeof(*remote));
9D01CD74  8FC30040   LW V1, 64(S8)
9D01CD78  27C2001E   ADDIU V0, S8, 30
9D01CD7C  00602021   ADDU A0, V1, ZERO
9D01CD80  00402821   ADDU A1, V0, ZERO
9D01CD84  0F40D298   JAL 0x9D034A60
9D01CD88  24060006   ADDIU A2, ZERO, 6
720:                 
721:                 	// Return a simplified version of the EtherType field to the caller
722:                     *type = MAC_UNKNOWN;
9D01CD8C  8FC20044   LW V0, 68(S8)
9D01CD90  2403FFFF   ADDIU V1, ZERO, -1
9D01CD94  A0430000   SB V1, 0(V0)
723:                     if( (header.Type.v[1] == 0x08u) && 
9D01CD98  93C30025   LBU V1, 37(S8)
9D01CD9C  24020008   ADDIU V0, ZERO, 8
9D01CDA0  1462000B   BNE V1, V0, 0x9D01CDD0
9D01CDA4  00000000   NOP
9D01CDAC  10400005   BEQ V0, ZERO, 0x9D01CDC4
9D01CDB0  00000000   NOP
724:                     	((header.Type.v[0] == (BYTE)ETHER_IP) || (header.Type.v[0] == (BYTE)ETHER_ARP)) )
9D01CDA8  93C20024   LBU V0, 36(S8)
9D01CDB4  93C30024   LBU V1, 36(S8)
9D01CDB8  24020006   ADDIU V0, ZERO, 6
9D01CDBC  14620004   BNE V1, V0, 0x9D01CDD0
9D01CDC0  00000000   NOP
725:                     {
726:                     	*type = header.Type.v[0];
9D01CDC4  93C30024   LBU V1, 36(S8)
9D01CDC8  8FC20044   LW V0, 68(S8)
9D01CDCC  A0430000   SB V1, 0(V0)
727:                     }
728:                 
729:                     // Mark this packet as discardable
730:                     ENC100Flags.bWasDiscarded = 0;
9D01CDD0  93828108   LBU V0, -32504(GP)
9D01CDD4  7C020004   INS V0, ZERO, 0, 1
9D01CDD8  A3828108   SB V0, -32504(GP)
731:                 	return TRUE;
9D01CDDC  24020001   ADDIU V0, ZERO, 1
732:                 }
9D01CDE0  03C0E821   ADDU SP, S8, ZERO
9D01CDE4  8FBF003C   LW RA, 60(SP)
9D01CDE8  8FBE0038   LW S8, 56(SP)
9D01CDEC  8FB20034   LW S2, 52(SP)
9D01CDF0  8FB10030   LW S1, 48(SP)
9D01CDF4  8FB0002C   LW S0, 44(SP)
9D01CDF8  03E00008   JR RA
9D01CDFC  27BD0040   ADDIU SP, SP, 64
733:                 
734:                 
735:                 /******************************************************************************
736:                  * Function:        void MACPutHeader(MAC_ADDR *remote, BYTE type, WORD dataLen)
737:                  *
738:                  * PreCondition:    MACIsTxReady() must return TRUE.
739:                  *
740:                  * Input:           *remote: Pointer to memory which contains the destination
741:                  * 							 MAC address (6 bytes)
742:                  *					type: The constant ETHER_ARP or ETHER_IP, defining which 
743:                  *						  value to write into the Ethernet header's type field.
744:                  *					dataLen: Length of the Ethernet data payload
745:                  *
746:                  * Output:          None
747:                  *
748:                  * Side Effects:    None
749:                  *
750:                  * Overview:        None
751:                  *
752:                  * Note:            Because of the dataLen parameter, it is probably 
753:                  *					advantagous to call this function immediately before 
754:                  *					transmitting a packet rather than initially when the 
755:                  *					packet is first created.  The order in which the packet
756:                  *					is constructed (header first or data first) is not 
757:                  *					important.
758:                  *****************************************************************************/
759:                 void MACPutHeader(MAC_ADDR *remote, BYTE type, WORD dataLen)
760:                 {
9D01CE00  27BDFFE0   ADDIU SP, SP, -32
9D01CE04  AFBF001C   SW RA, 28(SP)
9D01CE08  AFBE0018   SW S8, 24(SP)
9D01CE0C  03A0F021   ADDU S8, SP, ZERO
9D01CE10  AFC40020   SW A0, 32(S8)
9D01CE14  00A01821   ADDU V1, A1, ZERO
9D01CE18  00C01021   ADDU V0, A2, ZERO
9D01CE1C  A3C30024   SB V1, 36(S8)
9D01CE20  A7C20028   SH V0, 40(S8)
761:                 	WORD wEthernetType;
762:                 
763:                 	wEthernetType = 0x08 | ((type == MAC_IP) ? (ETHER_IP<<8) : (ETHER_ARP<<8));
9D01CE24  93C20024   LBU V0, 36(S8)
9D01CE28  14400004   BNE V0, ZERO, 0x9D01CE3C
9D01CE2C  00000000   NOP
9D01CE30  24020008   ADDIU V0, ZERO, 8
9D01CE34  0B407390   J 0x9D01CE40
9D01CE38  00000000   NOP
9D01CE3C  24020608   ADDIU V0, ZERO, 1544
9D01CE40  A7C20010   SH V0, 16(S8)
764:                 	
765:                 	// Set the Window Write Pointer to the beginning of the transmit buffer
766:                 	WriteReg(EGPWRPT, TXSTART);
9D01CE44  24040088   ADDIU A0, ZERO, 136
9D01CE48  00002821   ADDU A1, ZERO, ZERO
9D01CE4C  0F40792D   JAL 0x9D01E4B4
9D01CE50  00000000   NOP
767:                 	WriteReg(ETXLEN, dataLen + sizeof(ETHER_HEADER));
9D01CE54  97C20028   LHU V0, 40(S8)
9D01CE58  2442000E   ADDIU V0, V0, 14
9D01CE5C  3042FFFF   ANDI V0, V0, -1
9D01CE60  24040002   ADDIU A0, ZERO, 2
9D01CE64  00402821   ADDU A1, V0, ZERO
9D01CE68  0F40792D   JAL 0x9D01E4B4
9D01CE6C  00000000   NOP
768:                 
769:                 	// Write the Ethernet destination MAC address, our source MAC address, 
770:                 	// and the Ethernet Type field.
771:                     WriteMemoryWindow(GP_WINDOW, (BYTE*)remote, sizeof(*remote));
9D01CE70  8FC20020   LW V0, 32(S8)
9D01CE74  24040002   ADDIU A0, ZERO, 2
9D01CE78  00402821   ADDU A1, V0, ZERO
9D01CE7C  24060006   ADDIU A2, ZERO, 6
9D01CE80  0F4076A3   JAL 0x9D01DA8C
9D01CE84  00000000   NOP
772:                     WriteMemoryWindow(GP_WINDOW, (BYTE*)&AppConfig.MyMACAddr, 6);
9D01CE88  24040002   ADDIU A0, ZERO, 2
9D01CE8C  3C02A000   LUI V0, -24576
9D01CE90  24450755   ADDIU A1, V0, 1877
9D01CE94  24060006   ADDIU A2, ZERO, 6
9D01CE98  0F4076A3   JAL 0x9D01DA8C
9D01CE9C  00000000   NOP
773:                     WriteMemoryWindow(GP_WINDOW, (BYTE*)&wEthernetType, 2);
9D01CEA0  27C20010   ADDIU V0, S8, 16
9D01CEA4  24040002   ADDIU A0, ZERO, 2
9D01CEA8  00402821   ADDU A1, V0, ZERO
9D01CEAC  24060002   ADDIU A2, ZERO, 2
9D01CEB0  0F4076A3   JAL 0x9D01DA8C
9D01CEB4  00000000   NOP
774:                 }
9D01CEB8  03C0E821   ADDU SP, S8, ZERO
9D01CEBC  8FBF001C   LW RA, 28(SP)
9D01CEC0  8FBE0018   LW S8, 24(SP)
9D01CEC4  27BD0020   ADDIU SP, SP, 32
9D01CEC8  03E00008   JR RA
9D01CECC  00000000   NOP
775:                 
776:                 
777:                 
778:                 /******************************************************************************
779:                  * Function:        void MACFlush(void)
780:                  *
781:                  * PreCondition:    A packet has been created by calling MACPut() and 
782:                  *					MACPutHeader().
783:                  *
784:                  * Input:           None
785:                  *
786:                  * Output:          None
787:                  *
788:                  * Side Effects:    None
789:                  *
790:                  * Overview:        MACFlush causes the current TX packet to be sent out on 
791:                  *					the Ethernet medium.  The hardware MAC will take control
792:                  *					and handle CRC generation, collision retransmission and 
793:                  *					other details.
794:                  *
795:                  * Note:			After transmission completes (MACIsTxReady() returns TRUE), 
796:                  *					the packet can be modified and transmitted again by calling 
797:                  *					MACFlush() again.  Until MACPutHeader() or MACPut() is 
798:                  *					called (in the TX data area), the data in the TX buffer 
799:                  *					will not be corrupted.
800:                  *****************************************************************************/
801:                 void MACFlush(void)
802:                 {
9D01CED0  27BDFFE0   ADDIU SP, SP, -32
9D01CED4  AFBF001C   SW RA, 28(SP)
9D01CED8  AFBE0018   SW S8, 24(SP)
9D01CEDC  03A0F021   ADDU S8, SP, ZERO
803:                 	WORD w;
804:                 
805:                 	// Check to see if the duplex status has changed.  This can 
806:                 	// change if the user unplugs the cable and plugs it into a 
807:                 	// different node.  Auto-negotiation will automatically set 
808:                 	// the duplex in the PHY, but we must also update the MAC 
809:                 	// inter-packet gap timing and duplex state to match.
810:                 	if(ReadReg(EIR) & EIR_LINKIF)
9D01CEE0  2404001C   ADDIU A0, ZERO, 28
9D01CEE4  0F4078D5   JAL 0x9D01E354
9D01CEE8  00000000   NOP
9D01CEEC  30420800   ANDI V0, V0, 2048
9D01CEF0  10400025   BEQ V0, ZERO, 0x9D01CF88
9D01CEF4  00000000   NOP
811:                 	{
812:                 		BFCReg(EIR, EIR_LINKIF);
9D01CEF8  2404001C   ADDIU A0, ZERO, 28
9D01CEFC  24050800   ADDIU A1, ZERO, 2048
9D01CF00  0F4079D4   JAL 0x9D01E750
9D01CF04  00000000   NOP
813:                 
814:                 		// Update MAC duplex settings to match PHY duplex setting
815:                 		w = ReadReg(MACON2);
9D01CF08  24040042   ADDIU A0, ZERO, 66
9D01CF0C  0F4078D5   JAL 0x9D01E354
9D01CF10  00000000   NOP
9D01CF14  A7C20010   SH V0, 16(S8)
816:                 		if(ReadReg(ESTAT) & ESTAT_PHYDPX)
9D01CF18  2404001A   ADDIU A0, ZERO, 26
9D01CF1C  0F4078D5   JAL 0x9D01E354
9D01CF20  00000000   NOP
9D01CF24  30420400   ANDI V0, V0, 1024
9D01CF28  1040000A   BEQ V0, ZERO, 0x9D01CF54
9D01CF2C  00000000   NOP
817:                 		{
818:                 			// Switching to full duplex
819:                 			WriteReg(MABBIPG, 0x15);
9D01CF30  24040044   ADDIU A0, ZERO, 68
9D01CF34  24050015   ADDIU A1, ZERO, 21
9D01CF38  0F40792D   JAL 0x9D01E4B4
9D01CF3C  00000000   NOP
820:                 			w |= MACON2_FULDPX;
9D01CF40  97C20010   LHU V0, 16(S8)
9D01CF44  34420001   ORI V0, V0, 1
9D01CF48  A7C20010   SH V0, 16(S8)
9D01CF4C  0B4073DD   J 0x9D01CF74
9D01CF50  00000000   NOP
821:                 		}
822:                 		else
823:                 		{
824:                 			// Switching to half duplex
825:                 			WriteReg(MABBIPG, 0x12);
9D01CF54  24040044   ADDIU A0, ZERO, 68
9D01CF58  24050012   ADDIU A1, ZERO, 18
9D01CF5C  0F40792D   JAL 0x9D01E4B4
9D01CF60  00000000   NOP
826:                 			w &= ~MACON2_FULDPX;
9D01CF64  97C30010   LHU V1, 16(S8)
9D01CF68  2402FFFE   ADDIU V0, ZERO, -2
9D01CF6C  00621024   AND V0, V1, V0
9D01CF70  A7C20010   SH V0, 16(S8)
827:                 		}
828:                 		WriteReg(MACON2, w);
9D01CF74  97C20010   LHU V0, 16(S8)
9D01CF78  24040042   ADDIU A0, ZERO, 66
9D01CF7C  00402821   ADDU A1, V0, ZERO
9D01CF80  0F40792D   JAL 0x9D01E4B4
9D01CF84  00000000   NOP
829:                 	}
830:                 
831:                 
832:                 	// Start the transmission, but only if we are linked.  Supressing 
833:                 	// transmissing when unlinked is necessary to avoid stalling the TX engine 
834:                 	// if we are in PHY energy detect power down mode and no link is present.  
835:                 	// A stalled TX engine won't do any harm in itself, but will cause the 
836:                 	// MACIsTXReady() function to continuously return FALSE, which will 
837:                 	// ultimately stall the Microchip TCP/IP stack since there is blocking code 
838:                 	// elsewhere in other files that expect the TX engine to always self-free 
839:                 	// itself very quickly.
840:                 	if(ReadReg(ESTAT) & ESTAT_PHYLNK)
9D01CF88  2404001A   ADDIU A0, ZERO, 26
9D01CF8C  0F4078D5   JAL 0x9D01E354
9D01CF90  00000000   NOP
9D01CF94  30420100   ANDI V0, V0, 256
9D01CF98  10400005   BEQ V0, ZERO, 0x9D01CFB0
9D01CF9C  00000000   NOP
841:                 		BFSReg(ECON1, ECON1_TXRTS);
9D01CFA0  2404001E   ADDIU A0, ZERO, 30
9D01CFA4  24050002   ADDIU A1, ZERO, 2
9D01CFA8  0F40798D   JAL 0x9D01E634
9D01CFAC  00000000   NOP
842:                 }
9D01CFB0  03C0E821   ADDU SP, S8, ZERO
9D01CFB4  8FBF001C   LW RA, 28(SP)
9D01CFB8  8FBE0018   LW S8, 24(SP)
9D01CFBC  27BD0020   ADDIU SP, SP, 32
9D01CFC0  03E00008   JR RA
9D01CFC4  00000000   NOP
843:                 
844:                 
845:                 /******************************************************************************
846:                  * Function:        void MACSetReadPtrInRx(WORD offset)
847:                  *
848:                  * PreCondition:    A packet has been obtained by calling MACGetHeader() and 
849:                  *					getting a TRUE result.
850:                  *
851:                  * Input:           offset: WORD specifying how many bytes beyond the Ethernet 
852:                  *							header's type field to relocate the SPI read 
853:                  *							pointer.
854:                  *
855:                  * Output:          None
856:                  *
857:                  * Side Effects:    None
858:                  *
859:                  * Overview:        SPI read pointer are updated.  All calls to 
860:                  *					MACGet() and MACGetArray() will use these new values.
861:                  *
862:                  * Note:			RXSTOP must be statically defined as being > RXSTART for 
863:                  *					this function to work correctly.  In other words, do not 
864:                  *					define an RX buffer which spans the 0x1FFF->0x0000 memory
865:                  *					boundary.
866:                  *****************************************************************************/
867:                 void MACSetReadPtrInRx(WORD offset)
868:                 {
9D01CFC8  27BDFFE0   ADDIU SP, SP, -32
9D01CFCC  AFBF001C   SW RA, 28(SP)
9D01CFD0  AFBE0018   SW S8, 24(SP)
9D01CFD4  03A0F021   ADDU S8, SP, ZERO
9D01CFD8  00801021   ADDU V0, A0, ZERO
9D01CFDC  A7C20020   SH V0, 32(S8)
869:                 	WORD wReadPtr;
870:                 
871:                 	// Determine the address of the beginning of the entire packet
872:                 	// and adjust the address to the desired location
873:                 	wReadPtr = wCurrentPacketPointer + sizeof(ENC100_PREAMBLE) + offset;
9D01CFE0  97838102   LHU V1, -32510(GP)
9D01CFE4  97C20020   LHU V0, 32(S8)
9D01CFE8  00621021   ADDU V0, V1, V0
9D01CFEC  3042FFFF   ANDI V0, V0, -1
9D01CFF0  24420016   ADDIU V0, V0, 22
9D01CFF4  A7C20010   SH V0, 16(S8)
874:                 	
875:                 	// Since the receive buffer is circular, adjust if a wraparound is needed
876:                 	if(wReadPtr > RXSTOP)
9D01CFF8  97C20010   LHU V0, 16(S8)
9D01CFFC  2C426000   SLTIU V0, V0, 24576
9D01D000  14400004   BNE V0, ZERO, 0x9D01D014
9D01D004  00000000   NOP
877:                 		wReadPtr -= RXSIZE;
9D01D008  97C20010   LHU V0, 16(S8)
9D01D00C  2442E786   ADDIU V0, V0, -6266
9D01D010  A7C20010   SH V0, 16(S8)
878:                 	
879:                 	// Set the RX Window Read pointer to the new calculated value
880:                 	WriteReg(ERXRDPT, wReadPtr);
9D01D014  97C20010   LHU V0, 16(S8)
9D01D018  2404008A   ADDIU A0, ZERO, 138
9D01D01C  00402821   ADDU A1, V0, ZERO
9D01D020  0F40792D   JAL 0x9D01E4B4
9D01D024  00000000   NOP
881:                 }
9D01D028  03C0E821   ADDU SP, S8, ZERO
9D01D02C  8FBF001C   LW RA, 28(SP)
9D01D030  8FBE0018   LW S8, 24(SP)
9D01D034  27BD0020   ADDIU SP, SP, 32
9D01D038  03E00008   JR RA
9D01D03C  00000000   NOP
882:                 
883:                 
884:                 /******************************************************************************
885:                  * Function:        PTR_BASE MACSetWritePtr(PTR_BASE address)
886:                  *
887:                  * PreCondition:    None
888:                  *
889:                  * Input:           Address: Address to seek to
890:                  *
891:                  * Output:          WORD: Old EWRPT location
892:                  *
893:                  * Side Effects:    None
894:                  *
895:                  * Overview:        SPI write pointer is updated.  All calls to 
896:                  *					MACPut() and MACPutArray() will use this new value.
897:                  *
898:                  * Note:			None
899:                  *****************************************************************************/
900:                 PTR_BASE MACSetWritePtr(PTR_BASE address)
901:                 {
9D01D040  27BDFFE0   ADDIU SP, SP, -32
9D01D044  AFBF001C   SW RA, 28(SP)
9D01D048  AFBE0018   SW S8, 24(SP)
9D01D04C  03A0F021   ADDU S8, SP, ZERO
9D01D050  AFC40020   SW A0, 32(S8)
902:                 	WORD wOldWritePtr;
903:                 
904:                 	wOldWritePtr = ReadReg(EGPWRPT);
9D01D054  24040088   ADDIU A0, ZERO, 136
9D01D058  0F4078D5   JAL 0x9D01E354
9D01D05C  00000000   NOP
9D01D060  A7C20010   SH V0, 16(S8)
905:                 
906:                 	// Set the TX Write Pointer to the new calculated value
907:                 	WriteReg(EGPWRPT, address);
9D01D064  8FC20020   LW V0, 32(S8)
9D01D068  3042FFFF   ANDI V0, V0, -1
9D01D06C  24040088   ADDIU A0, ZERO, 136
9D01D070  00402821   ADDU A1, V0, ZERO
9D01D074  0F40792D   JAL 0x9D01E4B4
9D01D078  00000000   NOP
908:                 
909:                 	return wOldWritePtr;
9D01D07C  97C20010   LHU V0, 16(S8)
910:                 }
9D01D080  03C0E821   ADDU SP, S8, ZERO
9D01D084  8FBF001C   LW RA, 28(SP)
9D01D088  8FBE0018   LW S8, 24(SP)
9D01D08C  27BD0020   ADDIU SP, SP, 32
9D01D090  03E00008   JR RA
9D01D094  00000000   NOP
911:                 
912:                 
913:                 /******************************************************************************
914:                  * Function:        PTR_BASE MACSetReadPtr(PTR_BASE Address)
915:                  *
916:                  * PreCondition:    None
917:                  *
918:                  * Input:           Address: Address to seek to
919:                  *
920:                  * Output:          WORD: Old ERDPT value
921:                  *
922:                  * Side Effects:    None
923:                  *
924:                  * Overview:        SPI write pointer is updated.  All calls to 
925:                  *					MACPut() and MACPutArray() will use this new value.
926:                  *
927:                  * Note:			None
928:                  *****************************************************************************/
929:                 PTR_BASE MACSetReadPtr(PTR_BASE address)
930:                 {
9D01D098  27BDFFE0   ADDIU SP, SP, -32
9D01D09C  AFBF001C   SW RA, 28(SP)
9D01D0A0  AFBE0018   SW S8, 24(SP)
9D01D0A4  03A0F021   ADDU S8, SP, ZERO
9D01D0A8  AFC40020   SW A0, 32(S8)
931:                 	WORD wOldReadPtr;
932:                 
933:                 	wOldReadPtr = ReadReg(ERXRDPT);
9D01D0AC  2404008A   ADDIU A0, ZERO, 138
9D01D0B0  0F4078D5   JAL 0x9D01E354
9D01D0B4  00000000   NOP
9D01D0B8  A7C20010   SH V0, 16(S8)
934:                 
935:                 	// Set the RX Read Pointer to the new calculated value
936:                 	WriteReg(ERXRDPT, address);
9D01D0BC  8FC20020   LW V0, 32(S8)
9D01D0C0  3042FFFF   ANDI V0, V0, -1
9D01D0C4  2404008A   ADDIU A0, ZERO, 138
9D01D0C8  00402821   ADDU A1, V0, ZERO
9D01D0CC  0F40792D   JAL 0x9D01E4B4
9D01D0D0  00000000   NOP
937:                 
938:                 	return wOldReadPtr;
9D01D0D4  97C20010   LHU V0, 16(S8)
939:                 }
9D01D0D8  03C0E821   ADDU SP, S8, ZERO
9D01D0DC  8FBF001C   LW RA, 28(SP)
9D01D0E0  8FBE0018   LW S8, 24(SP)
9D01D0E4  27BD0020   ADDIU SP, SP, 32
9D01D0E8  03E00008   JR RA
9D01D0EC  00000000   NOP
940:                 
941:                 
942:                 /******************************************************************************
943:                  * Function:        WORD MACCalcRxChecksum(WORD offset, WORD len)
944:                  *
945:                  * PreCondition:    None
946:                  *
947:                  * Input:           offset	- Number of bytes beyond the beginning of the 
948:                  *							Ethernet data (first byte after the type field) 
949:                  *							where the checksum should begin
950:                  *					len		- Total number of bytes to include in the checksum
951:                  *
952:                  * Output:          16-bit checksum as defined by RFC 793.
953:                  *
954:                  * Side Effects:    None
955:                  *
956:                  * Overview:        This function performs a checksum calculation in the MAC
957:                  *                  buffer itself
958:                  *
959:                  * Note:            None
960:                  *****************************************************************************/
961:                 WORD MACCalcRxChecksum(WORD offset, WORD len)
962:                 {
9D01D0F0  27BDFFE0   ADDIU SP, SP, -32
9D01D0F4  AFBF001C   SW RA, 28(SP)
9D01D0F8  AFBE0018   SW S8, 24(SP)
9D01D0FC  03A0F021   ADDU S8, SP, ZERO
9D01D100  00801821   ADDU V1, A0, ZERO
9D01D104  00A01021   ADDU V0, A1, ZERO
9D01D108  A7C30020   SH V1, 32(S8)
9D01D10C  A7C20024   SH V0, 36(S8)
963:                 	WORD wStartAddress;
964:                 
965:                 	// Add the offset requested by firmware plus the Ethernet header
966:                 	wStartAddress = wCurrentPacketPointer + sizeof(ENC100_PREAMBLE) + offset;
9D01D110  97838102   LHU V1, -32510(GP)
9D01D114  97C20020   LHU V0, 32(S8)
9D01D118  00621021   ADDU V0, V1, V0
9D01D11C  3042FFFF   ANDI V0, V0, -1
9D01D120  24420016   ADDIU V0, V0, 22
9D01D124  A7C20010   SH V0, 16(S8)
967:                 	if(wStartAddress > RXSTOP)
9D01D128  97C20010   LHU V0, 16(S8)
9D01D12C  2C426000   SLTIU V0, V0, 24576
9D01D130  14400004   BNE V0, ZERO, 0x9D01D144
9D01D134  00000000   NOP
968:                 		wStartAddress -= RXSIZE;
9D01D138  97C20010   LHU V0, 16(S8)
9D01D13C  2442E786   ADDIU V0, V0, -6266
9D01D140  A7C20010   SH V0, 16(S8)
969:                 
970:                 	// If in power down, temporarily bring power up so we can use the DMA
971:                 	if(ENC100Flags.PoweredDown)
9D01D144  93828108   LBU V0, -32504(GP)
9D01D148  30420002   ANDI V0, V0, 2
9D01D14C  304200FF   ANDI V0, V0, 255
9D01D150  10400007   BEQ V0, ZERO, 0x9D01D170
9D01D154  00000000   NOP
972:                 		BFSReg(ECON2, ECON2_ETHEN);
9D01D158  2404006E   ADDIU A0, ZERO, 110
9D01D15C  34058000   ORI A1, ZERO, -32768
9D01D160  0F40798D   JAL 0x9D01E634
9D01D164  00000000   NOP
973:                 
974:                 	// Calculate the checksum using the ENCX24J600 DMA engine		
975:                 	while(ReadReg(ECON1) & ECON1_DMAST);
9D01D168  0B40745D   J 0x9D01D174
9D01D16C  00000000   NOP
9D01D170  00000000   NOP
9D01D174  2404001E   ADDIU A0, ZERO, 30
9D01D178  0F4078D5   JAL 0x9D01E354
9D01D17C  00000000   NOP
9D01D180  30420020   ANDI V0, V0, 32
9D01D184  1440FFFB   BNE V0, ZERO, 0x9D01D174
9D01D188  00000000   NOP
976:                 	WriteReg(EDMAST, wStartAddress);
9D01D18C  97C20010   LHU V0, 16(S8)
9D01D190  2404000A   ADDIU A0, ZERO, 10
9D01D194  00402821   ADDU A1, V0, ZERO
9D01D198  0F40792D   JAL 0x9D01E4B4
9D01D19C  00000000   NOP
977:                 	WriteReg(EDMALEN, len);
9D01D1A0  97C20024   LHU V0, 36(S8)
9D01D1A4  2404000C   ADDIU A0, ZERO, 12
9D01D1A8  00402821   ADDU A1, V0, ZERO
9D01D1AC  0F40792D   JAL 0x9D01E4B4
9D01D1B0  00000000   NOP
978:                 	BFCReg(ECON1, ECON1_DMACPY | ECON1_DMANOCS | ECON1_DMACSSD);
9D01D1B4  2404001E   ADDIU A0, ZERO, 30
9D01D1B8  2405001C   ADDIU A1, ZERO, 28
9D01D1BC  0F4079D4   JAL 0x9D01E750
9D01D1C0  00000000   NOP
979:                 	BFSReg(ECON1, ECON1_DMAST);
9D01D1C4  2404001E   ADDIU A0, ZERO, 30
9D01D1C8  24050020   ADDIU A1, ZERO, 32
9D01D1CC  0F40798D   JAL 0x9D01E634
9D01D1D0  00000000   NOP
980:                 	while(ReadReg(ECON1) & ECON1_DMAST);
9D01D1D4  00000000   NOP
9D01D1D8  2404001E   ADDIU A0, ZERO, 30
9D01D1DC  0F4078D5   JAL 0x9D01E354
9D01D1E0  00000000   NOP
9D01D1E4  30420020   ANDI V0, V0, 32
9D01D1E8  1440FFFB   BNE V0, ZERO, 0x9D01D1D8
9D01D1EC  00000000   NOP
981:                 
982:                 	// Restore power down state, if applicable
983:                 	if(ENC100Flags.PoweredDown)
9D01D1F0  93828108   LBU V0, -32504(GP)
9D01D1F4  30420002   ANDI V0, V0, 2
9D01D1F8  304200FF   ANDI V0, V0, 255
9D01D1FC  10400005   BEQ V0, ZERO, 0x9D01D214
9D01D200  00000000   NOP
984:                 		BFCReg(ECON2, ECON2_ETHEN);
9D01D204  2404006E   ADDIU A0, ZERO, 110
9D01D208  34058000   ORI A1, ZERO, -32768
9D01D20C  0F4079D4   JAL 0x9D01E750
9D01D210  00000000   NOP
985:                 
986:                 	return ReadReg(EDMACS);
9D01D214  24040010   ADDIU A0, ZERO, 16
9D01D218  0F4078D5   JAL 0x9D01E354
9D01D21C  00000000   NOP
987:                 }
9D01D220  03C0E821   ADDU SP, S8, ZERO
9D01D224  8FBF001C   LW RA, 28(SP)
9D01D228  8FBE0018   LW S8, 24(SP)
9D01D22C  27BD0020   ADDIU SP, SP, 32
9D01D230  03E00008   JR RA
9D01D234  00000000   NOP
988:                 
989:                 /******************************************************************************
990:                  * Function:        WORD CalcIPBufferChecksum(WORD len)
991:                  *
992:                  * PreCondition:    Read buffer pointer set to starting of checksum data
993:                  *
994:                  * Input:           len: Total number of bytes to calculate the checksum over. 
995:                  *						 The first byte included in the checksum is the byte 
996:                  *						 pointed to by ERDPT, which is updated by calls to 
997:                  *						 MACSetReadPtr(), MACGet(), MACGetArray(), 
998:                  *						 MACGetHeader(), etc.
999:                  *
1000:                 * Output:          16-bit checksum as defined by RFC 793
1001:                 *
1002:                 * Side Effects:    None
1003:                 *
1004:                 * Overview:        This function performs a checksum calculation in the MAC
1005:                 *                  buffer itself.  The ENCx24J600 has a hardware DMA module 
1006:                 *					which can calculate the checksum faster than software, so 
1007:                 *					this function replaces the CaclIPBufferChecksum() function 
1008:                 *					defined in the helpers.c file.  Through the use of 
1009:                 *					preprocessor defines, this replacement is automatic.
1010:                 *
1011:                 * Note:            This function works either in the RX buffer area or the TX
1012:                 *					buffer area.  No validation is done on the len parameter.
1013:                 *****************************************************************************/
1014:                WORD CalcIPBufferChecksum(WORD len)
1015:                {
9D01D238  27BDFFE8   ADDIU SP, SP, -24
9D01D23C  AFBF0014   SW RA, 20(SP)
9D01D240  AFBE0010   SW S8, 16(SP)
9D01D244  03A0F021   ADDU S8, SP, ZERO
9D01D248  00801021   ADDU V0, A0, ZERO
9D01D24C  A7C20018   SH V0, 24(S8)
1016:                	// If in power down, temporarily bring power up so we can use the DMA
1017:                	if(ENC100Flags.PoweredDown)
9D01D250  93828108   LBU V0, -32504(GP)
9D01D254  30420002   ANDI V0, V0, 2
9D01D258  304200FF   ANDI V0, V0, 255
9D01D25C  10400007   BEQ V0, ZERO, 0x9D01D27C
9D01D260  00000000   NOP
1018:                		BFSReg(ECON2, ECON2_ETHEN);
9D01D264  2404006E   ADDIU A0, ZERO, 110
9D01D268  34058000   ORI A1, ZERO, -32768
9D01D26C  0F40798D   JAL 0x9D01E634
9D01D270  00000000   NOP
1019:                
1020:                	// Calculate the checksum using the ENCX24J600 DMA engine
1021:                	while(ReadReg(ECON1) & ECON1_DMAST);
9D01D274  0B4074A0   J 0x9D01D280
9D01D278  00000000   NOP
9D01D27C  00000000   NOP
9D01D280  2404001E   ADDIU A0, ZERO, 30
9D01D284  0F4078D5   JAL 0x9D01E354
9D01D288  00000000   NOP
9D01D28C  30420020   ANDI V0, V0, 32
9D01D290  1440FFFB   BNE V0, ZERO, 0x9D01D280
9D01D294  00000000   NOP
1022:                	WriteReg(EDMAST, ReadReg(ERXRDPT));
9D01D298  2404008A   ADDIU A0, ZERO, 138
9D01D29C  0F4078D5   JAL 0x9D01E354
9D01D2A0  00000000   NOP
9D01D2A4  2404000A   ADDIU A0, ZERO, 10
9D01D2A8  00402821   ADDU A1, V0, ZERO
9D01D2AC  0F40792D   JAL 0x9D01E4B4
9D01D2B0  00000000   NOP
1023:                	WriteReg(EDMALEN, len);
9D01D2B4  97C20018   LHU V0, 24(S8)
9D01D2B8  2404000C   ADDIU A0, ZERO, 12
9D01D2BC  00402821   ADDU A1, V0, ZERO
9D01D2C0  0F40792D   JAL 0x9D01E4B4
9D01D2C4  00000000   NOP
1024:                	BFCReg(ECON1, ECON1_DMACPY | ECON1_DMANOCS | ECON1_DMACSSD);
9D01D2C8  2404001E   ADDIU A0, ZERO, 30
9D01D2CC  2405001C   ADDIU A1, ZERO, 28
9D01D2D0  0F4079D4   JAL 0x9D01E750
9D01D2D4  00000000   NOP
1025:                	BFSReg(ECON1, ECON1_DMAST);
9D01D2D8  2404001E   ADDIU A0, ZERO, 30
9D01D2DC  24050020   ADDIU A1, ZERO, 32
9D01D2E0  0F40798D   JAL 0x9D01E634
9D01D2E4  00000000   NOP
1026:                	while(ReadReg(ECON1) & ECON1_DMAST);
9D01D2E8  00000000   NOP
9D01D2EC  2404001E   ADDIU A0, ZERO, 30
9D01D2F0  0F4078D5   JAL 0x9D01E354
9D01D2F4  00000000   NOP
9D01D2F8  30420020   ANDI V0, V0, 32
9D01D2FC  1440FFFB   BNE V0, ZERO, 0x9D01D2EC
9D01D300  00000000   NOP
1027:                
1028:                	// Restore power down state, if applicable
1029:                	if(ENC100Flags.PoweredDown)
9D01D304  93828108   LBU V0, -32504(GP)
9D01D308  30420002   ANDI V0, V0, 2
9D01D30C  304200FF   ANDI V0, V0, 255
9D01D310  10400005   BEQ V0, ZERO, 0x9D01D328
9D01D314  00000000   NOP
1030:                		BFCReg(ECON2, ECON2_ETHEN);
9D01D318  2404006E   ADDIU A0, ZERO, 110
9D01D31C  34058000   ORI A1, ZERO, -32768
9D01D320  0F4079D4   JAL 0x9D01E750
9D01D324  00000000   NOP
1031:                
1032:                	return ReadReg(EDMACS);
9D01D328  24040010   ADDIU A0, ZERO, 16
9D01D32C  0F4078D5   JAL 0x9D01E354
9D01D330  00000000   NOP
1033:                }
9D01D334  03C0E821   ADDU SP, S8, ZERO
9D01D338  8FBF0014   LW RA, 20(SP)
9D01D33C  8FBE0010   LW S8, 16(SP)
9D01D340  27BD0018   ADDIU SP, SP, 24
9D01D344  03E00008   JR RA
9D01D348  00000000   NOP
1034:                
1035:                
1036:                /*****************************************************************************
1037:                  Function:
1038:                	void MACMemCopyAsync(PTR_BASE destAddr, PTR_BASE sourceAddr, WORD len)
1039:                
1040:                  Summary:
1041:                	Asynchronously copies data from one address to another within the 24KB 
1042:                	Ethernet memory.
1043:                
1044:                  Description:
1045:                	Asynchronously copies data from one address to another within the 24KB 
1046:                	Ethernet memory using the ENCX24J600 hardware DMA engine (very fast).  
1047:                	Overlapped memory regions are allowed (with restrictions).  The addresses 
1048:                	do not have to be aligned.
1049:                
1050:                  Precondition:
1051:                	SPI bus must be initialized (done in MACInit()).
1052:                
1053:                  Parameters:
1054:                	destAddr - Destination address in the Ethernet memory to copy to.  If 
1055:                		(PTR_BASE)-1 is specified, the current EGPWRPT value will be used 
1056:                		instead.
1057:                	sourceAddr - Source address to read from.  If (PTR_BASE)-1 is specified, 
1058:                		the current EGPRDPT value will be used instead.
1059:                	len - Number of bytes to copy
1060:                
1061:                  Returns:
1062:                	None
1063:                
1064:                  Remarks:
1065:                  	Call MACIsMemCopyDone() to see when the transfer is complete.
1066:                  	
1067:                	Copying to a destination region that overlaps with the source address 
1068:                	is supported only if the destination start address is at a lower memory 
1069:                	address (closer to 0x0000) than the source pointer.  However, if they do 
1070:                	overlap there must be at least 2 bytes of non-overlap to ensure correct 
1071:                	results due to hardware DMA requirements.  For example, destAddr = 0; 
1072:                	sourceAddr = 1; is illegal while destAddr = 0; sourceAddr = 2; is fine.
1073:                  
1074:                 	If a prior transfer is already in progress prior to calling this function, 
1075:                 	this function will block until it can start this transfer.
1076:                
1077:                 	If (PTR_BASE)-1 is used for the sourceAddr or destAddr parameters, 
1078:                 	then that pointer will get updated with the next address after the read or 
1079:                 	write.
1080:                 *****************************************************************************/
1081:                void MACMemCopyAsync(PTR_BASE destAddr, PTR_BASE sourceAddr, WORD len)
1082:                {
9D01D34C  27BDFFE0   ADDIU SP, SP, -32
9D01D350  AFBF001C   SW RA, 28(SP)
9D01D354  AFBE0018   SW S8, 24(SP)
9D01D358  03A0F021   ADDU S8, SP, ZERO
9D01D35C  AFC40020   SW A0, 32(S8)
9D01D360  AFC50024   SW A1, 36(S8)
9D01D364  00C01021   ADDU V0, A2, ZERO
9D01D368  A7C20028   SH V0, 40(S8)
1083:                	WORD wNewReadPtr;
1084:                
1085:                	// Decode destination and source addresses
1086:                	if(destAddr == (PTR_BASE)-1)
9D01D36C  8FC30020   LW V1, 32(S8)
9D01D370  2402FFFF   ADDIU V0, ZERO, -1
9D01D374  1462000E   BNE V1, V0, 0x9D01D3B0
9D01D378  00000000   NOP
1087:                	{
1088:                		destAddr = ReadReg(EGPWRPT);
9D01D37C  24040088   ADDIU A0, ZERO, 136
9D01D380  0F4078D5   JAL 0x9D01E354
9D01D384  00000000   NOP
9D01D388  AFC20020   SW V0, 32(S8)
1089:                		WriteReg(EGPWRPT, destAddr + len);
9D01D38C  8FC20020   LW V0, 32(S8)
9D01D390  3043FFFF   ANDI V1, V0, -1
9D01D394  97C20028   LHU V0, 40(S8)
9D01D398  00621021   ADDU V0, V1, V0
9D01D39C  3042FFFF   ANDI V0, V0, -1
9D01D3A0  24040088   ADDIU A0, ZERO, 136
9D01D3A4  00402821   ADDU A1, V0, ZERO
9D01D3A8  0F40792D   JAL 0x9D01E4B4
9D01D3AC  00000000   NOP
1090:                	}
1091:                	if(sourceAddr == (PTR_BASE)-1)
9D01D3B0  8FC30024   LW V1, 36(S8)
9D01D3B4  2402FFFF   ADDIU V0, ZERO, -1
9D01D3B8  14620016   BNE V1, V0, 0x9D01D414
9D01D3BC  00000000   NOP
1092:                	{
1093:                		sourceAddr = ReadReg(ERXRDPT);
9D01D3C0  2404008A   ADDIU A0, ZERO, 138
9D01D3C4  0F4078D5   JAL 0x9D01E354
9D01D3C8  00000000   NOP
9D01D3CC  AFC20024   SW V0, 36(S8)
1094:                		wNewReadPtr = sourceAddr + len;
9D01D3D0  8FC20024   LW V0, 36(S8)
9D01D3D4  3043FFFF   ANDI V1, V0, -1
9D01D3D8  97C20028   LHU V0, 40(S8)
9D01D3DC  00621021   ADDU V0, V1, V0
9D01D3E0  A7C20010   SH V0, 16(S8)
1095:                		if(wNewReadPtr > RXSTOP)
9D01D3E4  97C20010   LHU V0, 16(S8)
9D01D3E8  2C426000   SLTIU V0, V0, 24576
9D01D3EC  14400004   BNE V0, ZERO, 0x9D01D400
9D01D3F0  00000000   NOP
1096:                			wNewReadPtr -= RXSIZE;
9D01D3F4  97C20010   LHU V0, 16(S8)
9D01D3F8  2442E786   ADDIU V0, V0, -6266
9D01D3FC  A7C20010   SH V0, 16(S8)
1097:                		WriteReg(ERXRDPT, wNewReadPtr);
9D01D400  97C20010   LHU V0, 16(S8)
9D01D404  2404008A   ADDIU A0, ZERO, 138
9D01D408  00402821   ADDU A1, V0, ZERO
9D01D40C  0F40792D   JAL 0x9D01E4B4
9D01D410  00000000   NOP
1098:                	}
1099:                
1100:                	// If in power down, temporarily bring power up so we can use the DMA
1101:                	if(ENC100Flags.PoweredDown)
9D01D414  93828108   LBU V0, -32504(GP)
9D01D418  30420002   ANDI V0, V0, 2
9D01D41C  304200FF   ANDI V0, V0, 255
9D01D420  10400007   BEQ V0, ZERO, 0x9D01D440
9D01D424  00000000   NOP
1102:                		BFSReg(ECON2, ECON2_ETHEN);
9D01D428  2404006E   ADDIU A0, ZERO, 110
9D01D42C  34058000   ORI A1, ZERO, -32768
9D01D430  0F40798D   JAL 0x9D01E634
9D01D434  00000000   NOP
1103:                
1104:                	// Start the copy using the DMA 
1105:                	while(ReadReg(ECON1) & ECON1_DMAST);
9D01D438  0B407511   J 0x9D01D444
9D01D43C  00000000   NOP
9D01D440  00000000   NOP
9D01D444  2404001E   ADDIU A0, ZERO, 30
9D01D448  0F4078D5   JAL 0x9D01E354
9D01D44C  00000000   NOP
9D01D450  30420020   ANDI V0, V0, 32
9D01D454  1440FFFB   BNE V0, ZERO, 0x9D01D444
9D01D458  00000000   NOP
1106:                	WriteReg(EDMAST, sourceAddr);
9D01D45C  8FC20024   LW V0, 36(S8)
9D01D460  3042FFFF   ANDI V0, V0, -1
9D01D464  2404000A   ADDIU A0, ZERO, 10
9D01D468  00402821   ADDU A1, V0, ZERO
9D01D46C  0F40792D   JAL 0x9D01E4B4
9D01D470  00000000   NOP
1107:                	WriteReg(EDMADST, destAddr);
9D01D474  8FC20020   LW V0, 32(S8)
9D01D478  3042FFFF   ANDI V0, V0, -1
9D01D47C  2404000E   ADDIU A0, ZERO, 14
9D01D480  00402821   ADDU A1, V0, ZERO
9D01D484  0F40792D   JAL 0x9D01E4B4
9D01D488  00000000   NOP
1108:                	WriteReg(EDMALEN, len);
9D01D48C  97C20028   LHU V0, 40(S8)
9D01D490  2404000C   ADDIU A0, ZERO, 12
9D01D494  00402821   ADDU A1, V0, ZERO
9D01D498  0F40792D   JAL 0x9D01E4B4
9D01D49C  00000000   NOP
1109:                	BFSReg(ECON1, ECON1_DMAST | ECON1_DMACPY);
9D01D4A0  2404001E   ADDIU A0, ZERO, 30
9D01D4A4  24050030   ADDIU A1, ZERO, 48
9D01D4A8  0F40798D   JAL 0x9D01E634
9D01D4AC  00000000   NOP
1110:                }
9D01D4B0  03C0E821   ADDU SP, S8, ZERO
9D01D4B4  8FBF001C   LW RA, 28(SP)
9D01D4B8  8FBE0018   LW S8, 24(SP)
9D01D4BC  27BD0020   ADDIU SP, SP, 32
9D01D4C0  03E00008   JR RA
9D01D4C4  00000000   NOP
1111:                
1112:                BOOL MACIsMemCopyDone(void)
1113:                {
9D01D4C8  27BDFFE0   ADDIU SP, SP, -32
9D01D4CC  AFBF001C   SW RA, 28(SP)
9D01D4D0  AFBE0018   SW S8, 24(SP)
9D01D4D4  03A0F021   ADDU S8, SP, ZERO
1114:                	BOOL bDone;
1115:                	
1116:                	bDone = !(ReadReg(ECON1) & ECON1_DMAST);
9D01D4D8  2404001E   ADDIU A0, ZERO, 30
9D01D4DC  0F4078D5   JAL 0x9D01E354
9D01D4E0  00000000   NOP
9D01D4E4  30420020   ANDI V0, V0, 32
9D01D4E8  2C420001   SLTIU V0, V0, 1
9D01D4EC  AFC20010   SW V0, 16(S8)
1117:                	
1118:                	// Restore power down state, if applicable
1119:                	if(bDone && ENC100Flags.PoweredDown)
9D01D4F0  8FC20010   LW V0, 16(S8)
9D01D4F4  1040000A   BEQ V0, ZERO, 0x9D01D520
9D01D4F8  00000000   NOP
9D01D4FC  93828108   LBU V0, -32504(GP)
9D01D500  30420002   ANDI V0, V0, 2
9D01D504  304200FF   ANDI V0, V0, 255
9D01D508  10400005   BEQ V0, ZERO, 0x9D01D520
9D01D50C  00000000   NOP
1120:                		BFCReg(ECON2, ECON2_ETHEN);
9D01D510  2404006E   ADDIU A0, ZERO, 110
9D01D514  34058000   ORI A1, ZERO, -32768
9D01D518  0F4079D4   JAL 0x9D01E750
9D01D51C  00000000   NOP
1121:                
1122:                	return bDone;
9D01D520  8FC20010   LW V0, 16(S8)
1123:                }
9D01D524  03C0E821   ADDU SP, S8, ZERO
9D01D528  8FBF001C   LW RA, 28(SP)
9D01D52C  8FBE0018   LW S8, 24(SP)
9D01D530  27BD0020   ADDIU SP, SP, 32
9D01D534  03E00008   JR RA
9D01D538  00000000   NOP
1124:                
1125:                
1126:                /******************************************************************************
1127:                 * Function:        BYTE MACGet()
1128:                 *
1129:                 * PreCondition:    SPI bus must be initialized (done in MACInit()).
1130:                 * 					ERDPT must point to the place to read from.
1131:                 *
1132:                 * Input:           None
1133:                 *
1134:                 * Output:          Byte read from the ENCx24J600's RAM
1135:                 *
1136:                 * Side Effects:    None
1137:                 *
1138:                 * Overview:        MACGet returns the byte pointed to by ERDPT and 
1139:                 *					increments ERDPT so MACGet() can be called again.  The 
1140:                 *					increment will follow the receive buffer wrapping boundary.
1141:                 *
1142:                 * Note:            None
1143:                 *****************************************************************************/
1144:                BYTE MACGet()
1145:                {
9D01D53C  27BDFFE0   ADDIU SP, SP, -32
9D01D540  AFBF001C   SW RA, 28(SP)
9D01D544  AFBE0018   SW S8, 24(SP)
9D01D548  03A0F021   ADDU S8, SP, ZERO
1146:                	BYTE i;
1147:                	
1148:                	ReadMemoryWindow(RX_WINDOW, &i, 1);
9D01D54C  24040004   ADDIU A0, ZERO, 4
9D01D550  27C20010   ADDIU V0, S8, 16
9D01D554  00402821   ADDU A1, V0, ZERO
9D01D558  24060001   ADDIU A2, ZERO, 1
9D01D55C  0F4076D8   JAL 0x9D01DB60
9D01D560  00000000   NOP
1149:                	return i;
9D01D564  93C20010   LBU V0, 16(S8)
1150:                }//end MACGet
9D01D568  03C0E821   ADDU SP, S8, ZERO
9D01D56C  8FBF001C   LW RA, 28(SP)
9D01D570  8FBE0018   LW S8, 24(SP)
9D01D574  27BD0020   ADDIU SP, SP, 32
9D01D578  03E00008   JR RA
9D01D57C  00000000   NOP
1151:                
1152:                
1153:                /******************************************************************************
1154:                 * Function:        WORD MACGetArray(BYTE *val, WORD len)
1155:                 *
1156:                 * PreCondition:    SPI bus must be initialized (done in MACInit()).
1157:                 * 					ERDPT must point to the place to read from.
1158:                 *
1159:                 * Input:           *val: Pointer to storage location
1160:                 *					len:  Number of bytes to read from the data buffer.
1161:                 *
1162:                 * Output:          Byte(s) of data read from the data buffer.
1163:                 *
1164:                 * Side Effects:    None
1165:                 *
1166:                 * Overview:        Burst reads several sequential bytes from the data buffer 
1167:                 *					and places them into local memory.  With SPI burst support, 
1168:                 *					it performs much faster than multiple MACGet() calls.
1169:                 *					ERDPT is incremented after each byte, following the same 
1170:                 *					rules as MACGet().
1171:                 *
1172:                 * Note:            None
1173:                 *****************************************************************************/
1174:                WORD MACGetArray(BYTE *val, WORD len)
1175:                {
9D01D580  27BDFFE0   ADDIU SP, SP, -32
9D01D584  AFBF001C   SW RA, 28(SP)
9D01D588  AFBE0018   SW S8, 24(SP)
9D01D58C  03A0F021   ADDU S8, SP, ZERO
9D01D590  AFC40020   SW A0, 32(S8)
9D01D594  00A01021   ADDU V0, A1, ZERO
9D01D598  A7C20024   SH V0, 36(S8)
1176:                	WORD wNewReadPtr;
1177:                	
1178:                	if(val)
9D01D59C  8FC20020   LW V0, 32(S8)
9D01D5A0  10400009   BEQ V0, ZERO, 0x9D01D5C8
9D01D5A4  00000000   NOP
1179:                	{
1180:                		ReadMemoryWindow(RX_WINDOW, val, len);
9D01D5A8  97C20024   LHU V0, 36(S8)
9D01D5AC  24040004   ADDIU A0, ZERO, 4
9D01D5B0  8FC50020   LW A1, 32(S8)
9D01D5B4  00403021   ADDU A2, V0, ZERO
9D01D5B8  0F4076D8   JAL 0x9D01DB60
9D01D5BC  00000000   NOP
9D01D5C0  0B407585   J 0x9D01D614
9D01D5C4  00000000   NOP
1181:                	}
1182:                	else
1183:                	{
1184:                		wNewReadPtr = ReadReg(ERXRDPT) + len;
9D01D5C8  2404008A   ADDIU A0, ZERO, 138
9D01D5CC  0F4078D5   JAL 0x9D01E354
9D01D5D0  00000000   NOP
9D01D5D4  00401821   ADDU V1, V0, ZERO
9D01D5D8  97C20024   LHU V0, 36(S8)
9D01D5DC  00621021   ADDU V0, V1, V0
9D01D5E0  A7C20010   SH V0, 16(S8)
1185:                		if(wNewReadPtr > RXSTOP)
9D01D5E4  97C20010   LHU V0, 16(S8)
9D01D5E8  2C426000   SLTIU V0, V0, 24576
9D01D5EC  14400004   BNE V0, ZERO, 0x9D01D600
9D01D5F0  00000000   NOP
1186:                			wNewReadPtr -= RXSIZE;
9D01D5F4  97C20010   LHU V0, 16(S8)
9D01D5F8  2442E786   ADDIU V0, V0, -6266
9D01D5FC  A7C20010   SH V0, 16(S8)
1187:                		WriteReg(ERXRDPT, wNewReadPtr);
9D01D600  97C20010   LHU V0, 16(S8)
9D01D604  2404008A   ADDIU A0, ZERO, 138
9D01D608  00402821   ADDU A1, V0, ZERO
9D01D60C  0F40792D   JAL 0x9D01E4B4
9D01D610  00000000   NOP
1188:                	}
1189:                		
1190:                	return len;
9D01D614  97C20024   LHU V0, 36(S8)
1191:                }//end MACGetArray
9D01D618  03C0E821   ADDU SP, S8, ZERO
9D01D61C  8FBF001C   LW RA, 28(SP)
9D01D620  8FBE0018   LW S8, 24(SP)
9D01D624  27BD0020   ADDIU SP, SP, 32
9D01D628  03E00008   JR RA
9D01D62C  00000000   NOP
1192:                
1193:                
1194:                /******************************************************************************
1195:                 * Function:        void MACPut(BYTE val)
1196:                 *
1197:                 * PreCondition:    SPI bus must be initialized (done in MACInit()).
1198:                 * 					EWRPT must point to the location to begin writing.
1199:                 *
1200:                 * Input:           Byte to write into the ENCx24J600 buffer memory
1201:                 *
1202:                 * Output:          None
1203:                 *
1204:                 * Side Effects:    None
1205:                 *
1206:                 * Overview:        MACPut outputs the Write Buffer Memory opcode/constant 
1207:                 *					(8 bits) and data to write (8 bits) over the SPI.  
1208:                 *					EWRPT is incremented after the write.
1209:                 *
1210:                 * Note:            None
1211:                 *****************************************************************************/
1212:                void MACPut(BYTE val)
1213:                {
9D01D630  27BDFFE8   ADDIU SP, SP, -24
9D01D634  AFBF0014   SW RA, 20(SP)
9D01D638  AFBE0010   SW S8, 16(SP)
9D01D63C  03A0F021   ADDU S8, SP, ZERO
9D01D640  00801021   ADDU V0, A0, ZERO
9D01D644  A3C20018   SB V0, 24(S8)
1214:                	WriteMemoryWindow(GP_WINDOW, &val, 1);
9D01D648  24040002   ADDIU A0, ZERO, 2
9D01D64C  27C50018   ADDIU A1, S8, 24
9D01D650  24060001   ADDIU A2, ZERO, 1
9D01D654  0F4076A3   JAL 0x9D01DA8C
9D01D658  00000000   NOP
1215:                }//end MACPut
9D01D65C  03C0E821   ADDU SP, S8, ZERO
9D01D660  8FBF0014   LW RA, 20(SP)
9D01D664  8FBE0010   LW S8, 16(SP)
9D01D668  27BD0018   ADDIU SP, SP, 24
9D01D66C  03E00008   JR RA
9D01D670  00000000   NOP
1216:                
1217:                
1218:                /******************************************************************************
1219:                 * Function:        void MACPutArray(BYTE *val, WORD len)
1220:                 *
1221:                 * PreCondition:    SPI bus must be initialized (done in MACInit()).
1222:                 * 					EWRPT must point to the location to begin writing.
1223:                 *
1224:                 * Input:           *val: Pointer to source of bytes to copy.
1225:                 *					len:  Number of bytes to write to the data buffer.
1226:                 *
1227:                 * Output:          None
1228:                 *
1229:                 * Side Effects:    None
1230:                 *
1231:                 * Overview:        MACPutArray writes several sequential bytes to the 
1232:                 *					ENCx24J600 RAM.  It performs faster than multiple MACPut()
1233:                 *					calls.  EWRPT is incremented by len.
1234:                 *
1235:                 * Note:            None
1236:                 *****************************************************************************/
1237:                void MACPutArray(BYTE *val, WORD len)
1238:                {
9D01D674  27BDFFE8   ADDIU SP, SP, -24
9D01D678  AFBF0014   SW RA, 20(SP)
9D01D67C  AFBE0010   SW S8, 16(SP)
9D01D680  03A0F021   ADDU S8, SP, ZERO
9D01D684  AFC40018   SW A0, 24(S8)
9D01D688  00A01021   ADDU V0, A1, ZERO
9D01D68C  A7C2001C   SH V0, 28(S8)
1239:                	WriteMemoryWindow(GP_WINDOW, val, len);
9D01D690  97C2001C   LHU V0, 28(S8)
9D01D694  24040002   ADDIU A0, ZERO, 2
9D01D698  8FC50018   LW A1, 24(S8)
9D01D69C  00403021   ADDU A2, V0, ZERO
9D01D6A0  0F4076A3   JAL 0x9D01DA8C
9D01D6A4  00000000   NOP
1240:                }//end MACPutArray
9D01D6A8  03C0E821   ADDU SP, S8, ZERO
9D01D6AC  8FBF0014   LW RA, 20(SP)
9D01D6B0  8FBE0010   LW S8, 16(SP)
9D01D6B4  27BD0018   ADDIU SP, SP, 24
9D01D6B8  03E00008   JR RA
9D01D6BC  00000000   NOP
1241:                
1242:                
1243:                #if defined(__18CXX)
1244:                /******************************************************************************
1245:                 * Function:        void MACPutROMArray(ROM BYTE *val, WORD len)
1246:                 *
1247:                 * PreCondition:    SPI bus must be initialized (done in MACInit()).
1248:                 * 					EWRPT must point to the location to begin writing.
1249:                 *
1250:                 * Input:           *val: Pointer to source of bytes to copy.
1251:                 *					len:  Number of bytes to write to the data buffer.
1252:                 *
1253:                 * Output:          None
1254:                 *
1255:                 * Side Effects:    None
1256:                 *
1257:                 * Overview:        MACPutArray writes several sequential bytes to the 
1258:                 *					ENCx24J600 RAM.  It performs faster than multiple MACPut()
1259:                 *					calls.  EWRPT is incremented by len.
1260:                 *
1261:                 * Note:            None
1262:                 *****************************************************************************/
1263:                void MACPutROMArray(ROM BYTE *val, WORD len)
1264:                {
1265:                	WORD wChunkLen;
1266:                	BYTE vBuffer[12];
1267:                
1268:                	while(len)
1269:                	{
1270:                		wChunkLen = sizeof(vBuffer);
1271:                		if(len < wChunkLen)
1272:                			wChunkLen = len;
1273:                
1274:                		memcpypgm2ram((void*)vBuffer, (ROM void*)val, wChunkLen);
1275:                		WriteMemoryWindow(GP_WINDOW, vBuffer, wChunkLen);
1276:                
1277:                		len -= wChunkLen;
1278:                		val += wChunkLen;
1279:                	}
1280:                }//end MACPutROMArray
1281:                #endif
1282:                
1283:                
1284:                /******************************************************************************
1285:                 * Function:        void MACPowerDown(void)
1286:                 *
1287:                 * PreCondition:    SPI bus must be initialized (done in MACInit()).
1288:                 *
1289:                 * Input:           None
1290:                 *
1291:                 * Output:          None
1292:                 *
1293:                 * Side Effects:    None
1294:                 *
1295:                 * Overview:        MACPowerDown puts the ENCx24J600 in low power sleep mode. In
1296:                 *					sleep mode, no packets can be transmitted or received.  
1297:                 *					All MAC and PHY registers should not be accessed.
1298:                 *
1299:                 *					To exit power down, call MACPowerUp().
1300:                 *
1301:                 * Note:            If a packet is being transmitted while this function is 
1302:                 * 					called, this function will block until it is it complete.
1303:                 *					If anything is being received, it will be completed.
1304:                 *****************************************************************************/
1305:                void MACPowerDown(void)
1306:                {
9D01D6C0  27BDFFE8   ADDIU SP, SP, -24
9D01D6C4  AFBF0014   SW RA, 20(SP)
9D01D6C8  AFBE0010   SW S8, 16(SP)
9D01D6CC  03A0F021   ADDU S8, SP, ZERO
1307:                	// Disable packet reception
1308:                	BFCReg(ECON1, ECON1_RXEN);
9D01D6D0  2404001E   ADDIU A0, ZERO, 30
9D01D6D4  24050001   ADDIU A1, ZERO, 1
9D01D6D8  0F4079D4   JAL 0x9D01E750
9D01D6DC  00000000   NOP
1309:                
1310:                	// Make sure any last packet which was in-progress when RXEN was cleared 
1311:                	// is completed
1312:                	while(ReadReg(ESTAT) & ESTAT_RXBUSY);
9D01D6E0  00000000   NOP
9D01D6E4  2404001A   ADDIU A0, ZERO, 26
9D01D6E8  0F4078D5   JAL 0x9D01E354
9D01D6EC  00000000   NOP
9D01D6F0  30422000   ANDI V0, V0, 8192
9D01D6F4  1440FFFB   BNE V0, ZERO, 0x9D01D6E4
9D01D6F8  00000000   NOP
1313:                
1314:                	// If a packet is being transmitted, the DMA is operating, the Modular 
1315:                	// Exponentiation or AES engine is running, wait for it to finish
1316:                	while(ReadReg(ECON1) & (ECON1_TXRTS | ECON1_DMAST | ECON1_MODEXST | ECON1_AESST));
9D01D6FC  00000000   NOP
9D01D700  2404001E   ADDIU A0, ZERO, 30
9D01D704  0F4078D5   JAL 0x9D01E354
9D01D708  00000000   NOP
9D01D70C  30428822   ANDI V0, V0, -30686
9D01D710  1440FFFB   BNE V0, ZERO, 0x9D01D700
9D01D714  00000000   NOP
1317:                	
1318:                	// Enter sleep mode
1319:                	ENC100Flags.PoweredDown = 1;
9D01D718  93828108   LBU V0, -32504(GP)
9D01D71C  24030001   ADDIU V1, ZERO, 1
9D01D720  7C620844   INS V0, V1, 1, 1
9D01D724  A3828108   SB V0, -32504(GP)
1320:                	ENC100Flags.CryptoEnabled = 0;
9D01D728  93828108   LBU V0, -32504(GP)
9D01D72C  7C021084   INS V0, ZERO, 2, 1
9D01D730  A3828108   SB V0, -32504(GP)
1321:                	if(ReadReg(EIR) & EIR_CRYPTEN)				// Turn off ModdEx/AES clock
9D01D734  2404001C   ADDIU A0, ZERO, 28
9D01D738  0F4078D5   JAL 0x9D01E354
9D01D73C  00000000   NOP
9D01D740  7C021620   SEH V0, V0
9D01D744  04410003   BGEZ V0, 0x9D01D754
9D01D748  00000000   NOP
1322:                		ToggleCRYPTEN();
9D01D74C  0F407A67   JAL 0x9D01E99C
9D01D750  00000000   NOP
1323:                	WritePHYReg(PHCON1, PHCON1_PSLEEP);			// Turn off the PHY
9D01D754  00002021   ADDU A0, ZERO, ZERO
9D01D758  24050800   ADDIU A1, ZERO, 2048
9D01D75C  0F407A44   JAL WritePHYReg
9D01D760  00000000   NOP
1324:                	BFCReg(ECON2, ECON2_ETHEN | ECON2_STRCH);	// Turn off general internal clocks and LED stretching so they immediately turn off and don't get stuck on
9D01D764  2404006E   ADDIU A0, ZERO, 110
9D01D768  3405C000   ORI A1, ZERO, -16384
9D01D76C  0F4079D4   JAL 0x9D01E750
9D01D770  00000000   NOP
1325:                }//end MACPowerDown
9D01D774  03C0E821   ADDU SP, S8, ZERO
9D01D778  8FBF0014   LW RA, 20(SP)
9D01D77C  8FBE0010   LW S8, 16(SP)
9D01D780  27BD0018   ADDIU SP, SP, 24
9D01D784  03E00008   JR RA
9D01D788  00000000   NOP
1326:                
1327:                
1328:                /******************************************************************************
1329:                 * Function:        void MACEDPowerDown(void)
1330:                 *
1331:                 * PreCondition:    SPI/PSP bus must be initialized (done in MACInit()).
1332:                 *
1333:                 * Input:           None
1334:                 *
1335:                 * Output:          None
1336:                 *
1337:                 * Side Effects:    None
1338:                 *
1339:                 * Overview:        MACEDPowerDown puts the ENCx24J600 PHY in Energy Detect 
1340:                 *					mode. In this mode, the PHY will passively listen for link 
1341:                 *					pulses and automatically link up, if detected. This can be 
1342:                 *					detected via the MACIsLinked() function.  This power state 
1343:                 *					will save power only when an Ethernet cable is unattached.
1344:                 *
1345:                 *					To exit energy detect power down, call MACPowerUp().
1346:                 *
1347:                 * Note:            The ENCx24J600 is fully operational when in energy detect 
1348:                 *					mode.  If a Ethernet link is detected or already established,
1349:                 *					full TX/RX activity will work as normal and no power saving 
1350:                 *					will occur.
1351:                 *****************************************************************************/
1352:                void MACEDPowerDown(void)
1353:                {
9D01D78C  27BDFFE8   ADDIU SP, SP, -24
9D01D790  AFBF0014   SW RA, 20(SP)
9D01D794  AFBE0010   SW S8, 16(SP)
9D01D798  03A0F021   ADDU S8, SP, ZERO
1354:                	// Put the PHY into energy detect mode
1355:                	WritePHYReg(PHCON2, PHCON2_EDPWRDN);		
9D01D79C  24040011   ADDIU A0, ZERO, 17
9D01D7A0  24052000   ADDIU A1, ZERO, 8192
9D01D7A4  0F407A44   JAL WritePHYReg
9D01D7A8  00000000   NOP
1356:                }//end MACEDPowerDown
9D01D7AC  03C0E821   ADDU SP, S8, ZERO
9D01D7B0  8FBF0014   LW RA, 20(SP)
9D01D7B4  8FBE0010   LW S8, 16(SP)
9D01D7B8  27BD0018   ADDIU SP, SP, 24
9D01D7BC  03E00008   JR RA
9D01D7C0  00000000   NOP
1357:                
1358:                
1359:                /******************************************************************************
1360:                 * Function:        void MACPowerUp(void)
1361:                 *
1362:                 * PreCondition:    SPI bus must be initialized (done in MACInit()).
1363:                 *
1364:                 * Input:           None
1365:                 *
1366:                 * Output:          None
1367:                 *
1368:                 * Side Effects:    None
1369:                 *
1370:                 * Overview:        MACPowerUp returns the ENCx24J600 back to normal operation
1371:                 *					after a previous call to MACPowerDown().  Calling this 
1372:                 *					function when already powered up will have no effect.
1373:                 *
1374:                 * Note:            If a link partner is present, it will take 10s of 
1375:                 *					milliseconds before a new link will be established after
1376:                 *					waking up.  While not linked, packets which are 
1377:                 *					transmitted will most likely be lost.  MACIsLinked() can 
1378:                 *					be called to determine if a link is established.
1379:                 *****************************************************************************/
1380:                void MACPowerUp(void)
1381:                {	
9D01D7C4  27BDFFE8   ADDIU SP, SP, -24
9D01D7C8  AFBF0014   SW RA, 20(SP)
9D01D7CC  AFBE0010   SW S8, 16(SP)
9D01D7D0  03A0F021   ADDU S8, SP, ZERO
1382:                	// Start up general clocks and reenable LED stretching
1383:                	ENC100Flags.PoweredDown = 0;
9D01D7D4  93828108   LBU V0, -32504(GP)
9D01D7D8  7C020844   INS V0, ZERO, 1, 1
9D01D7DC  A3828108   SB V0, -32504(GP)
1384:                	BFSReg(ECON2, ECON2_ETHEN | ECON2_STRCH);
9D01D7E0  2404006E   ADDIU A0, ZERO, 110
9D01D7E4  3405C000   ORI A1, ZERO, -16384
9D01D7E8  0F40798D   JAL 0x9D01E634
9D01D7EC  00000000   NOP
1385:                	
1386:                	// Power PHY back up and put in auto-negotation mode to reestablish a link
1387:                	if(ReadPHYReg(PHCON1) & PHCON1_PSLEEP)
9D01D7F0  00002021   ADDU A0, ZERO, ZERO
9D01D7F4  0F407A1B   JAL ReadPHYReg
9D01D7F8  00000000   NOP
9D01D7FC  30420800   ANDI V0, V0, 2048
9D01D800  10400005   BEQ V0, ZERO, 0x9D01D818
9D01D804  00000000   NOP
1388:                		WritePHYReg(PHCON1, PHCON1_ANEN);
9D01D808  00002021   ADDU A0, ZERO, ZERO
9D01D80C  24051000   ADDIU A1, ZERO, 4096
9D01D810  0F407A44   JAL WritePHYReg
9D01D814  00000000   NOP
1389:                	
1390:                	// Disable energy detect PHY power down
1391:                	WritePHYReg(PHCON2, 0x0000);
9D01D818  24040011   ADDIU A0, ZERO, 17
9D01D81C  00002821   ADDU A1, ZERO, ZERO
9D01D820  0F407A44   JAL WritePHYReg
9D01D824  00000000   NOP
1392:                
1393:                	// Ensure the PLL and PHY are ready
1394:                	while(!(ReadReg(ESTAT) & (ESTAT_PHYRDY | ESTAT_CLKRDY)));
9D01D828  00000000   NOP
9D01D82C  2404001A   ADDIU A0, ZERO, 26
9D01D830  0F4078D5   JAL 0x9D01E354
9D01D834  00000000   NOP
9D01D838  30421200   ANDI V0, V0, 4608
9D01D83C  1040FFFB   BEQ V0, ZERO, 0x9D01D82C
9D01D840  00000000   NOP
1395:                	
1396:                	// Enable packet reception
1397:                	BFSReg(ECON1, ECON1_RXEN);
9D01D844  2404001E   ADDIU A0, ZERO, 30
9D01D848  24050001   ADDIU A1, ZERO, 1
9D01D84C  0F40798D   JAL 0x9D01E634
9D01D850  00000000   NOP
1398:                }//end MACPowerUp
9D01D854  03C0E821   ADDU SP, S8, ZERO
9D01D858  8FBF0014   LW RA, 20(SP)
9D01D85C  8FBE0010   LW S8, 16(SP)
9D01D860  27BD0018   ADDIU SP, SP, 24
9D01D864  03E00008   JR RA
9D01D868  00000000   NOP
1399:                
1400:                
1401:                /******************************************************************************
1402:                 * Function:        void SetCLKOUT(BYTE NewConfig)
1403:                 *
1404:                 * PreCondition:    SPI or Parallel bus must be initialized (done in MACInit()).
1405:                 *
1406:                 * Input:           NewConfig - 0x00: CLKOUT disabled (pin driven low)
1407:                 *								0x01: 33.333 MHz
1408:                 *								0x02: 25.000 MHz
1409:                 *								0x03: 20.000 MHz
1410:                 *								0x04: 16.667 MHz
1411:                 *								0x05: 12.500 MHz
1412:                 *								0x06: 10.000 MHz
1413:                 *								0x07:  8.333 MHz
1414:                 *								0x08:  8.000 MHz (47.5% duty cycle)
1415:                 *								0x09:  6.250 MHz
1416:                 *								0x0A:  5.000 MHz
1417:                 *								0x0B:  4.000 MHz
1418:                 *								0x0C:  3.125 MHz
1419:                 *								0x0D: CLKOUT disabled (pin driven low)
1420:                 *								0x0E: 100.00 kHz
1421:                 *								0x0F:  50.00 kHz
1422:                 *
1423:                 * Output:          None
1424:                 *
1425:                 * Side Effects:    None
1426:                 *
1427:                 * Overview:        Writes the value of NewConfig into the COCON bits of ECON2
1428:                 *					register.  The CLKOUT pin will beginning outputting the 
1429:                 *					new frequency immediately.
1430:                 *
1431:                 * Note:            
1432:                 *****************************************************************************/
1433:                void SetCLKOUT(BYTE NewConfig)
1434:                {	
9D01D86C  27BDFFE0   ADDIU SP, SP, -32
9D01D870  AFBF001C   SW RA, 28(SP)
9D01D874  AFBE0018   SW S8, 24(SP)
9D01D878  03A0F021   ADDU S8, SP, ZERO
9D01D87C  00801021   ADDU V0, A0, ZERO
9D01D880  A3C20020   SB V0, 32(S8)
1435:                	WORD w;
1436:                	
1437:                	w = ReadReg(ECON2) & 0xF0FF;	
9D01D884  2404006E   ADDIU A0, ZERO, 110
9D01D888  0F4078D5   JAL 0x9D01E354
9D01D88C  00000000   NOP
9D01D890  00401821   ADDU V1, V0, ZERO
9D01D894  2402F0FF   ADDIU V0, ZERO, -3841
9D01D898  00621024   AND V0, V1, V0
9D01D89C  3042FFFF   ANDI V0, V0, -1
9D01D8A0  A7C20010   SH V0, 16(S8)
1438:                	((BYTE*)&w)[1] |= (NewConfig & 0x0F);
9D01D8A4  27C20010   ADDIU V0, S8, 16
9D01D8A8  24420001   ADDIU V0, V0, 1
9D01D8AC  27C30010   ADDIU V1, S8, 16
9D01D8B0  24630001   ADDIU V1, V1, 1
9D01D8B4  90630000   LBU V1, 0(V1)
9D01D8B8  7C032420   SEB A0, V1
9D01D8BC  83C30020   LB V1, 32(S8)
9D01D8C0  3063000F   ANDI V1, V1, 15
9D01D8C4  7C031C20   SEB V1, V1
9D01D8C8  00831825   OR V1, A0, V1
9D01D8CC  7C031C20   SEB V1, V1
9D01D8D0  306300FF   ANDI V1, V1, 255
9D01D8D4  A0430000   SB V1, 0(V0)
1439:                	WriteReg(ECON2, w);
9D01D8D8  97C20010   LHU V0, 16(S8)
9D01D8DC  2404006E   ADDIU A0, ZERO, 110
9D01D8E0  00402821   ADDU A1, V0, ZERO
9D01D8E4  0F40792D   JAL 0x9D01E4B4
9D01D8E8  00000000   NOP
1440:                }//end SetCLKOUT
9D01D8EC  03C0E821   ADDU SP, S8, ZERO
9D01D8F0  8FBF001C   LW RA, 28(SP)
9D01D8F4  8FBE0018   LW S8, 24(SP)
9D01D8F8  27BD0020   ADDIU SP, SP, 32
9D01D8FC  03E00008   JR RA
9D01D900  00000000   NOP
1441:                
1442:                
1443:                /******************************************************************************
1444:                 * Function:        BYTE GetCLKOUT(void)
1445:                 *
1446:                 * PreCondition:    SPI or Parallel bus must be initialized (done in MACInit()).
1447:                 *
1448:                 * Input:           None
1449:                 *
1450:                 * Output:          BYTE -	0x00: CLKOUT disabled (pin driven low)
1451:                 *							0x01: 33.333 MHz
1452:                 *							0x02: 25.000 MHz
1453:                 *							0x03: 20.000 MHz
1454:                 *							0x04: 16.667 MHz
1455:                 *							0x05: 12.500 MHz
1456:                 *							0x06: 10.000 MHz
1457:                 *							0x07:  8.333 MHz
1458:                 *							0x08:  8.000 MHz (47.5% duty cycle)
1459:                 *							0x09:  6.250 MHz
1460:                 *							0x0A:  5.000 MHz
1461:                 *							0x0B:  4.000 MHz
1462:                 *							0x0C:  3.125 MHz
1463:                 *							0x0D: CLKOUT disabled (pin driven low)
1464:                 *							0x0E: 100.00 kHz
1465:                 *							0x0F:  50.00 kHz
1466:                 *
1467:                 * Side Effects:    None
1468:                 *
1469:                 * Overview:        Returns the current value of the COCON bits of ECON2 
1470:                 *					register.
1471:                 *
1472:                 * Note:            None
1473:                 *****************************************************************************/
1474:                BYTE GetCLKOUT(void)
1475:                {	
9D01D904  27BDFFE0   ADDIU SP, SP, -32
9D01D908  AFBF001C   SW RA, 28(SP)
9D01D90C  AFBE0018   SW S8, 24(SP)
9D01D910  03A0F021   ADDU S8, SP, ZERO
1476:                	WORD w;
1477:                
1478:                	w = ReadReg(ECON2);	
9D01D914  2404006E   ADDIU A0, ZERO, 110
9D01D918  0F4078D5   JAL 0x9D01E354
9D01D91C  00000000   NOP
9D01D920  A7C20010   SH V0, 16(S8)
1479:                
1480:                	return ((BYTE*)&w)[1] & 0x0F;
9D01D924  27C20010   ADDIU V0, S8, 16
9D01D928  24420001   ADDIU V0, V0, 1
9D01D92C  90420000   LBU V0, 0(V0)
9D01D930  3042000F   ANDI V0, V0, 15
9D01D934  304200FF   ANDI V0, V0, 255
1481:                }//end GetCLKOUT
9D01D938  03C0E821   ADDU SP, S8, ZERO
9D01D93C  8FBF001C   LW RA, 28(SP)
9D01D940  8FBE0018   LW S8, 24(SP)
9D01D944  27BD0020   ADDIU SP, SP, 32
9D01D948  03E00008   JR RA
9D01D94C  00000000   NOP
1482:                
1483:                
1484:                /******************************************************************************
1485:                 * Function:        void SetRXHashTableEntry(MAC_ADDR DestMACAddr)
1486:                 *
1487:                 * PreCondition:    SPI/PSP interface must be initialized (done in MACInit()).
1488:                 *
1489:                 * Input:           DestMACAddr: 6 byte group destination MAC address to allow 
1490:                 *								 through the Hash Table Filter.  If DestMACAddr 
1491:                 *								 is set to 00-00-00-00-00-00, then the hash 
1492:                 *								 table will be cleared of all entries and the 
1493:                 *								 filter will be disabled.
1494:                 *
1495:                 * Output:          Sets the appropriate bit in the EHT* registers to allow 
1496:                 *					packets sent to DestMACAddr to be received and enables the 
1497:                 *					Hash Table receive filter (if not already).
1498:                 *
1499:                 * Side Effects:    None
1500:                 *
1501:                 * Overview:        Calculates a CRC-32 using polynomial 0x4C11DB7 and then, 
1502:                 *					using bits 28:23 of the CRC, sets the appropriate bit in 
1503:                 *					the EHT1-EHT4 registers.
1504:                 *
1505:                 * Note:            This code is commented out to save code space on systems 
1506:                 *					that do not need this function.  Change the 
1507:                 *					"#if STACK_USE_ZEROCONF_MDNS_SD" line to "#if 1" to 
1508:                 *					uncomment it, assuming you aren't using the Zeroconf module, 
1509:                 *					which requires mutlicast support and enables this function 
1510:                 *					automatically.
1511:                 *
1512:                 *					There is no way to individually unset destination MAC 
1513:                 *					addresses from the hash table since it is possible to have 
1514:                 *					a hash collision and therefore multiple MAC addresses 
1515:                 *					relying on the same hash table bit.  The stack would have 
1516:                 *					to individually store each 6 byte MAC address to support 
1517:                 *					this feature, which would waste a lot of RAM and be 
1518:                 *					unnecessary in most applications.  As a simple compromise, 
1519:                 *					you can call SetRXHashTableEntry() using a 
1520:                 *					00-00-00-00-00-00 destination MAC address, which will clear 
1521:                 *					the entire hash table and disable the hash table filter.  
1522:                 *					This will allow you to then re-add the necessary 
1523:                 *					destination address(es).
1524:                 *****************************************************************************/
1525:                #if defined(STACK_USE_ZEROCONF_MDNS_SD)
1526:                void SetRXHashTableEntry(MAC_ADDR DestMACAddr)
1527:                {
1528:                	DWORD_VAL CRC = {0xFFFFFFFF};
1529:                	WORD HTRegister;
1530:                	BYTE i, j;
1531:                
1532:                	// Clear the Hash Table bits and disable the Hash Table Filter if a special 
1533:                	// 00-00-00-00-00-00 destination MAC address is provided.
1534:                	if((DestMACAddr.v[0] | DestMACAddr.v[1] | DestMACAddr.v[2] | DestMACAddr.v[3] | DestMACAddr.v[4] | DestMACAddr.v[5]) == 0x00u)
1535:                	{
1536:                		// Disable the Hash Table receive filter and clear the hash table
1537:                		BFCReg(ERXFCON, ERXFCON_HTEN);
1538:                		WriteReg(EHT1, 0x0000);
1539:                		WriteReg(EHT2, 0x0000);
1540:                		WriteReg(EHT3, 0x0000);
1541:                		WriteReg(EHT4, 0x0000);
1542:                
1543:                		return;
1544:                	}
1545:                
1546:                
1547:                	// Calculate a CRC-32 over the 6 byte MAC address 
1548:                	// using polynomial 0x4C11DB7
1549:                	for(i = 0; i < sizeof(MAC_ADDR); i++)
1550:                	{
1551:                		BYTE  crcnext;
1552:                	
1553:                		// shift in 8 bits
1554:                		for(j = 0; j < 8; j++)
1555:                		{
1556:                			crcnext = 0;
1557:                			if(((BYTE_VAL*)&(CRC.v[3]))->bits.b7)
1558:                				crcnext = 1;
1559:                			crcnext ^= (((BYTE_VAL*)&DestMACAddr.v[i])->bits.b0);
1560:                	
1561:                			CRC.Val <<= 1;
1562:                			if(crcnext)
1563:                				CRC.Val ^= 0x4C11DB7;
1564:                			// next bit
1565:                			DestMACAddr.v[i] >>= 1;
1566:                		}
1567:                	}
1568:                	
1569:                	// CRC-32 calculated, now extract bits 28:23
1570:                	// Bits 25:23 define where within the Hash Table byte the bit needs to be set
1571:                	// Bits 28:26 define which of the 8 Hash Table bytes that bits 25:23 apply to
1572:                	i = CRC.v[3] & 0x1F;
1573:                	HTRegister = (i >> 2) + EHT1;
1574:                	i = (i << 1) & 0x06;
1575:                	((BYTE_VAL*)&i)->bits.b0 = ((BYTE_VAL*)&CRC.v[2])->bits.b7;
1576:                	
1577:                	// Set the proper bit in the Hash Table
1578:                	BFSReg(HTRegister, 1<<i);
1579:                	
1580:                	// Ensure that the Hash Table receive filter is enabled
1581:                	BFSReg(ERXFCON, ERXFCON_HTEN);
1582:                }
1583:                #endif
1584:                
1585:                /******************************************************************************
1586:                 * Function:        static void SendSystemReset(void)
1587:                 *
1588:                 * PreCondition:    SPI or PSP bus must be initialized (done in MACInit()).
1589:                 *
1590:                 * Input:           None
1591:                 *
1592:                 * Output:          None
1593:                 *
1594:                 * Side Effects:    None
1595:                 *
1596:                 * Overview:        SendSystemReset reliably resets the Ethernet controller.  
1597:                 *					It resets all register contents (except for COCON bits of 
1598:                 *					ECON2) and returns the device to the power on default state.
1599:                 *					This function should be called instead of directly 
1600:                 *					attempting to perform a reset via the ECON2<ETHRST> bit.  
1601:                 *					If using the PSP, SendSystemReset also does basic checks to 
1602:                 *					look for unsoldered pins or solder bridges on the PSP pins.
1603:                 *
1604:                 * Note:            This function is a blocking function and will lock up the 
1605:                 *					application if a non-recoverable problem is present.  
1606:                 *					Possible non-recoverable problems include:
1607:                 *						- SPI module not configured correctly
1608:                 *						- PMP module not configured correctly
1609:                 *						- HardwareProfile pins not defined correctly
1610:                 *						- Solder bridge on SPI/PSP/PMP lines
1611:                 *						- Unsoldered pins on SPI/PSP/PMP lines
1612:                 *						- 25MHz Ethernet oscillator not running
1613:                 *						- Vdd lower than ENCX24J600 operating range
1614:                 *						- I/O levels out of range (for example if the PIC is at 
1615:                 *						  2V without level shifting)
1616:                 *						- Bus contention on SPI/PSP/PMP lines with other slaves
1617:                 *						- One or more Vdd or Vss pins are not connected.
1618:                 *****************************************************************************/
1619:                static void SendSystemReset(void)
1620:                {
9D01D950  27BDFFE8   ADDIU SP, SP, -24
9D01D954  AFBF0014   SW RA, 20(SP)
9D01D958  AFBE0010   SW S8, 16(SP)
9D01D95C  03A0F021   ADDU S8, SP, ZERO
1621:                	// Power cycle the ENCx24J600 device, if any sort of POR pin is defined
1622:                	#if defined(ENC100_POR_IO)
1623:                		ENC100_POR_IO = 0;
9D01D960  3C03BF88   LUI V1, -16504
9D01D964  8C626160   LW V0, 24928(V1)
9D01D968  7C026B44   INS V0, ZERO, 13, 1
9D01D96C  AC626160   SW V0, 24928(V1)
1624:                		ENC100_POR_TRIS = 0;
9D01D970  3C03BF88   LUI V1, -16504
9D01D974  8C626140   LW V0, 24896(V1)
9D01D978  7C026B44   INS V0, ZERO, 13, 1
9D01D97C  AC626140   SW V0, 24896(V1)
1625:                		DelayMs(2);
9D01D980  24040002   ADDIU A0, ZERO, 2
9D01D984  0F40D68D   JAL DelayMs
9D01D988  00000000   NOP
1626:                
1627:                		// If the INT/SPISEL signal is connected, force it to the correct state 
1628:                		// for latching SPI or PSP mode.
1629:                		#if defined(ENC100_INT_TRIS)	
1630:                			#if ENC100_INTERFACE_MODE == 0	// SPI
1631:                				ENC100_INT_IO = 1;
9D01D98C  3C03BF88   LUI V1, -16504
9D01D990  8C626110   LW V0, 24848(V1)
9D01D994  24040001   ADDIU A0, ZERO, 1
9D01D998  7C824A44   INS V0, A0, 9, 1
9D01D99C  AC626110   SW V0, 24848(V1)
1632:                			#else	// PSP
1633:                				ENC100_INT_IO = 0;
1634:                			#endif
1635:                			ENC100_INT_TRIS = 0;
9D01D9A0  3C03BF88   LUI V1, -16504
9D01D9A4  8C626100   LW V0, 24832(V1)
9D01D9A8  7C024A44   INS V0, ZERO, 9, 1
9D01D9AC  AC626100   SW V0, 24832(V1)
1636:                		#endif
1637:                
1638:                		// Turn on power and wait for interface latching to occur
1639:                		ENC100_POR_IO = 1;
9D01D9B0  3C03BF88   LUI V1, -16504
9D01D9B4  8C626160   LW V0, 24928(V1)
9D01D9B8  24040001   ADDIU A0, ZERO, 1
9D01D9BC  7C826B44   INS V0, A0, 13, 1
9D01D9C0  AC626160   SW V0, 24928(V1)
1640:                		vCurrentBank = 0;
9D01D9C4  A3808100   SB ZERO, -32512(GP)
1641:                		Delay10us(40);
9D01D9C8  24040028   ADDIU A0, ZERO, 40
9D01D9CC  0F40D69D   JAL Delay10us
9D01D9D0  00000000   NOP
1642:                		
1643:                		// Tri-state interrupt GPIO so that we don't cause bus contention.
1644:                		#if defined(ENC100_INT_TRIS)
1645:                			ENC100_INT_TRIS = 1;
9D01D9D4  3C03BF88   LUI V1, -16504
9D01D9D8  8C626100   LW V0, 24832(V1)
9D01D9DC  24040001   ADDIU A0, ZERO, 1
9D01D9E0  7C824A44   INS V0, A0, 9, 1
9D01D9E4  AC626100   SW V0, 24832(V1)
1646:                		#endif
1647:                	#endif
1648:                	
1649:                	// Perform a reset via the SPI/PSP interface
1650:                	do
1651:                	{
1652:                		// Set and clear a few bits that clears themselves upon reset.  
1653:                		// If EUDAST cannot be written to and your code gets stuck in this 
1654:                		// loop, you have a hardware problem of some sort (SPI or PMP not 
1655:                		// initialized correctly, I/O pins aren't connected or are 
1656:                		// shorted to something, power isn't available, etc.)
1657:                		do
1658:                		{
1659:                			WriteReg(EUDAST, 0x1234);
9D01D9E8  24040016   ADDIU A0, ZERO, 22
9D01D9EC  24051234   ADDIU A1, ZERO, 4660
9D01D9F0  0F40792D   JAL 0x9D01E4B4
9D01D9F4  00000000   NOP
1660:                		} while(ReadReg(EUDAST) != 0x1234u);
9D01D9F8  24040016   ADDIU A0, ZERO, 22
9D01D9FC  0F4078D5   JAL 0x9D01E354
9D01DA00  00000000   NOP
9D01DA04  00401821   ADDU V1, V0, ZERO
9D01DA08  24021234   ADDIU V0, ZERO, 4660
9D01DA0C  1462FFF6   BNE V1, V0, 0x9D01D9E8
9D01DA10  00000000   NOP
1661:                
1662:                		// Issue a reset and wait for it to complete
1663:                		BFSReg(ECON2, ECON2_ETHRST);
9D01DA14  2404006E   ADDIU A0, ZERO, 110
9D01DA18  24050010   ADDIU A1, ZERO, 16
9D01DA1C  0F40798D   JAL 0x9D01E634
9D01DA20  00000000   NOP
1664:                		vCurrentBank = 0;
9D01DA24  A3808100   SB ZERO, -32512(GP)
1665:                		while((ReadReg(ESTAT) & (ESTAT_CLKRDY | ESTAT_RSTDONE | ESTAT_PHYRDY)) != (ESTAT_CLKRDY | ESTAT_RSTDONE | ESTAT_PHYRDY));
9D01DA28  00000000   NOP
9D01DA2C  2404001A   ADDIU A0, ZERO, 26
9D01DA30  0F4078D5   JAL 0x9D01E354
9D01DA34  00000000   NOP
9D01DA38  30431A00   ANDI V1, V0, 6656
9D01DA3C  24021A00   ADDIU V0, ZERO, 6656
9D01DA40  1462FFFA   BNE V1, V0, 0x9D01DA2C
9D01DA44  00000000   NOP
1666:                		Delay10us(3);
9D01DA48  24040003   ADDIU A0, ZERO, 3
9D01DA4C  0F40D69D   JAL Delay10us
9D01DA50  00000000   NOP
1667:                
1668:                		// Check to see if the reset operation was successful by 
1669:                		// checking if EUDAST went back to its reset default.  This test 
1670:                		// should always pass, but certain special conditions might make 
1671:                		// this test fail, such as a PSP pin shorted to logic high.
1672:                	} while(ReadReg(EUDAST) != 0x0000u);
9D01DA54  24040016   ADDIU A0, ZERO, 22
9D01DA58  0F4078D5   JAL 0x9D01E354
9D01DA5C  00000000   NOP
9D01DA60  1440FFE1   BNE V0, ZERO, 0x9D01D9E8
9D01DA64  00000000   NOP
1673:                	
1674:                	
1675:                	// Really ensure reset is done and give some time for power to be stable
1676:                	DelayMs(1);
9D01DA68  24040001   ADDIU A0, ZERO, 1
9D01DA6C  0F40D68D   JAL DelayMs
9D01DA70  00000000   NOP
1677:                
1678:                
1679:                	// If using PSP, verify all address and data lines are working
1680:                	#if (ENC100_INTERFACE_MODE >= 1) && (ENC100_INTERFACE_MODE < 9) && defined(ENC100_PSP_USE_INDIRECT_RAM_ADDRESSING)
1681:                	{
1682:                		BYTE i;
1683:                		WORD wTestWriteData, wTestReadData;
1684:                		
1685:                		// If we have a PSP interface, but are using indirect addressing, we 
1686:                		// can't use the ReadMemory()/WriteMemory() functions directly to access 
1687:                		// RAM.  Instead, lets do a simple test to verify all data lines only.
1688:                		
1689:                		// Check marching zero data pattern, then marching one data pattern
1690:                		wTestWriteData = 0xFFFE;
1691:                		for(i = 0; i < 34u; i++)
1692:                		{
1693:                			WriteReg(EHT1, wTestWriteData);
1694:                			wTestReadData = ReadReg(EHT1);
1695:                			
1696:                			// See if the data matches.  If your application gets stuck here, 
1697:                			// it means you have a hardware failure.  Check all of your PSP 
1698:                			// address and data lines.
1699:                			if(wTestWriteData != wTestReadData)
1700:                				while(1);
1701:                			
1702:                			// March the data over left by one bit
1703:                			wTestWriteData <<= 1;
1704:                			if(i == 16u)
1705:                				wTestWriteData = 0x0001;
1706:                			else if(i < 16u)
1707:                				wTestWriteData |= 0x0001;
1708:                		}	
1709:                	}
1710:                	#elif (ENC100_INTERFACE_MODE >= 1) // Parallel direct addressing
1711:                	{
1712:                		WORD w;
1713:                		WORD wTestWriteData, wTestReadData;
1714:                		
1715:                		// Initialize RAM contents with a random pattern and read back to verify
1716:                		// This step is critical if using a PSP interface since some functionality 
1717:                		// may appear to work while a solder bridge or disconnect will cause 
1718:                		// certain memory ranges to fail.
1719:                
1720:                		// Generate and write random pattern
1721:                		LFSRSeedRand(600);
1722:                		for(w = 0; w < ENC100_RAM_SIZE; w += sizeof(wTestWriteData))
1723:                		{
1724:                			wTestWriteData = LFSRRand();
1725:                			WriteMemory(w, (BYTE*)&wTestWriteData, sizeof(wTestWriteData));
1726:                			ReadMemory(w, (BYTE*)&wTestReadData, sizeof(wTestReadData));
1727:                			
1728:                			// See if the data matches.  If your application gets stuck here, 
1729:                			// it means you have a hardware failure.  Check all of your PSP 
1730:                			// address and data lines.
1731:                			if(wTestWriteData != wTestReadData)
1732:                				while(1);
1733:                		}
1734:                		
1735:                		// Read back and verify random pattern
1736:                		LFSRSeedRand(600);
1737:                		for(w = 0; w < ENC100_RAM_SIZE; w += sizeof(wTestWriteData))
1738:                		{
1739:                			wTestWriteData = LFSRRand();
1740:                			ReadMemory(w, (BYTE*)&wTestReadData, sizeof(wTestReadData));
1741:                			
1742:                			// See if the data matches.  If your application gets stuck here, 
1743:                			// it means you have a hardware failure.  Check all of your PSP 
1744:                			// address and data lines.
1745:                			if(wTestWriteData != wTestReadData)
1746:                				while(1);
1747:                		}
1748:                	}
1749:                	#endif
1750:                	
1751:                }//end SendSystemReset
9D01DA74  03C0E821   ADDU SP, S8, ZERO
9D01DA78  8FBF0014   LW RA, 20(SP)
9D01DA7C  8FBE0010   LW S8, 16(SP)
9D01DA80  27BD0018   ADDIU SP, SP, 24
9D01DA84  03E00008   JR RA
9D01DA88  00000000   NOP
1752:                
1753:                
1754:                #if ENC100_INTERFACE_MODE	// WriteMemory() is not currently needed in SPI mode
1755:                /******************************************************************************
1756:                 * Function:        void WriteMemory(WORD wAddress, BYTE *vData, WORD wLength)
1757:                 *
1758:                 * PreCondition:    None
1759:                 *
1760:                 * Input:           wAddress: ENCX24J600 RAM or SFR address to write to
1761:                 *					*vData: Pointer to local PIC RAM which needs to be written 
1762:                 *							to the ENCX24J600
1763:                 *					wLength: Number of bytes to copy from vData to wAddress
1764:                 *
1765:                 * Output:          None
1766:                 *
1767:                 * Side Effects:    None
1768:                 *
1769:                 * Overview:        Copys 0 or more bytes to the ENCX24J600 RAM
1770:                 *
1771:                 * Note:            Can be used to access SFRs and ESFRs when using PSP
1772:                 *****************************************************************************/
1773:                void WriteMemory(WORD wAddress, BYTE *vData, WORD wLength)
1774:                {
1775:                	BOOL bISREnabled;
1776:                
1777:                	if(wLength == 0u)
1778:                		return;
1779:                
1780:                	#if defined(ENC100_ISR_ENABLE) && defined(ENC100_INT_TRIS)
1781:                		bISREnabled = ENC100_ISR_ENABLE;
1782:                		ENC100_ISR_ENABLE = 0;
1783:                	#endif
1784:                
1785:                	#if !defined(ENC100_BIT_BANG_PMP) && ((ENC100_INTERFACE_MODE == 1) || (ENC100_INTERFACE_MODE == 2) || (ENC100_INTERFACE_MODE == 5) || (ENC100_INTERFACE_MODE == 6))
1786:                	{
1787:                		ConfigurePMPModule();
1788:                		AssertChipSelect();
1789:                		while(wLength--)
1790:                		{
1791:                			PMADDR = wAddress++;	// NOTE: Performance might be improvable if you use PMP address increment
1792:                			while(PMMODEbits.BUSY);
1793:                			PMDIN1 = *vData++;
1794:                		}
1795:                		while(PMMODEbits.BUSY);
1796:                		DeassertChipSelect();
1797:                		PMCONbits.PMPEN = 0;
1798:                	}
1799:                	#elif !defined(ENC100_BIT_BANG_PMP) && ((ENC100_INTERFACE_MODE == 3) || (ENC100_INTERFACE_MODE == 4) || (ENC100_INTERFACE_MODE == 9) || (ENC100_INTERFACE_MODE == 10))
1800:                	{
1801:                		WORD wWORDAddress;
1802:                		volatile WORD wDummy;
1803:                		
1804:                		wWORDAddress = wAddress>>1;
1805:                		ConfigurePMPModule();
1806:                		AssertChipSelect();
1807:                		if(wAddress & 0x1)		
1808:                		{
1809:                			PMADDR = wWORDAddress++;
1810:                			wDummy = PMDIN1;		// Can't write to a single byte address by itself, so we will do a read-modify-write
1811:                			wLength--;
1812:                			((BYTE*)&wDummy)[1] = *vData++;
1813:                			while(PMMODEbits.BUSY);
1814:                			((BYTE*)&wDummy)[0] = ((BYTE*)&PMDIN1)[0];
1815:                			while(PMMODEbits.BUSY);
1816:                			PMDIN1 = wDummy;
1817:                		}
1818:                		while(wLength >= 2u)
1819:                		{
1820:                			PMADDR = wWORDAddress++;	// NOTE: Performance might be improvable if you use PMP address increment
1821:                			wLength -= 2;
1822:                			((BYTE*)&wDummy)[0] = *vData++;
1823:                			((BYTE*)&wDummy)[1] = *vData++;
1824:                			while(PMMODEbits.BUSY);
1825:                			PMDIN1 = wDummy;
1826:                		}
1827:                		if(wLength)
1828:                		{
1829:                			PMADDR = wWORDAddress;
1830:                			wDummy = PMDIN1;		// Can't write to a single byte address by itself, so we will do a read-modify-write
1831:                			((BYTE*)&wDummy)[0] = *vData++;
1832:                			while(PMMODEbits.BUSY);
1833:                			((BYTE*)&wDummy)[1] = ((BYTE*)&PMDIN1)[1];
1834:                			while(PMMODEbits.BUSY);
1835:                			PMDIN1 = wDummy;
1836:                		}		
1837:                		while(PMMODEbits.BUSY);
1838:                		DeassertChipSelect();
1839:                		PMCONbits.PMPEN = 0;
1840:                	}
1841:                	#elif ENC100_INTERFACE_MODE == 1
1842:                		ENC100_SET_ADDR_TRIS_OUT();
1843:                		ENC100_SET_AD_TRIS_OUT();
1844:                		AssertChipSelect();
1845:                		while(wLength--)
1846:                		{
1847:                			ENC100_SET_ADDR_IO(wAddress++);
1848:                			ENC100_SET_AD_IO(*vData++);
1849:                			ENC100_SO_WR_B0SEL_EN_IO = 1;
1850:                			ENC100_SO_WR_B0SEL_EN_IO = 0;
1851:                		}
1852:                		DeassertChipSelect();
1853:                	#elif ENC100_INTERFACE_MODE == 2
1854:                		ENC100_SET_ADDR_TRIS_OUT();
1855:                		ENC100_SET_AD_TRIS_OUT();
1856:                		AssertChipSelect();
1857:                		ENC100_SI_RD_RW_IO = 0;
1858:                		while(wLength--)
1859:                		{
1860:                			ENC100_SET_ADDR_IO(wAddress++);
1861:                			ENC100_SET_AD_IO(*vData++);
1862:                			ENC100_SO_WR_B0SEL_EN_IO = 1;
1863:                			ENC100_SO_WR_B0SEL_EN_IO = 0;
1864:                		}
1865:                		DeassertChipSelect();
1866:                	#elif ENC100_INTERFACE_MODE == 3
1867:                	{
1868:                		WORD wData;
1869:                		
1870:                		ENC100_SET_ADDR_TRIS_OUT();
1871:                		ENC100_SET_AD_TRIS_OUT();
1872:                		AssertChipSelect();
1873:                		if(wAddress & 0x1)		// Write high byte to odd address, if not WORD aligned
1874:                		{
1875:                			ENC100_SET_ADDR_IO(wAddress>>1);
1876:                			#if 1 // ENC100_WRH_B1SEL_IO == ENC100_SO_WR_B0SEL_EN_IO	// Word writes only -- need to perform read-modify-write
1877:                				ENC100_SET_AD_TRIS_IN();
1878:                				ENC100_SI_RD_RW_IO = 1;
1879:                				DelaySetupHold();
1880:                				((BYTE*)&wData)[0] = ENC100_GET_AD_IOL();
1881:                				ENC100_SI_RD_RW_IO = 0;
1882:                				ENC100_SET_AD_TRIS_OUT();
1883:                			#endif
1884:                			((BYTE*)&wData)[1] = *vData++;
1885:                			ENC100_SET_AD_IO(wData);
1886:                			ENC100_WRH_B1SEL_IO = 1;
1887:                			ENC100_WRH_B1SEL_IO = 0;
1888:                			wAddress++;
1889:                			wLength--;
1890:                		}
1891:                		while(wLength >= 2u)		// Write all possible WORDs
1892:                		{
1893:                			ENC100_SET_ADDR_IO(wAddress>>1);
1894:                			((BYTE*)&wData)[0] = *vData++;
1895:                			((BYTE*)&wData)[1] = *vData++;
1896:                			ENC100_SET_AD_IO(wData);
1897:                			ENC100_SO_WR_B0SEL_EN_IO = 1;
1898:                			ENC100_WRH_B1SEL_IO = 1;
1899:                			ENC100_SO_WR_B0SEL_EN_IO = 0;
1900:                			ENC100_WRH_B1SEL_IO = 0;
1901:                			wAddress += 2;
1902:                			wLength -= 2;
1903:                		}
1904:                		if(wLength)				// Write final byte to low byte address, if needed
1905:                		{
1906:                			ENC100_SET_ADDR_IO(wAddress>>1);
1907:                			#if 1 // ENC100_WRH_B1SEL_IO == ENC100_SO_WR_B0SEL_EN_IO	// Word writes only -- need to perform read-modify-write
1908:                				ENC100_SET_AD_TRIS_IN();
1909:                				ENC100_SI_RD_RW_IO = 1;
1910:                				DelaySetupHold();
1911:                				((BYTE*)&wData)[1] = ENC100_GET_AD_IOH();
1912:                				ENC100_SI_RD_RW_IO = 0;
1913:                				ENC100_SET_AD_TRIS_OUT();
1914:                			#endif
1915:                			((BYTE*)&wData)[0] = *vData++;
1916:                			ENC100_SET_AD_IO(wData);
1917:                			ENC100_SO_WR_B0SEL_EN_IO = 1;
1918:                			ENC100_SO_WR_B0SEL_EN_IO = 0;
1919:                		}
1920:                		DeassertChipSelect();
1921:                	}
1922:                	#elif ENC100_INTERFACE_MODE == 4
1923:                	{
1924:                		WORD wData;
1925:                		
1926:                		ENC100_SET_ADDR_TRIS_OUT();
1927:                		ENC100_SET_AD_TRIS_OUT();
1928:                		AssertChipSelect();
1929:                		ENC100_SI_RD_RW_IO = 0;
1930:                		if(wAddress & 0x1)		// Write high byte to odd address, if not WORD aligned
1931:                		{
1932:                			ENC100_SET_ADDR_IO(wAddress>>1);
1933:                			#if 1 // ENC100_WRH_B1SEL_IO == ENC100_SO_WR_B0SEL_EN_IO	// Word writes only -- need to perform read-modify-write
1934:                				ENC100_SET_AD_TRIS_IN();
1935:                				ENC100_SI_RD_RW_IO = 1;
1936:                				ENC100_SO_WR_B0SEL_EN_IO = 1;
1937:                				DelaySetupHold();
1938:                				((BYTE*)&wData)[0] = ENC100_GET_AD_IOL();
1939:                				ENC100_SO_WR_B0SEL_EN_IO = 0;
1940:                				ENC100_SI_RD_RW_IO = 0;
1941:                				ENC100_SET_AD_TRIS_OUT();
1942:                			#endif
1943:                			((BYTE*)&wData)[1] = *vData++;
1944:                			ENC100_SET_AD_IO(wData);
1945:                			ENC100_WRH_B1SEL_IO = 1;
1946:                			ENC100_WRH_B1SEL_IO = 0;
1947:                			wAddress++;
1948:                			wLength--;
1949:                		}
1950:                		while(wLength >= 2u)		// Write all possible WORDs
1951:                		{
1952:                			ENC100_SET_ADDR_IO(wAddress>>1);
1953:                			((BYTE*)&wData)[0] = *vData++;
1954:                			((BYTE*)&wData)[1] = *vData++;
1955:                			ENC100_SET_AD_IO(wData);
1956:                			ENC100_SO_WR_B0SEL_EN_IO = 1;
1957:                			ENC100_WRH_B1SEL_IO = 1;
1958:                			ENC100_SO_WR_B0SEL_EN_IO = 0;
1959:                			ENC100_WRH_B1SEL_IO = 0;
1960:                			wAddress += 2;
1961:                			wLength -= 2;
1962:                		}
1963:                		if(wLength)				// Write final byte to low byte address, if needed
1964:                		{
1965:                			ENC100_SET_ADDR_IO(wAddress>>1);
1966:                			#if 1 // ENC100_WRH_B1SEL_IO == ENC100_SO_WR_B0SEL_EN_IO	// Word writes only -- need to perform read-modify-write
1967:                				ENC100_SET_AD_TRIS_IN();
1968:                				ENC100_SI_RD_RW_IO = 1;
1969:                				ENC100_SO_WR_B0SEL_EN_IO = 1;
1970:                				DelaySetupHold();
1971:                				((BYTE*)&wData)[1] = ENC100_GET_AD_IOH();
1972:                				ENC100_SO_WR_B0SEL_EN_IO = 0;
1973:                				ENC100_SI_RD_RW_IO = 0;
1974:                				ENC100_SET_AD_TRIS_OUT();
1975:                			#endif
1976:                			((BYTE*)&wData)[0] = *vData++;
1977:                			ENC100_SET_AD_IO(wData);
1978:                			ENC100_SO_WR_B0SEL_EN_IO = 1;
1979:                			ENC100_SO_WR_B0SEL_EN_IO = 0;
1980:                		}
1981:                		DeassertChipSelect();
1982:                	}
1983:                	#elif ENC100_INTERFACE_MODE == 5
1984:                	{
1985:                		ENC100_SET_AD_TRIS_OUT();
1986:                		AssertChipSelect();
1987:                		while(wLength--)
1988:                		{
1989:                			ENC100_SET_AD_IO(wAddress);
1990:                			ENC100_SCK_AL_IO = 1;
1991:                			ENC100_SCK_AL_IO = 0;
1992:                			ENC100_SET_AD_IOL(*vData++);
1993:                			wAddress++;
1994:                			ENC100_SO_WR_B0SEL_EN_IO = 1;
1995:                			ENC100_SO_WR_B0SEL_EN_IO = 0;
1996:                		}
1997:                		DeassertChipSelect();
1998:                	}
1999:                	#elif ENC100_INTERFACE_MODE == 6
2000:                	{
2001:                		ENC100_SET_AD_TRIS_OUT();
2002:                		AssertChipSelect();
2003:                		ENC100_SI_RD_RW_IO = 0;
2004:                		while(wLength--)
2005:                		{
2006:                			ENC100_SET_AD_IO(wAddress);
2007:                			ENC100_SCK_AL_IO = 1;
2008:                			ENC100_SCK_AL_IO = 0;
2009:                			ENC100_SET_AD_IOL(*vData++);
2010:                			wAddress++;
2011:                			ENC100_SO_WR_B0SEL_EN_IO = 1;
2012:                			ENC100_SO_WR_B0SEL_EN_IO = 0;
2013:                		}
2014:                		DeassertChipSelect();
2015:                	}
2016:                	#elif ENC100_INTERFACE_MODE == 9
2017:                	{
2018:                		WORD wData;
2019:                		
2020:                		ENC100_SET_AD_TRIS_OUT();
2021:                		AssertChipSelect();
2022:                		if(wAddress & 0x1)		// Write high byte to odd address, if not WORD aligned
2023:                		{
2024:                			ENC100_SET_AD_IO(wAddress>>1);
2025:                			ENC100_SCK_AL_IO = 1;
2026:                			ENC100_SCK_AL_IO = 0;
2027:                			#if 1 // ENC100_WRH_B1SEL_IO == ENC100_SO_WR_B0SEL_EN_IO	// Word writes only -- need to perform read-modify-write
2028:                				ENC100_SET_AD_TRIS_IN();
2029:                				ENC100_SI_RD_RW_IO = 1;
2030:                				DelaySetupHold();
2031:                				((BYTE*)&wData)[0] = ENC100_GET_AD_IOL();
2032:                				ENC100_SI_RD_RW_IO = 0;
2033:                				ENC100_SET_AD_TRIS_OUT();
2034:                			#endif
2035:                			((BYTE*)&wData)[1] = *vData++;
2036:                			ENC100_SET_AD_IO(wData);
2037:                			ENC100_WRH_B1SEL_IO = 1;
2038:                			wAddress++;
2039:                			wLength--;
2040:                			DelaySetupHold();
2041:                			ENC100_WRH_B1SEL_IO = 0;
2042:                		}
2043:                		while(wLength >= 2u)		// Write all possible WORDs
2044:                		{
2045:                			ENC100_SET_AD_IO(wAddress>>1);
2046:                			ENC100_SCK_AL_IO = 1;
2047:                			ENC100_SCK_AL_IO = 0;
2048:                			((BYTE*)&wData)[0] = *vData++;
2049:                			((BYTE*)&wData)[1] = *vData++;
2050:                			ENC100_SET_AD_IO(wData);
2051:                			ENC100_SO_WR_B0SEL_EN_IO = 1;
2052:                			ENC100_WRH_B1SEL_IO = 1;
2053:                			wAddress += 2;
2054:                			wLength -= 2;
2055:                			DelaySetupHold();
2056:                			ENC100_SO_WR_B0SEL_EN_IO = 0;
2057:                			ENC100_WRH_B1SEL_IO = 0;
2058:                		}
2059:                		if(wLength)				// Write final byte to low byte address, if needed
2060:                		{
2061:                			ENC100_SET_AD_IO(wAddress>>1);
2062:                			ENC100_SCK_AL_IO = 1;
2063:                			ENC100_SCK_AL_IO = 0;
2064:                			#if 1 // ENC100_WRH_B1SEL_IO == ENC100_SO_WR_B0SEL_EN_IO	// Word writes only -- need to perform read-modify-write
2065:                				ENC100_SET_AD_TRIS_IN();
2066:                				ENC100_SI_RD_RW_IO = 1;
2067:                				DelaySetupHold();
2068:                				((BYTE*)&wData)[1] = ENC100_GET_AD_IOH();
2069:                				ENC100_SI_RD_RW_IO = 0;
2070:                				ENC100_SET_AD_TRIS_OUT();
2071:                			#endif
2072:                			((BYTE*)&wData)[0] = *vData++;
2073:                			ENC100_SET_AD_IO(wData);
2074:                			ENC100_SO_WR_B0SEL_EN_IO = 1;
2075:                			DelaySetupHold();
2076:                			ENC100_SO_WR_B0SEL_EN_IO = 0;
2077:                		}
2078:                		DeassertChipSelect();
2079:                	}
2080:                	#elif ENC100_INTERFACE_MODE == 10
2081:                	{
2082:                		WORD wData;
2083:                		
2084:                		ENC100_SET_AD_TRIS_OUT();
2085:                		AssertChipSelect();
2086:                		if(wAddress & 0x1)		// Write high byte to odd address, if not WORD aligned
2087:                		{
2088:                			ENC100_SET_AD_IO(wAddress>>1);
2089:                			ENC100_SCK_AL_IO = 1;
2090:                			ENC100_SCK_AL_IO = 0;
2091:                			#if 1 // ENC100_WRH_B1SEL_IO == ENC100_SO_WR_B0SEL_EN_IO	// Word writes only -- need to perform read-modify-write
2092:                				ENC100_SET_AD_TRIS_IN();
2093:                				ENC100_SI_RD_RW_IO = 1;
2094:                				ENC100_SO_WR_B0SEL_EN_IO = 1;
2095:                				DelaySetupHold();
2096:                				((BYTE*)&wData)[0] = ENC100_GET_AD_IOL();
2097:                				ENC100_SO_WR_B0SEL_EN_IO = 0;
2098:                				ENC100_SET_AD_TRIS_OUT();
2099:                			#endif
2100:                			ENC100_SI_RD_RW_IO = 0;
2101:                			((BYTE*)&wData)[1] = *vData++;
2102:                			ENC100_SET_AD_IO(wData);
2103:                			ENC100_WRH_B1SEL_IO = 1;
2104:                			wAddress++;
2105:                			wLength--;
2106:                			DelaySetupHold();
2107:                			ENC100_WRH_B1SEL_IO = 0;
2108:                		}
2109:                		ENC100_SI_RD_RW_IO = 0;
2110:                		while(wLength >= 2u)		// Write all possible WORDs
2111:                		{
2112:                			ENC100_SET_AD_IO(wAddress>>1);
2113:                			ENC100_SCK_AL_IO = 1;
2114:                			ENC100_SCK_AL_IO = 0;
2115:                			((BYTE*)&wData)[0] = *vData++;
2116:                			((BYTE*)&wData)[1] = *vData++;
2117:                			ENC100_SET_AD_IO(wData);
2118:                			ENC100_SO_WR_B0SEL_EN_IO = 1;
2119:                			ENC100_WRH_B1SEL_IO = 1;
2120:                			wAddress += 2;
2121:                			wLength -= 2;
2122:                			DelaySetupHold();
2123:                			ENC100_SO_WR_B0SEL_EN_IO = 0;
2124:                			ENC100_WRH_B1SEL_IO = 0;
2125:                		}
2126:                		if(wLength)				// Write final byte to low byte address, if needed
2127:                		{
2128:                			ENC100_SET_AD_IO(wAddress>>1);
2129:                			ENC100_SCK_AL_IO = 1;
2130:                			ENC100_SCK_AL_IO = 0;
2131:                			#if 1 // ENC100_WRH_B1SEL_IO == ENC100_SO_WR_B0SEL_EN_IO	// Word writes only -- need to perform read-modify-write
2132:                				ENC100_SET_AD_TRIS_IN();
2133:                				ENC100_SI_RD_RW_IO = 1;
2134:                				ENC100_SO_WR_B0SEL_EN_IO = 1;
2135:                				DelaySetupHold();
2136:                				((BYTE*)&wData)[1] = ENC100_GET_AD_IOH();
2137:                				ENC100_SO_WR_B0SEL_EN_IO = 0;
2138:                				ENC100_SET_AD_TRIS_OUT();
2139:                			#endif
2140:                			ENC100_SI_RD_RW_IO = 0;
2141:                			((BYTE*)&wData)[0] = *vData++;
2142:                			ENC100_SET_AD_IO(wData);
2143:                			ENC100_SO_WR_B0SEL_EN_IO = 1;
2144:                			DelaySetupHold();
2145:                			ENC100_SO_WR_B0SEL_EN_IO = 0;
2146:                		}
2147:                		DeassertChipSelect();
2148:                	}
2149:                	#else	// SPI mode
2150:                	{
2151:                		WORD w;
2152:                
2153:                		// Use RX window
2154:                		w = Execute2(RRXWRPT, 0x0000);
2155:                		Execute2(WRXWRPT, wAddress);
2156:                		WriteN(WBMRX, vData, wLength);
2157:                		Execute2(WRXWRPT, w);
2158:                	}
2159:                	#endif
2160:                
2161:                	#if defined(ENC100_ISR_ENABLE) && defined(ENC100_INT_TRIS)
2162:                		ENC100_ISR_ENABLE = bISREnabled;
2163:                	#endif
2164:                }
2165:                #endif
2166:                
2167:                
2168:                /******************************************************************************
2169:                 * Function:        void WriteMemoryWindow(BYTE vWindow, BYTE *vData, WORD wLength)
2170:                 *
2171:                 * PreCondition:    None
2172:                 *
2173:                 * Input:           vWindow: UDA_WINDOW, GP_WINDOW, or RX_WINDOW corresponding 
2174:                 *							 to the window register to write to
2175:                 *					*vData: Pointer to local PIC RAM which contains the 
2176:                 *							source data
2177:                 *					wLength: Number of bytes to copy from vData to window
2178:                 *
2179:                 * Output:          None
2180:                 *
2181:                 * Side Effects:    None
2182:                 *
2183:                 * Overview:        Copys 0 or more bytes from CPU RAM to the ENCX24J600 
2184:                 *					Family RAM using one of the UDA, TX, or RX write window 
2185:                 *					pointers.  This pointer is incremented by the number of 
2186:                 *					bytes writen.
2187:                 *
2188:                 * Note:            None
2189:                 *****************************************************************************/
2190:                 void WriteMemoryWindow(BYTE vWindow, BYTE *vData, WORD wLength)
2191:                {
9D01DA8C  27BDFFE0   ADDIU SP, SP, -32
9D01DA90  AFBF001C   SW RA, 28(SP)
9D01DA94  AFBE0018   SW S8, 24(SP)
9D01DA98  03A0F021   ADDU S8, SP, ZERO
9D01DA9C  00801821   ADDU V1, A0, ZERO
9D01DAA0  AFC50024   SW A1, 36(S8)
9D01DAA4  00C01021   ADDU V0, A2, ZERO
9D01DAA8  A3C30020   SB V1, 32(S8)
9D01DAAC  A7C20028   SH V0, 40(S8)
2192:                	BOOL bISREnabled;
2193:                
2194:                	#if (ENC100_INTERFACE_MODE >= 1)	// Parallel mode
2195:                		WORD wAddress;
2196:                	#endif
2197:                
2198:                	// If we are in the middle of a SPI/PSP read/write operation, an interrupt 
2199:                	// cannot be immediately processed (which would also require SPI/PSP 
2200:                	// read/write operations).  Therefore, we must disable the Ethernet 
2201:                	// interrupt temporarily to ensure this illegal reentrancy doesn't occur.
2202:                	#if defined(ENC100_ISR_ENABLE) && defined(ENC100_INT_TRIS)
2203:                		bISREnabled = ENC100_ISR_ENABLE;
9D01DAB0  3C02BF88   LUI V0, -16504
9D01DAB4  8C421060   LW V0, 4192(V0)
9D01DAB8  7C4204C0   EXT V0, V0, 19, 1
9D01DABC  304200FF   ANDI V0, V0, 255
9D01DAC0  AFC20014   SW V0, 20(S8)
2204:                		ENC100_ISR_ENABLE = 0;
9D01DAC4  3C03BF88   LUI V1, -16504
9D01DAC8  8C621060   LW V0, 4192(V1)
9D01DACC  7C029CC4   INS V0, ZERO, 19, 1
9D01DAD0  AC621060   SW V0, 4192(V1)
2205:                	#endif
2206:                
2207:                	// Decode the vWindow handle to the litteral SFR address to read/write from/to
2208:                	#if (ENC100_INTERFACE_MODE == 1) || (ENC100_INTERFACE_MODE == 2) || (ENC100_INTERFACE_MODE == 5) || (ENC100_INTERFACE_MODE == 6)
2209:                		wAddress = EUDADATA;
2210:                		if(vWindow & GP_WINDOW)
2211:                			wAddress = EGPDATA;
2212:                		if(vWindow & RX_WINDOW)
2213:                			wAddress = ERXDATA;
2214:                	#elif (ENC100_INTERFACE_MODE == 3) || (ENC100_INTERFACE_MODE == 4) || (ENC100_INTERFACE_MODE == 9) || (ENC100_INTERFACE_MODE == 10)
2215:                		wAddress = (EUDADATA>>1);
2216:                		if(vWindow & GP_WINDOW)
2217:                			wAddress = (EGPDATA>>1);
2218:                		if(vWindow & RX_WINDOW)
2219:                			wAddress = (ERXDATA>>1);
2220:                	#endif
2221:                
2222:                	#if (ENC100_INTERFACE_MODE >= 1) && !defined(ENC100_BIT_BANG_PMP)	// PMP under hardware control
2223:                	{	
2224:                		ConfigurePMPModule();
2225:                		AssertChipSelect();
2226:                		PMADDR = wAddress;
2227:                		while(wLength--)
2228:                		{
2229:                			while(PMMODEbits.BUSY);
2230:                			PMDIN1 = *vData++;
2231:                		}
2232:                		while(PMMODEbits.BUSY);
2233:                		DeassertChipSelect();
2234:                		PMCONbits.PMPEN = 0;
2235:                	}
2236:                	#elif ENC100_INTERFACE_MODE == 1	// Bit bang PMP
2237:                		ENC100_SET_ADDR_TRIS_OUT();
2238:                		ENC100_SET_AD_TRIS_OUT();
2239:                		AssertChipSelect();
2240:                		ENC100_SET_ADDR_IO(wAddress);
2241:                		while(wLength--)
2242:                		{
2243:                			ENC100_SET_AD_IO(*vData++);
2244:                			ENC100_SO_WR_B0SEL_EN_IO = 1;
2245:                			ENC100_SO_WR_B0SEL_EN_IO = 0;
2246:                		}
2247:                		DeassertChipSelect();
2248:                	#elif ENC100_INTERFACE_MODE == 2		// Bit bang PMP
2249:                		ENC100_SET_ADDR_TRIS_OUT();
2250:                		ENC100_SET_AD_TRIS_OUT();
2251:                		AssertChipSelect();
2252:                		ENC100_SI_RD_RW_IO = 0;
2253:                		ENC100_SET_ADDR_IO(wAddress);
2254:                		while(wLength--)
2255:                		{
2256:                			ENC100_SET_AD_IO(*vData++);
2257:                			ENC100_SO_WR_B0SEL_EN_IO = 1;
2258:                			ENC100_SO_WR_B0SEL_EN_IO = 0;
2259:                		}
2260:                		DeassertChipSelect();
2261:                	#elif ENC100_INTERFACE_MODE == 3		// Bit bang PMP
2262:                	{
2263:                		ENC100_SET_ADDR_TRIS_OUT();
2264:                		ENC100_SET_AD_TRIS_OUT();
2265:                		AssertChipSelect();
2266:                		ENC100_SET_ADDR_IO(wAddress);
2267:                		while(wLength--)
2268:                		{
2269:                			ENC100_SET_AD_IOL(*vData++);
2270:                			ENC100_SO_WR_B0SEL_EN_IO = 1;
2271:                			ENC100_SO_WR_B0SEL_EN_IO = 0;
2272:                		}
2273:                		DeassertChipSelect();
2274:                	}
2275:                	#elif ENC100_INTERFACE_MODE == 4		// Bit bang PMP
2276:                	{
2277:                		ENC100_SET_ADDR_TRIS_OUT();
2278:                		ENC100_SET_AD_TRIS_OUT();
2279:                		AssertChipSelect();
2280:                		ENC100_SI_RD_RW_IO = 0;
2281:                		ENC100_SET_ADDR_IO(wAddress);
2282:                		while(wLength--)
2283:                		{
2284:                			ENC100_SET_AD_IOL(*vData++);
2285:                			ENC100_SO_WR_B0SEL_EN_IO = 1;
2286:                			ENC100_SO_WR_B0SEL_EN_IO = 0;
2287:                		}
2288:                		DeassertChipSelect();
2289:                	}
2290:                	#elif ENC100_INTERFACE_MODE == 5		// Bit bang PMP
2291:                	{
2292:                		ENC100_SET_AD_TRIS_OUT();
2293:                		AssertChipSelect();
2294:                		ENC100_SET_AD_IO(wAddress);
2295:                		ENC100_SCK_AL_IO = 1;
2296:                		ENC100_SCK_AL_IO = 0;
2297:                		while(wLength--)
2298:                		{
2299:                			ENC100_SET_AD_IO(*vData++);
2300:                			ENC100_SO_WR_B0SEL_EN_IO = 1;
2301:                			ENC100_SO_WR_B0SEL_EN_IO = 0;
2302:                		}
2303:                		DeassertChipSelect();
2304:                	}
2305:                	#elif ENC100_INTERFACE_MODE == 6		// Bit bang PMP
2306:                	{
2307:                		ENC100_SET_AD_TRIS_OUT();
2308:                		AssertChipSelect();
2309:                		ENC100_SI_RD_RW_IO = 0;
2310:                		ENC100_SET_AD_IO(wAddress);
2311:                		ENC100_SCK_AL_IO = 1;
2312:                		ENC100_SCK_AL_IO = 0;
2313:                		while(wLength--)
2314:                		{
2315:                			ENC100_SET_AD_IO(*vData++);
2316:                			ENC100_SO_WR_B0SEL_EN_IO = 1;
2317:                			ENC100_SO_WR_B0SEL_EN_IO = 0;
2318:                		}
2319:                		DeassertChipSelect();
2320:                	}
2321:                	#elif ENC100_INTERFACE_MODE == 9		// Bit bang PMP
2322:                	{
2323:                		ENC100_SET_AD_TRIS_OUT();
2324:                		AssertChipSelect();
2325:                		ENC100_SET_AD_IO(wAddress);
2326:                		ENC100_SCK_AL_IO = 1;
2327:                		ENC100_SCK_AL_IO = 0;
2328:                		while(wLength--)
2329:                		{
2330:                			ENC100_SET_AD_IOL(*vData++);
2331:                			ENC100_SO_WR_B0SEL_EN_IO = 1;
2332:                			DelaySetupHold();
2333:                			ENC100_SO_WR_B0SEL_EN_IO = 0;
2334:                		}
2335:                		DeassertChipSelect();
2336:                	}
2337:                	#elif ENC100_INTERFACE_MODE == 10		// Bit bang PMP
2338:                	{
2339:                		ENC100_SET_AD_TRIS_OUT();
2340:                		AssertChipSelect();
2341:                		ENC100_SI_RD_RW_IO = 0;
2342:                		ENC100_SET_AD_IO(wAddress);
2343:                		ENC100_SCK_AL_IO = 1;
2344:                		ENC100_SCK_AL_IO = 0;
2345:                		while(wLength--)
2346:                		{
2347:                			ENC100_SET_AD_IOL(*vData++);
2348:                			ENC100_SO_WR_B0SEL_EN_IO = 1;
2349:                			DelaySetupHold();
2350:                			ENC100_SO_WR_B0SEL_EN_IO = 0;
2351:                		}
2352:                		DeassertChipSelect();
2353:                	}
2354:                	#else	// SPI mode
2355:                	{
2356:                		BYTE vOpcode;
2357:                
2358:                		vOpcode = WBMUDA;
9D01DAD4  24020032   ADDIU V0, ZERO, 50
9D01DAD8  A3C20010   SB V0, 16(S8)
2359:                		if(vWindow & GP_WINDOW)
9D01DADC  93C20020   LBU V0, 32(S8)
9D01DAE0  30420002   ANDI V0, V0, 2
9D01DAE4  10400003   BEQ V0, ZERO, 0x9D01DAF4
9D01DAE8  00000000   NOP
2360:                			vOpcode = WBMGP;
9D01DAEC  2402002A   ADDIU V0, ZERO, 42
9D01DAF0  A3C20010   SB V0, 16(S8)
2361:                		if(vWindow & RX_WINDOW)
9D01DAF4  93C20020   LBU V0, 32(S8)
9D01DAF8  30420004   ANDI V0, V0, 4
9D01DAFC  10400003   BEQ V0, ZERO, 0x9D01DB0C
9D01DB00  00000000   NOP
2362:                			vOpcode = WBMRX;
9D01DB04  2402002E   ADDIU V0, ZERO, 46
9D01DB08  A3C20010   SB V0, 16(S8)
2363:                
2364:                		WriteN(vOpcode, vData, wLength);
9D01DB0C  93C30010   LBU V1, 16(S8)
9D01DB10  97C20028   LHU V0, 40(S8)
9D01DB14  00602021   ADDU A0, V1, ZERO
9D01DB18  8FC50024   LW A1, 36(S8)
9D01DB1C  00403021   ADDU A2, V0, ZERO
9D01DB20  0F40787D   JAL 0x9D01E1F4
9D01DB24  00000000   NOP
2365:                	}
2366:                	#endif
2367:                
2368:                	#if defined(ENC100_ISR_ENABLE) && defined(ENC100_INT_TRIS)
2369:                		ENC100_ISR_ENABLE = bISREnabled;
9D01DB28  8FC20014   LW V0, 20(S8)
9D01DB2C  304200FF   ANDI V0, V0, 255
9D01DB30  30420001   ANDI V0, V0, 1
9D01DB34  304400FF   ANDI A0, V0, 255
9D01DB38  3C03BF88   LUI V1, -16504
9D01DB3C  8C621060   LW V0, 4192(V1)
9D01DB40  7C829CC4   INS V0, A0, 19, 1
9D01DB44  AC621060   SW V0, 4192(V1)
2370:                	#endif
2371:                }
9D01DB48  03C0E821   ADDU SP, S8, ZERO
9D01DB4C  8FBF001C   LW RA, 28(SP)
9D01DB50  8FBE0018   LW S8, 24(SP)
9D01DB54  27BD0020   ADDIU SP, SP, 32
9D01DB58  03E00008   JR RA
9D01DB5C  00000000   NOP
2372:                
2373:                
2374:                #if ENC100_INTERFACE_MODE	// ReadMemory() is not currently needed in SPI mode
2375:                /******************************************************************************
2376:                 * Function:        void ReadMemory(WORD wAddress, BYTE *vData, WORD wLength)
2377:                 *
2378:                 * PreCondition:    None
2379:                 *
2380:                 * Input:           wAddress: ENCX24J600 RAM or SFR address to read from
2381:                 *					*vData: Pointer to local PIC RAM which will be written 
2382:                 *							with data from the ENCX24J600.
2383:                 *					wLength: Number of bytes to copy from wAddress to vData
2384:                 *
2385:                 * Output:          None
2386:                 *
2387:                 * Side Effects:    None
2388:                 *
2389:                 * Overview:        Copys 0 or more bytes from the ENCX24J600 RAM
2390:                 *
2391:                 * Note:            Can be used to access SFRs and ESFRs when using PSP
2392:                 *****************************************************************************/
2393:                void ReadMemory(WORD wAddress, BYTE *vData, WORD wLength)
2394:                {
2395:                	BOOL bISREnabled;
2396:                	
2397:                	if(wLength == 0u)
2398:                		return;
2399:                
2400:                	#if defined(ENC100_ISR_ENABLE) && defined(ENC100_INT_TRIS)
2401:                		bISREnabled = ENC100_ISR_ENABLE;
2402:                		ENC100_ISR_ENABLE = 0;
2403:                	#endif
2404:                
2405:                	#if !defined(ENC100_BIT_BANG_PMP) && ((ENC100_INTERFACE_MODE == 1) || (ENC100_INTERFACE_MODE == 2) || (ENC100_INTERFACE_MODE == 5) || (ENC100_INTERFACE_MODE == 6))
2406:                	{
2407:                		volatile BYTE vDummy;
2408:                
2409:                		ConfigurePMPModule();
2410:                		AssertChipSelect();
2411:                		PMADDR = wAddress++;
2412:                		vDummy = PMDIN1;
2413:                		while(--wLength)
2414:                		{
2415:                			PMADDR = wAddress++;
2416:                			while(PMMODEbits.BUSY);
2417:                			*vData++ = PMDIN1;
2418:                		}
2419:                		while(PMMODEbits.BUSY);
2420:                		DeassertChipSelect();
2421:                		*vData = PMDIN1;
2422:                		PMCONbits.PMPEN = 0;
2423:                	}
2424:                	#elif !defined(ENC100_BIT_BANG_PMP) && ((ENC100_INTERFACE_MODE == 3) || (ENC100_INTERFACE_MODE == 4) || (ENC100_INTERFACE_MODE == 9) || (ENC100_INTERFACE_MODE == 10))
2425:                	{
2426:                		WORD wWORDAddress;
2427:                		volatile WORD wDummy;
2428:                	
2429:                		wWORDAddress = wAddress>>1;
2430:                		ConfigurePMPModule();
2431:                		AssertChipSelect();
2432:                		PMADDR = wWORDAddress++;
2433:                		wDummy = PMDIN1;
2434:                		if(wAddress & 0x1)
2435:                		{
2436:                			PMADDR = wWORDAddress++;
2437:                			wLength--;
2438:                			while(PMMODEbits.BUSY);
2439:                			*vData++ = ((BYTE*)&PMDIN1)[1];
2440:                		}
2441:                		while(wLength >= 2)
2442:                		{
2443:                			PMADDR = wWORDAddress++;
2444:                			wLength -= 2;
2445:                			while(PMMODEbits.BUSY);
2446:                			wDummy = PMDIN1;
2447:                			*vData++ = ((BYTE*)&wDummy)[0];
2448:                			*vData++ = ((BYTE*)&wDummy)[1];
2449:                		}
2450:                		if(wLength)
2451:                		{
2452:                			while(PMMODEbits.BUSY);
2453:                			*vData = ((BYTE*)&PMDIN1)[0];
2454:                		}
2455:                		DeassertChipSelect();
2456:                		PMCONbits.PMPEN = 0;
2457:                	}
2458:                	#elif ENC100_INTERFACE_MODE == 1
2459:                		ENC100_SET_ADDR_TRIS_OUT();
2460:                		ENC100_SET_AD_TRIS_IN();
2461:                		AssertChipSelect();
2462:                		while(wLength--)
2463:                		{
2464:                			ENC100_SET_ADDR_IO(wAddress);
2465:                			ENC100_SI_RD_RW_IO = 1;
2466:                			wAddress++;
2467:                			DelaySetupHold();
2468:                			*vData++ = ENC100_GET_AD_IO();
2469:                			ENC100_SI_RD_RW_IO = 0;
2470:                		}
2471:                		DeassertChipSelect();
2472:                		
2473:                	#elif ENC100_INTERFACE_MODE == 2
2474:                		ENC100_SET_ADDR_TRIS_OUT();
2475:                		ENC100_SET_AD_TRIS_IN();
2476:                		AssertChipSelect();
2477:                		ENC100_SI_RD_RW_IO = 1;
2478:                		while(wLength--)
2479:                		{
2480:                			ENC100_SET_ADDR_IO(wAddress);
2481:                			ENC100_SO_WR_B0SEL_EN_IO = 1;
2482:                			wAddress++;
2483:                			DelaySetupHold();
2484:                			*vData++ = ENC100_GET_AD_IO();
2485:                			ENC100_SO_WR_B0SEL_EN_IO = 0;
2486:                		}
2487:                		DeassertChipSelect();
2488:                		
2489:                	#elif ENC100_INTERFACE_MODE == 3
2490:                		ENC100_SET_ADDR_TRIS_OUT();
2491:                		ENC100_SET_AD_TRIS_IN();
2492:                		AssertChipSelect();
2493:                		if(wAddress & 0x1)		// Read from high byte if not WORD aligned
2494:                		{
2495:                			ENC100_SET_ADDR_IO(wAddress>>1);
2496:                			ENC100_SI_RD_RW_IO = 1;
2497:                			DelaySetupHold();
2498:                			wAddress++;
2499:                			wLength--;
2500:                			*vData++ = ENC100_GET_AD_IOH();
2501:                			ENC100_SI_RD_RW_IO = 0;
2502:                		}
2503:                		while(wLength >= 2u)	// Read all necessary WORDs
2504:                		{
2505:                			ENC100_SET_ADDR_IO(wAddress>>1);
2506:                			ENC100_SI_RD_RW_IO = 1;
2507:                			DelaySetupHold();
2508:                			wLength -= 2;
2509:                			wAddress += 2;
2510:                			*vData++ = ENC100_GET_AD_IOL();
2511:                			*vData++ = ENC100_GET_AD_IOH();
2512:                			ENC100_SI_RD_RW_IO = 0;			
2513:                		}
2514:                		if(wLength)				// Read final low byte, if needed
2515:                		{
2516:                			ENC100_SET_ADDR_IO(wAddress>>1);
2517:                			ENC100_SI_RD_RW_IO = 1;
2518:                			DelaySetupHold();
2519:                			*vData = ENC100_GET_AD_IOL();
2520:                			ENC100_SI_RD_RW_IO = 0;			
2521:                		}
2522:                		DeassertChipSelect();
2523:                		
2524:                	#elif ENC100_INTERFACE_MODE == 4
2525:                		ENC100_SET_ADDR_TRIS_OUT();
2526:                		ENC100_SET_AD_TRIS_IN();
2527:                		AssertChipSelect();
2528:                		ENC100_SI_RD_RW_IO = 1;
2529:                		if(wAddress & 0x1)		// Read from high byte if not WORD aligned
2530:                		{
2531:                			ENC100_SET_ADDR_IO(wAddress>>1);
2532:                			ENC100_SO_WR_B0SEL_EN_IO = 1;
2533:                			DelaySetupHold();
2534:                			wAddress++;
2535:                			wLength--;
2536:                			*vData++ = ENC100_GET_AD_IOH();
2537:                			ENC100_SO_WR_B0SEL_EN_IO = 0;
2538:                		}
2539:                		while(wLength >= 2u)	// Read all necessary WORDs
2540:                		{
2541:                			ENC100_SET_ADDR_IO(wAddress>>1);
2542:                			ENC100_SO_WR_B0SEL_EN_IO = 1;
2543:                			DelaySetupHold();
2544:                			wLength -= 2;
2545:                			wAddress += 2;
2546:                			*vData++ = ENC100_GET_AD_IOL();
2547:                			*vData++ = ENC100_GET_AD_IOH();
2548:                			ENC100_SO_WR_B0SEL_EN_IO = 0;
2549:                		}
2550:                		if(wLength)				// Read final low byte, if needed
2551:                		{
2552:                			ENC100_SET_ADDR_IO(wAddress>>1);
2553:                			ENC100_SO_WR_B0SEL_EN_IO = 1;
2554:                			DelaySetupHold();
2555:                			*vData = ENC100_GET_AD_IOL();
2556:                			ENC100_SO_WR_B0SEL_EN_IO = 0;
2557:                		}
2558:                
2559:                		DeassertChipSelect();
2560:                		
2561:                	#elif ENC100_INTERFACE_MODE == 5
2562:                		AssertChipSelect();
2563:                		while(wLength--)
2564:                		{
2565:                			ENC100_SET_AD_TRIS_OUT();
2566:                			ENC100_SET_AD_IO(wAddress);
2567:                			ENC100_SCK_AL_IO = 1;
2568:                			ENC100_SCK_AL_IO = 0;
2569:                			ENC100_SET_AD_TRIS_IN();
2570:                			ENC100_SI_RD_RW_IO = 1;
2571:                			DelaySetupHold();
2572:                			wAddress++;
2573:                			*vData++ = ENC100_GET_AD_IO();
2574:                			ENC100_SI_RD_RW_IO = 0;		
2575:                		}
2576:                		DeassertChipSelect();
2577:                		
2578:                	#elif ENC100_INTERFACE_MODE == 6
2579:                		AssertChipSelect();
2580:                		ENC100_SI_RD_RW_IO = 1;
2581:                		while(wLength--)
2582:                		{
2583:                			ENC100_SET_AD_TRIS_OUT();
2584:                			ENC100_SET_AD_IO(wAddress);
2585:                			ENC100_SCK_AL_IO = 1;
2586:                			ENC100_SCK_AL_IO = 0;
2587:                			ENC100_SET_AD_TRIS_IN();
2588:                			ENC100_SO_WR_B0SEL_EN_IO = 1;
2589:                			DelaySetupHold();
2590:                			wAddress++;
2591:                			*vData++ = ENC100_GET_AD_IO();
2592:                			ENC100_SO_WR_B0SEL_EN_IO = 0;		
2593:                		}
2594:                		DeassertChipSelect();
2595:                		
2596:                	#elif ENC100_INTERFACE_MODE == 9
2597:                	{
2598:                		AssertChipSelect();
2599:                		if(wAddress & 0x1)		// Read from high byte if not WORD aligned
2600:                		{
2601:                			ENC100_SET_AD_TRIS_OUT();
2602:                			ENC100_SET_AD_IO(wAddress>>1);
2603:                			ENC100_SCK_AL_IO = 1;
2604:                			ENC100_SCK_AL_IO = 0;
2605:                			ENC100_SET_AD_TRIS_IN();
2606:                			ENC100_SI_RD_RW_IO = 1;
2607:                			DelaySetupHold();
2608:                			wAddress++;
2609:                			wLength--;
2610:                			*vData++ = ENC100_GET_AD_IOH();
2611:                			ENC100_SI_RD_RW_IO = 0;			
2612:                		}
2613:                		while(wLength >= 2u)	// Read all necessary WORDs
2614:                		{
2615:                			ENC100_SET_AD_TRIS_OUT();
2616:                			ENC100_SET_AD_IO(wAddress>>1);
2617:                			ENC100_SCK_AL_IO = 1;
2618:                			ENC100_SCK_AL_IO = 0;
2619:                			ENC100_SET_AD_TRIS_IN();
2620:                			ENC100_SI_RD_RW_IO = 1;
2621:                			DelaySetupHold();
2622:                			wAddress += 2;
2623:                			wLength -= 2;
2624:                			*vData++ = ENC100_GET_AD_IOL();
2625:                			*vData++ = ENC100_GET_AD_IOH();
2626:                			ENC100_SI_RD_RW_IO = 0;		
2627:                		}
2628:                		if(wLength)				// Read final low byte, if needed
2629:                		{
2630:                			ENC100_SET_AD_TRIS_OUT();
2631:                			ENC100_SET_AD_IO(wAddress>>1);
2632:                			ENC100_SCK_AL_IO = 1;
2633:                			ENC100_SCK_AL_IO = 0;
2634:                			ENC100_SET_AD_TRIS_IN();
2635:                			ENC100_SI_RD_RW_IO = 1;
2636:                			DelaySetupHold();
2637:                			*vData++ = ENC100_GET_AD_IOL();
2638:                			ENC100_SI_RD_RW_IO = 0;			
2639:                		}
2640:                		DeassertChipSelect();
2641:                	}
2642:                	#elif ENC100_INTERFACE_MODE == 10
2643:                	{
2644:                		AssertChipSelect();
2645:                		ENC100_SI_RD_RW_IO = 1;
2646:                		if(wAddress & 0x1)		// Read from high byte if not WORD aligned
2647:                		{
2648:                			ENC100_SET_AD_TRIS_OUT();
2649:                			ENC100_SET_AD_IO(wAddress>>1);
2650:                			ENC100_SCK_AL_IO = 1;
2651:                			ENC100_SCK_AL_IO = 0;
2652:                			ENC100_SET_AD_TRIS_IN();
2653:                			ENC100_SO_WR_B0SEL_EN_IO = 1;
2654:                			DelaySetupHold();
2655:                			wAddress++;
2656:                			wLength--;
2657:                			*vData++ = ENC100_GET_AD_IOH();
2658:                			ENC100_SO_WR_B0SEL_EN_IO = 0;			
2659:                		}
2660:                		while(wLength >= 2u)	// Read all necessary WORDs
2661:                		{
2662:                			ENC100_SET_AD_TRIS_OUT();
2663:                			ENC100_SET_AD_IO(wAddress>>1);
2664:                			ENC100_SCK_AL_IO = 1;
2665:                			ENC100_SCK_AL_IO = 0;
2666:                			ENC100_SET_AD_TRIS_IN();
2667:                			ENC100_SO_WR_B0SEL_EN_IO = 1;
2668:                			DelaySetupHold();
2669:                			wAddress += 2;
2670:                			wLength -= 2;
2671:                			*vData++ = ENC100_GET_AD_IOL();
2672:                			*vData++ = ENC100_GET_AD_IOH();
2673:                			ENC100_SO_WR_B0SEL_EN_IO = 0;		
2674:                		}
2675:                		if(wLength)				// Read final low byte, if needed
2676:                		{
2677:                			ENC100_SET_AD_TRIS_OUT();
2678:                			ENC100_SET_AD_IO(wAddress>>1);
2679:                			ENC100_SCK_AL_IO = 1;
2680:                			ENC100_SCK_AL_IO = 0;
2681:                			ENC100_SET_AD_TRIS_IN();
2682:                			ENC100_SO_WR_B0SEL_EN_IO = 1;
2683:                			DelaySetupHold();
2684:                			*vData++ = ENC100_GET_AD_IOL();
2685:                			ENC100_SO_WR_B0SEL_EN_IO = 0;			
2686:                		}
2687:                		DeassertChipSelect();
2688:                	}
2689:                	#else // SPI mode
2690:                	{
2691:                		WORD w;
2692:                
2693:                		// Use RX pointer
2694:                		w = Execute2(RRXRDPT, 0x0000);
2695:                		Execute2(WRXRDPT, wAddress);
2696:                		ReadN(RBMRX, vData, wLength);
2697:                		Execute2(WRXRDPT, w);
2698:                	}	
2699:                	#endif
2700:                
2701:                	#if defined(ENC100_ISR_ENABLE) && defined(ENC100_INT_TRIS)
2702:                		ENC100_ISR_ENABLE = bISREnabled;
2703:                	#endif
2704:                }
2705:                #endif
2706:                
2707:                /******************************************************************************
2708:                 * Function:        void ReadMemoryWindow(BYTE vWindow, BYTE *vData, WORD wLength)
2709:                 *
2710:                 * PreCondition:    None
2711:                 *
2712:                 * Input:           vWindow: UDA_WINDOW, GP_WINDOW, or RX_WINDOW corresponding 
2713:                 *							 to the window register to read from
2714:                 *					*vData: Pointer to local PIC RAM which will be written 
2715:                 *							with data from the ENC624J600 Family.
2716:                 *					wLength: Number of bytes to copy from window to vData
2717:                 *
2718:                 * Output:          None
2719:                 *
2720:                 * Side Effects:    None
2721:                 *
2722:                 * Overview:        Copys 0 or more bytes from the ENC624J600 Family RAM using 
2723:                 *					one of the UDA, TX, or RX read window pointers.  This 
2724:                 *					pointer is incremented by the number of bytes read.  
2725:                 *					However, if using a 16-bit parallel interface, the pointer 
2726:                 *					will be incremented by 1 extra if the length parameter is 
2727:                 *					odd to ensure 16-bit alignment.
2728:                 *
2729:                 * Note:            None
2730:                 *****************************************************************************/
2731:                void ReadMemoryWindow(BYTE vWindow, BYTE *vData, WORD wLength)
2732:                {
9D01DB60  27BDFFE0   ADDIU SP, SP, -32
9D01DB64  AFBF001C   SW RA, 28(SP)
9D01DB68  AFBE0018   SW S8, 24(SP)
9D01DB6C  03A0F021   ADDU S8, SP, ZERO
9D01DB70  00801821   ADDU V1, A0, ZERO
9D01DB74  AFC50024   SW A1, 36(S8)
9D01DB78  00C01021   ADDU V0, A2, ZERO
9D01DB7C  A3C30020   SB V1, 32(S8)
9D01DB80  A7C20028   SH V0, 40(S8)
2733:                	BOOL bISREnabled;
2734:                	
2735:                	#if (ENC100_INTERFACE_MODE >= 1)	// Parallel mode
2736:                		WORD wAddress;
2737:                	#endif
2738:                
2739:                	if(wLength == 0u)
9D01DB84  97C20028   LHU V0, 40(S8)
9D01DB88  10400029   BEQ V0, ZERO, 0x9D01DC30
9D01DB8C  00000000   NOP
2740:                		return;
9D01DC30  00000000   NOP
2741:                
2742:                	#if defined(ENC100_ISR_ENABLE) && defined(ENC100_INT_TRIS)
2743:                		bISREnabled = ENC100_ISR_ENABLE;
9D01DB90  3C02BF88   LUI V0, -16504
9D01DB94  8C421060   LW V0, 4192(V0)
9D01DB98  7C4204C0   EXT V0, V0, 19, 1
9D01DB9C  304200FF   ANDI V0, V0, 255
9D01DBA0  AFC20014   SW V0, 20(S8)
2744:                		ENC100_ISR_ENABLE = 0;
9D01DBA4  3C03BF88   LUI V1, -16504
9D01DBA8  8C621060   LW V0, 4192(V1)
9D01DBAC  7C029CC4   INS V0, ZERO, 19, 1
9D01DBB0  AC621060   SW V0, 4192(V1)
2745:                	#endif
2746:                	
2747:                	#if (ENC100_INTERFACE_MODE == 1) || (ENC100_INTERFACE_MODE == 2) || (ENC100_INTERFACE_MODE == 5) || (ENC100_INTERFACE_MODE == 6)
2748:                		wAddress = EUDADATA;
2749:                		if(vWindow & GP_WINDOW)
2750:                			wAddress = EGPDATA;
2751:                		if(vWindow & RX_WINDOW)
2752:                			wAddress = ERXDATA;
2753:                	#elif (ENC100_INTERFACE_MODE == 3) || (ENC100_INTERFACE_MODE == 4) || (ENC100_INTERFACE_MODE == 9) || (ENC100_INTERFACE_MODE == 10)
2754:                		wAddress = (EUDADATA>>1);
2755:                		if(vWindow & GP_WINDOW)
2756:                			wAddress = (EGPDATA>>1);
2757:                		if(vWindow & RX_WINDOW)
2758:                			wAddress = (ERXDATA>>1);
2759:                	#endif
2760:                	
2761:                	#if (ENC100_INTERFACE_MODE >= 1) && !defined(ENC100_BIT_BANG_PMP)
2762:                	{
2763:                		volatile BYTE vDummy;
2764:                
2765:                		ConfigurePMPModule();
2766:                		AssertChipSelect();
2767:                		PMADDR = wAddress;
2768:                		vDummy = PMDIN1;
2769:                		while(--wLength)
2770:                		{
2771:                			while(PMMODEbits.BUSY);
2772:                			*vData++ = PMDIN1;
2773:                		}
2774:                		while(PMMODEbits.BUSY);
2775:                		DeassertChipSelect();
2776:                		PMCONbits.PMPEN = 0;
2777:                		*vData = PMDIN1;
2778:                	}
2779:                	#elif ENC100_INTERFACE_MODE == 1
2780:                		ENC100_SET_ADDR_TRIS_OUT();
2781:                		ENC100_SET_AD_TRIS_IN();
2782:                		AssertChipSelect();
2783:                		ENC100_SET_ADDR_IO(wAddress);
2784:                		while(wLength--)
2785:                		{
2786:                			ENC100_SI_RD_RW_IO = 1;
2787:                			DelaySetupHold();
2788:                			*vData++ = ENC100_GET_AD_IO();
2789:                			ENC100_SI_RD_RW_IO = 0;			
2790:                		}
2791:                		DeassertChipSelect();
2792:                	#elif ENC100_INTERFACE_MODE == 2
2793:                		ENC100_SET_ADDR_TRIS_OUT();
2794:                		ENC100_SET_AD_TRIS_IN();
2795:                		AssertChipSelect();
2796:                		ENC100_SI_RD_RW_IO = 1;
2797:                		ENC100_SET_ADDR_IO(wAddress);
2798:                		while(wLength--)
2799:                		{
2800:                			ENC100_SO_WR_B0SEL_EN_IO = 1;
2801:                			DelaySetupHold();
2802:                			*vData++ = ENC100_GET_AD_IO();
2803:                			ENC100_SO_WR_B0SEL_EN_IO = 0;
2804:                		}
2805:                		DeassertChipSelect();
2806:                	#elif ENC100_INTERFACE_MODE == 3
2807:                		ENC100_SET_ADDR_TRIS_OUT();
2808:                		ENC100_SET_AD_TRIS_IN();
2809:                		AssertChipSelect();
2810:                		ENC100_SET_ADDR_IO(wAddress);
2811:                		while(wLength--)
2812:                		{
2813:                			ENC100_SI_RD_RW_IO = 1;
2814:                			DelaySetupHold();
2815:                			*vData++ = ENC100_GET_AD_IOL();
2816:                			ENC100_SI_RD_RW_IO = 0;	
2817:                		}
2818:                		DeassertChipSelect();
2819:                	#elif ENC100_INTERFACE_MODE == 4
2820:                		ENC100_SET_ADDR_TRIS_OUT();
2821:                		ENC100_SET_AD_TRIS_IN();
2822:                		AssertChipSelect();
2823:                		ENC100_SI_RD_RW_IO = 1;
2824:                		ENC100_SET_ADDR_IO(wAddress);
2825:                		while(wLength--)
2826:                		{
2827:                			ENC100_SO_WR_B0SEL_EN_IO = 1;
2828:                			DelaySetupHold();
2829:                			*vData++ = ENC100_GET_AD_IOL();
2830:                			ENC100_SO_WR_B0SEL_EN_IO = 0;
2831:                		}
2832:                		DeassertChipSelect();
2833:                	#elif ENC100_INTERFACE_MODE == 5
2834:                		AssertChipSelect();
2835:                		ENC100_SET_AD_TRIS_OUT();
2836:                		ENC100_SET_AD_IO(wAddress);
2837:                		ENC100_SCK_AL_IO = 1;
2838:                		ENC100_SCK_AL_IO = 0;
2839:                		ENC100_SET_AD_TRIS_IN();
2840:                		while(wLength--)
2841:                		{
2842:                			ENC100_SI_RD_RW_IO = 1;
2843:                			DelaySetupHold();
2844:                			*vData++ = ENC100_GET_AD_IO();
2845:                			ENC100_SI_RD_RW_IO = 0;			
2846:                		}
2847:                		DeassertChipSelect();
2848:                	#elif ENC100_INTERFACE_MODE == 6
2849:                		AssertChipSelect();
2850:                		ENC100_SI_RD_RW_IO = 1;
2851:                		ENC100_SET_AD_TRIS_OUT();
2852:                		ENC100_SET_AD_IO(wAddress);
2853:                		ENC100_SCK_AL_IO = 1;
2854:                		ENC100_SCK_AL_IO = 0;
2855:                		ENC100_SET_AD_TRIS_IN();
2856:                		while(wLength--)
2857:                		{
2858:                			ENC100_SO_WR_B0SEL_EN_IO = 1;
2859:                			DelaySetupHold();
2860:                			*vData++ = ENC100_GET_AD_IO();
2861:                			ENC100_SO_WR_B0SEL_EN_IO = 0;			
2862:                		}
2863:                		DeassertChipSelect();
2864:                	#elif ENC100_INTERFACE_MODE == 9
2865:                		AssertChipSelect();
2866:                		ENC100_SET_AD_TRIS_OUT();
2867:                		ENC100_SET_AD_IO(wAddress);
2868:                		ENC100_SCK_AL_IO = 1;
2869:                		ENC100_SCK_AL_IO = 0;
2870:                		ENC100_SET_AD_TRIS_IN();
2871:                		while(wLength--)
2872:                		{
2873:                			ENC100_SI_RD_RW_IO = 1;
2874:                			DelaySetupHold();
2875:                			*vData++ = ENC100_GET_AD_IOL();
2876:                			ENC100_SI_RD_RW_IO = 0;			
2877:                		}
2878:                		DeassertChipSelect();
2879:                	#elif ENC100_INTERFACE_MODE == 10
2880:                		AssertChipSelect();
2881:                		ENC100_SI_RD_RW_IO = 1;
2882:                		ENC100_SET_AD_TRIS_OUT();
2883:                		ENC100_SET_AD_IO(wAddress);
2884:                		ENC100_SCK_AL_IO = 1;
2885:                		ENC100_SCK_AL_IO = 0;
2886:                		ENC100_SET_AD_TRIS_IN();
2887:                		while(wLength--)
2888:                		{
2889:                			ENC100_SO_WR_B0SEL_EN_IO = 1;
2890:                			DelaySetupHold();
2891:                			*vData++ = ENC100_GET_AD_IOL();
2892:                			ENC100_SO_WR_B0SEL_EN_IO = 0;			
2893:                		}
2894:                		DeassertChipSelect();
2895:                	#else // SPI mode
2896:                	{
2897:                		BYTE vOpcode;
2898:                
2899:                		vOpcode = RBMUDA;
9D01DBB4  24020030   ADDIU V0, ZERO, 48
9D01DBB8  A3C20010   SB V0, 16(S8)
2900:                		if(vWindow & GP_WINDOW)
9D01DBBC  93C20020   LBU V0, 32(S8)
9D01DBC0  30420002   ANDI V0, V0, 2
9D01DBC4  10400003   BEQ V0, ZERO, 0x9D01DBD4
9D01DBC8  00000000   NOP
2901:                			vOpcode = RBMGP;
9D01DBCC  24020028   ADDIU V0, ZERO, 40
9D01DBD0  A3C20010   SB V0, 16(S8)
2902:                		if(vWindow & RX_WINDOW)
9D01DBD4  93C20020   LBU V0, 32(S8)
9D01DBD8  30420004   ANDI V0, V0, 4
9D01DBDC  10400003   BEQ V0, ZERO, 0x9D01DBEC
9D01DBE0  00000000   NOP
2903:                			vOpcode = RBMRX;
9D01DBE4  2402002C   ADDIU V0, ZERO, 44
9D01DBE8  A3C20010   SB V0, 16(S8)
2904:                
2905:                		ReadN(vOpcode, vData, wLength);
9D01DBEC  93C30010   LBU V1, 16(S8)
9D01DBF0  97C20028   LHU V0, 40(S8)
9D01DBF4  00602021   ADDU A0, V1, ZERO
9D01DBF8  8FC50024   LW A1, 36(S8)
9D01DBFC  00403021   ADDU A2, V0, ZERO
9D01DC00  0F407827   JAL 0x9D01E09C
9D01DC04  00000000   NOP
2906:                	}
2907:                	#endif
2908:                
2909:                	#if defined(ENC100_ISR_ENABLE) && defined(ENC100_INT_TRIS)
2910:                		ENC100_ISR_ENABLE = bISREnabled;
9D01DC08  8FC20014   LW V0, 20(S8)
9D01DC0C  304200FF   ANDI V0, V0, 255
9D01DC10  30420001   ANDI V0, V0, 1
9D01DC14  304400FF   ANDI A0, V0, 255
9D01DC18  3C03BF88   LUI V1, -16504
9D01DC1C  8C621060   LW V0, 4192(V1)
9D01DC20  7C829CC4   INS V0, A0, 19, 1
9D01DC24  AC621060   SW V0, 4192(V1)
9D01DC28  0B40770D   J 0x9D01DC34
9D01DC2C  00000000   NOP
2911:                	#endif
2912:                }
9D01DC34  03C0E821   ADDU SP, S8, ZERO
9D01DC38  8FBF001C   LW RA, 28(SP)
9D01DC3C  8FBE0018   LW S8, 24(SP)
9D01DC40  27BD0020   ADDIU SP, SP, 32
9D01DC44  03E00008   JR RA
9D01DC48  00000000   NOP
2913:                
2914:                
2915:                
2916:                #if (ENC100_INTERFACE_MODE == 0)	// These are SPI only functions
2917:                /******************************************************************************
2918:                 * Function:        void Execute0(BYTE vOpcode)
2919:                 *
2920:                 * PreCondition:    SPI bus must be initialized (done in MACInit()).
2921:                 *
2922:                 * Input:           None
2923:                 *
2924:                 * Output:          None
2925:                 *
2926:                 * Side Effects:    None
2927:                 *
2928:                 * Overview:        Sends a single byte command with no parameters
2929:                 *
2930:                 * Note:            None
2931:                 *****************************************************************************/
2932:                static void Execute0(BYTE vOpcode)
2933:                {
9D01DC4C  27BDFFF0   ADDIU SP, SP, -16
9D01DC50  AFBE000C   SW S8, 12(SP)
9D01DC54  03A0F021   ADDU S8, SP, ZERO
9D01DC58  00801021   ADDU V0, A0, ZERO
9D01DC5C  A3C20010   SB V0, 16(S8)
2934:                	volatile BYTE vDummy;
2935:                	BOOL bISREnabled;
2936:                
2937:                	#if defined(ENC100_ISR_ENABLE) && defined(ENC100_INT_TRIS)
2938:                		bISREnabled = ENC100_ISR_ENABLE;
9D01DC60  3C02BF88   LUI V0, -16504
9D01DC64  8C421060   LW V0, 4192(V0)
9D01DC68  7C4204C0   EXT V0, V0, 19, 1
9D01DC6C  304200FF   ANDI V0, V0, 255
9D01DC70  AFC20000   SW V0, 0(S8)
2939:                		ENC100_ISR_ENABLE = 0;
9D01DC74  3C03BF88   LUI V1, -16504
9D01DC78  8C621060   LW V0, 4192(V1)
9D01DC7C  7C029CC4   INS V0, ZERO, 19, 1
9D01DC80  AC621060   SW V0, 4192(V1)
2940:                	#endif
2941:                
2942:                	AssertChipSelect();
9D01DC84  3C03BF88   LUI V1, -16504
9D01DC88  8C626160   LW V0, 24928(V1)
9D01DC8C  7C026304   INS V0, ZERO, 12, 1
9D01DC90  AC626160   SW V0, 24928(V1)
2943:                	ClearSPIDoneFlag();
2944:                	ENC100_SSPBUF = vOpcode;	// Send the command/opcode
9D01DC94  93C30010   LBU V1, 16(S8)
9D01DC98  3C02BF80   LUI V0, -16512
9D01DC9C  AC435A20   SW V1, 23072(V0)
2945:                	WaitForDataByte();
2946:                	vDummy = ENC100_SSPBUF;
9D01DCC8  3C02BF80   LUI V0, -16512
9D01DCCC  8C425A20   LW V0, 23072(V0)
9D01DCD0  304200FF   ANDI V0, V0, 255
9D01DCD4  A3C20004   SB V0, 4(S8)
2947:                	DeassertChipSelect();
9D01DCD8  3C03BF88   LUI V1, -16504
9D01DCDC  8C626160   LW V0, 24928(V1)
9D01DCE0  24040001   ADDIU A0, ZERO, 1
9D01DCE4  7C826304   INS V0, A0, 12, 1
9D01DCE8  AC626160   SW V0, 24928(V1)
2948:                
2949:                	#if defined(ENC100_ISR_ENABLE) && defined(ENC100_INT_TRIS)
2950:                		ENC100_ISR_ENABLE = bISREnabled;
9D01DCEC  8FC20000   LW V0, 0(S8)
9D01DCF0  304200FF   ANDI V0, V0, 255
9D01DCF4  30420001   ANDI V0, V0, 1
9D01DCF8  304400FF   ANDI A0, V0, 255
9D01DCFC  3C03BF88   LUI V1, -16504
9D01DD00  8C621060   LW V0, 4192(V1)
9D01DD04  7C829CC4   INS V0, A0, 19, 1
9D01DD08  AC621060   SW V0, 4192(V1)
2951:                	#endif
2952:                }//end Execute0
9D01DD0C  03C0E821   ADDU SP, S8, ZERO
9D01DD10  8FBE000C   LW S8, 12(SP)
9D01DD14  27BD0010   ADDIU SP, SP, 16
9D01DD18  03E00008   JR RA
9D01DD1C  00000000   NOP
2953:                
2954:                // This Execute1 function is not currently used
2955:                //static BYTE Execute1(BYTE vOpcode, BYTE vData)
2956:                //{
2957:                //	volatile BYTE vReturn;
2958:                //	BOOL bISREnabled;
2959:                //
2960:                //	#if defined(ENC100_ISR_ENABLE) && defined(ENC100_INT_TRIS)
2961:                //		bISREnabled = ENC100_ISR_ENABLE;
2962:                //		ENC100_ISR_ENABLE = 0;
2963:                //	#endif
2964:                //
2965:                //	AssertChipSelect();
2966:                //	ClearSPIDoneFlag();
2967:                //	ENC100_SSPBUF = vOpcode;	// Send the command/opcode
2968:                //	WaitForDataByte();
2969:                //	vReturn = ENC100_SSPBUF;
2970:                //	ENC100_SSPBUF = vData;		// Send the data
2971:                //	WaitForDataByte();
2972:                //	vReturn = ENC100_SSPBUF;
2973:                //	DeassertChipSelect();
2974:                //
2975:                //	#if defined(ENC100_ISR_ENABLE) && defined(ENC100_INT_TRIS)
2976:                //		ENC100_ISR_ENABLE = bISREnabled;
2977:                //	#endif
2978:                //
2979:                //	return vReturn;
2980:                //}//end Execute1
2981:                
2982:                static WORD Execute2(BYTE vOpcode, WORD wData)
2983:                {
9D01DD20  27BDFFF0   ADDIU SP, SP, -16
9D01DD24  AFBE000C   SW S8, 12(SP)
9D01DD28  03A0F021   ADDU S8, SP, ZERO
9D01DD2C  00801821   ADDU V1, A0, ZERO
9D01DD30  00A01021   ADDU V0, A1, ZERO
9D01DD34  A3C30010   SB V1, 16(S8)
9D01DD38  A7C20014   SH V0, 20(S8)
2984:                	volatile WORD wReturn;
2985:                	BOOL bISREnabled;
2986:                
2987:                	#if defined(ENC100_ISR_ENABLE) && defined(ENC100_INT_TRIS)
2988:                		bISREnabled = ENC100_ISR_ENABLE;
9D01DD3C  3C02BF88   LUI V0, -16504
9D01DD40  8C421060   LW V0, 4192(V0)
9D01DD44  7C4204C0   EXT V0, V0, 19, 1
9D01DD48  304200FF   ANDI V0, V0, 255
9D01DD4C  AFC20000   SW V0, 0(S8)
2989:                		ENC100_ISR_ENABLE = 0;
9D01DD50  3C03BF88   LUI V1, -16504
9D01DD54  8C621060   LW V0, 4192(V1)
9D01DD58  7C029CC4   INS V0, ZERO, 19, 1
9D01DD5C  AC621060   SW V0, 4192(V1)
2990:                	#endif
2991:                
2992:                	AssertChipSelect();
9D01DD60  3C03BF88   LUI V1, -16504
9D01DD64  8C626160   LW V0, 24928(V1)
9D01DD68  7C026304   INS V0, ZERO, 12, 1
9D01DD6C  AC626160   SW V0, 24928(V1)
2993:                	ClearSPIDoneFlag();
2994:                	ENC100_SSPBUF = vOpcode;			// Send the command/opcode
9D01DD70  93C30010   LBU V1, 16(S8)
9D01DD74  3C02BF80   LUI V0, -16512
9D01DD78  AC435A20   SW V1, 23072(V0)
2995:                	WaitForDataByte();
2996:                	((BYTE*)&wReturn)[0] = ENC100_SSPBUF;
9D01DDA4  27C20004   ADDIU V0, S8, 4
9D01DDA8  3C03BF80   LUI V1, -16512
9D01DDAC  8C635A20   LW V1, 23072(V1)
9D01DDB0  306300FF   ANDI V1, V1, 255
9D01DDB4  A0430000   SB V1, 0(V0)
2997:                	ENC100_SSPBUF = ((BYTE*)&wData)[0];	// Send low byte of data
9D01DDB8  27C20014   ADDIU V0, S8, 20
9D01DDBC  90420000   LBU V0, 0(V0)
9D01DDC0  00401821   ADDU V1, V0, ZERO
9D01DDC4  3C02BF80   LUI V0, -16512
9D01DDC8  AC435A20   SW V1, 23072(V0)
2998:                	WaitForDataByte();
2999:                	((BYTE*)&wReturn)[0] = ENC100_SSPBUF;
9D01DDF4  27C20004   ADDIU V0, S8, 4
9D01DDF8  3C03BF80   LUI V1, -16512
9D01DDFC  8C635A20   LW V1, 23072(V1)
9D01DE00  306300FF   ANDI V1, V1, 255
9D01DE04  A0430000   SB V1, 0(V0)
3000:                	ENC100_SSPBUF = ((BYTE*)&wData)[1];	// Send high byte of data
9D01DE08  27C20014   ADDIU V0, S8, 20
9D01DE0C  24420001   ADDIU V0, V0, 1
9D01DE10  90420000   LBU V0, 0(V0)
9D01DE14  00401821   ADDU V1, V0, ZERO
9D01DE18  3C02BF80   LUI V0, -16512
9D01DE1C  AC435A20   SW V1, 23072(V0)
3001:                	WaitForDataByte();
3002:                	((BYTE*)&wReturn)[1] = ENC100_SSPBUF;
9D01DE48  27C20004   ADDIU V0, S8, 4
9D01DE4C  24420001   ADDIU V0, V0, 1
9D01DE50  3C03BF80   LUI V1, -16512
9D01DE54  8C635A20   LW V1, 23072(V1)
9D01DE58  306300FF   ANDI V1, V1, 255
9D01DE5C  A0430000   SB V1, 0(V0)
3003:                	DeassertChipSelect();
9D01DE60  3C03BF88   LUI V1, -16504
9D01DE64  8C626160   LW V0, 24928(V1)
9D01DE68  24040001   ADDIU A0, ZERO, 1
9D01DE6C  7C826304   INS V0, A0, 12, 1
9D01DE70  AC626160   SW V0, 24928(V1)
3004:                
3005:                	#if defined(ENC100_ISR_ENABLE) && defined(ENC100_INT_TRIS)
3006:                		ENC100_ISR_ENABLE = bISREnabled;
9D01DE74  8FC20000   LW V0, 0(S8)
9D01DE78  304200FF   ANDI V0, V0, 255
9D01DE7C  30420001   ANDI V0, V0, 1
9D01DE80  304400FF   ANDI A0, V0, 255
9D01DE84  3C03BF88   LUI V1, -16504
9D01DE88  8C621060   LW V0, 4192(V1)
9D01DE8C  7C829CC4   INS V0, A0, 19, 1
9D01DE90  AC621060   SW V0, 4192(V1)
3007:                	#endif
3008:                
3009:                	return wReturn;
9D01DE94  97C20004   LHU V0, 4(S8)
9D01DE98  3042FFFF   ANDI V0, V0, -1
3010:                }//end Execute2
9D01DE9C  03C0E821   ADDU SP, S8, ZERO
9D01DEA0  8FBE000C   LW S8, 12(SP)
9D01DEA4  27BD0010   ADDIU SP, SP, 16
9D01DEA8  03E00008   JR RA
9D01DEAC  00000000   NOP
3011:                
3012:                static DWORD Execute3(BYTE vOpcode, DWORD dwData)
3013:                {
9D01DEB0  27BDFFF0   ADDIU SP, SP, -16
9D01DEB4  AFBE000C   SW S8, 12(SP)
9D01DEB8  03A0F021   ADDU S8, SP, ZERO
9D01DEBC  00801021   ADDU V0, A0, ZERO
9D01DEC0  AFC50014   SW A1, 20(S8)
9D01DEC4  A3C20010   SB V0, 16(S8)
3014:                	volatile DWORD dwReturn;
3015:                	BOOL bISREnabled;
3016:                
3017:                	#if defined(ENC100_ISR_ENABLE) && defined(ENC100_INT_TRIS)
3018:                		bISREnabled = ENC100_ISR_ENABLE;
9D01DEC8  3C02BF88   LUI V0, -16504
9D01DECC  8C421060   LW V0, 4192(V0)
9D01DED0  7C4204C0   EXT V0, V0, 19, 1
9D01DED4  304200FF   ANDI V0, V0, 255
9D01DED8  AFC20000   SW V0, 0(S8)
3019:                		ENC100_ISR_ENABLE = 0;
9D01DEDC  3C03BF88   LUI V1, -16504
9D01DEE0  8C621060   LW V0, 4192(V1)
9D01DEE4  7C029CC4   INS V0, ZERO, 19, 1
9D01DEE8  AC621060   SW V0, 4192(V1)
3020:                	#endif
3021:                
3022:                	AssertChipSelect();
9D01DEEC  3C03BF88   LUI V1, -16504
9D01DEF0  8C626160   LW V0, 24928(V1)
9D01DEF4  7C026304   INS V0, ZERO, 12, 1
9D01DEF8  AC626160   SW V0, 24928(V1)
3023:                	ClearSPIDoneFlag();
3024:                	ENC100_SSPBUF = vOpcode;				// Send the command/opcode
9D01DEFC  93C30010   LBU V1, 16(S8)
9D01DF00  3C02BF80   LUI V0, -16512
9D01DF04  AC435A20   SW V1, 23072(V0)
3025:                	((BYTE*)&dwReturn)[3] = 0x00;
9D01DF08  27C20004   ADDIU V0, S8, 4
9D01DF0C  24420003   ADDIU V0, V0, 3
9D01DF10  A0400000   SB ZERO, 0(V0)
3026:                	WaitForDataByte();
3027:                	((BYTE*)&dwReturn)[0] = ENC100_SSPBUF;
9D01DF3C  27C20004   ADDIU V0, S8, 4
9D01DF40  3C03BF80   LUI V1, -16512
9D01DF44  8C635A20   LW V1, 23072(V1)
9D01DF48  306300FF   ANDI V1, V1, 255
9D01DF4C  A0430000   SB V1, 0(V0)
3028:                	ENC100_SSPBUF = ((BYTE*)&dwData)[0];	// Send byte 0 of data
9D01DF50  27C20014   ADDIU V0, S8, 20
9D01DF54  90420000   LBU V0, 0(V0)
9D01DF58  00401821   ADDU V1, V0, ZERO
9D01DF5C  3C02BF80   LUI V0, -16512
9D01DF60  AC435A20   SW V1, 23072(V0)
3029:                	WaitForDataByte();
3030:                	((BYTE*)&dwReturn)[0] = ENC100_SSPBUF;
9D01DF8C  27C20004   ADDIU V0, S8, 4
9D01DF90  3C03BF80   LUI V1, -16512
9D01DF94  8C635A20   LW V1, 23072(V1)
9D01DF98  306300FF   ANDI V1, V1, 255
9D01DF9C  A0430000   SB V1, 0(V0)
3031:                	ENC100_SSPBUF = ((BYTE*)&dwData)[1];	// Send byte 1 of data
9D01DFA0  27C20014   ADDIU V0, S8, 20
9D01DFA4  24420001   ADDIU V0, V0, 1
9D01DFA8  90420000   LBU V0, 0(V0)
9D01DFAC  00401821   ADDU V1, V0, ZERO
9D01DFB0  3C02BF80   LUI V0, -16512
9D01DFB4  AC435A20   SW V1, 23072(V0)
3032:                	WaitForDataByte();
3033:                	((BYTE*)&dwReturn)[1] = ENC100_SSPBUF;
9D01DFE0  27C20004   ADDIU V0, S8, 4
9D01DFE4  24420001   ADDIU V0, V0, 1
9D01DFE8  3C03BF80   LUI V1, -16512
9D01DFEC  8C635A20   LW V1, 23072(V1)
9D01DFF0  306300FF   ANDI V1, V1, 255
9D01DFF4  A0430000   SB V1, 0(V0)
3034:                	ENC100_SSPBUF = ((BYTE*)&dwData)[2];	// Send byte 2 of data
9D01DFF8  27C20014   ADDIU V0, S8, 20
9D01DFFC  24420002   ADDIU V0, V0, 2
9D01E000  90420000   LBU V0, 0(V0)
9D01E004  00401821   ADDU V1, V0, ZERO
9D01E008  3C02BF80   LUI V0, -16512
9D01E00C  AC435A20   SW V1, 23072(V0)
3035:                	WaitForDataByte();
3036:                	((BYTE*)&dwReturn)[2] = ENC100_SSPBUF;
9D01E038  27C20004   ADDIU V0, S8, 4
9D01E03C  24420002   ADDIU V0, V0, 2
9D01E040  3C03BF80   LUI V1, -16512
9D01E044  8C635A20   LW V1, 23072(V1)
9D01E048  306300FF   ANDI V1, V1, 255
9D01E04C  A0430000   SB V1, 0(V0)
3037:                	DeassertChipSelect();
9D01E050  3C03BF88   LUI V1, -16504
9D01E054  8C626160   LW V0, 24928(V1)
9D01E058  24040001   ADDIU A0, ZERO, 1
9D01E05C  7C826304   INS V0, A0, 12, 1
9D01E060  AC626160   SW V0, 24928(V1)
3038:                
3039:                	#if defined(ENC100_ISR_ENABLE) && defined(ENC100_INT_TRIS)
3040:                		ENC100_ISR_ENABLE = bISREnabled;
9D01E064  8FC20000   LW V0, 0(S8)
9D01E068  304200FF   ANDI V0, V0, 255
9D01E06C  30420001   ANDI V0, V0, 1
9D01E070  304400FF   ANDI A0, V0, 255
9D01E074  3C03BF88   LUI V1, -16504
9D01E078  8C621060   LW V0, 4192(V1)
9D01E07C  7C829CC4   INS V0, A0, 19, 1
9D01E080  AC621060   SW V0, 4192(V1)
3041:                	#endif
3042:                
3043:                	return dwReturn;
9D01E084  8FC20004   LW V0, 4(S8)
3044:                }//end Execute2
9D01E088  03C0E821   ADDU SP, S8, ZERO
9D01E08C  8FBE000C   LW S8, 12(SP)
9D01E090  27BD0010   ADDIU SP, SP, 16
9D01E094  03E00008   JR RA
9D01E098  00000000   NOP
3045:                
3046:                static void ReadN(BYTE vOpcode, BYTE* vData, WORD wDataLen)
3047:                {
9D01E09C  27BDFFF0   ADDIU SP, SP, -16
9D01E0A0  AFBE000C   SW S8, 12(SP)
9D01E0A4  03A0F021   ADDU S8, SP, ZERO
9D01E0A8  00801821   ADDU V1, A0, ZERO
9D01E0AC  AFC50014   SW A1, 20(S8)
9D01E0B0  00C01021   ADDU V0, A2, ZERO
9D01E0B4  A3C30010   SB V1, 16(S8)
9D01E0B8  A7C20018   SH V0, 24(S8)
3048:                	volatile BYTE vDummy;
3049:                	BOOL bISREnabled;
3050:                
3051:                	#if defined(ENC100_ISR_ENABLE) && defined(ENC100_INT_TRIS)
3052:                		bISREnabled = ENC100_ISR_ENABLE;
9D01E0BC  3C02BF88   LUI V0, -16504
9D01E0C0  8C421060   LW V0, 4192(V0)
9D01E0C4  7C4204C0   EXT V0, V0, 19, 1
9D01E0C8  304200FF   ANDI V0, V0, 255
9D01E0CC  AFC20000   SW V0, 0(S8)
3053:                		ENC100_ISR_ENABLE = 0;
9D01E0D0  3C03BF88   LUI V1, -16504
9D01E0D4  8C621060   LW V0, 4192(V1)
9D01E0D8  7C029CC4   INS V0, ZERO, 19, 1
9D01E0DC  AC621060   SW V0, 4192(V1)
3054:                	#endif
3055:                
3056:                	AssertChipSelect();
9D01E0E0  3C03BF88   LUI V1, -16504
9D01E0E4  8C626160   LW V0, 24928(V1)
9D01E0E8  7C026304   INS V0, ZERO, 12, 1
9D01E0EC  AC626160   SW V0, 24928(V1)
3057:                	ClearSPIDoneFlag();
3058:                	ENC100_SSPBUF = vOpcode;				// Send the command/opcode
9D01E0F0  93C30010   LBU V1, 16(S8)
9D01E0F4  3C02BF80   LUI V0, -16512
9D01E0F8  AC435A20   SW V1, 23072(V0)
3059:                	WaitForDataByte();
3060:                	vDummy = ENC100_SSPBUF;
9D01E124  3C02BF80   LUI V0, -16512
9D01E128  8C425A20   LW V0, 23072(V0)
9D01E12C  304200FF   ANDI V0, V0, 255
9D01E130  A3C20004   SB V0, 4(S8)
3061:                	while(wDataLen--)
9D01E134  0B407863   J 0x9D01E18C
9D01E138  00000000   NOP
9D01E18C  97C20018   LHU V0, 24(S8)
9D01E190  0002102B   SLTU V0, ZERO, V0
9D01E194  304200FF   ANDI V0, V0, 255
9D01E198  97C30018   LHU V1, 24(S8)
9D01E19C  2463FFFF   ADDIU V1, V1, -1
9D01E1A0  A7C30018   SH V1, 24(S8)
9D01E1A4  1440FFE5   BNE V0, ZERO, 0x9D01E13C
9D01E1A8  00000000   NOP
3062:                	{
3063:                		ENC100_SSPBUF = 0x00;
9D01E13C  3C02BF80   LUI V0, -16512
9D01E140  AC405A20   SW ZERO, 23072(V0)
3064:                		WaitForDataByte();
3065:                		*vData++ = ENC100_SSPBUF;
9D01E16C  3C02BF80   LUI V0, -16512
9D01E170  8C425A20   LW V0, 23072(V0)
9D01E174  304300FF   ANDI V1, V0, 255
9D01E178  8FC20014   LW V0, 20(S8)
9D01E17C  A0430000   SB V1, 0(V0)
9D01E180  8FC20014   LW V0, 20(S8)
9D01E184  24420001   ADDIU V0, V0, 1
9D01E188  AFC20014   SW V0, 20(S8)
3066:                	}
3067:                	DeassertChipSelect();
9D01E1AC  3C03BF88   LUI V1, -16504
9D01E1B0  8C626160   LW V0, 24928(V1)
9D01E1B4  24040001   ADDIU A0, ZERO, 1
9D01E1B8  7C826304   INS V0, A0, 12, 1
9D01E1BC  AC626160   SW V0, 24928(V1)
3068:                
3069:                	#if defined(ENC100_ISR_ENABLE) && defined(ENC100_INT_TRIS)
3070:                		ENC100_ISR_ENABLE = bISREnabled;
9D01E1C0  8FC20000   LW V0, 0(S8)
9D01E1C4  304200FF   ANDI V0, V0, 255
9D01E1C8  30420001   ANDI V0, V0, 1
9D01E1CC  304400FF   ANDI A0, V0, 255
9D01E1D0  3C03BF88   LUI V1, -16504
9D01E1D4  8C621060   LW V0, 4192(V1)
9D01E1D8  7C829CC4   INS V0, A0, 19, 1
9D01E1DC  AC621060   SW V0, 4192(V1)
3071:                	#endif
3072:                }
9D01E1E0  03C0E821   ADDU SP, S8, ZERO
9D01E1E4  8FBE000C   LW S8, 12(SP)
9D01E1E8  27BD0010   ADDIU SP, SP, 16
9D01E1EC  03E00008   JR RA
9D01E1F0  00000000   NOP
3073:                
3074:                static void WriteN(BYTE vOpcode, BYTE* vData, WORD wDataLen)
3075:                {
9D01E1F4  27BDFFF0   ADDIU SP, SP, -16
9D01E1F8  AFBE000C   SW S8, 12(SP)
9D01E1FC  03A0F021   ADDU S8, SP, ZERO
9D01E200  00801821   ADDU V1, A0, ZERO
9D01E204  AFC50014   SW A1, 20(S8)
9D01E208  00C01021   ADDU V0, A2, ZERO
9D01E20C  A3C30010   SB V1, 16(S8)
9D01E210  A7C20018   SH V0, 24(S8)
3076:                	volatile BYTE vDummy;
3077:                	BOOL bISREnabled;
3078:                
3079:                	#if defined(ENC100_ISR_ENABLE) && defined(ENC100_INT_TRIS)
3080:                		bISREnabled = ENC100_ISR_ENABLE;
9D01E214  3C02BF88   LUI V0, -16504
9D01E218  8C421060   LW V0, 4192(V0)
9D01E21C  7C4204C0   EXT V0, V0, 19, 1
9D01E220  304200FF   ANDI V0, V0, 255
9D01E224  AFC20000   SW V0, 0(S8)
3081:                		ENC100_ISR_ENABLE = 0;
9D01E228  3C03BF88   LUI V1, -16504
9D01E22C  8C621060   LW V0, 4192(V1)
9D01E230  7C029CC4   INS V0, ZERO, 19, 1
9D01E234  AC621060   SW V0, 4192(V1)
3082:                	#endif
3083:                
3084:                	AssertChipSelect();
9D01E238  3C03BF88   LUI V1, -16504
9D01E23C  8C626160   LW V0, 24928(V1)
9D01E240  7C026304   INS V0, ZERO, 12, 1
9D01E244  AC626160   SW V0, 24928(V1)
3085:                	ClearSPIDoneFlag();
3086:                	ENC100_SSPBUF = vOpcode;				// Send the command/opcode
9D01E248  93C30010   LBU V1, 16(S8)
9D01E24C  3C02BF80   LUI V0, -16512
9D01E250  AC435A20   SW V1, 23072(V0)
3087:                	WaitForDataByte();
3088:                	vDummy = ENC100_SSPBUF;
9D01E27C  3C02BF80   LUI V0, -16512
9D01E280  8C425A20   LW V0, 23072(V0)
9D01E284  304200FF   ANDI V0, V0, 255
9D01E288  A3C20004   SB V0, 4(S8)
3089:                
3090:                	while(wDataLen--)
9D01E28C  0B4078BB   J 0x9D01E2EC
9D01E290  00000000   NOP
9D01E2EC  97C20018   LHU V0, 24(S8)
9D01E2F0  0002102B   SLTU V0, ZERO, V0
9D01E2F4  304200FF   ANDI V0, V0, 255
9D01E2F8  97C30018   LHU V1, 24(S8)
9D01E2FC  2463FFFF   ADDIU V1, V1, -1
9D01E300  A7C30018   SH V1, 24(S8)
9D01E304  1440FFE3   BNE V0, ZERO, 0x9D01E294
9D01E308  00000000   NOP
3091:                	{
3092:                		ENC100_SSPBUF = *vData++;
9D01E294  8FC20014   LW V0, 20(S8)
9D01E298  90420000   LBU V0, 0(V0)
9D01E29C  00401821   ADDU V1, V0, ZERO
9D01E2A0  3C02BF80   LUI V0, -16512
9D01E2A4  AC435A20   SW V1, 23072(V0)
9D01E2A8  8FC20014   LW V0, 20(S8)
9D01E2AC  24420001   ADDIU V0, V0, 1
9D01E2B0  AFC20014   SW V0, 20(S8)
3093:                		WaitForDataByte();
3094:                		vDummy = ENC100_SSPBUF;
9D01E2DC  3C02BF80   LUI V0, -16512
9D01E2E0  8C425A20   LW V0, 23072(V0)
9D01E2E4  304200FF   ANDI V0, V0, 255
9D01E2E8  A3C20004   SB V0, 4(S8)
3095:                	}
3096:                	DeassertChipSelect();
9D01E30C  3C03BF88   LUI V1, -16504
9D01E310  8C626160   LW V0, 24928(V1)
9D01E314  24040001   ADDIU A0, ZERO, 1
9D01E318  7C826304   INS V0, A0, 12, 1
9D01E31C  AC626160   SW V0, 24928(V1)
3097:                
3098:                	#if defined(ENC100_ISR_ENABLE) && defined(ENC100_INT_TRIS)
3099:                		ENC100_ISR_ENABLE = bISREnabled;
9D01E320  8FC20000   LW V0, 0(S8)
9D01E324  304200FF   ANDI V0, V0, 255
9D01E328  30420001   ANDI V0, V0, 1
9D01E32C  304400FF   ANDI A0, V0, 255
9D01E330  3C03BF88   LUI V1, -16504
9D01E334  8C621060   LW V0, 4192(V1)
9D01E338  7C829CC4   INS V0, A0, 19, 1
9D01E33C  AC621060   SW V0, 4192(V1)
3100:                	#endif
3101:                }
9D01E340  03C0E821   ADDU SP, S8, ZERO
9D01E344  8FBE000C   LW S8, 12(SP)
9D01E348  27BD0010   ADDIU SP, SP, 16
9D01E34C  03E00008   JR RA
9D01E350  00000000   NOP
3102:                
3103:                #endif
3104:                
3105:                /******************************************************************************
3106:                 * Function:        WORD ReadReg(WORD wAddress)
3107:                 *
3108:                 * PreCondition:    SPI/PSP bus must be initialized (done in MACInit()).
3109:                 *
3110:                 * Input:           wAddress: Address of SFR register to read from.  
3111:                 *							  The LSb is ignored and treated as '0' always.
3112:                 *
3113:                 * Output:          WORD value of register contents
3114:                 *
3115:                 * Side Effects:    None
3116:                 *
3117:                 * Overview:        Selects the correct bank (if needed), and reads the 
3118:                 *					corresponding 16-bit register
3119:                 *
3120:                 * Note:            This routine cannot be used to read PHY registers.  
3121:                 *					Use the ReadPHYReg() function to read from PHY registers.
3122:                 *****************************************************************************/
3123:                static WORD ReadReg(WORD wAddress)
3124:                {
9D01E354  27BDFFE0   ADDIU SP, SP, -32
9D01E358  AFBF001C   SW RA, 28(SP)
9D01E35C  AFBE0018   SW S8, 24(SP)
9D01E360  03A0F021   ADDU S8, SP, ZERO
9D01E364  00801021   ADDU V0, A0, ZERO
9D01E368  A7C20020   SH V0, 32(S8)
3125:                	#if (ENC100_INTERFACE_MODE >= 1)	// Parallel mode
3126:                	{
3127:                		WORD w;
3128:                		
3129:                		ReadMemory(wAddress, (BYTE*)&w, 2);
3130:                		return w;
3131:                	}
3132:                	#else	// SPI mode
3133:                	{
3134:                		WORD w;
3135:                		BYTE vBank;
3136:                		
3137:                		// See if we need to change register banks
3138:                		vBank = ((BYTE)wAddress) & 0xE0;
9D01E36C  97C20020   LHU V0, 32(S8)
9D01E370  304300FF   ANDI V1, V0, 255
9D01E374  2402FFE0   ADDIU V0, ZERO, -32
9D01E378  00621024   AND V0, V1, V0
9D01E37C  A3C20010   SB V0, 16(S8)
3139:                		if(vBank <= (0x3u<<5))
9D01E380  93C20010   LBU V0, 16(S8)
9D01E384  2C420061   SLTIU V0, V0, 97
9D01E388  10400032   BEQ V0, ZERO, 0x9D01E454
9D01E38C  00000000   NOP
3140:                		{
3141:                			if(vBank != vCurrentBank)
9D01E390  93828100   LBU V0, -32512(GP)
9D01E394  93C30010   LBU V1, 16(S8)
9D01E398  10620024   BEQ V1, V0, 0x9D01E42C
9D01E39C  00000000   NOP
3142:                			{
3143:                				if(vBank == (0x0u<<5))
9D01E3A0  93C20010   LBU V0, 16(S8)
9D01E3A4  14400006   BNE V0, ZERO, 0x9D01E3C0
9D01E3A8  00000000   NOP
3144:                					Execute0(B0SEL);
9D01E3AC  240400C0   ADDIU A0, ZERO, 192
9D01E3B0  0F407713   JAL 0x9D01DC4C
9D01E3B4  00000000   NOP
9D01E3B8  0B407909   J 0x9D01E424
9D01E3BC  00000000   NOP
3145:                				else if(vBank == (0x1u<<5))
9D01E3C0  93C30010   LBU V1, 16(S8)
9D01E3C4  24020020   ADDIU V0, ZERO, 32
9D01E3C8  14620006   BNE V1, V0, 0x9D01E3E4
9D01E3CC  00000000   NOP
3146:                					Execute0(B1SEL);
9D01E3D0  240400C2   ADDIU A0, ZERO, 194
9D01E3D4  0F407713   JAL 0x9D01DC4C
9D01E3D8  00000000   NOP
9D01E3DC  0B407909   J 0x9D01E424
9D01E3E0  00000000   NOP
3147:                				else if(vBank == (0x2u<<5))
9D01E3E4  93C30010   LBU V1, 16(S8)
9D01E3E8  24020040   ADDIU V0, ZERO, 64
9D01E3EC  14620006   BNE V1, V0, 0x9D01E408
9D01E3F0  00000000   NOP
3148:                					Execute0(B2SEL);
9D01E3F4  240400C4   ADDIU A0, ZERO, 196
9D01E3F8  0F407713   JAL 0x9D01DC4C
9D01E3FC  00000000   NOP
9D01E400  0B407909   J 0x9D01E424
9D01E404  00000000   NOP
3149:                				else if(vBank == (0x3u<<5))
9D01E408  93C30010   LBU V1, 16(S8)
9D01E40C  24020060   ADDIU V0, ZERO, 96
9D01E410  14620004   BNE V1, V0, 0x9D01E424
9D01E414  00000000   NOP
3150:                					Execute0(B3SEL);
9D01E418  240400C6   ADDIU A0, ZERO, 198
9D01E41C  0F407713   JAL 0x9D01DC4C
9D01E420  00000000   NOP
3151:                					
3152:                				vCurrentBank = vBank;
9D01E424  93C20010   LBU V0, 16(S8)
9D01E428  A3828100   SB V0, -32512(GP)
3153:                			}
3154:                		
3155:                			w = Execute2(RCR | (wAddress & 0x1F), 0x0000);
9D01E42C  97C20020   LHU V0, 32(S8)
9D01E430  304200FF   ANDI V0, V0, 255
9D01E434  3042001F   ANDI V0, V0, 31
9D01E438  00402021   ADDU A0, V0, ZERO
9D01E43C  00002821   ADDU A1, ZERO, ZERO
9D01E440  0F407748   JAL 0x9D01DD20
9D01E444  00000000   NOP
9D01E448  A7C20012   SH V0, 18(S8)
9D01E44C  0B407926   J 0x9D01E498
9D01E450  00000000   NOP
3156:                		}
3157:                		else
3158:                		{
3159:                			DWORD dw = Execute3(RCRU, (DWORD)wAddress);
9D01E454  97C20020   LHU V0, 32(S8)
9D01E458  24040020   ADDIU A0, ZERO, 32
9D01E45C  00402821   ADDU A1, V0, ZERO
9D01E460  0F4077AC   JAL 0x9D01DEB0
9D01E464  00000000   NOP
9D01E468  AFC20014   SW V0, 20(S8)
3160:                			((BYTE*)&w)[0] = ((BYTE*)&dw)[1];
9D01E46C  27C20012   ADDIU V0, S8, 18
9D01E470  27C30014   ADDIU V1, S8, 20
9D01E474  24630001   ADDIU V1, V1, 1
9D01E478  90630000   LBU V1, 0(V1)
9D01E47C  A0430000   SB V1, 0(V0)
3161:                			((BYTE*)&w)[1] = ((BYTE*)&dw)[2];
9D01E480  27C20012   ADDIU V0, S8, 18
9D01E484  24420001   ADDIU V0, V0, 1
9D01E488  27C30014   ADDIU V1, S8, 20
9D01E48C  24630002   ADDIU V1, V1, 2
9D01E490  90630000   LBU V1, 0(V1)
9D01E494  A0430000   SB V1, 0(V0)
3162:                		}
3163:                
3164:                		return w;
9D01E498  97C20012   LHU V0, 18(S8)
3165:                	}
3166:                	#endif
3167:                }//end ReadReg
9D01E49C  03C0E821   ADDU SP, S8, ZERO
9D01E4A0  8FBF001C   LW RA, 28(SP)
9D01E4A4  8FBE0018   LW S8, 24(SP)
9D01E4A8  27BD0020   ADDIU SP, SP, 32
9D01E4AC  03E00008   JR RA
9D01E4B0  00000000   NOP
3168:                
3169:                
3170:                /******************************************************************************
3171:                 * Function:        void WriteReg(WORD wAddress, WORD wValue)
3172:                 *
3173:                 * PreCondition:    SPI/PSP bus must be initialized (done in MACInit()).
3174:                 *
3175:                 * Input:           wAddress: Address of the SFR register to write to.  
3176:                 *					16-bit WORD to be written into the register.
3177:                 *
3178:                 * Output:          None
3179:                 *
3180:                 * Side Effects:    None
3181:                 *
3182:                 * Overview:        Selects the correct bank (if using the SPI and needed), and 
3183:                 *					writes the corresponding 16-bit register with wValue.
3184:                 *
3185:                 * Note:            This routine cannot write to PHY registers.  Use the 
3186:                 *					WritePHYReg() function for writing to PHY registers.
3187:                 *****************************************************************************/
3188:                static void WriteReg(WORD wAddress, WORD wValue)
3189:                {
9D01E4B4  27BDFFE0   ADDIU SP, SP, -32
9D01E4B8  AFBF001C   SW RA, 28(SP)
9D01E4BC  AFBE0018   SW S8, 24(SP)
9D01E4C0  03A0F021   ADDU S8, SP, ZERO
9D01E4C4  00801821   ADDU V1, A0, ZERO
9D01E4C8  00A01021   ADDU V0, A1, ZERO
9D01E4CC  A7C30020   SH V1, 32(S8)
9D01E4D0  A7C20024   SH V0, 36(S8)
3190:                	#if (ENC100_INTERFACE_MODE >= 1)	// Parallel mode
3191:                	{
3192:                		WriteMemory(wAddress, (BYTE*)&wValue, 2);
3193:                	}
3194:                	#else	// SPI mode
3195:                	{
3196:                		BYTE vBank;
3197:                		
3198:                		// See if we need to change register banks
3199:                		vBank = ((BYTE)wAddress) & 0xE0;
9D01E4D4  97C20020   LHU V0, 32(S8)
9D01E4D8  304300FF   ANDI V1, V0, 255
9D01E4DC  2402FFE0   ADDIU V0, ZERO, -32
9D01E4E0  00621024   AND V0, V1, V0
9D01E4E4  A3C20010   SB V0, 16(S8)
3200:                		if(vBank <= (0x3u<<5))
9D01E4E8  93C20010   LBU V0, 16(S8)
9D01E4EC  2C420061   SLTIU V0, V0, 97
9D01E4F0  10400036   BEQ V0, ZERO, 0x9D01E5CC
9D01E4F4  00000000   NOP
3201:                		{
3202:                			if(vBank != vCurrentBank)
9D01E4F8  93828100   LBU V0, -32512(GP)
9D01E4FC  93C30010   LBU V1, 16(S8)
9D01E500  10620024   BEQ V1, V0, 0x9D01E594
9D01E504  00000000   NOP
3203:                			{
3204:                				if(vBank == (0x0u<<5))
9D01E508  93C20010   LBU V0, 16(S8)
9D01E50C  14400006   BNE V0, ZERO, 0x9D01E528
9D01E510  00000000   NOP
3205:                					Execute0(B0SEL);
9D01E514  240400C0   ADDIU A0, ZERO, 192
9D01E518  0F407713   JAL 0x9D01DC4C
9D01E51C  00000000   NOP
9D01E520  0B407963   J 0x9D01E58C
9D01E524  00000000   NOP
3206:                				else if(vBank == (0x1u<<5))
9D01E528  93C30010   LBU V1, 16(S8)
9D01E52C  24020020   ADDIU V0, ZERO, 32
9D01E530  14620006   BNE V1, V0, 0x9D01E54C
9D01E534  00000000   NOP
3207:                					Execute0(B1SEL);
9D01E538  240400C2   ADDIU A0, ZERO, 194
9D01E53C  0F407713   JAL 0x9D01DC4C
9D01E540  00000000   NOP
9D01E544  0B407963   J 0x9D01E58C
9D01E548  00000000   NOP
3208:                				else if(vBank == (0x2u<<5))
9D01E54C  93C30010   LBU V1, 16(S8)
9D01E550  24020040   ADDIU V0, ZERO, 64
9D01E554  14620006   BNE V1, V0, 0x9D01E570
9D01E558  00000000   NOP
3209:                					Execute0(B2SEL);
9D01E55C  240400C4   ADDIU A0, ZERO, 196
9D01E560  0F407713   JAL 0x9D01DC4C
9D01E564  00000000   NOP
9D01E568  0B407963   J 0x9D01E58C
9D01E56C  00000000   NOP
3210:                				else if(vBank == (0x3u<<5))
9D01E570  93C30010   LBU V1, 16(S8)
9D01E574  24020060   ADDIU V0, ZERO, 96
9D01E578  14620004   BNE V1, V0, 0x9D01E58C
9D01E57C  00000000   NOP
3211:                					Execute0(B3SEL);
9D01E580  240400C6   ADDIU A0, ZERO, 198
9D01E584  0F407713   JAL 0x9D01DC4C
9D01E588  00000000   NOP
3212:                	
3213:                				vCurrentBank = vBank;
9D01E58C  93C20010   LBU V0, 16(S8)
9D01E590  A3828100   SB V0, -32512(GP)
3214:                			}
3215:                		
3216:                			Execute2(WCR | (wAddress & 0x1F), wValue);
9D01E594  97C20020   LHU V0, 32(S8)
9D01E598  304200FF   ANDI V0, V0, 255
9D01E59C  3042001F   ANDI V0, V0, 31
9D01E5A0  304200FF   ANDI V0, V0, 255
9D01E5A4  34420040   ORI V0, V0, 64
9D01E5A8  304200FF   ANDI V0, V0, 255
9D01E5AC  00401821   ADDU V1, V0, ZERO
9D01E5B0  97C20024   LHU V0, 36(S8)
9D01E5B4  00602021   ADDU A0, V1, ZERO
9D01E5B8  00402821   ADDU A1, V0, ZERO
9D01E5BC  0F407748   JAL 0x9D01DD20
9D01E5C0  00000000   NOP
9D01E5C4  0B407987   J 0x9D01E61C
9D01E5C8  00000000   NOP
3217:                		}
3218:                		else
3219:                		{
3220:                			DWORD dw;
3221:                			((BYTE*)&dw)[0] = (BYTE)wAddress;
9D01E5CC  27C20014   ADDIU V0, S8, 20
9D01E5D0  97C30020   LHU V1, 32(S8)
9D01E5D4  306300FF   ANDI V1, V1, 255
9D01E5D8  A0430000   SB V1, 0(V0)
3222:                			((BYTE*)&dw)[1] = ((BYTE*)&wValue)[0];
9D01E5DC  27C20014   ADDIU V0, S8, 20
9D01E5E0  24420001   ADDIU V0, V0, 1
9D01E5E4  27C30024   ADDIU V1, S8, 36
9D01E5E8  90630000   LBU V1, 0(V1)
9D01E5EC  A0430000   SB V1, 0(V0)
3223:                			((BYTE*)&dw)[2] = ((BYTE*)&wValue)[1];
9D01E5F0  27C20014   ADDIU V0, S8, 20
9D01E5F4  24420002   ADDIU V0, V0, 2
9D01E5F8  27C30024   ADDIU V1, S8, 36
9D01E5FC  24630001   ADDIU V1, V1, 1
9D01E600  90630000   LBU V1, 0(V1)
9D01E604  A0430000   SB V1, 0(V0)
3224:                			Execute3(WCRU, dw);
9D01E608  8FC20014   LW V0, 20(S8)
9D01E60C  24040022   ADDIU A0, ZERO, 34
9D01E610  00402821   ADDU A1, V0, ZERO
9D01E614  0F4077AC   JAL 0x9D01DEB0
9D01E618  00000000   NOP
3225:                		}
3226:                			
3227:                	}
3228:                	#endif
3229:                }//end WriteReg
9D01E61C  03C0E821   ADDU SP, S8, ZERO
9D01E620  8FBF001C   LW RA, 28(SP)
9D01E624  8FBE0018   LW S8, 24(SP)
9D01E628  27BD0020   ADDIU SP, SP, 32
9D01E62C  03E00008   JR RA
9D01E630  00000000   NOP
3230:                
3231:                
3232:                /******************************************************************************
3233:                 * Function:        void BFSReg(WORD wAddress, WORD wBitMask)
3234:                 *					void BFCReg(WORD wAddress, WORD wBitMask)
3235:                 *
3236:                 * PreCondition:    None
3237:                 *
3238:                 * Input:           7 bit address of the register to write to.  
3239:                 *					16-bit WORD bitmask to set/clear in the register.
3240:                 *
3241:                 * Output:          None
3242:                 *
3243:                 * Side Effects:    None
3244:                 *
3245:                 * Overview:        Sets/clears bits in Ethernet SFR registers
3246:                 *
3247:                 * Note:            These functions cannot be used to access ESFR registers.
3248:                 *****************************************************************************/
3249:                static void BFSReg(WORD wAddress, WORD wBitMask)
3250:                {
9D01E634  27BDFFE0   ADDIU SP, SP, -32
9D01E638  AFBF001C   SW RA, 28(SP)
9D01E63C  AFBE0018   SW S8, 24(SP)
9D01E640  03A0F021   ADDU S8, SP, ZERO
9D01E644  00801821   ADDU V1, A0, ZERO
9D01E648  00A01021   ADDU V0, A1, ZERO
9D01E64C  A7C30020   SH V1, 32(S8)
9D01E650  A7C20024   SH V0, 36(S8)
3251:                	#if (ENC100_INTERFACE_MODE >= 1)	// Parallel mode
3252:                	{
3253:                		WriteMemory(wAddress+SET_OFFSET, (BYTE*)&wBitMask, 2);
3254:                	}
3255:                	#else	// SPI mode
3256:                	{
3257:                		BYTE vBank;
3258:                		
3259:                		// See if we need to change register banks
3260:                		vBank = ((BYTE)wAddress) & 0xE0;
9D01E654  97C20020   LHU V0, 32(S8)
9D01E658  304300FF   ANDI V1, V0, 255
9D01E65C  2402FFE0   ADDIU V0, ZERO, -32
9D01E660  00621024   AND V0, V1, V0
9D01E664  A3C20010   SB V0, 16(S8)
3261:                		if(vBank != vCurrentBank)
9D01E668  93828100   LBU V0, -32512(GP)
9D01E66C  93C30010   LBU V1, 16(S8)
9D01E670  10620024   BEQ V1, V0, 0x9D01E704
9D01E674  00000000   NOP
3262:                		{
3263:                			if(vBank == (0x0u<<5))
9D01E678  93C20010   LBU V0, 16(S8)
9D01E67C  14400006   BNE V0, ZERO, 0x9D01E698
9D01E680  00000000   NOP
3264:                				Execute0(B0SEL);
9D01E684  240400C0   ADDIU A0, ZERO, 192
9D01E688  0F407713   JAL 0x9D01DC4C
9D01E68C  00000000   NOP
9D01E690  0B4079BF   J 0x9D01E6FC
9D01E694  00000000   NOP
3265:                			else if(vBank == (0x1u<<5))
9D01E698  93C30010   LBU V1, 16(S8)
9D01E69C  24020020   ADDIU V0, ZERO, 32
9D01E6A0  14620006   BNE V1, V0, 0x9D01E6BC
9D01E6A4  00000000   NOP
3266:                				Execute0(B1SEL);
9D01E6A8  240400C2   ADDIU A0, ZERO, 194
9D01E6AC  0F407713   JAL 0x9D01DC4C
9D01E6B0  00000000   NOP
9D01E6B4  0B4079BF   J 0x9D01E6FC
9D01E6B8  00000000   NOP
3267:                			else if(vBank == (0x2u<<5))
9D01E6BC  93C30010   LBU V1, 16(S8)
9D01E6C0  24020040   ADDIU V0, ZERO, 64
9D01E6C4  14620006   BNE V1, V0, 0x9D01E6E0
9D01E6C8  00000000   NOP
3268:                				Execute0(B2SEL);
9D01E6CC  240400C4   ADDIU A0, ZERO, 196
9D01E6D0  0F407713   JAL 0x9D01DC4C
9D01E6D4  00000000   NOP
9D01E6D8  0B4079BF   J 0x9D01E6FC
9D01E6DC  00000000   NOP
3269:                			else if(vBank == (0x3u<<5))
9D01E6E0  93C30010   LBU V1, 16(S8)
9D01E6E4  24020060   ADDIU V0, ZERO, 96
9D01E6E8  14620004   BNE V1, V0, 0x9D01E6FC
9D01E6EC  00000000   NOP
3270:                				Execute0(B3SEL);
9D01E6F0  240400C6   ADDIU A0, ZERO, 198
9D01E6F4  0F407713   JAL 0x9D01DC4C
9D01E6F8  00000000   NOP
3271:                
3272:                			vCurrentBank = vBank;
9D01E6FC  93C20010   LBU V0, 16(S8)
9D01E700  A3828100   SB V0, -32512(GP)
3273:                		}
3274:                	
3275:                		Execute2(BFS | (wAddress & 0x1F), wBitMask);
9D01E704  97C20020   LHU V0, 32(S8)
9D01E708  304200FF   ANDI V0, V0, 255
9D01E70C  3042001F   ANDI V0, V0, 31
9D01E710  304300FF   ANDI V1, V0, 255
9D01E714  2402FF80   ADDIU V0, ZERO, -128
9D01E718  00621025   OR V0, V1, V0
9D01E71C  304200FF   ANDI V0, V0, 255
9D01E720  00401821   ADDU V1, V0, ZERO
9D01E724  97C20024   LHU V0, 36(S8)
9D01E728  00602021   ADDU A0, V1, ZERO
9D01E72C  00402821   ADDU A1, V0, ZERO
9D01E730  0F407748   JAL 0x9D01DD20
9D01E734  00000000   NOP
3276:                	}
3277:                	#endif
3278:                }//end BFSReg
9D01E738  03C0E821   ADDU SP, S8, ZERO
9D01E73C  8FBF001C   LW RA, 28(SP)
9D01E740  8FBE0018   LW S8, 24(SP)
9D01E744  27BD0020   ADDIU SP, SP, 32
9D01E748  03E00008   JR RA
9D01E74C  00000000   NOP
3279:                
3280:                static void BFCReg(WORD wAddress, WORD wBitMask)
3281:                {
9D01E750  27BDFFE0   ADDIU SP, SP, -32
9D01E754  AFBF001C   SW RA, 28(SP)
9D01E758  AFBE0018   SW S8, 24(SP)
9D01E75C  03A0F021   ADDU S8, SP, ZERO
9D01E760  00801821   ADDU V1, A0, ZERO
9D01E764  00A01021   ADDU V0, A1, ZERO
9D01E768  A7C30020   SH V1, 32(S8)
9D01E76C  A7C20024   SH V0, 36(S8)
3282:                	#if (ENC100_INTERFACE_MODE >= 1)	// Parallel mode
3283:                	{
3284:                		WriteMemory(wAddress+CLR_OFFSET, (BYTE*)&wBitMask, 2);
3285:                	}
3286:                	#else	// SPI mode
3287:                	{
3288:                		BYTE vBank;
3289:                		
3290:                		// See if we need to change register banks
3291:                		vBank = ((BYTE)wAddress) & 0xE0;
9D01E770  97C20020   LHU V0, 32(S8)
9D01E774  304300FF   ANDI V1, V0, 255
9D01E778  2402FFE0   ADDIU V0, ZERO, -32
9D01E77C  00621024   AND V0, V1, V0
9D01E780  A3C20010   SB V0, 16(S8)
3292:                		if(vBank != vCurrentBank)
9D01E784  93828100   LBU V0, -32512(GP)
9D01E788  93C30010   LBU V1, 16(S8)
9D01E78C  10620024   BEQ V1, V0, 0x9D01E820
9D01E790  00000000   NOP
3293:                		{
3294:                			if(vBank == (0x0u<<5))
9D01E794  93C20010   LBU V0, 16(S8)
9D01E798  14400006   BNE V0, ZERO, 0x9D01E7B4
9D01E79C  00000000   NOP
3295:                				Execute0(B0SEL);
9D01E7A0  240400C0   ADDIU A0, ZERO, 192
9D01E7A4  0F407713   JAL 0x9D01DC4C
9D01E7A8  00000000   NOP
9D01E7AC  0B407A06   J 0x9D01E818
9D01E7B0  00000000   NOP
3296:                			else if(vBank == (0x1u<<5))
9D01E7B4  93C30010   LBU V1, 16(S8)
9D01E7B8  24020020   ADDIU V0, ZERO, 32
9D01E7BC  14620006   BNE V1, V0, 0x9D01E7D8
9D01E7C0  00000000   NOP
3297:                				Execute0(B1SEL);
9D01E7C4  240400C2   ADDIU A0, ZERO, 194
9D01E7C8  0F407713   JAL 0x9D01DC4C
9D01E7CC  00000000   NOP
9D01E7D0  0B407A06   J 0x9D01E818
9D01E7D4  00000000   NOP
3298:                			else if(vBank == (0x2u<<5))
9D01E7D8  93C30010   LBU V1, 16(S8)
9D01E7DC  24020040   ADDIU V0, ZERO, 64
9D01E7E0  14620006   BNE V1, V0, 0x9D01E7FC
9D01E7E4  00000000   NOP
3299:                				Execute0(B2SEL);
9D01E7E8  240400C4   ADDIU A0, ZERO, 196
9D01E7EC  0F407713   JAL 0x9D01DC4C
9D01E7F0  00000000   NOP
9D01E7F4  0B407A06   J 0x9D01E818
9D01E7F8  00000000   NOP
3300:                			else if(vBank == (0x3u<<5))
9D01E7FC  93C30010   LBU V1, 16(S8)
9D01E800  24020060   ADDIU V0, ZERO, 96
9D01E804  14620004   BNE V1, V0, 0x9D01E818
9D01E808  00000000   NOP
3301:                				Execute0(B3SEL);
9D01E80C  240400C6   ADDIU A0, ZERO, 198
9D01E810  0F407713   JAL 0x9D01DC4C
9D01E814  00000000   NOP
3302:                
3303:                			vCurrentBank = vBank;
9D01E818  93C20010   LBU V0, 16(S8)
9D01E81C  A3828100   SB V0, -32512(GP)
3304:                		}
3305:                	
3306:                		Execute2(BFC | (wAddress & 0x1F), wBitMask);
9D01E820  97C20020   LHU V0, 32(S8)
9D01E824  304200FF   ANDI V0, V0, 255
9D01E828  3042001F   ANDI V0, V0, 31
9D01E82C  304300FF   ANDI V1, V0, 255
9D01E830  2402FFA0   ADDIU V0, ZERO, -96
9D01E834  00621025   OR V0, V1, V0
9D01E838  304200FF   ANDI V0, V0, 255
9D01E83C  00401821   ADDU V1, V0, ZERO
9D01E840  97C20024   LHU V0, 36(S8)
9D01E844  00602021   ADDU A0, V1, ZERO
9D01E848  00402821   ADDU A1, V0, ZERO
9D01E84C  0F407748   JAL 0x9D01DD20
9D01E850  00000000   NOP
3307:                	}
3308:                	#endif
3309:                }//end BFCReg
9D01E854  03C0E821   ADDU SP, S8, ZERO
9D01E858  8FBF001C   LW RA, 28(SP)
9D01E85C  8FBE0018   LW S8, 24(SP)
9D01E860  27BD0020   ADDIU SP, SP, 32
9D01E864  03E00008   JR RA
9D01E868  00000000   NOP
3310:                
3311:                
3312:                /******************************************************************************
3313:                 * Function:        WORD ReadPHYReg(BYTE Register)
3314:                 *
3315:                 * PreCondition:    SPI bus must be initialized (done in MACInit()).
3316:                 *
3317:                 * Input:           Address of the PHY register to read from.
3318:                 *
3319:                 * Output:          16 bits of data read from the PHY register.
3320:                 *
3321:                 * Side Effects:    None
3322:                 *
3323:                 * Overview:        ReadPHYReg performs an MII read operation.  While in 
3324:                 *					progress, it simply polls the MII BUSY bit wasting time 
3325:                 *					(25.6us).
3326:                 *
3327:                 * Note:            None
3328:                 *****************************************************************************/
3329:                WORD ReadPHYReg(BYTE Register)
3330:                {
9D01E86C  27BDFFE0   ADDIU SP, SP, -32
9D01E870  AFBF001C   SW RA, 28(SP)
9D01E874  AFBE0018   SW S8, 24(SP)
9D01E878  03A0F021   ADDU S8, SP, ZERO
9D01E87C  00801021   ADDU V0, A0, ZERO
9D01E880  A3C20020   SB V0, 32(S8)
3331:                	WORD wResult;
3332:                
3333:                	// Set the right address and start the register read operation
3334:                	WriteReg(MIREGADR, 0x0100 | Register);
9D01E884  93C20020   LBU V0, 32(S8)
9D01E888  3042FFFF   ANDI V0, V0, -1
9D01E88C  34420100   ORI V0, V0, 256
9D01E890  3042FFFF   ANDI V0, V0, -1
9D01E894  24040054   ADDIU A0, ZERO, 84
9D01E898  00402821   ADDU A1, V0, ZERO
9D01E89C  0F40792D   JAL 0x9D01E4B4
9D01E8A0  00000000   NOP
3335:                	WriteReg(MICMD, MICMD_MIIRD);
9D01E8A4  24040052   ADDIU A0, ZERO, 82
9D01E8A8  24050001   ADDIU A1, ZERO, 1
9D01E8AC  0F40792D   JAL 0x9D01E4B4
9D01E8B0  00000000   NOP
3336:                
3337:                	// Loop to wait until the PHY register has been read through the MII
3338:                	// This requires 25.6us
3339:                	while(ReadReg(MISTAT) & MISTAT_BUSY);
9D01E8B4  00000000   NOP
9D01E8B8  2404006A   ADDIU A0, ZERO, 106
9D01E8BC  0F4078D5   JAL 0x9D01E354
9D01E8C0  00000000   NOP
9D01E8C4  30420001   ANDI V0, V0, 1
9D01E8C8  304200FF   ANDI V0, V0, 255
9D01E8CC  1440FFFA   BNE V0, ZERO, 0x9D01E8B8
9D01E8D0  00000000   NOP
3340:                
3341:                	// Stop reading
3342:                	WriteReg(MICMD, 0x0000);
9D01E8D4  24040052   ADDIU A0, ZERO, 82
9D01E8D8  00002821   ADDU A1, ZERO, ZERO
9D01E8DC  0F40792D   JAL 0x9D01E4B4
9D01E8E0  00000000   NOP
3343:                	
3344:                	// Obtain results and return
3345:                	wResult = ReadReg(MIRD);
9D01E8E4  24040068   ADDIU A0, ZERO, 104
9D01E8E8  0F4078D5   JAL 0x9D01E354
9D01E8EC  00000000   NOP
9D01E8F0  A7C20010   SH V0, 16(S8)
3346:                
3347:                	return wResult;
9D01E8F4  97C20010   LHU V0, 16(S8)
3348:                }//end ReadPHYReg
9D01E8F8  03C0E821   ADDU SP, S8, ZERO
9D01E8FC  8FBF001C   LW RA, 28(SP)
9D01E900  8FBE0018   LW S8, 24(SP)
9D01E904  27BD0020   ADDIU SP, SP, 32
9D01E908  03E00008   JR RA
9D01E90C  00000000   NOP
3349:                
3350:                /******************************************************************************
3351:                 * Function:        WritePHYReg
3352:                 *
3353:                 * PreCondition:    SPI bus must be initialized (done in MACInit()).
3354:                 *
3355:                 * Input:           Address of the PHY register to write to.
3356:                 *					16 bits of data to write to PHY register.
3357:                 *
3358:                 * Output:          None
3359:                 *
3360:                 * Side Effects:    None
3361:                 *
3362:                 * Overview:        WritePHYReg performs an MII write operation.  While in 
3363:                 *					progress, it simply polls the MII BUSY bit wasting time.
3364:                 *
3365:                 * Note:            None
3366:                 *****************************************************************************/
3367:                void WritePHYReg(BYTE Register, WORD Data)
3368:                {
9D01E910  27BDFFE8   ADDIU SP, SP, -24
9D01E914  AFBF0014   SW RA, 20(SP)
9D01E918  AFBE0010   SW S8, 16(SP)
9D01E91C  03A0F021   ADDU S8, SP, ZERO
9D01E920  00801821   ADDU V1, A0, ZERO
9D01E924  00A01021   ADDU V0, A1, ZERO
9D01E928  A3C30018   SB V1, 24(S8)
9D01E92C  A7C2001C   SH V0, 28(S8)
3369:                	// Write the register address
3370:                	WriteReg(MIREGADR,  0x0100 | Register);
9D01E930  93C20018   LBU V0, 24(S8)
9D01E934  3042FFFF   ANDI V0, V0, -1
9D01E938  34420100   ORI V0, V0, 256
9D01E93C  3042FFFF   ANDI V0, V0, -1
9D01E940  24040054   ADDIU A0, ZERO, 84
9D01E944  00402821   ADDU A1, V0, ZERO
9D01E948  0F40792D   JAL 0x9D01E4B4
9D01E94C  00000000   NOP
3371:                	
3372:                	// Write the data
3373:                	WriteReg(MIWR, Data);
9D01E950  97C2001C   LHU V0, 28(S8)
9D01E954  24040066   ADDIU A0, ZERO, 102
9D01E958  00402821   ADDU A1, V0, ZERO
9D01E95C  0F40792D   JAL 0x9D01E4B4
9D01E960  00000000   NOP
3374:                
3375:                	// Wait until the PHY register has been written
3376:                	while(ReadReg(MISTAT) & MISTAT_BUSY);
9D01E964  00000000   NOP
9D01E968  2404006A   ADDIU A0, ZERO, 106
9D01E96C  0F4078D5   JAL 0x9D01E354
9D01E970  00000000   NOP
9D01E974  30420001   ANDI V0, V0, 1
9D01E978  304200FF   ANDI V0, V0, 255
9D01E97C  1440FFFA   BNE V0, ZERO, 0x9D01E968
9D01E980  00000000   NOP
3377:                }//end WritePHYReg
9D01E984  03C0E821   ADDU SP, S8, ZERO
9D01E988  8FBF0014   LW RA, 20(SP)
9D01E98C  8FBE0010   LW S8, 16(SP)
9D01E990  27BD0018   ADDIU SP, SP, 24
9D01E994  03E00008   JR RA
9D01E998  00000000   NOP
3378:                
3379:                
3380:                
3381:                /*****************************************************************************
3382:                  Function:
3383:                	static void ToggleCRYPTEN(void)
3384:                
3385:                  Summary:
3386:                	Toggles the CRYPTEN (EIR<15>) cryptographic enable bit in an errata safe 
3387:                	way.
3388:                
3389:                  Description:
3390:                	Due to an ENC424J600/624J600 Rev. A2 silicon errata, it is not possible to 
3391:                	set or clear the CRYPTEN bit (EIR<15>) by using the BFSReg() or BFCReg() 
3392:                	functions.  Instead a register write to the volatile EIR interrupt flags 
3393:                	register is required.  This function reads EIR, toggles the CRYPTEN state, 
3394:                	and writes the value back to EIR in a manner that does not destroy or 
3395:                	glitch the interrupt states.
3396:                
3397:                  Precondition:
3398:                	None
3399:                
3400:                  Parameters:
3401:                	None
3402:                
3403:                  Returns:
3404:                	None
3405:                  ***************************************************************************/
3406:                static void ToggleCRYPTEN(void)
3407:                {
9D01E99C  27BDFFE0   ADDIU SP, SP, -32
9D01E9A0  AFBF001C   SW RA, 28(SP)
9D01E9A4  AFBE0018   SW S8, 24(SP)
9D01E9A8  03A0F021   ADDU S8, SP, ZERO
3408:                	WORD wLinkStat;
3409:                	WORD wInterruptEnable;
3410:                	
3411:                	// About to do read-modify-write to interrupt flags - disable interrupts 
3412:                	// temporarily.
3413:                	wInterruptEnable = ReadReg(EIE);
9D01E9AC  24040072   ADDIU A0, ZERO, 114
9D01E9B0  0F4078D5   JAL 0x9D01E354
9D01E9B4  00000000   NOP
9D01E9B8  A7C20010   SH V0, 16(S8)
3414:                	if(wInterruptEnable & EIE_INTIE)
9D01E9BC  87C20010   LH V0, 16(S8)
9D01E9C0  04410005   BGEZ V0, 0x9D01E9D8
9D01E9C4  00000000   NOP
3415:                		BFCReg(EIE, EIE_INTIE);
9D01E9C8  24040072   ADDIU A0, ZERO, 114
9D01E9CC  34058000   ORI A1, ZERO, -32768
9D01E9D0  0F4079D4   JAL 0x9D01E750
9D01E9D4  00000000   NOP
3416:                		
3417:                	// Get current link status so that we can regenerate LINKIF if it is missed
3418:                	wLinkStat = ReadReg(ESTAT);
9D01E9D8  2404001A   ADDIU A0, ZERO, 26
9D01E9DC  0F4078D5   JAL 0x9D01E354
9D01E9E0  00000000   NOP
9D01E9E4  A7C20012   SH V0, 18(S8)
3419:                	
3420:                	#if(ENC100_INTERFACE_MODE == 0)	// SPI
3421:                	{
3422:                		BYTE i;
3423:                		
3424:                		ReadN(RCR | EIRH, &i, 1);	// Read EIR high byte only
9D01E9E8  27C20014   ADDIU V0, S8, 20
9D01E9EC  2404001D   ADDIU A0, ZERO, 29
9D01E9F0  00402821   ADDU A1, V0, ZERO
9D01E9F4  24060001   ADDIU A2, ZERO, 1
9D01E9F8  0F407827   JAL 0x9D01E09C
9D01E9FC  00000000   NOP
3425:                		i ^= 0x80;					// Modify - toggle CRYPTEN	
9D01EA00  93C30014   LBU V1, 20(S8)
9D01EA04  2402FF80   ADDIU V0, ZERO, -128
9D01EA08  00621026   XOR V0, V1, V0
9D01EA0C  304200FF   ANDI V0, V0, 255
9D01EA10  A3C20014   SB V0, 20(S8)
3426:                		WriteN(WCR | EIRH, &i, 1);	// Write EIR high byte only
9D01EA14  27C20014   ADDIU V0, S8, 20
9D01EA18  2404005D   ADDIU A0, ZERO, 93
9D01EA1C  00402821   ADDU A1, V0, ZERO
9D01EA20  24060001   ADDIU A2, ZERO, 1
9D01EA24  0F40787D   JAL 0x9D01E1F4
9D01EA28  00000000   NOP
3427:                	}
3428:                	#elif(ENC100_INTERFACE_MODE == 1) || (ENC100_INTERFACE_MODE == 2) || (ENC100_INTERFACE_MODE == 5) || (ENC100_INTERFACE_MODE == 6) 	// 8-bit PSP modes
3429:                	{
3430:                		BYTE i;
3431:                		
3432:                		ReadMemory(EIRH, &i, 1);	// Read EIR high byte only
3433:                		i ^= 0x80;					// Modify - toggle CRYPTEN	
3434:                		WriteMemory(EIRH, &i, 1);	// Write EIR high byte only
3435:                	}
3436:                	#else	// 16-bit PSP
3437:                	{
3438:                		WORD w;
3439:                		
3440:                		// Wait for any pending transmit and DMA operations to complete so that 
3441:                		// the interrupt flags get set appropriately
3442:                		while(ReadReg(ECON1) & (ECON1_DMAST | ECON1_TXRTS));
3443:                
3444:                		// Turn on/off crypto enable
3445:                		ReadMemory(EIR, (BYTE*)&w, 2);	// Read EIR
3446:                		w ^= EIR_CRYPTEN;				// Modify - set CRYPTEN	
3447:                		WriteMemory(EIR, (BYTE*)&w, 2);	// Write EIR - has to be 16 bits
3448:                		
3449:                		// Regenerate packet counter full interrupt flag, PCFULIF, if it was 
3450:                		// missed (unlikley but possible) 
3451:                		if((ReadReg(ESTAT) & 0xFFu) == 0xFFu)
3452:                			BFSReg(EIR, EIR_PCFULIF);
3453:                	}
3454:                	#endif
3455:                
3456:                	// Generate link change interrupt if the status has changed while we were 
3457:                	// doing the read-modify-write operation (unlikely but possible)
3458:                	if((ReadReg(ESTAT) ^ wLinkStat) & ESTAT_PHYLNK)
9D01EA2C  2404001A   ADDIU A0, ZERO, 26
9D01EA30  0F4078D5   JAL 0x9D01E354
9D01EA34  00000000   NOP
9D01EA38  00401821   ADDU V1, V0, ZERO
9D01EA3C  97C20012   LHU V0, 18(S8)
9D01EA40  00621026   XOR V0, V1, V0
9D01EA44  3042FFFF   ANDI V0, V0, -1
9D01EA48  30420100   ANDI V0, V0, 256
9D01EA4C  10400005   BEQ V0, ZERO, 0x9D01EA64
9D01EA50  00000000   NOP
3459:                		BFSReg(EIR, EIR_LINKIF);
9D01EA54  2404001C   ADDIU A0, ZERO, 28
9D01EA58  24050800   ADDIU A1, ZERO, 2048
9D01EA5C  0F40798D   JAL 0x9D01E634
9D01EA60  00000000   NOP
3460:                		
3461:                	// Restore interrupts
3462:                	if(wInterruptEnable & EIE_INTIE)
9D01EA64  87C20010   LH V0, 16(S8)
9D01EA68  04410005   BGEZ V0, 0x9D01EA80
9D01EA6C  00000000   NOP
3463:                		BFSReg(EIE, EIE_INTIE);
9D01EA70  24040072   ADDIU A0, ZERO, 114
9D01EA74  34058000   ORI A1, ZERO, -32768
9D01EA78  0F40798D   JAL 0x9D01E634
9D01EA7C  00000000   NOP
3464:                }
9D01EA80  03C0E821   ADDU SP, S8, ZERO
9D01EA84  8FBF001C   LW RA, 28(SP)
9D01EA88  8FBE0018   LW S8, 24(SP)
9D01EA8C  27BD0020   ADDIU SP, SP, 32
9D01EA90  03E00008   JR RA
9D01EA94  00000000   NOP
3465:                
3466:                
3467:                /****************************************************************************
3468:                  Section:
3469:                	Global RSA Variables
3470:                  ***************************************************************************/
3471:                #if (defined(STACK_USE_SSL_SERVER) || defined(STACK_USE_SSL_CLIENT)) && (SSL_RSA_CLIENT_SIZE <= 1024)
3472:                
3473:                static SM_RSA smRSA;					// State machine variable
3474:                static BYTE keyLength;					// Length of the input key
3475:                static BYTE* vOutput;					// Where output should be stored
3476:                
3477:                extern ROM BYTE SSL_N[SSL_RSA_KEY_SIZE/8], SSL_D[SSL_RSA_KEY_SIZE/8];
3478:                
3479:                
3480:                /****************************************************************************
3481:                  Section:
3482:                	Function Implementations
3483:                  ***************************************************************************/
3484:                
3485:                /*****************************************************************************
3486:                  Function:
3487:                	void RSAInit(void)
3488:                
3489:                Deleted Only
3490:                  ***************************************************************************/
3491:                void RSAInit(void)
3492:                {
3493:                	smRSA = SM_RSA_IDLE;
3494:                }
3495:                
3496:                /*****************************************************************************
3497:                  Function:
3498:                	BOOL RSABeginUsage(RSA_OP op, WORD vKeyByteLen)
3499:                
3500:                Same
3501:                  ***************************************************************************/
3502:                BOOL RSABeginUsage(RSA_OP op, WORD vKeyByteLen)
3503:                {
3504:                	if(smRSA != SM_RSA_IDLE)
3505:                		return FALSE;
3506:                
3507:                	keyLength = vKeyByteLen;
3508:                	
3509:                	// ENCX24J600 modular exponentiation engine only supports 1024 bit, 768 bit, 
3510:                	// and 512 bit modulos.  Other values could cause the incorrect behavior so 
3511:                	// must be avoided.
3512:                	if(!((keyLength == 1024u/8u) || (keyLength == 768u/8u) || (keyLength == 512u/8u)))
3513:                		return FALSE;
3514:                
3515:                	// Set up the state machine
3516:                	if(op == RSA_OP_ENCRYPT)
3517:                	{
3518:                		smRSA = SM_RSA_ENCRYPT_START;
3519:                
3520:                		// Turn on Modular Exponentiation hardware engine
3521:                		if(!(ReadReg(EIR) & EIR_CRYPTEN))
3522:                			ToggleCRYPTEN();
3523:                	}
3524:                #if defined(STACK_USE_SSL_SERVER) || defined(STACK_USE_RSA_DECRYPT)
3525:                	else if(op == RSA_OP_DECRYPT)
3526:                	{
3527:                		WORD oldPtr;
3528:                
3529:                		smRSA = SM_RSA_DECRYPT_START;
3530:                
3531:                		// Turn on Modular Exponentiation hardware engine
3532:                		if(!(ReadReg(EIR) & EIR_CRYPTEN))
3533:                			ToggleCRYPTEN();
3534:                
3535:                	    // Copy the decryption key and DMA into palce
3536:                	    oldPtr = MACSetWritePtr(BASE_CRYPTOB_ADDR);
3537:                	    MACPutROMArray(SSL_D, keyLength);
3538:                	    MACMemCopyAsync(ENC100_MODEX_E, BASE_CRYPTOB_ADDR, 128);
3539:                	    while(!MACIsMemCopyDone());
3540:                
3541:                		// Copy the modulus and DMA into palce
3542:                		MACSetWritePtr(BASE_CRYPTOB_ADDR);
3543:                	    MACPutROMArray(SSL_N, keyLength);
3544:                	    MACMemCopyAsync(ENC100_MODEX_M, BASE_CRYPTOB_ADDR, 128);
3545:                	    while(!MACIsMemCopyDone());
3546:                
3547:                		// Restore the write pointer
3548:                		MACSetWritePtr(oldPtr);
3549:                	}
3550:                #endif
3551:                	else
3552:                		return FALSE;
3553:                
3554:                	return TRUE;
3555:                }
3556:                
3557:                /*****************************************************************************
3558:                  Function:
3559:                	void RSAEndUsage(void)
3560:                
3561:                Same
3562:                Need to clear MODEXST to cancel
3563:                  ***************************************************************************/
3564:                void RSAEndUsage(void)
3565:                {
3566:                	smRSA = SM_RSA_IDLE;
3567:                
3568:                	// Turn off Modular Exponentiation hardware engine to save power
3569:                	if(ReadReg(EIR) & EIR_CRYPTEN)
3570:                		ToggleCRYPTEN();
3571:                }
3572:                
3573:                /*****************************************************************************
3574:                  Function:
3575:                	void RSASetData(BYTE* data, WORD len, RSA_DATA_FORMAT format)
3576:                
3577:                Replaced
3578:                  ***************************************************************************/
3579:                void RSASetData(BYTE* data, WORD len, RSA_DATA_FORMAT format)
3580:                {
3581:                	WORD oldPtr;
3582:                	BYTE i;
3583:                	
3584:                	// Little-endian input is not supported for ENC624 hardware crypto
3585:                	if(format == RSA_LITTLE_ENDIAN)
3586:                		while(1);
3587:                		
3588:                	// Set the write pointer to reserved crypto area
3589:                    oldPtr = MACSetWritePtr(BASE_CRYPTOB_ADDR);
3590:                
3591:                	// Pad the input data according to PKCS #1 Block 2 if doing an encryption 
3592:                	// operation
3593:                	#if defined(STACK_USE_SSL_CLIENT) || defined(STACK_USE_RSA_ENCRYPT)
3594:                	{
3595:                		BYTE j;
3596:                		
3597:                		if(smRSA == SM_RSA_ENCRYPT_START)
3598:                		{
3599:                			if(len < keyLength-4)
3600:                			{
3601:                				MACPut(0x00);
3602:                				MACPut(0x02);
3603:                				for(i = len + 3; i < keyLength; i++)
3604:                				{
3605:                					do
3606:                					{
3607:                						j = RandomGet();
3608:                					} while(j == 0x00u);
3609:                					MACPut(j);
3610:                				}
3611:                				MACPut(0x00);
3612:                			}
3613:                		}
3614:                	}
3615:                	#endif
3616:                    
3617:                    // Left zero-pad the input for decrypt operations
3618:                    if(smRSA == SM_RSA_DECRYPT_START)
3619:                    {
3620:                	    for(i = len; i < keyLength; i++)
3621:                	    	MACPut(0x00);
3622:                	}
3623:                	
3624:                	// Copy data into ENCX24J600 and DMA into ModEx engine
3625:                    MACPutArray(data, len);
3626:                    MACMemCopyAsync(ENC100_MODEX_X, BASE_CRYPTOB_ADDR, 128);
3627:                
3628:                	// Restore the write pointer
3629:                	MACSetWritePtr(oldPtr);
3630:                		
3631:                	// Decrypt operations happen in place
3632:                	if(smRSA == SM_RSA_DECRYPT_START)
3633:                		RSASetResult(data, format);
3634:                
3635:                	// Wait for DMA engine to finish copying data into ModEx engine
3636:                    while(!MACIsMemCopyDone());
3637:                }
3638:                
3639:                /*****************************************************************************
3640:                  Function:
3641:                	void RSASetResult(BYTE* data, RSA_DATA_FORMAT format)
3642:                
3643:                Replaced
3644:                  ***************************************************************************/
3645:                void RSASetResult(BYTE* data, RSA_DATA_FORMAT format)
3646:                {	
3647:                	// Little-endian input is not supported for ENC624 hardware crypto
3648:                	if(format == RSA_LITTLE_ENDIAN)
3649:                		while(1);
3650:                		
3651:                	vOutput = data;
3652:                }
3653:                
3654:                /*****************************************************************************
3655:                  Function:
3656:                	void RSASetE(BYTE *data, BYTE len, RSA_DATA_FORMAT format)
3657:                
3658:                Replace
3659:                  ***************************************************************************/
3660:                #if defined(STACK_USE_RSA_ENCRYPT)
3661:                void RSASetE(BYTE* data, BYTE len, RSA_DATA_FORMAT format)
3662:                {
3663:                	WORD oldPtr;
3664:                	BYTE i;
3665:                	
3666:                	// Little-endian input is not supported for ENC624 hardware crypto
3667:                	if(format == RSA_LITTLE_ENDIAN)
3668:                		while(1);
3669:                		
3670:                	// Set the write pointer to reserved crypto area
3671:                    oldPtr = MACSetWritePtr(BASE_CRYPTOB_ADDR);
3672:                    
3673:                    // Zero-pad the input, copy data, and DMA into palce
3674:                    for(i = len; i < keyLength; i++)
3675:                    	MACPut(0x00);
3676:                    MACPutArray(data, len);
3677:                    MACMemCopyAsync(ENC100_MODEX_E, BASE_CRYPTOB_ADDR, 128);
3678:                    
3679:                	// Restore the write pointer
3680:                	MACSetWritePtr(oldPtr);
3681:                
3682:                	// Wait for DMA copy to ModEx to complete
3683:                    while(!MACIsMemCopyDone());
3684:                }
3685:                #endif
3686:                
3687:                /*****************************************************************************
3688:                  Function:
3689:                	void RSASetN(BYTE* data, RSA_DATA_FORMAT format)
3690:                
3691:                Replace
3692:                  ***************************************************************************/
3693:                #if defined(STACK_USE_RSA_ENCRYPT)
3694:                void RSASetN(BYTE* data, RSA_DATA_FORMAT format)
3695:                {
3696:                	WORD oldPtr;
3697:                	
3698:                	// Little-endian input is not supported for ENC624 hardware crypto
3699:                	if(format == RSA_LITTLE_ENDIAN)
3700:                		while(1);
3701:                		
3702:                	// Set the write pointer to reserved crypto area
3703:                    oldPtr = MACSetWritePtr(BASE_CRYPTOB_ADDR);
3704:                    
3705:                    // Copy data and DMA into palce
3706:                    MACPutArray(data, keyLength);
3707:                    MACMemCopyAsync(ENC100_MODEX_M, BASE_CRYPTOB_ADDR, 128);
3708:                    
3709:                	// Restore the write pointer
3710:                	MACSetWritePtr(oldPtr);
3711:                
3712:                	// Wait for DMA copy to ModEx to complete
3713:                    while(!MACIsMemCopyDone());
3714:                }
3715:                #endif
3716:                
3717:                /*****************************************************************************
3718:                  Function:
3719:                	RSA_STATUS RSAStep(void)
3720:                
3721:                Replace
3722:                  ***************************************************************************/
3723:                RSA_STATUS RSAStep(void)
3724:                {
3725:                	WORD oldPtr;
3726:                	
3727:                	switch(smRSA)
3728:                	{
3729:                		case SM_RSA_ENCRYPT_START:
3730:                		case SM_RSA_DECRYPT_START:
3731:                			// Set the correct key length
3732:                			BFCReg(ECON2, ECON2_MODLEN1 | ECON2_MODLEN0);
3733:                			if(keyLength == 1024u/8u)
3734:                				BFSReg(ECON2, ECON2_MODLEN1);				
3735:                			if(keyLength == 768u/8u)
3736:                				BFSReg(ECON2, ECON2_MODLEN0);
3737:                			
3738:                			// Start the engine
3739:                			BFSReg(ECON1, ECON1_MODEXST);
3740:                			
3741:                			// Advance state machine to SM_RSA_ENCRYPT.  With the ENCX24J600 
3742:                			// Modular Exponentiation engine, the finishing of decryption is 
3743:                			// identical to the finishing of encryption.
3744:                			smRSA = SM_RSA_ENCRYPT;
3745:                			break;
3746:                			
3747:                		case SM_RSA_ENCRYPT:	// Also used to finish decryption
3748:                			// Check if operation is complete
3749:                			if(ReadReg(ECON1) & ECON1_MODEXST)
3750:                				break;
3751:                				
3752:                			// Copy the data out
3753:                			MACMemCopyAsync(BASE_CRYPTOB_ADDR, ENC100_MODEX_Y, 128);
3754:                   			oldPtr = MACSetReadPtr(BASE_CRYPTOB_ADDR);
3755:                			while(!MACIsMemCopyDone());
3756:                			MACGetArray(vOutput, keyLength);
3757:                			MACSetReadPtr(oldPtr);
3758:                
3759:                			// Indicate that we're finished
3760:                			smRSA = SM_RSA_DONE;
3761:                			return RSA_DONE;
3762:                		
3763:                		default:
3764:                			// Unknown state
3765:                			return RSA_DONE;
3766:                	}
3767:                	
3768:                	// Indicate that we're still working
3769:                	return RSA_WORKING;
3770:                	
3771:                }
3772:                
3773:                
3774:                /****************************************************************************
3775:                  Section:
3776:                	Fundamental RSA Operations
3777:                  ***************************************************************************/
3778:                
3779:                /*****************************************************************************
3780:                  Function:
3781:                	static BOOL _RSAModExpROM(BIGINT* y, BIGINT* x, BIGINT_ROM* e, 
3782:                								BIGINT_ROM* n)
3783:                
3784:                Not Needed
3785:                  ***************************************************************************/
3786:                
3787:                /*****************************************************************************
3788:                  Function:
3789:                	static BOOL _RSAModExp(BIGINT* y, BIGINT* x, BIGINT* e, BIGINT* n)
3790:                
3791:                Not Needed
3792:                  ***************************************************************************/
3793:                
3794:                #endif
3795:                
3796:                
3797:                
3798:                #ifdef ENC100_DEBUG
3799:                // A function potentially useful for debugging, but a waste of code otherwise
3800:                void ENC100DumpState(void)
3801:                {
3802:                	WORD w;
3803:                	BYTE a[32];
3804:                	BYTE i;
3805:                
3806:                	printf("\r\n  Current Packet Address = 0x%04hX", wCurrentPacketPointer);
3807:                	printf("\r\n  EIR     = 0x%04hX", ReadReg(EIR));
3808:                	printf("\r\n  ERXST   = 0x%04hX", ReadReg(ERXST));
3809:                	printf("\r\n  EUDAST  = 0x%04hX", ReadReg(EUDAST));
3810:                	printf("\r\n  EUDAND  = 0x%04hX", ReadReg(EUDAND));
3811:                	printf("\r\n  ERXTAIL = 0x%04hX", ReadReg(ERXTAIL));
3812:                	printf("\r\n  ERXHEAD = 0x%04hX", ReadReg(ERXHEAD));
3813:                	w = ReadReg(ESTAT);
3814:                	printf("\r\n  ESTAT   = 0x%04hX (Packet Count = %hhu)", w, (BYTE)w);
3815:                	printf("\r\n  ERXFCON = 0x%04hX", ReadReg(ERXFCON));
3816:                	printf("\r\n  MACON1  = 0x%04hX", ReadReg(MACON1));
3817:                	printf("\r\n  MACON2  = 0x%04hX", ReadReg(MACON2));
3818:                	printf("\r\n  ECON1   = 0x%04hX", ReadReg(ECON1));
3819:                	printf("\r\n  ECON2   = 0x%04hX", ReadReg(ECON2));
3820:                	printf("\r\n  ETXST   = 0x%04hX", ReadReg(ETXST));
3821:                	printf("\r\n  ETXLEN  = 0x%04hX", ReadReg(ETXLEN));
3822:                	printf("\r\n  EDMAST  = 0x%04hX", ReadReg(EDMAST));
3823:                	printf("\r\n  EDMALEN = 0x%04hX", ReadReg(EDMALEN));
3824:                	printf("\r\n  EDMADST = 0x%04hX", ReadReg(EDMADST));
3825:                	printf("\r\n  EDMACS  = 0x%04hX", ReadReg(EDMACS));
3826:                
3827:                	for(w = 0; w < ENC100_RAM_SIZE; w += 16)
3828:                	{
3829:                		ReadMemory(w, a, 16);
3830:                		
3831:                		for(i = 0; i < 16u; i++)
3832:                		{
3833:                			if((a[i] >= 0x20) && (a[i] <= 0x7E))
3834:                				a[i+16] = a[i];
3835:                			else
3836:                				a[i+16] = '.';
3837:                		}
3838:                		
3839:                		printf("\r\n%04hx  %02hhx %02hhx %02hhx %02hhx %02hhx %02hhx %02hhx %02hhx  %02hhx %02hhx %02hhx %02hhx %02hhx %02hhx %02hhx %02hhx   %hhc%hhc%hhc%hhc%hhc%hhc%hhc%hhc %hhc%hhc%hhc%hhc%hhc%hhc%hhc%hhc", w, a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15], a[16], a[17], a[18], a[19], a[20], a[21], a[22], a[23], a[24], a[25], a[26], a[27], a[28], a[29], a[30], a[31]);
3840:                	}
3841:                	printf("\r\n\r\n");
3842:                }
3843:                #endif
3844:                
3845:                #endif //#if defined(ENC100_INTERFACE_MODE)
---  C:/Users/Diego/Documents/GitHub/pic32webFREERtos/Pic32Web.X/src/tcpip/src/Delay.c  -----------------
1:                   /*********************************************************************
2:                    *
3:                    *                  General Delay rouines
4:                    *
5:                    *********************************************************************
6:                    * FileName:        Delay.c
7:                    * Dependencies:    Compiler.h
8:                    * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32
9:                    * Compiler:        Microchip C32 v1.05 or higher
10:                   *					Microchip C30 v3.12 or higher
11:                   *					Microchip C18 v3.30 or higher
12:                   *					HI-TECH PICC-18 PRO 9.63PL2 or higher
13:                   * Company:         Microchip Technology, Inc.
14:                   *
15:                   * Software License Agreement
16:                   *
17:                   * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights
18:                   * reserved.
19:                   *
20:                   * Microchip licenses to you the right to use, modify, copy, and
21:                   * distribute:
22:                   * (i)  the Software when embedded on a Microchip microcontroller or
23:                   *      digital signal controller product ("Device") which is
24:                   *      integrated into Licensee's product; or
25:                   * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h,
26:                   *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device
27:                   *		used in conjunction with a Microchip ethernet controller for
28:                   *		the sole purpose of interfacing with the ethernet controller.
29:                   *
30:                   * You should refer to the license agreement accompanying this
31:                   * Software for additional information regarding your rights and
32:                   * obligations.
33:                   *
34:                   * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT
35:                   * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT
36:                   * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A
37:                   * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL
38:                   * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR
39:                   * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF
40:                   * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS
41:                   * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE
42:                   * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER
43:                   * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT
44:                   * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE.
45:                   *
46:                   *
47:                   * Author               Date    Comment
48:                   *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
49:                   * Nilesh Rajbharti     5/9/02  Original        (Rev 1.0)
50:                   ********************************************************************/
51:                  #define __DELAY_C
52:                  
53:                  #include "TCPIP Stack/TCPIP.h"
54:                  #include <FreeRTOS.h>
55:                  #include <task.h>
56:                  
57:                  #if !defined(__18CXX) || defined(HI_TECH_C)
58:                  void DelayMs(WORD ms)
59:                  {
9D035A34  27BDFFE8   ADDIU SP, SP, -24
9D035A38  AFBF0014   SW RA, 20(SP)
9D035A3C  AFBE0010   SW S8, 16(SP)
9D035A40  03A0F021   ADDU S8, SP, ZERO
9D035A44  00801021   ADDU V0, A0, ZERO
9D035A48  A7C20018   SH V0, 24(S8)
60:                  #ifdef INC_FREERTOS_H
61:                      vTaskDelay(ms);
9D035A4C  97C20018   LHU V0, 24(S8)
9D035A50  00402021   ADDU A0, V0, ZERO
9D035A54  0F407BB9   JAL vTaskDelay
9D035A58  00000000   NOP
62:                  #else
63:                      unsigned char i;
64:                      while(ms--)
65:                      {
66:                          i=4;
67:                          while(i--)
68:                          {
69:                              Delay10us(25);
70:                          }
71:                      }
72:                  #endif
73:                  }
9D035A5C  03C0E821   ADDU SP, S8, ZERO
9D035A60  8FBF0014   LW RA, 20(SP)
9D035A64  8FBE0010   LW S8, 16(SP)
9D035A68  27BD0018   ADDIU SP, SP, 24
9D035A6C  03E00008   JR RA
9D035A70  00000000   NOP
74:                  #endif	//#if !defined(__18CXX) || defined(HI_TECH_C)
75:                  
76:                  
77:                  #if defined(__C30__) || defined(__C32__)
78:                  void Delay10us(DWORD dwCount)
79:                  {
9D035A74  27BDFFF0   ADDIU SP, SP, -16
9D035A78  AFBE000C   SW S8, 12(SP)
9D035A7C  03A0F021   ADDU S8, SP, ZERO
9D035A80  AFC40010   SW A0, 16(S8)
80:                  	volatile DWORD _dcnt;
81:                  
82:                  	_dcnt = dwCount*((DWORD)(0.00001/(1.0/GetInstructionClock())/10));
9D035A84  8FC30010   LW V1, 16(S8)
9D035A88  24020050   ADDIU V0, ZERO, 80
9D035A8C  70621002   MUL V0, V1, V0
9D035A90  0B40D6A9   J 0x9D035AA4
83:                  	while(_dcnt--)
9D035A94  AFC20000   SW V0, 0(S8)
9D035AA4  8FC20000   LW V0, 0(S8)
9D035AA8  0002182B   SLTU V1, ZERO, V0
9D035AAC  306300FF   ANDI V1, V1, 255
9D035AB0  2442FFFF   ADDIU V0, V0, -1
9D035AB4  1460FFF8   BNE V1, ZERO, 0x9D035A98
9D035AB8  AFC20000   SW V0, 0(S8)
84:                  	{
85:                  		#if defined(__C32__)
86:                  			Nop();
9D035A98  00000040   SSNOP
87:                  			Nop();
9D035A9C  00000040   SSNOP
88:                  			Nop();
9D035AA0  00000040   SSNOP
89:                  		#endif
90:                  	}
91:                  }
9D035ABC  03C0E821   ADDU SP, S8, ZERO
9D035AC0  8FBE000C   LW S8, 12(SP)
9D035AC4  03E00008   JR RA
9D035AC8  27BD0010   ADDIU SP, SP, 16
92:                  #endif
---  C:/Users/Diego/Documents/GitHub/pic32webFREERtos/Pic32Web.X/src/tcpip/src/DNS.c  -------------------
1:                   /*********************************************************************
2:                    *
3:                    *	Domain Name System (DNS) Client
4:                    *  Module for Microchip TCP/IP Stack
5:                    *	 -Provides hostname to IP address translation
6:                    *	 -Reference: RFC 1035
7:                    *
8:                    *********************************************************************
9:                    * FileName:        DNS.c
10:                   * Dependencies:    UDP, ARP, Tick
11:                   * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32
12:                   * Compiler:        Microchip C32 v1.05 or higher
13:                   *					Microchip C30 v3.12 or higher
14:                   *					Microchip C18 v3.30 or higher
15:                   *					HI-TECH PICC-18 PRO 9.63PL2 or higher
16:                   * Company:         Microchip Technology, Inc.
17:                   *
18:                   * Software License Agreement
19:                   *
20:                   * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights
21:                   * reserved.
22:                   *
23:                   * Microchip licenses to you the right to use, modify, copy, and
24:                   * distribute:
25:                   * (i)  the Software when embedded on a Microchip microcontroller or
26:                   *      digital signal controller product ("Device") which is
27:                   *      integrated into Licensee's product; or
28:                   * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h,
29:                   *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device
30:                   *		used in conjunction with a Microchip ethernet controller for
31:                   *		the sole purpose of interfacing with the ethernet controller.
32:                   *
33:                   * You should refer to the license agreement accompanying this
34:                   * Software for additional information regarding your rights and
35:                   * obligations.
36:                   *
37:                   * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT
38:                   * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT
39:                   * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A
40:                   * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL
41:                   * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR
42:                   * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF
43:                   * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS
44:                   * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE
45:                   * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER
46:                   * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT
47:                   * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE.
48:                   *
49:                   *
50:                   * Author               Date		Comment
51:                   *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
52:                   * Howard Schlunder     7/31/06		Original
53:                   * Howard Schlunder		10/09/06	Added DNSBeginUsage(), DNSEndUsage() 
54:                   *									module ownership semaphore
55:                   * Howard Schlunder		08/28/09	Fixed name compression parsing bug
56:                   ********************************************************************/
57:                  #define __DNS_C
58:                  
59:                  #include "TCPIP Stack/TCPIP.h"
60:                  
61:                  #if defined(STACK_USE_DNS)
62:                  
63:                  /****************************************************************************
64:                    Section:
65:                  	Constants and Global Variables
66:                    ***************************************************************************/
67:                  
68:                  #define DNS_PORT		53u					// Default port for DNS resolutions
69:                  #define DNS_TIMEOUT		(TICK_SECOND*1)		// Elapsed time after which a DNS resolution is considered to have timed out
70:                  
71:                  static UDP_SOCKET MySocket = INVALID_UDP_SOCKET;	// UDP socket to use for DNS queries
72:                  static BYTE *DNSHostName;							// Host name in RAM to look up
73:                  static ROM BYTE *DNSHostNameROM;					// Host name in ROM to look up
74:                  static BYTE RecordType;								// Record type being queried
75:                  static NODE_INFO ResolvedInfo;						// Node information about the resolved node
76:                  
77:                  // Semaphore flags for the DNS module
78:                  static union
79:                  {
80:                  	BYTE Val;
81:                  	struct
82:                  	{
83:                  		unsigned char DNSInUse 		: 1;	// Indicates the DNS module is in use
84:                  		unsigned char AddressValid	: 1;	// Indicates that the address resolution is valid and complete
85:                  		unsigned char filler 		: 6;
86:                  	} bits;
87:                  } Flags = {0x00};
88:                  
89:                  // State machine for a DNS query
90:                  static enum
91:                  {
92:                  	DNS_START = 0, 				// Initial state to reset client state variables
93:                  	DNS_ARP_START_RESOLVE,		// Send ARP resolution of DNS server or gateway MAC address
94:                  	DNS_ARP_RESOLVE,			// Wait for response to ARP request
95:                  	DNS_OPEN_SOCKET,			// Open UDP socket
96:                  	DNS_QUERY,					// Send DNS query to DNS server
97:                  	DNS_GET_RESULT,				// Wait for response from DNS server
98:                  	DNS_FAIL,					// ARP or DNS server not responding
99:                  	DNS_DONE					// DNS query is finished
100:                 } smDNS = DNS_DONE;
101:                 
102:                 // Structure for the DNS header
103:                 typedef struct
104:                 {
105:                 	WORD_VAL TransactionID;
106:                 	WORD_VAL Flags;
107:                 	WORD_VAL Questions;
108:                 	WORD_VAL Answers;
109:                 	WORD_VAL AuthoritativeRecords;
110:                 	WORD_VAL AdditionalRecords;
111:                 } DNS_HEADER;
112:                 
113:                 typedef struct
114:                 {
115:                 	// Response name is first, but it is variable length and must be retrieved using the DNSDiscardName() function
116:                 	WORD_VAL	ResponseType;
117:                 	WORD_VAL	ResponseClass;
118:                 	DWORD_VAL	ResponseTTL;
119:                 	WORD_VAL	ResponseLen;
120:                 } DNS_ANSWER_HEADER;
121:                 
122:                 
123:                 /****************************************************************************
124:                   Section:
125:                 	Function Prototypes
126:                   ***************************************************************************/
127:                 
128:                 static void DNSPutString(BYTE* String);
129:                 static void DNSDiscardName(void);
130:                 
131:                 #if defined(__18CXX)
132:                 	static void DNSPutROMString(ROM BYTE* String);
133:                 #else
134:                 	// Non-ROM alias for C30/C32
135:                 	#define DNSPutROMString(a)	DNSPutString((BYTE*)a)
136:                 #endif
137:                 
138:                 
139:                 /*****************************************************************************
140:                   Function:
141:                 	BOOL DNSBeginUsage(void)
142:                 
143:                   Summary:
144:                 	Claims access to the DNS module.
145:                 	
146:                   Description:
147:                 	This function acts as a semaphore to obtain usage of the DNS module.
148:                 	Call this function and ensure that it returns TRUE before calling any
149:                 	other DNS APIs.  Call DNSEndUsage when this application no longer 
150:                 	needs the DNS module so that other applications may make use of it.
151:                 
152:                   Precondition:
153:                 	Stack is initialized.
154:                 
155:                   Parameters:
156:                 	None
157:                 
158:                   Return Values:
159:                   	TRUE - No other DNS resolutions are in progress and the calling
160:                   			application has sucessfully taken ownership of the DNS module
161:                   	FALSE - The DNS module is currently in use.  Yield to the stack and 
162:                   			attempt this call again later.
163:                   	
164:                   Remarks:
165:                 	Ensure that DNSEndUsage is always called once your application has
166:                 	obtained control of the DNS module.  If this is not done, the stack
167:                 	will hang for all future applications requiring DNS access.
168:                   ***************************************************************************/
169:                 BOOL DNSBeginUsage(void)
170:                 {
9D02955C  27BDFFF8   ADDIU SP, SP, -8
9D029560  AFBE0004   SW S8, 4(SP)
9D029564  03A0F021   ADDU S8, SP, ZERO
171:                 	if(Flags.bits.DNSInUse)
9D029568  938280F8   LBU V0, -32520(GP)
9D02956C  30420001   ANDI V0, V0, 1
9D029570  304200FF   ANDI V0, V0, 255
9D029574  10400004   BEQ V0, ZERO, 0x9D029588
9D029578  00000000   NOP
172:                 		return FALSE;
9D02957C  00001021   ADDU V0, ZERO, ZERO
9D029580  0B40A567   J 0x9D02959C
9D029584  00000000   NOP
173:                 
174:                 	Flags.bits.DNSInUse = TRUE;
9D029588  938280F8   LBU V0, -32520(GP)
9D02958C  24030001   ADDIU V1, ZERO, 1
9D029590  7C620004   INS V0, V1, 0, 1
9D029594  A38280F8   SB V0, -32520(GP)
175:                 	return TRUE;
9D029598  24020001   ADDIU V0, ZERO, 1
176:                 }
9D02959C  03C0E821   ADDU SP, S8, ZERO
9D0295A0  8FBE0004   LW S8, 4(SP)
9D0295A4  27BD0008   ADDIU SP, SP, 8
9D0295A8  03E00008   JR RA
9D0295AC  00000000   NOP
177:                 
178:                 
179:                 /*****************************************************************************
180:                   Function:
181:                 	BOOL DNSEndUsage(void)
182:                 
183:                   Summary:
184:                 	Releases control of the DNS module.
185:                 	
186:                   Description:
187:                 	This function acts as a semaphore to obtain usage of the DNS module.
188:                 	Call this function when this application no longer needs the DNS 
189:                 	module so that other applications may make use of it.
190:                 
191:                   Precondition:
192:                 	DNSBeginUsage returned TRUE on a previous call.
193:                 
194:                   Parameters:
195:                 	None
196:                 
197:                   Return Values:
198:                   	TRUE - The address to the host name was successfully resolved.
199:                   	FALSE - The DNS failed or the address does not exist.
200:                   	
201:                   Remarks:
202:                 	Ensure that DNSEndUsage is always called once your application has
203:                 	obtained control of the DNS module.  If this is not done, the stack
204:                 	will hang for all future applications requiring DNS access.
205:                   ***************************************************************************/
206:                 BOOL DNSEndUsage(void)
207:                 {
9D0295B0  27BDFFE8   ADDIU SP, SP, -24
9D0295B4  AFBF0014   SW RA, 20(SP)
9D0295B8  AFBE0010   SW S8, 16(SP)
9D0295BC  03A0F021   ADDU S8, SP, ZERO
208:                 	if(MySocket != INVALID_UDP_SOCKET)
9D0295C0  93838018   LBU V1, -32744(GP)
9D0295C4  240200FF   ADDIU V0, ZERO, 255
9D0295C8  10620007   BEQ V1, V0, 0x9D0295E8
9D0295CC  00000000   NOP
209:                 	{
210:                 		UDPClose(MySocket);
9D0295D0  93828018   LBU V0, -32744(GP)
9D0295D4  00402021   ADDU A0, V0, ZERO
9D0295D8  0F40A2B9   JAL UDPClose
9D0295DC  00000000   NOP
211:                 		MySocket = INVALID_UDP_SOCKET;
9D0295E0  2402FFFF   ADDIU V0, ZERO, -1
9D0295E4  A3828018   SB V0, -32744(GP)
212:                 	}
213:                 	smDNS = DNS_DONE;
9D0295E8  24020007   ADDIU V0, ZERO, 7
9D0295EC  AF82801C   SW V0, -32740(GP)
214:                 	Flags.bits.DNSInUse = FALSE;
9D0295F0  938280F8   LBU V0, -32520(GP)
9D0295F4  7C020004   INS V0, ZERO, 0, 1
9D0295F8  A38280F8   SB V0, -32520(GP)
215:                 
216:                 	return Flags.bits.AddressValid;
9D0295FC  938280F8   LBU V0, -32520(GP)
9D029600  7C420040   EXT V0, V0, 1, 1
9D029604  304200FF   ANDI V0, V0, 255
217:                 }
9D029608  03C0E821   ADDU SP, S8, ZERO
9D02960C  8FBF0014   LW RA, 20(SP)
9D029610  8FBE0010   LW S8, 16(SP)
9D029614  27BD0018   ADDIU SP, SP, 24
9D029618  03E00008   JR RA
9D02961C  00000000   NOP
218:                 
219:                 
220:                 /*****************************************************************************
221:                   Function:
222:                 	void DNSResolve(BYTE* Hostname, BYTE Type)
223:                 
224:                   Summary:
225:                 	Begins resolution of an address.
226:                 	
227:                   Description:
228:                 	This function attempts to resolve a host name to an IP address.  When 
229:                 	called, it starts the DNS state machine.  Call DNSIsResolved repeatedly
230:                 	to determine if the resolution is complete.
231:                 	
232:                 	Only one DNS resoultion may be executed at a time.  The Hostname must 
233:                 	not be modified in memory until the resolution is complete.
234:                 
235:                   Precondition:
236:                 	DNSBeginUsage returned TRUE on a previous call.
237:                 
238:                   Parameters:
239:                 	Hostname - A pointer to the null terminated string specifiying the
240:                 		host for which to resolve an IP.
241:                 	RecordType - DNS_TYPE_A or DNS_TYPE_MX depending on what type of
242:                 		record resolution is desired.
243:                 
244:                   Returns:
245:                   	None
246:                   	
247:                   Remarks:
248:                 	This function requires access to one UDP socket.  If none are available,
249:                 	MAX_UDP_SOCKETS may need to be increased.
250:                   ***************************************************************************/
251:                 void DNSResolve(BYTE* Hostname, BYTE Type)
252:                 {
9D029620  27BDFFE8   ADDIU SP, SP, -24
9D029624  AFBF0014   SW RA, 20(SP)
9D029628  AFBE0010   SW S8, 16(SP)
9D02962C  03A0F021   ADDU S8, SP, ZERO
9D029630  AFC40018   SW A0, 24(S8)
9D029634  00A01021   ADDU V0, A1, ZERO
9D029638  A3C2001C   SB V0, 28(S8)
253:                 	if(StringToIPAddress(Hostname, &ResolvedInfo.IPAddr))
9D02963C  8FC40018   LW A0, 24(S8)
9D029640  3C02A000   LUI V0, -24576
9D029644  244532C4   ADDIU A1, V0, 12996
9D029648  0F4096C2   JAL StringToIPAddress
9D02964C  00000000   NOP
9D029650  10400009   BEQ V0, ZERO, 0x9D029678
9D029654  00000000   NOP
254:                 	{
255:                 		Flags.bits.AddressValid = TRUE;
9D029658  938280F8   LBU V0, -32520(GP)
9D02965C  24030001   ADDIU V1, ZERO, 1
9D029660  7C620844   INS V0, V1, 1, 1
9D029664  A38280F8   SB V0, -32520(GP)
256:                 		smDNS = DNS_DONE;
9D029668  24020007   ADDIU V0, ZERO, 7
9D02966C  AF82801C   SW V0, -32740(GP)
9D029670  0B40A5A7   J 0x9D02969C
9D029674  00000000   NOP
257:                 	}
258:                 	else
259:                 	{	
260:                 		DNSHostName = Hostname;
9D029678  8FC20018   LW V0, 24(S8)
9D02967C  AF8280EC   SW V0, -32532(GP)
261:                 		DNSHostNameROM = NULL;
9D029680  AF8080F0   SW ZERO, -32528(GP)
262:                 		smDNS = DNS_START;
9D029684  AF80801C   SW ZERO, -32740(GP)
263:                 		RecordType = Type;
9D029688  93C2001C   LBU V0, 28(S8)
9D02968C  A38280F4   SB V0, -32524(GP)
264:                 		Flags.bits.AddressValid = FALSE;
9D029690  938280F8   LBU V0, -32520(GP)
9D029694  7C020844   INS V0, ZERO, 1, 1
9D029698  A38280F8   SB V0, -32520(GP)
265:                 	}
266:                 }
9D02969C  03C0E821   ADDU SP, S8, ZERO
9D0296A0  8FBF0014   LW RA, 20(SP)
9D0296A4  8FBE0010   LW S8, 16(SP)
9D0296A8  27BD0018   ADDIU SP, SP, 24
9D0296AC  03E00008   JR RA
9D0296B0  00000000   NOP
267:                 
268:                 
269:                 /*****************************************************************************
270:                   Function:
271:                 	void DNSResolveROM(ROM BYTE* Hostname, BYTE Type)
272:                 
273:                   Summary:
274:                 	Begins resolution of an address.
275:                 	
276:                   Description:
277:                 	This function attempts to resolve a host name to an IP address.  When 
278:                 	called, it starts the DNS state machine.  Call DNSIsResolved repeatedly
279:                 	to determine if the resolution is complete.
280:                 	
281:                 	Only one DNS resoultion may be executed at a time.  The Hostname must 
282:                 	not be modified in memory until the resolution is complete.
283:                 
284:                   Precondition:
285:                 	DNSBeginUsage returned TRUE on a previous call.
286:                 
287:                   Parameters:
288:                 	Hostname - A pointer to the null terminated string specifiying the
289:                 		host for which to resolve an IP.
290:                 	RecordType - DNS_TYPE_A or DNS_TYPE_MX depending on what type of
291:                 		record resolution is desired.
292:                 
293:                   Returns:
294:                   	None
295:                   	
296:                   Remarks:
297:                 	This function requires access to one UDP socket.  If none are available,
298:                 	MAX_UDP_SOCKETS may need to be increased.
299:                 	
300:                 	This function is aliased to DNSResolve on non-PIC18 platforms.
301:                   ***************************************************************************/
302:                 #if defined(__18CXX)
303:                 void DNSResolveROM(ROM BYTE* Hostname, BYTE Type)
304:                 {
305:                 	if(ROMStringToIPAddress(Hostname, &ResolvedInfo.IPAddr))
306:                 	{
307:                 		Flags.bits.AddressValid = TRUE;
308:                 		smDNS = DNS_DONE;
309:                 	}
310:                 	else
311:                 	{	
312:                 		DNSHostName = NULL;
313:                 		DNSHostNameROM = Hostname;
314:                 		smDNS = DNS_START;
315:                 		RecordType = Type;
316:                 		Flags.bits.AddressValid = FALSE;
317:                 	}
318:                 }
319:                 #endif
320:                 
321:                 
322:                 /*****************************************************************************
323:                   Function:
324:                 	BOOL DNSIsResolved(IP_ADDR* HostIP)
325:                 
326:                   Summary:
327:                 	Determines if the DNS resolution is complete and provides the IP.
328:                 	
329:                   Description:
330:                 	Call this function to determine if the DNS resolution of an address has
331:                 	been completed.  If so, the resolved address will be provided in HostIP.
332:                 
333:                   Precondition:
334:                 	DNSResolve or DNSResolveROM has been called.
335:                 
336:                   Parameters:
337:                 	HostIP - A pointer to an IP_ADDR structure in which to store the 
338:                 		resolved IP address once resolution is complete.
339:                 
340:                   Return Values:
341:                   	TRUE - The DNS client has obtained an IP, or the DNS process
342:                   		has encountered an error.  HostIP will be 0.0.0.0 on error.  Possible 
343:                   		errors include server timeout (i.e. DNS server not available), hostname 
344:                   		not in the DNS, or DNS server errors.
345:                   	FALSE - The resolution process is still in progress.
346:                   ***************************************************************************/
347:                 BOOL DNSIsResolved(IP_ADDR* HostIP)
348:                 {
9D0296B4  27BDFFC8   ADDIU SP, SP, -56
9D0296B8  AFBF0034   SW RA, 52(SP)
9D0296BC  AFBE0030   SW S8, 48(SP)
9D0296C0  03A0F021   ADDU S8, SP, ZERO
9D0296C4  AFC40038   SW A0, 56(S8)
349:                 	static DWORD		StartTime;
350:                 	static WORD_VAL		SentTransactionID __attribute__((persistent));
351:                 	static BYTE			vARPAttemptCount;
352:                 	static BYTE			vDNSAttemptCount;
353:                 	BYTE 				i;
354:                 	WORD_VAL			w;
355:                 	DNS_HEADER			DNSHeader;
356:                 	DNS_ANSWER_HEADER	DNSAnswerHeader;
357:                 
358:                 	switch(smDNS)
9D0296C8  8F82801C   LW V0, -32740(GP)
9D0296CC  2C430008   SLTIU V1, V0, 8
9D0296D0  106002F4   BEQ V1, ZERO, 0x9D02A2A4
9D0296D4  00000000   NOP
9D0296D8  00021880   SLL V1, V0, 2
9D0296DC  3C029D03   LUI V0, -25341
9D0296E0  244296F4   ADDIU V0, V0, -26892
9D0296E4  00621021   ADDU V0, V1, V0
9D0296E8  8C420000   LW V0, 0(V0)
9D0296EC  00400008   JR V0
9D0296F0  00000000   NOP
359:                 	{
360:                 		case DNS_START:
361:                 			vARPAttemptCount = 0;
9D029714  A38080F9   SB ZERO, -32519(GP)
362:                 			vDNSAttemptCount = 0;
9D029718  A38080FA   SB ZERO, -32518(GP)
363:                 			// No break;
364:                 
365:                 		case DNS_ARP_START_RESOLVE:
366:                 			ARPResolve(&AppConfig.PrimaryDNSServer);
9D02971C  3C02A000   LUI V0, -24576
9D029720  24440734   ADDIU A0, V0, 1844
9D029724  0F40BCC0   JAL ARPResolve
9D029728  00000000   NOP
367:                 			vARPAttemptCount++;
9D02972C  938280F9   LBU V0, -32519(GP)
9D029730  24420001   ADDIU V0, V0, 1
9D029734  304200FF   ANDI V0, V0, 255
9D029738  A38280F9   SB V0, -32519(GP)
368:                 			StartTime = TickGet();
9D02973C  0F40CDD6   JAL TickGet
9D029740  00000000   NOP
9D029744  AF8280FC   SW V0, -32516(GP)
369:                 			smDNS = DNS_ARP_RESOLVE;
9D029748  24020002   ADDIU V0, ZERO, 2
9D02974C  AF82801C   SW V0, -32740(GP)
370:                 			break;
9D029750  0B40A8A9   J 0x9D02A2A4
9D029754  00000000   NOP
371:                 
372:                 		case DNS_ARP_RESOLVE:
373:                 			if(!ARPIsResolved(&AppConfig.PrimaryDNSServer, &ResolvedInfo.MACAddr))
9D029758  3C02A000   LUI V0, -24576
9D02975C  24440734   ADDIU A0, V0, 1844
9D029760  3C02A000   LUI V0, -24576
9D029764  244532C8   ADDIU A1, V0, 13000
9D029768  0F40BCF9   JAL ARPIsResolved
9D02976C  00000000   NOP
9D029770  14400016   BNE V0, ZERO, 0x9D0297CC
9D029774  00000000   NOP
374:                 			{
375:                 				if(TickGet() - StartTime > DNS_TIMEOUT)
9D029778  0F40CDD6   JAL TickGet
9D02977C  00000000   NOP
9D029780  00401821   ADDU V1, V0, ZERO
9D029784  8F8280FC   LW V0, -32516(GP)
9D029788  00621823   SUBU V1, V1, V0
9D02978C  3C020002   LUI V0, 2
9D029790  3442625B   ORI V0, V0, 25179
9D029794  0062102B   SLTU V0, V1, V0
9D029798  144002B5   BNE V0, ZERO, 0x9D02A270
9D02979C  00000000   NOP
376:                 					smDNS = (vARPAttemptCount >= 3u) ? DNS_FAIL : DNS_ARP_START_RESOLVE;
9D0297A0  938280F9   LBU V0, -32519(GP)
9D0297A4  2C420003   SLTIU V0, V0, 3
9D0297A8  14400004   BNE V0, ZERO, 0x9D0297BC
9D0297AC  00000000   NOP
9D0297B0  24020006   ADDIU V0, ZERO, 6
9D0297B4  0B40A5F0   J 0x9D0297C0
9D0297B8  00000000   NOP
9D0297BC  24020001   ADDIU V0, ZERO, 1
9D0297C0  AF82801C   SW V0, -32740(GP)
377:                 				break;
9D0297C4  0B40A8A9   J 0x9D02A2A4
9D0297C8  00000000   NOP
9D02A270  00000000   NOP
9D02A274  0B40A8A9   J 0x9D02A2A4
9D02A278  00000000   NOP
378:                 			}
379:                 			ResolvedInfo.IPAddr.Val = AppConfig.PrimaryDNSServer.Val;
9D0297CC  3C02A000   LUI V0, -24576
9D0297D0  24420728   ADDIU V0, V0, 1832
9D0297D4  8843000F   LWL V1, 15(V0)
9D0297D8  9843000C   LWR V1, 12(V0)
9D0297DC  3C02A000   LUI V0, -24576
9D0297E0  AC4332C4   SW V1, 12996(V0)
380:                 			smDNS = DNS_OPEN_SOCKET;
9D0297E4  24020003   ADDIU V0, ZERO, 3
9D0297E8  AF82801C   SW V0, -32740(GP)
381:                 			// No break: DNS_OPEN_SOCKET is the correct next state
382:                 		
383:                 		case DNS_OPEN_SOCKET:
384:                 			//MySocket = UDPOpen(0, &ResolvedInfo, DNS_PORT);
385:                 			
386:                 			MySocket = UDPOpenEx((DWORD)&ResolvedInfo,UDP_OPEN_NODE_INFO,0, DNS_PORT);
9D0297EC  3C02A000   LUI V0, -24576
9D0297F0  244232C4   ADDIU V0, V0, 12996
9D0297F4  00402021   ADDU A0, V0, ZERO
9D0297F8  24050004   ADDIU A1, ZERO, 4
9D0297FC  00003021   ADDU A2, ZERO, ZERO
9D029800  24070035   ADDIU A3, ZERO, 53
9D029804  0F40A0DD   JAL UDPOpenEx
9D029808  00000000   NOP
9D02980C  A3828018   SB V0, -32744(GP)
387:                 			if(MySocket == INVALID_UDP_SOCKET)
9D029810  93838018   LBU V1, -32744(GP)
9D029814  240200FF   ADDIU V0, ZERO, 255
9D029818  10620298   BEQ V1, V0, 0x9D02A27C
9D02981C  00000000   NOP
388:                 				break;
9D02A27C  00000000   NOP
9D02A280  0B40A8A9   J 0x9D02A2A4
9D02A284  00000000   NOP
389:                 
390:                 			smDNS = DNS_QUERY;
9D029820  24020004   ADDIU V0, ZERO, 4
9D029824  AF82801C   SW V0, -32740(GP)
391:                 			// No need to break, we can immediately start resolution
392:                 			
393:                 		case DNS_QUERY:
394:                 			if(!UDPIsPutReady(MySocket))
9D029828  93828018   LBU V0, -32744(GP)
9D02982C  00402021   ADDU A0, V0, ZERO
9D029830  0F40A307   JAL UDPIsPutReady
9D029834  00000000   NOP
9D029838  10400293   BEQ V0, ZERO, 0x9D02A288
9D02983C  00000000   NOP
395:                 				break;
9D02A288  00000000   NOP
9D02A28C  0B40A8A9   J 0x9D02A2A4
9D02A290  00000000   NOP
396:                 			
397:                 			// Put DNS query here
398:                 			SentTransactionID.Val++;
9D029840  3C02A000   LUI V0, -24576
9D029844  94420220   LHU V0, 544(V0)
9D029848  24420001   ADDIU V0, V0, 1
9D02984C  3043FFFF   ANDI V1, V0, -1
9D029850  3C02A000   LUI V0, -24576
9D029854  A4430220   SH V1, 544(V0)
399:                 			UDPPut(SentTransactionID.v[1]);// User chosen transaction ID
9D029858  3C02A000   LUI V0, -24576
9D02985C  90420221   LBU V0, 545(V0)
9D029860  00402021   ADDU A0, V0, ZERO
9D029864  0F40A32A   JAL UDPPut
9D029868  00000000   NOP
400:                 			UDPPut(SentTransactionID.v[0]);
9D02986C  3C02A000   LUI V0, -24576
9D029870  90420220   LBU V0, 544(V0)
9D029874  00402021   ADDU A0, V0, ZERO
9D029878  0F40A32A   JAL UDPPut
9D02987C  00000000   NOP
401:                 			UDPPut(0x01);		// Standard query with recursion
9D029880  24040001   ADDIU A0, ZERO, 1
9D029884  0F40A32A   JAL UDPPut
9D029888  00000000   NOP
402:                 			UDPPut(0x00);	
9D02988C  00002021   ADDU A0, ZERO, ZERO
9D029890  0F40A32A   JAL UDPPut
9D029894  00000000   NOP
403:                 			UDPPut(0x00);		// 0x0001 questions
9D029898  00002021   ADDU A0, ZERO, ZERO
9D02989C  0F40A32A   JAL UDPPut
9D0298A0  00000000   NOP
404:                 			UDPPut(0x01);
9D0298A4  24040001   ADDIU A0, ZERO, 1
9D0298A8  0F40A32A   JAL UDPPut
9D0298AC  00000000   NOP
405:                 			UDPPut(0x00);		// 0x0000 answers
9D0298B0  00002021   ADDU A0, ZERO, ZERO
9D0298B4  0F40A32A   JAL UDPPut
9D0298B8  00000000   NOP
406:                 			UDPPut(0x00);
9D0298BC  00002021   ADDU A0, ZERO, ZERO
9D0298C0  0F40A32A   JAL UDPPut
9D0298C4  00000000   NOP
407:                 			UDPPut(0x00);		// 0x0000 name server resource records
9D0298C8  00002021   ADDU A0, ZERO, ZERO
9D0298CC  0F40A32A   JAL UDPPut
9D0298D0  00000000   NOP
408:                 			UDPPut(0x00);
9D0298D4  00002021   ADDU A0, ZERO, ZERO
9D0298D8  0F40A32A   JAL UDPPut
9D0298DC  00000000   NOP
409:                 			UDPPut(0x00);		// 0x0000 additional records
9D0298E0  00002021   ADDU A0, ZERO, ZERO
9D0298E4  0F40A32A   JAL UDPPut
9D0298E8  00000000   NOP
410:                 			UDPPut(0x00);
9D0298EC  00002021   ADDU A0, ZERO, ZERO
9D0298F0  0F40A32A   JAL UDPPut
9D0298F4  00000000   NOP
411:                 
412:                 			// Put hostname string to resolve
413:                 			if(DNSHostName)
9D0298F8  8F8280EC   LW V0, -32532(GP)
9D0298FC  10400007   BEQ V0, ZERO, 0x9D02991C
9D029900  00000000   NOP
414:                 				DNSPutString(DNSHostName);
9D029904  8F8280EC   LW V0, -32532(GP)
9D029908  00402021   ADDU A0, V0, ZERO
9D02990C  0F40A8B0   JAL 0x9D02A2C0
9D029910  00000000   NOP
9D029914  0B40A64B   J 0x9D02992C
9D029918  00000000   NOP
415:                 			else
416:                 				DNSPutROMString(DNSHostNameROM);
9D02991C  8F8280F0   LW V0, -32528(GP)
9D029920  00402021   ADDU A0, V0, ZERO
9D029924  0F40A8B0   JAL 0x9D02A2C0
9D029928  00000000   NOP
417:                 
418:                 			UDPPut(0x00);		// Type: DNS_TYPE_A A (host address) or DNS_TYPE_MX for mail exchange
9D02992C  00002021   ADDU A0, ZERO, ZERO
9D029930  0F40A32A   JAL UDPPut
9D029934  00000000   NOP
419:                 			UDPPut(RecordType);
9D029938  938280F4   LBU V0, -32524(GP)
9D02993C  00402021   ADDU A0, V0, ZERO
9D029940  0F40A32A   JAL UDPPut
9D029944  00000000   NOP
420:                 			UDPPut(0x00);		// Class: IN (Internet)
9D029948  00002021   ADDU A0, ZERO, ZERO
9D02994C  0F40A32A   JAL UDPPut
9D029950  00000000   NOP
421:                 			UDPPut(0x01);
9D029954  24040001   ADDIU A0, ZERO, 1
9D029958  0F40A32A   JAL UDPPut
9D02995C  00000000   NOP
422:                 
423:                 			UDPFlush();
9D029960  0F40A38D   JAL UDPFlush
9D029964  00000000   NOP
424:                 			StartTime = TickGet();
9D029968  0F40CDD6   JAL TickGet
9D02996C  00000000   NOP
9D029970  AF8280FC   SW V0, -32516(GP)
425:                 			smDNS = DNS_GET_RESULT;
9D029974  24020005   ADDIU V0, ZERO, 5
9D029978  AF82801C   SW V0, -32740(GP)
426:                 			break;
9D02997C  0B40A8A9   J 0x9D02A2A4
9D029980  00000000   NOP
427:                 
428:                 		case DNS_GET_RESULT:
429:                 			if(!UDPIsGetReady(MySocket))
9D029984  93828018   LBU V0, -32744(GP)
9D029988  00402021   ADDU A0, V0, ZERO
9D02998C  0F40A3FD   JAL UDPIsGetReady
9D029990  00000000   NOP
9D029994  1440000F   BNE V0, ZERO, 0x9D0299D4
9D029998  00000000   NOP
430:                 			{
431:                 				if(TickGet() - StartTime > DNS_TIMEOUT)
9D02999C  0F40CDD6   JAL TickGet
9D0299A0  00000000   NOP
9D0299A4  00401821   ADDU V1, V0, ZERO
9D0299A8  8F8280FC   LW V0, -32516(GP)
9D0299AC  00621823   SUBU V1, V1, V0
9D0299B0  3C020002   LUI V0, 2
9D0299B4  3442625B   ORI V0, V0, 25179
9D0299B8  0062102B   SLTU V0, V1, V0
9D0299BC  14400235   BNE V0, ZERO, 0x9D02A294
9D0299C0  00000000   NOP
432:                 					smDNS = DNS_FAIL;
9D0299C4  24020006   ADDIU V0, ZERO, 6
9D0299C8  AF82801C   SW V0, -32740(GP)
433:                 				break;
9D0299CC  0B40A8A9   J 0x9D02A2A4
9D0299D0  00000000   NOP
9D02A294  00000000   NOP
9D02A298  0B40A8A9   J 0x9D02A2A4
9D02A29C  00000000   NOP
434:                 			}
435:                 
436:                 			// Retrieve the DNS header and de-big-endian it
437:                 			UDPGet(&DNSHeader.TransactionID.v[1]);
9D0299D4  27C20018   ADDIU V0, S8, 24
9D0299D8  24420001   ADDIU V0, V0, 1
9D0299DC  00402021   ADDU A0, V0, ZERO
9D0299E0  0F40A421   JAL UDPGet
9D0299E4  00000000   NOP
438:                 			UDPGet(&DNSHeader.TransactionID.v[0]);
9D0299E8  27C20018   ADDIU V0, S8, 24
9D0299EC  00402021   ADDU A0, V0, ZERO
9D0299F0  0F40A421   JAL UDPGet
9D0299F4  00000000   NOP
439:                 
440:                 			// Throw this packet away if it isn't in response to our last query
441:                 			if(DNSHeader.TransactionID.Val != SentTransactionID.Val)
9D0299F8  97C30018   LHU V1, 24(S8)
9D0299FC  3C02A000   LUI V0, -24576
9D029A00  94420220   LHU V0, 544(V0)
9D029A04  10620005   BEQ V1, V0, 0x9D029A1C
9D029A08  00000000   NOP
442:                 			{
443:                 				UDPDiscard();
9D029A0C  0F40A472   JAL UDPDiscard
9D029A10  00000000   NOP
444:                 				break;
9D029A14  0B40A8A9   J 0x9D02A2A4
9D029A18  00000000   NOP
445:                 			}
446:                 
447:                 			UDPGet(&DNSHeader.Flags.v[1]);
9D029A1C  27C20018   ADDIU V0, S8, 24
9D029A20  24420003   ADDIU V0, V0, 3
9D029A24  00402021   ADDU A0, V0, ZERO
9D029A28  0F40A421   JAL UDPGet
9D029A2C  00000000   NOP
448:                 			UDPGet(&DNSHeader.Flags.v[0]);
9D029A30  27C20018   ADDIU V0, S8, 24
9D029A34  24420002   ADDIU V0, V0, 2
9D029A38  00402021   ADDU A0, V0, ZERO
9D029A3C  0F40A421   JAL UDPGet
9D029A40  00000000   NOP
449:                 			UDPGet(&DNSHeader.Questions.v[1]);
9D029A44  27C20018   ADDIU V0, S8, 24
9D029A48  24420005   ADDIU V0, V0, 5
9D029A4C  00402021   ADDU A0, V0, ZERO
9D029A50  0F40A421   JAL UDPGet
9D029A54  00000000   NOP
450:                 			UDPGet(&DNSHeader.Questions.v[0]);
9D029A58  27C20018   ADDIU V0, S8, 24
9D029A5C  24420004   ADDIU V0, V0, 4
9D029A60  00402021   ADDU A0, V0, ZERO
9D029A64  0F40A421   JAL UDPGet
9D029A68  00000000   NOP
451:                 			UDPGet(&DNSHeader.Answers.v[1]);
9D029A6C  27C20018   ADDIU V0, S8, 24
9D029A70  24420007   ADDIU V0, V0, 7
9D029A74  00402021   ADDU A0, V0, ZERO
9D029A78  0F40A421   JAL UDPGet
9D029A7C  00000000   NOP
452:                 			UDPGet(&DNSHeader.Answers.v[0]);
9D029A80  27C20018   ADDIU V0, S8, 24
9D029A84  24420006   ADDIU V0, V0, 6
9D029A88  00402021   ADDU A0, V0, ZERO
9D029A8C  0F40A421   JAL UDPGet
9D029A90  00000000   NOP
453:                 			UDPGet(&DNSHeader.AuthoritativeRecords.v[1]);
9D029A94  27C20018   ADDIU V0, S8, 24
9D029A98  24420009   ADDIU V0, V0, 9
9D029A9C  00402021   ADDU A0, V0, ZERO
9D029AA0  0F40A421   JAL UDPGet
9D029AA4  00000000   NOP
454:                 			UDPGet(&DNSHeader.AuthoritativeRecords.v[0]);
9D029AA8  27C20018   ADDIU V0, S8, 24
9D029AAC  24420008   ADDIU V0, V0, 8
9D029AB0  00402021   ADDU A0, V0, ZERO
9D029AB4  0F40A421   JAL UDPGet
9D029AB8  00000000   NOP
455:                 			UDPGet(&DNSHeader.AdditionalRecords.v[1]);
9D029ABC  27C20018   ADDIU V0, S8, 24
9D029AC0  2442000B   ADDIU V0, V0, 11
9D029AC4  00402021   ADDU A0, V0, ZERO
9D029AC8  0F40A421   JAL UDPGet
9D029ACC  00000000   NOP
456:                 			UDPGet(&DNSHeader.AdditionalRecords.v[0]);
9D029AD0  27C20018   ADDIU V0, S8, 24
9D029AD4  2442000A   ADDIU V0, V0, 10
9D029AD8  00402021   ADDU A0, V0, ZERO
9D029ADC  0F40A421   JAL UDPGet
9D029AE0  00000000   NOP
457:                 
458:                 			// Remove all questions (queries)
459:                 			while(DNSHeader.Questions.Val--)
9D029AE4  0B40A6CF   J 0x9D029B3C
9D029AE8  00000000   NOP
9D029B3C  97C2001C   LHU V0, 28(S8)
9D029B40  0002182B   SLTU V1, ZERO, V0
9D029B44  306300FF   ANDI V1, V1, 255
9D029B48  2442FFFF   ADDIU V0, V0, -1
9D029B4C  3042FFFF   ANDI V0, V0, -1
9D029B50  A7C2001C   SH V0, 28(S8)
9D029B54  1460FFE5   BNE V1, ZERO, 0x9D029AEC
9D029B58  00000000   NOP
460:                 			{
461:                 				DNSDiscardName();
9D029AEC  0F40A900   JAL 0x9D02A400
9D029AF0  00000000   NOP
462:                 				UDPGet(&w.v[1]);		// Question type
9D029AF4  27C20014   ADDIU V0, S8, 20
9D029AF8  24420001   ADDIU V0, V0, 1
9D029AFC  00402021   ADDU A0, V0, ZERO
9D029B00  0F40A421   JAL UDPGet
9D029B04  00000000   NOP
463:                 				UDPGet(&w.v[0]);
9D029B08  27C20014   ADDIU V0, S8, 20
9D029B0C  00402021   ADDU A0, V0, ZERO
9D029B10  0F40A421   JAL UDPGet
9D029B14  00000000   NOP
464:                 				UDPGet(&w.v[1]);		// Question class
9D029B18  27C20014   ADDIU V0, S8, 20
9D029B1C  24420001   ADDIU V0, V0, 1
9D029B20  00402021   ADDU A0, V0, ZERO
9D029B24  0F40A421   JAL UDPGet
9D029B28  00000000   NOP
465:                 				UDPGet(&w.v[0]);
9D029B2C  27C20014   ADDIU V0, S8, 20
9D029B30  00402021   ADDU A0, V0, ZERO
9D029B34  0F40A421   JAL UDPGet
9D029B38  00000000   NOP
466:                 			}
467:                 			
468:                 			// Scan through answers
469:                 			while(DNSHeader.Answers.Val--)
9D029B5C  0B40A743   J 0x9D029D0C
9D029B60  00000000   NOP
9D029D0C  97C2001E   LHU V0, 30(S8)
9D029D10  0002182B   SLTU V1, ZERO, V0
9D029D14  306300FF   ANDI V1, V1, 255
9D029D18  2442FFFF   ADDIU V0, V0, -1
9D029D1C  3042FFFF   ANDI V0, V0, -1
9D029D20  A7C2001E   SH V0, 30(S8)
9D029D24  1460FF8F   BNE V1, ZERO, 0x9D029B64
9D029D28  00000000   NOP
470:                 			{				
471:                 				DNSDiscardName();					// Throw away response name
9D029B64  0F40A900   JAL 0x9D02A400
9D029B68  00000000   NOP
472:                 				UDPGet(&DNSAnswerHeader.ResponseType.v[1]);		// Response type
9D029B6C  27C20024   ADDIU V0, S8, 36
9D029B70  24420001   ADDIU V0, V0, 1
9D029B74  00402021   ADDU A0, V0, ZERO
9D029B78  0F40A421   JAL UDPGet
9D029B7C  00000000   NOP
473:                 				UDPGet(&DNSAnswerHeader.ResponseType.v[0]);
9D029B80  27C20024   ADDIU V0, S8, 36
9D029B84  00402021   ADDU A0, V0, ZERO
9D029B88  0F40A421   JAL UDPGet
9D029B8C  00000000   NOP
474:                 				UDPGet(&DNSAnswerHeader.ResponseClass.v[1]);	// Response class
9D029B90  27C20024   ADDIU V0, S8, 36
9D029B94  24420003   ADDIU V0, V0, 3
9D029B98  00402021   ADDU A0, V0, ZERO
9D029B9C  0F40A421   JAL UDPGet
9D029BA0  00000000   NOP
475:                 				UDPGet(&DNSAnswerHeader.ResponseClass.v[0]);
9D029BA4  27C20024   ADDIU V0, S8, 36
9D029BA8  24420002   ADDIU V0, V0, 2
9D029BAC  00402021   ADDU A0, V0, ZERO
9D029BB0  0F40A421   JAL UDPGet
9D029BB4  00000000   NOP
476:                 				UDPGet(&DNSAnswerHeader.ResponseTTL.v[3]);		// Time to live
9D029BB8  27C20024   ADDIU V0, S8, 36
9D029BBC  24420007   ADDIU V0, V0, 7
9D029BC0  00402021   ADDU A0, V0, ZERO
9D029BC4  0F40A421   JAL UDPGet
9D029BC8  00000000   NOP
477:                 				UDPGet(&DNSAnswerHeader.ResponseTTL.v[2]);
9D029BCC  27C20024   ADDIU V0, S8, 36
9D029BD0  24420006   ADDIU V0, V0, 6
9D029BD4  00402021   ADDU A0, V0, ZERO
9D029BD8  0F40A421   JAL UDPGet
9D029BDC  00000000   NOP
478:                 				UDPGet(&DNSAnswerHeader.ResponseTTL.v[1]);
9D029BE0  27C20024   ADDIU V0, S8, 36
9D029BE4  24420005   ADDIU V0, V0, 5
9D029BE8  00402021   ADDU A0, V0, ZERO
9D029BEC  0F40A421   JAL UDPGet
9D029BF0  00000000   NOP
479:                 				UDPGet(&DNSAnswerHeader.ResponseTTL.v[0]);
9D029BF4  27C20024   ADDIU V0, S8, 36
9D029BF8  24420004   ADDIU V0, V0, 4
9D029BFC  00402021   ADDU A0, V0, ZERO
9D029C00  0F40A421   JAL UDPGet
9D029C04  00000000   NOP
480:                 				UDPGet(&DNSAnswerHeader.ResponseLen.v[1]);		// Response length
9D029C08  27C20024   ADDIU V0, S8, 36
9D029C0C  24420009   ADDIU V0, V0, 9
9D029C10  00402021   ADDU A0, V0, ZERO
9D029C14  0F40A421   JAL UDPGet
9D029C18  00000000   NOP
481:                 				UDPGet(&DNSAnswerHeader.ResponseLen.v[0]);
9D029C1C  27C20024   ADDIU V0, S8, 36
9D029C20  24420008   ADDIU V0, V0, 8
9D029C24  00402021   ADDU A0, V0, ZERO
9D029C28  0F40A421   JAL UDPGet
9D029C2C  00000000   NOP
482:                 
483:                 				// Make sure that this is a 4 byte IP address, response type A or MX, class 1
484:                 				// Check if this is Type A or MX
485:                 				if( DNSAnswerHeader.ResponseType.Val	== 0x0001u &&
9D029C30  97C30024   LHU V1, 36(S8)
9D029C34  24020001   ADDIU V0, ZERO, 1
9D029C38  14620025   BNE V1, V0, 0x9D029CD0
9D029C3C  00000000   NOP
9D029C44  24020001   ADDIU V0, ZERO, 1
9D029C48  14620024   BNE V1, V0, 0x9D029CDC
9D029C4C  00000000   NOP
486:                 					DNSAnswerHeader.ResponseClass.Val	== 0x0001u && // Internet class
9D029C40  97C30026   LHU V1, 38(S8)
9D029C54  24020004   ADDIU V0, ZERO, 4
9D029C58  14620023   BNE V1, V0, 0x9D029CE8
9D029C5C  00000000   NOP
487:                 					DNSAnswerHeader.ResponseLen.Val		== 0x0004u)
9D029C50  97C3002C   LHU V1, 44(S8)
488:                 				{
489:                 					Flags.bits.AddressValid = TRUE;
9D029C60  938280F8   LBU V0, -32520(GP)
9D029C64  24030001   ADDIU V1, ZERO, 1
9D029C68  7C620844   INS V0, V1, 1, 1
9D029C6C  A38280F8   SB V0, -32520(GP)
490:                 					UDPGet(&ResolvedInfo.IPAddr.v[0]);
9D029C70  3C02A000   LUI V0, -24576
9D029C74  244432C4   ADDIU A0, V0, 12996
9D029C78  0F40A421   JAL UDPGet
9D029C7C  00000000   NOP
491:                 					UDPGet(&ResolvedInfo.IPAddr.v[1]);
9D029C80  3C02A000   LUI V0, -24576
9D029C84  244432C5   ADDIU A0, V0, 12997
9D029C88  0F40A421   JAL UDPGet
9D029C8C  00000000   NOP
492:                 					UDPGet(&ResolvedInfo.IPAddr.v[2]);
9D029C90  3C02A000   LUI V0, -24576
9D029C94  244432C6   ADDIU A0, V0, 12998
9D029C98  0F40A421   JAL UDPGet
9D029C9C  00000000   NOP
493:                 					UDPGet(&ResolvedInfo.IPAddr.v[3]);
9D029CA0  3C02A000   LUI V0, -24576
9D029CA4  244432C7   ADDIU A0, V0, 12999
9D029CA8  0F40A421   JAL UDPGet
9D029CAC  00000000   NOP
494:                 					goto DoneSearchingRecords;
9D029CB0  0B40A833   J 0x9D02A0CC
9D029CB4  00000000   NOP
495:                 				}
496:                 				else
497:                 				{
498:                 					while(DNSAnswerHeader.ResponseLen.Val--)
9D029CD0  00000000   NOP
9D029CD4  0B40A73B   J 0x9D029CEC
9D029CD8  00000000   NOP
9D029CDC  00000000   NOP
9D029CE0  0B40A73B   J 0x9D029CEC
9D029CE4  00000000   NOP
9D029CE8  00000000   NOP
9D029CEC  97C2002C   LHU V0, 44(S8)
9D029CF0  0002182B   SLTU V1, ZERO, V0
9D029CF4  306300FF   ANDI V1, V1, 255
9D029CF8  2442FFFF   ADDIU V0, V0, -1
9D029CFC  3042FFFF   ANDI V0, V0, -1
9D029D00  A7C2002C   SH V0, 44(S8)
9D029D04  1460FFEC   BNE V1, ZERO, 0x9D029CB8
9D029D08  00000000   NOP
499:                 					{
500:                 						UDPGet(&i);
9D029CB8  27C20010   ADDIU V0, S8, 16
9D029CBC  00402021   ADDU A0, V0, ZERO
9D029CC0  0F40A421   JAL UDPGet
9D029CC4  00000000   NOP
9D029CC8  0B40A73B   J 0x9D029CEC
9D029CCC  00000000   NOP
501:                 					}
502:                 				}
503:                 			}
504:                 
505:                 			// Remove all Authoritative Records
506:                 			while(DNSHeader.AuthoritativeRecords.Val--)
9D029D2C  0B40A7B7   J 0x9D029EDC
9D029D30  00000000   NOP
9D029EDC  97C20020   LHU V0, 32(S8)
9D029EE0  0002182B   SLTU V1, ZERO, V0
9D029EE4  306300FF   ANDI V1, V1, 255
9D029EE8  2442FFFF   ADDIU V0, V0, -1
9D029EEC  3042FFFF   ANDI V0, V0, -1
9D029EF0  A7C20020   SH V0, 32(S8)
9D029EF4  1460FF8F   BNE V1, ZERO, 0x9D029D34
9D029EF8  00000000   NOP
507:                 			{
508:                 				DNSDiscardName();					// Throw away response name
9D029D34  0F40A900   JAL 0x9D02A400
9D029D38  00000000   NOP
509:                 				UDPGet(&DNSAnswerHeader.ResponseType.v[1]);		// Response type
9D029D3C  27C20024   ADDIU V0, S8, 36
9D029D40  24420001   ADDIU V0, V0, 1
9D029D44  00402021   ADDU A0, V0, ZERO
9D029D48  0F40A421   JAL UDPGet
9D029D4C  00000000   NOP
510:                 				UDPGet(&DNSAnswerHeader.ResponseType.v[0]);
9D029D50  27C20024   ADDIU V0, S8, 36
9D029D54  00402021   ADDU A0, V0, ZERO
9D029D58  0F40A421   JAL UDPGet
9D029D5C  00000000   NOP
511:                 				UDPGet(&DNSAnswerHeader.ResponseClass.v[1]);	// Response class
9D029D60  27C20024   ADDIU V0, S8, 36
9D029D64  24420003   ADDIU V0, V0, 3
9D029D68  00402021   ADDU A0, V0, ZERO
9D029D6C  0F40A421   JAL UDPGet
9D029D70  00000000   NOP
512:                 				UDPGet(&DNSAnswerHeader.ResponseClass.v[0]);
9D029D74  27C20024   ADDIU V0, S8, 36
9D029D78  24420002   ADDIU V0, V0, 2
9D029D7C  00402021   ADDU A0, V0, ZERO
9D029D80  0F40A421   JAL UDPGet
9D029D84  00000000   NOP
513:                 				UDPGet(&DNSAnswerHeader.ResponseTTL.v[3]);		// Time to live
9D029D88  27C20024   ADDIU V0, S8, 36
9D029D8C  24420007   ADDIU V0, V0, 7
9D029D90  00402021   ADDU A0, V0, ZERO
9D029D94  0F40A421   JAL UDPGet
9D029D98  00000000   NOP
514:                 				UDPGet(&DNSAnswerHeader.ResponseTTL.v[2]);
9D029D9C  27C20024   ADDIU V0, S8, 36
9D029DA0  24420006   ADDIU V0, V0, 6
9D029DA4  00402021   ADDU A0, V0, ZERO
9D029DA8  0F40A421   JAL UDPGet
9D029DAC  00000000   NOP
515:                 				UDPGet(&DNSAnswerHeader.ResponseTTL.v[1]);
9D029DB0  27C20024   ADDIU V0, S8, 36
9D029DB4  24420005   ADDIU V0, V0, 5
9D029DB8  00402021   ADDU A0, V0, ZERO
9D029DBC  0F40A421   JAL UDPGet
9D029DC0  00000000   NOP
516:                 				UDPGet(&DNSAnswerHeader.ResponseTTL.v[0]);
9D029DC4  27C20024   ADDIU V0, S8, 36
9D029DC8  24420004   ADDIU V0, V0, 4
9D029DCC  00402021   ADDU A0, V0, ZERO
9D029DD0  0F40A421   JAL UDPGet
9D029DD4  00000000   NOP
517:                 				UDPGet(&DNSAnswerHeader.ResponseLen.v[1]);		// Response length
9D029DD8  27C20024   ADDIU V0, S8, 36
9D029DDC  24420009   ADDIU V0, V0, 9
9D029DE0  00402021   ADDU A0, V0, ZERO
9D029DE4  0F40A421   JAL UDPGet
9D029DE8  00000000   NOP
518:                 				UDPGet(&DNSAnswerHeader.ResponseLen.v[0]);
9D029DEC  27C20024   ADDIU V0, S8, 36
9D029DF0  24420008   ADDIU V0, V0, 8
9D029DF4  00402021   ADDU A0, V0, ZERO
9D029DF8  0F40A421   JAL UDPGet
9D029DFC  00000000   NOP
519:                 
520:                 				// Make sure that this is a 4 byte IP address, response type A or MX, class 1
521:                 				// Check if this is Type A
522:                 				if( DNSAnswerHeader.ResponseType.Val	== 0x0001u &&
9D029E00  97C30024   LHU V1, 36(S8)
9D029E04  24020001   ADDIU V0, ZERO, 1
9D029E08  14620025   BNE V1, V0, 0x9D029EA0
9D029E0C  00000000   NOP
9D029E14  24020001   ADDIU V0, ZERO, 1
9D029E18  14620024   BNE V1, V0, 0x9D029EAC
9D029E1C  00000000   NOP
523:                 					DNSAnswerHeader.ResponseClass.Val	== 0x0001u && // Internet class
9D029E10  97C30026   LHU V1, 38(S8)
9D029E24  24020004   ADDIU V0, ZERO, 4
9D029E28  14620023   BNE V1, V0, 0x9D029EB8
9D029E2C  00000000   NOP
524:                 					DNSAnswerHeader.ResponseLen.Val		== 0x0004u)
9D029E20  97C3002C   LHU V1, 44(S8)
525:                 				{
526:                 					Flags.bits.AddressValid = TRUE;
9D029E30  938280F8   LBU V0, -32520(GP)
9D029E34  24030001   ADDIU V1, ZERO, 1
9D029E38  7C620844   INS V0, V1, 1, 1
9D029E3C  A38280F8   SB V0, -32520(GP)
527:                 					UDPGet(&ResolvedInfo.IPAddr.v[0]);
9D029E40  3C02A000   LUI V0, -24576
9D029E44  244432C4   ADDIU A0, V0, 12996
9D029E48  0F40A421   JAL UDPGet
9D029E4C  00000000   NOP
528:                 					UDPGet(&ResolvedInfo.IPAddr.v[1]);
9D029E50  3C02A000   LUI V0, -24576
9D029E54  244432C5   ADDIU A0, V0, 12997
9D029E58  0F40A421   JAL UDPGet
9D029E5C  00000000   NOP
529:                 					UDPGet(&ResolvedInfo.IPAddr.v[2]);
9D029E60  3C02A000   LUI V0, -24576
9D029E64  244432C6   ADDIU A0, V0, 12998
9D029E68  0F40A421   JAL UDPGet
9D029E6C  00000000   NOP
530:                 					UDPGet(&ResolvedInfo.IPAddr.v[3]);
9D029E70  3C02A000   LUI V0, -24576
9D029E74  244432C7   ADDIU A0, V0, 12999
9D029E78  0F40A421   JAL UDPGet
9D029E7C  00000000   NOP
531:                 					goto DoneSearchingRecords;
9D029E80  0B40A833   J 0x9D02A0CC
9D029E84  00000000   NOP
532:                 				}
533:                 				else
534:                 				{
535:                 					while(DNSAnswerHeader.ResponseLen.Val--)
9D029EA0  00000000   NOP
9D029EA4  0B40A7AF   J 0x9D029EBC
9D029EA8  00000000   NOP
9D029EAC  00000000   NOP
9D029EB0  0B40A7AF   J 0x9D029EBC
9D029EB4  00000000   NOP
9D029EB8  00000000   NOP
9D029EBC  97C2002C   LHU V0, 44(S8)
9D029EC0  0002182B   SLTU V1, ZERO, V0
9D029EC4  306300FF   ANDI V1, V1, 255
9D029EC8  2442FFFF   ADDIU V0, V0, -1
9D029ECC  3042FFFF   ANDI V0, V0, -1
9D029ED0  A7C2002C   SH V0, 44(S8)
9D029ED4  1460FFEC   BNE V1, ZERO, 0x9D029E88
9D029ED8  00000000   NOP
536:                 					{
537:                 						UDPGet(&i);
9D029E88  27C20010   ADDIU V0, S8, 16
9D029E8C  00402021   ADDU A0, V0, ZERO
9D029E90  0F40A421   JAL UDPGet
9D029E94  00000000   NOP
9D029E98  0B40A7AF   J 0x9D029EBC
9D029E9C  00000000   NOP
538:                 					}
539:                 				}
540:                 			}
541:                 
542:                 			// Remove all Additional Records
543:                 			while(DNSHeader.AdditionalRecords.Val--)
9D029EFC  0B40A82B   J 0x9D02A0AC
9D029F00  00000000   NOP
9D02A0AC  97C20022   LHU V0, 34(S8)
9D02A0B0  0002182B   SLTU V1, ZERO, V0
9D02A0B4  306300FF   ANDI V1, V1, 255
9D02A0B8  2442FFFF   ADDIU V0, V0, -1
9D02A0BC  3042FFFF   ANDI V0, V0, -1
9D02A0C0  A7C20022   SH V0, 34(S8)
9D02A0C4  1460FF8F   BNE V1, ZERO, 0x9D029F04
9D02A0C8  00000000   NOP
544:                 			{
545:                 				DNSDiscardName();					// Throw away response name
9D029F04  0F40A900   JAL 0x9D02A400
9D029F08  00000000   NOP
546:                 				UDPGet(&DNSAnswerHeader.ResponseType.v[1]);		// Response type
9D029F0C  27C20024   ADDIU V0, S8, 36
9D029F10  24420001   ADDIU V0, V0, 1
9D029F14  00402021   ADDU A0, V0, ZERO
9D029F18  0F40A421   JAL UDPGet
9D029F1C  00000000   NOP
547:                 				UDPGet(&DNSAnswerHeader.ResponseType.v[0]);
9D029F20  27C20024   ADDIU V0, S8, 36
9D029F24  00402021   ADDU A0, V0, ZERO
9D029F28  0F40A421   JAL UDPGet
9D029F2C  00000000   NOP
548:                 				UDPGet(&DNSAnswerHeader.ResponseClass.v[1]);	// Response class
9D029F30  27C20024   ADDIU V0, S8, 36
9D029F34  24420003   ADDIU V0, V0, 3
9D029F38  00402021   ADDU A0, V0, ZERO
9D029F3C  0F40A421   JAL UDPGet
9D029F40  00000000   NOP
549:                 				UDPGet(&DNSAnswerHeader.ResponseClass.v[0]);
9D029F44  27C20024   ADDIU V0, S8, 36
9D029F48  24420002   ADDIU V0, V0, 2
9D029F4C  00402021   ADDU A0, V0, ZERO
9D029F50  0F40A421   JAL UDPGet
9D029F54  00000000   NOP
550:                 				UDPGet(&DNSAnswerHeader.ResponseTTL.v[3]);		// Time to live
9D029F58  27C20024   ADDIU V0, S8, 36
9D029F5C  24420007   ADDIU V0, V0, 7
9D029F60  00402021   ADDU A0, V0, ZERO
9D029F64  0F40A421   JAL UDPGet
9D029F68  00000000   NOP
551:                 				UDPGet(&DNSAnswerHeader.ResponseTTL.v[2]);
9D029F6C  27C20024   ADDIU V0, S8, 36
9D029F70  24420006   ADDIU V0, V0, 6
9D029F74  00402021   ADDU A0, V0, ZERO
9D029F78  0F40A421   JAL UDPGet
9D029F7C  00000000   NOP
552:                 				UDPGet(&DNSAnswerHeader.ResponseTTL.v[1]);
9D029F80  27C20024   ADDIU V0, S8, 36
9D029F84  24420005   ADDIU V0, V0, 5
9D029F88  00402021   ADDU A0, V0, ZERO
9D029F8C  0F40A421   JAL UDPGet
9D029F90  00000000   NOP
553:                 				UDPGet(&DNSAnswerHeader.ResponseTTL.v[0]);
9D029F94  27C20024   ADDIU V0, S8, 36
9D029F98  24420004   ADDIU V0, V0, 4
9D029F9C  00402021   ADDU A0, V0, ZERO
9D029FA0  0F40A421   JAL UDPGet
9D029FA4  00000000   NOP
554:                 				UDPGet(&DNSAnswerHeader.ResponseLen.v[1]);		// Response length
9D029FA8  27C20024   ADDIU V0, S8, 36
9D029FAC  24420009   ADDIU V0, V0, 9
9D029FB0  00402021   ADDU A0, V0, ZERO
9D029FB4  0F40A421   JAL UDPGet
9D029FB8  00000000   NOP
555:                 				UDPGet(&DNSAnswerHeader.ResponseLen.v[0]);
9D029FBC  27C20024   ADDIU V0, S8, 36
9D029FC0  24420008   ADDIU V0, V0, 8
9D029FC4  00402021   ADDU A0, V0, ZERO
9D029FC8  0F40A421   JAL UDPGet
9D029FCC  00000000   NOP
556:                 
557:                 				// Make sure that this is a 4 byte IP address, response type A or MX, class 1
558:                 				// Check if this is Type A
559:                 				if( DNSAnswerHeader.ResponseType.Val	== 0x0001u &&
9D029FD0  97C30024   LHU V1, 36(S8)
9D029FD4  24020001   ADDIU V0, ZERO, 1
9D029FD8  14620025   BNE V1, V0, 0x9D02A070
9D029FDC  00000000   NOP
9D029FE4  24020001   ADDIU V0, ZERO, 1
9D029FE8  14620024   BNE V1, V0, 0x9D02A07C
9D029FEC  00000000   NOP
560:                 					DNSAnswerHeader.ResponseClass.Val	== 0x0001u && // Internet class
9D029FE0  97C30026   LHU V1, 38(S8)
9D029FF4  24020004   ADDIU V0, ZERO, 4
9D029FF8  14620023   BNE V1, V0, 0x9D02A088
9D029FFC  00000000   NOP
561:                 					DNSAnswerHeader.ResponseLen.Val		== 0x0004u)
9D029FF0  97C3002C   LHU V1, 44(S8)
562:                 				{
563:                 					Flags.bits.AddressValid = TRUE;
9D02A000  938280F8   LBU V0, -32520(GP)
9D02A004  24030001   ADDIU V1, ZERO, 1
9D02A008  7C620844   INS V0, V1, 1, 1
9D02A00C  A38280F8   SB V0, -32520(GP)
564:                 					UDPGet(&ResolvedInfo.IPAddr.v[0]);
9D02A010  3C02A000   LUI V0, -24576
9D02A014  244432C4   ADDIU A0, V0, 12996
9D02A018  0F40A421   JAL UDPGet
9D02A01C  00000000   NOP
565:                 					UDPGet(&ResolvedInfo.IPAddr.v[1]);
9D02A020  3C02A000   LUI V0, -24576
9D02A024  244432C5   ADDIU A0, V0, 12997
9D02A028  0F40A421   JAL UDPGet
9D02A02C  00000000   NOP
566:                 					UDPGet(&ResolvedInfo.IPAddr.v[2]);
9D02A030  3C02A000   LUI V0, -24576
9D02A034  244432C6   ADDIU A0, V0, 12998
9D02A038  0F40A421   JAL UDPGet
9D02A03C  00000000   NOP
567:                 					UDPGet(&ResolvedInfo.IPAddr.v[3]);
9D02A040  3C02A000   LUI V0, -24576
9D02A044  244432C7   ADDIU A0, V0, 12999
9D02A048  0F40A421   JAL UDPGet
9D02A04C  00000000   NOP
568:                 					goto DoneSearchingRecords;
9D02A050  0B40A833   J 0x9D02A0CC
9D02A054  00000000   NOP
569:                 				}
570:                 				else
571:                 				{
572:                 					while(DNSAnswerHeader.ResponseLen.Val--)
9D02A070  00000000   NOP
9D02A074  0B40A823   J 0x9D02A08C
9D02A078  00000000   NOP
9D02A07C  00000000   NOP
9D02A080  0B40A823   J 0x9D02A08C
9D02A084  00000000   NOP
9D02A088  00000000   NOP
9D02A08C  97C2002C   LHU V0, 44(S8)
9D02A090  0002182B   SLTU V1, ZERO, V0
9D02A094  306300FF   ANDI V1, V1, 255
9D02A098  2442FFFF   ADDIU V0, V0, -1
9D02A09C  3042FFFF   ANDI V0, V0, -1
9D02A0A0  A7C2002C   SH V0, 44(S8)
9D02A0A4  1460FFEC   BNE V1, ZERO, 0x9D02A058
9D02A0A8  00000000   NOP
573:                 					{
574:                 						UDPGet(&i);
9D02A058  27C20010   ADDIU V0, S8, 16
9D02A05C  00402021   ADDU A0, V0, ZERO
9D02A060  0F40A421   JAL UDPGet
9D02A064  00000000   NOP
9D02A068  0B40A823   J 0x9D02A08C
9D02A06C  00000000   NOP
575:                 					}
576:                 				}
577:                 			}
578:                 
579:                 DoneSearchingRecords:
580:                 
581:                 			UDPDiscard();
9D02A0CC  0F40A472   JAL UDPDiscard
9D02A0D0  00000000   NOP
582:                 			UDPClose(MySocket);
9D02A0D4  93828018   LBU V0, -32744(GP)
9D02A0D8  00402021   ADDU A0, V0, ZERO
9D02A0DC  0F40A2B9   JAL UDPClose
9D02A0E0  00000000   NOP
583:                 			MySocket = INVALID_UDP_SOCKET;
9D02A0E4  2402FFFF   ADDIU V0, ZERO, -1
9D02A0E8  A3828018   SB V0, -32744(GP)
584:                 			smDNS = DNS_DONE;
9D02A0EC  24020007   ADDIU V0, ZERO, 7
9D02A0F0  AF82801C   SW V0, -32740(GP)
585:                 			// No break, DNS_DONE is the correct step
586:                 
587:                 		case DNS_DONE:
588:                 			// Return 0.0.0.0 if DNS resolution failed, otherwise return the 
589:                 			// resolved IP address
590:                 			if(!Flags.bits.AddressValid)
9D02A0F4  938280F8   LBU V0, -32520(GP)
9D02A0F8  30420002   ANDI V0, V0, 2
9D02A0FC  304200FF   ANDI V0, V0, 255
9D02A100  14400003   BNE V0, ZERO, 0x9D02A110
9D02A104  00000000   NOP
591:                 				ResolvedInfo.IPAddr.Val = 0;
9D02A108  3C02A000   LUI V0, -24576
9D02A10C  AC4032C4   SW ZERO, 12996(V0)
592:                 			HostIP->Val = ResolvedInfo.IPAddr.Val;
9D02A110  3C02A000   LUI V0, -24576
9D02A114  8C4332C4   LW V1, 12996(V0)
9D02A118  8FC20038   LW V0, 56(S8)
9D02A11C  AC430000   SW V1, 0(V0)
593:                 			return TRUE;
9D02A120  24020001   ADDIU V0, ZERO, 1
9D02A124  0B40A8AA   J 0x9D02A2A8
9D02A128  00000000   NOP
594:                 
595:                 		case DNS_FAIL:
596:                 			// If 3 attempts or more, quit
597:                 			if(vDNSAttemptCount >= 2u)
9D02A12C  938280FA   LBU V0, -32518(GP)
9D02A130  2C420002   SLTIU V0, V0, 2
9D02A134  14400006   BNE V0, ZERO, 0x9D02A150
9D02A138  00000000   NOP
598:                 			{
599:                 				// Return an invalid IP address 0.0.0.0 if we can't finish ARP or DNS query step
600:                 				HostIP->Val = 0x00000000;
9D02A13C  8FC20038   LW V0, 56(S8)
9D02A140  AC400000   SW ZERO, 0(V0)
601:                 				return TRUE;
9D02A144  24020001   ADDIU V0, ZERO, 1
9D02A148  0B40A8AA   J 0x9D02A2A8
9D02A14C  00000000   NOP
602:                 			}
603:                 			vDNSAttemptCount++;
9D02A150  938280FA   LBU V0, -32518(GP)
9D02A154  24420001   ADDIU V0, V0, 1
9D02A158  304200FF   ANDI V0, V0, 255
9D02A15C  A38280FA   SB V0, -32518(GP)
604:                 
605:                 			// Swap primary and secondary DNS servers if there is a secondary DNS server programmed
606:                 			if(AppConfig.SecondaryDNSServer.Val)
9D02A160  3C02A000   LUI V0, -24576
9D02A164  24420728   ADDIU V0, V0, 1832
9D02A168  88430013   LWL V1, 19(V0)
9D02A16C  00602021   ADDU A0, V1, ZERO
9D02A170  98440010   LWR A0, 16(V0)
9D02A174  00801021   ADDU V0, A0, ZERO
9D02A178  10400049   BEQ V0, ZERO, 0x9D02A2A0
9D02A17C  00000000   NOP
607:                 			{
608:                 				AppConfig.PrimaryDNSServer.Val ^= AppConfig.SecondaryDNSServer.Val;
9D02A180  3C02A000   LUI V0, -24576
9D02A184  24420728   ADDIU V0, V0, 1832
9D02A188  8843000F   LWL V1, 15(V0)
9D02A18C  9843000C   LWR V1, 12(V0)
9D02A190  3C02A000   LUI V0, -24576
9D02A194  24420728   ADDIU V0, V0, 1832
9D02A198  88440013   LWL A0, 19(V0)
9D02A19C  00802821   ADDU A1, A0, ZERO
9D02A1A0  98450010   LWR A1, 16(V0)
9D02A1A4  00A01021   ADDU V0, A1, ZERO
9D02A1A8  00621826   XOR V1, V1, V0
9D02A1AC  3C02A000   LUI V0, -24576
9D02A1B0  24420728   ADDIU V0, V0, 1832
9D02A1B4  A843000F   SWL V1, 15(V0)
9D02A1B8  B843000C   SWR V1, 12(V0)
609:                 				AppConfig.SecondaryDNSServer.Val ^= AppConfig.PrimaryDNSServer.Val;
9D02A1BC  3C02A000   LUI V0, -24576
9D02A1C0  24420728   ADDIU V0, V0, 1832
9D02A1C4  88430013   LWL V1, 19(V0)
9D02A1C8  98430010   LWR V1, 16(V0)
9D02A1CC  3C02A000   LUI V0, -24576
9D02A1D0  24420728   ADDIU V0, V0, 1832
9D02A1D4  8844000F   LWL A0, 15(V0)
9D02A1D8  00802821   ADDU A1, A0, ZERO
9D02A1DC  9845000C   LWR A1, 12(V0)
9D02A1E0  00A01021   ADDU V0, A1, ZERO
9D02A1E4  00621826   XOR V1, V1, V0
9D02A1E8  3C02A000   LUI V0, -24576
9D02A1EC  24420728   ADDIU V0, V0, 1832
9D02A1F0  A8430013   SWL V1, 19(V0)
9D02A1F4  B8430010   SWR V1, 16(V0)
610:                 				AppConfig.PrimaryDNSServer.Val ^= AppConfig.SecondaryDNSServer.Val;
9D02A1F8  3C02A000   LUI V0, -24576
9D02A1FC  24420728   ADDIU V0, V0, 1832
9D02A200  8843000F   LWL V1, 15(V0)
9D02A204  9843000C   LWR V1, 12(V0)
9D02A208  3C02A000   LUI V0, -24576
9D02A20C  24420728   ADDIU V0, V0, 1832
9D02A210  88440013   LWL A0, 19(V0)
9D02A214  00802821   ADDU A1, A0, ZERO
9D02A218  98450010   LWR A1, 16(V0)
9D02A21C  00A01021   ADDU V0, A1, ZERO
9D02A220  00621826   XOR V1, V1, V0
9D02A224  3C02A000   LUI V0, -24576
9D02A228  24420728   ADDIU V0, V0, 1832
9D02A22C  A843000F   SWL V1, 15(V0)
9D02A230  B843000C   SWR V1, 12(V0)
611:                 
612:                 				// Start another ARP resolution for the secondary server (now primary)
613:                 				vARPAttemptCount = 0;
9D02A234  A38080F9   SB ZERO, -32519(GP)
614:                 				if(MySocket != INVALID_UDP_SOCKET)
9D02A238  93838018   LBU V1, -32744(GP)
9D02A23C  240200FF   ADDIU V0, ZERO, 255
9D02A240  10620007   BEQ V1, V0, 0x9D02A260
9D02A244  00000000   NOP
615:                 				{
616:                 					UDPClose(MySocket);
9D02A248  93828018   LBU V0, -32744(GP)
9D02A24C  00402021   ADDU A0, V0, ZERO
9D02A250  0F40A2B9   JAL UDPClose
9D02A254  00000000   NOP
617:                 					MySocket = INVALID_UDP_SOCKET;
9D02A258  2402FFFF   ADDIU V0, ZERO, -1
9D02A25C  A3828018   SB V0, -32744(GP)
618:                 				}
619:                 				smDNS = DNS_ARP_START_RESOLVE;
9D02A260  24020001   ADDIU V0, ZERO, 1
9D02A264  AF82801C   SW V0, -32740(GP)
620:                 			}
621:                 
622:                 			break;
9D02A268  0B40A8A9   J 0x9D02A2A4
9D02A26C  00000000   NOP
9D02A2A0  00000000   NOP
623:                 
624:                 	}
625:                 	
626:                 	return FALSE;
9D02A2A4  00001021   ADDU V0, ZERO, ZERO
627:                 }
9D02A2A8  03C0E821   ADDU SP, S8, ZERO
9D02A2AC  8FBF0034   LW RA, 52(SP)
9D02A2B0  8FBE0030   LW S8, 48(SP)
9D02A2B4  27BD0038   ADDIU SP, SP, 56
9D02A2B8  03E00008   JR RA
9D02A2BC  00000000   NOP
628:                 
629:                 /*****************************************************************************
630:                   Function:
631:                 	static void DNSPutString(BYTE* String)
632:                 
633:                   Summary:
634:                 	Writes a string to the DNS socket.
635:                 	
636:                   Description:
637:                 	This function writes a string to the DNS socket, ensuring that it is
638:                 	properly formatted.
639:                 
640:                   Precondition:
641:                 	UDP socket is obtained and ready for writing.
642:                 
643:                   Parameters:
644:                 	String - the string to write to the UDP socket.
645:                 
646:                   Returns:
647:                   	None
648:                   ***************************************************************************/
649:                 static void DNSPutString(BYTE* String)
650:                 {
9D02A2C0  27BDFFE0   ADDIU SP, SP, -32
9D02A2C4  AFBF001C   SW RA, 28(SP)
9D02A2C8  AFBE0018   SW S8, 24(SP)
9D02A2CC  03A0F021   ADDU S8, SP, ZERO
9D02A2D0  AFC40020   SW A0, 32(S8)
651:                 	BYTE *RightPtr;
652:                 	BYTE i;
653:                 	BYTE Len;
654:                 
655:                 	RightPtr = String;
9D02A2D4  8FC20020   LW V0, 32(S8)
9D02A2D8  AFC20010   SW V0, 16(S8)
9D02A2DC  0B40A8BA   J 0x9D02A2E8
9D02A2E0  00000000   NOP
656:                 
657:                 	while(1)
658:                 	{
659:                 		do
660:                 		{
661:                 			i = *RightPtr++;
9D02A2E8  8FC20010   LW V0, 16(S8)
9D02A2EC  90420000   LBU V0, 0(V0)
9D02A2F0  A3C20014   SB V0, 20(S8)
9D02A2F4  8FC20010   LW V0, 16(S8)
9D02A2F8  24420001   ADDIU V0, V0, 1
9D02A2FC  AFC20010   SW V0, 16(S8)
662:                 		} while((i != 0x00u) && (i != '.') && (i != '/') && (i != ',') && (i != '>'));
9D02A300  93C20014   LBU V0, 20(S8)
9D02A304  10400011   BEQ V0, ZERO, 0x9D02A34C
9D02A308  00000000   NOP
9D02A30C  93C30014   LBU V1, 20(S8)
9D02A310  2402002E   ADDIU V0, ZERO, 46
9D02A314  1062000D   BEQ V1, V0, 0x9D02A34C
9D02A318  00000000   NOP
9D02A31C  93C30014   LBU V1, 20(S8)
9D02A320  2402002F   ADDIU V0, ZERO, 47
9D02A324  10620009   BEQ V1, V0, 0x9D02A34C
9D02A328  00000000   NOP
9D02A32C  93C30014   LBU V1, 20(S8)
9D02A330  2402002C   ADDIU V0, ZERO, 44
9D02A334  10620005   BEQ V1, V0, 0x9D02A34C
9D02A338  00000000   NOP
9D02A33C  93C30014   LBU V1, 20(S8)
9D02A340  2402003E   ADDIU V0, ZERO, 62
9D02A344  1462FFE8   BNE V1, V0, 0x9D02A2E8
9D02A348  00000000   NOP
663:                 	
664:                 		// Put the length and data
665:                 		// Also, skip over the '.' in the input string
666:                 		Len = (BYTE)(RightPtr-String-1);
9D02A34C  8FC20010   LW V0, 16(S8)
9D02A350  304300FF   ANDI V1, V0, 255
9D02A354  8FC20020   LW V0, 32(S8)
9D02A358  304200FF   ANDI V0, V0, 255
9D02A35C  00621023   SUBU V0, V1, V0
9D02A360  304200FF   ANDI V0, V0, 255
9D02A364  2442FFFF   ADDIU V0, V0, -1
9D02A368  A3C20015   SB V0, 21(S8)
667:                 		UDPPut(Len);
9D02A36C  93C20015   LBU V0, 21(S8)
9D02A370  00402021   ADDU A0, V0, ZERO
9D02A374  0F40A32A   JAL UDPPut
9D02A378  00000000   NOP
668:                 		String += UDPPutArray(String, Len) + 1;
9D02A37C  93C20015   LBU V0, 21(S8)
9D02A380  8FC40020   LW A0, 32(S8)
9D02A384  00402821   ADDU A1, V0, ZERO
9D02A388  0F40A34D   JAL UDPPutArray
9D02A38C  00000000   NOP
9D02A390  24420001   ADDIU V0, V0, 1
9D02A394  8FC30020   LW V1, 32(S8)
9D02A398  00621021   ADDU V0, V1, V0
9D02A39C  AFC20020   SW V0, 32(S8)
669:                 
670:                 		if(i == 0x00u || i == '/' || i == ',' || i == '>')
9D02A3A0  93C20014   LBU V0, 20(S8)
9D02A3A4  1040000D   BEQ V0, ZERO, 0x9D02A3DC
9D02A3A8  00000000   NOP
9D02A3AC  93C30014   LBU V1, 20(S8)
9D02A3B0  2402002F   ADDIU V0, ZERO, 47
9D02A3B4  10620009   BEQ V1, V0, 0x9D02A3DC
9D02A3B8  00000000   NOP
9D02A3BC  93C30014   LBU V1, 20(S8)
9D02A3C0  2402002C   ADDIU V0, ZERO, 44
9D02A3C4  10620005   BEQ V1, V0, 0x9D02A3DC
9D02A3C8  00000000   NOP
9D02A3CC  93C30014   LBU V1, 20(S8)
9D02A3D0  2402003E   ADDIU V0, ZERO, 62
9D02A3D4  1462FFC3   BNE V1, V0, 0x9D02A2E4
9D02A3D8  00000000   NOP
671:                 			break;
672:                 	}
9D02A2E4  00000000   NOP
673:                 	
674:                 	// Put the string null terminator character (zero length label)
675:                 	UDPPut(0x00);
9D02A3DC  00002021   ADDU A0, ZERO, ZERO
9D02A3E0  0F40A32A   JAL UDPPut
9D02A3E4  00000000   NOP
676:                 }
9D02A3E8  03C0E821   ADDU SP, S8, ZERO
9D02A3EC  8FBF001C   LW RA, 28(SP)
9D02A3F0  8FBE0018   LW S8, 24(SP)
9D02A3F4  27BD0020   ADDIU SP, SP, 32
9D02A3F8  03E00008   JR RA
9D02A3FC  00000000   NOP
677:                 
678:                 /*****************************************************************************
679:                   Function:
680:                 	static void DNSPutROMString(ROM BYTE* String)
681:                 
682:                   Summary:
683:                 	Writes a ROM string to the DNS socket.
684:                 	
685:                   Description:
686:                 	This function writes a string to the DNS socket, ensuring that it is
687:                 	properly formatted.
688:                 
689:                   Precondition:
690:                 	UDP socket is obtained and ready for writing.
691:                 
692:                   Parameters:
693:                 	String - the string to write to the UDP socket.
694:                 
695:                   Returns:
696:                   	None
697:                   
698:                   Remarks:
699:                   	This function is aliased to DNSPutString on non-PIC18 platforms.
700:                   ***************************************************************************/
701:                 #if defined(__18CXX)
702:                 static void DNSPutROMString(ROM BYTE* String)
703:                 {
704:                 	ROM BYTE *RightPtr;
705:                 	BYTE i;
706:                 	BYTE Len;
707:                 
708:                 	RightPtr = String;
709:                 
710:                 	while(1)
711:                 	{
712:                 		do
713:                 		{
714:                 			i = *RightPtr++;
715:                 		} while((i != 0x00u) && (i != '.') && (i != '/') && (i != ',') && (i != '>'));
716:                 	
717:                 		// Put the length and data
718:                 		// Also, skip over the '.' in the input string
719:                 		Len = (BYTE)(RightPtr-String-1);
720:                 		UDPPut(Len);
721:                 		String += UDPPutROMArray(String, Len) + 1;
722:                 
723:                 		if(i == 0x00u || i == '/' || i == ',' || i == '>')
724:                 			break;
725:                 	}
726:                 	
727:                 	// Put the string terminator character (zero length label)
728:                 	UDPPut(0x00);
729:                 }
730:                 #endif
731:                 
732:                 
733:                 /*****************************************************************************
734:                   Function:
735:                 	static void DNSDiscardName(void)
736:                 
737:                   Summary:
738:                 	Reads a name string or string pointer from the DNS socket and discards it.
739:                 	
740:                   Description:
741:                 	This function reads a name string from the DNS socket.  Each string 
742:                 	consists of a series of labels.  Each label consists of a length prefix 
743:                 	byte, followed by the label bytes.  At the end of the string, a zero length 
744:                 	label is found as termination.  If name compression is used, this function 
745:                 	will automatically detect the pointer and discard it.
746:                 
747:                   Precondition:
748:                 	UDP socket is obtained and ready for reading a DNS name
749:                 
750:                   Parameters:
751:                 	None
752:                 
753:                   Returns:
754:                   	None
755:                   ***************************************************************************/
756:                 static void DNSDiscardName(void)
757:                 {
9D02A400  27BDFFE0   ADDIU SP, SP, -32
9D02A404  AFBF001C   SW RA, 28(SP)
9D02A408  AFBE0018   SW S8, 24(SP)
9D02A40C  03A0F021   ADDU S8, SP, ZERO
758:                 	BYTE i;
759:                 
760:                 	while(1)
761:                 	{
762:                 		// Get first byte which will tell us if this is a 16-bit pointer or the 
763:                 		// length of the first of a series of labels
764:                 		if(!UDPGet(&i))
9D02A410  27C20010   ADDIU V0, S8, 16
9D02A414  00402021   ADDU A0, V0, ZERO
9D02A418  0F40A421   JAL UDPGet
9D02A41C  00000000   NOP
9D02A420  10400016   BEQ V0, ZERO, 0x9D02A47C
9D02A424  00000000   NOP
765:                 			return;
9D02A47C  00000000   NOP
9D02A480  0B40A923   J 0x9D02A48C
9D02A484  00000000   NOP
766:                 		
767:                 		// Check if this is a pointer, if so, get the reminaing 8 bits and return
768:                 		if((i & 0xC0u) == 0xC0u)
9D02A428  93C20010   LBU V0, 16(S8)
9D02A42C  304300C0   ANDI V1, V0, 192
9D02A430  240200C0   ADDIU V0, ZERO, 192
9D02A434  14620007   BNE V1, V0, 0x9D02A454
9D02A438  00000000   NOP
769:                 		{
770:                 			UDPGet(&i);
9D02A43C  27C20010   ADDIU V0, S8, 16
9D02A440  00402021   ADDU A0, V0, ZERO
9D02A444  0F40A421   JAL UDPGet
9D02A448  00000000   NOP
771:                 			return;
9D02A44C  0B40A923   J 0x9D02A48C
9D02A450  00000000   NOP
772:                 		}
773:                 
774:                 		// Exit once we reach a zero length label
775:                 		if(i == 0u)					
9D02A454  93C20010   LBU V0, 16(S8)
9D02A458  1040000B   BEQ V0, ZERO, 0x9D02A488
9D02A45C  00000000   NOP
776:                 			return;
9D02A488  00000000   NOP
777:                 
778:                 		// Discard complete label
779:                 		UDPGetArray(NULL, i);		
9D02A460  93C20010   LBU V0, 16(S8)
9D02A464  00002021   ADDU A0, ZERO, ZERO
9D02A468  00402821   ADDU A1, V0, ZERO
9D02A46C  0F40A442   JAL UDPGetArray
9D02A470  00000000   NOP
780:                 	}
9D02A474  0B40A904   J 0x9D02A410
9D02A478  00000000   NOP
781:                 }
9D02A48C  03C0E821   ADDU SP, S8, ZERO
9D02A490  8FBF001C   LW RA, 28(SP)
9D02A494  8FBE0018   LW S8, 24(SP)
9D02A498  27BD0020   ADDIU SP, SP, 32
9D02A49C  03E00008   JR RA
9D02A4A0  00000000   NOP
782:                 
783:                 
784:                 #endif	//#if defined(STACK_USE_DNS)
---  C:/Users/Diego/Documents/GitHub/pic32webFREERtos/Pic32Web.X/src/tcpip/src/DHCPs.c  -----------------
1:                   /*********************************************************************
2:                    *
3:                    *  Dynamic Host Configuration Protocol (DHCP) Server
4:                    *  Module for Microchip TCP/IP Stack
5:                    *	 -Provides automatic IP address, subnet mask, gateway address, 
6:                    *	  DNS server address, and other configuration parameters on DHCP 
7:                    *	  enabled networks.
8:                    *	 -Reference: RFC 2131, 2132
9:                    *
10:                   *********************************************************************
11:                   * FileName:        DHCPs.c
12:                   * Dependencies:    UDP, ARP, Tick
13:                   * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32
14:                   * Compiler:        Microchip C32 v1.05 or higher
15:                   *					Microchip C30 v3.12 or higher
16:                   *					Microchip C18 v3.30 or higher
17:                   *					HI-TECH PICC-18 PRO 9.63PL2 or higher
18:                   * Company:         Microchip Technology, Inc.
19:                   *
20:                   * Software License Agreement
21:                   *
22:                   * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights
23:                   * reserved.
24:                   *
25:                   * Microchip licenses to you the right to use, modify, copy, and
26:                   * distribute:
27:                   * (i)  the Software when embedded on a Microchip microcontroller or
28:                   *      digital signal controller product ("Device") which is
29:                   *      integrated into Licensee's product; or
30:                   * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h,
31:                   *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device
32:                   *		used in conjunction with a Microchip ethernet controller for
33:                   *		the sole purpose of interfacing with the ethernet controller.
34:                   *
35:                   * You should refer to the license agreement accompanying this
36:                   * Software for additional information regarding your rights and
37:                   * obligations.
38:                   *
39:                   * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT
40:                   * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT
41:                   * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A
42:                   * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL
43:                   * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR
44:                   * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF
45:                   * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS
46:                   * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE
47:                   * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER
48:                   * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT
49:                   * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE.
50:                   *
51:                   *
52:                   * Author               Date    	Comment
53:                   *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
54:                   * Howard Schlunder     02/28/07	Original
55:                   ********************************************************************/
56:                  #define __DHCPS_C
57:                  
58:                  #include "TCPIPConfig.h"
59:                  
60:                  #if defined(STACK_USE_DHCP_SERVER)
61:                  
62:                  #include "TCPIP Stack/TCPIP.h"
63:                  
64:                  // Duration of our DHCP Lease in seconds.  This is extrememly short so 
65:                  // the client won't use our IP for long if we inadvertantly 
66:                  // provide a lease on a network that has a more authoratative DHCP server.
67:                  #define DHCP_LEASE_DURATION				60ul
68:                  /// Ignore: #define DHCP_MAX_LEASES					2		// Not implemented
69:                  
70:                  // DHCP Control Block.  Lease IP address is derived from index into DCB array.
71:                  typedef struct
72:                  {
73:                  	DWORD 		LeaseExpires;	// Expiration time for this lease
74:                  	MAC_ADDR	ClientMAC;		// Client's MAC address.  Multicase bit is used to determine if a lease is given out or not
75:                  	enum 
76:                  	{
77:                  		LEASE_UNUSED = 0,
78:                  		LEASE_REQUESTED,
79:                  		LEASE_GRANTED
80:                  	} smLease;					// Status of this lease
81:                  } DHCP_CONTROL_BLOCK;
82:                  
83:                  static UDP_SOCKET			MySocket;		// Socket used by DHCP Server
84:                  static IP_ADDR				DHCPNextLease;	// IP Address to provide for next lease
85:                  /// Ignore: static DHCP_CONTROL_BLOCK	DCB[DHCP_MAX_LEASES];	// Not Implmented
86:                  BOOL 						bDHCPServerEnabled = TRUE;	// Whether or not the DHCP server is enabled
87:                  
88:                  static void DHCPReplyToDiscovery(BOOTP_HEADER *Header);
89:                  static void DHCPReplyToRequest(BOOTP_HEADER *Header, BOOL bAccept);
90:                  
91:                  
92:                  /*****************************************************************************
93:                    Function:
94:                  	void DHCPServerTask(void)
95:                  
96:                    Summary:
97:                  	Performs periodic DHCP server tasks.
98:                  
99:                    Description:
100:                 	This function performs any periodic tasks requied by the DHCP server 
101:                 	module, such as processing DHCP requests and distributing IP addresses.
102:                 
103:                   Precondition:
104:                 	None
105:                 
106:                   Parameters:
107:                 	None
108:                 
109:                   Returns:
110:                   	None
111:                   ***************************************************************************/
112:                 void DHCPServerTask(void)
113:                 {
9D02B2D4  27BDFFB8   ADDIU SP, SP, -72
9D02B2D8  AFBF0044   SW RA, 68(SP)
9D02B2DC  AFBE0040   SW S8, 64(SP)
9D02B2E0  03A0F021   ADDU S8, SP, ZERO
114:                 	BYTE 				i;
115:                 	BYTE				Option, Len;
116:                 	BOOTP_HEADER		BOOTPHeader;
117:                 	DWORD				dw;
118:                 	BOOL				bAccept;
119:                 	static enum
120:                 	{
121:                 		DHCP_OPEN_SOCKET,
122:                 		DHCP_LISTEN
123:                 	} smDHCPServer = DHCP_OPEN_SOCKET;
124:                 
125:                 #if defined(STACK_USE_DHCP_CLIENT)
126:                 	// Make sure we don't clobber anyone else's DHCP server
127:                 	if(DHCPIsServerDetected(0))
9D02B2E4  00002021   ADDU A0, ZERO, ZERO
9D02B2E8  0F4090BC   JAL DHCPIsServerDetected
9D02B2EC  00000000   NOP
9D02B2F0  144000E7   BNE V0, ZERO, 0x9D02B690
9D02B2F4  00000000   NOP
128:                 		return;
9D02B690  00000000   NOP
9D02B694  0B40ADBA   J 0x9D02B6E8
9D02B698  00000000   NOP
129:                 #endif
130:                 
131:                 	if(!bDHCPServerEnabled)
9D02B2F8  8F828014   LW V0, -32748(GP)
9D02B2FC  104000E7   BEQ V0, ZERO, 0x9D02B69C
9D02B300  00000000   NOP
132:                 		return;
9D02B69C  00000000   NOP
9D02B6A0  0B40ADBA   J 0x9D02B6E8
9D02B6A4  00000000   NOP
133:                 
134:                 	switch(smDHCPServer)
9D02B304  8F8280E8   LW V0, -32536(GP)
9D02B308  10400006   BEQ V0, ZERO, 0x9D02B324
9D02B30C  00000000   NOP
9D02B310  24030001   ADDIU V1, ZERO, 1
9D02B314  1043002E   BEQ V0, V1, 0x9D02B3D0
9D02B318  00000000   NOP
9D02B31C  0B40ADBA   J 0x9D02B6E8
9D02B320  00000000   NOP
135:                 	{
136:                 		case DHCP_OPEN_SOCKET:
137:                 			// Obtain a UDP socket to listen/transmit on
138:                 			//MySocket = UDPOpen(DHCP_SERVER_PORT, NULL, DHCP_CLIENT_PORT);
139:                 			MySocket = UDPOpenEx(0,UDP_OPEN_SERVER,DHCP_SERVER_PORT, DHCP_CLIENT_PORT);
9D02B324  00002021   ADDU A0, ZERO, ZERO
9D02B328  00002821   ADDU A1, ZERO, ZERO
9D02B32C  24060043   ADDIU A2, ZERO, 67
9D02B330  24070044   ADDIU A3, ZERO, 68
9D02B334  0F40A0DD   JAL UDPOpenEx
9D02B338  00000000   NOP
9D02B33C  A38280E0   SB V0, -32544(GP)
140:                 			if(MySocket == INVALID_UDP_SOCKET)
9D02B340  938380E0   LBU V1, -32544(GP)
9D02B344  240200FF   ADDIU V0, ZERO, 255
9D02B348  106200D7   BEQ V1, V0, 0x9D02B6A8
9D02B34C  00000000   NOP
141:                 				break;
9D02B6A8  00000000   NOP
9D02B6AC  0B40ADBA   J 0x9D02B6E8
9D02B6B0  00000000   NOP
142:                 
143:                 
144:                 			// Decide which address to lease out
145:                 			// Note that this needs to be changed if we are to 
146:                 			// support more than one lease
147:                 			DHCPNextLease.Val = (AppConfig.MyIPAddr.Val & AppConfig.MyMask.Val) + 0x02000000;
9D02B350  3C02A000   LUI V0, -24576
9D02B354  24430728   ADDIU V1, V0, 1832
9D02B358  88630003   LWL V1, 3(V1)
9D02B35C  98430728   LWR V1, 1832(V0)
9D02B360  3C02A000   LUI V0, -24576
9D02B364  24420728   ADDIU V0, V0, 1832
9D02B368  88440007   LWL A0, 7(V0)
9D02B36C  00802821   ADDU A1, A0, ZERO
9D02B370  98450004   LWR A1, 4(V0)
9D02B374  00A01021   ADDU V0, A1, ZERO
9D02B378  00621824   AND V1, V1, V0
9D02B37C  3C020200   LUI V0, 512
9D02B380  00621021   ADDU V0, V1, V0
9D02B384  AF8280E4   SW V0, -32540(GP)
148:                 			if(DHCPNextLease.v[3] == 255u)
9D02B388  938380E7   LBU V1, -32537(GP)
9D02B38C  240200FF   ADDIU V0, ZERO, 255
9D02B390  14620005   BNE V1, V0, 0x9D02B3A8
9D02B394  00000000   NOP
149:                 				DHCPNextLease.v[3] += 0x03;
9D02B398  938280E7   LBU V0, -32537(GP)
9D02B39C  24420003   ADDIU V0, V0, 3
9D02B3A0  304200FF   ANDI V0, V0, 255
9D02B3A4  A38280E7   SB V0, -32537(GP)
150:                 			if(DHCPNextLease.v[3] == 0u)
9D02B3A8  938280E7   LBU V0, -32537(GP)
9D02B3AC  14400005   BNE V0, ZERO, 0x9D02B3C4
9D02B3B0  00000000   NOP
151:                 				DHCPNextLease.v[3] += 0x02;
9D02B3B4  938280E7   LBU V0, -32537(GP)
9D02B3B8  24420002   ADDIU V0, V0, 2
9D02B3BC  304200FF   ANDI V0, V0, 255
9D02B3C0  A38280E7   SB V0, -32537(GP)
152:                 
153:                 			smDHCPServer++;
9D02B3C4  8F8280E8   LW V0, -32536(GP)
9D02B3C8  24420001   ADDIU V0, V0, 1
9D02B3CC  AF8280E8   SW V0, -32536(GP)
154:                 
155:                 		case DHCP_LISTEN:
156:                 			// Check to see if a valid DHCP packet has arrived
157:                 			if(UDPIsGetReady(MySocket) < 241u)
9D02B3D0  938280E0   LBU V0, -32544(GP)
9D02B3D4  00402021   ADDU A0, V0, ZERO
9D02B3D8  0F40A3FD   JAL UDPIsGetReady
9D02B3DC  00000000   NOP
9D02B3E0  2C4200F1   SLTIU V0, V0, 241
9D02B3E4  144000B3   BNE V0, ZERO, 0x9D02B6B4
9D02B3E8  00000000   NOP
158:                 				break;
9D02B6B4  00000000   NOP
9D02B6B8  0B40ADBA   J 0x9D02B6E8
9D02B6BC  00000000   NOP
159:                 
160:                 			// Retrieve the BOOTP header
161:                 			UDPGetArray((BYTE*)&BOOTPHeader, sizeof(BOOTPHeader));
9D02B3EC  27C20018   ADDIU V0, S8, 24
9D02B3F0  00402021   ADDU A0, V0, ZERO
9D02B3F4  24050022   ADDIU A1, ZERO, 34
9D02B3F8  0F40A442   JAL UDPGetArray
9D02B3FC  00000000   NOP
162:                 
163:                 			bAccept = (BOOTPHeader.ClientIP.Val == DHCPNextLease.Val) || (BOOTPHeader.ClientIP.Val == 0x00000000u);
9D02B400  8FC30024   LW V1, 36(S8)
9D02B404  8F8280E4   LW V0, -32540(GP)
9D02B408  10620004   BEQ V1, V0, 0x9D02B41C
9D02B40C  00000000   NOP
9D02B410  8FC20024   LW V0, 36(S8)
9D02B414  14400004   BNE V0, ZERO, 0x9D02B428
9D02B418  00000000   NOP
9D02B41C  24020001   ADDIU V0, ZERO, 1
9D02B420  0B40AD0B   J 0x9D02B42C
9D02B424  00000000   NOP
9D02B428  00001021   ADDU V0, ZERO, ZERO
9D02B42C  AFC20010   SW V0, 16(S8)
164:                 
165:                 			// Validate first three fields
166:                 			if(BOOTPHeader.MessageType != 1u)
9D02B430  93C30018   LBU V1, 24(S8)
9D02B434  24020001   ADDIU V0, ZERO, 1
9D02B438  146200A1   BNE V1, V0, 0x9D02B6C0
9D02B43C  00000000   NOP
167:                 				break;
9D02B6C0  00000000   NOP
9D02B6C4  0B40ADBA   J 0x9D02B6E8
9D02B6C8  00000000   NOP
168:                 			if(BOOTPHeader.HardwareType != 1u)
9D02B440  93C30019   LBU V1, 25(S8)
9D02B444  24020001   ADDIU V0, ZERO, 1
9D02B448  146200A0   BNE V1, V0, 0x9D02B6CC
9D02B44C  00000000   NOP
169:                 				break;
9D02B6CC  00000000   NOP
9D02B6D0  0B40ADBA   J 0x9D02B6E8
9D02B6D4  00000000   NOP
170:                 			if(BOOTPHeader.HardwareLen != 6u)
9D02B450  93C3001A   LBU V1, 26(S8)
9D02B454  24020006   ADDIU V0, ZERO, 6
9D02B458  1462009F   BNE V1, V0, 0x9D02B6D8
9D02B45C  00000000   NOP
171:                 				break;
9D02B6D8  00000000   NOP
9D02B6DC  0B40ADBA   J 0x9D02B6E8
9D02B6E0  00000000   NOP
172:                 
173:                 			// Throw away 10 unused bytes of hardware address,
174:                 			// server host name, and boot file name -- unsupported/not needed.
175:                 			for(i = 0; i < 64+128+(16-sizeof(MAC_ADDR)); i++)
9D02B460  A3C00014   SB ZERO, 20(S8)
9D02B464  0B40AD23   J 0x9D02B48C
9D02B468  00000000   NOP
9D02B47C  93C20014   LBU V0, 20(S8)
9D02B480  24420001   ADDIU V0, V0, 1
9D02B484  304200FF   ANDI V0, V0, 255
9D02B488  A3C20014   SB V0, 20(S8)
9D02B48C  93C20014   LBU V0, 20(S8)
9D02B490  2C4200CA   SLTIU V0, V0, 202
9D02B494  1440FFF5   BNE V0, ZERO, 0x9D02B46C
9D02B498  00000000   NOP
176:                 				UDPGet(&Option);
9D02B46C  27C20015   ADDIU V0, S8, 21
9D02B470  00402021   ADDU A0, V0, ZERO
9D02B474  0F40A421   JAL UDPGet
9D02B478  00000000   NOP
177:                 
178:                 			// Obtain Magic Cookie and verify
179:                 			UDPGetArray((BYTE*)&dw, sizeof(DWORD));
9D02B49C  27C2003C   ADDIU V0, S8, 60
9D02B4A0  00402021   ADDU A0, V0, ZERO
9D02B4A4  24050004   ADDIU A1, ZERO, 4
9D02B4A8  0F40A442   JAL UDPGetArray
9D02B4AC  00000000   NOP
180:                 			if(dw != 0x63538263ul)
9D02B4B0  8FC3003C   LW V1, 60(S8)
9D02B4B4  3C026353   LUI V0, 25427
9D02B4B8  34428263   ORI V0, V0, -32157
9D02B4BC  14620089   BNE V1, V0, 0x9D02B6E4
9D02B4C0  00000000   NOP
181:                 				break;
9D02B6E4  00000000   NOP
182:                 
183:                 			// Obtain options
184:                 			while(1)
185:                 			{
186:                 				// Get option type
187:                 				if(!UDPGet(&Option))
9D02B4C4  27C20015   ADDIU V0, S8, 21
9D02B4C8  00402021   ADDU A0, V0, ZERO
9D02B4CC  0F40A421   JAL UDPGet
9D02B4D0  00000000   NOP
9D02B4D4  10400065   BEQ V0, ZERO, 0x9D02B66C
9D02B4D8  00000000   NOP
188:                 					break;
9D02B66C  00000000   NOP
9D02B670  0B40AD9F   J 0x9D02B67C
9D02B674  00000000   NOP
189:                 				if(Option == DHCP_END_OPTION)
9D02B4DC  93C30015   LBU V1, 21(S8)
9D02B4E0  240200FF   ADDIU V0, ZERO, 255
9D02B4E4  10620064   BEQ V1, V0, 0x9D02B678
9D02B4E8  00000000   NOP
190:                 					break;
9D02B678  00000000   NOP
191:                 
192:                 				// Get option length
193:                 				UDPGet(&Len);
9D02B4EC  27C20016   ADDIU V0, S8, 22
9D02B4F0  00402021   ADDU A0, V0, ZERO
9D02B4F4  0F40A421   JAL UDPGet
9D02B4F8  00000000   NOP
194:                 	
195:                 				// Process option
196:                 				switch(Option)
9D02B4FC  93C20015   LBU V0, 21(S8)
9D02B500  24030035   ADDIU V1, ZERO, 53
9D02B504  10430009   BEQ V0, V1, 0x9D02B52C
9D02B508  00000000   NOP
9D02B50C  240300FF   ADDIU V1, ZERO, 255
9D02B510  10430042   BEQ V0, V1, 0x9D02B61C
9D02B514  00000000   NOP
9D02B518  24030032   ADDIU V1, ZERO, 50
9D02B51C  1043002B   BEQ V0, V1, 0x9D02B5CC
9D02B520  00000000   NOP
197:                 				{
198:                 					case DHCP_MESSAGE_TYPE:
199:                 						UDPGet(&i);
9D02B52C  27C20014   ADDIU V0, S8, 20
9D02B530  00402021   ADDU A0, V0, ZERO
9D02B534  0F40A421   JAL UDPGet
9D02B538  00000000   NOP
200:                 						switch(i)
9D02B53C  93C20014   LBU V0, 20(S8)
9D02B540  24030003   ADDIU V1, ZERO, 3
9D02B544  10430017   BEQ V0, V1, 0x9D02B5A4
9D02B548  00000000   NOP
9D02B54C  28430004   SLTI V1, V0, 4
9D02B550  10600006   BEQ V1, ZERO, 0x9D02B56C
9D02B554  00000000   NOP
9D02B558  24030001   ADDIU V1, ZERO, 1
9D02B55C  1043000B   BEQ V0, V1, 0x9D02B58C
9D02B560  00000000   NOP
9D02B564  0B40AD71   J 0x9D02B5C4
9D02B568  00000000   NOP
9D02B56C  24030004   ADDIU V1, ZERO, 4
9D02B570  10430013   BEQ V0, V1, 0x9D02B5C0
9D02B574  00000000   NOP
9D02B578  24030007   ADDIU V1, ZERO, 7
9D02B57C  10430010   BEQ V0, V1, 0x9D02B5C0
9D02B580  00000000   NOP
9D02B584  0B40AD71   J 0x9D02B5C4
9D02B588  00000000   NOP
201:                 						{
202:                 							case DHCP_DISCOVER_MESSAGE:
203:                 								DHCPReplyToDiscovery(&BOOTPHeader);
9D02B58C  27C20018   ADDIU V0, S8, 24
9D02B590  00402021   ADDU A0, V0, ZERO
9D02B594  0F40ADC0   JAL 0x9D02B700
9D02B598  00000000   NOP
204:                 								break;
9D02B59C  0B40AD71   J 0x9D02B5C4
9D02B5A0  00000000   NOP
205:                 
206:                 							case DHCP_REQUEST_MESSAGE:
207:                 								DHCPReplyToRequest(&BOOTPHeader, bAccept);
9D02B5A4  27C20018   ADDIU V0, S8, 24
9D02B5A8  00402021   ADDU A0, V0, ZERO
9D02B5AC  8FC50010   LW A1, 16(S8)
9D02B5B0  0F40AE92   JAL 0x9D02BA48
9D02B5B4  00000000   NOP
208:                 								break;
9D02B5B8  0B40AD71   J 0x9D02B5C4
9D02B5BC  00000000   NOP
209:                 
210:                 							// Need to handle these if supporting more than one DHCP lease
211:                 							case DHCP_RELEASE_MESSAGE:
212:                 							case DHCP_DECLINE_MESSAGE:
213:                 								break;
9D02B5C0  00000000   NOP
214:                 						}
215:                 						break;
9D02B5C4  0B40AD8B   J 0x9D02B62C
9D02B5C8  00000000   NOP
216:                 
217:                 					case DHCP_PARAM_REQUEST_IP_ADDRESS:
218:                 						if(Len == 4u)
9D02B5CC  93C30016   LBU V1, 22(S8)
9D02B5D0  24020004   ADDIU V0, ZERO, 4
9D02B5D4  1462000F   BNE V1, V0, 0x9D02B614
9D02B5D8  00000000   NOP
219:                 						{
220:                 							// Get the requested IP address and see if it is the one we have on offer.
221:                 							UDPGetArray((BYTE*)&dw, 4);
9D02B5DC  27C2003C   ADDIU V0, S8, 60
9D02B5E0  00402021   ADDU A0, V0, ZERO
9D02B5E4  24050004   ADDIU A1, ZERO, 4
9D02B5E8  0F40A442   JAL UDPGetArray
9D02B5EC  00000000   NOP
222:                 							Len -= 4;
9D02B5F0  93C20016   LBU V0, 22(S8)
9D02B5F4  2442FFFC   ADDIU V0, V0, -4
9D02B5F8  304200FF   ANDI V0, V0, 255
9D02B5FC  A3C20016   SB V0, 22(S8)
223:                 							bAccept = (dw == DHCPNextLease.Val);
9D02B600  8F8380E4   LW V1, -32540(GP)
9D02B604  8FC2003C   LW V0, 60(S8)
9D02B608  00621026   XOR V0, V1, V0
9D02B60C  2C420001   SLTIU V0, V0, 1
9D02B610  AFC20010   SW V0, 16(S8)
224:                 						}
225:                 						break;
9D02B614  0B40AD8B   J 0x9D02B62C
9D02B618  00000000   NOP
226:                 
227:                 					case DHCP_END_OPTION:
228:                 						UDPDiscard();
9D02B61C  0F40A472   JAL UDPDiscard
9D02B620  00000000   NOP
229:                 						return;
9D02B624  0B40ADBA   J 0x9D02B6E8
9D02B628  00000000   NOP
230:                 				}
231:                 
232:                 				// Remove any unprocessed bytes that we don't care about
233:                 				while(Len--)
9D02B524  0B40AD91   J 0x9D02B644
9D02B528  00000000   NOP
9D02B62C  0B40AD91   J 0x9D02B644
9D02B630  00000000   NOP
9D02B644  93C20016   LBU V0, 22(S8)
9D02B648  0002182B   SLTU V1, ZERO, V0
9D02B64C  306300FF   ANDI V1, V1, 255
9D02B650  2442FFFF   ADDIU V0, V0, -1
9D02B654  304200FF   ANDI V0, V0, 255
9D02B658  A3C20016   SB V0, 22(S8)
9D02B65C  1460FFF5   BNE V1, ZERO, 0x9D02B634
9D02B660  00000000   NOP
234:                 				{
235:                 					UDPGet(&i);
9D02B634  27C20014   ADDIU V0, S8, 20
9D02B638  00402021   ADDU A0, V0, ZERO
9D02B63C  0F40A421   JAL UDPGet
9D02B640  00000000   NOP
236:                 				}
237:                 			}			
9D02B664  0B40AD31   J 0x9D02B4C4
9D02B668  00000000   NOP
238:                 
239:                 			UDPDiscard();
9D02B67C  0F40A472   JAL UDPDiscard
9D02B680  00000000   NOP
240:                 			break;
9D02B684  00000000   NOP
9D02B688  0B40ADBA   J 0x9D02B6E8
9D02B68C  00000000   NOP
241:                 	}
242:                 }
9D02B6E8  03C0E821   ADDU SP, S8, ZERO
9D02B6EC  8FBF0044   LW RA, 68(SP)
9D02B6F0  8FBE0040   LW S8, 64(SP)
9D02B6F4  27BD0048   ADDIU SP, SP, 72
9D02B6F8  03E00008   JR RA
9D02B6FC  00000000   NOP
243:                 
244:                 
245:                 /*****************************************************************************
246:                   Function:
247:                 	static void DHCPReplyToDiscovery(BOOTP_HEADER *Header)
248:                 
249:                   Summary:
250:                 	Replies to a DHCP Discover message.
251:                 
252:                   Description:
253:                 	This function replies to a DHCP Discover message by sending out a 
254:                 	DHCP Offer message.
255:                 
256:                   Precondition:
257:                 	None
258:                 
259:                   Parameters:
260:                 	Header - the BootP header this is in response to.
261:                 
262:                   Returns:
263:                   	None
264:                   ***************************************************************************/
265:                 static void DHCPReplyToDiscovery(BOOTP_HEADER *Header)
266:                 {
9D02B700  27BDFFE0   ADDIU SP, SP, -32
9D02B704  AFBF001C   SW RA, 28(SP)
9D02B708  AFBE0018   SW S8, 24(SP)
9D02B70C  03A0F021   ADDU S8, SP, ZERO
9D02B710  AFC40020   SW A0, 32(S8)
267:                 	BYTE i;
268:                 
269:                 	// Set the correct socket to active and ensure that 
270:                 	// enough space is available to generate the DHCP response
271:                 	if(UDPIsPutReady(MySocket) < 300u)
9D02B714  938280E0   LBU V0, -32544(GP)
9D02B718  00402021   ADDU A0, V0, ZERO
9D02B71C  0F40A307   JAL UDPIsPutReady
9D02B720  00000000   NOP
9D02B724  2C42012C   SLTIU V0, V0, 300
9D02B728  144000C0   BNE V0, ZERO, 0x9D02BA2C
9D02B72C  00000000   NOP
272:                 		return;
9D02BA2C  00000000   NOP
273:                 
274:                 	// Begin putting the BOOTP Header and DHCP options
275:                 	UDPPut(BOOT_REPLY);			// Message Type: 2 (BOOTP Reply)
9D02B730  24040002   ADDIU A0, ZERO, 2
9D02B734  0F40A32A   JAL UDPPut
9D02B738  00000000   NOP
276:                 	// Reply with the same Hardware Type, Hardware Address Length, Hops, and Transaction ID fields
277:                 	UDPPutArray((BYTE*)&(Header->HardwareType), 7);
9D02B73C  8FC20020   LW V0, 32(S8)
9D02B740  24420001   ADDIU V0, V0, 1
9D02B744  00402021   ADDU A0, V0, ZERO
9D02B748  24050007   ADDIU A1, ZERO, 7
9D02B74C  0F40A34D   JAL UDPPutArray
9D02B750  00000000   NOP
278:                 	UDPPut(0x00);				// Seconds Elapsed: 0 (Not used)
9D02B754  00002021   ADDU A0, ZERO, ZERO
9D02B758  0F40A32A   JAL UDPPut
9D02B75C  00000000   NOP
279:                 	UDPPut(0x00);				// Seconds Elapsed: 0 (Not used)
9D02B760  00002021   ADDU A0, ZERO, ZERO
9D02B764  0F40A32A   JAL UDPPut
9D02B768  00000000   NOP
280:                 	UDPPutArray((BYTE*)&(Header->BootpFlags), sizeof(Header->BootpFlags));
9D02B76C  8FC20020   LW V0, 32(S8)
9D02B770  2442000A   ADDIU V0, V0, 10
9D02B774  00402021   ADDU A0, V0, ZERO
9D02B778  24050002   ADDIU A1, ZERO, 2
9D02B77C  0F40A34D   JAL UDPPutArray
9D02B780  00000000   NOP
281:                 	UDPPut(0x00);				// Your (client) IP Address: 0.0.0.0 (none yet assigned)
9D02B784  00002021   ADDU A0, ZERO, ZERO
9D02B788  0F40A32A   JAL UDPPut
9D02B78C  00000000   NOP
282:                 	UDPPut(0x00);				// Your (client) IP Address: 0.0.0.0 (none yet assigned)
9D02B790  00002021   ADDU A0, ZERO, ZERO
9D02B794  0F40A32A   JAL UDPPut
9D02B798  00000000   NOP
283:                 	UDPPut(0x00);				// Your (client) IP Address: 0.0.0.0 (none yet assigned)
9D02B79C  00002021   ADDU A0, ZERO, ZERO
9D02B7A0  0F40A32A   JAL UDPPut
9D02B7A4  00000000   NOP
284:                 	UDPPut(0x00);				// Your (client) IP Address: 0.0.0.0 (none yet assigned)
9D02B7A8  00002021   ADDU A0, ZERO, ZERO
9D02B7AC  0F40A32A   JAL UDPPut
9D02B7B0  00000000   NOP
285:                 	UDPPutArray((BYTE*)&DHCPNextLease, sizeof(IP_ADDR));	// Lease IP address to give out
9D02B7B4  278480E4   ADDIU A0, GP, -32540
9D02B7B8  24050004   ADDIU A1, ZERO, 4
9D02B7BC  0F40A34D   JAL UDPPutArray
9D02B7C0  00000000   NOP
286:                 	UDPPut(0x00);				// Next Server IP Address: 0.0.0.0 (not used)
9D02B7C4  00002021   ADDU A0, ZERO, ZERO
9D02B7C8  0F40A32A   JAL UDPPut
9D02B7CC  00000000   NOP
287:                 	UDPPut(0x00);				// Next Server IP Address: 0.0.0.0 (not used)
9D02B7D0  00002021   ADDU A0, ZERO, ZERO
9D02B7D4  0F40A32A   JAL UDPPut
9D02B7D8  00000000   NOP
288:                 	UDPPut(0x00);				// Next Server IP Address: 0.0.0.0 (not used)
9D02B7DC  00002021   ADDU A0, ZERO, ZERO
9D02B7E0  0F40A32A   JAL UDPPut
9D02B7E4  00000000   NOP
289:                 	UDPPut(0x00);				// Next Server IP Address: 0.0.0.0 (not used)
9D02B7E8  00002021   ADDU A0, ZERO, ZERO
9D02B7EC  0F40A32A   JAL UDPPut
9D02B7F0  00000000   NOP
290:                 	UDPPut(0x00);				// Relay Agent IP Address: 0.0.0.0 (not used)
9D02B7F4  00002021   ADDU A0, ZERO, ZERO
9D02B7F8  0F40A32A   JAL UDPPut
9D02B7FC  00000000   NOP
291:                 	UDPPut(0x00);				// Relay Agent IP Address: 0.0.0.0 (not used)
9D02B800  00002021   ADDU A0, ZERO, ZERO
9D02B804  0F40A32A   JAL UDPPut
9D02B808  00000000   NOP
292:                 	UDPPut(0x00);				// Relay Agent IP Address: 0.0.0.0 (not used)
9D02B80C  00002021   ADDU A0, ZERO, ZERO
9D02B810  0F40A32A   JAL UDPPut
9D02B814  00000000   NOP
293:                 	UDPPut(0x00);				// Relay Agent IP Address: 0.0.0.0 (not used)
9D02B818  00002021   ADDU A0, ZERO, ZERO
9D02B81C  0F40A32A   JAL UDPPut
9D02B820  00000000   NOP
294:                 	UDPPutArray((BYTE*)&(Header->ClientMAC), sizeof(MAC_ADDR));	// Client MAC address: Same as given by client
9D02B824  8FC20020   LW V0, 32(S8)
9D02B828  2442001C   ADDIU V0, V0, 28
9D02B82C  00402021   ADDU A0, V0, ZERO
9D02B830  24050006   ADDIU A1, ZERO, 6
9D02B834  0F40A34D   JAL UDPPutArray
9D02B838  00000000   NOP
295:                 	for(i = 0; i < 64+128+(16-sizeof(MAC_ADDR)); i++)	// Remaining 10 bytes of client hardware address, server host name: Null string (not used)
9D02B83C  A3C00010   SB ZERO, 16(S8)
9D02B840  0B40AE18   J 0x9D02B860
9D02B844  00000000   NOP
9D02B854  93C20010   LBU V0, 16(S8)
9D02B858  24420001   ADDIU V0, V0, 1
9D02B85C  A3C20010   SB V0, 16(S8)
9D02B860  93C20010   LBU V0, 16(S8)
9D02B864  2C4200CA   SLTIU V0, V0, 202
9D02B868  1440FFF7   BNE V0, ZERO, 0x9D02B848
9D02B86C  00000000   NOP
296:                 		UDPPut(0x00);									// Boot filename: Null string (not used)
9D02B848  00002021   ADDU A0, ZERO, ZERO
9D02B84C  0F40A32A   JAL UDPPut
9D02B850  00000000   NOP
297:                 	UDPPut(0x63);				// Magic Cookie: 0x63538263
9D02B870  24040063   ADDIU A0, ZERO, 99
9D02B874  0F40A32A   JAL UDPPut
9D02B878  00000000   NOP
298:                 	UDPPut(0x82);				// Magic Cookie: 0x63538263
9D02B87C  24040082   ADDIU A0, ZERO, 130
9D02B880  0F40A32A   JAL UDPPut
9D02B884  00000000   NOP
299:                 	UDPPut(0x53);				// Magic Cookie: 0x63538263
9D02B888  24040053   ADDIU A0, ZERO, 83
9D02B88C  0F40A32A   JAL UDPPut
9D02B890  00000000   NOP
300:                 	UDPPut(0x63);				// Magic Cookie: 0x63538263
9D02B894  24040063   ADDIU A0, ZERO, 99
9D02B898  0F40A32A   JAL UDPPut
9D02B89C  00000000   NOP
301:                 	
302:                 	// Options: DHCP Offer
303:                 	UDPPut(DHCP_MESSAGE_TYPE);	
9D02B8A0  24040035   ADDIU A0, ZERO, 53
9D02B8A4  0F40A32A   JAL UDPPut
9D02B8A8  00000000   NOP
304:                 	UDPPut(1);
9D02B8AC  24040001   ADDIU A0, ZERO, 1
9D02B8B0  0F40A32A   JAL UDPPut
9D02B8B4  00000000   NOP
305:                 	UDPPut(DHCP_OFFER_MESSAGE);
9D02B8B8  24040002   ADDIU A0, ZERO, 2
9D02B8BC  0F40A32A   JAL UDPPut
9D02B8C0  00000000   NOP
306:                 
307:                 	// Option: Subnet Mask
308:                 	UDPPut(DHCP_SUBNET_MASK);
9D02B8C4  24040001   ADDIU A0, ZERO, 1
9D02B8C8  0F40A32A   JAL UDPPut
9D02B8CC  00000000   NOP
309:                 	UDPPut(sizeof(IP_ADDR));
9D02B8D0  24040004   ADDIU A0, ZERO, 4
9D02B8D4  0F40A32A   JAL UDPPut
9D02B8D8  00000000   NOP
310:                 	UDPPutArray((BYTE*)&AppConfig.MyMask, sizeof(IP_ADDR));
9D02B8DC  3C02A000   LUI V0, -24576
9D02B8E0  2444072C   ADDIU A0, V0, 1836
9D02B8E4  24050004   ADDIU A1, ZERO, 4
9D02B8E8  0F40A34D   JAL UDPPutArray
9D02B8EC  00000000   NOP
311:                 
312:                 	// Option: Lease duration
313:                 	UDPPut(DHCP_IP_LEASE_TIME);
9D02B8F0  24040033   ADDIU A0, ZERO, 51
9D02B8F4  0F40A32A   JAL UDPPut
9D02B8F8  00000000   NOP
314:                 	UDPPut(4);
9D02B8FC  24040004   ADDIU A0, ZERO, 4
9D02B900  0F40A32A   JAL UDPPut
9D02B904  00000000   NOP
315:                 	UDPPut((DHCP_LEASE_DURATION>>24) & 0xFF);
9D02B908  00002021   ADDU A0, ZERO, ZERO
9D02B90C  0F40A32A   JAL UDPPut
9D02B910  00000000   NOP
316:                 	UDPPut((DHCP_LEASE_DURATION>>16) & 0xFF);
9D02B914  00002021   ADDU A0, ZERO, ZERO
9D02B918  0F40A32A   JAL UDPPut
9D02B91C  00000000   NOP
317:                 	UDPPut((DHCP_LEASE_DURATION>>8) & 0xFF);
9D02B920  00002021   ADDU A0, ZERO, ZERO
9D02B924  0F40A32A   JAL UDPPut
9D02B928  00000000   NOP
318:                 	UDPPut((DHCP_LEASE_DURATION) & 0xFF);
9D02B92C  2404003C   ADDIU A0, ZERO, 60
9D02B930  0F40A32A   JAL UDPPut
9D02B934  00000000   NOP
319:                 
320:                 	// Option: Server identifier
321:                 	UDPPut(DHCP_SERVER_IDENTIFIER);	
9D02B938  24040036   ADDIU A0, ZERO, 54
9D02B93C  0F40A32A   JAL UDPPut
9D02B940  00000000   NOP
322:                 	UDPPut(sizeof(IP_ADDR));
9D02B944  24040004   ADDIU A0, ZERO, 4
9D02B948  0F40A32A   JAL UDPPut
9D02B94C  00000000   NOP
323:                 	UDPPutArray((BYTE*)&AppConfig.MyIPAddr, sizeof(IP_ADDR));
9D02B950  3C02A000   LUI V0, -24576
9D02B954  24440728   ADDIU A0, V0, 1832
9D02B958  24050004   ADDIU A1, ZERO, 4
9D02B95C  0F40A34D   JAL UDPPutArray
9D02B960  00000000   NOP
324:                 
325:                 	// Option: Router/Gateway address
326:                 	UDPPut(DHCP_ROUTER);		
9D02B964  24040003   ADDIU A0, ZERO, 3
9D02B968  0F40A32A   JAL UDPPut
9D02B96C  00000000   NOP
327:                 	UDPPut(sizeof(IP_ADDR));
9D02B970  24040004   ADDIU A0, ZERO, 4
9D02B974  0F40A32A   JAL UDPPut
9D02B978  00000000   NOP
328:                 	UDPPutArray((BYTE*)&AppConfig.MyIPAddr, sizeof(IP_ADDR));
9D02B97C  3C02A000   LUI V0, -24576
9D02B980  24440728   ADDIU A0, V0, 1832
9D02B984  24050004   ADDIU A1, ZERO, 4
9D02B988  0F40A34D   JAL UDPPutArray
9D02B98C  00000000   NOP
329:                 
330:                 	// Option: DNS server address
331:                 	UDPPut(DHCP_DNS);
9D02B990  24040006   ADDIU A0, ZERO, 6
9D02B994  0F40A32A   JAL UDPPut
9D02B998  00000000   NOP
332:                 	UDPPut(sizeof(IP_ADDR));
9D02B99C  24040004   ADDIU A0, ZERO, 4
9D02B9A0  0F40A32A   JAL UDPPut
9D02B9A4  00000000   NOP
333:                 	UDPPutArray((BYTE*)&AppConfig.MyIPAddr, sizeof(IP_ADDR));
9D02B9A8  3C02A000   LUI V0, -24576
9D02B9AC  24440728   ADDIU A0, V0, 1832
9D02B9B0  24050004   ADDIU A1, ZERO, 4
9D02B9B4  0F40A34D   JAL UDPPutArray
9D02B9B8  00000000   NOP
334:                 
335:                 	// No more options, mark ending
336:                 	UDPPut(DHCP_END_OPTION);
9D02B9BC  240400FF   ADDIU A0, ZERO, 255
9D02B9C0  0F40A32A   JAL UDPPut
9D02B9C4  00000000   NOP
337:                 
338:                 	// Add zero padding to ensure compatibility with old BOOTP relays that discard small packets (<300 UDP octets)
339:                 	while(UDPTxCount < 300u)
9D02B9C8  0B40AE77   J 0x9D02B9DC
9D02B9CC  00000000   NOP
9D02B9DC  978281EA   LHU V0, -32278(GP)
9D02B9E0  2C42012C   SLTIU V0, V0, 300
9D02B9E4  1440FFFA   BNE V0, ZERO, 0x9D02B9D0
9D02B9E8  00000000   NOP
340:                 		UDPPut(0); 
9D02B9D0  00002021   ADDU A0, ZERO, ZERO
9D02B9D4  0F40A32A   JAL UDPPut
9D02B9D8  00000000   NOP
341:                 
342:                 	// Force remote destination address to be the broadcast address, regardless 
343:                 	// of what the node's source IP address was (to ensure we don't try to 
344:                 	// unicast to 0.0.0.0).
345:                 	memset((void*)&UDPSocketInfo[MySocket].remote.remoteNode, 0xFF, sizeof(NODE_INFO));
9D02B9EC  938280E0   LBU V0, -32544(GP)
9D02B9F0  00401821   ADDU V1, V0, ZERO
9D02B9F4  2402001C   ADDIU V0, ZERO, 28
9D02B9F8  70621802   MUL V1, V1, V0
9D02B9FC  3C02A000   LUI V0, -24576
9D02BA00  24420648   ADDIU V0, V0, 1608
9D02BA04  00621021   ADDU V0, V1, V0
9D02BA08  00402021   ADDU A0, V0, ZERO
9D02BA0C  240500FF   ADDIU A1, ZERO, 255
9D02BA10  2406000A   ADDIU A2, ZERO, 10
9D02BA14  0F40D5EC   JAL 0x9D0357B0
9D02BA18  00000000   NOP
346:                 
347:                 	// Transmit the packet
348:                 	UDPFlush();
9D02BA1C  0F40A38D   JAL UDPFlush
9D02BA20  00000000   NOP
9D02BA24  0B40AE8C   J 0x9D02BA30
9D02BA28  00000000   NOP
349:                 }
9D02BA30  03C0E821   ADDU SP, S8, ZERO
9D02BA34  8FBF001C   LW RA, 28(SP)
9D02BA38  8FBE0018   LW S8, 24(SP)
9D02BA3C  27BD0020   ADDIU SP, SP, 32
9D02BA40  03E00008   JR RA
9D02BA44  00000000   NOP
350:                 
351:                 
352:                 /*****************************************************************************
353:                   Function:
354:                 	static void DHCPReplyToRequest(BOOTP_HEADER *Header, BOOL bAccept)
355:                 
356:                   Summary:
357:                 	Replies to a DHCP Request message.
358:                 
359:                   Description:
360:                 	This function replies to a DHCP Request message by sending out a 
361:                 	DHCP Acknowledge message.
362:                 
363:                   Precondition:
364:                 	None
365:                 
366:                   Parameters:
367:                 	Header - the BootP header this is in response to.
368:                 	bAccept - whether or not we've accepted this request
369:                 
370:                   Returns:
371:                   	None
372:                   
373:                   Internal:
374:                 	Needs to support more than one simultaneous lease in the future.
375:                   ***************************************************************************/
376:                 static void DHCPReplyToRequest(BOOTP_HEADER *Header, BOOL bAccept)
377:                 {
9D02BA48  27BDFFE0   ADDIU SP, SP, -32
9D02BA4C  AFBF001C   SW RA, 28(SP)
9D02BA50  AFBE0018   SW S8, 24(SP)
9D02BA54  03A0F021   ADDU S8, SP, ZERO
9D02BA58  AFC40020   SW A0, 32(S8)
9D02BA5C  AFC50024   SW A1, 36(S8)
378:                 	BYTE i;
379:                 
380:                 	// Set the correct socket to active and ensure that 
381:                 	// enough space is available to generate the DHCP response
382:                 	if(UDPIsPutReady(MySocket) < 300u)
9D02BA60  938280E0   LBU V0, -32544(GP)
9D02BA64  00402021   ADDU A0, V0, ZERO
9D02BA68  0F40A307   JAL UDPIsPutReady
9D02BA6C  00000000   NOP
9D02BA70  2C42012C   SLTIU V0, V0, 300
9D02BA74  1040003D   BEQ V0, ZERO, 0x9D02BB6C
9D02BA78  00000000   NOP
383:                 		return;
9D02BA7C  0B40AFB1   J 0x9D02BEC4
9D02BA80  00000000   NOP
384:                 
385:                 	// Search through all remaining options and look for the Requested IP address field
386:                 	// Obtain options
387:                 	while(UDPIsGetReady(MySocket))
9D02BB6C  00000000   NOP
9D02BB70  938280E0   LBU V0, -32544(GP)
9D02BB74  00402021   ADDU A0, V0, ZERO
9D02BB78  0F40A3FD   JAL UDPIsGetReady
9D02BB7C  00000000   NOP
9D02BB80  1440FFC0   BNE V0, ZERO, 0x9D02BA84
9D02BB84  00000000   NOP
9D02BB88  0B40AEEB   J 0x9D02BBAC
9D02BB8C  00000000   NOP
388:                 	{
389:                 		BYTE Option, Len;
390:                 		DWORD dw;
391:                 
392:                 		// Get option type
393:                 		if(!UDPGet(&Option))
9D02BA84  27C20011   ADDIU V0, S8, 17
9D02BA88  00402021   ADDU A0, V0, ZERO
9D02BA8C  0F40A421   JAL UDPGet
9D02BA90  00000000   NOP
9D02BA94  1040003E   BEQ V0, ZERO, 0x9D02BB90
9D02BA98  00000000   NOP
394:                 			break;
9D02BB90  00000000   NOP
9D02BB94  0B40AEEB   J 0x9D02BBAC
9D02BB98  00000000   NOP
395:                 		if(Option == DHCP_END_OPTION)
9D02BA9C  93C30011   LBU V1, 17(S8)
9D02BAA0  240200FF   ADDIU V0, ZERO, 255
9D02BAA4  1062003D   BEQ V1, V0, 0x9D02BB9C
9D02BAA8  00000000   NOP
396:                 			break;
9D02BB9C  00000000   NOP
9D02BBA0  0B40AEEB   J 0x9D02BBAC
9D02BBA4  00000000   NOP
397:                 
398:                 		// Get option length
399:                 		UDPGet(&Len);
9D02BAAC  27C20012   ADDIU V0, S8, 18
9D02BAB0  00402021   ADDU A0, V0, ZERO
9D02BAB4  0F40A421   JAL UDPGet
9D02BAB8  00000000   NOP
400:                 
401:                 		// Process option
402:                 		if((Option == DHCP_PARAM_REQUEST_IP_ADDRESS) && (Len == 4u))
9D02BABC  93C30011   LBU V1, 17(S8)
9D02BAC0  24020032   ADDIU V0, ZERO, 50
9D02BAC4  1462001B   BNE V1, V0, 0x9D02BB34
9D02BAC8  00000000   NOP
9D02BACC  93C30012   LBU V1, 18(S8)
9D02BAD0  24020004   ADDIU V0, ZERO, 4
9D02BAD4  1462001A   BNE V1, V0, 0x9D02BB40
9D02BAD8  00000000   NOP
403:                 		{
404:                 			// Get the requested IP address and see if it is the one we have on offer.  If not, we should send back a NAK, but since there could be some other DHCP server offering this address, we'll just silently ignore this request.
405:                 			UDPGetArray((BYTE*)&dw, 4);
9D02BADC  27C20014   ADDIU V0, S8, 20
9D02BAE0  00402021   ADDU A0, V0, ZERO
9D02BAE4  24050004   ADDIU A1, ZERO, 4
9D02BAE8  0F40A442   JAL UDPGetArray
9D02BAEC  00000000   NOP
406:                 			Len -= 4;
9D02BAF0  93C20012   LBU V0, 18(S8)
9D02BAF4  2442FFFC   ADDIU V0, V0, -4
9D02BAF8  304200FF   ANDI V0, V0, 255
9D02BAFC  A3C20012   SB V0, 18(S8)
407:                 			if(dw != DHCPNextLease.Val)
9D02BB00  8F8380E4   LW V1, -32540(GP)
9D02BB04  8FC20014   LW V0, 20(S8)
9D02BB08  10620027   BEQ V1, V0, 0x9D02BBA8
9D02BB0C  00000000   NOP
408:                 			{
409:                 				bAccept = FALSE;
9D02BB10  AFC00024   SW ZERO, 36(S8)
410:                 			}
411:                 			break;
9D02BB14  0B40AEEB   J 0x9D02BBAC
9D02BB18  00000000   NOP
9D02BBA8  00000000   NOP
412:                 		}
413:                 
414:                 		// Remove the unprocessed bytes that we don't care about
415:                 		while(Len--)
9D02BB34  00000000   NOP
9D02BB38  0B40AED1   J 0x9D02BB44
9D02BB3C  00000000   NOP
9D02BB40  00000000   NOP
9D02BB44  93C20012   LBU V0, 18(S8)
9D02BB48  0002182B   SLTU V1, ZERO, V0
9D02BB4C  306300FF   ANDI V1, V1, 255
9D02BB50  2442FFFF   ADDIU V0, V0, -1
9D02BB54  304200FF   ANDI V0, V0, 255
9D02BB58  A3C20012   SB V0, 18(S8)
9D02BB5C  1460FFEF   BNE V1, ZERO, 0x9D02BB1C
9D02BB60  00000000   NOP
9D02BB64  0B40AEDC   J 0x9D02BB70
9D02BB68  00000000   NOP
416:                 		{
417:                 			UDPGet(&i);
9D02BB1C  27C20010   ADDIU V0, S8, 16
9D02BB20  00402021   ADDU A0, V0, ZERO
9D02BB24  0F40A421   JAL UDPGet
9D02BB28  00000000   NOP
9D02BB2C  0B40AED1   J 0x9D02BB44
9D02BB30  00000000   NOP
418:                 		}
419:                 	}			
420:                 
421:                 	// Begin putting the BOOTP Header and DHCP options
422:                 	UDPPut(BOOT_REPLY);			// Message Type: 2 (BOOTP Reply)
9D02BBAC  24040002   ADDIU A0, ZERO, 2
9D02BBB0  0F40A32A   JAL UDPPut
9D02BBB4  00000000   NOP
423:                 	// Reply with the same Hardware Type, Hardware Address Length, Hops, and Transaction ID fields
424:                 	UDPPutArray((BYTE*)&(Header->HardwareType), 7);
9D02BBB8  8FC20020   LW V0, 32(S8)
9D02BBBC  24420001   ADDIU V0, V0, 1
9D02BBC0  00402021   ADDU A0, V0, ZERO
9D02BBC4  24050007   ADDIU A1, ZERO, 7
9D02BBC8  0F40A34D   JAL UDPPutArray
9D02BBCC  00000000   NOP
425:                 	UDPPut(0x00);				// Seconds Elapsed: 0 (Not used)
9D02BBD0  00002021   ADDU A0, ZERO, ZERO
9D02BBD4  0F40A32A   JAL UDPPut
9D02BBD8  00000000   NOP
426:                 	UDPPut(0x00);				// Seconds Elapsed: 0 (Not used)
9D02BBDC  00002021   ADDU A0, ZERO, ZERO
9D02BBE0  0F40A32A   JAL UDPPut
9D02BBE4  00000000   NOP
427:                 	UDPPutArray((BYTE*)&(Header->BootpFlags), sizeof(Header->BootpFlags));
9D02BBE8  8FC20020   LW V0, 32(S8)
9D02BBEC  2442000A   ADDIU V0, V0, 10
9D02BBF0  00402021   ADDU A0, V0, ZERO
9D02BBF4  24050002   ADDIU A1, ZERO, 2
9D02BBF8  0F40A34D   JAL UDPPutArray
9D02BBFC  00000000   NOP
428:                 	UDPPutArray((BYTE*)&(Header->ClientIP), sizeof(IP_ADDR));// Your (client) IP Address:
9D02BC00  8FC20020   LW V0, 32(S8)
9D02BC04  2442000C   ADDIU V0, V0, 12
9D02BC08  00402021   ADDU A0, V0, ZERO
9D02BC0C  24050004   ADDIU A1, ZERO, 4
9D02BC10  0F40A34D   JAL UDPPutArray
9D02BC14  00000000   NOP
429:                 	UDPPutArray((BYTE*)&DHCPNextLease, sizeof(IP_ADDR));	// Lease IP address to give out
9D02BC18  278480E4   ADDIU A0, GP, -32540
9D02BC1C  24050004   ADDIU A1, ZERO, 4
9D02BC20  0F40A34D   JAL UDPPutArray
9D02BC24  00000000   NOP
430:                 	UDPPut(0x00);				// Next Server IP Address: 0.0.0.0 (not used)
9D02BC28  00002021   ADDU A0, ZERO, ZERO
9D02BC2C  0F40A32A   JAL UDPPut
9D02BC30  00000000   NOP
431:                 	UDPPut(0x00);				// Next Server IP Address: 0.0.0.0 (not used)
9D02BC34  00002021   ADDU A0, ZERO, ZERO
9D02BC38  0F40A32A   JAL UDPPut
9D02BC3C  00000000   NOP
432:                 	UDPPut(0x00);				// Next Server IP Address: 0.0.0.0 (not used)
9D02BC40  00002021   ADDU A0, ZERO, ZERO
9D02BC44  0F40A32A   JAL UDPPut
9D02BC48  00000000   NOP
433:                 	UDPPut(0x00);				// Next Server IP Address: 0.0.0.0 (not used)
9D02BC4C  00002021   ADDU A0, ZERO, ZERO
9D02BC50  0F40A32A   JAL UDPPut
9D02BC54  00000000   NOP
434:                 	UDPPut(0x00);				// Relay Agent IP Address: 0.0.0.0 (not used)
9D02BC58  00002021   ADDU A0, ZERO, ZERO
9D02BC5C  0F40A32A   JAL UDPPut
9D02BC60  00000000   NOP
435:                 	UDPPut(0x00);				// Relay Agent IP Address: 0.0.0.0 (not used)
9D02BC64  00002021   ADDU A0, ZERO, ZERO
9D02BC68  0F40A32A   JAL UDPPut
9D02BC6C  00000000   NOP
436:                 	UDPPut(0x00);				// Relay Agent IP Address: 0.0.0.0 (not used)
9D02BC70  00002021   ADDU A0, ZERO, ZERO
9D02BC74  0F40A32A   JAL UDPPut
9D02BC78  00000000   NOP
437:                 	UDPPut(0x00);				// Relay Agent IP Address: 0.0.0.0 (not used)
9D02BC7C  00002021   ADDU A0, ZERO, ZERO
9D02BC80  0F40A32A   JAL UDPPut
9D02BC84  00000000   NOP
438:                 	UDPPutArray((BYTE*)&(Header->ClientMAC), sizeof(MAC_ADDR));	// Client MAC address: Same as given by client
9D02BC88  8FC20020   LW V0, 32(S8)
9D02BC8C  2442001C   ADDIU V0, V0, 28
9D02BC90  00402021   ADDU A0, V0, ZERO
9D02BC94  24050006   ADDIU A1, ZERO, 6
9D02BC98  0F40A34D   JAL UDPPutArray
9D02BC9C  00000000   NOP
439:                 	for(i = 0; i < 64+128+(16-sizeof(MAC_ADDR)); i++)	// Remaining 10 bytes of client hardware address, server host name: Null string (not used)
9D02BCA0  A3C00010   SB ZERO, 16(S8)
9D02BCA4  0B40AF32   J 0x9D02BCC8
9D02BCA8  00000000   NOP
9D02BCB8  93C20010   LBU V0, 16(S8)
9D02BCBC  24420001   ADDIU V0, V0, 1
9D02BCC0  304200FF   ANDI V0, V0, 255
9D02BCC4  A3C20010   SB V0, 16(S8)
9D02BCC8  93C20010   LBU V0, 16(S8)
9D02BCCC  2C4200CA   SLTIU V0, V0, 202
9D02BCD0  1440FFF6   BNE V0, ZERO, 0x9D02BCAC
9D02BCD4  00000000   NOP
440:                 		UDPPut(0x00);									// Boot filename: Null string (not used)
9D02BCAC  00002021   ADDU A0, ZERO, ZERO
9D02BCB0  0F40A32A   JAL UDPPut
9D02BCB4  00000000   NOP
441:                 	UDPPut(0x63);				// Magic Cookie: 0x63538263
9D02BCD8  24040063   ADDIU A0, ZERO, 99
9D02BCDC  0F40A32A   JAL UDPPut
9D02BCE0  00000000   NOP
442:                 	UDPPut(0x82);				// Magic Cookie: 0x63538263
9D02BCE4  24040082   ADDIU A0, ZERO, 130
9D02BCE8  0F40A32A   JAL UDPPut
9D02BCEC  00000000   NOP
443:                 	UDPPut(0x53);				// Magic Cookie: 0x63538263
9D02BCF0  24040053   ADDIU A0, ZERO, 83
9D02BCF4  0F40A32A   JAL UDPPut
9D02BCF8  00000000   NOP
444:                 	UDPPut(0x63);				// Magic Cookie: 0x63538263
9D02BCFC  24040063   ADDIU A0, ZERO, 99
9D02BD00  0F40A32A   JAL UDPPut
9D02BD04  00000000   NOP
445:                 	
446:                 	// Options: DHCP lease ACKnowledge
447:                 	if(bAccept)
9D02BD08  8FC20024   LW V0, 36(S8)
9D02BD0C  1040000C   BEQ V0, ZERO, 0x9D02BD40
9D02BD10  00000000   NOP
448:                 	{
449:                 		UDPPut(DHCP_OPTION_ACK_MESSAGE);	
9D02BD14  24040035   ADDIU A0, ZERO, 53
9D02BD18  0F40A32A   JAL UDPPut
9D02BD1C  00000000   NOP
450:                 		UDPPut(1);
9D02BD20  24040001   ADDIU A0, ZERO, 1
9D02BD24  0F40A32A   JAL UDPPut
9D02BD28  00000000   NOP
451:                 		UDPPut(DHCP_ACK_MESSAGE);
9D02BD2C  24040005   ADDIU A0, ZERO, 5
9D02BD30  0F40A32A   JAL UDPPut
9D02BD34  00000000   NOP
9D02BD38  0B40AF59   J 0x9D02BD64
9D02BD3C  00000000   NOP
452:                 	}
453:                 	else	// Send a NACK
454:                 	{
455:                 		UDPPut(DHCP_OPTION_ACK_MESSAGE);	
9D02BD40  24040035   ADDIU A0, ZERO, 53
9D02BD44  0F40A32A   JAL UDPPut
9D02BD48  00000000   NOP
456:                 		UDPPut(1);
9D02BD4C  24040001   ADDIU A0, ZERO, 1
9D02BD50  0F40A32A   JAL UDPPut
9D02BD54  00000000   NOP
457:                 		UDPPut(DHCP_NAK_MESSAGE);
9D02BD58  24040006   ADDIU A0, ZERO, 6
9D02BD5C  0F40A32A   JAL UDPPut
9D02BD60  00000000   NOP
458:                 	}
459:                 
460:                 	// Option: Lease duration
461:                 	UDPPut(DHCP_IP_LEASE_TIME);
9D02BD64  24040033   ADDIU A0, ZERO, 51
9D02BD68  0F40A32A   JAL UDPPut
9D02BD6C  00000000   NOP
462:                 	UDPPut(4);
9D02BD70  24040004   ADDIU A0, ZERO, 4
9D02BD74  0F40A32A   JAL UDPPut
9D02BD78  00000000   NOP
463:                 	UDPPut((DHCP_LEASE_DURATION>>24) & 0xFF);
9D02BD7C  00002021   ADDU A0, ZERO, ZERO
9D02BD80  0F40A32A   JAL UDPPut
9D02BD84  00000000   NOP
464:                 	UDPPut((DHCP_LEASE_DURATION>>16) & 0xFF);
9D02BD88  00002021   ADDU A0, ZERO, ZERO
9D02BD8C  0F40A32A   JAL UDPPut
9D02BD90  00000000   NOP
465:                 	UDPPut((DHCP_LEASE_DURATION>>8) & 0xFF);
9D02BD94  00002021   ADDU A0, ZERO, ZERO
9D02BD98  0F40A32A   JAL UDPPut
9D02BD9C  00000000   NOP
466:                 	UDPPut((DHCP_LEASE_DURATION) & 0xFF);
9D02BDA0  2404003C   ADDIU A0, ZERO, 60
9D02BDA4  0F40A32A   JAL UDPPut
9D02BDA8  00000000   NOP
467:                 
468:                 	// Option: Server identifier
469:                 	UDPPut(DHCP_SERVER_IDENTIFIER);	
9D02BDAC  24040036   ADDIU A0, ZERO, 54
9D02BDB0  0F40A32A   JAL UDPPut
9D02BDB4  00000000   NOP
470:                 	UDPPut(sizeof(IP_ADDR));
9D02BDB8  24040004   ADDIU A0, ZERO, 4
9D02BDBC  0F40A32A   JAL UDPPut
9D02BDC0  00000000   NOP
471:                 	UDPPutArray((BYTE*)&AppConfig.MyIPAddr, sizeof(IP_ADDR));
9D02BDC4  3C02A000   LUI V0, -24576
9D02BDC8  24440728   ADDIU A0, V0, 1832
9D02BDCC  24050004   ADDIU A1, ZERO, 4
9D02BDD0  0F40A34D   JAL UDPPutArray
9D02BDD4  00000000   NOP
472:                 
473:                 	// Option: Subnet Mask
474:                 	UDPPut(DHCP_SUBNET_MASK);
9D02BDD8  24040001   ADDIU A0, ZERO, 1
9D02BDDC  0F40A32A   JAL UDPPut
9D02BDE0  00000000   NOP
475:                 	UDPPut(sizeof(IP_ADDR));
9D02BDE4  24040004   ADDIU A0, ZERO, 4
9D02BDE8  0F40A32A   JAL UDPPut
9D02BDEC  00000000   NOP
476:                 	UDPPutArray((BYTE*)&AppConfig.MyMask, sizeof(IP_ADDR));
9D02BDF0  3C02A000   LUI V0, -24576
9D02BDF4  2444072C   ADDIU A0, V0, 1836
9D02BDF8  24050004   ADDIU A1, ZERO, 4
9D02BDFC  0F40A34D   JAL UDPPutArray
9D02BE00  00000000   NOP
477:                 
478:                 	// Option: Router/Gateway address
479:                 	UDPPut(DHCP_ROUTER);		
9D02BE04  24040003   ADDIU A0, ZERO, 3
9D02BE08  0F40A32A   JAL UDPPut
9D02BE0C  00000000   NOP
480:                 	UDPPut(sizeof(IP_ADDR));
9D02BE10  24040004   ADDIU A0, ZERO, 4
9D02BE14  0F40A32A   JAL UDPPut
9D02BE18  00000000   NOP
481:                 	UDPPutArray((BYTE*)&AppConfig.MyIPAddr, sizeof(IP_ADDR));
9D02BE1C  3C02A000   LUI V0, -24576
9D02BE20  24440728   ADDIU A0, V0, 1832
9D02BE24  24050004   ADDIU A1, ZERO, 4
9D02BE28  0F40A34D   JAL UDPPutArray
9D02BE2C  00000000   NOP
482:                 
483:                 	// Option: DNS server address
484:                 	UDPPut(DHCP_DNS);
9D02BE30  24040006   ADDIU A0, ZERO, 6
9D02BE34  0F40A32A   JAL UDPPut
9D02BE38  00000000   NOP
485:                 	UDPPut(sizeof(IP_ADDR));
9D02BE3C  24040004   ADDIU A0, ZERO, 4
9D02BE40  0F40A32A   JAL UDPPut
9D02BE44  00000000   NOP
486:                 	UDPPutArray((BYTE*)&AppConfig.MyIPAddr, sizeof(IP_ADDR));
9D02BE48  3C02A000   LUI V0, -24576
9D02BE4C  24440728   ADDIU A0, V0, 1832
9D02BE50  24050004   ADDIU A1, ZERO, 4
9D02BE54  0F40A34D   JAL UDPPutArray
9D02BE58  00000000   NOP
487:                 
488:                 	// No more options, mark ending
489:                 	UDPPut(DHCP_END_OPTION);
9D02BE5C  240400FF   ADDIU A0, ZERO, 255
9D02BE60  0F40A32A   JAL UDPPut
9D02BE64  00000000   NOP
490:                 
491:                 	// Add zero padding to ensure compatibility with old BOOTP relays that discard small packets (<300 UDP octets)
492:                 	while(UDPTxCount < 300u)
9D02BE68  0B40AF9F   J 0x9D02BE7C
9D02BE6C  00000000   NOP
9D02BE7C  978281EA   LHU V0, -32278(GP)
9D02BE80  2C42012C   SLTIU V0, V0, 300
9D02BE84  1440FFFA   BNE V0, ZERO, 0x9D02BE70
9D02BE88  00000000   NOP
493:                 		UDPPut(0); 
9D02BE70  00002021   ADDU A0, ZERO, ZERO
9D02BE74  0F40A32A   JAL UDPPut
9D02BE78  00000000   NOP
494:                 
495:                 	// Force remote destination address to be the broadcast address, regardless 
496:                 	// of what the node's source IP address was (to ensure we don't try to 
497:                 	// unicast to 0.0.0.0).
498:                 	memset((void*)&UDPSocketInfo[MySocket].remote.remoteNode, 0xFF, sizeof(NODE_INFO));
9D02BE8C  938280E0   LBU V0, -32544(GP)
9D02BE90  00401821   ADDU V1, V0, ZERO
9D02BE94  2402001C   ADDIU V0, ZERO, 28
9D02BE98  70621802   MUL V1, V1, V0
9D02BE9C  3C02A000   LUI V0, -24576
9D02BEA0  24420648   ADDIU V0, V0, 1608
9D02BEA4  00621021   ADDU V0, V1, V0
9D02BEA8  00402021   ADDU A0, V0, ZERO
9D02BEAC  240500FF   ADDIU A1, ZERO, 255
9D02BEB0  2406000A   ADDIU A2, ZERO, 10
9D02BEB4  0F40D5EC   JAL 0x9D0357B0
9D02BEB8  00000000   NOP
499:                 
500:                 	// Transmit the packet
501:                 	UDPFlush();
9D02BEBC  0F40A38D   JAL UDPFlush
9D02BEC0  00000000   NOP
502:                 }
9D02BEC4  03C0E821   ADDU SP, S8, ZERO
9D02BEC8  8FBF001C   LW RA, 28(SP)
9D02BECC  8FBE0018   LW S8, 24(SP)
9D02BED0  27BD0020   ADDIU SP, SP, 32
9D02BED4  03E00008   JR RA
9D02BED8  00000000   NOP
503:                 
504:                 #endif //#if defined(STACK_USE_DHCP_SERVER)
---  C:/Users/Diego/Documents/GitHub/pic32webFREERtos/Pic32Web.X/src/tcpip/src/DHCP.c  ------------------
1:                   /*********************************************************************
2:                   *
3:                   *	Dynamic Host Configuration Protocol (DHCP) Client
4:                   *	Module for Microchip TCP/IP Stack
5:                   *	 -Provides automatic IP address, subnet mask, gateway address, 
6:                   *	  DNS server address, and other configuration parameters on DHCP 
7:                   *	  enabled networks.
8:                   *	 -Reference: RFC 2131, 2132
9:                   *
10:                  *********************************************************************
11:                  * FileName:		DHCP.c
12:                  * Dependencies:	UDP
13:                  * Processor:	PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32
14:                  * Compiler:		Microchip C32 v1.05 or higher
15:                  *				Microchip C30 v3.12 or higher
16:                  *				Microchip C18 v3.30 or higher
17:                  *				HI-TECH PICC-18 PRO 9.63PL2 or higher
18:                  * Company:		Microchip Technology, Inc.
19:                  *
20:                  * Software License Agreement
21:                  *
22:                  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights
23:                  * reserved.
24:                  *
25:                  * Microchip licenses to you the right to use, modify, copy, and
26:                  * distribute:
27:                  * (i)  the Software when embedded on a Microchip microcontroller or
28:                  *      digital signal controller product ("Device") which is
29:                  *      integrated into Licensee's product; or
30:                  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h,
31:                  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device
32:                  *		used in conjunction with a Microchip ethernet controller for
33:                  *		the sole purpose of interfacing with the ethernet controller.
34:                  *
35:                  * You should refer to the license agreement accompanying this
36:                  * Software for additional information regarding your rights and
37:                  * obligations.
38:                  *
39:                  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT
40:                  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT
41:                  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A
42:                  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL
43:                  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR
44:                  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF
45:                  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS
46:                  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE
47:                  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER
48:                  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT
49:                  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE.
50:                  *
51:                  *
52:                  * Author               Date    Comment
53:                  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
54:                  * Nilesh Rajbharti     3/21/01  Original        (Rev 1.0)
55:                  * Nilesh Rajbharti     7/10/02  Explicitly initialized tempIPAddress
56:                  *                                               (Rev 2.11)
57:                  * Nilesh Rajbharti     5/16/03 Increased DHCP_TIMEOUT to 2 seconds.
58:                  * Nilesh Rajbharti     5/16/03 Fixed SM_DHCP_BROADCAST logic
59:                  *                              where UDPPut was called before setting
60:                  *                              active socket.
61:                  * Robert Sloan         5/29/03 Improved DHCP State machine to handle
62:                  *                              NAK and renew existing IP address.
63:                  * Nilesh Rajbharti     8/15/03 Modified _DHCPRecieve() to check for
64:                  *                              chaddr field before accpting the packet.
65:                  *                              Fixed DHCPTask() where it would not
66:                  *                              reply to first OFFER.
67:                  * Nilesh Rajbharti     3/1/04  Used tickDiff in DHCPTask() "bind"
68:                  *                              state to adjust for irregular TICK_SECOND
69:                  *                              Without this logic, actual lease time count
70:                  *                              down may be incorrect.
71:                  * Howard Schlunder		5/11/06	Fixed tickDiff usage, reducing 
72:                  *								accumulated timing error.  Fixed DHCP 
73:                  *								state machine requesting IP 0.0.0.0 
74:                  *								after lease expiration.
75:                  * Howard Schlunder		6/01/06	Added DHCPFlags.bits.bOfferReceived flag to 
76:                  *								allow operation on networks with multiple
77:                  *								DHCP servers offering multiple addresses
78:                  * Howard Schlunder		8/01/06 Added DNS server option to DHCP request, 
79:                  *								untested Host Name option to DHCP request
80:                  * Howard Schlunder		1/09/06	Fixed a DHCP renewal not renewing lease time bug
81:                  * Howard Schlunder		3/16/07 Rewrote DHCP state machine
82:                  ********************************************************************/
83:                  #define __DHCP_C
84:                  
85:                  #include "TCPIPConfig.h"
86:                  
87:                  #if defined(STACK_USE_DHCP_CLIENT)
88:                  
89:                  #include "TCPIP Stack/TCPIP.h"
90:                  
91:                  // Defines how long to wait before a DHCP request times out
92:                  #define DHCP_TIMEOUT				(2ul*TICK_SECOND)
93:                  
94:                  // Unique variables per interface
95:                  typedef struct
96:                  {
97:                  	UDP_SOCKET			hDHCPSocket;	// Handle to DHCP client socket
98:                  	SM_DHCP				smState;		// DHCP client state machine variable
99:                  	union
100:                 	{
101:                 	    struct
102:                 	    {
103:                 	        unsigned char bIsBound : 1;				// Whether or not DHCP is currently bound
104:                 	        unsigned char bEvent : 1;				// Indicates to an external module that the DHCP client has been reset, has obtained new parameters via the DHCP client, or has refreshed a lease on existing ones
105:                 	        unsigned char bOfferReceived : 1;		// Whether or not an offer has been received
106:                 			unsigned char bDHCPServerDetected : 1;	// Indicates if a DCHP server has been detected
107:                 			unsigned char bUseUnicastMode : 1;		// Indicates if the 
108:                 	    } bits;
109:                 	    BYTE val;
110:                 	} flags;
111:                 	DWORD 				dwTimer;		// Tick timer value used for triggering future events after a certain wait period.
112:                 	DWORD				dwLeaseTime;	// DHCP lease time remaining, in seconds
113:                 	DWORD				dwServerID;		// DHCP Server ID cache
114:                 	IP_ADDR				tempIPAddress;	// Temporary IP address to use when no DHCP lease
115:                 	IP_ADDR				tempGateway;	// Temporary gateway to use when no DHCP lease
116:                 	IP_ADDR				tempMask;		// Temporary mask to use when no DHCP lease
117:                 	#if defined(STACK_USE_DNS)
118:                 	IP_ADDR				tempDNS;		// Temporary primary DNS server
119:                 	IP_ADDR				tempDNS2;		// Temporary secondary DNS server
120:                 	#endif	
121:                 	// Indicates which DHCP values are currently valid
122:                 	union
123:                 	{
124:                 		struct
125:                 		{
126:                 			char IPAddress:1;	// Leased IP address is valid
127:                 			char Gateway:1;		// Gateway address is valid
128:                 			char Mask:1;		// Subnet mask is valid
129:                 			char DNS:1;			// Primary DNS is valid
130:                 			char DNS2:1;		// Secondary DNS is valid
131:                 			char HostName:1;	// Host name is valid (not implemented)
132:                 		} bits;
133:                 		BYTE val;
134:                 	} validValues;
135:                 } DHCP_CLIENT_VARS;
136:                 
137:                 BOOL DHCPClientInitializedOnce = FALSE;
138:                 
139:                 static BYTE _DHCPReceive(void);
140:                 static void _DHCPSend(BYTE messageType, BOOL bRenewing);
141:                 
142:                 #if defined (WF_CS_IO)
143:                 extern void SignalDHCPSuccessful(void);
144:                 #endif
145:                 
146:                 /*****************************************************************************
147:                   Function:
148:                 	static void LoadState(BYTE vInterface)
149:                 
150:                   Summary:
151:                 	Saves the DHCPClient state information structure to the appropriate 
152:                 	location and loads DHCPClient with the state information for the specified 
153:                 	interface.
154:                 
155:                   Description:
156:                 	Saves the DHCPClient state information structure to the appropriate 
157:                 	location and loads DHCPClient with the state information for the specified 
158:                 	interface.
159:                 
160:                   Precondition:
161:                 	None
162:                 
163:                   Parameters:
164:                 	None
165:                 
166:                   Returns:
167:                 	None
168:                 
169:                   Remarks:
170:                   	This function does nothing when you only have one physical interface.
171:                 ***************************************************************************/
172:                 #if NETWORK_INTERFACES > 1
173:                 
174:                 static DHCP_CLIENT_VARS	DHCPClients[NETWORK_INTERFACES];
175:                 static DHCP_CLIENT_VARS	*SelectedDHCPClient;
176:                 #define DHCPClient		(*SelectedDHCPClient)
177:                 #define LoadState(v)	do(SelectedDHCPClient = &DHCPClients[v])while(0)
178:                 
179:                 #else
180:                 
181:                 static DHCP_CLIENT_VARS DHCPClient;
182:                 #define LoadState(v)
183:                 
184:                 #endif
185:                 
186:                 
187:                 /*****************************************************************************
188:                   Function:
189:                 	void DHCPInit(BYTE vInterface)
190:                 
191:                   Summary:
192:                 	Resets the DHCP client module for the specified interface.
193:                 
194:                   Description:
195:                 	Resets the DHCP client module, giving up any current lease, knowledge of 
196:                 	DHCP servers, etc. for the specified interface.
197:                 
198:                   Precondition:
199:                 	None
200:                 
201:                   Parameters:
202:                 	vInterface - Interface number to initialize DHCP client state variables 
203:                 		for.   If you only have one interface, specify 0x00.
204:                 
205:                   Returns:
206:                 	None
207:                 
208:                   Remarks:
209:                 	This function may be called multiple times throughout the life of the 
210:                 	application, if desired.  
211:                 ***************************************************************************/
212:                 void DHCPInit(BYTE vInterface)
213:                 {
9D024054  27BDFFE0   ADDIU SP, SP, -32
9D024058  AFBF001C   SW RA, 28(SP)
9D02405C  AFBE0018   SW S8, 24(SP)
9D024060  03A0F021   ADDU S8, SP, ZERO
9D024064  00801021   ADDU V0, A0, ZERO
9D024068  A3C20020   SB V0, 32(S8)
214:                 	BYTE i;
215:                 	
216:                 	// Upon the first call after POR, we must reset all handles to invalid so 
217:                 	// that we don't inadvertently close someone else's handle.
218:                 	if(!DHCPClientInitializedOnce)
9D02406C  8F8280DC   LW V0, -32548(GP)
9D024070  1440000F   BNE V0, ZERO, 0x9D0240B0
9D024074  00000000   NOP
219:                 	{
220:                 		DHCPClientInitializedOnce = TRUE;
9D024078  24020001   ADDIU V0, ZERO, 1
9D02407C  AF8280DC   SW V0, -32548(GP)
221:                 		for(i = 0; i < NETWORK_INTERFACES; i++)
9D024080  A3C00010   SB ZERO, 16(S8)
9D024084  0B409029   J 0x9D0240A4
9D024088  00000000   NOP
9D024098  93C20010   LBU V0, 16(S8)
9D02409C  24420001   ADDIU V0, V0, 1
9D0240A0  A3C20010   SB V0, 16(S8)
9D0240A4  93C20010   LBU V0, 16(S8)
9D0240A8  1040FFF8   BEQ V0, ZERO, 0x9D02408C
9D0240AC  00000000   NOP
222:                 		{
223:                 			LoadState(i);
224:                 			DHCPClient.hDHCPSocket = INVALID_UDP_SOCKET;
9D02408C  3C02A000   LUI V0, -24576
9D024090  2403FFFF   ADDIU V1, ZERO, -1
9D024094  A0433254   SB V1, 12884(V0)
225:                 		}		
226:                 	}
227:                 	
228:                 	
229:                 	LoadState(vInterface);
230:                 	
231:                 	if(DHCPClient.hDHCPSocket != INVALID_UDP_SOCKET)
9D0240B0  3C02A000   LUI V0, -24576
9D0240B4  90433254   LBU V1, 12884(V0)
9D0240B8  240200FF   ADDIU V0, ZERO, 255
9D0240BC  10620009   BEQ V1, V0, 0x9D0240E4
9D0240C0  00000000   NOP
232:                 	{
233:                 		UDPClose(DHCPClient.hDHCPSocket);
9D0240C4  3C02A000   LUI V0, -24576
9D0240C8  90423254   LBU V0, 12884(V0)
9D0240CC  00402021   ADDU A0, V0, ZERO
9D0240D0  0F40A2B9   JAL UDPClose
9D0240D4  00000000   NOP
234:                 		DHCPClient.hDHCPSocket = INVALID_UDP_SOCKET;
9D0240D8  3C02A000   LUI V0, -24576
9D0240DC  2403FFFF   ADDIU V1, ZERO, -1
9D0240E0  A0433254   SB V1, 12884(V0)
235:                 	}
236:                 
237:                 	// Reset state machine and flags to default values
238:                 	DHCPClient.smState = SM_DHCP_GET_SOCKET;
9D0240E4  3C02A000   LUI V0, -24576
9D0240E8  24423254   ADDIU V0, V0, 12884
9D0240EC  24030001   ADDIU V1, ZERO, 1
9D0240F0  AC430004   SW V1, 4(V0)
239:                 	DHCPClient.flags.val = 0;
9D0240F4  3C02A000   LUI V0, -24576
9D0240F8  24423254   ADDIU V0, V0, 12884
9D0240FC  A0400008   SB ZERO, 8(V0)
240:                 	DHCPClient.flags.bits.bUseUnicastMode = TRUE;	// This flag toggles before use, so this statement actually means to start out using broadcast mode.
9D024100  3C02A000   LUI V0, -24576
9D024104  24433254   ADDIU V1, V0, 12884
9D024108  8C620008   LW V0, 8(V1)
9D02410C  24040001   ADDIU A0, ZERO, 1
9D024110  7C822104   INS V0, A0, 4, 1
9D024114  AC620008   SW V0, 8(V1)
241:                 	DHCPClient.flags.bits.bEvent = TRUE;
9D024118  3C02A000   LUI V0, -24576
9D02411C  24433254   ADDIU V1, V0, 12884
9D024120  8C620008   LW V0, 8(V1)
9D024124  24040001   ADDIU A0, ZERO, 1
9D024128  7C820844   INS V0, A0, 1, 1
9D02412C  AC620008   SW V0, 8(V1)
242:                 }
9D024130  03C0E821   ADDU SP, S8, ZERO
9D024134  8FBF001C   LW RA, 28(SP)
9D024138  8FBE0018   LW S8, 24(SP)
9D02413C  27BD0020   ADDIU SP, SP, 32
9D024140  03E00008   JR RA
9D024144  00000000   NOP
243:                 
244:                 
245:                 /*****************************************************************************
246:                   Function:
247:                 	void DHCPDisable(BYTE vInterface)
248:                 
249:                   Summary:
250:                 	Disables the DHCP Client for the specified interface.
251:                 
252:                   Description:
253:                 	Disables the DHCP client for the specified interface by sending the state 
254:                 	machine to "SM_DHCP_DISABLED".  If the interface was previously configured 
255:                 	by DHCP, the configuration will continue to be used but the module will no 
256:                 	longer preform any renewals.
257:                 
258:                   Precondition:
259:                 	None
260:                 
261:                   Parameters:
262:                 	vInterface - Interface number to disable the DHCP client on.   If you only 
263:                 		have one interface, specify 0x00.
264:                 
265:                   Returns:
266:                 	None
267:                 
268:                   Remarks:
269:                 	Since the interface continues using its old configuration, it is possible 
270:                 	that the lease may expire and the DHCP server provide the IP to another
271:                 	client.  The application should replace the current IP address and other
272:                 	configuration with static information following a call to this function.
273:                 ***************************************************************************/
274:                 void DHCPDisable(BYTE vInterface)
275:                 {
9D024148  27BDFFE8   ADDIU SP, SP, -24
9D02414C  AFBF0014   SW RA, 20(SP)
9D024150  AFBE0010   SW S8, 16(SP)
9D024154  03A0F021   ADDU S8, SP, ZERO
9D024158  00801021   ADDU V0, A0, ZERO
9D02415C  A3C20018   SB V0, 24(S8)
276:                 	LoadState(vInterface);
277:                 
278:                 	if(DHCPClient.hDHCPSocket != INVALID_UDP_SOCKET)
9D024160  3C02A000   LUI V0, -24576
9D024164  90433254   LBU V1, 12884(V0)
9D024168  240200FF   ADDIU V0, ZERO, 255
9D02416C  10620009   BEQ V1, V0, 0x9D024194
9D024170  00000000   NOP
279:                 	{
280:                 		UDPClose(DHCPClient.hDHCPSocket);
9D024174  3C02A000   LUI V0, -24576
9D024178  90423254   LBU V0, 12884(V0)
9D02417C  00402021   ADDU A0, V0, ZERO
9D024180  0F40A2B9   JAL UDPClose
9D024184  00000000   NOP
281:                 		DHCPClient.hDHCPSocket = INVALID_UDP_SOCKET;
9D024188  3C02A000   LUI V0, -24576
9D02418C  2403FFFF   ADDIU V1, ZERO, -1
9D024190  A0433254   SB V1, 12884(V0)
282:                 	}
283:                 
284:                 	DHCPClient.smState = SM_DHCP_DISABLED;
9D024194  3C02A000   LUI V0, -24576
9D024198  24423254   ADDIU V0, V0, 12884
9D02419C  AC400004   SW ZERO, 4(V0)
285:                 }
9D0241A0  03C0E821   ADDU SP, S8, ZERO
9D0241A4  8FBF0014   LW RA, 20(SP)
9D0241A8  8FBE0010   LW S8, 16(SP)
9D0241AC  27BD0018   ADDIU SP, SP, 24
9D0241B0  03E00008   JR RA
9D0241B4  00000000   NOP
286:                 
287:                 
288:                 /*****************************************************************************
289:                   Function:
290:                 	void DHCPEnable(BYTE vInterface)
291:                 
292:                   Summary:
293:                 	Enables the DHCP client for the specified interface.
294:                 
295:                   Description:
296:                 	Enables the DHCP client for the specified interface, if it is disabled.  
297:                 	If it is already enabled, nothing is done.
298:                 
299:                   Precondition:
300:                 	None
301:                 
302:                   Parameters:
303:                 	vInterface - Interface number to enable the DHCP client on.   If you only 
304:                 		have one interface, specify 0x00.
305:                 
306:                   Returns:
307:                 	None
308:                 ***************************************************************************/
309:                 void DHCPEnable(BYTE vInterface)
310:                 {
9D0241B8  27BDFFF8   ADDIU SP, SP, -8
9D0241BC  AFBE0004   SW S8, 4(SP)
9D0241C0  03A0F021   ADDU S8, SP, ZERO
9D0241C4  00801021   ADDU V0, A0, ZERO
9D0241C8  A3C20008   SB V0, 8(S8)
311:                 	LoadState(vInterface);
312:                 
313:                 	if(DHCPClient.smState == SM_DHCP_DISABLED)
9D0241CC  3C02A000   LUI V0, -24576
9D0241D0  24423254   ADDIU V0, V0, 12884
9D0241D4  8C420004   LW V0, 4(V0)
9D0241D8  1440000A   BNE V0, ZERO, 0x9D024204
9D0241DC  00000000   NOP
314:                 	{
315:                 		DHCPClient.smState = SM_DHCP_GET_SOCKET;
9D0241E0  3C02A000   LUI V0, -24576
9D0241E4  24423254   ADDIU V0, V0, 12884
9D0241E8  24030001   ADDIU V1, ZERO, 1
9D0241EC  AC430004   SW V1, 4(V0)
316:                 		DHCPClient.flags.bits.bIsBound = FALSE;
9D0241F0  3C02A000   LUI V0, -24576
9D0241F4  24433254   ADDIU V1, V0, 12884
9D0241F8  8C620008   LW V0, 8(V1)
9D0241FC  7C020004   INS V0, ZERO, 0, 1
9D024200  AC620008   SW V0, 8(V1)
317:                 	}
318:                 }
9D024204  03C0E821   ADDU SP, S8, ZERO
9D024208  8FBE0004   LW S8, 4(SP)
9D02420C  27BD0008   ADDIU SP, SP, 8
9D024210  03E00008   JR RA
9D024214  00000000   NOP
319:                 
320:                 /*****************************************************************************
321:                   Function:
322:                 	BOOL DHCPIsEnabled(BYTE vInterface)
323:                 
324:                   Summary:
325:                 	Determins if the DHCP client is enabled on the specified interface.
326:                 
327:                   Description:
328:                 	Determins if the DHCP client is enabled on the specified interface.
329:                 
330:                   Precondition:
331:                 	None
332:                 
333:                   Parameters:
334:                 	vInterface - Interface number to query.   If you only have one interface, 
335:                 		specify 0x00.
336:                 
337:                   Returns:
338:                 	None
339:                 ***************************************************************************/
340:                 BOOL DHCPIsEnabled(BYTE vInterface)
341:                 {
9D024218  27BDFFF8   ADDIU SP, SP, -8
9D02421C  AFBE0004   SW S8, 4(SP)
9D024220  03A0F021   ADDU S8, SP, ZERO
9D024224  00801021   ADDU V0, A0, ZERO
9D024228  A3C20008   SB V0, 8(S8)
342:                 	LoadState(vInterface);
343:                 	return DHCPClient.smState != SM_DHCP_DISABLED;
9D02422C  3C02A000   LUI V0, -24576
9D024230  24423254   ADDIU V0, V0, 12884
9D024234  8C420004   LW V0, 4(V0)
9D024238  0002102B   SLTU V0, ZERO, V0
344:                 }
9D02423C  03C0E821   ADDU SP, S8, ZERO
9D024240  8FBE0004   LW S8, 4(SP)
9D024244  27BD0008   ADDIU SP, SP, 8
9D024248  03E00008   JR RA
9D02424C  00000000   NOP
345:                 
346:                 
347:                 /*****************************************************************************
348:                   Function:
349:                 	BOOL DHCPIsBound(BYTE vInterface)
350:                 
351:                   Summary:
352:                 	Determins if the DHCP client has an IP address lease on the specified 
353:                 	interface.
354:                 
355:                   Description:
356:                 	Determins if the DHCP client has an IP address lease on the specified 
357:                 	interface.
358:                 
359:                   Precondition:
360:                 	None
361:                 
362:                   Parameters:
363:                 	vInterface - Interface number to query.   If you only have one interface, 
364:                 		specify 0x00.
365:                 
366:                   Returns:
367:                 	TRUE - DHCP client has obtained an IP address lease (and likely other 
368:                 		parameters) and these values are currently being used.
369:                 	FALSE - No IP address is currently leased
370:                 ***************************************************************************/
371:                 BOOL DHCPIsBound(BYTE vInterface)
372:                 {
9D024250  27BDFFF8   ADDIU SP, SP, -8
9D024254  AFBE0004   SW S8, 4(SP)
9D024258  03A0F021   ADDU S8, SP, ZERO
9D02425C  00801021   ADDU V0, A0, ZERO
9D024260  A3C20008   SB V0, 8(S8)
373:                 	LoadState(vInterface);
374:                 	return DHCPClient.flags.bits.bIsBound;
9D024264  3C02A000   LUI V0, -24576
9D024268  24423254   ADDIU V0, V0, 12884
9D02426C  8C420008   LW V0, 8(V0)
9D024270  7C420000   EXT V0, V0, 0, 1
9D024274  304200FF   ANDI V0, V0, 255
375:                 }
9D024278  03C0E821   ADDU SP, S8, ZERO
9D02427C  8FBE0004   LW S8, 4(SP)
9D024280  27BD0008   ADDIU SP, SP, 8
9D024284  03E00008   JR RA
9D024288  00000000   NOP
376:                 
377:                 /*****************************************************************************
378:                   Function:
379:                 	BOOL DHCPStateChanged(BYTE vInterface)
380:                 
381:                   Summary:
382:                 	Determins if the DHCP client on the specified interface has changed states 
383:                 	or refreshed its IP address lease.
384:                 
385:                   Description:
386:                 	Determins if the DHCP client on the specified interface has changed states 
387:                 	or refreshed its IP address lease.  This function can be used to determine
388:                 	when to update an LCD or other display whenever the DHCP assigned IP 
389:                 	address has potentially changed.
390:                 	
391:                   Precondition:
392:                 	None
393:                 
394:                   Parameters:
395:                 	vInterface - Interface number to query.   If you only have one interface, 
396:                 		specify 0x00.
397:                 
398:                   Returns:
399:                 	TRUE - The IP address lease have been reliquished (due to reinitilization), 
400:                 		obtained (first event), or renewed since the last call to 
401:                 		DHCPStateChanged().
402:                 	FALSE - The DHCP client has not detected any changes since the last call to 
403:                 		DHCPStateChanged().
404:                 ***************************************************************************/
405:                 BOOL DHCPStateChanged(BYTE vInterface)
406:                 {
9D02428C  27BDFFF8   ADDIU SP, SP, -8
9D024290  AFBE0004   SW S8, 4(SP)
9D024294  03A0F021   ADDU S8, SP, ZERO
9D024298  00801021   ADDU V0, A0, ZERO
9D02429C  A3C20008   SB V0, 8(S8)
407:                 	LoadState(vInterface);
408:                 	if(DHCPClient.flags.bits.bEvent)
9D0242A0  3C02A000   LUI V0, -24576
9D0242A4  24423254   ADDIU V0, V0, 12884
9D0242A8  8C420008   LW V0, 8(V0)
9D0242AC  30420002   ANDI V0, V0, 2
9D0242B0  10400009   BEQ V0, ZERO, 0x9D0242D8
9D0242B4  00000000   NOP
409:                 	{
410:                 		DHCPClient.flags.bits.bEvent = 0;
9D0242B8  3C02A000   LUI V0, -24576
9D0242BC  24433254   ADDIU V1, V0, 12884
9D0242C0  8C620008   LW V0, 8(V1)
9D0242C4  7C020844   INS V0, ZERO, 1, 1
9D0242C8  AC620008   SW V0, 8(V1)
411:                 		return TRUE;
9D0242CC  24020001   ADDIU V0, ZERO, 1
9D0242D0  0B4090B7   J 0x9D0242DC
9D0242D4  00000000   NOP
412:                 	}
413:                 	return FALSE;
9D0242D8  00001021   ADDU V0, ZERO, ZERO
414:                 }
9D0242DC  03C0E821   ADDU SP, S8, ZERO
9D0242E0  8FBE0004   LW S8, 4(SP)
9D0242E4  27BD0008   ADDIU SP, SP, 8
9D0242E8  03E00008   JR RA
9D0242EC  00000000   NOP
415:                 
416:                 
417:                 /*****************************************************************************
418:                   Function:
419:                 	BOOL DHCPIsServerDetected(BYTE vInterface)
420:                 
421:                   Summary:
422:                 	Determins if the DHCP client on the specified interface has seen a DHCP 
423:                 	server.
424:                 
425:                   Description:
426:                 	Determins if the DHCP client on the specified interface has seen a DHCP 
427:                 	server.
428:                 	
429:                   Precondition:
430:                 	None
431:                 
432:                   Parameters:
433:                 	vInterface - Interface number to query.   If you only have one interface, 
434:                 		specify 0x00.
435:                 
436:                   Returns:
437:                 	TRUE - At least one DHCP server is attached to the specified network 
438:                 		interface.
439:                 	FALSE - No DHCP servers are currently detected on the specified network 
440:                 		interface.
441:                 ***************************************************************************/
442:                 BOOL DHCPIsServerDetected(BYTE vInterface)
443:                 {
9D0242F0  27BDFFF8   ADDIU SP, SP, -8
9D0242F4  AFBE0004   SW S8, 4(SP)
9D0242F8  03A0F021   ADDU S8, SP, ZERO
9D0242FC  00801021   ADDU V0, A0, ZERO
9D024300  A3C20008   SB V0, 8(S8)
444:                 	LoadState(vInterface);
445:                 	return DHCPClient.flags.bits.bDHCPServerDetected;
9D024304  3C02A000   LUI V0, -24576
9D024308  24423254   ADDIU V0, V0, 12884
9D02430C  8C420008   LW V0, 8(V0)
9D024310  7C4200C0   EXT V0, V0, 3, 1
9D024314  304200FF   ANDI V0, V0, 255
446:                 }
9D024318  03C0E821   ADDU SP, S8, ZERO
9D02431C  8FBE0004   LW S8, 4(SP)
9D024320  27BD0008   ADDIU SP, SP, 8
9D024324  03E00008   JR RA
9D024328  00000000   NOP
447:                 
448:                 
449:                 /*****************************************************************************
450:                   Function:
451:                 	void DHCPTask(void)
452:                 
453:                   Summary:
454:                 	Performs periodic DHCP tasks for all interfaces.
455:                 
456:                   Description:
457:                 	This function performs any periodic tasks requied by the DHCP module, 
458:                 	such as sending and receiving messages involved with obtaining and
459:                 	maintaining a lease.
460:                 
461:                   Precondition:
462:                 	None
463:                 
464:                   Parameters:
465:                 	None
466:                 
467:                   Returns:
468:                 	None
469:                 ***************************************************************************/
470:                 void DHCPTask(void)
471:                 {
9D02432C  27BDFFE0   ADDIU SP, SP, -32
9D024330  AFBF001C   SW RA, 28(SP)
9D024334  AFBE0018   SW S8, 24(SP)
9D024338  03A0F021   ADDU S8, SP, ZERO
472:                 	BYTE i;
473:                 	
474:                 	for(i = 0; i < NETWORK_INTERFACES; i++)
9D02433C  A3C00010   SB ZERO, 16(S8)
9D024340  0B4092F5   J 0x9D024BD4
9D024344  00000000   NOP
9D024BC8  93C20010   LBU V0, 16(S8)
9D024BCC  24420001   ADDIU V0, V0, 1
9D024BD0  A3C20010   SB V0, 16(S8)
9D024BD4  93C20010   LBU V0, 16(S8)
9D024BD8  1040FDDB   BEQ V0, ZERO, 0x9D024348
9D024BDC  00000000   NOP
475:                 	{
476:                 		LoadState(i);
477:                 		switch(DHCPClient.smState)
9D024348  3C02A000   LUI V0, -24576
9D02434C  24423254   ADDIU V0, V0, 12884
9D024350  8C420004   LW V0, 4(V0)
9D024354  2C43000D   SLTIU V1, V0, 13
9D024358  1060021B   BEQ V1, ZERO, 0x9D024BC8
9D02435C  00000000   NOP
9D024360  00021880   SLL V1, V0, 2
9D024364  3C029D02   LUI V0, -25342
9D024368  2442437C   ADDIU V0, V0, 17276
9D02436C  00621021   ADDU V0, V1, V0
9D024370  8C420000   LW V0, 0(V0)
9D024374  00400008   JR V0
9D024378  00000000   NOP
478:                 		{
479:                 			case SM_DHCP_DISABLED:
480:                 				// When the module is disabled, do absolutely nothing
481:                 				break;
9D024B34  00000000   NOP
9D024B38  0B4092F2   J 0x9D024BC8
9D024B3C  00000000   NOP
482:                 			
483:                 			case SM_DHCP_GET_SOCKET:
484:                 				// Open a socket to send and receive broadcast messages on
485:                 				//DHCPClient.hDHCPSocket = UDPOpen(DHCP_CLIENT_PORT, NULL, DHCP_SERVER_PORT);
486:                 				
487:                 				DHCPClient.hDHCPSocket = UDPOpenEx(0,UDP_OPEN_SERVER,DHCP_CLIENT_PORT, DHCP_SERVER_PORT);
9D0243B0  00002021   ADDU A0, ZERO, ZERO
9D0243B4  00002821   ADDU A1, ZERO, ZERO
9D0243B8  24060044   ADDIU A2, ZERO, 68
9D0243BC  24070043   ADDIU A3, ZERO, 67
9D0243C0  0F40A0DD   JAL UDPOpenEx
9D0243C4  00000000   NOP
9D0243C8  00401821   ADDU V1, V0, ZERO
9D0243CC  3C02A000   LUI V0, -24576
9D0243D0  A0433254   SB V1, 12884(V0)
488:                 				if(DHCPClient.hDHCPSocket == INVALID_UDP_SOCKET)
9D0243D4  3C02A000   LUI V0, -24576
9D0243D8  90433254   LBU V1, 12884(V0)
9D0243DC  240200FF   ADDIU V0, ZERO, 255
9D0243E0  106201D7   BEQ V1, V0, 0x9D024B40
9D0243E4  00000000   NOP
489:                 					break;
9D024B40  00000000   NOP
9D024B44  0B4092F2   J 0x9D024BC8
9D024B48  00000000   NOP
490:                 	
491:                 				DHCPClient.smState = SM_DHCP_SEND_DISCOVERY;
9D0243E8  3C02A000   LUI V0, -24576
9D0243EC  24423254   ADDIU V0, V0, 12884
9D0243F0  24030002   ADDIU V1, ZERO, 2
9D0243F4  AC430004   SW V1, 4(V0)
492:                 				// No break
493:                 	
494:                 			case SM_DHCP_SEND_DISCOVERY:
495:                 				// Assume default IP Lease time of 60 seconds.
496:                 				// This should be minimum possible to make sure that if the
497:                 				// server did not specify lease time, we try again after this 
498:                 				// minimum time.
499:                 				DHCPClient.dwLeaseTime = 60;
9D0243F8  3C02A000   LUI V0, -24576
9D0243FC  24423254   ADDIU V0, V0, 12884
9D024400  2403003C   ADDIU V1, ZERO, 60
9D024404  AC430010   SW V1, 16(V0)
500:                 				DHCPClient.validValues.val = 0x00;
9D024408  3C02A000   LUI V0, -24576
9D02440C  24423254   ADDIU V0, V0, 12884
9D024410  A040002C   SB ZERO, 44(V0)
501:                 				DHCPClient.flags.bits.bIsBound = FALSE;	
9D024414  3C02A000   LUI V0, -24576
9D024418  24433254   ADDIU V1, V0, 12884
9D02441C  8C620008   LW V0, 8(V1)
9D024420  7C020004   INS V0, ZERO, 0, 1
9D024424  AC620008   SW V0, 8(V1)
502:                 				DHCPClient.flags.bits.bOfferReceived = FALSE;
9D024428  3C02A000   LUI V0, -24576
9D02442C  24433254   ADDIU V1, V0, 12884
9D024430  8C620008   LW V0, 8(V1)
9D024434  7C021084   INS V0, ZERO, 2, 1
9D024438  AC620008   SW V0, 8(V1)
503:                 	
504:                 				// No point in wasting time transmitting a discovery if we are 
505:                 				// unlinked.  No one will see it.  
506:                 				if(!MACIsLinked())
9D02443C  0F40726F   JAL MACIsLinked
9D024440  00000000   NOP
9D024444  104001C1   BEQ V0, ZERO, 0x9D024B4C
9D024448  00000000   NOP
507:                 					break;
9D024B4C  00000000   NOP
9D024B50  0B4092F2   J 0x9D024BC8
9D024B54  00000000   NOP
508:                 	
509:                             	#if defined(WF_CS_IO) && defined(STACK_USE_UART)
510:                 					// Note: Use this debug message out to UART with caution. It can prevent slow down stack
511:                 					// performance and possibly prevent STA from properly receiving DHCP IP.
512:                             	    // putrsUART("DHCP Send Discovery...\r\n");
513:                                 #endif
514:                             	
515:                 				// Ensure transmitter is ready to accept data
516:                 				if(UDPIsPutReady(DHCPClient.hDHCPSocket) < 300u)
9D02444C  3C02A000   LUI V0, -24576
9D024450  90423254   LBU V0, 12884(V0)
9D024454  00402021   ADDU A0, V0, ZERO
9D024458  0F40A307   JAL UDPIsPutReady
9D02445C  00000000   NOP
9D024460  2C42012C   SLTIU V0, V0, 300
9D024464  144001BC   BNE V0, ZERO, 0x9D024B58
9D024468  00000000   NOP
517:                 					break;
9D024B58  00000000   NOP
9D024B5C  0B4092F2   J 0x9D024BC8
9D024B60  00000000   NOP
518:                 
519:                 				// Toggle the BOOTP Broadcast flag to ensure compatibility with 
520:                 				// bad DHCP servers that don't know how to handle broadcast 
521:                 				// responses.  This results in the next discovery attempt to be 
522:                 				// made using the opposite mode.
523:                 				DHCPClient.flags.bits.bUseUnicastMode ^= 1;
9D02446C  3C02A000   LUI V0, -24576
9D024470  24423254   ADDIU V0, V0, 12884
9D024474  8C420008   LW V0, 8(V0)
9D024478  7C420100   EXT V0, V0, 4, 1
9D02447C  304200FF   ANDI V0, V0, 255
9D024480  38420001   XORI V0, V0, 1
9D024484  304200FF   ANDI V0, V0, 255
9D024488  30420001   ANDI V0, V0, 1
9D02448C  304400FF   ANDI A0, V0, 255
9D024490  3C02A000   LUI V0, -24576
9D024494  24433254   ADDIU V1, V0, 12884
9D024498  8C620008   LW V0, 8(V1)
9D02449C  7C822104   INS V0, A0, 4, 1
9D0244A0  AC620008   SW V0, 8(V1)
524:                 	
525:                 				// Ensure that we transmit to the broadcast IP and MAC addresses
526:                 				// The UDP Socket remembers who it was last talking to
527:                 				memset((void*)&UDPSocketInfo[DHCPClient.hDHCPSocket].remote.remoteNode, 0xFF, sizeof(UDPSocketInfo[0].remote.remoteNode));
9D0244A4  3C02A000   LUI V0, -24576
9D0244A8  90423254   LBU V0, 12884(V0)
9D0244AC  00401821   ADDU V1, V0, ZERO
9D0244B0  2402001C   ADDIU V0, ZERO, 28
9D0244B4  70621802   MUL V1, V1, V0
9D0244B8  3C02A000   LUI V0, -24576
9D0244BC  24420648   ADDIU V0, V0, 1608
9D0244C0  00621021   ADDU V0, V1, V0
9D0244C4  00402021   ADDU A0, V0, ZERO
9D0244C8  240500FF   ADDIU A1, ZERO, 255
9D0244CC  2406000A   ADDIU A2, ZERO, 10
9D0244D0  0F40D5EC   JAL 0x9D0357B0
9D0244D4  00000000   NOP
528:                 	
529:                 				// Send the DHCP Discover broadcast
530:                 				_DHCPSend(DHCP_DISCOVER_MESSAGE, FALSE);
9D0244D8  24040001   ADDIU A0, ZERO, 1
9D0244DC  00002821   ADDU A1, ZERO, ZERO
9D0244E0  0F4094E3   JAL 0x9D02538C
9D0244E4  00000000   NOP
531:                 	
532:                 				// Start a timer and begin looking for a response
533:                 				DHCPClient.dwTimer = TickGet();
9D0244E8  0F40CDD6   JAL TickGet
9D0244EC  00000000   NOP
9D0244F0  00401821   ADDU V1, V0, ZERO
9D0244F4  3C02A000   LUI V0, -24576
9D0244F8  24423254   ADDIU V0, V0, 12884
9D0244FC  AC43000C   SW V1, 12(V0)
534:                 				DHCPClient.smState = SM_DHCP_GET_OFFER;
9D024500  3C02A000   LUI V0, -24576
9D024504  24423254   ADDIU V0, V0, 12884
9D024508  24030003   ADDIU V1, ZERO, 3
9D02450C  AC430004   SW V1, 4(V0)
535:                 				break;
9D024510  0B4092F2   J 0x9D024BC8
9D024514  00000000   NOP
536:                 	
537:                 			case SM_DHCP_GET_OFFER:
538:                 				// Check to see if a packet has arrived
539:                 				if(UDPIsGetReady(DHCPClient.hDHCPSocket) < 250u)
9D024518  3C02A000   LUI V0, -24576
9D02451C  90423254   LBU V0, 12884(V0)
9D024520  00402021   ADDU A0, V0, ZERO
9D024524  0F40A3FD   JAL UDPIsGetReady
9D024528  00000000   NOP
9D02452C  2C4200FA   SLTIU V0, V0, 250
9D024530  10400013   BEQ V0, ZERO, 0x9D024580
9D024534  00000000   NOP
540:                 				{
541:                 					// Go back and transmit a new discovery if we didn't get an offer after 2 seconds
542:                 					if(TickGet() - DHCPClient.dwTimer >= DHCP_TIMEOUT)
9D024538  0F40CDD6   JAL TickGet
9D02453C  00000000   NOP
9D024540  00401821   ADDU V1, V0, ZERO
9D024544  3C02A000   LUI V0, -24576
9D024548  24423254   ADDIU V0, V0, 12884
9D02454C  8C42000C   LW V0, 12(V0)
9D024550  00621823   SUBU V1, V1, V0
9D024554  3C020004   LUI V0, 4
9D024558  3442C4B4   ORI V0, V0, -15180
9D02455C  0062102B   SLTU V0, V1, V0
9D024560  14400180   BNE V0, ZERO, 0x9D024B64
9D024564  00000000   NOP
543:                 						DHCPClient.smState = SM_DHCP_SEND_DISCOVERY;
9D024568  3C02A000   LUI V0, -24576
9D02456C  24423254   ADDIU V0, V0, 12884
9D024570  24030002   ADDIU V1, ZERO, 2
9D024574  AC430004   SW V1, 4(V0)
544:                 					break;
9D024578  0B4092F2   J 0x9D024BC8
9D02457C  00000000   NOP
9D024B64  00000000   NOP
9D024B68  0B4092F2   J 0x9D024BC8
9D024B6C  00000000   NOP
545:                 				}
546:                 	
547:                 				// Let the DHCP server module know that there is a DHCP server 
548:                 				// on this network
549:                 				DHCPClient.flags.bits.bDHCPServerDetected = TRUE;
9D024580  3C02A000   LUI V0, -24576
9D024584  24433254   ADDIU V1, V0, 12884
9D024588  8C620008   LW V0, 8(V1)
9D02458C  24040001   ADDIU A0, ZERO, 1
9D024590  7C8218C4   INS V0, A0, 3, 1
9D024594  AC620008   SW V0, 8(V1)
550:                 	
551:                 				// Check to see if we received an offer
552:                 				if(_DHCPReceive() != DHCP_OFFER_MESSAGE)
9D024598  0F4092FE   JAL 0x9D024BF8
9D02459C  00000000   NOP
9D0245A0  00401821   ADDU V1, V0, ZERO
9D0245A4  24020002   ADDIU V0, ZERO, 2
9D0245A8  14620171   BNE V1, V0, 0x9D024B70
9D0245AC  00000000   NOP
553:                 					break;
9D024B70  00000000   NOP
9D024B74  0B4092F2   J 0x9D024BC8
9D024B78  00000000   NOP
554:                 	
555:                 				DHCPClient.smState = SM_DHCP_SEND_REQUEST;
9D0245B0  3C02A000   LUI V0, -24576
9D0245B4  24423254   ADDIU V0, V0, 12884
9D0245B8  24030004   ADDIU V1, ZERO, 4
9D0245BC  AC430004   SW V1, 4(V0)
556:                 				// No break
557:                 	
558:                 			case SM_DHCP_SEND_REQUEST:
559:                 				if(UDPIsPutReady(DHCPClient.hDHCPSocket) < 258u)
9D0245C0  3C02A000   LUI V0, -24576
9D0245C4  90423254   LBU V0, 12884(V0)
9D0245C8  00402021   ADDU A0, V0, ZERO
9D0245CC  0F40A307   JAL UDPIsPutReady
9D0245D0  00000000   NOP
9D0245D4  2C420102   SLTIU V0, V0, 258
9D0245D8  14400168   BNE V0, ZERO, 0x9D024B7C
9D0245DC  00000000   NOP
560:                 					break;
9D024B7C  00000000   NOP
9D024B80  0B4092F2   J 0x9D024BC8
9D024B84  00000000   NOP
561:                 
562:                 				// Ensure that we transmit to the broadcast IP and MAC addresses
563:                 				// The UDP Socket remembers who it was last talking to, so 
564:                 				// we must set this back to the broadcast address since the 
565:                 				// current socket values are the unicast addresses of the DHCP 
566:                 				// server.
567:                 				memset((void*)&UDPSocketInfo[DHCPClient.hDHCPSocket].remote.remoteNode, 0xFF, sizeof(UDPSocketInfo[0].remote.remoteNode));
9D0245E0  3C02A000   LUI V0, -24576
9D0245E4  90423254   LBU V0, 12884(V0)
9D0245E8  00401821   ADDU V1, V0, ZERO
9D0245EC  2402001C   ADDIU V0, ZERO, 28
9D0245F0  70621802   MUL V1, V1, V0
9D0245F4  3C02A000   LUI V0, -24576
9D0245F8  24420648   ADDIU V0, V0, 1608
9D0245FC  00621021   ADDU V0, V1, V0
9D024600  00402021   ADDU A0, V0, ZERO
9D024604  240500FF   ADDIU A1, ZERO, 255
9D024608  2406000A   ADDIU A2, ZERO, 10
9D02460C  0F40D5EC   JAL 0x9D0357B0
9D024610  00000000   NOP
568:                 	
569:                 				// Send the DHCP request message
570:                 				_DHCPSend(DHCP_REQUEST_MESSAGE, FALSE);
9D024614  24040003   ADDIU A0, ZERO, 3
9D024618  00002821   ADDU A1, ZERO, ZERO
9D02461C  0F4094E3   JAL 0x9D02538C
9D024620  00000000   NOP
571:                 	
572:                 				// Start a timer and begin looking for a response
573:                 				DHCPClient.dwTimer = TickGet();
9D024624  0F40CDD6   JAL TickGet
9D024628  00000000   NOP
9D02462C  00401821   ADDU V1, V0, ZERO
9D024630  3C02A000   LUI V0, -24576
9D024634  24423254   ADDIU V0, V0, 12884
9D024638  AC43000C   SW V1, 12(V0)
574:                 				DHCPClient.smState = SM_DHCP_GET_REQUEST_ACK;
9D02463C  3C02A000   LUI V0, -24576
9D024640  24423254   ADDIU V0, V0, 12884
9D024644  24030005   ADDIU V1, ZERO, 5
9D024648  AC430004   SW V1, 4(V0)
575:                 				break;
9D02464C  0B4092F2   J 0x9D024BC8
9D024650  00000000   NOP
576:                 	
577:                 			case SM_DHCP_GET_REQUEST_ACK:
578:                 				// Check to see if a packet has arrived
579:                 				if(UDPIsGetReady(DHCPClient.hDHCPSocket) < 250u)
9D024654  3C02A000   LUI V0, -24576
9D024658  90423254   LBU V0, 12884(V0)
9D02465C  00402021   ADDU A0, V0, ZERO
9D024660  0F40A3FD   JAL UDPIsGetReady
9D024664  00000000   NOP
9D024668  2C4200FA   SLTIU V0, V0, 250
9D02466C  10400013   BEQ V0, ZERO, 0x9D0246BC
9D024670  00000000   NOP
580:                 				{
581:                 					// Go back and transmit a new discovery if we didn't get an ACK after 2 seconds
582:                 					if(TickGet() - DHCPClient.dwTimer >= DHCP_TIMEOUT)
9D024674  0F40CDD6   JAL TickGet
9D024678  00000000   NOP
9D02467C  00401821   ADDU V1, V0, ZERO
9D024680  3C02A000   LUI V0, -24576
9D024684  24423254   ADDIU V0, V0, 12884
9D024688  8C42000C   LW V0, 12(V0)
9D02468C  00621823   SUBU V1, V1, V0
9D024690  3C020004   LUI V0, 4
9D024694  3442C4B4   ORI V0, V0, -15180
9D024698  0062102B   SLTU V0, V1, V0
9D02469C  1440013A   BNE V0, ZERO, 0x9D024B88
9D0246A0  00000000   NOP
583:                 						DHCPClient.smState = SM_DHCP_SEND_DISCOVERY;
9D0246A4  3C02A000   LUI V0, -24576
9D0246A8  24423254   ADDIU V0, V0, 12884
9D0246AC  24030002   ADDIU V1, ZERO, 2
9D0246B0  AC430004   SW V1, 4(V0)
584:                 					break;
9D0246B4  0B4092F2   J 0x9D024BC8
9D0246B8  00000000   NOP
9D024B88  00000000   NOP
9D024B8C  0B4092F2   J 0x9D024BC8
9D024B90  00000000   NOP
585:                 				}
586:                 	
587:                 				// Check to see if we received an offer
588:                 				switch(_DHCPReceive())
9D0246BC  0F4092FE   JAL 0x9D024BF8
9D0246C0  00000000   NOP
9D0246C4  24030005   ADDIU V1, ZERO, 5
9D0246C8  10430006   BEQ V0, V1, 0x9D0246E4
9D0246CC  00000000   NOP
9D0246D0  24030006   ADDIU V1, ZERO, 6
9D0246D4  10430068   BEQ V0, V1, 0x9D024878
9D0246D8  00000000   NOP
589:                 				{
590:                 					case DHCP_ACK_MESSAGE:
591:                 						UDPClose(DHCPClient.hDHCPSocket);
9D0246E4  3C02A000   LUI V0, -24576
9D0246E8  90423254   LBU V0, 12884(V0)
9D0246EC  00402021   ADDU A0, V0, ZERO
9D0246F0  0F40A2B9   JAL UDPClose
9D0246F4  00000000   NOP
592:                 						DHCPClient.hDHCPSocket = INVALID_UDP_SOCKET;
9D0246F8  3C02A000   LUI V0, -24576
9D0246FC  2403FFFF   ADDIU V1, ZERO, -1
9D024700  A0433254   SB V1, 12884(V0)
593:                 						DHCPClient.dwTimer = TickGet();
9D024704  0F40CDD6   JAL TickGet
9D024708  00000000   NOP
9D02470C  00401821   ADDU V1, V0, ZERO
9D024710  3C02A000   LUI V0, -24576
9D024714  24423254   ADDIU V0, V0, 12884
9D024718  AC43000C   SW V1, 12(V0)
594:                 						DHCPClient.smState = SM_DHCP_BOUND;
9D02471C  3C02A000   LUI V0, -24576
9D024720  24423254   ADDIU V0, V0, 12884
9D024724  24030006   ADDIU V1, ZERO, 6
9D024728  AC430004   SW V1, 4(V0)
595:                 						DHCPClient.flags.bits.bEvent = 1;
9D02472C  3C02A000   LUI V0, -24576
9D024730  24433254   ADDIU V1, V0, 12884
9D024734  8C620008   LW V0, 8(V1)
9D024738  24040001   ADDIU A0, ZERO, 1
9D02473C  7C820844   INS V0, A0, 1, 1
9D024740  AC620008   SW V0, 8(V1)
596:                 						DHCPClient.flags.bits.bIsBound = TRUE;	
9D024744  3C02A000   LUI V0, -24576
9D024748  24433254   ADDIU V1, V0, 12884
9D02474C  8C620008   LW V0, 8(V1)
9D024750  24040001   ADDIU A0, ZERO, 1
9D024754  7C820004   INS V0, A0, 0, 1
9D024758  AC620008   SW V0, 8(V1)
597:                 
598:                 						if(DHCPClient.validValues.bits.IPAddress)
9D02475C  3C02A000   LUI V0, -24576
9D024760  24423254   ADDIU V0, V0, 12884
9D024764  8C42002C   LW V0, 44(V0)
9D024768  30420001   ANDI V0, V0, 1
9D02476C  10400008   BEQ V0, ZERO, 0x9D024790
9D024770  00000000   NOP
599:                 						{
600:                 							AppConfig.MyIPAddr = DHCPClient.tempIPAddress;
9D024774  3C02A000   LUI V0, -24576
9D024778  3C03A000   LUI V1, -24576
9D02477C  24633254   ADDIU V1, V1, 12884
9D024780  8C630018   LW V1, 24(V1)
9D024784  24440728   ADDIU A0, V0, 1832
9D024788  A8830003   SWL V1, 3(A0)
9D02478C  B8430728   SWR V1, 1832(V0)
601:                 							
602:                 							#if defined(WF_CS_IO) 
603:                 							    #if defined(STACK_USE_UART )
604:                 							        putrsUART("DHCP client successful\r\n");
605:                 							    #endif
606:                     							SignalDHCPSuccessful();
607:                 							#endif
608:                 							
609:                 						}	
610:                 						if(DHCPClient.validValues.bits.Mask)
9D024790  3C02A000   LUI V0, -24576
9D024794  24423254   ADDIU V0, V0, 12884
9D024798  8C42002C   LW V0, 44(V0)
9D02479C  30420004   ANDI V0, V0, 4
9D0247A0  10400008   BEQ V0, ZERO, 0x9D0247C4
9D0247A4  00000000   NOP
611:                 							AppConfig.MyMask = DHCPClient.tempMask;
9D0247A8  3C02A000   LUI V0, -24576
9D0247AC  3C03A000   LUI V1, -24576
9D0247B0  24633254   ADDIU V1, V1, 12884
9D0247B4  24420728   ADDIU V0, V0, 1832
9D0247B8  8C630020   LW V1, 32(V1)
9D0247BC  A8430007   SWL V1, 7(V0)
9D0247C0  B8430004   SWR V1, 4(V0)
612:                 						if(DHCPClient.validValues.bits.Gateway)
9D0247C4  3C02A000   LUI V0, -24576
9D0247C8  24423254   ADDIU V0, V0, 12884
9D0247CC  8C42002C   LW V0, 44(V0)
9D0247D0  30420002   ANDI V0, V0, 2
9D0247D4  10400008   BEQ V0, ZERO, 0x9D0247F8
9D0247D8  00000000   NOP
613:                 							AppConfig.MyGateway = DHCPClient.tempGateway;
9D0247DC  3C02A000   LUI V0, -24576
9D0247E0  3C03A000   LUI V1, -24576
9D0247E4  24633254   ADDIU V1, V1, 12884
9D0247E8  24420728   ADDIU V0, V0, 1832
9D0247EC  8C63001C   LW V1, 28(V1)
9D0247F0  A843000B   SWL V1, 11(V0)
9D0247F4  B8430008   SWR V1, 8(V0)
614:                 						#if defined(STACK_USE_DNS)
615:                 							if(DHCPClient.validValues.bits.DNS)
9D0247F8  3C02A000   LUI V0, -24576
9D0247FC  24423254   ADDIU V0, V0, 12884
9D024800  8C42002C   LW V0, 44(V0)
9D024804  30420008   ANDI V0, V0, 8
9D024808  10400008   BEQ V0, ZERO, 0x9D02482C
9D02480C  00000000   NOP
616:                 								AppConfig.PrimaryDNSServer.Val = DHCPClient.tempDNS.Val;
9D024810  3C02A000   LUI V0, -24576
9D024814  24423254   ADDIU V0, V0, 12884
9D024818  8C430024   LW V1, 36(V0)
9D02481C  3C02A000   LUI V0, -24576
9D024820  24420728   ADDIU V0, V0, 1832
9D024824  A843000F   SWL V1, 15(V0)
9D024828  B843000C   SWR V1, 12(V0)
617:                 							AppConfig.SecondaryDNSServer.Val = 0x00000000ul;
9D02482C  3C02A000   LUI V0, -24576
9D024830  24420728   ADDIU V0, V0, 1832
9D024834  A8400013   SWL ZERO, 19(V0)
9D024838  B8400010   SWR ZERO, 16(V0)
618:                 							if(DHCPClient.validValues.bits.DNS2)
9D02483C  3C02A000   LUI V0, -24576
9D024840  24423254   ADDIU V0, V0, 12884
9D024844  8C42002C   LW V0, 44(V0)
9D024848  30420010   ANDI V0, V0, 16
9D02484C  10400008   BEQ V0, ZERO, 0x9D024870
9D024850  00000000   NOP
619:                 								AppConfig.SecondaryDNSServer.Val = DHCPClient.tempDNS2.Val;
9D024854  3C02A000   LUI V0, -24576
9D024858  24423254   ADDIU V0, V0, 12884
9D02485C  8C430028   LW V1, 40(V0)
9D024860  3C02A000   LUI V0, -24576
9D024864  24420728   ADDIU V0, V0, 1832
9D024868  A8430013   SWL V1, 19(V0)
9D02486C  B8430010   SWR V1, 16(V0)
620:                 						#endif
621:                 						//if(DHCPClient.validValues.bits.HostName)
622:                 						//	memcpy(AppConfig.NetBIOSName, (void*)DHCPClient.tempHostName, sizeof(AppConfig.NetBIOSName));
623:                 	
624:                 						break;
9D024870  0B409223   J 0x9D02488C
9D024874  00000000   NOP
625:                 	
626:                 					case DHCP_NAK_MESSAGE:
627:                 						DHCPClient.smState = SM_DHCP_SEND_DISCOVERY;
9D024878  3C02A000   LUI V0, -24576
9D02487C  24423254   ADDIU V0, V0, 12884
9D024880  24030002   ADDIU V1, ZERO, 2
9D024884  AC430004   SW V1, 4(V0)
628:                 						break;
9D024888  00000000   NOP
629:                 				}
630:                 				break;
9D0246DC  0B4092F2   J 0x9D024BC8
9D0246E0  00000000   NOP
9D02488C  0B4092F2   J 0x9D024BC8
9D024890  00000000   NOP
631:                 	
632:                 			case SM_DHCP_BOUND:
633:                 				if(TickGet() - DHCPClient.dwTimer < TICK_SECOND)
9D024894  0F40CDD6   JAL TickGet
9D024898  00000000   NOP
9D02489C  00401821   ADDU V1, V0, ZERO
9D0248A0  3C02A000   LUI V0, -24576
9D0248A4  24423254   ADDIU V0, V0, 12884
9D0248A8  8C42000C   LW V0, 12(V0)
9D0248AC  00621823   SUBU V1, V1, V0
9D0248B0  3C020002   LUI V0, 2
9D0248B4  3442625A   ORI V0, V0, 25178
9D0248B8  0062102B   SLTU V0, V1, V0
9D0248BC  144000B5   BNE V0, ZERO, 0x9D024B94
9D0248C0  00000000   NOP
634:                 					break;
9D024B94  00000000   NOP
9D024B98  0B4092F2   J 0x9D024BC8
9D024B9C  00000000   NOP
635:                 	
636:                 				// Check to see if our lease is still valid, if so, decrement lease 
637:                 				// time
638:                 				if(DHCPClient.dwLeaseTime >= 2ul)
9D0248C4  3C02A000   LUI V0, -24576
9D0248C8  24423254   ADDIU V0, V0, 12884
9D0248CC  8C420010   LW V0, 16(V0)
9D0248D0  2C420002   SLTIU V0, V0, 2
9D0248D4  14400013   BNE V0, ZERO, 0x9D024924
9D0248D8  00000000   NOP
639:                 				{
640:                 					DHCPClient.dwTimer += TICK_SECOND;
9D0248DC  3C02A000   LUI V0, -24576
9D0248E0  24423254   ADDIU V0, V0, 12884
9D0248E4  8C43000C   LW V1, 12(V0)
9D0248E8  3C020002   LUI V0, 2
9D0248EC  3442625A   ORI V0, V0, 25178
9D0248F0  00621821   ADDU V1, V1, V0
9D0248F4  3C02A000   LUI V0, -24576
9D0248F8  24423254   ADDIU V0, V0, 12884
9D0248FC  AC43000C   SW V1, 12(V0)
641:                 					DHCPClient.dwLeaseTime--;
9D024900  3C02A000   LUI V0, -24576
9D024904  24423254   ADDIU V0, V0, 12884
9D024908  8C420010   LW V0, 16(V0)
9D02490C  2443FFFF   ADDIU V1, V0, -1
9D024910  3C02A000   LUI V0, -24576
9D024914  24423254   ADDIU V0, V0, 12884
9D024918  AC430010   SW V1, 16(V0)
642:                 					break;
9D02491C  0B4092F2   J 0x9D024BC8
9D024920  00000000   NOP
643:                 				}
644:                 	
645:                 				// Open a socket to send and receive DHCP messages on
646:                 				//DHCPClient.hDHCPSocket = UDPOpen(DHCP_CLIENT_PORT, NULL, DHCP_SERVER_PORT);
647:                 				
648:                 				DHCPClient.hDHCPSocket = UDPOpenEx(0,UDP_OPEN_SERVER,DHCP_CLIENT_PORT, DHCP_SERVER_PORT);
9D024924  00002021   ADDU A0, ZERO, ZERO
9D024928  00002821   ADDU A1, ZERO, ZERO
9D02492C  24060044   ADDIU A2, ZERO, 68
9D024930  24070043   ADDIU A3, ZERO, 67
9D024934  0F40A0DD   JAL UDPOpenEx
9D024938  00000000   NOP
9D02493C  00401821   ADDU V1, V0, ZERO
9D024940  3C02A000   LUI V0, -24576
9D024944  A0433254   SB V1, 12884(V0)
649:                 				if(DHCPClient.hDHCPSocket == INVALID_UDP_SOCKET)
9D024948  3C02A000   LUI V0, -24576
9D02494C  90433254   LBU V1, 12884(V0)
9D024950  240200FF   ADDIU V0, ZERO, 255
9D024954  10620092   BEQ V1, V0, 0x9D024BA0
9D024958  00000000   NOP
650:                 					break;
9D024BA0  00000000   NOP
9D024BA4  0B4092F2   J 0x9D024BC8
9D024BA8  00000000   NOP
651:                 	
652:                 				DHCPClient.smState = SM_DHCP_SEND_RENEW;
9D02495C  3C02A000   LUI V0, -24576
9D024960  24423254   ADDIU V0, V0, 12884
9D024964  24030007   ADDIU V1, ZERO, 7
9D024968  AC430004   SW V1, 4(V0)
653:                 				// No break
654:                 	
655:                 			case SM_DHCP_SEND_RENEW:
656:                 			case SM_DHCP_SEND_RENEW2:
657:                 			case SM_DHCP_SEND_RENEW3:
658:                 				if(UDPIsPutReady(DHCPClient.hDHCPSocket) < 258u)
9D02496C  3C02A000   LUI V0, -24576
9D024970  90423254   LBU V0, 12884(V0)
9D024974  00402021   ADDU A0, V0, ZERO
9D024978  0F40A307   JAL UDPIsPutReady
9D02497C  00000000   NOP
9D024980  2C420102   SLTIU V0, V0, 258
9D024984  14400089   BNE V0, ZERO, 0x9D024BAC
9D024988  00000000   NOP
659:                 					break;
9D024BAC  00000000   NOP
9D024BB0  0B4092F2   J 0x9D024BC8
9D024BB4  00000000   NOP
660:                 	
661:                 				// Send the DHCP request message
662:                 				_DHCPSend(DHCP_REQUEST_MESSAGE, TRUE);
9D02498C  24040003   ADDIU A0, ZERO, 3
9D024990  24050001   ADDIU A1, ZERO, 1
9D024994  0F4094E3   JAL 0x9D02538C
9D024998  00000000   NOP
663:                 				DHCPClient.flags.bits.bOfferReceived = FALSE;
9D02499C  3C02A000   LUI V0, -24576
9D0249A0  24433254   ADDIU V1, V0, 12884
9D0249A4  8C620008   LW V0, 8(V1)
9D0249A8  7C021084   INS V0, ZERO, 2, 1
9D0249AC  AC620008   SW V0, 8(V1)
664:                 	
665:                 				// Start a timer and begin looking for a response
666:                 				DHCPClient.dwTimer = TickGet();
9D0249B0  0F40CDD6   JAL TickGet
9D0249B4  00000000   NOP
9D0249B8  00401821   ADDU V1, V0, ZERO
9D0249BC  3C02A000   LUI V0, -24576
9D0249C0  24423254   ADDIU V0, V0, 12884
9D0249C4  AC43000C   SW V1, 12(V0)
667:                 				DHCPClient.smState++;
9D0249C8  3C02A000   LUI V0, -24576
9D0249CC  24423254   ADDIU V0, V0, 12884
9D0249D0  8C420004   LW V0, 4(V0)
9D0249D4  24430001   ADDIU V1, V0, 1
9D0249D8  3C02A000   LUI V0, -24576
9D0249DC  24423254   ADDIU V0, V0, 12884
9D0249E0  AC430004   SW V1, 4(V0)
668:                 				break;
9D0249E4  0B4092F2   J 0x9D024BC8
9D0249E8  00000000   NOP
669:                 	
670:                 			case SM_DHCP_GET_RENEW_ACK:
671:                 			case SM_DHCP_GET_RENEW_ACK2:
672:                 			case SM_DHCP_GET_RENEW_ACK3:
673:                 				// Check to see if a packet has arrived
674:                 				if(UDPIsGetReady(DHCPClient.hDHCPSocket) < 250u)
9D0249EC  3C02A000   LUI V0, -24576
9D0249F0  90423254   LBU V0, 12884(V0)
9D0249F4  00402021   ADDU A0, V0, ZERO
9D0249F8  0F40A3FD   JAL UDPIsGetReady
9D0249FC  00000000   NOP
9D024A00  2C4200FA   SLTIU V0, V0, 250
9D024A04  10400020   BEQ V0, ZERO, 0x9D024A88
9D024A08  00000000   NOP
675:                 				{
676:                 					// Go back and transmit a new discovery if we didn't get an ACK after 2 seconds
677:                 					if(TickGet() - DHCPClient.dwTimer >=  DHCP_TIMEOUT)
9D024A0C  0F40CDD6   JAL TickGet
9D024A10  00000000   NOP
9D024A14  00401821   ADDU V1, V0, ZERO
9D024A18  3C02A000   LUI V0, -24576
9D024A1C  24423254   ADDIU V0, V0, 12884
9D024A20  8C42000C   LW V0, 12(V0)
9D024A24  00621823   SUBU V1, V1, V0
9D024A28  3C020004   LUI V0, 4
9D024A2C  3442C4B4   ORI V0, V0, -15180
9D024A30  0062102B   SLTU V0, V1, V0
9D024A34  14400060   BNE V0, ZERO, 0x9D024BB8
9D024A38  00000000   NOP
678:                 					{
679:                 						if(++DHCPClient.smState > SM_DHCP_GET_RENEW_ACK3)
9D024A3C  3C02A000   LUI V0, -24576
9D024A40  24423254   ADDIU V0, V0, 12884
9D024A44  8C420004   LW V0, 4(V0)
9D024A48  24430001   ADDIU V1, V0, 1
9D024A4C  3C02A000   LUI V0, -24576
9D024A50  24423254   ADDIU V0, V0, 12884
9D024A54  AC430004   SW V1, 4(V0)
9D024A58  3C02A000   LUI V0, -24576
9D024A5C  24423254   ADDIU V0, V0, 12884
9D024A60  8C420004   LW V0, 4(V0)
9D024A64  2C42000D   SLTIU V0, V0, 13
9D024A68  14400056   BNE V0, ZERO, 0x9D024BC4
9D024A6C  00000000   NOP
680:                 							DHCPClient.smState = SM_DHCP_SEND_DISCOVERY;
9D024A70  3C02A000   LUI V0, -24576
9D024A74  24423254   ADDIU V0, V0, 12884
9D024A78  24030002   ADDIU V1, ZERO, 2
9D024A7C  AC430004   SW V1, 4(V0)
681:                 					}
682:                 					break;
9D024A80  0B4092F2   J 0x9D024BC8
9D024A84  00000000   NOP
9D024BB8  00000000   NOP
9D024BBC  0B4092F2   J 0x9D024BC8
9D024BC0  00000000   NOP
9D024BC4  00000000   NOP
683:                 				}
684:                 	
685:                 				// Check to see if we received an offer
686:                 				switch(_DHCPReceive())
9D024A88  0F4092FE   JAL 0x9D024BF8
9D024A8C  00000000   NOP
9D024A90  24030005   ADDIU V1, ZERO, 5
9D024A94  10430006   BEQ V0, V1, 0x9D024AB0
9D024A98  00000000   NOP
9D024A9C  24030006   ADDIU V1, ZERO, 6
9D024AA0  1043001D   BEQ V0, V1, 0x9D024B18
9D024AA4  00000000   NOP
687:                 				{
688:                 					case DHCP_ACK_MESSAGE:
689:                 						UDPClose(DHCPClient.hDHCPSocket);
9D024AB0  3C02A000   LUI V0, -24576
9D024AB4  90423254   LBU V0, 12884(V0)
9D024AB8  00402021   ADDU A0, V0, ZERO
9D024ABC  0F40A2B9   JAL UDPClose
9D024AC0  00000000   NOP
690:                 						DHCPClient.hDHCPSocket = INVALID_UDP_SOCKET;
9D024AC4  3C02A000   LUI V0, -24576
9D024AC8  2403FFFF   ADDIU V1, ZERO, -1
9D024ACC  A0433254   SB V1, 12884(V0)
691:                 						DHCPClient.dwTimer = TickGet();
9D024AD0  0F40CDD6   JAL TickGet
9D024AD4  00000000   NOP
9D024AD8  00401821   ADDU V1, V0, ZERO
9D024ADC  3C02A000   LUI V0, -24576
9D024AE0  24423254   ADDIU V0, V0, 12884
9D024AE4  AC43000C   SW V1, 12(V0)
692:                 						DHCPClient.smState = SM_DHCP_BOUND;
9D024AE8  3C02A000   LUI V0, -24576
9D024AEC  24423254   ADDIU V0, V0, 12884
9D024AF0  24030006   ADDIU V1, ZERO, 6
9D024AF4  AC430004   SW V1, 4(V0)
693:                 						DHCPClient.flags.bits.bEvent = 1;
9D024AF8  3C02A000   LUI V0, -24576
9D024AFC  24433254   ADDIU V1, V0, 12884
9D024B00  8C620008   LW V0, 8(V1)
9D024B04  24040001   ADDIU A0, ZERO, 1
9D024B08  7C820844   INS V0, A0, 1, 1
9D024B0C  AC620008   SW V0, 8(V1)
694:                 						break;
9D024B10  0B4092CB   J 0x9D024B2C
9D024B14  00000000   NOP
695:                 		
696:                 					case DHCP_NAK_MESSAGE:
697:                 						DHCPClient.smState = SM_DHCP_SEND_DISCOVERY;
9D024B18  3C02A000   LUI V0, -24576
9D024B1C  24423254   ADDIU V0, V0, 12884
9D024B20  24030002   ADDIU V1, ZERO, 2
9D024B24  AC430004   SW V1, 4(V0)
698:                 						break;
9D024B28  00000000   NOP
699:                 				}
700:                 				break;
9D024AA8  0B4092F2   J 0x9D024BC8
9D024AAC  00000000   NOP
9D024B2C  0B4092F2   J 0x9D024BC8
9D024B30  00000000   NOP
701:                 		}
702:                 	}
703:                 }
9D024BE0  03C0E821   ADDU SP, S8, ZERO
9D024BE4  8FBF001C   LW RA, 28(SP)
9D024BE8  8FBE0018   LW S8, 24(SP)
9D024BEC  27BD0020   ADDIU SP, SP, 32
9D024BF0  03E00008   JR RA
9D024BF4  00000000   NOP
704:                 
705:                 
706:                 
707:                 /*****************************************************************************
708:                 Function:
709:                   void _DHCPReceive(void)
710:                 
711:                 Description:
712:                   Receives and parses a DHCP message.
713:                 
714:                 Precondition:
715:                   A DHCP message is waiting in the UDP buffer.
716:                 
717:                 Parameters:
718:                   None
719:                 
720:                 Returns:
721:                   One of the DCHP_TYPE* contants.
722:                 ***************************************************************************/
723:                 static BYTE _DHCPReceive(void)
724:                 {
9D024BF8  27BDFFD8   ADDIU SP, SP, -40
9D024BFC  AFBF0024   SW RA, 36(SP)
9D024C00  AFBE0020   SW S8, 32(SP)
9D024C04  03A0F021   ADDU S8, SP, ZERO
725:                 	/*********************************************************************
726:                 	DHCP PACKET FORMAT AS PER RFC 1541
727:                 
728:                 	0                   1                   2                   3
729:                 	0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
730:                 	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
731:                 	|     op (1)    |   htype (1)   |   hlen (1)    |   hops (1)    |
732:                 	+---------------+---------------+---------------+---------------+
733:                 	|                            xid (4)                            |
734:                 	+-------------------------------+-------------------------------+
735:                 	|           secs (2)            |           flags (2)           |
736:                 	+-------------------------------+-------------------------------+
737:                 	|                          ciaddr  (4)                          |
738:                 	+---------------------------------------------------------------+
739:                 	|                          yiaddr  (4)                          |
740:                 	+---------------------------------------------------------------+
741:                 	|                          siaddr  (4)                          |
742:                 	+---------------------------------------------------------------+
743:                 	|                          giaddr  (4)                          |
744:                 	+---------------------------------------------------------------+
745:                 	|                                                               |
746:                 	|                          chaddr  (16)                         |
747:                 	|                                                               |
748:                 	|                                                               |
749:                 	+---------------------------------------------------------------+
750:                 	|                                                               |
751:                 	|                          sname   (64)                         |
752:                 	+---------------------------------------------------------------+
753:                 	|                                                               |
754:                 	|                          file    (128)                        |
755:                 	+---------------------------------------------------------------+
756:                 	|                                                               |
757:                 	|                          options (312)                        |
758:                 	+---------------------------------------------------------------+
759:                 
760:                 	********************************************************************/
761:                 	BYTE v;
762:                 	BYTE i, j;
763:                 	BYTE type;
764:                 	BOOL lbDone;
765:                 	DWORD tempServerID;
766:                 
767:                 
768:                 	// Assume unknown message until proven otherwise.
769:                 	type = DHCP_UNKNOWN_MESSAGE;
9D024C08  A3C0001A   SB ZERO, 26(S8)
770:                 
771:                 	UDPGet(&v);                             // op
9D024C0C  27C20018   ADDIU V0, S8, 24
9D024C10  00402021   ADDU A0, V0, ZERO
9D024C14  0F40A421   JAL UDPGet
9D024C18  00000000   NOP
772:                 
773:                 	// Make sure this is BOOT_REPLY.
774:                 	if ( v == BOOT_REPLY )
9D024C1C  93C30018   LBU V1, 24(S8)
9D024C20  24020002   ADDIU V0, ZERO, 2
9D024C24  146201A1   BNE V1, V0, 0x9D0252AC
9D024C28  00000000   NOP
775:                 	{
776:                 		// Jump to chaddr field (Client Hardware Address -- our MAC address for 
777:                 		// Ethernet and WiFi networks) and verify that this message is directed 
778:                 		// to us before doing any other processing.
779:                 		UDPSetRxBuffer(28);		// chaddr field is at offset 28 in the UDP packet payload -- see DHCP packet format above
9D024C2C  2404001C   ADDIU A0, ZERO, 28
9D024C30  0F40A2F3   JAL UDPSetRxBuffer
9D024C34  00000000   NOP
780:                 		for ( i = 0; i < 6u; i++ )
9D024C38  A3C00010   SB ZERO, 16(S8)
9D024C3C  0B409320   J 0x9D024C80
9D024C40  00000000   NOP
9D024C74  93C20010   LBU V0, 16(S8)
9D024C78  24420001   ADDIU V0, V0, 1
9D024C7C  A3C20010   SB V0, 16(S8)
9D024C80  93C20010   LBU V0, 16(S8)
9D024C84  2C420006   SLTIU V0, V0, 6
9D024C88  1440FFEE   BNE V0, ZERO, 0x9D024C44
9D024C8C  00000000   NOP
781:                 		{
782:                 			UDPGet(&v);
9D024C44  27C20018   ADDIU V0, S8, 24
9D024C48  00402021   ADDU A0, V0, ZERO
9D024C4C  0F40A421   JAL UDPGet
9D024C50  00000000   NOP
783:                 			if ( v != AppConfig.MyMACAddr.v[i])
9D024C54  93C20010   LBU V0, 16(S8)
9D024C58  3C03A000   LUI V1, -24576
9D024C5C  24630728   ADDIU V1, V1, 1832
9D024C60  00621021   ADDU V0, V1, V0
9D024C64  9043002D   LBU V1, 45(V0)
9D024C68  93C20018   LBU V0, 24(S8)
9D024C6C  146201AB   BNE V1, V0, 0x9D02531C
9D024C70  00000000   NOP
784:                 				goto UDPInvalid;
9D02531C  00000000   NOP
9D025320  0B4094DA   J 0x9D025368
9D025324  00000000   NOP
785:                 		}
786:                 
787:                 		// Check to see if this is the first offer.  If it is, record its 
788:                 		// yiaddr value ("Your (client) IP address") so that we can REQUEST to 
789:                 		// use it later.
790:                 		if(!DHCPClient.flags.bits.bOfferReceived)
9D024C90  3C02A000   LUI V0, -24576
9D024C94  24423254   ADDIU V0, V0, 12884
9D024C98  8C420008   LW V0, 8(V0)
9D024C9C  30420004   ANDI V0, V0, 4
9D024CA0  1440000F   BNE V0, ZERO, 0x9D024CE0
9D024CA4  00000000   NOP
791:                 		{
792:                 			UDPSetRxBuffer(16);
9D024CA8  24040010   ADDIU A0, ZERO, 16
9D024CAC  0F40A2F3   JAL UDPSetRxBuffer
9D024CB0  00000000   NOP
793:                 			UDPGetArray((BYTE*)&DHCPClient.tempIPAddress, sizeof(DHCPClient.tempIPAddress));
9D024CB4  3C02A000   LUI V0, -24576
9D024CB8  2444326C   ADDIU A0, V0, 12908
9D024CBC  24050004   ADDIU A1, ZERO, 4
9D024CC0  0F40A442   JAL UDPGetArray
9D024CC4  00000000   NOP
794:                 			DHCPClient.validValues.bits.IPAddress = 1;
9D024CC8  3C02A000   LUI V0, -24576
9D024CCC  24433254   ADDIU V1, V0, 12884
9D024CD0  8C62002C   LW V0, 44(V1)
9D024CD4  2404FFFF   ADDIU A0, ZERO, -1
9D024CD8  7C820004   INS V0, A0, 0, 1
9D024CDC  AC62002C   SW V0, 44(V1)
795:                 		}
796:                 
797:                 		// Jump to DHCP options (ignore htype, hlen, hops, xid, secs, flags, 
798:                 		// ciaddr, siaddr, giaddr, padding part of chaddr, sname, file, magic 
799:                 		// cookie fields)
800:                 		UDPSetRxBuffer(240);
9D024CE0  240400F0   ADDIU A0, ZERO, 240
9D024CE4  0F40A2F3   JAL UDPSetRxBuffer
9D024CE8  00000000   NOP
801:                 
802:                 		lbDone = FALSE;
9D024CEC  AFC00014   SW ZERO, 20(S8)
803:                 		do
804:                 		{
805:                 			// Get the Option number
806:                 			// Break out eventually in case if this is a malformed 
807:                 			// DHCP message, ie: missing DHCP_END_OPTION marker
808:                 			if(!UDPGet(&v))
9D024CF0  27C20018   ADDIU V0, S8, 24
9D024CF4  00402021   ADDU A0, V0, ZERO
9D024CF8  0F40A421   JAL UDPGet
9D024CFC  00000000   NOP
9D024D00  14400005   BNE V0, ZERO, 0x9D024D18
9D024D04  00000000   NOP
809:                 			{
810:                 				lbDone = TRUE;
9D024D08  24020001   ADDIU V0, ZERO, 1
9D024D0C  AFC20014   SW V0, 20(S8)
811:                 				break;
9D024D10  0B4094AB   J 0x9D0252AC
9D024D14  00000000   NOP
812:                 			}
813:                 
814:                 			switch(v)
9D024D18  93C20018   LBU V0, 24(S8)
9D024D1C  24030033   ADDIU V1, ZERO, 51
9D024D20  10430105   BEQ V0, V1, 0x9D025138
9D024D24  00000000   NOP
9D024D28  28430034   SLTI V1, V0, 52
9D024D2C  1060000C   BEQ V1, ZERO, 0x9D024D60
9D024D30  00000000   NOP
9D024D34  24030003   ADDIU V1, ZERO, 3
9D024D38  10430055   BEQ V0, V1, 0x9D024E90
9D024D3C  00000000   NOP
9D024D40  24030006   ADDIU V1, ZERO, 6
9D024D44  1043008F   BEQ V0, V1, 0x9D024F84
9D024D48  00000000   NOP
9D024D4C  24030001   ADDIU V1, ZERO, 1
9D024D50  10430024   BEQ V0, V1, 0x9D024DE4
9D024D54  00000000   NOP
9D024D58  0B409490   J 0x9D025240
9D024D5C  00000000   NOP
9D024D60  24030036   ADDIU V1, ZERO, 54
9D024D64  104300D3   BEQ V0, V1, 0x9D0250B4
9D024D68  00000000   NOP
9D024D6C  240300FF   ADDIU V1, ZERO, 255
9D024D70  104300ED   BEQ V0, V1, 0x9D025128
9D024D74  00000000   NOP
9D024D78  24030035   ADDIU V1, ZERO, 53
9D024D7C  14430130   BNE V0, V1, 0x9D025240
9D024D80  00000000   NOP
815:                 			{
816:                 				case DHCP_MESSAGE_TYPE:
817:                 					UDPGet(&v);                         // Skip len
9D024D84  27C20018   ADDIU V0, S8, 24
9D024D88  00402021   ADDU A0, V0, ZERO
9D024D8C  0F40A421   JAL UDPGet
9D024D90  00000000   NOP
818:                 					// Len must be 1.
819:                 					if ( v == 1u )
9D024D94  93C30018   LBU V1, 24(S8)
9D024D98  24020001   ADDIU V0, ZERO, 1
9D024D9C  14620162   BNE V1, V0, 0x9D025328
9D024DA0  00000000   NOP
820:                 					{
821:                 						UDPGet(&type);                  // Get type
9D024DA4  27C2001A   ADDIU V0, S8, 26
9D024DA8  00402021   ADDU A0, V0, ZERO
9D024DAC  0F40A421   JAL UDPGet
9D024DB0  00000000   NOP
822:                 
823:                 						// Throw away the packet if we know we don't need it (ie: another offer when we already have one)
824:                 						if(DHCPClient.flags.bits.bOfferReceived && (type == DHCP_OFFER_MESSAGE))
9D024DB4  3C02A000   LUI V0, -24576
9D024DB8  24423254   ADDIU V0, V0, 12884
9D024DBC  8C420008   LW V0, 8(V0)
9D024DC0  30420004   ANDI V0, V0, 4
9D024DC4  10400132   BEQ V0, ZERO, 0x9D025290
9D024DC8  00000000   NOP
9D024DCC  93C3001A   LBU V1, 26(S8)
9D024DD0  24020002   ADDIU V0, ZERO, 2
9D024DD4  14620131   BNE V1, V0, 0x9D02529C
9D024DD8  00000000   NOP
825:                 						{
826:                 							goto UDPInvalid;
9D024DDC  0B4094DA   J 0x9D025368
9D024DE0  00000000   NOP
827:                 						}
828:                 					}
829:                 					else
830:                 						goto UDPInvalid;
9D025328  00000000   NOP
9D02532C  0B4094DA   J 0x9D025368
9D025330  00000000   NOP
831:                 					break;
9D025290  00000000   NOP
9D025294  0B4094A8   J 0x9D0252A0
9D025298  00000000   NOP
9D02529C  00000000   NOP
832:                 
833:                 				case DHCP_SUBNET_MASK:
834:                 					UDPGet(&v);                     // Skip len
9D024DE4  27C20018   ADDIU V0, S8, 24
9D024DE8  00402021   ADDU A0, V0, ZERO
9D024DEC  0F40A421   JAL UDPGet
9D024DF0  00000000   NOP
835:                 					// Len must be 4.
836:                 					if ( v == 4u )
9D024DF4  93C30018   LBU V1, 24(S8)
9D024DF8  24020004   ADDIU V0, ZERO, 4
9D024DFC  1462014D   BNE V1, V0, 0x9D025334
9D024E00  00000000   NOP
837:                 					{
838:                 						// Check to see if this is the first offer
839:                 						if(DHCPClient.flags.bits.bOfferReceived)
9D024E04  3C02A000   LUI V0, -24576
9D024E08  24423254   ADDIU V0, V0, 12884
9D024E0C  8C420008   LW V0, 8(V0)
9D024E10  30420004   ANDI V0, V0, 4
9D024E14  10400011   BEQ V0, ZERO, 0x9D024E5C
9D024E18  00000000   NOP
840:                 						{
841:                 							// Discard offered IP mask, we already have an offer
842:                 							for ( i = 0; i < 4u; i++ )
9D024E1C  A3C00010   SB ZERO, 16(S8)
9D024E20  0B409391   J 0x9D024E44
9D024E24  00000000   NOP
9D024E38  93C20010   LBU V0, 16(S8)
9D024E3C  24420001   ADDIU V0, V0, 1
9D024E40  A3C20010   SB V0, 16(S8)
9D024E44  93C20010   LBU V0, 16(S8)
9D024E48  2C420004   SLTIU V0, V0, 4
9D024E4C  1440FFF6   BNE V0, ZERO, 0x9D024E28
9D024E50  00000000   NOP
843:                 								UDPGet(&v);
9D024E28  27C20018   ADDIU V0, S8, 24
9D024E2C  00402021   ADDU A0, V0, ZERO
9D024E30  0F40A421   JAL UDPGet
9D024E34  00000000   NOP
844:                 						}
845:                 						else
846:                 						{
847:                 							UDPGetArray((BYTE*)&DHCPClient.tempMask, sizeof(DHCPClient.tempMask));
9D024E5C  3C02A000   LUI V0, -24576
9D024E60  24443274   ADDIU A0, V0, 12916
9D024E64  24050004   ADDIU A1, ZERO, 4
9D024E68  0F40A442   JAL UDPGetArray
9D024E6C  00000000   NOP
848:                 							DHCPClient.validValues.bits.Mask = 1;
9D024E70  3C02A000   LUI V0, -24576
9D024E74  24433254   ADDIU V1, V0, 12884
9D024E78  8C62002C   LW V0, 44(V1)
9D024E7C  2404FFFF   ADDIU A0, ZERO, -1
9D024E80  7C821084   INS V0, A0, 2, 1
9D024E84  AC62002C   SW V0, 44(V1)
849:                 						}
850:                 					}
851:                 					else
852:                 						goto UDPInvalid;
9D025334  00000000   NOP
9D025338  0B4094DA   J 0x9D025368
9D02533C  00000000   NOP
853:                 					break;
9D024E54  0B4094A8   J 0x9D0252A0
9D024E58  00000000   NOP
9D024E88  0B4094A8   J 0x9D0252A0
9D024E8C  00000000   NOP
854:                 
855:                 				case DHCP_ROUTER:
856:                 					UDPGet(&j);
9D024E90  27C20019   ADDIU V0, S8, 25
9D024E94  00402021   ADDU A0, V0, ZERO
9D024E98  0F40A421   JAL UDPGet
9D024E9C  00000000   NOP
857:                 					// Len must be >= 4.
858:                 					if ( j >= 4u )
9D024EA0  93C20019   LBU V0, 25(S8)
9D024EA4  2C420004   SLTIU V0, V0, 4
9D024EA8  14400125   BNE V0, ZERO, 0x9D025340
9D024EAC  00000000   NOP
859:                 					{
860:                 						// Check to see if this is the first offer
861:                 						if(DHCPClient.flags.bits.bOfferReceived)
9D024EB0  3C02A000   LUI V0, -24576
9D024EB4  24423254   ADDIU V0, V0, 12884
9D024EB8  8C420008   LW V0, 8(V0)
9D024EBC  30420004   ANDI V0, V0, 4
9D024EC0  10400011   BEQ V0, ZERO, 0x9D024F08
9D024EC4  00000000   NOP
862:                 						{
863:                 							// Discard offered Gateway address, we already have an offer
864:                 							for ( i = 0; i < 4u; i++ )
9D024EC8  A3C00010   SB ZERO, 16(S8)
9D024ECC  0B4093BC   J 0x9D024EF0
9D024ED0  00000000   NOP
9D024EE4  93C20010   LBU V0, 16(S8)
9D024EE8  24420001   ADDIU V0, V0, 1
9D024EEC  A3C20010   SB V0, 16(S8)
9D024EF0  93C20010   LBU V0, 16(S8)
9D024EF4  2C420004   SLTIU V0, V0, 4
9D024EF8  1440FFF6   BNE V0, ZERO, 0x9D024ED4
9D024EFC  00000000   NOP
9D024F00  0B4093CD   J 0x9D024F34
9D024F04  00000000   NOP
865:                 								UDPGet(&v);
9D024ED4  27C20018   ADDIU V0, S8, 24
9D024ED8  00402021   ADDU A0, V0, ZERO
9D024EDC  0F40A421   JAL UDPGet
9D024EE0  00000000   NOP
866:                 						}
867:                 						else
868:                 						{
869:                 							UDPGetArray((BYTE*)&DHCPClient.tempGateway, sizeof(DHCPClient.tempGateway));
9D024F08  3C02A000   LUI V0, -24576
9D024F0C  24443270   ADDIU A0, V0, 12912
9D024F10  24050004   ADDIU A1, ZERO, 4
9D024F14  0F40A442   JAL UDPGetArray
9D024F18  00000000   NOP
870:                 							DHCPClient.validValues.bits.Gateway = 1;
9D024F1C  3C02A000   LUI V0, -24576
9D024F20  24433254   ADDIU V1, V0, 12884
9D024F24  8C62002C   LW V0, 44(V1)
9D024F28  2404FFFF   ADDIU A0, ZERO, -1
9D024F2C  7C820844   INS V0, A0, 1, 1
9D024F30  AC62002C   SW V0, 44(V1)
871:                 						}
872:                 					}
873:                 					else
874:                 						goto UDPInvalid;
9D025340  00000000   NOP
9D025344  0B4094DA   J 0x9D025368
9D025348  00000000   NOP
875:                 
876:                 					// Discard any other router addresses.
877:                 					j -= 4;
9D024F34  93C20019   LBU V0, 25(S8)
9D024F38  2442FFFC   ADDIU V0, V0, -4
9D024F3C  304200FF   ANDI V0, V0, 255
9D024F40  A3C20019   SB V0, 25(S8)
878:                 					while(j--)
9D024F44  0B4093D7   J 0x9D024F5C
9D024F48  00000000   NOP
9D024F5C  93C20019   LBU V0, 25(S8)
9D024F60  0002182B   SLTU V1, ZERO, V0
9D024F64  306300FF   ANDI V1, V1, 255
9D024F68  2442FFFF   ADDIU V0, V0, -1
9D024F6C  304200FF   ANDI V0, V0, 255
9D024F70  A3C20019   SB V0, 25(S8)
9D024F74  1460FFF5   BNE V1, ZERO, 0x9D024F4C
9D024F78  00000000   NOP
879:                 						UDPGet(&v);
9D024F4C  27C20018   ADDIU V0, S8, 24
9D024F50  00402021   ADDU A0, V0, ZERO
9D024F54  0F40A421   JAL UDPGet
9D024F58  00000000   NOP
880:                 					break;
9D024F7C  0B4094A8   J 0x9D0252A0
9D024F80  00000000   NOP
881:                 
882:                 				#if defined(STACK_USE_DNS)
883:                 				case DHCP_DNS:
884:                 					UDPGet(&j);
9D024F84  27C20019   ADDIU V0, S8, 25
9D024F88  00402021   ADDU A0, V0, ZERO
9D024F8C  0F40A421   JAL UDPGet
9D024F90  00000000   NOP
885:                 					// Len must be >= 4.
886:                 					if(j < 4u)
9D024F94  93C20019   LBU V0, 25(S8)
9D024F98  2C420004   SLTIU V0, V0, 4
9D024F9C  144000EB   BNE V0, ZERO, 0x9D02534C
9D024FA0  00000000   NOP
887:                 						goto UDPInvalid;
9D02534C  00000000   NOP
9D025350  0B4094DA   J 0x9D025368
9D025354  00000000   NOP
888:                 
889:                 					// Check to see if this is the first offer
890:                 					if(!DHCPClient.flags.bits.bOfferReceived)
9D024FA4  3C02A000   LUI V0, -24576
9D024FA8  24423254   ADDIU V0, V0, 12884
9D024FAC  8C420008   LW V0, 8(V0)
9D024FB0  30420004   ANDI V0, V0, 4
9D024FB4  14400010   BNE V0, ZERO, 0x9D024FF8
9D024FB8  00000000   NOP
891:                 					{
892:                 						UDPGetArray((BYTE*)&DHCPClient.tempDNS, sizeof(DHCPClient.tempDNS));
9D024FBC  3C02A000   LUI V0, -24576
9D024FC0  24443278   ADDIU A0, V0, 12920
9D024FC4  24050004   ADDIU A1, ZERO, 4
9D024FC8  0F40A442   JAL UDPGetArray
9D024FCC  00000000   NOP
893:                 						DHCPClient.validValues.bits.DNS = 1;
9D024FD0  3C02A000   LUI V0, -24576
9D024FD4  24433254   ADDIU V1, V0, 12884
9D024FD8  8C62002C   LW V0, 44(V1)
9D024FDC  2404FFFF   ADDIU A0, ZERO, -1
9D024FE0  7C8218C4   INS V0, A0, 3, 1
9D024FE4  AC62002C   SW V0, 44(V1)
894:                 						j -= 4;
9D024FE8  93C20019   LBU V0, 25(S8)
9D024FEC  2442FFFC   ADDIU V0, V0, -4
9D024FF0  304200FF   ANDI V0, V0, 255
9D024FF4  A3C20019   SB V0, 25(S8)
895:                 					}
896:                 
897:                 					// Len must be >= 4 for a secondary DNS server address
898:                 					if(j >= 4u)
9D024FF8  93C20019   LBU V0, 25(S8)
9D024FFC  2C420004   SLTIU V0, V0, 4
9D025000  1440001E   BNE V0, ZERO, 0x9D02507C
9D025004  00000000   NOP
899:                 					{
900:                 						// Check to see if this is the first offer
901:                 						if(!DHCPClient.flags.bits.bOfferReceived)
9D025008  3C02A000   LUI V0, -24576
9D02500C  24423254   ADDIU V0, V0, 12884
9D025010  8C420008   LW V0, 8(V0)
9D025014  30420004   ANDI V0, V0, 4
9D025018  1440001B   BNE V0, ZERO, 0x9D025088
9D02501C  00000000   NOP
902:                 						{
903:                 							UDPGetArray((BYTE*)&DHCPClient.tempDNS2, sizeof(DHCPClient.tempDNS2));
9D025020  3C02A000   LUI V0, -24576
9D025024  2444327C   ADDIU A0, V0, 12924
9D025028  24050004   ADDIU A1, ZERO, 4
9D02502C  0F40A442   JAL UDPGetArray
9D025030  00000000   NOP
904:                 							DHCPClient.validValues.bits.DNS2 = 1;
9D025034  3C02A000   LUI V0, -24576
9D025038  24433254   ADDIU V1, V0, 12884
9D02503C  8C62002C   LW V0, 44(V1)
9D025040  2404FFFF   ADDIU A0, ZERO, -1
9D025044  7C822104   INS V0, A0, 4, 1
9D025048  AC62002C   SW V0, 44(V1)
905:                 							j -= 4;
9D02504C  93C20019   LBU V0, 25(S8)
9D025050  2442FFFC   ADDIU V0, V0, -4
9D025054  304200FF   ANDI V0, V0, 255
9D025058  A3C20019   SB V0, 25(S8)
906:                 						}
907:                 					}
908:                 
909:                 					// Discard any other DNS server addresses
910:                 					while(j--)
9D02505C  0B409423   J 0x9D02508C
9D025060  00000000   NOP
9D02507C  00000000   NOP
9D025080  0B409423   J 0x9D02508C
9D025084  00000000   NOP
9D025088  00000000   NOP
9D02508C  93C20019   LBU V0, 25(S8)
9D025090  0002182B   SLTU V1, ZERO, V0
9D025094  306300FF   ANDI V1, V1, 255
9D025098  2442FFFF   ADDIU V0, V0, -1
9D02509C  304200FF   ANDI V0, V0, 255
9D0250A0  A3C20019   SB V0, 25(S8)
9D0250A4  1460FFEF   BNE V1, ZERO, 0x9D025064
9D0250A8  00000000   NOP
911:                 						UDPGet(&v);
9D025064  27C20018   ADDIU V0, S8, 24
9D025068  00402021   ADDU A0, V0, ZERO
9D02506C  0F40A421   JAL UDPGet
9D025070  00000000   NOP
9D025074  0B409423   J 0x9D02508C
9D025078  00000000   NOP
912:                 					break;
9D0250AC  0B4094A8   J 0x9D0252A0
9D0250B0  00000000   NOP
913:                 				#endif
914:                 
915:                 					//            case DHCP_HOST_NAME:
916:                 					//                UDPGet(&j);
917:                 					//                // Len must be >= 4.
918:                 					//                if(j < 1u)
919:                 					//					goto UDPInvalid;
920:                 					//
921:                 					//				// Check to see if this is the first offer
922:                 					//				if(DHCPFlags.bits.bOfferReceived)
923:                 					//				{
924:                 					//			        // Discard offered host name, we already have an offer
925:                 					//	                while(j--)
926:                 					//	                    UDPGet(&v);
927:                 					//				}
928:                 					//				else
929:                 					//				{
930:                 					//					for(i = 0; j, i < sizeof(tempHostName); i++, j--)
931:                 					//					{
932:                 					//						UDPGet(&tempHostName[i]);
933:                 					//					}
934:                 					//					while(j--)
935:                 					//					{
936:                 					//						UDPGet(&v);
937:                 					//					}
938:                 					//					ValidValues.bits.HostName = 1;
939:                 					//				}
940:                 					//
941:                 					//                break;
942:                 
943:                 				case DHCP_SERVER_IDENTIFIER:
944:                 					UDPGet(&v);                         // Get len
9D0250B4  27C20018   ADDIU V0, S8, 24
9D0250B8  00402021   ADDU A0, V0, ZERO
9D0250BC  0F40A421   JAL UDPGet
9D0250C0  00000000   NOP
945:                 					// Len must be 4.
946:                 					if ( v == 4u )
9D0250C4  93C30018   LBU V1, 24(S8)
9D0250C8  24020004   ADDIU V0, ZERO, 4
9D0250CC  146200A2   BNE V1, V0, 0x9D025358
9D0250D0  00000000   NOP
947:                 					{
948:                 						UDPGet(&(((BYTE*)&tempServerID)[3]));   // Get the id
9D0250D4  27C2001C   ADDIU V0, S8, 28
9D0250D8  24420003   ADDIU V0, V0, 3
9D0250DC  00402021   ADDU A0, V0, ZERO
9D0250E0  0F40A421   JAL UDPGet
9D0250E4  00000000   NOP
949:                 						UDPGet(&(((BYTE*)&tempServerID)[2]));
9D0250E8  27C2001C   ADDIU V0, S8, 28
9D0250EC  24420002   ADDIU V0, V0, 2
9D0250F0  00402021   ADDU A0, V0, ZERO
9D0250F4  0F40A421   JAL UDPGet
9D0250F8  00000000   NOP
950:                 						UDPGet(&(((BYTE*)&tempServerID)[1]));
9D0250FC  27C2001C   ADDIU V0, S8, 28
9D025100  24420001   ADDIU V0, V0, 1
9D025104  00402021   ADDU A0, V0, ZERO
9D025108  0F40A421   JAL UDPGet
9D02510C  00000000   NOP
951:                 						UDPGet(&(((BYTE*)&tempServerID)[0]));
9D025110  27C2001C   ADDIU V0, S8, 28
9D025114  00402021   ADDU A0, V0, ZERO
9D025118  0F40A421   JAL UDPGet
9D02511C  00000000   NOP
952:                 					}
953:                 					else
954:                 						goto UDPInvalid;
9D025358  00000000   NOP
9D02535C  0B4094DA   J 0x9D025368
9D025360  00000000   NOP
955:                 					break;
9D025120  0B4094A8   J 0x9D0252A0
9D025124  00000000   NOP
956:                 
957:                 				case DHCP_END_OPTION:
958:                 					lbDone = TRUE;
9D025128  24020001   ADDIU V0, ZERO, 1
9D02512C  AFC20014   SW V0, 20(S8)
959:                 					break;
9D025130  0B4094A8   J 0x9D0252A0
9D025134  00000000   NOP
960:                 
961:                 				case DHCP_IP_LEASE_TIME:
962:                 					UDPGet(&v);                         // Get len
9D025138  27C20018   ADDIU V0, S8, 24
9D02513C  00402021   ADDU A0, V0, ZERO
9D025140  0F40A421   JAL UDPGet
9D025144  00000000   NOP
963:                 					// Len must be 4.
964:                 					if ( v == 4u )
9D025148  93C30018   LBU V1, 24(S8)
9D02514C  24020004   ADDIU V0, ZERO, 4
9D025150  14620084   BNE V1, V0, 0x9D025364
9D025154  00000000   NOP
965:                 					{
966:                 						// Check to see if this is the first offer
967:                 						if(DHCPClient.flags.bits.bOfferReceived)
9D025158  3C02A000   LUI V0, -24576
9D02515C  24423254   ADDIU V0, V0, 12884
9D025160  8C420008   LW V0, 8(V0)
9D025164  30420004   ANDI V0, V0, 4
9D025168  10400011   BEQ V0, ZERO, 0x9D0251B0
9D02516C  00000000   NOP
968:                 						{
969:                 							// Discard offered lease time, we already have an offer
970:                 							for ( i = 0; i < 4u; i++ )
9D025170  A3C00010   SB ZERO, 16(S8)
9D025174  0B409466   J 0x9D025198
9D025178  00000000   NOP
9D02518C  93C20010   LBU V0, 16(S8)
9D025190  24420001   ADDIU V0, V0, 1
9D025194  A3C20010   SB V0, 16(S8)
9D025198  93C20010   LBU V0, 16(S8)
9D02519C  2C420004   SLTIU V0, V0, 4
9D0251A0  1440FFF6   BNE V0, ZERO, 0x9D02517C
9D0251A4  00000000   NOP
971:                 								UDPGet(&v);
9D02517C  27C20018   ADDIU V0, S8, 24
9D025180  00402021   ADDU A0, V0, ZERO
9D025184  0F40A421   JAL UDPGet
9D025188  00000000   NOP
972:                 						}
973:                 						else
974:                 						{
975:                 							UDPGet(&(((BYTE*)(&DHCPClient.dwLeaseTime))[3]));
9D0251B0  3C02A000   LUI V0, -24576
9D0251B4  24423264   ADDIU V0, V0, 12900
9D0251B8  24420003   ADDIU V0, V0, 3
9D0251BC  00402021   ADDU A0, V0, ZERO
9D0251C0  0F40A421   JAL UDPGet
9D0251C4  00000000   NOP
976:                 							UDPGet(&(((BYTE*)(&DHCPClient.dwLeaseTime))[2]));
9D0251C8  3C02A000   LUI V0, -24576
9D0251CC  24423264   ADDIU V0, V0, 12900
9D0251D0  24420002   ADDIU V0, V0, 2
9D0251D4  00402021   ADDU A0, V0, ZERO
9D0251D8  0F40A421   JAL UDPGet
9D0251DC  00000000   NOP
977:                 							UDPGet(&(((BYTE*)(&DHCPClient.dwLeaseTime))[1]));
9D0251E0  3C02A000   LUI V0, -24576
9D0251E4  24423264   ADDIU V0, V0, 12900
9D0251E8  24420001   ADDIU V0, V0, 1
9D0251EC  00402021   ADDU A0, V0, ZERO
9D0251F0  0F40A421   JAL UDPGet
9D0251F4  00000000   NOP
978:                 							UDPGet(&(((BYTE*)(&DHCPClient.dwLeaseTime))[0]));
9D0251F8  3C02A000   LUI V0, -24576
9D0251FC  24423264   ADDIU V0, V0, 12900
9D025200  00402021   ADDU A0, V0, ZERO
9D025204  0F40A421   JAL UDPGet
9D025208  00000000   NOP
979:                 
980:                 							// In case if our clock is not as accurate as the remote 
981:                 							// DHCP server's clock, let's treat the lease time as only 
982:                 							// 96.875% of the value given
983:                 							DHCPClient.dwLeaseTime -= DHCPClient.dwLeaseTime>>5;
9D02520C  3C02A000   LUI V0, -24576
9D025210  24423254   ADDIU V0, V0, 12884
9D025214  8C430010   LW V1, 16(V0)
9D025218  3C02A000   LUI V0, -24576
9D02521C  24423254   ADDIU V0, V0, 12884
9D025220  8C420010   LW V0, 16(V0)
9D025224  00021142   SRL V0, V0, 5
9D025228  00621823   SUBU V1, V1, V0
9D02522C  3C02A000   LUI V0, -24576
9D025230  24423254   ADDIU V0, V0, 12884
9D025234  AC430010   SW V1, 16(V0)
984:                 						}
985:                 					}
986:                 					else
987:                 						goto UDPInvalid;
9D025364  00000000   NOP
988:                 					break;
9D0251A8  0B4094A8   J 0x9D0252A0
9D0251AC  00000000   NOP
9D025238  0B4094A8   J 0x9D0252A0
9D02523C  00000000   NOP
989:                 
990:                 				default:
991:                 					// Ignore all unsupport tags.
992:                 					UDPGet(&j);                     // Get option len
9D025240  27C20019   ADDIU V0, S8, 25
9D025244  00402021   ADDU A0, V0, ZERO
9D025248  0F40A421   JAL UDPGet
9D02524C  00000000   NOP
993:                 					while( j-- )                    // Ignore option values
9D025250  0B40949A   J 0x9D025268
9D025254  00000000   NOP
9D025268  93C20019   LBU V0, 25(S8)
9D02526C  0002182B   SLTU V1, ZERO, V0
9D025270  306300FF   ANDI V1, V1, 255
9D025274  2442FFFF   ADDIU V0, V0, -1
9D025278  304200FF   ANDI V0, V0, 255
9D02527C  A3C20019   SB V0, 25(S8)
9D025280  1460FFF5   BNE V1, ZERO, 0x9D025258
9D025284  00000000   NOP
9D025288  0B4094A8   J 0x9D0252A0
9D02528C  00000000   NOP
994:                 						UDPGet(&v);
9D025258  27C20018   ADDIU V0, S8, 24
9D02525C  00402021   ADDU A0, V0, ZERO
9D025260  0F40A421   JAL UDPGet
9D025264  00000000   NOP
995:                 			}
996:                 		} while( !lbDone );
9D0252A0  8FC20014   LW V0, 20(S8)
9D0252A4  1040FE92   BEQ V0, ZERO, 0x9D024CF0
9D0252A8  00000000   NOP
997:                 	}
998:                 
999:                 	// If this is an OFFER message, remember current server id.
1000:                	if ( type == DHCP_OFFER_MESSAGE )
9D0252AC  93C3001A   LBU V1, 26(S8)
9D0252B0  24020002   ADDIU V0, ZERO, 2
9D0252B4  1462000D   BNE V1, V0, 0x9D0252EC
9D0252B8  00000000   NOP
1001:                	{
1002:                		DHCPClient.dwServerID = tempServerID;
9D0252BC  8FC3001C   LW V1, 28(S8)
9D0252C0  3C02A000   LUI V0, -24576
9D0252C4  24423254   ADDIU V0, V0, 12884
9D0252C8  AC430014   SW V1, 20(V0)
1003:                		DHCPClient.flags.bits.bOfferReceived = TRUE;
9D0252CC  3C02A000   LUI V0, -24576
9D0252D0  24433254   ADDIU V1, V0, 12884
9D0252D4  8C620008   LW V0, 8(V1)
9D0252D8  24040001   ADDIU A0, ZERO, 1
9D0252DC  7C821084   INS V0, A0, 2, 1
9D0252E0  AC620008   SW V0, 8(V1)
9D0252E4  0B4094C2   J 0x9D025308
9D0252E8  00000000   NOP
1004:                	}
1005:                	else
1006:                	{
1007:                		// For other types of messages, make sure that received
1008:                		// server id matches with our previous one.
1009:                		if ( DHCPClient.dwServerID != tempServerID )
9D0252EC  3C02A000   LUI V0, -24576
9D0252F0  24423254   ADDIU V0, V0, 12884
9D0252F4  8C430014   LW V1, 20(V0)
9D0252F8  8FC2001C   LW V0, 28(S8)
9D0252FC  10620002   BEQ V1, V0, 0x9D025308
9D025300  00000000   NOP
1010:                			type = DHCP_UNKNOWN_MESSAGE;
9D025304  A3C0001A   SB ZERO, 26(S8)
1011:                	}
1012:                
1013:                	UDPDiscard();                             // We are done with this packet
9D025308  0F40A472   JAL UDPDiscard
9D02530C  00000000   NOP
1014:                	return type;
9D025310  93C2001A   LBU V0, 26(S8)
9D025314  0B4094DD   J 0x9D025374
9D025318  00000000   NOP
1015:                
1016:                UDPInvalid:
1017:                	UDPDiscard();
9D025368  0F40A472   JAL UDPDiscard
9D02536C  00000000   NOP
1018:                	return DHCP_UNKNOWN_MESSAGE;
9D025370  00001021   ADDU V0, ZERO, ZERO
1019:                }
9D025374  03C0E821   ADDU SP, S8, ZERO
9D025378  8FBF0024   LW RA, 36(SP)
9D02537C  8FBE0020   LW S8, 32(SP)
9D025380  27BD0028   ADDIU SP, SP, 40
9D025384  03E00008   JR RA
9D025388  00000000   NOP
1020:                
1021:                
1022:                
1023:                
1024:                /*****************************************************************************
1025:                  Function:
1026:                	static void _DHCPSend(BYTE messageType, BOOL bRenewing)
1027:                
1028:                  Description:
1029:                	Sends a DHCP message.
1030:                
1031:                  Precondition:
1032:                	UDP is ready to write a DHCP packet.
1033:                
1034:                  Parameters:
1035:                	messageType - One of the DHCP_TYPE constants
1036:                	bRenewing - Whether or not this is a renewal request
1037:                
1038:                  Returns:
1039:                	None
1040:                ***************************************************************************/
1041:                static void _DHCPSend(BYTE messageType, BOOL bRenewing)
1042:                {
9D02538C  27BDFFE0   ADDIU SP, SP, -32
9D025390  AFBF001C   SW RA, 28(SP)
9D025394  AFBE0018   SW S8, 24(SP)
9D025398  03A0F021   ADDU S8, SP, ZERO
9D02539C  00801021   ADDU V0, A0, ZERO
9D0253A0  AFC50024   SW A1, 36(S8)
9D0253A4  A3C20020   SB V0, 32(S8)
1043:                	BYTE i;
1044:                	IP_ADDR	MyIP;
1045:                
1046:                
1047:                	UDPPut(BOOT_REQUEST);                       // op
9D0253A8  24040001   ADDIU A0, ZERO, 1
9D0253AC  0F40A32A   JAL UDPPut
9D0253B0  00000000   NOP
1048:                	UDPPut(BOOT_HW_TYPE);                       // htype
9D0253B4  24040001   ADDIU A0, ZERO, 1
9D0253B8  0F40A32A   JAL UDPPut
9D0253BC  00000000   NOP
1049:                	UDPPut(BOOT_LEN_OF_HW_TYPE);                // hlen
9D0253C0  24040006   ADDIU A0, ZERO, 6
9D0253C4  0F40A32A   JAL UDPPut
9D0253C8  00000000   NOP
1050:                	UDPPut(0);                                  // hops
9D0253CC  00002021   ADDU A0, ZERO, ZERO
9D0253D0  0F40A32A   JAL UDPPut
9D0253D4  00000000   NOP
1051:                	UDPPut(0x12);                               // xid[0]
9D0253D8  24040012   ADDIU A0, ZERO, 18
9D0253DC  0F40A32A   JAL UDPPut
9D0253E0  00000000   NOP
1052:                	UDPPut(0x23);                               // xid[1]
9D0253E4  24040023   ADDIU A0, ZERO, 35
9D0253E8  0F40A32A   JAL UDPPut
9D0253EC  00000000   NOP
1053:                	UDPPut(0x34);                               // xid[2]
9D0253F0  24040034   ADDIU A0, ZERO, 52
9D0253F4  0F40A32A   JAL UDPPut
9D0253F8  00000000   NOP
1054:                	UDPPut(0x56);                               // xid[3]
9D0253FC  24040056   ADDIU A0, ZERO, 86
9D025400  0F40A32A   JAL UDPPut
9D025404  00000000   NOP
1055:                	UDPPut(0);                                  // secs[0]
9D025408  00002021   ADDU A0, ZERO, ZERO
9D02540C  0F40A32A   JAL UDPPut
9D025410  00000000   NOP
1056:                	UDPPut(0);                                  // secs[1]
9D025414  00002021   ADDU A0, ZERO, ZERO
9D025418  0F40A32A   JAL UDPPut
9D02541C  00000000   NOP
1057:                	UDPPut(DHCPClient.flags.bits.bUseUnicastMode ? 0x00: 0x80);// flags[0] with Broadcast flag clear/set to correspond to bUseUnicastMode
9D025420  3C02A000   LUI V0, -24576
9D025424  24423254   ADDIU V0, V0, 12884
9D025428  8C420008   LW V0, 8(V0)
9D02542C  30420010   ANDI V0, V0, 16
9D025430  10400004   BEQ V0, ZERO, 0x9D025444
9D025434  00000000   NOP
9D025438  00001021   ADDU V0, ZERO, ZERO
9D02543C  0B409512   J 0x9D025448
9D025440  00000000   NOP
9D025444  24020080   ADDIU V0, ZERO, 128
9D025448  00402021   ADDU A0, V0, ZERO
9D02544C  0F40A32A   JAL UDPPut
9D025450  00000000   NOP
1058:                	UDPPut(0);                                  // flags[1]
9D025454  00002021   ADDU A0, ZERO, ZERO
9D025458  0F40A32A   JAL UDPPut
9D02545C  00000000   NOP
1059:                
1060:                	// If this is DHCP REQUEST message, use previously allocated IP address.
1061:                	if((messageType == DHCP_REQUEST_MESSAGE) && bRenewing)
9D025460  93C30020   LBU V1, 32(S8)
9D025464  24020003   ADDIU V0, ZERO, 3
9D025468  1462000B   BNE V1, V0, 0x9D025498
9D02546C  00000000   NOP
9D025470  8FC20024   LW V0, 36(S8)
9D025474  10400008   BEQ V0, ZERO, 0x9D025498
9D025478  00000000   NOP
1062:                	{
1063:                		UDPPutArray((BYTE*)&DHCPClient.tempIPAddress, sizeof(DHCPClient.tempIPAddress));
9D02547C  3C02A000   LUI V0, -24576
9D025480  2444326C   ADDIU A0, V0, 12908
9D025484  24050004   ADDIU A1, ZERO, 4
9D025488  0F40A34D   JAL UDPPutArray
9D02548C  00000000   NOP
9D025490  0B409532   J 0x9D0254C8
9D025494  00000000   NOP
1064:                	}
1065:                	else
1066:                	{
1067:                		UDPPut(0x00);
9D025498  00002021   ADDU A0, ZERO, ZERO
9D02549C  0F40A32A   JAL UDPPut
9D0254A0  00000000   NOP
1068:                		UDPPut(0x00);
9D0254A4  00002021   ADDU A0, ZERO, ZERO
9D0254A8  0F40A32A   JAL UDPPut
9D0254AC  00000000   NOP
1069:                		UDPPut(0x00);
9D0254B0  00002021   ADDU A0, ZERO, ZERO
9D0254B4  0F40A32A   JAL UDPPut
9D0254B8  00000000   NOP
1070:                		UDPPut(0x00);
9D0254BC  00002021   ADDU A0, ZERO, ZERO
9D0254C0  0F40A32A   JAL UDPPut
9D0254C4  00000000   NOP
1071:                	}
1072:                
1073:                	// Set yiaddr, siaddr, giaddr as zeros,
1074:                	for ( i = 0; i < 12u; i++ )
9D0254C8  A3C00010   SB ZERO, 16(S8)
9D0254CC  0B40953B   J 0x9D0254EC
9D0254D0  00000000   NOP
9D0254E0  93C20010   LBU V0, 16(S8)
9D0254E4  24420001   ADDIU V0, V0, 1
9D0254E8  A3C20010   SB V0, 16(S8)
9D0254EC  93C20010   LBU V0, 16(S8)
9D0254F0  2C42000C   SLTIU V0, V0, 12
9D0254F4  1440FFF7   BNE V0, ZERO, 0x9D0254D4
9D0254F8  00000000   NOP
1075:                		UDPPut(0x00);
9D0254D4  00002021   ADDU A0, ZERO, ZERO
9D0254D8  0F40A32A   JAL UDPPut
9D0254DC  00000000   NOP
1076:                
1077:                	// Load chaddr - Client hardware address.
1078:                	UDPPutArray((BYTE*)&AppConfig.MyMACAddr, sizeof(AppConfig.MyMACAddr));
9D0254FC  3C02A000   LUI V0, -24576
9D025500  24440755   ADDIU A0, V0, 1877
9D025504  24050006   ADDIU A1, ZERO, 6
9D025508  0F40A34D   JAL UDPPutArray
9D02550C  00000000   NOP
1079:                
1080:                	// Set chaddr[6..15], sname and file as zeros.
1081:                	for ( i = 0; i < 202u; i++ )
9D025510  A3C00010   SB ZERO, 16(S8)
9D025514  0B40954D   J 0x9D025534
9D025518  00000000   NOP
9D025528  93C20010   LBU V0, 16(S8)
9D02552C  24420001   ADDIU V0, V0, 1
9D025530  A3C20010   SB V0, 16(S8)
9D025534  93C20010   LBU V0, 16(S8)
9D025538  2C4200CA   SLTIU V0, V0, 202
9D02553C  1440FFF7   BNE V0, ZERO, 0x9D02551C
9D025540  00000000   NOP
1082:                		UDPPut(0);
9D02551C  00002021   ADDU A0, ZERO, ZERO
9D025520  0F40A32A   JAL UDPPut
9D025524  00000000   NOP
1083:                
1084:                	// Load magic cookie as per RFC 1533.
1085:                	UDPPut(99);
9D025544  24040063   ADDIU A0, ZERO, 99
9D025548  0F40A32A   JAL UDPPut
9D02554C  00000000   NOP
1086:                	UDPPut(130);
9D025550  24040082   ADDIU A0, ZERO, 130
9D025554  0F40A32A   JAL UDPPut
9D025558  00000000   NOP
1087:                	UDPPut(83);
9D02555C  24040053   ADDIU A0, ZERO, 83
9D025560  0F40A32A   JAL UDPPut
9D025564  00000000   NOP
1088:                	UDPPut(99);
9D025568  24040063   ADDIU A0, ZERO, 99
9D02556C  0F40A32A   JAL UDPPut
9D025570  00000000   NOP
1089:                
1090:                	// Load message type.
1091:                	UDPPut(DHCP_MESSAGE_TYPE);
9D025574  24040035   ADDIU A0, ZERO, 53
9D025578  0F40A32A   JAL UDPPut
9D02557C  00000000   NOP
1092:                	UDPPut(DHCP_MESSAGE_TYPE_LEN);
9D025580  24040001   ADDIU A0, ZERO, 1
9D025584  0F40A32A   JAL UDPPut
9D025588  00000000   NOP
1093:                	UDPPut(messageType);
9D02558C  93C20020   LBU V0, 32(S8)
9D025590  00402021   ADDU A0, V0, ZERO
9D025594  0F40A32A   JAL UDPPut
9D025598  00000000   NOP
1094:                
1095:                	if(messageType == DHCP_DISCOVER_MESSAGE)
9D02559C  93C30020   LBU V1, 32(S8)
9D0255A0  24020001   ADDIU V0, ZERO, 1
9D0255A4  14620006   BNE V1, V0, 0x9D0255C0
9D0255A8  00000000   NOP
1096:                	{
1097:                		// Reset offered flag so we know to act upon the next valid offer
1098:                		DHCPClient.flags.bits.bOfferReceived = FALSE;
9D0255AC  3C02A000   LUI V0, -24576
9D0255B0  24433254   ADDIU V1, V0, 12884
9D0255B4  8C620008   LW V0, 8(V1)
9D0255B8  7C021084   INS V0, ZERO, 2, 1
9D0255BC  AC620008   SW V0, 8(V1)
1099:                	}
1100:                
1101:                
1102:                	if((messageType == DHCP_REQUEST_MESSAGE) && !bRenewing)
9D0255C0  93C30020   LBU V1, 32(S8)
9D0255C4  24020003   ADDIU V0, ZERO, 3
9D0255C8  14620025   BNE V1, V0, 0x9D025660
9D0255CC  00000000   NOP
9D0255D0  8FC20024   LW V0, 36(S8)
9D0255D4  14400022   BNE V0, ZERO, 0x9D025660
9D0255D8  00000000   NOP
1103:                	{
1104:                		// DHCP REQUEST message must include server identifier the first time
1105:                		// to identify the server we are talking to.
1106:                		// _DHCPReceive() would populate "serverID" when it
1107:                		// receives DHCP OFFER message. We will simply use that
1108:                		// when we are replying to server.
1109:                		// If this is a renwal request, we must not include server id.
1110:                		UDPPut(DHCP_SERVER_IDENTIFIER);
9D0255DC  24040036   ADDIU A0, ZERO, 54
9D0255E0  0F40A32A   JAL UDPPut
9D0255E4  00000000   NOP
1111:                		UDPPut(DHCP_SERVER_IDENTIFIER_LEN);
9D0255E8  24040004   ADDIU A0, ZERO, 4
9D0255EC  0F40A32A   JAL UDPPut
9D0255F0  00000000   NOP
1112:                		UDPPut(((BYTE*)(&DHCPClient.dwServerID))[3]);
9D0255F4  3C02A000   LUI V0, -24576
9D0255F8  24423268   ADDIU V0, V0, 12904
9D0255FC  24420003   ADDIU V0, V0, 3
9D025600  90420000   LBU V0, 0(V0)
9D025604  00402021   ADDU A0, V0, ZERO
9D025608  0F40A32A   JAL UDPPut
9D02560C  00000000   NOP
1113:                		UDPPut(((BYTE*)(&DHCPClient.dwServerID))[2]);
9D025610  3C02A000   LUI V0, -24576
9D025614  24423268   ADDIU V0, V0, 12904
9D025618  24420002   ADDIU V0, V0, 2
9D02561C  90420000   LBU V0, 0(V0)
9D025620  00402021   ADDU A0, V0, ZERO
9D025624  0F40A32A   JAL UDPPut
9D025628  00000000   NOP
1114:                		UDPPut(((BYTE*)(&DHCPClient.dwServerID))[1]);
9D02562C  3C02A000   LUI V0, -24576
9D025630  24423268   ADDIU V0, V0, 12904
9D025634  24420001   ADDIU V0, V0, 1
9D025638  90420000   LBU V0, 0(V0)
9D02563C  00402021   ADDU A0, V0, ZERO
9D025640  0F40A32A   JAL UDPPut
9D025644  00000000   NOP
1115:                		UDPPut(((BYTE*)(&DHCPClient.dwServerID))[0]);
9D025648  3C02A000   LUI V0, -24576
9D02564C  24423268   ADDIU V0, V0, 12904
9D025650  90420000   LBU V0, 0(V0)
9D025654  00402021   ADDU A0, V0, ZERO
9D025658  0F40A32A   JAL UDPPut
9D02565C  00000000   NOP
1116:                	}
1117:                
1118:                	// Load our interested parameters
1119:                	// This is hardcoded list.  If any new parameters are desired,
1120:                	// new lines must be added here.
1121:                	UDPPut(DHCP_PARAM_REQUEST_LIST);
9D025660  24040037   ADDIU A0, ZERO, 55
9D025664  0F40A32A   JAL UDPPut
9D025668  00000000   NOP
1122:                	UDPPut(DHCP_PARAM_REQUEST_LIST_LEN);
9D02566C  24040004   ADDIU A0, ZERO, 4
9D025670  0F40A32A   JAL UDPPut
9D025674  00000000   NOP
1123:                	UDPPut(DHCP_SUBNET_MASK);
9D025678  24040001   ADDIU A0, ZERO, 1
9D02567C  0F40A32A   JAL UDPPut
9D025680  00000000   NOP
1124:                	UDPPut(DHCP_ROUTER);
9D025684  24040003   ADDIU A0, ZERO, 3
9D025688  0F40A32A   JAL UDPPut
9D02568C  00000000   NOP
1125:                	UDPPut(DHCP_DNS);
9D025690  24040006   ADDIU A0, ZERO, 6
9D025694  0F40A32A   JAL UDPPut
9D025698  00000000   NOP
1126:                	UDPPut(DHCP_HOST_NAME);
9D02569C  2404000C   ADDIU A0, ZERO, 12
9D0256A0  0F40A32A   JAL UDPPut
9D0256A4  00000000   NOP
1127:                
1128:                	// Add requested IP address to DHCP Request Message
1129:                	if( ((messageType == DHCP_REQUEST_MESSAGE) && !bRenewing) || 
9D0256A8  93C30020   LBU V1, 32(S8)
9D0256AC  24020003   ADDIU V0, ZERO, 3
9D0256B0  14620004   BNE V1, V0, 0x9D0256C4
9D0256B4  00000000   NOP
9D0256B8  8FC20024   LW V0, 36(S8)
9D0256BC  1040000A   BEQ V0, ZERO, 0x9D0256E8
9D0256C0  00000000   NOP
9D0256C4  93C30020   LBU V1, 32(S8)
9D0256C8  24020001   ADDIU V0, ZERO, 1
9D0256CC  14620011   BNE V1, V0, 0x9D025714
9D0256D0  00000000   NOP
1130:                		((messageType == DHCP_DISCOVER_MESSAGE) && DHCPClient.tempIPAddress.Val))
9D0256D4  3C02A000   LUI V0, -24576
9D0256D8  24423254   ADDIU V0, V0, 12884
9D0256DC  8C420018   LW V0, 24(V0)
9D0256E0  1040000C   BEQ V0, ZERO, 0x9D025714
9D0256E4  00000000   NOP
1131:                	{
1132:                		UDPPut(DHCP_PARAM_REQUEST_IP_ADDRESS);
9D0256E8  24040032   ADDIU A0, ZERO, 50
9D0256EC  0F40A32A   JAL UDPPut
9D0256F0  00000000   NOP
1133:                		UDPPut(DHCP_PARAM_REQUEST_IP_ADDRESS_LEN);
9D0256F4  24040004   ADDIU A0, ZERO, 4
9D0256F8  0F40A32A   JAL UDPPut
9D0256FC  00000000   NOP
1134:                		UDPPutArray((BYTE*)&DHCPClient.tempIPAddress, DHCP_PARAM_REQUEST_IP_ADDRESS_LEN);
9D025700  3C02A000   LUI V0, -24576
9D025704  2444326C   ADDIU A0, V0, 12908
9D025708  24050004   ADDIU A1, ZERO, 4
9D02570C  0F40A34D   JAL UDPPutArray
9D025710  00000000   NOP
1135:                	}
1136:                
1137:                	// Add any new paramter request here.
1138:                
1139:                	// End of Options.
1140:                	UDPPut(DHCP_END_OPTION);
9D025714  240400FF   ADDIU A0, ZERO, 255
9D025718  0F40A32A   JAL UDPPut
9D02571C  00000000   NOP
1141:                
1142:                	// Add zero padding to ensure compatibility with old BOOTP relays that discard small packets (<300 UDP octets)
1143:                	while(UDPTxCount < 300u)
9D025720  0B4095CD   J 0x9D025734
9D025724  00000000   NOP
9D025734  978281EA   LHU V0, -32278(GP)
9D025738  2C42012C   SLTIU V0, V0, 300
9D02573C  1440FFFA   BNE V0, ZERO, 0x9D025728
9D025740  00000000   NOP
1144:                		UDPPut(0); 
9D025728  00002021   ADDU A0, ZERO, ZERO
9D02572C  0F40A32A   JAL UDPPut
9D025730  00000000   NOP
1145:                
1146:                	// Make sure we advertise a 0.0.0.0 IP address so all DHCP servers will respond.  If we have a static IP outside the DHCP server's scope, it may simply ignore discover messages.
1147:                	MyIP.Val = AppConfig.MyIPAddr.Val;
9D025744  3C02A000   LUI V0, -24576
9D025748  24430728   ADDIU V1, V0, 1832
9D02574C  88630003   LWL V1, 3(V1)
9D025750  00602021   ADDU A0, V1, ZERO
9D025754  98440728   LWR A0, 1832(V0)
9D025758  00801021   ADDU V0, A0, ZERO
9D02575C  AFC20014   SW V0, 20(S8)
1148:                	if(!bRenewing)
9D025760  8FC20024   LW V0, 36(S8)
9D025764  14400005   BNE V0, ZERO, 0x9D02577C
9D025768  00000000   NOP
1149:                		AppConfig.MyIPAddr.Val = 0x00000000;
9D02576C  3C02A000   LUI V0, -24576
9D025770  24430728   ADDIU V1, V0, 1832
9D025774  A8600003   SWL ZERO, 3(V1)
9D025778  B8400728   SWR ZERO, 1832(V0)
1150:                	UDPFlush();
9D02577C  0F40A38D   JAL UDPFlush
9D025780  00000000   NOP
1151:                	AppConfig.MyIPAddr.Val = MyIP.Val;
9D025784  8FC30014   LW V1, 20(S8)
9D025788  3C02A000   LUI V0, -24576
9D02578C  24440728   ADDIU A0, V0, 1832
9D025790  A8830003   SWL V1, 3(A0)
9D025794  B8430728   SWR V1, 1832(V0)
1152:                
1153:                }
9D025798  03C0E821   ADDU SP, S8, ZERO
9D02579C  8FBF001C   LW RA, 28(SP)
9D0257A0  8FBE0018   LW S8, 24(SP)
9D0257A4  27BD0020   ADDIU SP, SP, 32
9D0257A8  03E00008   JR RA
9D0257AC  00000000   NOP
1154:                
1155:                
1156:                #endif	//#if defined(STACK_USE_DHCP_CLIENT)
---  C:/Users/Diego/Documents/GitHub/pic32webFREERtos/Pic32Web.X/src/tcpip/src/BerkeleyAPI.c  -----------
1:                   /*********************************************************************
2:                    *
3:                    *     Berekely Socket Distribution API Source File
4:                    *
5:                    *********************************************************************
6:                    * FileName:        BerkeleyAPI.c
7:                    * Description:     Berkeley Socket Distribution(BSD) APIs for Microchip TCPIP Stack
8:                    * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32
9:                    * Compiler:        Microchip C32 v1.05 or higher
10:                   *					Microchip C30 v3.12 or higher
11:                   *					Microchip C18 v3.30 or higher
12:                   *					HI-TECH PICC-18 PRO 9.63PL2 or higher
13:                   * Company:         Microchip Technology, Inc.
14:                   *
15:                   * Software License Agreement
16:                   *
17:                   * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights
18:                   * reserved.
19:                   *
20:                   * Microchip licenses to you the right to use, modify, copy, and
21:                   * distribute:
22:                   * (i)  the Software when embedded on a Microchip microcontroller or
23:                   *      digital signal controller product ("Device") which is
24:                   *      integrated into Licensee's product; or
25:                   * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h,
26:                   *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device
27:                   *		used in conjunction with a Microchip ethernet controller for
28:                   *		the sole purpose of interfacing with the ethernet controller.
29:                   *
30:                   * You should refer to the license agreement accompanying this
31:                   * Software for additional information regarding your rights and
32:                   * obligations.
33:                   *
34:                   * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT
35:                   * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT
36:                   * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A
37:                   * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL
38:                   * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR
39:                   * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF
40:                   * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS
41:                   * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE
42:                   * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER
43:                   * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT
44:                   * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE.
45:                   *
46:                   * Author               Date    	Comment
47:                   *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
48:                   * Aseem Swalah         4/3/08  	Original
49:                   ********************************************************************/
50:                  
51:                  #include "TCPIPConfig.h"
52:                  
53:                  #if defined(STACK_USE_BERKELEY_API)
54:                  
55:                  #include "TCPIP Stack/TCPIP.h"
56:                  
57:                  static BOOL HandlePossibleTCPDisconnection(SOCKET s);
58:                  
59:                  
60:                  #if defined(__18CXX) && !defined(HI_TECH_C)	
61:                  	#pragma udata BSD_uRAM
62:                  #endif
63:                  // Array of BSDSocket elements; used to track all socket state and connection information.
64:                  static struct BSDSocket  BSDSocketArray[BSD_SOCKET_COUNT];
65:                  #if defined(__18CXX) && !defined(HI_TECH_C)	
66:                  	#pragma udata
67:                  #endif
68:                  
69:                  // Contains the next local port number to associate with a socket.
70:                  static WORD gAutoPortNumber = 1024;
71:                  
72:                  
73:                  /*****************************************************************************
74:                    Function:
75:                  	void BerkeleySocketInit(void)
76:                  
77:                    Summary:
78:                  	Initializes the Berkeley socket structure array.
79:                  
80:                    Description:
81:                  	This function initializes the Berkeley socket array. This function should
82:                  	be called before any BSD socket call.
83:                  
84:                    Precondition:
85:                  	None.
86:                  
87:                    Parameters:
88:                  	None.
89:                  
90:                    Returns:
91:                  	None
92:                  
93:                    Remarks:
94:                  	None.
95:                    ***************************************************************************/
96:                  void BerkeleySocketInit(void)
97:                  {
9D022754  27BDFFF0   ADDIU SP, SP, -16
9D022758  AFBE000C   SW S8, 12(SP)
9D02275C  03A0F021   ADDU S8, SP, ZERO
98:                  	unsigned int s;
99:                  	struct BSDSocket *socket;
100:                 
101:                 	for ( s = 0; s < BSD_SOCKET_COUNT; s++ )
9D022760  AFC00000   SW ZERO, 0(S8)
9D022764  0B4089EA   J 0x9D0227A8
9D022768  00000000   NOP
9D02279C  8FC20000   LW V0, 0(S8)
9D0227A0  24420001   ADDIU V0, V0, 1
9D0227A4  AFC20000   SW V0, 0(S8)
9D0227A8  8FC20000   LW V0, 0(S8)
9D0227AC  2C420005   SLTIU V0, V0, 5
9D0227B0  1440FFEE   BNE V0, ZERO, 0x9D02276C
9D0227B4  00000000   NOP
102:                 	{
103:                 		socket             = (struct BSDSocket *)&BSDSocketArray[s];
9D02276C  8FC30000   LW V1, 0(S8)
9D022770  2402001C   ADDIU V0, ZERO, 28
9D022774  70621802   MUL V1, V1, V0
9D022778  3C02A000   LUI V0, -24576
9D02277C  24423080   ADDIU V0, V0, 12416
9D022780  00621021   ADDU V0, V1, V0
9D022784  AFC20004   SW V0, 4(S8)
104:                 		socket->bsdState   = SKT_CLOSED;
9D022788  8FC20004   LW V0, 4(S8)
9D02278C  AC400004   SW ZERO, 4(V0)
105:                 		socket->SocketID = INVALID_UDP_SOCKET;
9D022790  8FC20004   LW V0, 4(S8)
9D022794  2403FFFF   ADDIU V1, ZERO, -1
9D022798  A0430018   SB V1, 24(V0)
106:                 	}
107:                 }
9D0227B8  03C0E821   ADDU SP, S8, ZERO
9D0227BC  8FBE000C   LW S8, 12(SP)
9D0227C0  27BD0010   ADDIU SP, SP, 16
9D0227C4  03E00008   JR RA
9D0227C8  00000000   NOP
108:                 
109:                 /*****************************************************************************
110:                   Function:
111:                 	SOCKET socket( int af, int type, int protocol )
112:                 
113:                   Summary:
114:                 	This function creates a new Berkeley socket.
115:                 
116:                   Description:
117:                 	This function creates a new BSD socket for the microchip
118:                 	TCPIP stack. The return socket descriptor is used for the subsequent
119:                 	BSD operations.
120:                 
121:                   Precondition:
122:                 	BerkeleySocketInit function should be called.
123:                 
124:                   Parameters:
125:                 	af - address family - AF_INET.
126:                 	type - socket type SOCK_DGRAM or SOCK_STREAM.
127:                 	protocol - IP protocol IPPROTO_UDP or IPPROTO_TCP.
128:                 
129:                   Returns:
130:                 	New socket descriptor. INVALID_SOCKET in case of error.
131:                 
132:                   Remarks:
133:                 	None.
134:                   ***************************************************************************/
135:                 SOCKET socket( int af, int type, int protocol )
136:                 {
9D0227CC  27BDFFF0   ADDIU SP, SP, -16
9D0227D0  AFBE000C   SW S8, 12(SP)
9D0227D4  03A0F021   ADDU S8, SP, ZERO
9D0227D8  AFC40010   SW A0, 16(S8)
9D0227DC  AFC50014   SW A1, 20(S8)
9D0227E0  AFC60018   SW A2, 24(S8)
137:                 	struct BSDSocket *socket = BSDSocketArray;
9D0227E4  3C02A000   LUI V0, -24576
9D0227E8  24423080   ADDIU V0, V0, 12416
9D0227EC  AFC20000   SW V0, 0(S8)
138:                 	SOCKET s;
139:                 
140:                 	if( af != AF_INET )
9D0227F0  8FC30010   LW V1, 16(S8)
9D0227F4  24020002   ADDIU V0, ZERO, 2
9D0227F8  10620004   BEQ V1, V0, 0x9D02280C
9D0227FC  00000000   NOP
141:                 		return INVALID_SOCKET;
9D022800  240200FE   ADDIU V0, ZERO, 254
9D022804  0B408A4C   J 0x9D022930
9D022808  00000000   NOP
142:                 
143:                 	if(protocol == IPPROTO_IP)		
9D02280C  8FC20018   LW V0, 24(S8)
9D022810  14400011   BNE V0, ZERO, 0x9D022858
9D022814  00000000   NOP
144:                 	{
145:                 		switch(type)
9D022818  8FC20014   LW V0, 20(S8)
9D02281C  24030064   ADDIU V1, ZERO, 100
9D022820  10430008   BEQ V0, V1, 0x9D022844
9D022824  00000000   NOP
9D022828  2403006E   ADDIU V1, ZERO, 110
9D02282C  14430009   BNE V0, V1, 0x9D022854
9D022830  00000000   NOP
146:                 		{
147:                 			case SOCK_DGRAM:
148:                 				protocol = IPPROTO_UDP;
9D022834  24020011   ADDIU V0, ZERO, 17
9D022838  AFC20018   SW V0, 24(S8)
149:                 			break;
9D02283C  0B408A16   J 0x9D022858
9D022840  00000000   NOP
150:                 
151:                 			case SOCK_STREAM:
152:                 				protocol = IPPROTO_TCP;
9D022844  24020006   ADDIU V0, ZERO, 6
9D022848  AFC20018   SW V0, 24(S8)
153:                 			break;
9D02284C  0B408A16   J 0x9D022858
9D022850  00000000   NOP
154:                 			
155:                 			default:
156:                 			break;
9D022854  00000000   NOP
157:                 		}
158:                 	}
159:                 
160:                 	for( s = 0; s < BSD_SOCKET_COUNT; s++,socket++ )
9D022858  A3C00004   SB ZERO, 4(S8)
9D02285C  0B408A47   J 0x9D02291C
9D022860  00000000   NOP
9D022874  93C20004   LBU V0, 4(S8)
9D022878  24420001   ADDIU V0, V0, 1
9D02287C  A3C20004   SB V0, 4(S8)
9D022880  8FC20000   LW V0, 0(S8)
9D022884  2442001C   ADDIU V0, V0, 28
9D022888  AFC20000   SW V0, 0(S8)
9D02288C  0B408A47   J 0x9D02291C
9D022890  00000000   NOP
9D02291C  93C20004   LBU V0, 4(S8)
9D022920  2C420005   SLTIU V0, V0, 5
9D022924  1440FFCF   BNE V0, ZERO, 0x9D022864
9D022928  00000000   NOP
161:                 	{
162:                 		if( socket->bsdState != SKT_CLOSED ) //socket in use
9D022864  8FC20000   LW V0, 0(S8)
9D022868  8C420004   LW V0, 4(V0)
9D02286C  10400009   BEQ V0, ZERO, 0x9D022894
9D022870  00000000   NOP
163:                 			continue;
164:                 
165:                 		socket->SocketType = type;
9D022894  8FC20000   LW V0, 0(S8)
9D022898  8FC30014   LW V1, 20(S8)
9D02289C  AC430000   SW V1, 0(V0)
166:                 
167:                 		if( type == SOCK_DGRAM && protocol == IPPROTO_UDP )
9D0228A0  8FC30014   LW V1, 20(S8)
9D0228A4  2402006E   ADDIU V0, ZERO, 110
9D0228A8  1462000B   BNE V1, V0, 0x9D0228D8
9D0228AC  00000000   NOP
9D0228B0  8FC30018   LW V1, 24(S8)
9D0228B4  24020011   ADDIU V0, ZERO, 17
9D0228B8  14620007   BNE V1, V0, 0x9D0228D8
9D0228BC  00000000   NOP
168:                 		{
169:                 			socket->bsdState = SKT_CREATED;
9D0228C0  8FC20000   LW V0, 0(S8)
9D0228C4  24030001   ADDIU V1, ZERO, 1
9D0228C8  AC430004   SW V1, 4(V0)
170:                 			return s;
9D0228CC  93C20004   LBU V0, 4(S8)
9D0228D0  0B408A4C   J 0x9D022930
9D0228D4  00000000   NOP
171:                 		}
172:                 		else if( type == SOCK_STREAM && protocol == IPPROTO_TCP )
9D0228D8  8FC30014   LW V1, 20(S8)
9D0228DC  24020064   ADDIU V0, ZERO, 100
9D0228E0  1462000B   BNE V1, V0, 0x9D022910
9D0228E4  00000000   NOP
9D0228E8  8FC30018   LW V1, 24(S8)
9D0228EC  24020006   ADDIU V0, ZERO, 6
9D0228F0  14620007   BNE V1, V0, 0x9D022910
9D0228F4  00000000   NOP
173:                 		{
174:                 			socket->bsdState = SKT_CREATED;
9D0228F8  8FC20000   LW V0, 0(S8)
9D0228FC  24030001   ADDIU V1, ZERO, 1
9D022900  AC430004   SW V1, 4(V0)
175:                 			return s;
9D022904  93C20004   LBU V0, 4(S8)
9D022908  0B408A4C   J 0x9D022930
9D02290C  00000000   NOP
176:                 		}
177:                 		else
178:                 			return INVALID_SOCKET;
9D022910  240200FE   ADDIU V0, ZERO, 254
9D022914  0B408A4C   J 0x9D022930
9D022918  00000000   NOP
179:                 	}
180:                 
181:                 	return INVALID_SOCKET;
9D02292C  240200FE   ADDIU V0, ZERO, 254
182:                 }
9D022930  03C0E821   ADDU SP, S8, ZERO
9D022934  8FBE000C   LW S8, 12(SP)
9D022938  27BD0010   ADDIU SP, SP, 16
9D02293C  03E00008   JR RA
9D022940  00000000   NOP
183:                 
184:                 /*****************************************************************************
185:                   Function:
186:                 	int bind( SOCKET s, const struct sockaddr* name, int namelen )
187:                 
188:                   Summary:
189:                 	This function assigns a name to the socket descriptor.
190:                 
191:                   Description:
192:                 	The bind function assigns a name to an unnamed socket. The
193:                     name represents the local address of the communication
194:                     endpoint. For sockets of type SOCK_STREAM, the name of the
195:                     remote endpoint is assigned when a connect or accept function
196:                     is executed.
197:                 
198:                   Precondition:
199:                 	socket function should be called.
200:                 
201:                   Parameters:
202:                 	s - Socket descriptor returned from a previous call to socket.
203:                 	name - pointer to the sockaddr structure containing the
204:                 	local address of the socket.
205:                 	namelen - length of the sockaddr structure.
206:                 
207:                   Returns:
208:                 	If bind is successful, a value of 0 is returned. A return
209:                     value of SOCKET_ERROR indicates an error.
210:                 
211:                   Remarks:
212:                 	None.
213:                   ***************************************************************************/
214:                 int bind( SOCKET s, const struct sockaddr* name, int namelen )
215:                 {
9D022944  27BDFFD8   ADDIU SP, SP, -40
9D022948  AFBF0024   SW RA, 36(SP)
9D02294C  AFBE0020   SW S8, 32(SP)
9D022950  03A0F021   ADDU S8, SP, ZERO
9D022954  00801021   ADDU V0, A0, ZERO
9D022958  AFC5002C   SW A1, 44(S8)
9D02295C  AFC60030   SW A2, 48(S8)
9D022960  A3C20028   SB V0, 40(S8)
216:                 	struct BSDSocket *socket;
217:                 	struct sockaddr_in *local_addr;
218:                 	WORD lPort;
219:                 
220:                 	if( s >= BSD_SOCKET_COUNT )
9D022964  93C20028   LBU V0, 40(S8)
9D022968  2C420005   SLTIU V0, V0, 5
9D02296C  14400004   BNE V0, ZERO, 0x9D022980
9D022970  00000000   NOP
221:                 		return SOCKET_ERROR;
9D022974  2402FFFF   ADDIU V0, ZERO, -1
9D022978  0B408AAA   J 0x9D022AA8
9D02297C  00000000   NOP
222:                 
223:                 	socket = &BSDSocketArray[s];
9D022980  93C30028   LBU V1, 40(S8)
9D022984  2402001C   ADDIU V0, ZERO, 28
9D022988  70621802   MUL V1, V1, V0
9D02298C  3C02A000   LUI V0, -24576
9D022990  24423080   ADDIU V0, V0, 12416
9D022994  00621021   ADDU V0, V1, V0
9D022998  AFC20014   SW V0, 20(S8)
224:                 
225:                 	if( socket->bsdState != SKT_CREATED ) //only work with recently created socket
9D02299C  8FC20014   LW V0, 20(S8)
9D0229A0  8C430004   LW V1, 4(V0)
9D0229A4  24020001   ADDIU V0, ZERO, 1
9D0229A8  10620004   BEQ V1, V0, 0x9D0229BC
9D0229AC  00000000   NOP
226:                 		return SOCKET_ERROR;
9D0229B0  2402FFFF   ADDIU V0, ZERO, -1
9D0229B4  0B408AAA   J 0x9D022AA8
9D0229B8  00000000   NOP
227:                 
228:                 	if( (unsigned int)namelen < sizeof(struct sockaddr_in) )
9D0229BC  8FC20030   LW V0, 48(S8)
9D0229C0  2C420010   SLTIU V0, V0, 16
9D0229C4  10400004   BEQ V0, ZERO, 0x9D0229D8
9D0229C8  00000000   NOP
229:                 		return SOCKET_ERROR;
9D0229CC  2402FFFF   ADDIU V0, ZERO, -1
9D0229D0  0B408AAA   J 0x9D022AA8
9D0229D4  00000000   NOP
230:                 
231:                 	local_addr = (struct sockaddr_in *)name;
9D0229D8  8FC2002C   LW V0, 44(S8)
9D0229DC  AFC20018   SW V0, 24(S8)
232:                 
233:                 	lPort = local_addr->sin_port;
9D0229E0  8FC20018   LW V0, 24(S8)
9D0229E4  90430002   LBU V1, 2(V0)
9D0229E8  90420003   LBU V0, 3(V0)
9D0229EC  00021200   SLL V0, V0, 8
9D0229F0  00431025   OR V0, V0, V1
9D0229F4  A7C20010   SH V0, 16(S8)
234:                     if( lPort == 0u ) //pick a port
9D0229F8  97C20010   LHU V0, 16(S8)
9D0229FC  1440000C   BNE V0, ZERO, 0x9D022A30
9D022A00  00000000   NOP
235:                 	{
236:                 		lPort = gAutoPortNumber++;
9D022A04  97828010   LHU V0, -32752(GP)
9D022A08  A7C20010   SH V0, 16(S8)
9D022A0C  24420001   ADDIU V0, V0, 1
9D022A10  3042FFFF   ANDI V0, V0, -1
9D022A14  A7828010   SH V0, -32752(GP)
237:                         if(gAutoPortNumber > 5000u) // reset the port numbers
9D022A18  97828010   LHU V0, -32752(GP)
9D022A1C  2C421389   SLTIU V0, V0, 5001
9D022A20  14400003   BNE V0, ZERO, 0x9D022A30
9D022A24  00000000   NOP
238:                 			gAutoPortNumber = 1024;
9D022A28  24020400   ADDIU V0, ZERO, 1024
9D022A2C  A7828010   SH V0, -32752(GP)
239:                 	}
240:                 
241:                 	if(socket->SocketType == SOCK_DGRAM)
9D022A30  8FC20014   LW V0, 20(S8)
9D022A34  8C430000   LW V1, 0(V0)
9D022A38  2402006E   ADDIU V0, ZERO, 110
9D022A3C  14620013   BNE V1, V0, 0x9D022A8C
9D022A40  00000000   NOP
242:                 	{
243:                 		socket->SocketID = UDPOpenEx(0,UDP_OPEN_SERVER,lPort, 0);
9D022A44  97C20010   LHU V0, 16(S8)
9D022A48  00002021   ADDU A0, ZERO, ZERO
9D022A4C  00002821   ADDU A1, ZERO, ZERO
9D022A50  00403021   ADDU A2, V0, ZERO
9D022A54  00003821   ADDU A3, ZERO, ZERO
9D022A58  0F40A0DD   JAL UDPOpenEx
9D022A5C  00000000   NOP
9D022A60  00401821   ADDU V1, V0, ZERO
9D022A64  8FC20014   LW V0, 20(S8)
9D022A68  A0430018   SB V1, 24(V0)
244:                 		if(socket->SocketID == INVALID_UDP_SOCKET)
9D022A6C  8FC20014   LW V0, 20(S8)
9D022A70  90430018   LBU V1, 24(V0)
9D022A74  240200FF   ADDIU V0, ZERO, 255
9D022A78  14620004   BNE V1, V0, 0x9D022A8C
9D022A7C  00000000   NOP
245:                 			return SOCKET_ERROR;
9D022A80  2402FFFF   ADDIU V0, ZERO, -1
9D022A84  0B408AAA   J 0x9D022AA8
9D022A88  00000000   NOP
246:                 	}
247:                 
248:                 	socket->localPort = lPort;
9D022A8C  8FC20014   LW V0, 20(S8)
9D022A90  97C30010   LHU V1, 16(S8)
9D022A94  A4430008   SH V1, 8(V0)
249:                 	socket->bsdState  = SKT_BOUND;
9D022A98  8FC20014   LW V0, 20(S8)
9D022A9C  24030002   ADDIU V1, ZERO, 2
9D022AA0  AC430004   SW V1, 4(V0)
250:                 	return 0; //success
9D022AA4  00001021   ADDU V0, ZERO, ZERO
251:                 }
9D022AA8  03C0E821   ADDU SP, S8, ZERO
9D022AAC  8FBF0024   LW RA, 36(SP)
9D022AB0  8FBE0020   LW S8, 32(SP)
9D022AB4  27BD0028   ADDIU SP, SP, 40
9D022AB8  03E00008   JR RA
9D022ABC  00000000   NOP
252:                 
253:                 /*****************************************************************************
254:                   Function:
255:                 	int listen( SOCKET s, int backlog )
256:                 
257:                   Summary:
258:                 	The listen function sets the specified socket in a listen mode
259:                 
260:                   Description:
261:                 	This function sets the specified socket in a listen
262:                 	mode. Calling the listen function indicates that the
263:                 	application is ready to accept connection requests arriving
264:                 	at a socket of type SOCK_STREAM. The connection request is
265:                 	queued (if possible) until accepted with an accept function.
266:                 	The backlog parameter defines the maximum number of pending
267:                 	connections that may be queued.
268:                 
269:                   Precondition:
270:                 	bind() must have been called on the s socket first.
271:                 
272:                   Parameters:
273:                 	s - Socket identifier returned from a prior socket() call.
274:                 	backlog - Maximum number of connection requests that can be queued.  Note 
275:                 		that each backlog requires a TCP_PURPOSE_BERKELEY_SERVER type TCP 
276:                 		socket to be allocated in the TCPSocketInitializer[] in TCPIPConfig.h.
277:                 		Also, ensure that BSD_SOCKET_COUNT (also in TCPIPConfig.h) is greater 
278:                 		than the backlog by at least 1 (more if you have other BSD sockets in 
279:                 		use).
280:                 	
281:                   Returns:
282:                 	Returns 0 on success, else return SOCKET_ERROR.
283:                 
284:                   Remarks:
285:                 	None
286:                   ***************************************************************************/
287:                 int listen( SOCKET s, int backlog )
288:                 {
9D022AC0  27BDFFD8   ADDIU SP, SP, -40
9D022AC4  AFBF0024   SW RA, 36(SP)
9D022AC8  AFBE0020   SW S8, 32(SP)
9D022ACC  03A0F021   ADDU S8, SP, ZERO
9D022AD0  00801021   ADDU V0, A0, ZERO
9D022AD4  AFC5002C   SW A1, 44(S8)
9D022AD8  A3C20028   SB V0, 40(S8)
289:                 	struct BSDSocket *ps;
290:                 	SOCKET clientSockID;
291:                 	unsigned int socketcount;
292:                 	unsigned char assigned;
293:                 
294:                 	if( s >= BSD_SOCKET_COUNT )
9D022ADC  93C20028   LBU V0, 40(S8)
9D022AE0  2C420005   SLTIU V0, V0, 5
9D022AE4  14400004   BNE V0, ZERO, 0x9D022AF8
9D022AE8  00000000   NOP
295:                 		return SOCKET_ERROR;
9D022AEC  2402FFFF   ADDIU V0, ZERO, -1
9D022AF0  0B408B52   J 0x9D022D48
9D022AF4  00000000   NOP
296:                 
297:                 	ps = &BSDSocketArray[s];
9D022AF8  93C30028   LBU V1, 40(S8)
9D022AFC  2402001C   ADDIU V0, ZERO, 28
9D022B00  70621802   MUL V1, V1, V0
9D022B04  3C02A000   LUI V0, -24576
9D022B08  24423080   ADDIU V0, V0, 12416
9D022B0C  00621021   ADDU V0, V1, V0
9D022B10  AFC20018   SW V0, 24(S8)
298:                 
299:                 	if(ps->SocketType != SOCK_STREAM)
9D022B14  8FC20018   LW V0, 24(S8)
9D022B18  8C430000   LW V1, 0(V0)
9D022B1C  24020064   ADDIU V0, ZERO, 100
9D022B20  10620004   BEQ V1, V0, 0x9D022B34
9D022B24  00000000   NOP
300:                 		return SOCKET_ERROR;
9D022B28  2402FFFF   ADDIU V0, ZERO, -1
9D022B2C  0B408B52   J 0x9D022D48
9D022B30  00000000   NOP
301:                 
302:                 	if(ps->bsdState == SKT_BSD_LISTEN)
9D022B34  8FC20018   LW V0, 24(S8)
9D022B38  8C430004   LW V1, 4(V0)
9D022B3C  24020003   ADDIU V0, ZERO, 3
9D022B40  14620004   BNE V1, V0, 0x9D022B54
9D022B44  00000000   NOP
303:                 		backlog = ps->backlog;
9D022B48  8FC20018   LW V0, 24(S8)
9D022B4C  8C420010   LW V0, 16(V0)
9D022B50  AFC2002C   SW V0, 44(S8)
304:                 
305:                 	if((ps->bsdState != SKT_BOUND) && (ps->bsdState != SKT_BSD_LISTEN))
9D022B54  8FC20018   LW V0, 24(S8)
9D022B58  8C430004   LW V1, 4(V0)
9D022B5C  24020002   ADDIU V0, ZERO, 2
9D022B60  1062006C   BEQ V1, V0, 0x9D022D14
9D022B64  00000000   NOP
9D022B68  8FC20018   LW V0, 24(S8)
9D022B6C  8C430004   LW V1, 4(V0)
9D022B70  24020003   ADDIU V0, ZERO, 3
9D022B74  1062006A   BEQ V1, V0, 0x9D022D20
9D022B78  00000000   NOP
306:                 		return SOCKET_ERROR;
9D022B7C  2402FFFF   ADDIU V0, ZERO, -1
9D022B80  0B408B52   J 0x9D022D48
9D022B84  00000000   NOP
307:                 
308:                 	while(backlog--)
9D022D14  00000000   NOP
9D022D18  0B408B49   J 0x9D022D24
9D022D1C  00000000   NOP
9D022D20  00000000   NOP
9D022D24  8FC2002C   LW V0, 44(S8)
9D022D28  0002102B   SLTU V0, ZERO, V0
9D022D2C  304200FF   ANDI V0, V0, 255
9D022D30  8FC3002C   LW V1, 44(S8)
9D022D34  2463FFFF   ADDIU V1, V1, -1
9D022D38  AFC3002C   SW V1, 44(S8)
9D022D3C  1440FF92   BNE V0, ZERO, 0x9D022B88
9D022D40  00000000   NOP
309:                 	{
310:                 		assigned = 0;
9D022B88  A3C00014   SB ZERO, 20(S8)
311:                 		for(socketcount = 0; socketcount < BSD_SOCKET_COUNT; socketcount++)
9D022B8C  AFC00010   SW ZERO, 16(S8)
9D022B90  0B408B3B   J 0x9D022CEC
9D022B94  00000000   NOP
9D022BBC  8FC20010   LW V0, 16(S8)
9D022BC0  24420001   ADDIU V0, V0, 1
9D022BC4  AFC20010   SW V0, 16(S8)
9D022BC8  0B408B3B   J 0x9D022CEC
9D022BCC  00000000   NOP
9D022CEC  8FC20010   LW V0, 16(S8)
9D022CF0  2C420005   SLTIU V0, V0, 5
9D022CF4  1440FFA8   BNE V0, ZERO, 0x9D022B98
9D022CF8  00000000   NOP
312:                 		{
313:                 			if(BSDSocketArray[socketcount].bsdState != SKT_CLOSED)
9D022B98  3C02A000   LUI V0, -24576
9D022B9C  8FC40010   LW A0, 16(S8)
9D022BA0  24433080   ADDIU V1, V0, 12416
9D022BA4  2402001C   ADDIU V0, ZERO, 28
9D022BA8  70821002   MUL V0, A0, V0
9D022BAC  00621021   ADDU V0, V1, V0
9D022BB0  8C420004   LW V0, 4(V0)
9D022BB4  10400006   BEQ V0, ZERO, 0x9D022BD0
9D022BB8  00000000   NOP
314:                 				continue;
315:                 
316:                 			clientSockID = TCPOpen(0, TCP_OPEN_SERVER, ps->localPort, TCP_PURPOSE_BERKELEY_SERVER);
9D022BD0  8FC20018   LW V0, 24(S8)
9D022BD4  94420008   LHU V0, 8(V0)
9D022BD8  00002021   ADDU A0, ZERO, ZERO
9D022BDC  00002821   ADDU A1, ZERO, ZERO
9D022BE0  00403021   ADDU A2, V0, ZERO
9D022BE4  2407000A   ADDIU A3, ZERO, 10
9D022BE8  0F400109   JAL TCPOpen
9D022BEC  00000000   NOP
9D022BF0  A3C2001C   SB V0, 28(S8)
317:                 			if(clientSockID == INVALID_SOCKET)
9D022BF4  93C3001C   LBU V1, 28(S8)
9D022BF8  240200FE   ADDIU V0, ZERO, 254
9D022BFC  14620004   BNE V1, V0, 0x9D022C10
9D022C00  00000000   NOP
318:                 				return SOCKET_ERROR;
9D022C04  2402FFFF   ADDIU V0, ZERO, -1
9D022C08  0B408B52   J 0x9D022D48
9D022C0C  00000000   NOP
319:                 				
320:                 			// Clear the first reset flag
321:                 			TCPWasReset(clientSockID);
9D022C10  93C2001C   LBU V0, 28(S8)
9D022C14  00402021   ADDU A0, V0, ZERO
9D022C18  0F400229   JAL TCPWasReset
9D022C1C  00000000   NOP
322:                 
323:                 			assigned = 1;
9D022C20  24020001   ADDIU V0, ZERO, 1
9D022C24  A3C20014   SB V0, 20(S8)
324:                 			ps->bsdState = SKT_BSD_LISTEN;
9D022C28  8FC20018   LW V0, 24(S8)
9D022C2C  24030003   ADDIU V1, ZERO, 3
9D022C30  AC430004   SW V1, 4(V0)
325:                 			ps->backlog = backlog;
9D022C34  8FC20018   LW V0, 24(S8)
9D022C38  8FC3002C   LW V1, 44(S8)
9D022C3C  AC430010   SW V1, 16(V0)
326:                 
327:                 			BSDSocketArray[socketcount].SocketID = clientSockID;
9D022C40  3C02A000   LUI V0, -24576
9D022C44  8FC40010   LW A0, 16(S8)
9D022C48  2403001C   ADDIU V1, ZERO, 28
9D022C4C  70831802   MUL V1, A0, V1
9D022C50  24423080   ADDIU V0, V0, 12416
9D022C54  00621021   ADDU V0, V1, V0
9D022C58  93C3001C   LBU V1, 28(S8)
9D022C5C  A0430018   SB V1, 24(V0)
328:                 			BSDSocketArray[socketcount].bsdState = SKT_LISTEN;
9D022C60  3C02A000   LUI V0, -24576
9D022C64  8FC40010   LW A0, 16(S8)
9D022C68  24433080   ADDIU V1, V0, 12416
9D022C6C  2402001C   ADDIU V0, ZERO, 28
9D022C70  70821002   MUL V0, A0, V0
9D022C74  00621021   ADDU V0, V1, V0
9D022C78  24030004   ADDIU V1, ZERO, 4
9D022C7C  AC430004   SW V1, 4(V0)
329:                 			BSDSocketArray[socketcount].isServer = TRUE;
9D022C80  3C02A000   LUI V0, -24576
9D022C84  8FC40010   LW A0, 16(S8)
9D022C88  24433080   ADDIU V1, V0, 12416
9D022C8C  2402001C   ADDIU V0, ZERO, 28
9D022C90  70821002   MUL V0, A0, V0
9D022C94  00621021   ADDU V0, V1, V0
9D022C98  24030001   ADDIU V1, ZERO, 1
9D022C9C  AC430014   SW V1, 20(V0)
330:                 			BSDSocketArray[socketcount].localPort = ps->localPort;
9D022CA0  8FC20018   LW V0, 24(S8)
9D022CA4  94430008   LHU V1, 8(V0)
9D022CA8  3C02A000   LUI V0, -24576
9D022CAC  8FC50010   LW A1, 16(S8)
9D022CB0  2404001C   ADDIU A0, ZERO, 28
9D022CB4  70A42002   MUL A0, A1, A0
9D022CB8  24423080   ADDIU V0, V0, 12416
9D022CBC  00821021   ADDU V0, A0, V0
9D022CC0  A4430008   SH V1, 8(V0)
331:                 			BSDSocketArray[socketcount].SocketType = SOCK_STREAM;
9D022CC4  3C02A000   LUI V0, -24576
9D022CC8  8FC40010   LW A0, 16(S8)
9D022CCC  2403001C   ADDIU V1, ZERO, 28
9D022CD0  70831802   MUL V1, A0, V1
9D022CD4  24423080   ADDIU V0, V0, 12416
9D022CD8  00621021   ADDU V0, V1, V0
9D022CDC  24030064   ADDIU V1, ZERO, 100
9D022CE0  AC430000   SW V1, 0(V0)
332:                 			break;
9D022CE4  0B408B3F   J 0x9D022CFC
9D022CE8  00000000   NOP
333:                 		}
334:                 		if(!assigned)
9D022CFC  93C20014   LBU V0, 20(S8)
9D022D00  14400008   BNE V0, ZERO, 0x9D022D24
9D022D04  00000000   NOP
335:                 			return SOCKET_ERROR;
9D022D08  2402FFFF   ADDIU V0, ZERO, -1
9D022D0C  0B408B52   J 0x9D022D48
9D022D10  00000000   NOP
336:                 	}
337:                 	return 0; //Success
9D022D44  00001021   ADDU V0, ZERO, ZERO
338:                 }
9D022D48  03C0E821   ADDU SP, S8, ZERO
9D022D4C  8FBF0024   LW RA, 36(SP)
9D022D50  8FBE0020   LW S8, 32(SP)
9D022D54  27BD0028   ADDIU SP, SP, 40
9D022D58  03E00008   JR RA
9D022D5C  00000000   NOP
339:                 
340:                 
341:                 /*****************************************************************************
342:                   Function:
343:                 	SOCKET accept(SOCKET s, struct sockaddr* addr, int* addrlen)
344:                 
345:                   Summary:
346:                 	This function accepts connection requests queued for a listening socket.
347:                 
348:                   Description:
349:                 	The accept function is used to accept connection requests
350:                 	queued for a listening socket. If a connection request is
351:                 	pending, accept removes the request from the queue, and a new
352:                 	socket is created for the connection. The original listening
353:                 	socket remains open and continues to queue new connection
354:                 	requests. The socket must be a SOCK_STREAM type socket.
355:                 
356:                   Precondition:
357:                 	listen function should be called.
358:                 
359:                   Parameters:
360:                 	s - Socket descriptor returned from a previous call to
361:                 	socket. must be bound to a local name and in listening mode.
362:                 	addr - Optional pointer to a buffer that receives the address
363:                 	of the connecting entity.
364:                 	addrlen - Optional pointer to an integer that contains the
365:                 	length of the address addr
366:                 
367:                   Returns:
368:                 	If the accept function succeeds, it returns a non-negative
369:                 	integer that is a descriptor for the accepted socket.
370:                 	Otherwise, the value INVALID_SOCKET is returned.
371:                 
372:                   Remarks:
373:                 	None.
374:                   ***************************************************************************/
375:                 SOCKET accept(SOCKET s, struct sockaddr* addr, int* addrlen)
376:                 {
9D022D60  27BDFFD0   ADDIU SP, SP, -48
9D022D64  AFBF002C   SW RA, 44(SP)
9D022D68  AFBE0028   SW S8, 40(SP)
9D022D6C  03A0F021   ADDU S8, SP, ZERO
9D022D70  00801021   ADDU V0, A0, ZERO
9D022D74  AFC50034   SW A1, 52(S8)
9D022D78  AFC60038   SW A2, 56(S8)
9D022D7C  A3C20030   SB V0, 48(S8)
377:                 	struct BSDSocket *pListenSock;
378:                 	SOCKET_INFO *remoteSockInfo;
379:                 	struct sockaddr_in *addrRemote;
380:                 	unsigned int sockCount;
381:                 	TCP_SOCKET hTCP;
382:                 
383:                 	if( s >= BSD_SOCKET_COUNT )
9D022D80  93C20030   LBU V0, 48(S8)
9D022D84  2C420005   SLTIU V0, V0, 5
9D022D88  14400004   BNE V0, ZERO, 0x9D022D9C
9D022D8C  00000000   NOP
384:                 		return INVALID_SOCKET;
9D022D90  240200FE   ADDIU V0, ZERO, 254
9D022D94  0B408BFF   J 0x9D022FFC
9D022D98  00000000   NOP
385:                 
386:                 	pListenSock = &BSDSocketArray[s]; /* Get the pointer to listening server socket */
9D022D9C  93C30030   LBU V1, 48(S8)
9D022DA0  2402001C   ADDIU V0, ZERO, 28
9D022DA4  70621802   MUL V1, V1, V0
9D022DA8  3C02A000   LUI V0, -24576
9D022DAC  24423080   ADDIU V0, V0, 12416
9D022DB0  00621021   ADDU V0, V1, V0
9D022DB4  AFC20014   SW V0, 20(S8)
387:                 
388:                 	if ( pListenSock->bsdState != SKT_BSD_LISTEN )
9D022DB8  8FC20014   LW V0, 20(S8)
9D022DBC  8C430004   LW V1, 4(V0)
9D022DC0  24020003   ADDIU V0, ZERO, 3
9D022DC4  10620004   BEQ V1, V0, 0x9D022DD8
9D022DC8  00000000   NOP
389:                 		return INVALID_SOCKET;
9D022DCC  240200FE   ADDIU V0, ZERO, 254
9D022DD0  0B408BFF   J 0x9D022FFC
9D022DD4  00000000   NOP
390:                 	if ( pListenSock->SocketType != SOCK_STREAM )
9D022DD8  8FC20014   LW V0, 20(S8)
9D022DDC  8C430000   LW V1, 0(V0)
9D022DE0  24020064   ADDIU V0, ZERO, 100
9D022DE4  10620004   BEQ V1, V0, 0x9D022DF8
9D022DE8  00000000   NOP
391:                 		return INVALID_SOCKET;
9D022DEC  240200FE   ADDIU V0, ZERO, 254
9D022DF0  0B408BFF   J 0x9D022FFC
9D022DF4  00000000   NOP
392:                 
393:                 	for(sockCount = 0; sockCount < BSD_SOCKET_COUNT; sockCount++)
9D022DF8  AFC00010   SW ZERO, 16(S8)
9D022DFC  0B408BFA   J 0x9D022FE8
9D022E00  00000000   NOP
9D022FDC  8FC20010   LW V0, 16(S8)
9D022FE0  24420001   ADDIU V0, V0, 1
9D022FE4  AFC20010   SW V0, 16(S8)
9D022FE8  8FC20010   LW V0, 16(S8)
9D022FEC  2C420005   SLTIU V0, V0, 5
9D022FF0  1440FF84   BNE V0, ZERO, 0x9D022E04
9D022FF4  00000000   NOP
394:                 	{
395:                 		if(BSDSocketArray[sockCount].bsdState != SKT_LISTEN)
9D022E04  3C02A000   LUI V0, -24576
9D022E08  8FC40010   LW A0, 16(S8)
9D022E0C  24433080   ADDIU V1, V0, 12416
9D022E10  2402001C   ADDIU V0, ZERO, 28
9D022E14  70821002   MUL V0, A0, V0
9D022E18  00621021   ADDU V0, V1, V0
9D022E1C  8C430004   LW V1, 4(V0)
9D022E20  24020004   ADDIU V0, ZERO, 4
9D022E24  14620069   BNE V1, V0, 0x9D022FCC
9D022E28  00000000   NOP
396:                 			continue;
9D022FCC  00000000   NOP
9D022FD0  0B408BF7   J 0x9D022FDC
9D022FD4  00000000   NOP
397:                 
398:                 		if(BSDSocketArray[sockCount].localPort != pListenSock->localPort)
9D022E2C  3C02A000   LUI V0, -24576
9D022E30  8FC40010   LW A0, 16(S8)
9D022E34  2403001C   ADDIU V1, ZERO, 28
9D022E38  70831802   MUL V1, A0, V1
9D022E3C  24423080   ADDIU V0, V0, 12416
9D022E40  00621021   ADDU V0, V1, V0
9D022E44  94430008   LHU V1, 8(V0)
9D022E48  8FC20014   LW V0, 20(S8)
9D022E4C  94420008   LHU V0, 8(V0)
9D022E50  14620061   BNE V1, V0, 0x9D022FD8
9D022E54  00000000   NOP
399:                 			continue;
9D022FD8  00000000   NOP
400:                 
401:                 		hTCP = BSDSocketArray[sockCount].SocketID;
9D022E58  3C02A000   LUI V0, -24576
9D022E5C  8FC40010   LW A0, 16(S8)
9D022E60  2403001C   ADDIU V1, ZERO, 28
9D022E64  70831802   MUL V1, A0, V1
9D022E68  24423080   ADDIU V0, V0, 12416
9D022E6C  00621021   ADDU V0, V1, V0
9D022E70  90420018   LBU V0, 24(V0)
9D022E74  A3C20018   SB V0, 24(S8)
402:                 		
403:                 		// We don't care about connections and disconnections before we can 
404:                 		// process them, so clear the reset flag
405:                 		TCPWasReset(hTCP);	
9D022E78  93C20018   LBU V0, 24(S8)
9D022E7C  00402021   ADDU A0, V0, ZERO
9D022E80  0F400229   JAL TCPWasReset
9D022E84  00000000   NOP
406:                 		
407:                 		if(TCPIsConnected(hTCP))
9D022E88  93C20018   LBU V0, 24(S8)
9D022E8C  00402021   ADDU A0, V0, ZERO
9D022E90  0F400256   JAL TCPIsConnected
9D022E94  00000000   NOP
9D022E98  10400050   BEQ V0, ZERO, 0x9D022FDC
9D022E9C  00000000   NOP
408:                 		{
409:                 			remoteSockInfo = TCPGetRemoteInfo(hTCP);
9D022EA0  93C20018   LBU V0, 24(S8)
9D022EA4  00402021   ADDU A0, V0, ZERO
9D022EA8  0F400340   JAL TCPGetRemoteInfo
9D022EAC  00000000   NOP
9D022EB0  AFC2001C   SW V0, 28(S8)
410:                 			if(addr)
9D022EB4  8FC20034   LW V0, 52(S8)
9D022EB8  10400025   BEQ V0, ZERO, 0x9D022F50
9D022EBC  00000000   NOP
411:                 			{
412:                 				if(addrlen)
9D022EC0  8FC20038   LW V0, 56(S8)
9D022EC4  10400022   BEQ V0, ZERO, 0x9D022F50
9D022EC8  00000000   NOP
413:                 				{
414:                 					if((unsigned int)*addrlen < sizeof(struct sockaddr_in))
9D022ECC  8FC20038   LW V0, 56(S8)
9D022ED0  8C420000   LW V0, 0(V0)
9D022ED4  2C420010   SLTIU V0, V0, 16
9D022ED8  10400004   BEQ V0, ZERO, 0x9D022EEC
9D022EDC  00000000   NOP
415:                 						return INVALID_SOCKET;
9D022EE0  240200FE   ADDIU V0, ZERO, 254
9D022EE4  0B408BFF   J 0x9D022FFC
9D022EE8  00000000   NOP
416:                 					addrRemote = (struct sockaddr_in *)addr;
9D022EEC  8FC20034   LW V0, 52(S8)
9D022EF0  AFC20020   SW V0, 32(S8)
417:                 					addrRemote->sin_addr.S_un.S_addr = remoteSockInfo->remote.IPAddr.Val;
9D022EF4  8FC2001C   LW V0, 28(S8)
9D022EF8  88430003   LWL V1, 3(V0)
9D022EFC  98430000   LWR V1, 0(V0)
9D022F00  8FC20020   LW V0, 32(S8)
9D022F04  A8430007   SWL V1, 7(V0)
9D022F08  B8430004   SWR V1, 4(V0)
418:                 					addrRemote->sin_port = remoteSockInfo->remotePort.Val;
9D022F0C  8FC2001C   LW V0, 28(S8)
9D022F10  9443000A   LHU V1, 10(V0)
9D022F14  8FC20020   LW V0, 32(S8)
9D022F18  306400FF   ANDI A0, V1, 255
9D022F1C  90450002   LBU A1, 2(V0)
9D022F20  30A50000   ANDI A1, A1, 0
9D022F24  00A42025   OR A0, A1, A0
9D022F28  A0440002   SB A0, 2(V0)
9D022F2C  00031A02   SRL V1, V1, 8
9D022F30  3063FFFF   ANDI V1, V1, -1
9D022F34  90440003   LBU A0, 3(V0)
9D022F38  30840000   ANDI A0, A0, 0
9D022F3C  00831825   OR V1, A0, V1
9D022F40  A0430003   SB V1, 3(V0)
419:                 					*addrlen = sizeof(struct sockaddr_in);
9D022F44  8FC20038   LW V0, 56(S8)
9D022F48  24030010   ADDIU V1, ZERO, 16
9D022F4C  AC430000   SW V1, 0(V0)
420:                 				}
421:                 			}
422:                 			BSDSocketArray[sockCount].remotePort = remoteSockInfo->remotePort.Val;
9D022F50  8FC2001C   LW V0, 28(S8)
9D022F54  9443000A   LHU V1, 10(V0)
9D022F58  3C02A000   LUI V0, -24576
9D022F5C  8FC50010   LW A1, 16(S8)
9D022F60  2404001C   ADDIU A0, ZERO, 28
9D022F64  70A42002   MUL A0, A1, A0
9D022F68  24423080   ADDIU V0, V0, 12416
9D022F6C  00821021   ADDU V0, A0, V0
9D022F70  A443000A   SH V1, 10(V0)
423:                 			BSDSocketArray[sockCount].remoteIP   = remoteSockInfo->remote.IPAddr.Val;
9D022F74  8FC2001C   LW V0, 28(S8)
9D022F78  88430003   LWL V1, 3(V0)
9D022F7C  98430000   LWR V1, 0(V0)
9D022F80  3C02A000   LUI V0, -24576
9D022F84  8FC50010   LW A1, 16(S8)
9D022F88  24443080   ADDIU A0, V0, 12416
9D022F8C  2402001C   ADDIU V0, ZERO, 28
9D022F90  70A21002   MUL V0, A1, V0
9D022F94  00821021   ADDU V0, A0, V0
9D022F98  AC43000C   SW V1, 12(V0)
424:                 			BSDSocketArray[sockCount].bsdState = SKT_EST;
9D022F9C  3C02A000   LUI V0, -24576
9D022FA0  8FC40010   LW A0, 16(S8)
9D022FA4  24433080   ADDIU V1, V0, 12416
9D022FA8  2402001C   ADDIU V0, ZERO, 28
9D022FAC  70821002   MUL V0, A0, V0
9D022FB0  00621021   ADDU V0, V1, V0
9D022FB4  24030006   ADDIU V1, ZERO, 6
9D022FB8  AC430004   SW V1, 4(V0)
425:                 			return sockCount;
9D022FBC  8FC20010   LW V0, 16(S8)
9D022FC0  304200FF   ANDI V0, V0, 255
9D022FC4  0B408BFF   J 0x9D022FFC
9D022FC8  00000000   NOP
426:                 		}
427:                 	}
428:                 
429:                 	return INVALID_SOCKET;
9D022FF8  240200FE   ADDIU V0, ZERO, 254
430:                 }
9D022FFC  03C0E821   ADDU SP, S8, ZERO
9D023000  8FBF002C   LW RA, 44(SP)
9D023004  8FBE0028   LW S8, 40(SP)
9D023008  27BD0030   ADDIU SP, SP, 48
9D02300C  03E00008   JR RA
9D023010  00000000   NOP
431:                 
432:                 /*****************************************************************************
433:                   Function:
434:                 	int connect( SOCKET s, struct sockaddr* name, int namelen )
435:                 
436:                   Summary:
437:                 	This function connects to the peer communications end point.
438:                 
439:                   Description:
440:                 	The connect function assigns the address of the peer
441:                 	communications endpoint. For stream sockets, connection is
442:                 	established between the endpoints. For datagram sockets, an
443:                 	address filter is established between the endpoints until
444:                 	changed with another connect() function.
445:                 
446:                   Precondition:
447:                 	socket function should be called.
448:                 
449:                   Parameters:
450:                 	s - Socket descriptor returned from a previous call to socket.
451:                 	name - pointer to the sockaddr structure containing the
452:                 	peer address and port number.
453:                 	namelen - length of the sockaddr structure.
454:                 
455:                   Returns:
456:                 	If the connect() function succeeds, it returns 0. Otherwise,
457:                 	the value SOCKET_ERROR is returned to indicate an error
458:                 	condition. For stream based socket, if the connection is not
459:                 	established yet, connect returns SOCKET_CNXN_IN_PROGRESS.
460:                 
461:                   Remarks:
462:                 	None.
463:                   ***************************************************************************/
464:                 int connect( SOCKET s, struct sockaddr* name, int namelen )
465:                 {
9D023014  27BDFFD0   ADDIU SP, SP, -48
9D023018  AFBF002C   SW RA, 44(SP)
9D02301C  AFBE0028   SW S8, 40(SP)
9D023020  03A0F021   ADDU S8, SP, ZERO
9D023024  00801021   ADDU V0, A0, ZERO
9D023028  AFC50034   SW A1, 52(S8)
9D02302C  AFC60038   SW A2, 56(S8)
9D023030  A3C20030   SB V0, 48(S8)
466:                 	struct BSDSocket *socket;
467:                 	struct sockaddr_in *addr;
468:                 	DWORD remoteIP;
469:                 	WORD remotePort;
470:                 	WORD localPort;
471:                 
472:                 	if( s >= BSD_SOCKET_COUNT )
9D023034  93C20030   LBU V0, 48(S8)
9D023038  2C420005   SLTIU V0, V0, 5
9D02303C  14400004   BNE V0, ZERO, 0x9D023050
9D023040  00000000   NOP
473:                 		return SOCKET_ERROR;
9D023044  2402FFFF   ADDIU V0, ZERO, -1
9D023048  0B408CC9   J 0x9D023324
9D02304C  00000000   NOP
474:                 
475:                 	socket = &BSDSocketArray[s];
9D023050  93C30030   LBU V1, 48(S8)
9D023054  2402001C   ADDIU V0, ZERO, 28
9D023058  70621802   MUL V1, V1, V0
9D02305C  3C02A000   LUI V0, -24576
9D023060  24423080   ADDIU V0, V0, 12416
9D023064  00621021   ADDU V0, V1, V0
9D023068  AFC20010   SW V0, 16(S8)
476:                 
477:                 	if( socket->bsdState < SKT_CREATED )
9D02306C  8FC20010   LW V0, 16(S8)
9D023070  8C420004   LW V0, 4(V0)
9D023074  14400004   BNE V0, ZERO, 0x9D023088
9D023078  00000000   NOP
478:                 		return SOCKET_ERROR;
9D02307C  2402FFFF   ADDIU V0, ZERO, -1
9D023080  0B408CC9   J 0x9D023324
9D023084  00000000   NOP
479:                 
480:                 	if( (unsigned int)namelen < sizeof(struct sockaddr_in))
9D023088  8FC20038   LW V0, 56(S8)
9D02308C  2C420010   SLTIU V0, V0, 16
9D023090  10400004   BEQ V0, ZERO, 0x9D0230A4
9D023094  00000000   NOP
481:                 		return SOCKET_ERROR;
9D023098  2402FFFF   ADDIU V0, ZERO, -1
9D02309C  0B408CC9   J 0x9D023324
9D0230A0  00000000   NOP
482:                 
483:                 	addr = (struct sockaddr_in *)name;
9D0230A4  8FC20034   LW V0, 52(S8)
9D0230A8  AFC20014   SW V0, 20(S8)
484:                 	remotePort 	= addr->sin_port;
9D0230AC  8FC20014   LW V0, 20(S8)
9D0230B0  90430002   LBU V1, 2(V0)
9D0230B4  90420003   LBU V0, 3(V0)
9D0230B8  00021200   SLL V0, V0, 8
9D0230BC  00431025   OR V0, V0, V1
9D0230C0  A7C20018   SH V0, 24(S8)
485:                 	remoteIP 	= addr->sin_addr.S_un.S_addr;
9D0230C4  8FC20014   LW V0, 20(S8)
9D0230C8  88430007   LWL V1, 7(V0)
9D0230CC  00602021   ADDU A0, V1, ZERO
9D0230D0  98440004   LWR A0, 4(V0)
9D0230D4  00801021   ADDU V0, A0, ZERO
9D0230D8  AFC2001C   SW V0, 28(S8)
486:                 
487:                 	if( remoteIP == 0u || remotePort == 0u )
9D0230DC  8FC2001C   LW V0, 28(S8)
9D0230E0  10400004   BEQ V0, ZERO, 0x9D0230F4
9D0230E4  00000000   NOP
9D0230E8  97C20018   LHU V0, 24(S8)
9D0230EC  14400004   BNE V0, ZERO, 0x9D023100
9D0230F0  00000000   NOP
488:                 		return SOCKET_ERROR;
9D0230F4  2402FFFF   ADDIU V0, ZERO, -1
9D0230F8  0B408CC9   J 0x9D023324
9D0230FC  00000000   NOP
489:                 
490:                 	if( socket->SocketType == SOCK_STREAM )
9D023100  8FC20010   LW V0, 16(S8)
9D023104  8C430000   LW V1, 0(V0)
9D023108  24020064   ADDIU V0, ZERO, 100
9D02310C  14620050   BNE V1, V0, 0x9D023250
9D023110  00000000   NOP
491:                 	{
492:                 		switch(socket->bsdState)
9D023114  8FC20010   LW V0, 16(S8)
9D023118  8C420004   LW V0, 4(V0)
9D02311C  24030005   ADDIU V1, ZERO, 5
9D023120  10430010   BEQ V0, V1, 0x9D023164
9D023124  00000000   NOP
9D023128  2C430006   SLTIU V1, V0, 6
9D02312C  10600007   BEQ V1, ZERO, 0x9D02314C
9D023130  00000000   NOP
9D023134  2442FFFF   ADDIU V0, V0, -1
9D023138  2C420002   SLTIU V0, V0, 2
9D02313C  10400041   BEQ V0, ZERO, 0x9D023244
9D023140  00000000   NOP
9D023144  0B408C72   J 0x9D0231C8
9D023148  00000000   NOP
9D02314C  24030006   ADDIU V1, ZERO, 6
9D023150  1443003C   BNE V0, V1, 0x9D023244
9D023154  00000000   NOP
493:                 		{
494:                 		case SKT_EST:
495:                 			return 0; // already established
9D023158  00001021   ADDU V0, ZERO, ZERO
9D02315C  0B408CC9   J 0x9D023324
9D023160  00000000   NOP
496:                 
497:                 		case SKT_IN_PROGRESS:
498:                 			if(HandlePossibleTCPDisconnection(s))
9D023164  93C20030   LBU V0, 48(S8)
9D023168  00402021   ADDU A0, V0, ZERO
9D02316C  0F408FB5   JAL 0x9D023ED4
9D023170  00000000   NOP
9D023174  10400004   BEQ V0, ZERO, 0x9D023188
9D023178  00000000   NOP
499:                 				return SOCKET_ERROR;
9D02317C  2402FFFF   ADDIU V0, ZERO, -1
9D023180  0B408CC9   J 0x9D023324
9D023184  00000000   NOP
500:                 
501:                 			if(!TCPIsConnected(socket->SocketID))
9D023188  8FC20010   LW V0, 16(S8)
9D02318C  90420018   LBU V0, 24(V0)
9D023190  00402021   ADDU A0, V0, ZERO
9D023194  0F400256   JAL TCPIsConnected
9D023198  00000000   NOP
9D02319C  14400004   BNE V0, ZERO, 0x9D0231B0
9D0231A0  00000000   NOP
502:                 				return SOCKET_CNXN_IN_PROGRESS;
9D0231A4  2402FFFE   ADDIU V0, ZERO, -2
9D0231A8  0B408CC9   J 0x9D023324
9D0231AC  00000000   NOP
503:                 
504:                 			socket->bsdState = SKT_EST;
9D0231B0  8FC20010   LW V0, 16(S8)
9D0231B4  24030006   ADDIU V1, ZERO, 6
9D0231B8  AC430004   SW V1, 4(V0)
505:                 			return 0; //success
9D0231BC  00001021   ADDU V0, ZERO, ZERO
9D0231C0  0B408CC9   J 0x9D023324
9D0231C4  00000000   NOP
506:                 
507:                 		case SKT_CREATED:
508:                 		case SKT_BOUND:
509:                 			socket->SocketID = TCPOpen(remoteIP, TCP_OPEN_IP_ADDRESS, remotePort, TCP_PURPOSE_BERKELEY_CLIENT);
9D0231C8  97C20018   LHU V0, 24(S8)
9D0231CC  8FC4001C   LW A0, 28(S8)
9D0231D0  24050003   ADDIU A1, ZERO, 3
9D0231D4  00403021   ADDU A2, V0, ZERO
9D0231D8  2407000B   ADDIU A3, ZERO, 11
9D0231DC  0F400109   JAL TCPOpen
9D0231E0  00000000   NOP
9D0231E4  00401821   ADDU V1, V0, ZERO
9D0231E8  8FC20010   LW V0, 16(S8)
9D0231EC  A0430018   SB V1, 24(V0)
510:                 			if(socket->SocketID == INVALID_SOCKET)
9D0231F0  8FC20010   LW V0, 16(S8)
9D0231F4  90430018   LBU V1, 24(V0)
9D0231F8  240200FE   ADDIU V0, ZERO, 254
9D0231FC  14620004   BNE V1, V0, 0x9D023210
9D023200  00000000   NOP
511:                 				return SOCKET_ERROR;
9D023204  2402FFFF   ADDIU V0, ZERO, -1
9D023208  0B408CC9   J 0x9D023324
9D02320C  00000000   NOP
512:                 
513:                 			// Clear the first reset flag
514:                 			TCPWasReset(socket->SocketID);
9D023210  8FC20010   LW V0, 16(S8)
9D023214  90420018   LBU V0, 24(V0)
9D023218  00402021   ADDU A0, V0, ZERO
9D02321C  0F400229   JAL TCPWasReset
9D023220  00000000   NOP
515:                 
516:                 			socket->isServer = FALSE;
9D023224  8FC20010   LW V0, 16(S8)
9D023228  AC400014   SW ZERO, 20(V0)
517:                 			socket->bsdState = SKT_IN_PROGRESS;
9D02322C  8FC20010   LW V0, 16(S8)
9D023230  24030005   ADDIU V1, ZERO, 5
9D023234  AC430004   SW V1, 4(V0)
518:                 			return SOCKET_CNXN_IN_PROGRESS;
9D023238  2402FFFE   ADDIU V0, ZERO, -2
9D02323C  0B408CC9   J 0x9D023324
9D023240  00000000   NOP
519:                 
520:                 		default:
521:                 			return SOCKET_ERROR;
9D023244  2402FFFF   ADDIU V0, ZERO, -1
9D023248  0B408CC9   J 0x9D023324
9D02324C  00000000   NOP
522:                 		}
523:                 	}
524:                 	else
525:                 	{
526:                 		// If not explicitly bound to a local port, implicitly do the binding
527:                 		if(socket->bsdState == SKT_CREATED)
9D023250  8FC20010   LW V0, 16(S8)
9D023254  8C430004   LW V1, 4(V0)
9D023258  24020001   ADDIU V0, ZERO, 1
9D02325C  14620022   BNE V1, V0, 0x9D0232E8
9D023260  00000000   NOP
528:                 		{
529:                 			localPort = gAutoPortNumber++;
9D023264  97828010   LHU V0, -32752(GP)
9D023268  A7C20020   SH V0, 32(S8)
9D02326C  24420001   ADDIU V0, V0, 1
9D023270  3042FFFF   ANDI V0, V0, -1
9D023274  A7828010   SH V0, -32752(GP)
530:                 	        if(gAutoPortNumber > 5000u) // reset the port numbers
9D023278  97828010   LHU V0, -32752(GP)
9D02327C  2C421389   SLTIU V0, V0, 5001
9D023280  14400003   BNE V0, ZERO, 0x9D023290
9D023284  00000000   NOP
531:                 				gAutoPortNumber = 1024;
9D023288  24020400   ADDIU V0, ZERO, 1024
9D02328C  A7828010   SH V0, -32752(GP)
532:                 
533:                 			socket->SocketID = UDPOpenEx(0,UDP_OPEN_SERVER,localPort, remotePort);
9D023290  97C30020   LHU V1, 32(S8)
9D023294  97C20018   LHU V0, 24(S8)
9D023298  00002021   ADDU A0, ZERO, ZERO
9D02329C  00002821   ADDU A1, ZERO, ZERO
9D0232A0  00603021   ADDU A2, V1, ZERO
9D0232A4  00403821   ADDU A3, V0, ZERO
9D0232A8  0F40A0DD   JAL UDPOpenEx
9D0232AC  00000000   NOP
9D0232B0  00401821   ADDU V1, V0, ZERO
9D0232B4  8FC20010   LW V0, 16(S8)
9D0232B8  A0430018   SB V1, 24(V0)
534:                 			if(socket->SocketID == INVALID_UDP_SOCKET)
9D0232BC  8FC20010   LW V0, 16(S8)
9D0232C0  90430018   LBU V1, 24(V0)
9D0232C4  240200FF   ADDIU V0, ZERO, 255
9D0232C8  14620004   BNE V1, V0, 0x9D0232DC
9D0232CC  00000000   NOP
535:                 				return SOCKET_ERROR;
9D0232D0  2402FFFF   ADDIU V0, ZERO, -1
9D0232D4  0B408CC9   J 0x9D023324
9D0232D8  00000000   NOP
536:                 			socket->bsdState = SKT_BOUND;
9D0232DC  8FC20010   LW V0, 16(S8)
9D0232E0  24030002   ADDIU V1, ZERO, 2
9D0232E4  AC430004   SW V1, 4(V0)
537:                 		}
538:                 		if(socket->bsdState != SKT_BOUND)
9D0232E8  8FC20010   LW V0, 16(S8)
9D0232EC  8C430004   LW V1, 4(V0)
9D0232F0  24020002   ADDIU V0, ZERO, 2
9D0232F4  10620004   BEQ V1, V0, 0x9D023308
9D0232F8  00000000   NOP
539:                 			return SOCKET_ERROR;
9D0232FC  2402FFFF   ADDIU V0, ZERO, -1
9D023300  0B408CC9   J 0x9D023324
9D023304  00000000   NOP
540:                 
541:                 		// UDP: remote port is used as a filter. Need to call connect when using
542:                 		// send/recv calls. No need to call 'connect' if using sendto/recvfrom 
543:                 		// calls.
544:                 		socket->remotePort = remotePort;
9D023308  8FC20010   LW V0, 16(S8)
9D02330C  97C30018   LHU V1, 24(S8)
9D023310  A443000A   SH V1, 10(V0)
545:                 		socket->remoteIP = remoteIP;
9D023314  8FC20010   LW V0, 16(S8)
9D023318  8FC3001C   LW V1, 28(S8)
9D02331C  AC43000C   SW V1, 12(V0)
546:                 		return 0; //success
9D023320  00001021   ADDU V0, ZERO, ZERO
547:                 	}
548:                 	return SOCKET_ERROR;
549:                 }
9D023324  03C0E821   ADDU SP, S8, ZERO
9D023328  8FBF002C   LW RA, 44(SP)
9D02332C  8FBE0028   LW S8, 40(SP)
9D023330  27BD0030   ADDIU SP, SP, 48
9D023334  03E00008   JR RA
9D023338  00000000   NOP
550:                 
551:                 /*****************************************************************************
552:                   Function:
553:                 	int send( SOCKET s, const char* buf, int len, int flags )
554:                 	
555:                   Summary:
556:                 	The send function is used to send outgoing data on an already
557:                 	connected socket.
558:                 
559:                   Description:
560:                 	The send function is used to send outgoing data on an already
561:                 	connected socket. This function is used to send a reliable,
562:                 	ordered stream of data bytes on a socket of type SOCK_STREAM
563:                 	but can also be used to send datagrams on a socket of type SOCK_DGRAM.
564:                 
565:                   Precondition:
566:                 	connect function should be called for TCP and UDP sockets.
567:                 	Server side, accept function should be called.
568:                 
569:                   Parameters:
570:                 	s - Socket descriptor returned from a previous call to socket.
571:                 	buf - application data buffer containing data to transmit.
572:                 	len - length of data in bytes.
573:                 	flags - message flags. Currently this field is not supported.
574:                 
575:                   Returns:
576:                 	On success, send returns number of bytes sent. In case of
577:                 	error, returns SOCKET_ERROR. a zero indicates no data send.
578:                 
579:                   Remarks:
580:                 	None.
581:                   ***************************************************************************/
582:                 int send( SOCKET s, const char* buf, int len, int flags )
583:                 {
9D02333C  27BDFFE0   ADDIU SP, SP, -32
9D023340  AFBF001C   SW RA, 28(SP)
9D023344  AFBE0018   SW S8, 24(SP)
9D023348  03A0F021   ADDU S8, SP, ZERO
9D02334C  00801021   ADDU V0, A0, ZERO
9D023350  AFC50024   SW A1, 36(S8)
9D023354  AFC60028   SW A2, 40(S8)
9D023358  AFC7002C   SW A3, 44(S8)
9D02335C  A3C20020   SB V0, 32(S8)
584:                 	return sendto(s, buf, len, flags, NULL, 0);
9D023360  93C20020   LBU V0, 32(S8)
9D023364  AFA00010   SW ZERO, 16(SP)
9D023368  AFA00014   SW ZERO, 20(SP)
9D02336C  00402021   ADDU A0, V0, ZERO
9D023370  8FC50024   LW A1, 36(S8)
9D023374  8FC60028   LW A2, 40(S8)
9D023378  8FC7002C   LW A3, 44(S8)
9D02337C  0F408CE7   JAL sendto
9D023380  00000000   NOP
585:                 }
9D023384  03C0E821   ADDU SP, S8, ZERO
9D023388  8FBF001C   LW RA, 28(SP)
9D02338C  8FBE0018   LW S8, 24(SP)
9D023390  27BD0020   ADDIU SP, SP, 32
9D023394  03E00008   JR RA
9D023398  00000000   NOP
586:                 
587:                 /*****************************************************************************
588:                   Function:
589:                 	int sendto(SOCKET s, const char* buf, int len, int flags, const struct sockaddr* to, int tolen)
590:                 
591:                   Summary:
592:                 	This function used to send the data for both connection oriented and connection-less
593:                 	sockets.
594:                 
595:                   Description:
596:                 	The sendto function is used to send outgoing data on a socket.
597:                 	The destination address is given by to and tolen. Both 
598:                 	Datagram and stream sockets are supported.
599:                 
600:                   Precondition:
601:                 	socket function should be called.
602:                 
603:                   Parameters:
604:                 	s - Socket descriptor returned from a previous call to socket.
605:                 	buf - application data buffer containing data to transmit.
606:                 	len - length of data in bytes.
607:                 	flags - message flags. Currently this field is not supported.
608:                 	to - Optional pointer to the the sockaddr structure containing the
609:                 		destination address.  If NULL, the currently bound remote port and IP 
610:                 		address are used as the destination.
611:                 	tolen - length of the sockaddr structure.
612:                 
613:                   Returns:
614:                 	On success, sendto returns number of bytes sent. In case of
615:                 	error returns SOCKET_ERROR
616:                 
617:                   Remarks:
618:                 	None.
619:                   ***************************************************************************/
620:                 int sendto( SOCKET s, const char* buf, int len, int flags, const struct sockaddr* to, int tolen )
621:                 {
9D02339C  27BDFFC0   ADDIU SP, SP, -64
9D0233A0  AFBF003C   SW RA, 60(SP)
9D0233A4  AFBE0038   SW S8, 56(SP)
9D0233A8  03A0F021   ADDU S8, SP, ZERO
9D0233AC  00801021   ADDU V0, A0, ZERO
9D0233B0  AFC50044   SW A1, 68(S8)
9D0233B4  AFC60048   SW A2, 72(S8)
9D0233B8  AFC7004C   SW A3, 76(S8)
9D0233BC  A3C20040   SB V0, 64(S8)
622:                 	struct BSDSocket *socket;
623:                 	int size = SOCKET_ERROR;
9D0233C0  2402FFFF   ADDIU V0, ZERO, -1
9D0233C4  AFC20014   SW V0, 20(S8)
624:                 	NODE_INFO remoteInfo;
625:                 	static DWORD startTick;		// NOTE: startTick really should be a per socket BSDSocket structure member since other BSD calls can interfere with the ARP cycles
626:                 	WORD wRemotePort;
627:                 	struct sockaddr_in local;
628:                 
629:                 	if( s >= BSD_SOCKET_COUNT )
9D0233C8  93C20040   LBU V0, 64(S8)
9D0233CC  2C420005   SLTIU V0, V0, 5
9D0233D0  14400004   BNE V0, ZERO, 0x9D0233E4
9D0233D4  00000000   NOP
630:                 		return SOCKET_ERROR;
9D0233D8  2402FFFF   ADDIU V0, ZERO, -1
9D0233DC  0B408DCB   J 0x9D02372C
9D0233E0  00000000   NOP
631:                 
632:                 	socket = &BSDSocketArray[s];
9D0233E4  93C30040   LBU V1, 64(S8)
9D0233E8  2402001C   ADDIU V0, ZERO, 28
9D0233EC  70621802   MUL V1, V1, V0
9D0233F0  3C02A000   LUI V0, -24576
9D0233F4  24423080   ADDIU V0, V0, 12416
9D0233F8  00621021   ADDU V0, V1, V0
9D0233FC  AFC20018   SW V0, 24(S8)
633:                 
634:                 	if(socket->bsdState == SKT_CLOSED)
9D023400  8FC20018   LW V0, 24(S8)
9D023404  8C420004   LW V0, 4(V0)
9D023408  14400004   BNE V0, ZERO, 0x9D02341C
9D02340C  00000000   NOP
635:                 		return SOCKET_ERROR;
9D023410  2402FFFF   ADDIU V0, ZERO, -1
9D023414  0B408DCB   J 0x9D02372C
9D023418  00000000   NOP
636:                 
637:                 	if(socket->SocketType == SOCK_DGRAM) //UDP
9D02341C  8FC20018   LW V0, 24(S8)
9D023420  8C430000   LW V1, 0(V0)
9D023424  2402006E   ADDIU V0, ZERO, 110
9D023428  14620092   BNE V1, V0, 0x9D023674
9D02342C  00000000   NOP
638:                 	{
639:                 		// Decide the destination IP address and port
640:                 		remoteInfo.IPAddr.Val = socket->remoteIP;
9D023430  8FC20018   LW V0, 24(S8)
9D023434  8C42000C   LW V0, 12(V0)
9D023438  AFC2001C   SW V0, 28(S8)
641:                 		wRemotePort = socket->remotePort;
9D02343C  8FC20018   LW V0, 24(S8)
9D023440  9442000A   LHU V0, 10(V0)
9D023444  A7C20010   SH V0, 16(S8)
642:                 		if(to)
9D023448  8FC20050   LW V0, 80(S8)
9D02344C  1040002D   BEQ V0, ZERO, 0x9D023504
9D023450  00000000   NOP
643:                 		{
644:                 			if((unsigned int)tolen != sizeof(struct sockaddr_in))
9D023454  8FC30054   LW V1, 84(S8)
9D023458  24020010   ADDIU V0, ZERO, 16
9D02345C  10620004   BEQ V1, V0, 0x9D023470
9D023460  00000000   NOP
645:                 				return SOCKET_ERROR;
9D023464  2402FFFF   ADDIU V0, ZERO, -1
9D023468  0B408DCB   J 0x9D02372C
9D02346C  00000000   NOP
646:                 			wRemotePort = ((struct sockaddr_in*)to)->sin_port;
9D023470  8FC20050   LW V0, 80(S8)
9D023474  90430002   LBU V1, 2(V0)
9D023478  90420003   LBU V0, 3(V0)
9D02347C  00021200   SLL V0, V0, 8
9D023480  00431025   OR V0, V0, V1
9D023484  A7C20010   SH V0, 16(S8)
647:                 			remoteInfo.IPAddr.Val = ((struct sockaddr_in*)to)->sin_addr.s_addr;
9D023488  8FC20050   LW V0, 80(S8)
9D02348C  88430007   LWL V1, 7(V0)
9D023490  00602021   ADDU A0, V1, ZERO
9D023494  98440004   LWR A0, 4(V0)
9D023498  00801021   ADDU V0, A0, ZERO
9D02349C  AFC2001C   SW V0, 28(S8)
648:                 			
649:                 			// Implicitly bind the socket if it isn't already
650:                 			if(socket->bsdState == SKT_CREATED)
9D0234A0  8FC20018   LW V0, 24(S8)
9D0234A4  8C430004   LW V1, 4(V0)
9D0234A8  24020001   ADDIU V0, ZERO, 1
9D0234AC  14620015   BNE V1, V0, 0x9D023504
9D0234B0  00000000   NOP
651:                 			{
652:                 				memset(&local, 0x00, sizeof(local));
9D0234B4  27C20028   ADDIU V0, S8, 40
9D0234B8  00402021   ADDU A0, V0, ZERO
9D0234BC  00002821   ADDU A1, ZERO, ZERO
9D0234C0  24060010   ADDIU A2, ZERO, 16
9D0234C4  0F40D5EC   JAL 0x9D0357B0
9D0234C8  00000000   NOP
653:                 				if(bind(s, (struct sockaddr*)&local, sizeof(local)) == SOCKET_ERROR)
9D0234CC  93C30040   LBU V1, 64(S8)
9D0234D0  27C20028   ADDIU V0, S8, 40
9D0234D4  00602021   ADDU A0, V1, ZERO
9D0234D8  00402821   ADDU A1, V0, ZERO
9D0234DC  24060010   ADDIU A2, ZERO, 16
9D0234E0  0F408A51   JAL bind
9D0234E4  00000000   NOP
9D0234E8  00401821   ADDU V1, V0, ZERO
9D0234EC  2402FFFF   ADDIU V0, ZERO, -1
9D0234F0  14620004   BNE V1, V0, 0x9D023504
9D0234F4  00000000   NOP
654:                 					return SOCKET_ERROR;
9D0234F8  2402FFFF   ADDIU V0, ZERO, -1
9D0234FC  0B408DCB   J 0x9D02372C
9D023500  00000000   NOP
655:                 			}
656:                 		}
657:                 		if(remoteInfo.IPAddr.Val == IP_ADDR_ANY)
9D023504  8FC2001C   LW V0, 28(S8)
9D023508  14400003   BNE V0, ZERO, 0x9D023518
9D02350C  00000000   NOP
658:                 			remoteInfo.IPAddr.Val = 0xFFFFFFFFu;
9D023510  2402FFFF   ADDIU V0, ZERO, -1
9D023514  AFC2001C   SW V0, 28(S8)
659:                 
660:                 		// Set the remote IP and MAC address if it is different from what we already have stored in the UDP socket
661:                 		if(UDPSocketInfo[socket->SocketID].remote.remoteNode.IPAddr.Val != remoteInfo.IPAddr.Val)
9D023518  8FC20018   LW V0, 24(S8)
9D02351C  90420018   LBU V0, 24(V0)
9D023520  00402021   ADDU A0, V0, ZERO
9D023524  3C02A000   LUI V0, -24576
9D023528  2403001C   ADDIU V1, ZERO, 28
9D02352C  70831802   MUL V1, A0, V1
9D023530  24420648   ADDIU V0, V0, 1608
9D023534  00621021   ADDU V0, V1, V0
9D023538  8C430000   LW V1, 0(V0)
9D02353C  8FC2001C   LW V0, 28(S8)
9D023540  1062002E   BEQ V1, V0, 0x9D0235FC
9D023544  00000000   NOP
662:                 		{
663:                 			if(ARPIsResolved(&remoteInfo.IPAddr, &remoteInfo.MACAddr))
9D023548  27C3001C   ADDIU V1, S8, 28
9D02354C  27C2001C   ADDIU V0, S8, 28
9D023550  24420004   ADDIU V0, V0, 4
9D023554  00602021   ADDU A0, V1, ZERO
9D023558  00402821   ADDU A1, V0, ZERO
9D02355C  0F40BCF9   JAL ARPIsResolved
9D023560  00000000   NOP
9D023564  10400011   BEQ V0, ZERO, 0x9D0235AC
9D023568  00000000   NOP
664:                 			{
665:                 				memcpy((void*)&UDPSocketInfo[socket->SocketID].remote.remoteNode, (void*)&remoteInfo, sizeof(remoteInfo));
9D02356C  8FC20018   LW V0, 24(S8)
9D023570  90420018   LBU V0, 24(V0)
9D023574  00401821   ADDU V1, V0, ZERO
9D023578  2402001C   ADDIU V0, ZERO, 28
9D02357C  70621802   MUL V1, V1, V0
9D023580  3C02A000   LUI V0, -24576
9D023584  24420648   ADDIU V0, V0, 1608
9D023588  00621821   ADDU V1, V1, V0
9D02358C  27C2001C   ADDIU V0, S8, 28
9D023590  00602021   ADDU A0, V1, ZERO
9D023594  00402821   ADDU A1, V0, ZERO
9D023598  2406000A   ADDIU A2, ZERO, 10
9D02359C  0F40D298   JAL 0x9D034A60
9D0235A0  00000000   NOP
9D0235A4  0B408D7F   J 0x9D0235FC
9D0235A8  00000000   NOP
666:                 			}
667:                 			else
668:                 			{
669:                 				if(TickGet() - startTick > 1*TICK_SECOND)
9D0235AC  0F40CDD6   JAL TickGet
9D0235B0  00000000   NOP
9D0235B4  00401821   ADDU V1, V0, ZERO
9D0235B8  8F8280D8   LW V0, -32552(GP)
9D0235BC  00621823   SUBU V1, V1, V0
9D0235C0  3C020002   LUI V0, 2
9D0235C4  3442625B   ORI V0, V0, 25179
9D0235C8  0062102B   SLTU V0, V1, V0
9D0235CC  14400008   BNE V0, ZERO, 0x9D0235F0
9D0235D0  00000000   NOP
670:                 				{
671:                 					ARPResolve(&remoteInfo.IPAddr);
9D0235D4  27C2001C   ADDIU V0, S8, 28
9D0235D8  00402021   ADDU A0, V0, ZERO
9D0235DC  0F40BCC0   JAL ARPResolve
9D0235E0  00000000   NOP
672:                 					startTick = TickGet();
9D0235E4  0F40CDD6   JAL TickGet
9D0235E8  00000000   NOP
9D0235EC  AF8280D8   SW V0, -32552(GP)
673:                 				}
674:                 				return SOCKET_ERROR;
9D0235F0  2402FFFF   ADDIU V0, ZERO, -1
9D0235F4  0B408DCB   J 0x9D02372C
9D0235F8  00000000   NOP
675:                 			}
676:                 		}
677:                 		
678:                 		// Select the UDP socket and see if we can write to it
679:                 		if(UDPIsPutReady(socket->SocketID))
9D0235FC  8FC20018   LW V0, 24(S8)
9D023600  90420018   LBU V0, 24(V0)
9D023604  00402021   ADDU A0, V0, ZERO
9D023608  0F40A307   JAL UDPIsPutReady
9D02360C  00000000   NOP
9D023610  10400045   BEQ V0, ZERO, 0x9D023728
9D023614  00000000   NOP
680:                 		{
681:                 			// Set the proper remote port
682:                 			UDPSocketInfo[socket->SocketID].remotePort = wRemotePort;
9D023618  8FC20018   LW V0, 24(S8)
9D02361C  90420018   LBU V0, 24(V0)
9D023620  00402021   ADDU A0, V0, ZERO
9D023624  3C02A000   LUI V0, -24576
9D023628  2403001C   ADDIU V1, ZERO, 28
9D02362C  70831802   MUL V1, A0, V1
9D023630  24420648   ADDIU V0, V0, 1608
9D023634  00621021   ADDU V0, V1, V0
9D023638  97C30010   LHU V1, 16(S8)
9D02363C  A443000C   SH V1, 12(V0)
683:                 
684:                 			// Write data and send UDP datagram
685:                 			size = UDPPutArray((BYTE*)buf, len);
9D023640  8FC30044   LW V1, 68(S8)
9D023644  8FC20048   LW V0, 72(S8)
9D023648  3042FFFF   ANDI V0, V0, -1
9D02364C  00602021   ADDU A0, V1, ZERO
9D023650  00402821   ADDU A1, V0, ZERO
9D023654  0F40A34D   JAL UDPPutArray
9D023658  00000000   NOP
9D02365C  AFC20014   SW V0, 20(S8)
686:                 			UDPFlush();
9D023660  0F40A38D   JAL UDPFlush
9D023664  00000000   NOP
687:                 			return size;
9D023668  8FC20014   LW V0, 20(S8)
9D02366C  0B408DCB   J 0x9D02372C
9D023670  00000000   NOP
688:                 		}
689:                 	}
690:                 	else if(socket->SocketType == SOCK_STREAM) //TCP will only send to the already established socket.
9D023674  8FC20018   LW V0, 24(S8)
9D023678  8C430000   LW V1, 0(V0)
9D02367C  24020064   ADDIU V0, ZERO, 100
9D023680  14620029   BNE V1, V0, 0x9D023728
9D023684  00000000   NOP
691:                 	{
692:                 		if(socket->bsdState != SKT_EST)
9D023688  8FC20018   LW V0, 24(S8)
9D02368C  8C430004   LW V1, 4(V0)
9D023690  24020006   ADDIU V0, ZERO, 6
9D023694  10620004   BEQ V1, V0, 0x9D0236A8
9D023698  00000000   NOP
693:                 			return SOCKET_ERROR;
9D02369C  2402FFFF   ADDIU V0, ZERO, -1
9D0236A0  0B408DCB   J 0x9D02372C
9D0236A4  00000000   NOP
694:                 
695:                 		if(HandlePossibleTCPDisconnection(s))
9D0236A8  93C20040   LBU V0, 64(S8)
9D0236AC  00402021   ADDU A0, V0, ZERO
9D0236B0  0F408FB5   JAL 0x9D023ED4
9D0236B4  00000000   NOP
9D0236B8  10400004   BEQ V0, ZERO, 0x9D0236CC
9D0236BC  00000000   NOP
696:                 			return SOCKET_ERROR;
9D0236C0  2402FFFF   ADDIU V0, ZERO, -1
9D0236C4  0B408DCB   J 0x9D02372C
9D0236C8  00000000   NOP
697:                 			
698:                 		// Handle special case were 0 return value is okay
699:                 		if(len == 0)
9D0236CC  8FC20048   LW V0, 72(S8)
9D0236D0  14400004   BNE V0, ZERO, 0x9D0236E4
9D0236D4  00000000   NOP
700:                 			return 0;
9D0236D8  00001021   ADDU V0, ZERO, ZERO
9D0236DC  0B408DCB   J 0x9D02372C
9D0236E0  00000000   NOP
701:                 
702:                 		// Write data to the socket. If one or more bytes were written, then 
703:                 		// return this value.  Otherwise, fail and return SOCKET_ERROR.
704:                 		size = TCPPutArray(socket->SocketID, (BYTE*)buf, len);
9D0236E4  8FC20018   LW V0, 24(S8)
9D0236E8  90420018   LBU V0, 24(V0)
9D0236EC  00402021   ADDU A0, V0, ZERO
9D0236F0  8FC30044   LW V1, 68(S8)
9D0236F4  8FC20048   LW V0, 72(S8)
9D0236F8  3042FFFF   ANDI V0, V0, -1
9D0236FC  00602821   ADDU A1, V1, ZERO
9D023700  00403021   ADDU A2, V0, ZERO
9D023704  0F4004E1   JAL TCPPutArray
9D023708  00000000   NOP
9D02370C  AFC20014   SW V0, 20(S8)
705:                 		if(size)
9D023710  8FC20014   LW V0, 20(S8)
9D023714  10400004   BEQ V0, ZERO, 0x9D023728
9D023718  00000000   NOP
706:                 			return size;
9D02371C  8FC20014   LW V0, 20(S8)
9D023720  0B408DCB   J 0x9D02372C
9D023724  00000000   NOP
707:                 	}
708:                 	return SOCKET_ERROR;
9D023728  2402FFFF   ADDIU V0, ZERO, -1
709:                 }
9D02372C  03C0E821   ADDU SP, S8, ZERO
9D023730  8FBF003C   LW RA, 60(SP)
9D023734  8FBE0038   LW S8, 56(SP)
9D023738  27BD0040   ADDIU SP, SP, 64
9D02373C  03E00008   JR RA
9D023740  00000000   NOP
710:                 
711:                 /*****************************************************************************
712:                   Function:
713:                 	int recv( SOCKET s, char* buf, int len, int flags )
714:                 
715:                   Summary:
716:                 	The recv() function is used to receive incoming data that has
717:                 	been queued for a socket.
718:                 
719:                   Description:
720:                 	The recv() function is used to receive incoming data that has
721:                 	been queued for a socket. This function can be used with both 
722:                 	datagram and stream socket. If the available data
723:                 	is too large to fit in the supplied application buffer buf,
724:                 	excess bytes are discarded in case of SOCK_DGRAM type
725:                 	sockets.  For SOCK_STREAM types, the data is buffered
726:                 	internally so the application can retreive all data by
727:                 	multiple calls of recvfrom.
728:                 
729:                   Precondition:
730:                 	connect function should be called for TCP and UDP sockets.
731:                 	Server side, accept function should be called.
732:                 
733:                   Parameters:
734:                 	s - Socket descriptor returned from a previous call to socket.
735:                 	buf - application data receive buffer.
736:                 	len - buffer length in bytes.
737:                 	flags - no significance in this implementation
738:                 
739:                   Returns:
740:                 	If recv is successful, the number of bytes copied to
741:                 	application buffer buf is returned. A value of zero indicates
742:                 	no data available. A return value of SOCKET_ERROR (-1)
743:                 	indicates an error condition. A return value of SOCKET_DISCONNECTED
744:                 	indicates the connection no longer exists.
745:                 
746:                   Remarks:
747:                 	None.
748:                   ***************************************************************************/
749:                 int recv( SOCKET s, char* buf, int len, int flags )
750:                 {
9D023744  27BDFFE0   ADDIU SP, SP, -32
9D023748  AFBF001C   SW RA, 28(SP)
9D02374C  AFBE0018   SW S8, 24(SP)
9D023750  03A0F021   ADDU S8, SP, ZERO
9D023754  00801021   ADDU V0, A0, ZERO
9D023758  AFC50024   SW A1, 36(S8)
9D02375C  AFC60028   SW A2, 40(S8)
9D023760  AFC7002C   SW A3, 44(S8)
9D023764  A3C20020   SB V0, 32(S8)
751:                 	struct BSDSocket *socket;
752:                 
753:                 	if( s >= BSD_SOCKET_COUNT )
9D023768  93C20020   LBU V0, 32(S8)
9D02376C  2C420005   SLTIU V0, V0, 5
9D023770  14400004   BNE V0, ZERO, 0x9D023784
9D023774  00000000   NOP
754:                 		return SOCKET_ERROR;
9D023778  2402FFFF   ADDIU V0, ZERO, -1
9D02377C  0B408E28   J 0x9D0238A0
9D023780  00000000   NOP
755:                 
756:                 	socket = &BSDSocketArray[s];
9D023784  93C30020   LBU V1, 32(S8)
9D023788  2402001C   ADDIU V0, ZERO, 28
9D02378C  70621802   MUL V1, V1, V0
9D023790  3C02A000   LUI V0, -24576
9D023794  24423080   ADDIU V0, V0, 12416
9D023798  00621021   ADDU V0, V1, V0
9D02379C  AFC20010   SW V0, 16(S8)
757:                 
758:                 	if(socket->SocketType == SOCK_STREAM) //TCP
9D0237A0  8FC20010   LW V0, 16(S8)
9D0237A4  8C430000   LW V1, 0(V0)
9D0237A8  24020064   ADDIU V0, ZERO, 100
9D0237AC  1462001E   BNE V1, V0, 0x9D023828
9D0237B0  00000000   NOP
759:                 	{
760:                 		if(socket->bsdState != SKT_EST)
9D0237B4  8FC20010   LW V0, 16(S8)
9D0237B8  8C430004   LW V1, 4(V0)
9D0237BC  24020006   ADDIU V0, ZERO, 6
9D0237C0  10620004   BEQ V1, V0, 0x9D0237D4
9D0237C4  00000000   NOP
761:                 			return SOCKET_ERROR;
9D0237C8  2402FFFF   ADDIU V0, ZERO, -1
9D0237CC  0B408E28   J 0x9D0238A0
9D0237D0  00000000   NOP
762:                 
763:                 		if(HandlePossibleTCPDisconnection(s))
9D0237D4  93C20020   LBU V0, 32(S8)
9D0237D8  00402021   ADDU A0, V0, ZERO
9D0237DC  0F408FB5   JAL 0x9D023ED4
9D0237E0  00000000   NOP
9D0237E4  10400004   BEQ V0, ZERO, 0x9D0237F8
9D0237E8  00000000   NOP
764:                 			return SOCKET_ERROR;
9D0237EC  2402FFFF   ADDIU V0, ZERO, -1
9D0237F0  0B408E28   J 0x9D0238A0
9D0237F4  00000000   NOP
765:                 
766:                 		return TCPGetArray(socket->SocketID, (BYTE*)buf, len);
9D0237F8  8FC20010   LW V0, 16(S8)
9D0237FC  90420018   LBU V0, 24(V0)
9D023800  00402021   ADDU A0, V0, ZERO
9D023804  8FC30024   LW V1, 36(S8)
9D023808  8FC20028   LW V0, 40(S8)
9D02380C  3042FFFF   ANDI V0, V0, -1
9D023810  00602821   ADDU A1, V1, ZERO
9D023814  00403021   ADDU A2, V0, ZERO
9D023818  0F40077A   JAL TCPGetArray
9D02381C  00000000   NOP
9D023820  0B408E28   J 0x9D0238A0
9D023824  00000000   NOP
767:                 	}
768:                 	else if(socket->SocketType == SOCK_DGRAM) //UDP
9D023828  8FC20010   LW V0, 16(S8)
9D02382C  8C430000   LW V1, 0(V0)
9D023830  2402006E   ADDIU V0, ZERO, 110
9D023834  14620019   BNE V1, V0, 0x9D02389C
9D023838  00000000   NOP
769:                 	{
770:                 		if(socket->bsdState != SKT_BOUND)
9D02383C  8FC20010   LW V0, 16(S8)
9D023840  8C430004   LW V1, 4(V0)
9D023844  24020002   ADDIU V0, ZERO, 2
9D023848  10620004   BEQ V1, V0, 0x9D02385C
9D02384C  00000000   NOP
771:                 			return SOCKET_ERROR;
9D023850  2402FFFF   ADDIU V0, ZERO, -1
9D023854  0B408E28   J 0x9D0238A0
9D023858  00000000   NOP
772:                 
773:                 		if(UDPIsGetReady(socket->SocketID))
9D02385C  8FC20010   LW V0, 16(S8)
9D023860  90420018   LBU V0, 24(V0)
9D023864  00402021   ADDU A0, V0, ZERO
9D023868  0F40A3FD   JAL UDPIsGetReady
9D02386C  00000000   NOP
9D023870  1040000A   BEQ V0, ZERO, 0x9D02389C
9D023874  00000000   NOP
774:                 			return UDPGetArray((BYTE*)buf, len);
9D023878  8FC30024   LW V1, 36(S8)
9D02387C  8FC20028   LW V0, 40(S8)
9D023880  3042FFFF   ANDI V0, V0, -1
9D023884  00602021   ADDU A0, V1, ZERO
9D023888  00402821   ADDU A1, V0, ZERO
9D02388C  0F40A442   JAL UDPGetArray
9D023890  00000000   NOP
9D023894  0B408E28   J 0x9D0238A0
9D023898  00000000   NOP
775:                 	}
776:                 
777:                 	return 0;
9D02389C  00001021   ADDU V0, ZERO, ZERO
778:                 }
9D0238A0  03C0E821   ADDU SP, S8, ZERO
9D0238A4  8FBF001C   LW RA, 28(SP)
9D0238A8  8FBE0018   LW S8, 24(SP)
9D0238AC  27BD0020   ADDIU SP, SP, 32
9D0238B0  03E00008   JR RA
9D0238B4  00000000   NOP
779:                 
780:                 /*****************************************************************************
781:                   Function:
782:                 	int recvfrom(SOCKET s, char* buf, int len, int flags, struct sockaddr* from, int* fromlen)
783:                 
784:                   Summary:
785:                 	The recvfrom() function is used to receive incoming data that
786:                 	has been queued for a socket.
787:                 
788:                   Description:
789:                 	The recvfrom() function is used to receive incoming data that
790:                 	has been queued for a socket. This function can be used with
791:                 	both datagram and stream type sockets. If the available data
792:                 	is too large to fit in the supplied application buffer buf,
793:                 	excess bytes are discarded in case of SOCK_DGRAM type
794:                 	sockets. For SOCK_STREAM types, the data is buffered
795:                 	internally so the application can retreive all data by
796:                 	multiple calls of recvfrom.
797:                 
798:                   Precondition:
799:                 	socket function should be called.
800:                 
801:                   Parameters:
802:                 	s - Socket descriptor returned from a previous call to socket.
803:                 	buf - application data receive buffer.
804:                 	len - buffer length in bytes.
805:                 	flags - message flags. Currently this is not supported.
806:                 	from - pointer to the sockaddr structure that will be
807:                 	filled in with the destination address.
808:                 	fromlen - size of buffer pointed by from.
809:                 
810:                   Returns:
811:                 	If recvfrom is successful, the number of bytes copied to
812:                 	application buffer buf is returned. A value of zero indicates
813:                 	no data available. A return value of SOCKET_ERROR (-1)
814:                 	indicates an error condition.
815:                 
816:                   Remarks:
817:                 	None.
818:                   ***************************************************************************/
819:                 int recvfrom( SOCKET s, char* buf, int len, int flags, struct sockaddr* from, int* fromlen )
820:                 {
9D0238B8  27BDFFD8   ADDIU SP, SP, -40
9D0238BC  AFBF0024   SW RA, 36(SP)
9D0238C0  AFBE0020   SW S8, 32(SP)
9D0238C4  03A0F021   ADDU S8, SP, ZERO
9D0238C8  00801021   ADDU V0, A0, ZERO
9D0238CC  AFC5002C   SW A1, 44(S8)
9D0238D0  AFC60030   SW A2, 48(S8)
9D0238D4  AFC70034   SW A3, 52(S8)
9D0238D8  A3C20028   SB V0, 40(S8)
821:                 	struct BSDSocket *socket;
822:                 	struct sockaddr_in *rem_addr;
823:                 	SOCKET_INFO *remoteSockInfo;
824:                 
825:                 	socket = &BSDSocketArray[s];
9D0238DC  93C30028   LBU V1, 40(S8)
9D0238E0  2402001C   ADDIU V0, ZERO, 28
9D0238E4  70621802   MUL V1, V1, V0
9D0238E8  3C02A000   LUI V0, -24576
9D0238EC  24423080   ADDIU V0, V0, 12416
9D0238F0  00621021   ADDU V0, V1, V0
9D0238F4  AFC20010   SW V0, 16(S8)
826:                 	rem_addr = (struct sockaddr_in *)from;
9D0238F8  8FC20038   LW V0, 56(S8)
9D0238FC  AFC20014   SW V0, 20(S8)
827:                 
828:                 	if(socket->SocketType == SOCK_DGRAM) //UDP
9D023900  8FC20010   LW V0, 16(S8)
9D023904  8C430000   LW V1, 0(V0)
9D023908  2402006E   ADDIU V0, ZERO, 110
9D02390C  14620048   BNE V1, V0, 0x9D023A30
9D023910  00000000   NOP
829:                 	{
830:                 		// If this BSD socket doesn't have a Microchip UDP socket associated 
831:                 		// with it yet, then no data can be received and we must not use the 
832:                 		// socket->SocketID parameter, which isn't set yet.
833:                 		if(socket->bsdState != SKT_BOUND)
9D023914  8FC20010   LW V0, 16(S8)
9D023918  8C430004   LW V1, 4(V0)
9D02391C  24020002   ADDIU V0, ZERO, 2
9D023920  10620004   BEQ V1, V0, 0x9D023934
9D023924  00000000   NOP
834:                 			return 0;
9D023928  00001021   ADDU V0, ZERO, ZERO
9D02392C  0B408EBE   J 0x9D023AF8
9D023930  00000000   NOP
835:                 		
836:                 		if(UDPIsGetReady(socket->SocketID))
9D023934  8FC20010   LW V0, 16(S8)
9D023938  90420018   LBU V0, 24(V0)
9D02393C  00402021   ADDU A0, V0, ZERO
9D023940  0F40A3FD   JAL UDPIsGetReady
9D023944  00000000   NOP
9D023948  1040006A   BEQ V0, ZERO, 0x9D023AF4
9D02394C  00000000   NOP
837:                 		{
838:                 			// Capture sender information (can change packet to packet)
839:                 			if(from && fromlen)
9D023950  8FC20038   LW V0, 56(S8)
9D023954  1040002D   BEQ V0, ZERO, 0x9D023A0C
9D023958  00000000   NOP
9D02395C  8FC2003C   LW V0, 60(S8)
9D023960  1040002A   BEQ V0, ZERO, 0x9D023A0C
9D023964  00000000   NOP
840:                 			{
841:                 				if((unsigned int)*fromlen >= sizeof(struct sockaddr_in))
9D023968  8FC2003C   LW V0, 60(S8)
9D02396C  8C420000   LW V0, 0(V0)
9D023970  2C420010   SLTIU V0, V0, 16
9D023974  14400025   BNE V0, ZERO, 0x9D023A0C
9D023978  00000000   NOP
842:                 				{
843:                 					rem_addr->sin_addr.S_un.S_addr = UDPSocketInfo[socket->SocketID].remote.remoteNode.IPAddr.Val;
9D02397C  8FC20010   LW V0, 16(S8)
9D023980  90420018   LBU V0, 24(V0)
9D023984  00402021   ADDU A0, V0, ZERO
9D023988  3C02A000   LUI V0, -24576
9D02398C  2403001C   ADDIU V1, ZERO, 28
9D023990  70831802   MUL V1, A0, V1
9D023994  24420648   ADDIU V0, V0, 1608
9D023998  00621021   ADDU V0, V1, V0
9D02399C  8C430000   LW V1, 0(V0)
9D0239A0  8FC20014   LW V0, 20(S8)
9D0239A4  A8430007   SWL V1, 7(V0)
9D0239A8  B8430004   SWR V1, 4(V0)
844:                 					rem_addr->sin_port = UDPSocketInfo[socket->SocketID].remotePort;
9D0239AC  8FC20010   LW V0, 16(S8)
9D0239B0  90420018   LBU V0, 24(V0)
9D0239B4  00402021   ADDU A0, V0, ZERO
9D0239B8  3C02A000   LUI V0, -24576
9D0239BC  2403001C   ADDIU V1, ZERO, 28
9D0239C0  70831802   MUL V1, A0, V1
9D0239C4  24420648   ADDIU V0, V0, 1608
9D0239C8  00621021   ADDU V0, V1, V0
9D0239CC  9443000C   LHU V1, 12(V0)
9D0239D0  8FC20014   LW V0, 20(S8)
9D0239D4  306400FF   ANDI A0, V1, 255
9D0239D8  90450002   LBU A1, 2(V0)
9D0239DC  30A50000   ANDI A1, A1, 0
9D0239E0  00A42025   OR A0, A1, A0
9D0239E4  A0440002   SB A0, 2(V0)
9D0239E8  00031A02   SRL V1, V1, 8
9D0239EC  3063FFFF   ANDI V1, V1, -1
9D0239F0  90440003   LBU A0, 3(V0)
9D0239F4  30840000   ANDI A0, A0, 0
9D0239F8  00831825   OR V1, A0, V1
9D0239FC  A0430003   SB V1, 3(V0)
845:                 					*fromlen = sizeof(struct sockaddr_in);
9D023A00  8FC2003C   LW V0, 60(S8)
9D023A04  24030010   ADDIU V1, ZERO, 16
9D023A08  AC430000   SW V1, 0(V0)
846:                 				}
847:                 			}
848:                 
849:                 			return UDPGetArray((BYTE*)buf, len);
9D023A0C  8FC3002C   LW V1, 44(S8)
9D023A10  8FC20030   LW V0, 48(S8)
9D023A14  3042FFFF   ANDI V0, V0, -1
9D023A18  00602021   ADDU A0, V1, ZERO
9D023A1C  00402821   ADDU A1, V0, ZERO
9D023A20  0F40A442   JAL UDPGetArray
9D023A24  00000000   NOP
9D023A28  0B408EBE   J 0x9D023AF8
9D023A2C  00000000   NOP
850:                 		}
851:                 	}
852:                 	else  //TCP recieve from already connected socket.
853:                 	{
854:                 		if(from && fromlen)
9D023A30  8FC20038   LW V0, 56(S8)
9D023A34  10400026   BEQ V0, ZERO, 0x9D023AD0
9D023A38  00000000   NOP
9D023A3C  8FC2003C   LW V0, 60(S8)
9D023A40  10400023   BEQ V0, ZERO, 0x9D023AD0
9D023A44  00000000   NOP
855:                 		{
856:                 			// Capture sender information (will always match socket connection information)
857:                 			if((unsigned int)*fromlen >= sizeof(struct sockaddr_in))
9D023A48  8FC2003C   LW V0, 60(S8)
9D023A4C  8C420000   LW V0, 0(V0)
9D023A50  2C420010   SLTIU V0, V0, 16
9D023A54  1440001E   BNE V0, ZERO, 0x9D023AD0
9D023A58  00000000   NOP
858:                 			{
859:                 				remoteSockInfo = TCPGetRemoteInfo(socket->SocketID);
9D023A5C  8FC20010   LW V0, 16(S8)
9D023A60  90420018   LBU V0, 24(V0)
9D023A64  00402021   ADDU A0, V0, ZERO
9D023A68  0F400340   JAL TCPGetRemoteInfo
9D023A6C  00000000   NOP
9D023A70  AFC20018   SW V0, 24(S8)
860:                 				rem_addr->sin_addr.S_un.S_addr = remoteSockInfo->remote.IPAddr.Val;
9D023A74  8FC20018   LW V0, 24(S8)
9D023A78  88430003   LWL V1, 3(V0)
9D023A7C  98430000   LWR V1, 0(V0)
9D023A80  8FC20014   LW V0, 20(S8)
9D023A84  A8430007   SWL V1, 7(V0)
9D023A88  B8430004   SWR V1, 4(V0)
861:                 				rem_addr->sin_port = remoteSockInfo->remotePort.Val;
9D023A8C  8FC20018   LW V0, 24(S8)
9D023A90  9443000A   LHU V1, 10(V0)
9D023A94  8FC20014   LW V0, 20(S8)
9D023A98  306400FF   ANDI A0, V1, 255
9D023A9C  90450002   LBU A1, 2(V0)
9D023AA0  30A50000   ANDI A1, A1, 0
9D023AA4  00A42025   OR A0, A1, A0
9D023AA8  A0440002   SB A0, 2(V0)
9D023AAC  00031A02   SRL V1, V1, 8
9D023AB0  3063FFFF   ANDI V1, V1, -1
9D023AB4  90440003   LBU A0, 3(V0)
9D023AB8  30840000   ANDI A0, A0, 0
9D023ABC  00831825   OR V1, A0, V1
9D023AC0  A0430003   SB V1, 3(V0)
862:                 				*fromlen = sizeof(struct sockaddr_in);
9D023AC4  8FC2003C   LW V0, 60(S8)
9D023AC8  24030010   ADDIU V1, ZERO, 16
9D023ACC  AC430000   SW V1, 0(V0)
863:                 			}
864:                 		}
865:                 		return recv(s, buf, len, 0);
9D023AD0  93C20028   LBU V0, 40(S8)
9D023AD4  00402021   ADDU A0, V0, ZERO
9D023AD8  8FC5002C   LW A1, 44(S8)
9D023ADC  8FC60030   LW A2, 48(S8)
9D023AE0  00003821   ADDU A3, ZERO, ZERO
9D023AE4  0F408DD1   JAL recv
9D023AE8  00000000   NOP
9D023AEC  0B408EBE   J 0x9D023AF8
9D023AF0  00000000   NOP
866:                 	}
867:                 	return 0;
9D023AF4  00001021   ADDU V0, ZERO, ZERO
868:                 }
9D023AF8  03C0E821   ADDU SP, S8, ZERO
9D023AFC  8FBF0024   LW RA, 36(SP)
9D023B00  8FBE0020   LW S8, 32(SP)
9D023B04  27BD0028   ADDIU SP, SP, 40
9D023B08  03E00008   JR RA
9D023B0C  00000000   NOP
869:                 
870:                 /*****************************************************************************
871:                   Function:
872:                 	int gethostname(char* name, int namelen )
873:                 
874:                   Summary:
875:                 	Returns the standard host name for the system.
876:                 
877:                   Description:
878:                 	This function returns the standard host name of the system which is 
879:                 	calling this function.	The returned name is null-terminated.
880:                 
881:                   Precondition:
882:                 	None.
883:                 
884:                   Parameters:
885:                 	name - Pointer to a buffer that receives the local host name.
886:                 	namelen - size of the name array.
887:                 
888:                   Returns:
889:                 	Success will return a value of 0. 
890:                 	If name is too short to hold the host name or any other error occurs, 
891:                 	SOCKET_ERROR (-1) will be returned.  On error, *name will be unmodified 
892:                 	and no null terminator will be generated.
893:                 
894:                   Remarks:
895:                 	None.
896:                   ***************************************************************************/
897:                 int gethostname(char* name, int namelen)
898:                 {
9D023B10  27BDFFE0   ADDIU SP, SP, -32
9D023B14  AFBF001C   SW RA, 28(SP)
9D023B18  AFBE0018   SW S8, 24(SP)
9D023B1C  03A0F021   ADDU S8, SP, ZERO
9D023B20  AFC40020   SW A0, 32(S8)
9D023B24  AFC50024   SW A1, 36(S8)
899:                 	WORD wSourceLen;
900:                 	WORD w;
901:                 	BYTE v;
902:                 
903:                 	wSourceLen = sizeof(AppConfig.NetBIOSName);
9D023B28  24020010   ADDIU V0, ZERO, 16
9D023B2C  A7C20012   SH V0, 18(S8)
904:                 	for(w = 0; w < wSourceLen; w++)
9D023B30  A7C00010   SH ZERO, 16(S8)
9D023B34  0B408EDF   J 0x9D023B7C
9D023B38  00000000   NOP
9D023B70  97C20010   LHU V0, 16(S8)
9D023B74  24420001   ADDIU V0, V0, 1
9D023B78  A7C20010   SH V0, 16(S8)
9D023B7C  97C30010   LHU V1, 16(S8)
9D023B80  97C20012   LHU V0, 18(S8)
9D023B84  0062102B   SLTU V0, V1, V0
9D023B88  1440FFEC   BNE V0, ZERO, 0x9D023B3C
9D023B8C  00000000   NOP
905:                 	{
906:                 		v = AppConfig.NetBIOSName[w];
9D023B3C  97C20010   LHU V0, 16(S8)
9D023B40  3C03A000   LUI V1, -24576
9D023B44  24630728   ADDIU V1, V1, 1832
9D023B48  00621021   ADDU V0, V1, V0
9D023B4C  9042001C   LBU V0, 28(V0)
9D023B50  A3C20014   SB V0, 20(S8)
907:                 		if((v == ' ') || (v == 0u))
9D023B54  93C30014   LBU V1, 20(S8)
9D023B58  24020020   ADDIU V0, ZERO, 32
9D023B5C  1062000C   BEQ V1, V0, 0x9D023B90
9D023B60  00000000   NOP
9D023B64  93C20014   LBU V0, 20(S8)
9D023B68  10400009   BEQ V0, ZERO, 0x9D023B90
9D023B6C  00000000   NOP
908:                 			break;
909:                 	}
910:                 	wSourceLen = w;
9D023B90  97C20010   LHU V0, 16(S8)
9D023B94  A7C20012   SH V0, 18(S8)
911:                 	if(namelen < (int)wSourceLen + 1)
9D023B98  97C20012   LHU V0, 18(S8)
9D023B9C  24430001   ADDIU V1, V0, 1
9D023BA0  8FC20024   LW V0, 36(S8)
9D023BA4  0043102A   SLT V0, V0, V1
9D023BA8  10400004   BEQ V0, ZERO, 0x9D023BBC
9D023BAC  00000000   NOP
912:                 		return SOCKET_ERROR;
9D023BB0  2402FFFF   ADDIU V0, ZERO, -1
9D023BB4  0B408EFB   J 0x9D023BEC
9D023BB8  00000000   NOP
913:                 
914:                 	memcpy((void*)name, (void*)AppConfig.NetBIOSName, wSourceLen);
9D023BBC  97C20012   LHU V0, 18(S8)
9D023BC0  8FC40020   LW A0, 32(S8)
9D023BC4  3C03A000   LUI V1, -24576
9D023BC8  24650744   ADDIU A1, V1, 1860
9D023BCC  00403021   ADDU A2, V0, ZERO
9D023BD0  0F40D298   JAL 0x9D034A60
9D023BD4  00000000   NOP
915:                 	name[wSourceLen] = 0;
9D023BD8  97C20012   LHU V0, 18(S8)
9D023BDC  8FC30020   LW V1, 32(S8)
9D023BE0  00621021   ADDU V0, V1, V0
9D023BE4  A0400000   SB ZERO, 0(V0)
916:                 
917:                 	return 0;
9D023BE8  00001021   ADDU V0, ZERO, ZERO
918:                 }
9D023BEC  03C0E821   ADDU SP, S8, ZERO
9D023BF0  8FBF001C   LW RA, 28(SP)
9D023BF4  8FBE0018   LW S8, 24(SP)
9D023BF8  27BD0020   ADDIU SP, SP, 32
9D023BFC  03E00008   JR RA
9D023C00  00000000   NOP
919:                 
920:                 /*****************************************************************************
921:                   Function:
922:                 	int closesocket( SOCKET s )
923:                 	
924:                   Summary:
925:                 	The closesocket function closes an existing socket.
926:                 
927:                   Description:
928:                 	The closesocket function closes an existing socket.  
929:                 	This function releases the socket descriptor s.  
930:                 	Any data buffered at the socket is discarded.  If the 
931:                 	socket s is no longer needed, closesocket() must be 
932:                 	called in order to release all resources associated with s.
933:                 
934:                   Precondition:
935:                 	None.
936:                 
937:                   Parameters:
938:                 	s - Socket descriptor returned from a previous call to socket
939:                 
940:                   Returns:
941:                 	If closesocket is successful, a value of 0 is returned. 
942:                 	A return value of SOCKET_ERROR (-1) indicates an error.
943:                 
944:                   Remarks:
945:                 	None.
946:                   ***************************************************************************/
947:                 int closesocket( SOCKET s )
948:                 {	
9D023C04  27BDFFE0   ADDIU SP, SP, -32
9D023C08  AFBF001C   SW RA, 28(SP)
9D023C0C  AFBE0018   SW S8, 24(SP)
9D023C10  03A0F021   ADDU S8, SP, ZERO
9D023C14  00801021   ADDU V0, A0, ZERO
9D023C18  A3C20020   SB V0, 32(S8)
949:                 	BYTE i;
950:                 	struct BSDSocket *socket;
951:                 
952:                 	if( s >= BSD_SOCKET_COUNT )
9D023C1C  93C20020   LBU V0, 32(S8)
9D023C20  2C420005   SLTIU V0, V0, 5
9D023C24  14400004   BNE V0, ZERO, 0x9D023C38
9D023C28  00000000   NOP
953:                 		return SOCKET_ERROR;
9D023C2C  2402FFFF   ADDIU V0, ZERO, -1
9D023C30  0B408FAF   J 0x9D023EBC
9D023C34  00000000   NOP
954:                 
955:                 	socket = &BSDSocketArray[s];
9D023C38  93C30020   LBU V1, 32(S8)
9D023C3C  2402001C   ADDIU V0, ZERO, 28
9D023C40  70621802   MUL V1, V1, V0
9D023C44  3C02A000   LUI V0, -24576
9D023C48  24423080   ADDIU V0, V0, 12416
9D023C4C  00621021   ADDU V0, V1, V0
9D023C50  AFC20014   SW V0, 20(S8)
956:                 
957:                 	if(socket->bsdState == SKT_CLOSED)
9D023C54  8FC20014   LW V0, 20(S8)
9D023C58  8C420004   LW V0, 4(V0)
9D023C5C  14400004   BNE V0, ZERO, 0x9D023C70
9D023C60  00000000   NOP
958:                 		return 0;	// Nothing to do, so return success
9D023C64  00001021   ADDU V0, ZERO, ZERO
9D023C68  0B408FAF   J 0x9D023EBC
9D023C6C  00000000   NOP
959:                 
960:                 	if(socket->SocketType == SOCK_STREAM)
9D023C70  8FC20014   LW V0, 20(S8)
9D023C74  8C430000   LW V1, 0(V0)
9D023C78  24020064   ADDIU V0, ZERO, 100
9D023C7C  14620082   BNE V1, V0, 0x9D023E88
9D023C80  00000000   NOP
961:                 	{
962:                 		if(socket->bsdState == SKT_BSD_LISTEN)
9D023C84  8FC20014   LW V0, 20(S8)
9D023C88  8C430004   LW V1, 4(V0)
9D023C8C  24020003   ADDIU V0, ZERO, 3
9D023C90  14620036   BNE V1, V0, 0x9D023D6C
9D023C94  00000000   NOP
963:                 		{
964:                 			// This is a listerner handle, so when we close it we also should 
965:                 			// close all TCP sockets that were opened for backlog processing 
966:                 			// but didn't actually get connected
967:                 			for(i = 0; i < sizeof(BSDSocketArray)/sizeof(BSDSocketArray[0]); i++)
9D023C98  A3C00010   SB ZERO, 16(S8)
9D023C9C  0B408F55   J 0x9D023D54
9D023CA0  00000000   NOP
9D023D48  93C20010   LBU V0, 16(S8)
9D023D4C  24420001   ADDIU V0, V0, 1
9D023D50  A3C20010   SB V0, 16(S8)
9D023D54  93C20010   LBU V0, 16(S8)
9D023D58  2C420005   SLTIU V0, V0, 5
9D023D5C  1440FFD1   BNE V0, ZERO, 0x9D023CA4
9D023D60  00000000   NOP
9D023D64  0B408FAC   J 0x9D023EB0
9D023D68  00000000   NOP
968:                 			{
969:                 				if(BSDSocketArray[i].bsdState != SKT_LISTEN)
9D023CA4  93C40010   LBU A0, 16(S8)
9D023CA8  3C02A000   LUI V0, -24576
9D023CAC  24433080   ADDIU V1, V0, 12416
9D023CB0  2402001C   ADDIU V0, ZERO, 28
9D023CB4  70821002   MUL V0, A0, V0
9D023CB8  00621021   ADDU V0, V1, V0
9D023CBC  8C430004   LW V1, 4(V0)
9D023CC0  24020004   ADDIU V0, ZERO, 4
9D023CC4  1462001F   BNE V1, V0, 0x9D023D44
9D023CC8  00000000   NOP
970:                 					continue;
9D023D44  00000000   NOP
971:                 				if(BSDSocketArray[i].localPort == socket->localPort)
9D023CCC  93C40010   LBU A0, 16(S8)
9D023CD0  3C02A000   LUI V0, -24576
9D023CD4  2403001C   ADDIU V1, ZERO, 28
9D023CD8  70831802   MUL V1, A0, V1
9D023CDC  24423080   ADDIU V0, V0, 12416
9D023CE0  00621021   ADDU V0, V1, V0
9D023CE4  94430008   LHU V1, 8(V0)
9D023CE8  8FC20014   LW V0, 20(S8)
9D023CEC  94420008   LHU V0, 8(V0)
9D023CF0  14620015   BNE V1, V0, 0x9D023D48
9D023CF4  00000000   NOP
972:                 				{
973:                 					TCPClose(BSDSocketArray[i].SocketID);
9D023CF8  93C40010   LBU A0, 16(S8)
9D023CFC  3C02A000   LUI V0, -24576
9D023D00  2403001C   ADDIU V1, ZERO, 28
9D023D04  70831802   MUL V1, A0, V1
9D023D08  24423080   ADDIU V0, V0, 12416
9D023D0C  00621021   ADDU V0, V1, V0
9D023D10  90420018   LBU V0, 24(V0)
9D023D14  00402021   ADDU A0, V0, ZERO
9D023D18  0F40031D   JAL TCPClose
9D023D1C  00000000   NOP
974:                 					BSDSocketArray[i].bsdState = SKT_CLOSED;
9D023D20  93C40010   LBU A0, 16(S8)
9D023D24  3C02A000   LUI V0, -24576
9D023D28  24433080   ADDIU V1, V0, 12416
9D023D2C  2402001C   ADDIU V0, ZERO, 28
9D023D30  70821002   MUL V0, A0, V0
9D023D34  00621021   ADDU V0, V1, V0
9D023D38  AC400004   SW ZERO, 4(V0)
9D023D3C  0B408F52   J 0x9D023D48
9D023D40  00000000   NOP
975:                 				}
976:                 			}
977:                 		}
978:                 		else if(socket->bsdState >= SKT_LISTEN)
9D023D6C  8FC20014   LW V0, 20(S8)
9D023D70  8C420004   LW V0, 4(V0)
9D023D74  2C420004   SLTIU V0, V0, 4
9D023D78  1440004D   BNE V0, ZERO, 0x9D023EB0
9D023D7C  00000000   NOP
979:                 		{
980:                 			// For server sockets, if the parent listening socket is still open, 
981:                 			// then return this socket to the queue for future backlog processing.
982:                 			if(socket->isServer)
9D023D80  8FC20014   LW V0, 20(S8)
9D023D84  8C420014   LW V0, 20(V0)
9D023D88  10400033   BEQ V0, ZERO, 0x9D023E58
9D023D8C  00000000   NOP
983:                 			{
984:                 				for(i = 0; i < sizeof(BSDSocketArray)/sizeof(BSDSocketArray[0]); i++)
9D023D90  A3C00010   SB ZERO, 16(S8)
9D023D94  0B408F8B   J 0x9D023E2C
9D023D98  00000000   NOP
9D023E20  93C20010   LBU V0, 16(S8)
9D023E24  24420001   ADDIU V0, V0, 1
9D023E28  A3C20010   SB V0, 16(S8)
9D023E2C  93C20010   LBU V0, 16(S8)
9D023E30  2C420005   SLTIU V0, V0, 5
9D023E34  1440FFD9   BNE V0, ZERO, 0x9D023D9C
9D023E38  00000000   NOP
985:                 				{
986:                 					if(BSDSocketArray[i].bsdState != SKT_BSD_LISTEN)
9D023D9C  93C40010   LBU A0, 16(S8)
9D023DA0  3C02A000   LUI V0, -24576
9D023DA4  24433080   ADDIU V1, V0, 12416
9D023DA8  2402001C   ADDIU V0, ZERO, 28
9D023DAC  70821002   MUL V0, A0, V0
9D023DB0  00621021   ADDU V0, V1, V0
9D023DB4  8C430004   LW V1, 4(V0)
9D023DB8  24020003   ADDIU V0, ZERO, 3
9D023DBC  14620017   BNE V1, V0, 0x9D023E1C
9D023DC0  00000000   NOP
987:                 						continue;
9D023E1C  00000000   NOP
988:                 					if(BSDSocketArray[i].localPort == socket->localPort)
9D023DC4  93C40010   LBU A0, 16(S8)
9D023DC8  3C02A000   LUI V0, -24576
9D023DCC  2403001C   ADDIU V1, ZERO, 28
9D023DD0  70831802   MUL V1, A0, V1
9D023DD4  24423080   ADDIU V0, V0, 12416
9D023DD8  00621021   ADDU V0, V1, V0
9D023DDC  94430008   LHU V1, 8(V0)
9D023DE0  8FC20014   LW V0, 20(S8)
9D023DE4  94420008   LHU V0, 8(V0)
9D023DE8  1462000D   BNE V1, V0, 0x9D023E20
9D023DEC  00000000   NOP
989:                 					{
990:                 						TCPDisconnect(socket->SocketID);
9D023DF0  8FC20014   LW V0, 20(S8)
9D023DF4  90420018   LBU V0, 24(V0)
9D023DF8  00402021   ADDU A0, V0, ZERO
9D023DFC  0F400273   JAL TCPDisconnect
9D023E00  00000000   NOP
991:                 						
992:                 						// Listener socket is still open, so just return to the 
993:                 						// listening state so that the user must call accept() again to 
994:                 						// reuse this BSD socket
995:                 						socket->bsdState = SKT_LISTEN;
9D023E04  8FC20014   LW V0, 20(S8)
9D023E08  24030004   ADDIU V1, ZERO, 4
9D023E0C  AC430004   SW V1, 4(V0)
996:                 						return 0;
9D023E10  00001021   ADDU V0, ZERO, ZERO
9D023E14  0B408FAF   J 0x9D023EBC
9D023E18  00000000   NOP
997:                 					}
998:                 				}
999:                 				// If we get down here, then the parent listener socket has 
1000:                				// apparently already been closed, so this socket can not be 
1001:                				// reused.  Close it complete.
1002:                				TCPClose(socket->SocketID);
9D023E3C  8FC20014   LW V0, 20(S8)
9D023E40  90420018   LBU V0, 24(V0)
9D023E44  00402021   ADDU A0, V0, ZERO
9D023E48  0F40031D   JAL TCPClose
9D023E4C  00000000   NOP
9D023E50  0B408FAC   J 0x9D023EB0
9D023E54  00000000   NOP
1003:                			}
1004:                			else if(socket->bsdState != SKT_DISCONNECTED)	// this is a client socket that isn't already disconnected
9D023E58  8FC20014   LW V0, 20(S8)
9D023E5C  8C430004   LW V1, 4(V0)
9D023E60  24020007   ADDIU V0, ZERO, 7
9D023E64  10620012   BEQ V1, V0, 0x9D023EB0
9D023E68  00000000   NOP
1005:                			{
1006:                				TCPClose(socket->SocketID);
9D023E6C  8FC20014   LW V0, 20(S8)
9D023E70  90420018   LBU V0, 24(V0)
9D023E74  00402021   ADDU A0, V0, ZERO
9D023E78  0F40031D   JAL TCPClose
9D023E7C  00000000   NOP
9D023E80  0B408FAC   J 0x9D023EB0
9D023E84  00000000   NOP
1007:                			}
1008:                		}
1009:                	}
1010:                	else //udp sockets
1011:                	{
1012:                		if(socket->bsdState == SKT_BOUND)
9D023E88  8FC20014   LW V0, 20(S8)
9D023E8C  8C430004   LW V1, 4(V0)
9D023E90  24020002   ADDIU V0, ZERO, 2
9D023E94  14620006   BNE V1, V0, 0x9D023EB0
9D023E98  00000000   NOP
1013:                			UDPClose(socket->SocketID);
9D023E9C  8FC20014   LW V0, 20(S8)
9D023EA0  90420018   LBU V0, 24(V0)
9D023EA4  00402021   ADDU A0, V0, ZERO
9D023EA8  0F40A2B9   JAL UDPClose
9D023EAC  00000000   NOP
1014:                	}
1015:                
1016:                	socket->bsdState = SKT_CLOSED;
9D023EB0  8FC20014   LW V0, 20(S8)
9D023EB4  AC400004   SW ZERO, 4(V0)
1017:                	return 0; //success
9D023EB8  00001021   ADDU V0, ZERO, ZERO
1018:                }
9D023EBC  03C0E821   ADDU SP, S8, ZERO
9D023EC0  8FBF001C   LW RA, 28(SP)
9D023EC4  8FBE0018   LW S8, 24(SP)
9D023EC8  27BD0020   ADDIU SP, SP, 32
9D023ECC  03E00008   JR RA
9D023ED0  00000000   NOP
1019:                
1020:                
1021:                /*****************************************************************************
1022:                  Function:
1023:                	static BOOL HandlePossibleTCPDisconnection(SOCKET s)
1024:                	
1025:                  Summary:
1026:                	Internal function that checks for asynchronous TCP connection state 
1027:                	changes and resynchs the BSD socket descriptor state to match. 
1028:                
1029:                  Description:
1030:                	Internal function that checks for asynchronous TCP connection state 
1031:                	changes and resynchs the BSD socket descriptor state to match. 
1032:                
1033:                  Precondition:
1034:                	None
1035:                
1036:                  Parameters:
1037:                	s - TCP type socket descriptor returned from a previous call to socket.  
1038:                	    This socket must be in the SKT_LISTEN, SKT_IN_PROGRESS, SKT_EST, or 
1039:                	    SKT_DISCONNECTED states.
1040:                
1041:                  Returns:
1042:                	TRUE - Socket is disconnected
1043:                	FALSE - Socket is 
1044:                
1045:                  ***************************************************************************/
1046:                static BOOL HandlePossibleTCPDisconnection(SOCKET s)
1047:                {
9D023ED4  27BDFFD8   ADDIU SP, SP, -40
9D023ED8  AFBF0024   SW RA, 36(SP)
9D023EDC  AFBE0020   SW S8, 32(SP)
9D023EE0  03A0F021   ADDU S8, SP, ZERO
9D023EE4  00801021   ADDU V0, A0, ZERO
9D023EE8  A3C20028   SB V0, 40(S8)
1048:                	struct BSDSocket *socket;
1049:                	BYTE i;
1050:                	BOOL bSocketWasReset;
1051:                
1052:                	socket = &BSDSocketArray[s];
9D023EEC  93C30028   LBU V1, 40(S8)
9D023EF0  2402001C   ADDIU V0, ZERO, 28
9D023EF4  70621802   MUL V1, V1, V0
9D023EF8  3C02A000   LUI V0, -24576
9D023EFC  24423080   ADDIU V0, V0, 12416
9D023F00  00621021   ADDU V0, V1, V0
9D023F04  AFC20014   SW V0, 20(S8)
1053:                
1054:                	// Nothing to do if disconnection has already been handled
1055:                	if(socket->bsdState == SKT_DISCONNECTED)
9D023F08  8FC20014   LW V0, 20(S8)
9D023F0C  8C430004   LW V1, 4(V0)
9D023F10  24020007   ADDIU V0, ZERO, 7
9D023F14  14620004   BNE V1, V0, 0x9D023F28
9D023F18  00000000   NOP
1056:                		return TRUE;	
9D023F1C  24020001   ADDIU V0, ZERO, 1
9D023F20  0B40900F   J 0x9D02403C
9D023F24  00000000   NOP
1057:                
1058:                	// Find out if a disconnect has occurred
1059:                	bSocketWasReset = TCPWasReset(socket->SocketID);
9D023F28  8FC20014   LW V0, 20(S8)
9D023F2C  90420018   LBU V0, 24(V0)
9D023F30  00402021   ADDU A0, V0, ZERO
9D023F34  0F400229   JAL TCPWasReset
9D023F38  00000000   NOP
9D023F3C  AFC20018   SW V0, 24(S8)
1060:                
1061:                	// For server sockets, if the parent listening socket is still open, 
1062:                	// then return this socket to the queue for future backlog processing.
1063:                	if(socket->isServer)
9D023F40  8FC20014   LW V0, 20(S8)
9D023F44  8C420014   LW V0, 20(V0)
9D023F48  1040002D   BEQ V0, ZERO, 0x9D024000
9D023F4C  00000000   NOP
1064:                	{
1065:                		for(i = 0; i < sizeof(BSDSocketArray)/sizeof(BSDSocketArray[0]); i++)
9D023F50  A3C00010   SB ZERO, 16(S8)
9D023F54  0B408FFC   J 0x9D023FF0
9D023F58  00000000   NOP
9D023FE4  93C20010   LBU V0, 16(S8)
9D023FE8  24420001   ADDIU V0, V0, 1
9D023FEC  A3C20010   SB V0, 16(S8)
9D023FF0  93C20010   LBU V0, 16(S8)
9D023FF4  2C420005   SLTIU V0, V0, 5
9D023FF8  1440FFD8   BNE V0, ZERO, 0x9D023F5C
9D023FFC  00000000   NOP
1066:                		{
1067:                			if(BSDSocketArray[i].bsdState != SKT_BSD_LISTEN)
9D023F5C  93C40010   LBU A0, 16(S8)
9D023F60  3C02A000   LUI V0, -24576
9D023F64  24433080   ADDIU V1, V0, 12416
9D023F68  2402001C   ADDIU V0, ZERO, 28
9D023F6C  70821002   MUL V0, A0, V0
9D023F70  00621021   ADDU V0, V1, V0
9D023F74  8C430004   LW V1, 4(V0)
9D023F78  24020003   ADDIU V0, ZERO, 3
9D023F7C  14620018   BNE V1, V0, 0x9D023FE0
9D023F80  00000000   NOP
1068:                				continue;
9D023FE0  00000000   NOP
1069:                			if(BSDSocketArray[i].localPort == socket->localPort)
9D023F84  93C40010   LBU A0, 16(S8)
9D023F88  3C02A000   LUI V0, -24576
9D023F8C  2403001C   ADDIU V1, ZERO, 28
9D023F90  70831802   MUL V1, A0, V1
9D023F94  24423080   ADDIU V0, V0, 12416
9D023F98  00621021   ADDU V0, V1, V0
9D023F9C  94430008   LHU V1, 8(V0)
9D023FA0  8FC20014   LW V0, 20(S8)
9D023FA4  94420008   LHU V0, 8(V0)
9D023FA8  1462000E   BNE V1, V0, 0x9D023FE4
9D023FAC  00000000   NOP
1070:                			{
1071:                				// Nothing to do if a disconnect has not occurred
1072:                				if(!bSocketWasReset)
9D023FB0  8FC20018   LW V0, 24(S8)
9D023FB4  14400004   BNE V0, ZERO, 0x9D023FC8
9D023FB8  00000000   NOP
1073:                					return FALSE;
9D023FBC  00001021   ADDU V0, ZERO, ZERO
9D023FC0  0B40900F   J 0x9D02403C
9D023FC4  00000000   NOP
1074:                
1075:                				// Listener socket is still open, so just return to the 
1076:                				// listening state so that the user must call accept() again to 
1077:                				// reuse this BSD socket
1078:                				socket->bsdState = SKT_LISTEN;
9D023FC8  8FC20014   LW V0, 20(S8)
9D023FCC  24030004   ADDIU V1, ZERO, 4
9D023FD0  AC430004   SW V1, 4(V0)
1079:                				return TRUE;
9D023FD4  24020001   ADDIU V0, ZERO, 1
9D023FD8  0B40900F   J 0x9D02403C
9D023FDC  00000000   NOP
1080:                			}
1081:                		}
1082:                	}
1083:                			
1084:                	// If we get down here and the socket was reset, then this socket 
1085:                	// should be closed so that no more clients can connect to it.  However, 
1086:                	// we can't go to the BSD SKT_CLOSED state directly since the user still 
1087:                	// has to call closesocket() with this s SOCKET descriptor first.
1088:                	if(bSocketWasReset)
9D024000  8FC20018   LW V0, 24(S8)
9D024004  1040000C   BEQ V0, ZERO, 0x9D024038
9D024008  00000000   NOP
1089:                	{
1090:                		TCPClose(socket->SocketID);
9D02400C  8FC20014   LW V0, 20(S8)
9D024010  90420018   LBU V0, 24(V0)
9D024014  00402021   ADDU A0, V0, ZERO
9D024018  0F40031D   JAL TCPClose
9D02401C  00000000   NOP
1091:                		socket->bsdState = SKT_DISCONNECTED;
9D024020  8FC20014   LW V0, 20(S8)
9D024024  24030007   ADDIU V1, ZERO, 7
9D024028  AC430004   SW V1, 4(V0)
1092:                		return TRUE;
9D02402C  24020001   ADDIU V0, ZERO, 1
9D024030  0B40900F   J 0x9D02403C
9D024034  00000000   NOP
1093:                	}
1094:                	
1095:                	return FALSE;
9D024038  00001021   ADDU V0, ZERO, ZERO
1096:                }
9D02403C  03C0E821   ADDU SP, S8, ZERO
9D024040  8FBF0024   LW RA, 36(SP)
9D024044  8FBE0020   LW S8, 32(SP)
9D024048  27BD0028   ADDIU SP, SP, 40
9D02404C  03E00008   JR RA
9D024050  00000000   NOP
1097:                
1098:                #endif //STACK_USE_BERKELEY_API
1099:                
---  C:/Users/Diego/Documents/GitHub/pic32webFREERtos/Pic32Web.X/src/tcpip/src/AutoIP.c  ----------------
1:                   /*********************************************************************
2:                    *
3:                    *	AutoIP Client 
4:                    *  Module for Microchip TCP/IP Stack
5:                    *	 -Provides AutoIP Code for automatically allocating a link-layer
6:                    *      address
7:                    *	
8:                    *	-Reference: RFC 3927   	
9:                    *********************************************************************
10:                   * FileName:        AutoIP.c
11:                   * Dependencies:    UDP, ARP
12:                   * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32
13:                   * Compiler:        Microchip C32 v1.05 or higher
14:                   *					Microchip C30 v3.12 or higher
15:                   *					Microchip C18 v3.30 or higher
16:                   *					HI-TECH PICC-18 PRO 9.63PL2 or higher
17:                   * Company:         Microchip Technology, Inc.
18:                   *
19:                   * Software License Agreement
20:                   *
21:                   * Copyright (C) 2009 Microchip Technology Inc.  All rights
22:                   * reserved.
23:                   *
24:                   * Microchip licenses to you the right to use, modify, copy, and
25:                   * distribute:
26:                   * (i)  the Software when embedded on a Microchip microcontroller or
27:                   *      digital signal controller product ("Device") which is
28:                   *      integrated into Licensee's product; or
29:                   * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h,
30:                   *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device
31:                   *		used in conjunction with a Microchip ethernet controller for
32:                   *		the sole purpose of interfacing with the ethernet controller.
33:                   *
34:                   * You should refer to the license agreement accompanying this
35:                   * Software for additional information regarding your rights and
36:                   * obligations.
37:                   *
38:                   * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT
39:                   * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT
40:                   * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A
41:                   * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL
42:                   * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR
43:                   * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF
44:                   * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS
45:                   * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE
46:                   * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER
47:                   * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT
48:                   * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE.
49:                   *
50:                   * Author               Date    	Comment
51:                   *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
52:                   * Peter Reen           7/10/09  	Original        (Rev 1.0)
53:                   ********************************************************************/
54:                  
55:                  #define __AUTOIP_C
56:                  
57:                  #include "TCPIPConfig.h"
58:                  
59:                  #if defined (STACK_USE_AUTO_IP)
60:                  
61:                  #include "TCPIP Stack/TCPIP.h"
62:                  
63:                  // Set of variables for each network interface
64:                  typedef struct
65:                  {
66:                      // Global state-tracker variable
67:                      SM_AUTOIP smAUTOIPState;
68:                      // Global backoff-time counter
69:                      DWORD gAutoIPConflictTimer;
70:                      // Records the last time at which an AutoIP event occured
71:                      DWORD eventTime;
72:                      // An ARP packet
73:                      ARP_PACKET packet;
74:                      // Holds the number of ticks needed for a random delay
75:                      DWORD randomDelay;
76:                      // The seed value for the RNG
77:                      DWORD wRandSeed;
78:                  
79:                  	union
80:                  	{
81:                  	    struct
82:                  	    {
83:                  	        unsigned char gDisableAutoIP : 1;   // Prevents AutoIP from initializing if the user wants a static address
84:                  	        unsigned char bConfigureAutoIP : 1;
85:                  	        unsigned char bLastLinkState : 1;
86:                  			unsigned char checkAddress : 1;
87:                  			unsigned char bCurrentLinkState : 1;
88:                              #if defined (STACK_USE_DHCP_CLIENT)
89:                                  unsigned char bLastDHCPState : 1;
90:                              #endif
91:                  	    } bits;
92:                  	    BYTE val;
93:                  	} flags;
94:                  
95:                  
96:                      BYTE conflicts;
97:                  } AUTOIP_CLIENT_VARS;
98:                  
99:                  // Prototypes
100:                 
101:                 void AutoIPRandSeed (DWORD seed, BYTE vInterface);
102:                 DWORD AutoIPRand (BYTE vInterface);
103:                 
104:                 
105:                 /*****************************************************************************
106:                   Function:
107:                 	static void LoadState(BYTE vInterface)
108:                 
109:                   Summary:
110:                 	Saves the AutoIP client state information structure to the appropriate 
111:                 	location and loads AutoIP client with the state information for the specified 
112:                 	interface.
113:                 
114:                   Description:
115:                 	Saves the AutoIP client state information structure to the appropriate 
116:                 	location and loads AutoIP client with the state information for the specified 
117:                 	interface.
118:                 
119:                   Precondition:
120:                 	None
121:                 
122:                   Parameters:
123:                 	None
124:                 
125:                   Returns:
126:                 	None
127:                 
128:                   Remarks:
129:                   	This function does nothing when you only have one physical interface.
130:                 ***************************************************************************/
131:                 #if NETWORK_INTERFACES > 1
132:                 
133:                 static AUTOIP_CLIENT_VARS	AutoIPClients[NETWORK_INTERFACES];
134:                 static AUTOIP_CLIENT_VARS	*SelectedAutoIPClient;
135:                 #define AutoIPClient		(*SelectedAutoIPClient)
136:                 #define LoadState(v)	do(SelectedAutoIPClient = &AutoIPClients[v])while(0)
137:                 
138:                 #else
139:                 
140:                 static AUTOIP_CLIENT_VARS AutoIPClient;
141:                 #define LoadState(v)
142:                 
143:                 #endif
144:                 
145:                 
146:                 /*****************************************************************************
147:                   Function:
148:                 	void AutoIPInit(BYTE vInterface)
149:                 
150:                   Summary:
151:                 	Resets the AutoIP client module for the specified interface.
152:                 
153:                   Description:
154:                 	Resets the AutoIP client module
155:                 
156:                   Precondition:
157:                 	None
158:                 
159:                   Parameters:
160:                 	vInterface - Interface number to initialize AutoIP client state variables 
161:                 		for.   If you only have one interface, specify 0x00.
162:                 
163:                   Returns:
164:                 	None
165:                 
166:                   Remarks:
167:                 	This function may be called multiple times throughout the life of the 
168:                 	application, if desired.  
169:                 ***************************************************************************/
170:                 
171:                 void AutoIPInit (BYTE vInterface)
172:                 {
9D02A4A4  27BDFFF8   ADDIU SP, SP, -8
9D02A4A8  AFBE0004   SW S8, 4(SP)
9D02A4AC  03A0F021   ADDU S8, SP, ZERO
9D02A4B0  00801021   ADDU V0, A0, ZERO
9D02A4B4  A3C20008   SB V0, 8(S8)
173:                     LoadState (vInterface);
174:                 
175:                     AutoIPClient.flags.bits.bConfigureAutoIP = FALSE;
9D02A4B8  3C02A000   LUI V0, -24576
9D02A4BC  24433220   ADDIU V1, V0, 12832
9D02A4C0  8C620030   LW V0, 48(V1)
9D02A4C4  7C020844   INS V0, ZERO, 1, 1
9D02A4C8  AC620030   SW V0, 48(V1)
176:                     AutoIPClient.smAUTOIPState = SM_AUTOIP_DISABLED;
9D02A4CC  3C02A000   LUI V0, -24576
9D02A4D0  AC403220   SW ZERO, 12832(V0)
177:                     AutoIPClient.gAutoIPConflictTimer = 0;
9D02A4D4  3C02A000   LUI V0, -24576
9D02A4D8  24423220   ADDIU V0, V0, 12832
9D02A4DC  AC400004   SW ZERO, 4(V0)
178:                     AutoIPClient.flags.bits.bLastLinkState = FALSE;
9D02A4E0  3C02A000   LUI V0, -24576
9D02A4E4  24433220   ADDIU V1, V0, 12832
9D02A4E8  8C620030   LW V0, 48(V1)
9D02A4EC  7C021084   INS V0, ZERO, 2, 1
9D02A4F0  AC620030   SW V0, 48(V1)
179:                     AutoIPClient.flags.bits.checkAddress = FALSE;
9D02A4F4  3C02A000   LUI V0, -24576
9D02A4F8  24433220   ADDIU V1, V0, 12832
9D02A4FC  8C620030   LW V0, 48(V1)
9D02A500  7C0218C4   INS V0, ZERO, 3, 1
9D02A504  AC620030   SW V0, 48(V1)
180:                     AutoIPClient.conflicts = 0;
9D02A508  3C02A000   LUI V0, -24576
9D02A50C  24423220   ADDIU V0, V0, 12832
9D02A510  A0400031   SB ZERO, 49(V0)
181:                     #if defined (STACK_USE_DHCP_CLIENT)
182:                         AutoIPClient.flags.bits.bLastDHCPState = FALSE;
9D02A514  3C02A000   LUI V0, -24576
9D02A518  24433220   ADDIU V1, V0, 12832
9D02A51C  8C620030   LW V0, 48(V1)
9D02A520  7C022944   INS V0, ZERO, 5, 1
9D02A524  AC620030   SW V0, 48(V1)
183:                     #endif
184:                 }
9D02A528  03C0E821   ADDU SP, S8, ZERO
9D02A52C  8FBE0004   LW S8, 4(SP)
9D02A530  27BD0008   ADDIU SP, SP, 8
9D02A534  03E00008   JR RA
9D02A538  00000000   NOP
185:                 
186:                 
187:                 /*****************************************************************************
188:                   Function:
189:                 	BOOL AutoIPIsConfigured (BYTE vInterface)
190:                 
191:                   Summary:
192:                 	Determines if the AutoIP interface has successfully claimed an IP address
193:                 
194:                   Description:
195:                 	Determines if the AutoIP interface has successfully claimed an IP address
196:                 
197:                   Precondition:
198:                 	None
199:                 
200:                   Parameters:
201:                 	vInterface - Interface number to check AutoIP configuration for. If you 
202:                         only have one interface, specify 0x00.
203:                 
204:                   Returns:
205:                 	TRUE - The AutoIP client has successfully claimed an IP address
206:                     FALSE - The AutoIP client has not claimed an IP address
207:                 
208:                   Remarks:
209:                     None
210:                 ***************************************************************************/
211:                 BOOL AutoIPIsConfigured (BYTE vInterface)
212:                 {
9D02A53C  27BDFFF8   ADDIU SP, SP, -8
9D02A540  AFBE0004   SW S8, 4(SP)
9D02A544  03A0F021   ADDU S8, SP, ZERO
9D02A548  00801021   ADDU V0, A0, ZERO
9D02A54C  A3C20008   SB V0, 8(S8)
213:                     LoadState(vInterface);
214:                     return (AutoIPClient.smAUTOIPState == SM_AUTOIP_CONFIGURED) ? TRUE : FALSE;
9D02A550  3C02A000   LUI V0, -24576
9D02A554  8C423220   LW V0, 12832(V0)
9D02A558  3842000A   XORI V0, V0, 10
9D02A55C  2C420001   SLTIU V0, V0, 1
215:                 }
9D02A560  03C0E821   ADDU SP, S8, ZERO
9D02A564  8FBE0004   LW S8, 4(SP)
9D02A568  27BD0008   ADDIU SP, SP, 8
9D02A56C  03E00008   JR RA
9D02A570  00000000   NOP
216:                 
217:                 /*****************************************************************************
218:                   Function:
219:                 	BOOL AutoIPConfigIsInProgress (BYTE vInterface)
220:                 
221:                   Summary:
222:                 	Determines if the AutoIP address is being configured
223:                 
224:                   Description:
225:                 	Determines if the AutoIP address is being configured
226:                 
227:                   Precondition:
228:                 	None
229:                 
230:                   Parameters:
231:                 	vInterface - Interface number to check AutoIP configuration for. If you 
232:                         only have one interface, specify 0x00.
233:                 
234:                   Returns:
235:                 	TRUE - The AutoIP client is being configured
236:                     FALSE - The AutoIP client is not in configuration mode
237:                 
238:                   Remarks:
239:                     None
240:                 ***************************************************************************/
241:                 BOOL AutoIPConfigIsInProgress (BYTE vInterface)
242:                 {
9D02A574  27BDFFF8   ADDIU SP, SP, -8
9D02A578  AFBE0004   SW S8, 4(SP)
9D02A57C  03A0F021   ADDU S8, SP, ZERO
9D02A580  00801021   ADDU V0, A0, ZERO
9D02A584  A3C20008   SB V0, 8(S8)
243:                     LoadState(vInterface);
244:                     return AutoIPClient.flags.bits.bConfigureAutoIP;
9D02A588  3C02A000   LUI V0, -24576
9D02A58C  24423220   ADDIU V0, V0, 12832
9D02A590  8C420030   LW V0, 48(V0)
9D02A594  7C420040   EXT V0, V0, 1, 1
9D02A598  304200FF   ANDI V0, V0, 255
245:                 }
9D02A59C  03C0E821   ADDU SP, S8, ZERO
9D02A5A0  8FBE0004   LW S8, 4(SP)
9D02A5A4  27BD0008   ADDIU SP, SP, 8
9D02A5A8  03E00008   JR RA
9D02A5AC  00000000   NOP
246:                 
247:                 /*****************************************************************************
248:                   Function:
249:                 	void AutoIPTasks(void)
250:                 
251:                   Summary:
252:                 	Performs periodic AutoIP tasks.
253:                 
254:                   Description:
255:                 	This function performs any periodic tasks requied by the AutoIP module, 
256:                 	such as re/transmitting gratuitous ARP packets and defending addresses
257:                 
258:                   Precondition:
259:                 	None
260:                 
261:                   Parameters:
262:                 	None
263:                 
264:                   Returns:
265:                 	None
266:                 ***************************************************************************/
267:                 
268:                 void AutoIPTasks(void)
269:                 {
9D02A5B0  27BDFFD0   ADDIU SP, SP, -48
9D02A5B4  AFBF002C   SW RA, 44(SP)
9D02A5B8  AFBE0028   SW S8, 40(SP)
9D02A5BC  AFB30024   SW S3, 36(SP)
9D02A5C0  AFB20020   SW S2, 32(SP)
9D02A5C4  AFB1001C   SW S1, 28(SP)
9D02A5C8  AFB00018   SW S0, 24(SP)
9D02A5CC  03A0F021   ADDU S8, SP, ZERO
270:                     BYTE i;
271:                 
272:                     for (i = 0; i < NETWORK_INTERFACES; i++)
9D02A5D0  A3C00010   SB ZERO, 16(S8)
9D02A5D4  0B40ABD8   J 0x9D02AF60
9D02A5D8  00000000   NOP
9D02AF54  93C20010   LBU V0, 16(S8)
9D02AF58  24420001   ADDIU V0, V0, 1
9D02AF5C  A3C20010   SB V0, 16(S8)
9D02AF60  93C20010   LBU V0, 16(S8)
9D02AF64  1040FD9D   BEQ V0, ZERO, 0x9D02A5DC
9D02AF68  00000000   NOP
273:                     {
274:                         LoadState (i);
275:                         AutoIPClient.flags.bits.bCurrentLinkState = MACIsLinked();
9D02A5DC  0F40726F   JAL MACIsLinked
9D02A5E0  00000000   NOP
9D02A5E4  304200FF   ANDI V0, V0, 255
9D02A5E8  30420001   ANDI V0, V0, 1
9D02A5EC  304400FF   ANDI A0, V0, 255
9D02A5F0  3C02A000   LUI V0, -24576
9D02A5F4  24433220   ADDIU V1, V0, 12832
9D02A5F8  8C620030   LW V0, 48(V1)
9D02A5FC  7C822104   INS V0, A0, 4, 1
9D02A600  AC620030   SW V0, 48(V1)
276:                     	if(AutoIPClient.flags.bits.bCurrentLinkState != AutoIPClient.flags.bits.bLastLinkState)
9D02A604  3C02A000   LUI V0, -24576
9D02A608  24423220   ADDIU V0, V0, 12832
9D02A60C  8C420030   LW V0, 48(V0)
9D02A610  7C420100   EXT V0, V0, 4, 1
9D02A614  304300FF   ANDI V1, V0, 255
9D02A618  3C02A000   LUI V0, -24576
9D02A61C  24423220   ADDIU V0, V0, 12832
9D02A620  8C420030   LW V0, 48(V0)
9D02A624  7C420080   EXT V0, V0, 2, 1
9D02A628  304200FF   ANDI V0, V0, 255
9D02A62C  1062002D   BEQ V1, V0, 0x9D02A6E4
9D02A630  00000000   NOP
277:                     	{
278:                     		AutoIPClient.flags.bits.bLastLinkState = AutoIPClient.flags.bits.bCurrentLinkState;
9D02A634  3C02A000   LUI V0, -24576
9D02A638  24423220   ADDIU V0, V0, 12832
9D02A63C  8C420030   LW V0, 48(V0)
9D02A640  7C420100   EXT V0, V0, 4, 1
9D02A644  304400FF   ANDI A0, V0, 255
9D02A648  3C02A000   LUI V0, -24576
9D02A64C  24433220   ADDIU V1, V0, 12832
9D02A650  8C620030   LW V0, 48(V1)
9D02A654  7C821084   INS V0, A0, 2, 1
9D02A658  AC620030   SW V0, 48(V1)
279:                     		if(!AutoIPClient.flags.bits.bCurrentLinkState)
9D02A65C  3C02A000   LUI V0, -24576
9D02A660  24423220   ADDIU V0, V0, 12832
9D02A664  8C420030   LW V0, 48(V0)
9D02A668  30420010   ANDI V0, V0, 16
9D02A66C  1440001A   BNE V0, ZERO, 0x9D02A6D8
9D02A670  00000000   NOP
280:                     		{
281:                                 AutoIPClient.flags.bits.bConfigureAutoIP = FALSE;
9D02A674  3C02A000   LUI V0, -24576
9D02A678  24433220   ADDIU V1, V0, 12832
9D02A67C  8C620030   LW V0, 48(V1)
9D02A680  7C020844   INS V0, ZERO, 1, 1
9D02A684  AC620030   SW V0, 48(V1)
282:                                 AutoIPClient.smAUTOIPState = SM_AUTOIP_DISABLED;
9D02A688  3C02A000   LUI V0, -24576
9D02A68C  AC403220   SW ZERO, 12832(V0)
283:                     			AppConfig.MyIPAddr.Val = AppConfig.DefaultIPAddr.Val;
9D02A690  3C02A000   LUI V0, -24576
9D02A694  24420728   ADDIU V0, V0, 1832
9D02A698  88430017   LWL V1, 23(V0)
9D02A69C  98430014   LWR V1, 20(V0)
9D02A6A0  3C02A000   LUI V0, -24576
9D02A6A4  24440728   ADDIU A0, V0, 1832
9D02A6A8  A8830003   SWL V1, 3(A0)
9D02A6AC  B8430728   SWR V1, 1832(V0)
284:                     			AppConfig.MyMask.Val = AppConfig.DefaultMask.Val;
9D02A6B0  3C02A000   LUI V0, -24576
9D02A6B4  24420728   ADDIU V0, V0, 1832
9D02A6B8  8843001B   LWL V1, 27(V0)
9D02A6BC  98430018   LWR V1, 24(V0)
9D02A6C0  3C02A000   LUI V0, -24576
9D02A6C4  24420728   ADDIU V0, V0, 1832
9D02A6C8  A8430007   SWL V1, 7(V0)
9D02A6CC  B8430004   SWR V1, 4(V0)
9D02A6D0  0B40A9B9   J 0x9D02A6E4
9D02A6D4  00000000   NOP
285:                     		}
286:                             else
287:                             {
288:                                 AutoIPClient.smAUTOIPState = SM_AUTOIP_INIT_RNG;
9D02A6D8  3C02A000   LUI V0, -24576
9D02A6DC  24030001   ADDIU V1, ZERO, 1
9D02A6E0  AC433220   SW V1, 12832(V0)
289:                             }
290:                     	}
291:                     
292:                         #if defined (STACK_USE_DHCP_CLIENT)
293:                         if (DHCPIsBound(i))
9D02A6E4  93C20010   LBU V0, 16(S8)
9D02A6E8  00402021   ADDU A0, V0, ZERO
9D02A6EC  0F409094   JAL DHCPIsBound
9D02A6F0  00000000   NOP
9D02A6F4  10400010   BEQ V0, ZERO, 0x9D02A738
9D02A6F8  00000000   NOP
294:                         {
295:                             AutoIPClient.flags.bits.bConfigureAutoIP = FALSE;
9D02A6FC  3C02A000   LUI V0, -24576
9D02A700  24433220   ADDIU V1, V0, 12832
9D02A704  8C620030   LW V0, 48(V1)
9D02A708  7C020844   INS V0, ZERO, 1, 1
9D02A70C  AC620030   SW V0, 48(V1)
296:                             AutoIPClient.smAUTOIPState = SM_AUTOIP_DISABLED;
9D02A710  3C02A000   LUI V0, -24576
9D02A714  AC403220   SW ZERO, 12832(V0)
297:                             AutoIPClient.flags.bits.bLastDHCPState = TRUE;
9D02A718  3C02A000   LUI V0, -24576
9D02A71C  24433220   ADDIU V1, V0, 12832
9D02A720  8C620030   LW V0, 48(V1)
9D02A724  24040001   ADDIU A0, ZERO, 1
9D02A728  7C822944   INS V0, A0, 5, 1
9D02A72C  AC620030   SW V0, 48(V1)
9D02A730  0B40A9E2   J 0x9D02A788
9D02A734  00000000   NOP
298:                         }
299:                         else
300:                         {
301:                             if (AutoIPClient.flags.bits.bLastDHCPState == TRUE)
9D02A738  3C02A000   LUI V0, -24576
9D02A73C  24423220   ADDIU V0, V0, 12832
9D02A740  8C420030   LW V0, 48(V0)
9D02A744  30420020   ANDI V0, V0, 32
9D02A748  1040000A   BEQ V0, ZERO, 0x9D02A774
9D02A74C  00000000   NOP
302:                             {
303:                                 if (AutoIPClient.flags.bits.bCurrentLinkState)
9D02A750  3C02A000   LUI V0, -24576
9D02A754  24423220   ADDIU V0, V0, 12832
9D02A758  8C420030   LW V0, 48(V0)
9D02A75C  30420010   ANDI V0, V0, 16
9D02A760  10400004   BEQ V0, ZERO, 0x9D02A774
9D02A764  00000000   NOP
304:                                     AutoIPClient.smAUTOIPState = SM_AUTOIP_INIT_RNG;
9D02A768  3C02A000   LUI V0, -24576
9D02A76C  24030001   ADDIU V1, ZERO, 1
9D02A770  AC433220   SW V1, 12832(V0)
305:                             }
306:                             AutoIPClient.flags.bits.bLastDHCPState = FALSE;
9D02A774  3C02A000   LUI V0, -24576
9D02A778  24433220   ADDIU V1, V0, 12832
9D02A77C  8C620030   LW V0, 48(V1)
9D02A780  7C022944   INS V0, ZERO, 5, 1
9D02A784  AC620030   SW V0, 48(V1)
307:                         }
308:                         #endif
309:                     
310:                     
311:                         if (AutoIPClient.flags.bits.gDisableAutoIP == TRUE)
9D02A788  3C02A000   LUI V0, -24576
9D02A78C  24423220   ADDIU V0, V0, 12832
9D02A790  8C420030   LW V0, 48(V0)
9D02A794  30420001   ANDI V0, V0, 1
9D02A798  10400008   BEQ V0, ZERO, 0x9D02A7BC
9D02A79C  00000000   NOP
312:                         {
313:                             AutoIPClient.flags.bits.bConfigureAutoIP = FALSE;
9D02A7A0  3C02A000   LUI V0, -24576
9D02A7A4  24433220   ADDIU V1, V0, 12832
9D02A7A8  8C620030   LW V0, 48(V1)
9D02A7AC  7C020844   INS V0, ZERO, 1, 1
9D02A7B0  AC620030   SW V0, 48(V1)
314:                             AutoIPClient.smAUTOIPState = SM_AUTOIP_DISABLED;
9D02A7B4  3C02A000   LUI V0, -24576
9D02A7B8  AC403220   SW ZERO, 12832(V0)
315:                         }
316:                     
317:                     
318:                         switch (AutoIPClient.smAUTOIPState)
9D02A7BC  3C02A000   LUI V0, -24576
9D02A7C0  8C423220   LW V0, 12832(V0)
9D02A7C4  2C43000C   SLTIU V1, V0, 12
9D02A7C8  106001E2   BEQ V1, ZERO, 0x9D02AF54
9D02A7CC  00000000   NOP
9D02A7D0  00021880   SLL V1, V0, 2
9D02A7D4  3C029D03   LUI V0, -25341
9D02A7D8  2442A7EC   ADDIU V0, V0, -22548
9D02A7DC  00621021   ADDU V0, V1, V0
9D02A7E0  8C420000   LW V0, 0(V0)
9D02A7E4  00400008   JR V0
9D02A7E8  00000000   NOP
319:                         {
320:                             // Default no-AutoIP case
321:                         	case SM_AUTOIP_DISABLED:
322:                 
323:                                 break;
9D02AF20  00000000   NOP
9D02AF24  0B40ABD5   J 0x9D02AF54
9D02AF28  00000000   NOP
324:                     
325:                             // Initializes the random number generator with a seed based on the MAC address
326:                             case SM_AUTOIP_INIT_RNG:
327:                                 AutoIPRandSeed (((DWORD)AppConfig.MyMACAddr.v[0] + ((DWORD)AppConfig.MyMACAddr.v[1] << 8) + \
9D02A81C  3C02A000   LUI V0, -24576
9D02A820  24420728   ADDIU V0, V0, 1832
9D02A824  9042002D   LBU V0, 45(V0)
9D02A828  00401821   ADDU V1, V0, ZERO
9D02A82C  3C02A000   LUI V0, -24576
9D02A830  24420728   ADDIU V0, V0, 1832
9D02A834  9042002E   LBU V0, 46(V0)
9D02A838  00021200   SLL V0, V0, 8
9D02A83C  00621821   ADDU V1, V1, V0
9D02A850  00621821   ADDU V1, V1, V0
9D02A888  00621821   ADDU V1, V1, V0
9D02A88C  93C20010   LBU V0, 16(S8)
9D02A890  00602021   ADDU A0, V1, ZERO
9D02A894  00402821   ADDU A1, V0, ZERO
9D02A898  0F40AC8B   JAL AutoIPRandSeed
9D02A89C  00000000   NOP
328:                                         ((DWORD)AppConfig.MyMACAddr.v[2] << 16) + ((DWORD)AppConfig.MyMACAddr.v[3] << 24) + \
9D02A840  3C02A000   LUI V0, -24576
9D02A844  24420728   ADDIU V0, V0, 1832
9D02A848  9042002F   LBU V0, 47(V0)
9D02A84C  00021400   SLL V0, V0, 16
9D02A854  3C02A000   LUI V0, -24576
9D02A858  24420728   ADDIU V0, V0, 1832
9D02A85C  90420030   LBU V0, 48(V0)
9D02A860  00021600   SLL V0, V0, 24
9D02A864  00621821   ADDU V1, V1, V0
9D02A874  00621821   ADDU V1, V1, V0
329:                                         ((DWORD)AppConfig.MyMACAddr.v[4]) + ((DWORD)AppConfig.MyMACAddr.v[5] << 8)), i);
9D02A868  3C02A000   LUI V0, -24576
9D02A86C  24420728   ADDIU V0, V0, 1832
9D02A870  90420031   LBU V0, 49(V0)
9D02A878  3C02A000   LUI V0, -24576
9D02A87C  24420728   ADDIU V0, V0, 1832
9D02A880  90420032   LBU V0, 50(V0)
9D02A884  00021200   SLL V0, V0, 8
330:                     
331:                                 AutoIPClient.smAUTOIPState = SM_AUTOIP_CHECK_ADDRESS;
9D02A8A0  3C02A000   LUI V0, -24576
9D02A8A4  24030002   ADDIU V1, ZERO, 2
9D02A8A8  AC433220   SW V1, 12832(V0)
332:                     
333:                             // Check the address to see if it's in use before we write it into AppConfig
334:                             case SM_AUTOIP_CHECK_ADDRESS:
335:                     
336:                                 if (AutoIPClient.flags.bits.checkAddress == FALSE)
9D02A8AC  3C02A000   LUI V0, -24576
9D02A8B0  24423220   ADDIU V0, V0, 12832
9D02A8B4  8C420030   LW V0, 48(V0)
9D02A8B8  30420008   ANDI V0, V0, 8
9D02A8BC  14400030   BNE V0, ZERO, 0x9D02A980
9D02A8C0  00000000   NOP
337:                                 {
338:                                     AutoIPClient.flags.bits.checkAddress = TRUE;
9D02A8C4  3C02A000   LUI V0, -24576
9D02A8C8  24433220   ADDIU V1, V0, 12832
9D02A8CC  8C620030   LW V0, 48(V1)
9D02A8D0  24040001   ADDIU A0, ZERO, 1
9D02A8D4  7C8218C4   INS V0, A0, 3, 1
9D02A8D8  AC620030   SW V0, 48(V1)
339:                     
340:                                     AppConfig.MyMask.Val = 0x00000000;
9D02A8DC  3C02A000   LUI V0, -24576
9D02A8E0  24420728   ADDIU V0, V0, 1832
9D02A8E4  A8400007   SWL ZERO, 7(V0)
9D02A8E8  B8400004   SWR ZERO, 4(V0)
341:                     
342:                                     // Generate a random IP address (based on the MAC address) to try and claim.
343:                                     // Dynamic link-local addresses can fall within the range:
344:                                     // 169.254.1.0 - 169.254.254.255
345:                                     AutoIPClient.packet.TargetIPAddr.byte.MB = AutoIPRand(i) % 256;
9D02A8EC  93C20010   LBU V0, 16(S8)
9D02A8F0  00402021   ADDU A0, V0, ZERO
9D02A8F4  0F40AC9A   JAL AutoIPRand
9D02A8F8  00000000   NOP
9D02A8FC  304300FF   ANDI V1, V0, 255
9D02A900  3C02A000   LUI V0, -24576
9D02A904  24423220   ADDIU V0, V0, 12832
9D02A908  A0430027   SB V1, 39(V0)
346:                                     AutoIPClient.packet.TargetIPAddr.byte.UB = (AutoIPRand(i) % 254) + 1;
9D02A90C  93C20010   LBU V0, 16(S8)
9D02A910  00402021   ADDU A0, V0, ZERO
9D02A914  0F40AC9A   JAL AutoIPRand
9D02A918  00000000   NOP
9D02A91C  00401821   ADDU V1, V0, ZERO
9D02A920  240200FE   ADDIU V0, ZERO, 254
9D02A924  0062001B   DIVU V1, V0
9D02A928  004001F4   TEQ V0, ZERO
9D02A92C  00001010   MFHI V0, 0
9D02A930  304200FF   ANDI V0, V0, 255
9D02A934  24420001   ADDIU V0, V0, 1
9D02A938  304300FF   ANDI V1, V0, 255
9D02A93C  3C02A000   LUI V0, -24576
9D02A940  24423220   ADDIU V0, V0, 12832
9D02A944  A0430026   SB V1, 38(V0)
347:                                     AutoIPClient.packet.TargetIPAddr.word.LW = 0xFEA9;
9D02A948  3C02A000   LUI V0, -24576
9D02A94C  24423220   ADDIU V0, V0, 12832
9D02A950  2403FEA9   ADDIU V1, ZERO, -343
9D02A954  A4430024   SH V1, 36(V0)
348:                     
349:                                     ARPResolve (&AutoIPClient.packet.TargetIPAddr);
9D02A958  3C02A000   LUI V0, -24576
9D02A95C  24443244   ADDIU A0, V0, 12868
9D02A960  0F40BCC0   JAL ARPResolve
9D02A964  00000000   NOP
350:                     
351:                                     AutoIPClient.eventTime = TickGet();
9D02A968  0F40CDD6   JAL TickGet
9D02A96C  00000000   NOP
9D02A970  00401821   ADDU V1, V0, ZERO
9D02A974  3C02A000   LUI V0, -24576
9D02A978  24423220   ADDIU V0, V0, 12832
9D02A97C  AC430008   SW V1, 8(V0)
352:                                 }
353:                                 
354:                                 if (!ARPIsResolved (&AutoIPClient.packet.TargetIPAddr, &AutoIPClient.packet.TargetMACAddr))
9D02A980  3C02A000   LUI V0, -24576
9D02A984  24443244   ADDIU A0, V0, 12868
9D02A988  3C02A000   LUI V0, -24576
9D02A98C  2445323E   ADDIU A1, V0, 12862
9D02A990  0F40BCF9   JAL ARPIsResolved
9D02A994  00000000   NOP
9D02A998  14400012   BNE V0, ZERO, 0x9D02A9E4
9D02A99C  00000000   NOP
355:                                 {
356:                                     if (TickGet() - AutoIPClient.eventTime > TICK_SECOND)
9D02A9A0  0F40CDD6   JAL TickGet
9D02A9A4  00000000   NOP
9D02A9A8  00401821   ADDU V1, V0, ZERO
9D02A9AC  3C02A000   LUI V0, -24576
9D02A9B0  24423220   ADDIU V0, V0, 12832
9D02A9B4  8C420008   LW V0, 8(V0)
9D02A9B8  00621823   SUBU V1, V1, V0
9D02A9BC  3C020002   LUI V0, 2
9D02A9C0  3442625B   ORI V0, V0, 25179
9D02A9C4  0062102B   SLTU V0, V1, V0
9D02A9C8  14400158   BNE V0, ZERO, 0x9D02AF2C
9D02A9CC  00000000   NOP
357:                                     {
358:                                         AutoIPClient.smAUTOIPState = SM_AUTOIP_SETUP_MESSAGE;
9D02A9D0  3C02A000   LUI V0, -24576
9D02A9D4  24030003   ADDIU V1, ZERO, 3
9D02A9D8  AC433220   SW V1, 12832(V0)
359:                                     }
360:                                 }
361:                                 else
362:                                 {
363:                                     AutoIPClient.flags.bits.checkAddress = FALSE;
9D02A9E4  3C02A000   LUI V0, -24576
9D02A9E8  24433220   ADDIU V1, V0, 12832
9D02A9EC  8C620030   LW V0, 48(V1)
9D02A9F0  7C0218C4   INS V0, ZERO, 3, 1
9D02A9F4  AC620030   SW V0, 48(V1)
364:                                 }
365:                     
366:                                 break;
9D02A9DC  0B40ABD5   J 0x9D02AF54
9D02A9E0  00000000   NOP
9D02A9F8  0B40ABD5   J 0x9D02AF54
9D02A9FC  00000000   NOP
9D02AF2C  00000000   NOP
9D02AF30  0B40ABD5   J 0x9D02AF54
9D02AF34  00000000   NOP
367:                     
368:                             // Set up an ARP packet
369:                             case SM_AUTOIP_SETUP_MESSAGE:
370:                     
371:                                 AutoIPClient.flags.bits.checkAddress = FALSE;
9D02AA00  3C02A000   LUI V0, -24576
9D02AA04  24433220   ADDIU V1, V0, 12832
9D02AA08  8C620030   LW V0, 48(V1)
9D02AA0C  7C0218C4   INS V0, ZERO, 3, 1
9D02AA10  AC620030   SW V0, 48(V1)
372:                     
373:                                 // Set the bConfigureAutoIP flag- This flag will cause an AutoIP conflict
374:                                 // if a response packet is received from the address we're trying to claim.
375:                                 AutoIPClient.flags.bits.bConfigureAutoIP = TRUE;
9D02AA14  3C02A000   LUI V0, -24576
9D02AA18  24433220   ADDIU V1, V0, 12832
9D02AA1C  8C620030   LW V0, 48(V1)
9D02AA20  24040001   ADDIU A0, ZERO, 1
9D02AA24  7C820844   INS V0, A0, 1, 1
9D02AA28  AC620030   SW V0, 48(V1)
376:                     
377:                                 // Configure the fields for a gratuitous ARP packet
378:                             	AutoIPClient.packet.Operation            = ARP_OPERATION_REQ;
9D02AA2C  3C02A000   LUI V0, -24576
9D02AA30  24423220   ADDIU V0, V0, 12832
9D02AA34  24030001   ADDIU V1, ZERO, 1
9D02AA38  A4430012   SH V1, 18(V0)
379:                             
380:                             	AutoIPClient.packet.TargetMACAddr.v[0]   = 0xff;
9D02AA3C  3C02A000   LUI V0, -24576
9D02AA40  24423220   ADDIU V0, V0, 12832
9D02AA44  2403FFFF   ADDIU V1, ZERO, -1
9D02AA48  A043001E   SB V1, 30(V0)
381:                             	AutoIPClient.packet.TargetMACAddr.v[1]   = 0xff;
9D02AA4C  3C02A000   LUI V0, -24576
9D02AA50  24423220   ADDIU V0, V0, 12832
9D02AA54  2403FFFF   ADDIU V1, ZERO, -1
9D02AA58  A043001F   SB V1, 31(V0)
382:                             	AutoIPClient.packet.TargetMACAddr.v[2]   = 0xff;
9D02AA5C  3C02A000   LUI V0, -24576
9D02AA60  24423220   ADDIU V0, V0, 12832
9D02AA64  2403FFFF   ADDIU V1, ZERO, -1
9D02AA68  A0430020   SB V1, 32(V0)
383:                             	AutoIPClient.packet.TargetMACAddr.v[3]   = 0xff;
9D02AA6C  3C02A000   LUI V0, -24576
9D02AA70  24423220   ADDIU V0, V0, 12832
9D02AA74  2403FFFF   ADDIU V1, ZERO, -1
9D02AA78  A0430021   SB V1, 33(V0)
384:                             	AutoIPClient.packet.TargetMACAddr.v[4]   = 0xff;
9D02AA7C  3C02A000   LUI V0, -24576
9D02AA80  24423220   ADDIU V0, V0, 12832
9D02AA84  2403FFFF   ADDIU V1, ZERO, -1
9D02AA88  A0430022   SB V1, 34(V0)
385:                             	AutoIPClient.packet.TargetMACAddr.v[5]   = 0xff;
9D02AA8C  3C02A000   LUI V0, -24576
9D02AA90  24423220   ADDIU V0, V0, 12832
9D02AA94  2403FFFF   ADDIU V1, ZERO, -1
9D02AA98  A0430023   SB V1, 35(V0)
386:                     
387:                                 AppConfig.MyIPAddr = AutoIPClient.packet.TargetIPAddr;
9D02AA9C  3C02A000   LUI V0, -24576
9D02AAA0  3C03A000   LUI V1, -24576
9D02AAA4  24633220   ADDIU V1, V1, 12832
9D02AAA8  8C630024   LW V1, 36(V1)
9D02AAAC  24440728   ADDIU A0, V0, 1832
9D02AAB0  A8830003   SWL V1, 3(A0)
9D02AAB4  B8430728   SWR V1, 1832(V0)
388:                                 AppConfig.MyMask.Val = 0x0000FFFF;
9D02AAB8  3C02A000   LUI V0, -24576
9D02AABC  24420728   ADDIU V0, V0, 1832
9D02AAC0  3403FFFF   ORI V1, ZERO, -1
9D02AAC4  A8430007   SWL V1, 7(V0)
9D02AAC8  B8430004   SWR V1, 4(V0)
389:                             	memcpy(&AutoIPClient.packet.SenderMACAddr, (void*)&AppConfig.MyMACAddr, sizeof(AutoIPClient.packet.SenderMACAddr));
9D02AACC  3C02A000   LUI V0, -24576
9D02AAD0  24443234   ADDIU A0, V0, 12852
9D02AAD4  3C02A000   LUI V0, -24576
9D02AAD8  24450755   ADDIU A1, V0, 1877
9D02AADC  24060006   ADDIU A2, ZERO, 6
9D02AAE0  0F40D298   JAL 0x9D034A60
9D02AAE4  00000000   NOP
390:                                 AutoIPClient.packet.HardwareType  = HW_ETHERNET;
9D02AAE8  3C02A000   LUI V0, -24576
9D02AAEC  24423220   ADDIU V0, V0, 12832
9D02AAF0  24030001   ADDIU V1, ZERO, 1
9D02AAF4  A443000C   SH V1, 12(V0)
391:                                 AutoIPClient.packet.Protocol      = ARP_IP;
9D02AAF8  3C02A000   LUI V0, -24576
9D02AAFC  24423220   ADDIU V0, V0, 12832
9D02AB00  24030800   ADDIU V1, ZERO, 2048
9D02AB04  A443000E   SH V1, 14(V0)
392:                                 AutoIPClient.packet.MACAddrLen    = sizeof(MAC_ADDR);
9D02AB08  3C02A000   LUI V0, -24576
9D02AB0C  24423220   ADDIU V0, V0, 12832
9D02AB10  24030006   ADDIU V1, ZERO, 6
9D02AB14  A0430010   SB V1, 16(V0)
393:                                 AutoIPClient.packet.ProtocolLen   = sizeof(IP_ADDR);
9D02AB18  3C02A000   LUI V0, -24576
9D02AB1C  24423220   ADDIU V0, V0, 12832
9D02AB20  24030004   ADDIU V1, ZERO, 4
9D02AB24  A0430011   SB V1, 17(V0)
394:                                 AutoIPClient.packet.SenderIPAddr.Val  = AutoIPClient.packet.TargetIPAddr.Val;
9D02AB28  3C02A000   LUI V0, -24576
9D02AB2C  24423220   ADDIU V0, V0, 12832
9D02AB30  8C430024   LW V1, 36(V0)
9D02AB34  3C02A000   LUI V0, -24576
9D02AB38  24423220   ADDIU V0, V0, 12832
9D02AB3C  A843001D   SWL V1, 29(V0)
9D02AB40  B843001A   SWR V1, 26(V0)
395:                     
396:                                 SwapARPPacket(&AutoIPClient.packet);
9D02AB44  3C02A000   LUI V0, -24576
9D02AB48  2444322C   ADDIU A0, V0, 12844
9D02AB4C  0F40BD31   JAL SwapARPPacket
9D02AB50  00000000   NOP
397:                     
398:                                 // Generate a random delay between 0 and 1 second
399:                                 AutoIPClient.randomDelay = ((LFSRRand() % 20) * TICK_SECOND) / 20;
9D02AB54  0F40960D   JAL LFSRRand
9D02AB58  00000000   NOP
9D02AB5C  00401821   ADDU V1, V0, ZERO
9D02AB60  24020014   ADDIU V0, ZERO, 20
9D02AB64  0062001B   DIVU V1, V0
9D02AB68  004001F4   TEQ V0, ZERO
9D02AB6C  00001010   MFHI V0, 0
9D02AB70  3042FFFF   ANDI V0, V0, -1
9D02AB74  00408021   ADDU S0, V0, ZERO
9D02AB78  00008821   ADDU S1, ZERO, ZERO
9D02AB7C  3C020002   LUI V0, 2
9D02AB80  3442625A   ORI V0, V0, 25178
9D02AB84  72222002   MUL A0, S1, V0
9D02AB88  00001021   ADDU V0, ZERO, ZERO
9D02AB8C  72021002   MUL V0, S0, V0
9D02AB90  00822021   ADDU A0, A0, V0
9D02AB94  3C020002   LUI V0, 2
9D02AB98  3442625A   ORI V0, V0, 25178
9D02AB9C  02020019   MULTU 0, S0, V0
9D02ABA0  00001012   MFLO V0, 0
9D02ABA4  00001810   MFHI V1, 0
9D02ABA8  00832021   ADDU A0, A0, V1
9D02ABAC  00801821   ADDU V1, A0, ZERO
9D02ABB0  00402021   ADDU A0, V0, ZERO
9D02ABB4  00602821   ADDU A1, V1, ZERO
9D02ABB8  24060014   ADDIU A2, ZERO, 20
9D02ABBC  00003821   ADDU A3, ZERO, ZERO
9D02ABC0  0F40C887   JAL __udivdi3
9D02ABC4  00000000   NOP
9D02ABC8  00401821   ADDU V1, V0, ZERO
9D02ABCC  3C02A000   LUI V0, -24576
9D02ABD0  24423220   ADDIU V0, V0, 12832
9D02ABD4  AC430028   SW V1, 40(V0)
400:                                 // Store the current time
401:                                 AutoIPClient.eventTime = TickGet();
9D02ABD8  0F40CDD6   JAL TickGet
9D02ABDC  00000000   NOP
9D02ABE0  00401821   ADDU V1, V0, ZERO
9D02ABE4  3C02A000   LUI V0, -24576
9D02ABE8  24423220   ADDIU V0, V0, 12832
9D02ABEC  AC430008   SW V1, 8(V0)
402:                     
403:                                 // Set the state to send the ARP packet
404:                                 AutoIPClient.smAUTOIPState = SM_AUTOIP_GRATUITOUS_ARP1;
9D02ABF0  3C02A000   LUI V0, -24576
9D02ABF4  24030004   ADDIU V1, ZERO, 4
9D02ABF8  AC433220   SW V1, 12832(V0)
405:                     
406:                                 break;
9D02ABFC  0B40ABD5   J 0x9D02AF54
9D02AC00  00000000   NOP
407:                     
408:                             // Send a gratuitous ARP packet to try and claim our address
409:                             case SM_AUTOIP_GRATUITOUS_ARP1:
410:                             case SM_AUTOIP_GRATUITOUS_ARP2:
411:                             case SM_AUTOIP_GRATUITOUS_ARP3:
412:                                 // Check to ensure we've passed the delay time
413:                                 if (TickGet() - AutoIPClient.eventTime > AutoIPClient.randomDelay)
9D02AC04  0F40CDD6   JAL TickGet
9D02AC08  00000000   NOP
9D02AC0C  00401821   ADDU V1, V0, ZERO
9D02AC10  3C02A000   LUI V0, -24576
9D02AC14  24423220   ADDIU V0, V0, 12832
9D02AC18  8C420008   LW V0, 8(V0)
9D02AC1C  00621823   SUBU V1, V1, V0
9D02AC20  3C02A000   LUI V0, -24576
9D02AC24  24423220   ADDIU V0, V0, 12832
9D02AC28  8C420028   LW V0, 40(V0)
9D02AC2C  0043102B   SLTU V0, V0, V1
9D02AC30  104000C1   BEQ V0, ZERO, 0x9D02AF38
9D02AC34  00000000   NOP
414:                                 {
415:                                     // Store the new event time
416:                                     AutoIPClient.eventTime = TickGet();
9D02AC38  0F40CDD6   JAL TickGet
9D02AC3C  00000000   NOP
9D02AC40  00401821   ADDU V1, V0, ZERO
9D02AC44  3C02A000   LUI V0, -24576
9D02AC48  24423220   ADDIU V0, V0, 12832
9D02AC4C  AC430008   SW V1, 8(V0)
417:                                     // Generate a new random delay between 1 and 2 seconds
418:                                     AutoIPClient.randomDelay = TICK_SECOND + (((LFSRRand() % 20) * TICK_SECOND) / 20);
9D02AC50  0F40960D   JAL LFSRRand
9D02AC54  00000000   NOP
9D02AC58  3C03CCCC   LUI V1, -13108
9D02AC5C  3463CCCD   ORI V1, V1, -13107
9D02AC60  00430019   MULTU 0, V0, V1
9D02AC64  00002012   MFLO A0, 0
9D02AC68  00002810   MFHI A1, 0
9D02AC6C  00052102   SRL A0, A1, 4
9D02AC70  24030014   ADDIU V1, ZERO, 20
9D02AC74  70831802   MUL V1, A0, V1
9D02AC78  00431023   SUBU V0, V0, V1
9D02AC7C  3042FFFF   ANDI V0, V0, -1
9D02AC80  00409021   ADDU S2, V0, ZERO
9D02AC84  00009821   ADDU S3, ZERO, ZERO
9D02AC88  3C020002   LUI V0, 2
9D02AC8C  3442625A   ORI V0, V0, 25178
9D02AC90  72622002   MUL A0, S3, V0
9D02AC94  00001021   ADDU V0, ZERO, ZERO
9D02AC98  72421002   MUL V0, S2, V0
9D02AC9C  00822021   ADDU A0, A0, V0
9D02ACA0  3C020002   LUI V0, 2
9D02ACA4  3442625A   ORI V0, V0, 25178
9D02ACA8  02420019   MULTU 0, S2, V0
9D02ACAC  00001012   MFLO V0, 0
9D02ACB0  00001810   MFHI V1, 0
9D02ACB4  00832021   ADDU A0, A0, V1
9D02ACB8  00801821   ADDU V1, A0, ZERO
9D02ACBC  00402021   ADDU A0, V0, ZERO
9D02ACC0  00602821   ADDU A1, V1, ZERO
9D02ACC4  24060014   ADDIU A2, ZERO, 20
9D02ACC8  00003821   ADDU A3, ZERO, ZERO
9D02ACCC  0F40C887   JAL __udivdi3
9D02ACD0  00000000   NOP
9D02ACD4  00401821   ADDU V1, V0, ZERO
9D02ACD8  3C020002   LUI V0, 2
9D02ACDC  3442625A   ORI V0, V0, 25178
9D02ACE0  00621821   ADDU V1, V1, V0
9D02ACE4  3C02A000   LUI V0, -24576
9D02ACE8  24423220   ADDIU V0, V0, 12832
9D02ACEC  AC430028   SW V1, 40(V0)
419:                     
420:                                     // Transmit the packet
421:                                 	while(!MACIsTxReady());
9D02ACF0  00000000   NOP
9D02ACF4  0F40727E   JAL MACIsTxReady
9D02ACF8  00000000   NOP
9D02ACFC  1040FFFD   BEQ V0, ZERO, 0x9D02ACF4
9D02AD00  00000000   NOP
422:                                 	MACSetWritePtr(BASE_TX_ADDR);
9D02AD04  00002021   ADDU A0, ZERO, ZERO
9D02AD08  0F407410   JAL MACSetWritePtr
9D02AD0C  00000000   NOP
423:                     
424:                                     MACPutHeader(&AutoIPClient.packet.TargetMACAddr, MAC_ARP, sizeof(AutoIPClient.packet));
9D02AD10  3C02A000   LUI V0, -24576
9D02AD14  2444323E   ADDIU A0, V0, 12862
9D02AD18  24050006   ADDIU A1, ZERO, 6
9D02AD1C  2406001C   ADDIU A2, ZERO, 28
9D02AD20  0F407380   JAL MACPutHeader
9D02AD24  00000000   NOP
425:                                     MACPutArray((BYTE*)&AutoIPClient.packet, sizeof(AutoIPClient.packet));
9D02AD28  3C02A000   LUI V0, -24576
9D02AD2C  2442322C   ADDIU V0, V0, 12844
9D02AD30  00402021   ADDU A0, V0, ZERO
9D02AD34  2405001C   ADDIU A1, ZERO, 28
9D02AD38  0F40759D   JAL MACPutArray
9D02AD3C  00000000   NOP
426:                                     MACFlush();
9D02AD40  0F4073B4   JAL MACFlush
9D02AD44  00000000   NOP
427:                     
428:                                     // Increment the probe iteration or increment to the delay state
429:                                     AutoIPClient.smAUTOIPState++;
9D02AD48  3C02A000   LUI V0, -24576
9D02AD4C  8C423220   LW V0, 12832(V0)
9D02AD50  24430001   ADDIU V1, V0, 1
9D02AD54  3C02A000   LUI V0, -24576
9D02AD58  AC433220   SW V1, 12832(V0)
430:                                 }
431:                                 break;
9D02AD5C  0B40ABD5   J 0x9D02AF54
9D02AD60  00000000   NOP
9D02AF38  00000000   NOP
9D02AF3C  0B40ABD5   J 0x9D02AF54
9D02AF40  00000000   NOP
432:                     
433:                             // Delay for 1-2 seconds after sending the third ARP request before
434:                             // entering the configured state
435:                             case SM_AUTOIP_DELAY:
436:                                 if (TickGet() - AutoIPClient.eventTime > AutoIPClient.randomDelay)
9D02AD64  0F40CDD6   JAL TickGet
9D02AD68  00000000   NOP
9D02AD6C  00401821   ADDU V1, V0, ZERO
9D02AD70  3C02A000   LUI V0, -24576
9D02AD74  24423220   ADDIU V0, V0, 12832
9D02AD78  8C420008   LW V0, 8(V0)
9D02AD7C  00621823   SUBU V1, V1, V0
9D02AD80  3C02A000   LUI V0, -24576
9D02AD84  24423220   ADDIU V0, V0, 12832
9D02AD88  8C420028   LW V0, 40(V0)
9D02AD8C  0043102B   SLTU V0, V0, V1
9D02AD90  1040006C   BEQ V0, ZERO, 0x9D02AF44
9D02AD94  00000000   NOP
437:                                     AutoIPClient.smAUTOIPState = SM_AUTOIP_CONFIGURED;
9D02AD98  3C02A000   LUI V0, -24576
9D02AD9C  2403000A   ADDIU V1, ZERO, 10
9D02ADA0  AC433220   SW V1, 12832(V0)
438:                                 break;
9D02ADA4  0B40ABD5   J 0x9D02AF54
9D02ADA8  00000000   NOP
9D02AF44  00000000   NOP
9D02AF48  0B40ABD5   J 0x9D02AF54
9D02AF4C  00000000   NOP
439:                     
440:                             // Configure the module to limit the rate at which packets are sent
441:                             case SM_AUTOIP_RATE_LIMIT_SET:
442:                                 AutoIPClient.eventTime = TickGet();
9D02ADAC  0F40CDD6   JAL TickGet
9D02ADB0  00000000   NOP
9D02ADB4  00401821   ADDU V1, V0, ZERO
9D02ADB8  3C02A000   LUI V0, -24576
9D02ADBC  24423220   ADDIU V0, V0, 12832
9D02ADC0  AC430008   SW V1, 8(V0)
443:                                 AppConfig.MyIPAddr.v[0] = MY_DEFAULT_IP_ADDR_BYTE1;
9D02ADC4  3C02A000   LUI V0, -24576
9D02ADC8  2403FFA9   ADDIU V1, ZERO, -87
9D02ADCC  A0430728   SB V1, 1832(V0)
444:                                 AppConfig.MyIPAddr.v[1] = MY_DEFAULT_IP_ADDR_BYTE2;
9D02ADD0  3C02A000   LUI V0, -24576
9D02ADD4  24420728   ADDIU V0, V0, 1832
9D02ADD8  2403FFFE   ADDIU V1, ZERO, -2
9D02ADDC  A0430001   SB V1, 1(V0)
445:                                 AppConfig.MyIPAddr.v[2] = MY_DEFAULT_IP_ADDR_BYTE3;
9D02ADE0  3C02A000   LUI V0, -24576
9D02ADE4  24420728   ADDIU V0, V0, 1832
9D02ADE8  24030001   ADDIU V1, ZERO, 1
9D02ADEC  A0430002   SB V1, 2(V0)
446:                                 AppConfig.MyIPAddr.v[3] = MY_DEFAULT_IP_ADDR_BYTE4;
9D02ADF0  3C02A000   LUI V0, -24576
9D02ADF4  24420728   ADDIU V0, V0, 1832
9D02ADF8  24030001   ADDIU V1, ZERO, 1
9D02ADFC  A0430003   SB V1, 3(V0)
447:                                 AutoIPClient.smAUTOIPState = SM_AUTOIP_RATE_LIMIT_WAIT;
9D02AE00  3C02A000   LUI V0, -24576
9D02AE04  24030009   ADDIU V1, ZERO, 9
9D02AE08  AC433220   SW V1, 12832(V0)
448:                                 break;
9D02AE0C  0B40ABD5   J 0x9D02AF54
9D02AE10  00000000   NOP
449:                     
450:                             // Ensure that we don't try more than one address every 60 seconds
451:                             case SM_AUTOIP_RATE_LIMIT_WAIT:
452:                                 if (TickGet() - AutoIPClient.eventTime > TICK_SECOND * 60)
9D02AE14  0F40CDD6   JAL TickGet
9D02AE18  00000000   NOP
9D02AE1C  00401821   ADDU V1, V0, ZERO
9D02AE20  3C02A000   LUI V0, -24576
9D02AE24  24423220   ADDIU V0, V0, 12832
9D02AE28  8C420008   LW V0, 8(V0)
9D02AE2C  00621823   SUBU V1, V1, V0
9D02AE30  3C02008F   LUI V0, 143
9D02AE34  34420D19   ORI V0, V0, 3353
9D02AE38  0062102B   SLTU V0, V1, V0
9D02AE3C  14400044   BNE V0, ZERO, 0x9D02AF50
9D02AE40  00000000   NOP
453:                                     AutoIPClient.smAUTOIPState = SM_AUTOIP_CHECK_ADDRESS;
9D02AE44  3C02A000   LUI V0, -24576
9D02AE48  24030002   ADDIU V1, ZERO, 2
9D02AE4C  AC433220   SW V1, 12832(V0)
454:                                 break;
9D02AE50  0B40ABD5   J 0x9D02AF54
9D02AE54  00000000   NOP
9D02AF50  00000000   NOP
455:                     
456:                             // Configured state
457:                             case SM_AUTOIP_CONFIGURED:
458:                                 AutoIPClient.flags.bits.bConfigureAutoIP = FALSE;
9D02AE58  3C02A000   LUI V0, -24576
9D02AE5C  24433220   ADDIU V1, V0, 12832
9D02AE60  8C620030   LW V0, 48(V1)
9D02AE64  7C020844   INS V0, ZERO, 1, 1
9D02AE68  AC620030   SW V0, 48(V1)
459:                                 break;
9D02AE6C  0B40ABD5   J 0x9D02AF54
9D02AE70  00000000   NOP
460:                     
461:                             // Address defense state
462:                             case SM_AUTOIP_DEFEND:
463:                                 // Prepare and send an ARP response
464:                                 AutoIPClient.packet.Operation     = ARP_OPERATION_RESP;
9D02AE74  3C02A000   LUI V0, -24576
9D02AE78  24423220   ADDIU V0, V0, 12832
9D02AE7C  24030002   ADDIU V1, ZERO, 2
9D02AE80  A4430012   SH V1, 18(V0)
465:                                 AutoIPClient.packet.HardwareType  = HW_ETHERNET;
9D02AE84  3C02A000   LUI V0, -24576
9D02AE88  24423220   ADDIU V0, V0, 12832
9D02AE8C  24030001   ADDIU V1, ZERO, 1
9D02AE90  A443000C   SH V1, 12(V0)
466:                                 AutoIPClient.packet.Protocol      = ARP_IP;
9D02AE94  3C02A000   LUI V0, -24576
9D02AE98  24423220   ADDIU V0, V0, 12832
9D02AE9C  24030800   ADDIU V1, ZERO, 2048
9D02AEA0  A443000E   SH V1, 14(V0)
467:                     
468:                                 SwapARPPacket(&AutoIPClient.packet);
9D02AEA4  3C02A000   LUI V0, -24576
9D02AEA8  2444322C   ADDIU A0, V0, 12844
9D02AEAC  0F40BD31   JAL SwapARPPacket
9D02AEB0  00000000   NOP
469:                     
470:                             	while(!MACIsTxReady());
9D02AEB4  00000000   NOP
9D02AEB8  0F40727E   JAL MACIsTxReady
9D02AEBC  00000000   NOP
9D02AEC0  1040FFFD   BEQ V0, ZERO, 0x9D02AEB8
9D02AEC4  00000000   NOP
471:                             	MACSetWritePtr(BASE_TX_ADDR);
9D02AEC8  00002021   ADDU A0, ZERO, ZERO
9D02AECC  0F407410   JAL MACSetWritePtr
9D02AED0  00000000   NOP
472:                     
473:                                 MACPutHeader(&AutoIPClient.packet.TargetMACAddr, MAC_ARP, sizeof(AutoIPClient.packet));
9D02AED4  3C02A000   LUI V0, -24576
9D02AED8  2444323E   ADDIU A0, V0, 12862
9D02AEDC  24050006   ADDIU A1, ZERO, 6
9D02AEE0  2406001C   ADDIU A2, ZERO, 28
9D02AEE4  0F407380   JAL MACPutHeader
9D02AEE8  00000000   NOP
474:                                 MACPutArray((BYTE*)&AutoIPClient.packet, sizeof(AutoIPClient.packet));
9D02AEEC  3C02A000   LUI V0, -24576
9D02AEF0  2442322C   ADDIU V0, V0, 12844
9D02AEF4  00402021   ADDU A0, V0, ZERO
9D02AEF8  2405001C   ADDIU A1, ZERO, 28
9D02AEFC  0F40759D   JAL MACPutArray
9D02AF00  00000000   NOP
475:                                 MACFlush();
9D02AF04  0F4073B4   JAL MACFlush
9D02AF08  00000000   NOP
476:                     
477:                                 AutoIPClient.smAUTOIPState = SM_AUTOIP_CONFIGURED;
9D02AF0C  3C02A000   LUI V0, -24576
9D02AF10  2403000A   ADDIU V1, ZERO, 10
9D02AF14  AC433220   SW V1, 12832(V0)
478:                                 break;
9D02AF18  0B40ABD5   J 0x9D02AF54
9D02AF1C  00000000   NOP
479:                         }
480:                     }
481:                 }
9D02AF6C  03C0E821   ADDU SP, S8, ZERO
9D02AF70  8FBF002C   LW RA, 44(SP)
9D02AF74  8FBE0028   LW S8, 40(SP)
9D02AF78  8FB30024   LW S3, 36(SP)
9D02AF7C  8FB20020   LW S2, 32(SP)
9D02AF80  8FB1001C   LW S1, 28(SP)
9D02AF84  8FB00018   LW S0, 24(SP)
9D02AF88  27BD0030   ADDIU SP, SP, 48
9D02AF8C  03E00008   JR RA
9D02AF90  00000000   NOP
482:                 
483:                 /*****************************************************************************
484:                   Function:
485:                 	void AutoIPConflict(BYTE vInterface)
486:                 
487:                   Summary:
488:                 	Handles AutoIP address conflicts.
489:                 
490:                   Description:
491:                 	This function will change the state machine to handle AutoIP address
492:                     conflicts.
493:                 
494:                   Precondition:
495:                 	None
496:                 
497:                   Parameters:
498:                 	vInterface - Interface number to cause an AutoIP conflict for.   If 
499:                         you only have one interface, specify 0x00.
500:                 
501:                   Returns:
502:                 	None
503:                 ***************************************************************************/
504:                 void AutoIPConflict (BYTE vInterface)
505:                 {
9D02AF94  27BDFFE8   ADDIU SP, SP, -24
9D02AF98  AFBF0014   SW RA, 20(SP)
9D02AF9C  AFBE0010   SW S8, 16(SP)
9D02AFA0  03A0F021   ADDU S8, SP, ZERO
9D02AFA4  00801021   ADDU V0, A0, ZERO
9D02AFA8  A3C20018   SB V0, 24(S8)
506:                     LoadState (vInterface);
507:                 
508:                     AutoIPClient.conflicts++;
9D02AFAC  3C02A000   LUI V0, -24576
9D02AFB0  24423220   ADDIU V0, V0, 12832
9D02AFB4  90420031   LBU V0, 49(V0)
9D02AFB8  24420001   ADDIU V0, V0, 1
9D02AFBC  304300FF   ANDI V1, V0, 255
9D02AFC0  3C02A000   LUI V0, -24576
9D02AFC4  24423220   ADDIU V0, V0, 12832
9D02AFC8  A0430031   SB V1, 49(V0)
509:                 
510:                     // State handler
511:                     switch (AutoIPClient.smAUTOIPState)
9D02AFCC  3C02A000   LUI V0, -24576
9D02AFD0  8C423220   LW V0, 12832(V0)
9D02AFD4  2C43000C   SLTIU V1, V0, 12
9D02AFD8  10600047   BEQ V1, ZERO, 0x9D02B0F8
9D02AFDC  00000000   NOP
9D02AFE0  3C0380C0   LUI V1, -32576
9D02AFE4  00431804   SLLV V1, V1, V0
9D02AFE8  04600019   BLTZ V1, 0x9D02B050
9D02AFEC  00000000   NOP
9D02AFF0  3C030030   LUI V1, 48
9D02AFF4  00431804   SLLV V1, V1, V0
9D02AFF8  0460001F   BLTZ V1, 0x9D02B078
9D02AFFC  00000000   NOP
9D02B000  3C037F00   LUI V1, 32512
9D02B004  00431004   SLLV V0, V1, V0
9D02B008  0441003B   BGEZ V0, 0x9D02B0F8
9D02B00C  00000000   NOP
512:                     {
513:                         // During configuration, if there is a conflict, immediately give
514:                         // up the current address and select a new one.
515:                         // If more than 10 conflicts have occured, limit the rate of
516:                         // address retrys to 1 every 60 seconds.
517:                         case SM_AUTOIP_INIT_RNG:
518:                         case SM_AUTOIP_CHECK_ADDRESS:
519:                         case SM_AUTOIP_SETUP_MESSAGE:
520:                         case SM_AUTOIP_GRATUITOUS_ARP1:
521:                         case SM_AUTOIP_GRATUITOUS_ARP2:
522:                         case SM_AUTOIP_GRATUITOUS_ARP3:
523:                         case SM_AUTOIP_DELAY:
524:                             if (AutoIPClient.conflicts >= 10u)
9D02B010  3C02A000   LUI V0, -24576
9D02B014  24423220   ADDIU V0, V0, 12832
9D02B018  90420031   LBU V0, 49(V0)
9D02B01C  2C42000A   SLTIU V0, V0, 10
9D02B020  14400006   BNE V0, ZERO, 0x9D02B03C
9D02B024  00000000   NOP
525:                                 AutoIPClient.smAUTOIPState = SM_AUTOIP_RATE_LIMIT_SET;
9D02B028  3C02A000   LUI V0, -24576
9D02B02C  24030008   ADDIU V1, ZERO, 8
9D02B030  AC433220   SW V1, 12832(V0)
526:                             else
527:                                 AutoIPClient.smAUTOIPState = SM_AUTOIP_CHECK_ADDRESS;
9D02B03C  3C02A000   LUI V0, -24576
9D02B040  24030002   ADDIU V1, ZERO, 2
9D02B044  AC433220   SW V1, 12832(V0)
528:                             break;
9D02B034  0B40AC3E   J 0x9D02B0F8
9D02B038  00000000   NOP
9D02B048  0B40AC3E   J 0x9D02B0F8
9D02B04C  00000000   NOP
529:                         case SM_AUTOIP_RATE_LIMIT_SET:
530:                         case SM_AUTOIP_RATE_LIMIT_WAIT:
531:                         case SM_AUTOIP_DISABLED:
532:                             AutoIPClient.conflicts--;
9D02B050  3C02A000   LUI V0, -24576
9D02B054  24423220   ADDIU V0, V0, 12832
9D02B058  90420031   LBU V0, 49(V0)
9D02B05C  2442FFFF   ADDIU V0, V0, -1
9D02B060  304300FF   ANDI V1, V0, 255
9D02B064  3C02A000   LUI V0, -24576
9D02B068  24423220   ADDIU V0, V0, 12832
9D02B06C  A0430031   SB V1, 49(V0)
533:                             break;
9D02B070  0B40AC3E   J 0x9D02B0F8
9D02B074  00000000   NOP
534:                         // If there is a conflict while we have an address configured,
535:                         // send a defense packet.  If more than one conflict occurs within
536:                         // 10 seconds, claim a new address.
537:                         case SM_AUTOIP_CONFIGURED:
538:                         case SM_AUTOIP_DEFEND:
539:                             if (AutoIPClient.gAutoIPConflictTimer != 0u)
9D02B078  3C02A000   LUI V0, -24576
9D02B07C  24423220   ADDIU V0, V0, 12832
9D02B080  8C420004   LW V0, 4(V0)
9D02B084  10400012   BEQ V0, ZERO, 0x9D02B0D0
9D02B088  00000000   NOP
540:                             {
541:                                 if (TickGet() - AutoIPClient.gAutoIPConflictTimer < TICK_SECOND * 10)
9D02B08C  0F40CDD6   JAL TickGet
9D02B090  00000000   NOP
9D02B094  00401821   ADDU V1, V0, ZERO
9D02B098  3C02A000   LUI V0, -24576
9D02B09C  24423220   ADDIU V0, V0, 12832
9D02B0A0  8C420004   LW V0, 4(V0)
9D02B0A4  00621823   SUBU V1, V1, V0
9D02B0A8  3C020017   LUI V0, 23
9D02B0AC  3442D784   ORI V0, V0, -10364
9D02B0B0  0062102B   SLTU V0, V1, V0
9D02B0B4  10400006   BEQ V0, ZERO, 0x9D02B0D0
9D02B0B8  00000000   NOP
542:                                 {
543:                                     AutoIPClient.smAUTOIPState = SM_AUTOIP_CHECK_ADDRESS;
9D02B0BC  3C02A000   LUI V0, -24576
9D02B0C0  24030002   ADDIU V1, ZERO, 2
9D02B0C4  AC433220   SW V1, 12832(V0)
544:                                     return;;
9D02B0C8  0B40AC3E   J 0x9D02B0F8
9D02B0CC  00000000   NOP
545:                                 }
546:                             }
547:                             AutoIPClient.gAutoIPConflictTimer = TickGet();
9D02B0D0  0F40CDD6   JAL TickGet
9D02B0D4  00000000   NOP
9D02B0D8  00401821   ADDU V1, V0, ZERO
9D02B0DC  3C02A000   LUI V0, -24576
9D02B0E0  24423220   ADDIU V0, V0, 12832
9D02B0E4  AC430004   SW V1, 4(V0)
548:                             AutoIPClient.smAUTOIPState = SM_AUTOIP_DEFEND;
9D02B0E8  3C02A000   LUI V0, -24576
9D02B0EC  2403000B   ADDIU V1, ZERO, 11
9D02B0F0  AC433220   SW V1, 12832(V0)
549:                             break;
9D02B0F4  00000000   NOP
550:                 
551:                     }
552:                 }
9D02B0F8  03C0E821   ADDU SP, S8, ZERO
9D02B0FC  8FBF0014   LW RA, 20(SP)
9D02B100  8FBE0010   LW S8, 16(SP)
9D02B104  27BD0018   ADDIU SP, SP, 24
9D02B108  03E00008   JR RA
9D02B10C  00000000   NOP
553:                 
554:                 
555:                 /*****************************************************************************
556:                   Function:
557:                 	void AutoIPDisable (BYTE vInterface)
558:                 
559:                   Summary:
560:                 	Disables the AutoIP module.
561:                 
562:                   Description:
563:                 	Disables the AutoIP module.  If DHCP is enabled, this function will
564:                     reset the IP address to the default address if no DHCP address has been
565:                     bound.  If DHCP is disabled, this function will reset the IP address to
566:                     the default address.
567:                 
568:                   Precondition:
569:                 	None
570:                 
571:                   Parameters:
572:                 	vInterface - Interface number to disable AutoIP for.   If you only 
573:                         have one interface, specify 0x00.
574:                 
575:                   Returns:
576:                 	None
577:                 
578:                   Remarks:
579:                     None
580:                 ***************************************************************************/
581:                 
582:                 void AutoIPDisable (BYTE vInterface)
583:                 {
9D02B110  27BDFFE8   ADDIU SP, SP, -24
9D02B114  AFBF0014   SW RA, 20(SP)
9D02B118  AFBE0010   SW S8, 16(SP)
9D02B11C  03A0F021   ADDU S8, SP, ZERO
9D02B120  00801021   ADDU V0, A0, ZERO
9D02B124  A3C20018   SB V0, 24(S8)
584:                     LoadState (vInterface);
585:                 
586:                     AutoIPClient.flags.bits.gDisableAutoIP = TRUE;
9D02B128  3C02A000   LUI V0, -24576
9D02B12C  24433220   ADDIU V1, V0, 12832
9D02B130  8C620030   LW V0, 48(V1)
9D02B134  24040001   ADDIU A0, ZERO, 1
9D02B138  7C820004   INS V0, A0, 0, 1
9D02B13C  AC620030   SW V0, 48(V1)
587:                 
588:                     #if defined (STACK_USE_DHCP_CLIENT)
589:                     if (!DHCPIsBound(vInterface))
9D02B140  93C20018   LBU V0, 24(S8)
9D02B144  00402021   ADDU A0, V0, ZERO
9D02B148  0F409094   JAL DHCPIsBound
9D02B14C  00000000   NOP
9D02B150  14400011   BNE V0, ZERO, 0x9D02B198
9D02B154  00000000   NOP
590:                     {
591:                 		AppConfig.MyIPAddr.Val = AppConfig.DefaultIPAddr.Val;
9D02B158  3C02A000   LUI V0, -24576
9D02B15C  24420728   ADDIU V0, V0, 1832
9D02B160  88430017   LWL V1, 23(V0)
9D02B164  98430014   LWR V1, 20(V0)
9D02B168  3C02A000   LUI V0, -24576
9D02B16C  24440728   ADDIU A0, V0, 1832
9D02B170  A8830003   SWL V1, 3(A0)
9D02B174  B8430728   SWR V1, 1832(V0)
592:                 		AppConfig.MyMask.Val = AppConfig.DefaultMask.Val;
9D02B178  3C02A000   LUI V0, -24576
9D02B17C  24420728   ADDIU V0, V0, 1832
9D02B180  8843001B   LWL V1, 27(V0)
9D02B184  98430018   LWR V1, 24(V0)
9D02B188  3C02A000   LUI V0, -24576
9D02B18C  24420728   ADDIU V0, V0, 1832
9D02B190  A8430007   SWL V1, 7(V0)
9D02B194  B8430004   SWR V1, 4(V0)
593:                     }
594:                     #else
595:                 	AppConfig.MyIPAddr.Val = AppConfig.DefaultIPAddr.Val;
596:                 	AppConfig.MyMask.Val = AppConfig.DefaultMask.Val;
597:                     #endif
598:                 }
9D02B198  03C0E821   ADDU SP, S8, ZERO
9D02B19C  8FBF0014   LW RA, 20(SP)
9D02B1A0  8FBE0010   LW S8, 16(SP)
9D02B1A4  27BD0018   ADDIU SP, SP, 24
9D02B1A8  03E00008   JR RA
9D02B1AC  00000000   NOP
599:                 
600:                 /*****************************************************************************
601:                   Function:
602:                 	void AutoIPEnable (BYTE vInterface)
603:                 
604:                   Summary:
605:                 	Enables the AutoIP module.
606:                 
607:                   Description:
608:                 	Enables the AutoIP module.  This function will end the manual-disable
609:                     condition for AutoIP, and reset the state machine to the beginning.
610:                     If a DHCP address is bound or the link is broken, the state will be
611:                     automatically set back to disabled.
612:                 
613:                   Precondition:
614:                 	None
615:                 
616:                   Parameters:
617:                 	vInterface - Interface number to enable AutoIP for. If you only have 
618:                         one interface, specify 0x00.
619:                 
620:                   Returns:
621:                 	None
622:                 
623:                   Remarks:
624:                     None
625:                 ***************************************************************************/
626:                 
627:                 void AutoIPEnable (BYTE vInterface)
628:                 {
9D02B1B0  27BDFFF8   ADDIU SP, SP, -8
9D02B1B4  AFBE0004   SW S8, 4(SP)
9D02B1B8  03A0F021   ADDU S8, SP, ZERO
9D02B1BC  00801021   ADDU V0, A0, ZERO
9D02B1C0  A3C20008   SB V0, 8(S8)
629:                     LoadState (vInterface);
630:                 
631:                     AutoIPClient.flags.bits.gDisableAutoIP = FALSE;
9D02B1C4  3C02A000   LUI V0, -24576
9D02B1C8  24433220   ADDIU V1, V0, 12832
9D02B1CC  8C620030   LW V0, 48(V1)
9D02B1D0  7C020004   INS V0, ZERO, 0, 1
9D02B1D4  AC620030   SW V0, 48(V1)
632:                     AutoIPClient.smAUTOIPState = SM_AUTOIP_INIT_RNG;
9D02B1D8  3C02A000   LUI V0, -24576
9D02B1DC  24030001   ADDIU V1, ZERO, 1
9D02B1E0  AC433220   SW V1, 12832(V0)
633:                 }
9D02B1E4  03C0E821   ADDU SP, S8, ZERO
9D02B1E8  8FBE0004   LW S8, 4(SP)
9D02B1EC  27BD0008   ADDIU SP, SP, 8
9D02B1F0  03E00008   JR RA
9D02B1F4  00000000   NOP
634:                 
635:                 
636:                 /*****************************************************************************
637:                   Function:
638:                 	BOOL AutoIPIsDisabled (BYTE vInterface)
639:                 
640:                   Summary:
641:                 	Determines if the AutoIP state machine is in a disabled state.
642:                 
643:                   Description:
644:                 	Determines if the AutoIP state machine is in a disabled state.  This
645:                     could occur because a DHCP address is bound, the link is broken, or
646:                     the user has manually disabled the AutoIP module.
647:                 
648:                   Precondition:
649:                 	None
650:                 
651:                   Parameters:
652:                 	vInterface - Interface number to check the AutoIP disable status for.   
653:                         If you only have one interface, specify 0x00.
654:                 
655:                   Returns:
656:                 	TRUE - The AutoIP client is disabled
657:                     FALSE - The AutoIP client in active
658:                 
659:                   Remarks:
660:                     None
661:                 ***************************************************************************/
662:                 
663:                 BOOL AutoIPIsDisabled (BYTE vInterface)
664:                 {
9D02B1F8  27BDFFF8   ADDIU SP, SP, -8
9D02B1FC  AFBE0004   SW S8, 4(SP)
9D02B200  03A0F021   ADDU S8, SP, ZERO
9D02B204  00801021   ADDU V0, A0, ZERO
9D02B208  A3C20008   SB V0, 8(S8)
665:                     LoadState (vInterface);
666:                 
667:                     return (AutoIPClient.smAUTOIPState == SM_AUTOIP_DISABLED)?TRUE:FALSE;
9D02B20C  3C02A000   LUI V0, -24576
9D02B210  8C423220   LW V0, 12832(V0)
9D02B214  2C420001   SLTIU V0, V0, 1
668:                 }
9D02B218  03C0E821   ADDU SP, S8, ZERO
9D02B21C  8FBE0004   LW S8, 4(SP)
9D02B220  27BD0008   ADDIU SP, SP, 8
9D02B224  03E00008   JR RA
9D02B228  00000000   NOP
669:                 
670:                 /*****************************************************************************
671:                   Function:
672:                 	void AutoIPRandSeed (DWORD seed, BYTE vInterface)
673:                 
674:                   Summary:
675:                 	Seeds a random number generator used to generate a MAC
676:                 
677:                   Description:
678:                 	Seeds a random number generator used to generate a MAC
679:                 
680:                   Precondition:
681:                 	None
682:                 
683:                   Parameters:
684:                 	seed - The seed value for the RNG
685:                     vInterface - The interface to seed the generator for
686:                 
687:                   Returns:
688:                 	None
689:                 
690:                   Remarks:
691:                     None
692:                 ***************************************************************************/
693:                 
694:                 void AutoIPRandSeed (DWORD seed, BYTE vInterface)
695:                 {
9D02B22C  27BDFFF8   ADDIU SP, SP, -8
9D02B230  AFBE0004   SW S8, 4(SP)
9D02B234  03A0F021   ADDU S8, SP, ZERO
9D02B238  AFC40008   SW A0, 8(S8)
9D02B23C  00A01021   ADDU V0, A1, ZERO
9D02B240  A3C2000C   SB V0, 12(S8)
696:                     LoadState (vInterface);
697:                     AutoIPClient.wRandSeed = seed;
9D02B244  3C02A000   LUI V0, -24576
9D02B248  24423220   ADDIU V0, V0, 12832
9D02B24C  8FC30008   LW V1, 8(S8)
9D02B250  AC43002C   SW V1, 44(V0)
698:                 }
9D02B254  03C0E821   ADDU SP, S8, ZERO
9D02B258  8FBE0004   LW S8, 4(SP)
9D02B25C  27BD0008   ADDIU SP, SP, 8
9D02B260  03E00008   JR RA
9D02B264  00000000   NOP
699:                 
700:                 /*****************************************************************************
701:                   Function:
702:                 	DWORD AutoIPRand (BYTE vInterface)
703:                 
704:                   Summary:
705:                 	Generates a random number
706:                 
707:                   Description:
708:                 	Generates a random number using a LFSR
709:                 
710:                   Precondition:
711:                 	None
712:                 
713:                   Parameters:
714:                 	vInterface - The interface to generate the RNG for
715:                 
716:                   Returns:
717:                 	A random number from 0 to 2^32-1
718:                 
719:                   Remarks:
720:                     None
721:                 ***************************************************************************/
722:                 
723:                 DWORD AutoIPRand (BYTE vInterface)
724:                 {
9D02B268  27BDFFE8   ADDIU SP, SP, -24
9D02B26C  AFBF0014   SW RA, 20(SP)
9D02B270  AFBE0010   SW S8, 16(SP)
9D02B274  03A0F021   ADDU S8, SP, ZERO
9D02B278  00801021   ADDU V0, A0, ZERO
9D02B27C  A3C20018   SB V0, 24(S8)
725:                     LoadState (vInterface);
726:                     LFSRSeedRand(AutoIPClient.wRandSeed);
9D02B280  3C02A000   LUI V0, -24576
9D02B284  24423220   ADDIU V0, V0, 12832
9D02B288  8C42002C   LW V0, 44(V0)
9D02B28C  00402021   ADDU A0, V0, ZERO
9D02B290  0F4095EC   JAL LFSRSeedRand
9D02B294  00000000   NOP
727:                     AutoIPClient.wRandSeed = LFSRRand();
9D02B298  0F40960D   JAL LFSRRand
9D02B29C  00000000   NOP
9D02B2A0  00401821   ADDU V1, V0, ZERO
9D02B2A4  3C02A000   LUI V0, -24576
9D02B2A8  24423220   ADDIU V0, V0, 12832
9D02B2AC  AC43002C   SW V1, 44(V0)
728:                     return AutoIPClient.wRandSeed;
9D02B2B0  3C02A000   LUI V0, -24576
9D02B2B4  24423220   ADDIU V0, V0, 12832
9D02B2B8  8C42002C   LW V0, 44(V0)
729:                 }
9D02B2BC  03C0E821   ADDU SP, S8, ZERO
9D02B2C0  8FBF0014   LW RA, 20(SP)
9D02B2C4  8FBE0010   LW S8, 16(SP)
9D02B2C8  27BD0018   ADDIU SP, SP, 24
9D02B2CC  03E00008   JR RA
9D02B2D0  00000000   NOP
730:                 
731:                 #endif
732:                 
733:                 
734:                 
735:                 
736:                 
737:                 
---  C:/Users/Diego/Documents/GitHub/pic32webFREERtos/Pic32Web.X/src/tcpip/src/Announce.c  --------------
1:                   /*********************************************************************
2:                    *
3:                    *	Announce Client and Server
4:                    *  Module for Microchip TCP/IP Stack
5:                    *	 -Provides device hostname and IP address discovery on a local 
6:                    *    Ethernet subnet (same broadcast domain)
7:                    *	 -Reference: None.  Hopefully AN833 in the future.
8:                    *
9:                    *********************************************************************
10:                   * FileName:        Announce.c
11:                   * Dependencies:    UDP
12:                   * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32
13:                   * Compiler:        Microchip C32 v1.05 or higher
14:                   *					Microchip C30 v3.12 or higher
15:                   *					Microchip C18 v3.30 or higher
16:                   *					HI-TECH PICC-18 PRO 9.63PL2 or higher
17:                   * Company:         Microchip Technology, Inc.
18:                   *
19:                   * Software License Agreement
20:                   *
21:                   * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights
22:                   * reserved.
23:                   *
24:                   * Microchip licenses to you the right to use, modify, copy, and
25:                   * distribute:
26:                   * (i)  the Software when embedded on a Microchip microcontroller or
27:                   *      digital signal controller product ("Device") which is
28:                   *      integrated into Licensee's product; or
29:                   * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h,
30:                   *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device
31:                   *		used in conjunction with a Microchip ethernet controller for
32:                   *		the sole purpose of interfacing with the ethernet controller.
33:                   *
34:                   * You should refer to the license agreement accompanying this
35:                   * Software for additional information regarding your rights and
36:                   * obligations.
37:                   *
38:                   * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT
39:                   * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT
40:                   * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A
41:                   * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL
42:                   * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR
43:                   * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF
44:                   * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS
45:                   * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE
46:                   * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER
47:                   * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT
48:                   * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE.
49:                   *
50:                   *
51:                   * Author               Date    Comment
52:                   *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
53:                   * Howard Schlunder     10/7/04	Original
54:                   * Howard Schlunder		2/9/05	Simplified MAC address to text 
55:                   *								conversion logic
56:                   * Howard Schlunder		2/14/05	Fixed subnet broadcast calculation
57:                   * Howard Schlunder		10/3/06	Fixed a remoteNode saving bug
58:                   ********************************************************************/
59:                  #define __ANNOUNCE_C
60:                  
61:                  #include "../TCPIPConfig.h"
62:                  
63:                  #if defined(STACK_USE_ANNOUNCE)
64:                  
65:                  #include "TCPIP Stack/TCPIP.h"
66:                  
67:                  // The announce port
68:                  #define ANNOUNCE_PORT	30303
69:                  
70:                  
71:                  
72:                  extern NODE_INFO remoteNode;
73:                  
74:                  /****************************************************************************************************
75:                    Function:
76:                              void AnnounceIP(void)
77:                      
78:                    Summary:
79:                      Transmits an Announce packet.
80:                    Conditions:
81:                      Stack is initialized()
82:                    Return:
83:                      None
84:                    Side Effects:
85:                      None
86:                    Description:
87:                      AnnounceIP opens a UDP socket and transmits a broadcast packet to port
88:                      \30303. If a computer is on the same subnet and a utility is looking
89:                      for packets on the UDP port, it will receive the broadcast. For this
90:                      application, it is used to announce the change of this board's IP
91:                      address. The messages can be viewed with the TCP/IP Discoverer
92:                      software tool.
93:                    Remarks:
94:                      A UDP socket must be available before this function is called. It is
95:                      freed at the end of the function. MAX_UDP_SOCKETS may need to be
96:                      increased if other modules use UDP sockets.                                                      
97:                    ****************************************************************************************************/
98:                  void AnnounceIP(void)
99:                  {
9D032E84  27BDFFE0   ADDIU SP, SP, -32
9D032E88  AFBF001C   SW RA, 28(SP)
9D032E8C  AFBE0018   SW S8, 24(SP)
9D032E90  03A0F021   ADDU S8, SP, ZERO
100:                 	UDP_SOCKET	MySocket;
101:                 	BYTE 		i;
102:                 
103:                 	if(!MACIsLinked())  // Check for link before blindly opening and transmitting (similar to DHCP case)
9D032E94  0F40726F   JAL MACIsLinked
9D032E98  00000000   NOP
9D032E9C  1040004E   BEQ V0, ZERO, 0x9D032FD8
9D032EA0  00000000   NOP
104:                 		return;
9D032FD8  00000000   NOP
9D032FDC  0B40CBFA   J 0x9D032FE8
9D032FE0  00000000   NOP
105:                 
106:                 	// Open a UDP socket for outbound broadcast transmission
107:                 	//MySocket = UDPOpen(2860, NULL, ANNOUNCE_PORT);
108:                 	MySocket = UDPOpenEx(0,UDP_OPEN_SERVER,2860, ANNOUNCE_PORT);
9D032EA4  00002021   ADDU A0, ZERO, ZERO
9D032EA8  00002821   ADDU A1, ZERO, ZERO
9D032EAC  24060B2C   ADDIU A2, ZERO, 2860
9D032EB0  2407765F   ADDIU A3, ZERO, 30303
9D032EB4  0F40A0DD   JAL UDPOpenEx
9D032EB8  00000000   NOP
9D032EBC  A3C20011   SB V0, 17(S8)
109:                 	// Abort operation if no UDP sockets are available
110:                 	// If this ever happens, incrementing MAX_UDP_SOCKETS in 
111:                 	// StackTsk.h may help (at the expense of more global memory 
112:                 	// resources).
113:                 	if(MySocket == INVALID_UDP_SOCKET)
9D032EC0  93C30011   LBU V1, 17(S8)
9D032EC4  240200FF   ADDIU V0, ZERO, 255
9D032EC8  10620046   BEQ V1, V0, 0x9D032FE4
9D032ECC  00000000   NOP
114:                 		return;
9D032FE4  00000000   NOP
115:                 	
116:                 	// Make certain the socket can be written to
117:                 	while(!UDPIsPutReady(MySocket));
9D032ED0  00000000   NOP
9D032ED4  93C20011   LBU V0, 17(S8)
9D032ED8  00402021   ADDU A0, V0, ZERO
9D032EDC  0F40A307   JAL UDPIsPutReady
9D032EE0  00000000   NOP
9D032EE4  1040FFFB   BEQ V0, ZERO, 0x9D032ED4
9D032EE8  00000000   NOP
118:                 	
119:                 	// Begin sending our MAC address in human readable form.
120:                 	// The MAC address theoretically could be obtained from the 
121:                 	// packet header when the computer receives our UDP packet, 
122:                 	// however, in practice, the OS will abstract away the useful
123:                 	// information and it would be difficult to obtain.  It also 
124:                 	// would be lost if this broadcast packet were forwarded by a
125:                 	// router to a different portion of the network (note that 
126:                 	// broadcasts are normally not forwarded by routers).
127:                 	UDPPutArray((BYTE*)AppConfig.NetBIOSName, sizeof(AppConfig.NetBIOSName)-1);
9D032EEC  3C02A000   LUI V0, -24576
9D032EF0  24440744   ADDIU A0, V0, 1860
9D032EF4  2405000F   ADDIU A1, ZERO, 15
9D032EF8  0F40A34D   JAL UDPPutArray
9D032EFC  00000000   NOP
128:                 	UDPPut('\r');
9D032F00  2404000D   ADDIU A0, ZERO, 13
9D032F04  0F40A32A   JAL UDPPut
9D032F08  00000000   NOP
129:                 	UDPPut('\n');
9D032F0C  2404000A   ADDIU A0, ZERO, 10
9D032F10  0F40A32A   JAL UDPPut
9D032F14  00000000   NOP
130:                 
131:                 	// Convert the MAC address bytes to hex (text) and then send it
132:                 	i = 0;
9D032F18  A3C00010   SB ZERO, 16(S8)
133:                 	while(1)
134:                 	{
135:                 		UDPPut(btohexa_high(AppConfig.MyMACAddr.v[i]));
9D032F1C  93C20010   LBU V0, 16(S8)
9D032F20  3C03A000   LUI V1, -24576
9D032F24  24630728   ADDIU V1, V1, 1832
9D032F28  00621021   ADDU V0, V1, V0
9D032F2C  9042002D   LBU V0, 45(V0)
9D032F30  00402021   ADDU A0, V0, ZERO
9D032F34  0F409989   JAL btohexa_high
9D032F38  00000000   NOP
9D032F3C  00402021   ADDU A0, V0, ZERO
9D032F40  0F40A32A   JAL UDPPut
9D032F44  00000000   NOP
136:                 	    UDPPut(btohexa_low(AppConfig.MyMACAddr.v[i]));
9D032F48  93C20010   LBU V0, 16(S8)
9D032F4C  3C03A000   LUI V1, -24576
9D032F50  24630728   ADDIU V1, V1, 1832
9D032F54  00621021   ADDU V0, V1, V0
9D032F58  9042002D   LBU V0, 45(V0)
9D032F5C  00402021   ADDU A0, V0, ZERO
9D032F60  0F4099A2   JAL btohexa_low
9D032F64  00000000   NOP
9D032F68  00402021   ADDU A0, V0, ZERO
9D032F6C  0F40A32A   JAL UDPPut
9D032F70  00000000   NOP
137:                 	    if(++i == 6u)
9D032F74  93C20010   LBU V0, 16(S8)
9D032F78  24420001   ADDIU V0, V0, 1
9D032F7C  A3C20010   SB V0, 16(S8)
9D032F80  93C30010   LBU V1, 16(S8)
9D032F84  24020006   ADDIU V0, ZERO, 6
9D032F88  1462000E   BNE V1, V0, 0x9D032FC4
9D032F8C  00000000   NOP
138:                 	    	break;
139:                 	    UDPPut('-');
9D032FC4  2404002D   ADDIU A0, ZERO, 45
9D032FC8  0F40A32A   JAL UDPPut
9D032FCC  00000000   NOP
140:                 	}
9D032FD0  0B40CBC7   J 0x9D032F1C
9D032FD4  00000000   NOP
141:                 
142:                 	// Send some other human readable information.
143:                 	UDPPutROMString((ROM BYTE*)"\r\nDHCP/Power event occurred");
9D032F90  3C029D03   LUI V0, -25341
9D032F94  244261B4   ADDIU V0, V0, 25012
9D032F98  00402021   ADDU A0, V0, ZERO
9D032F9C  0F40A377   JAL UDPPutString
9D032FA0  00000000   NOP
144:                 
145:                 	// Send the packet
146:                 	UDPFlush();
9D032FA4  0F40A38D   JAL UDPFlush
9D032FA8  00000000   NOP
147:                 	
148:                 	// Close the socket so it can be used by other modules
149:                 	UDPClose(MySocket);
9D032FAC  93C20011   LBU V0, 17(S8)
9D032FB0  00402021   ADDU A0, V0, ZERO
9D032FB4  0F40A2B9   JAL UDPClose
9D032FB8  00000000   NOP
9D032FBC  0B40CBFA   J 0x9D032FE8
9D032FC0  00000000   NOP
150:                 }
9D032FE8  03C0E821   ADDU SP, S8, ZERO
9D032FEC  8FBF001C   LW RA, 28(SP)
9D032FF0  8FBE0018   LW S8, 24(SP)
9D032FF4  27BD0020   ADDIU SP, SP, 32
9D032FF8  03E00008   JR RA
9D032FFC  00000000   NOP
151:                 
152:                 /*********************************************************************
153:                  * Function:        void DiscoveryTask(void)
154:                  *
155:                  * Summary:         Announce callback task.
156:                  *
157:                  * PreCondition:    Stack is initialized()
158:                  *
159:                  * Input:           None
160:                  *
161:                  * Output:          None
162:                  *
163:                  * Side Effects:    None
164:                  *
165:                  * Overview:        Recurring task used to listen for Discovery
166:                  *                  messages on the specified ANNOUNCE_PORT.  These
167:                  *                  messages can be sent using the Microchip Device
168:                  *                  Discoverer tool. If one is received, this
169:                  *                  function will transmit a reply.
170:                  *
171:                  * Note:            A UDP socket must be available before this 
172:                  *					function is called.  It is freed at the end of 
173:                  *					the function.  MAX_UDP_SOCKETS may need to be 
174:                  *					increased if other modules use UDP sockets.
175:                  ********************************************************************/
176:                 void DiscoveryTask(void)
177:                 {
9D033000  27BDFFE0   ADDIU SP, SP, -32
9D033004  AFBF001C   SW RA, 28(SP)
9D033008  AFBE0018   SW S8, 24(SP)
9D03300C  03A0F021   ADDU S8, SP, ZERO
178:                 	static enum {
179:                 		DISCOVERY_HOME = 0,
180:                 		DISCOVERY_LISTEN,
181:                 		DISCOVERY_REQUEST_RECEIVED,
182:                 		DISCOVERY_DISABLED
183:                 	} DiscoverySM = DISCOVERY_HOME;
184:                 
185:                 	static UDP_SOCKET	MySocket;
186:                 	BYTE 				i;
187:                 	
188:                 	switch(DiscoverySM)
9D033010  8F8280CC   LW V0, -32564(GP)
9D033014  24030001   ADDIU V1, ZERO, 1
9D033018  10430019   BEQ V0, V1, 0x9D033080
9D03301C  00000000   NOP
9D033020  2C430001   SLTIU V1, V0, 1
9D033024  14600006   BNE V1, ZERO, 0x9D033040
9D033028  00000000   NOP
9D03302C  24030002   ADDIU V1, ZERO, 2
9D033030  10430033   BEQ V0, V1, 0x9D033100
9D033034  00000000   NOP
189:                 	{
190:                 		case DISCOVERY_HOME:
191:                 			// Open a UDP socket for inbound and outbound transmission
192:                 			// Since we expect to only receive broadcast packets and 
193:                 			// only send unicast packets directly to the node we last 
194:                 			// received from, the remote NodeInfo parameter can be anything
195:                 			//MySocket = UDPOpen(ANNOUNCE_PORT, NULL, ANNOUNCE_PORT);
196:                 			MySocket = UDPOpenEx(0,UDP_OPEN_SERVER,ANNOUNCE_PORT, ANNOUNCE_PORT);
9D033040  00002021   ADDU A0, ZERO, ZERO
9D033044  00002821   ADDU A1, ZERO, ZERO
9D033048  2406765F   ADDIU A2, ZERO, 30303
9D03304C  2407765F   ADDIU A3, ZERO, 30303
9D033050  0F40A0DD   JAL UDPOpenEx
9D033054  00000000   NOP
9D033058  A38280D0   SB V0, -32560(GP)
197:                 
198:                 			if(MySocket == INVALID_UDP_SOCKET)
9D03305C  938380D0   LBU V1, -32560(GP)
9D033060  240200FF   ADDIU V0, ZERO, 255
9D033064  10620067   BEQ V1, V0, 0x9D033204
9D033068  00000000   NOP
199:                 				return;
9D033204  00000000   NOP
9D033208  0B40CC8B   J 0x9D03322C
9D03320C  00000000   NOP
200:                 			else
201:                 				DiscoverySM++;
9D03306C  8F8280CC   LW V0, -32564(GP)
9D033070  24420001   ADDIU V0, V0, 1
9D033074  AF8280CC   SW V0, -32564(GP)
202:                 			break;
9D033078  0B40CC8B   J 0x9D03322C
9D03307C  00000000   NOP
203:                 
204:                 		case DISCOVERY_LISTEN:
205:                 			// Do nothing if no data is waiting
206:                 			if(!UDPIsGetReady(MySocket))
9D033080  938280D0   LBU V0, -32560(GP)
9D033084  00402021   ADDU A0, V0, ZERO
9D033088  0F40A3FD   JAL UDPIsGetReady
9D03308C  00000000   NOP
9D033090  1040005F   BEQ V0, ZERO, 0x9D033210
9D033094  00000000   NOP
207:                 				return;
9D033210  00000000   NOP
9D033214  0B40CC8B   J 0x9D03322C
9D033218  00000000   NOP
208:                 			
209:                 			// See if this is a discovery query or reply
210:                 			UDPGet(&i);
9D033098  27C20010   ADDIU V0, S8, 16
9D03309C  00402021   ADDU A0, V0, ZERO
9D0330A0  0F40A421   JAL UDPGet
9D0330A4  00000000   NOP
211:                 			UDPDiscard();
9D0330A8  0F40A472   JAL UDPDiscard
9D0330AC  00000000   NOP
212:                 			if(i != 'D')
9D0330B0  93C30010   LBU V1, 16(S8)
9D0330B4  24020044   ADDIU V0, ZERO, 68
9D0330B8  14620058   BNE V1, V0, 0x9D03321C
9D0330BC  00000000   NOP
213:                 				return;
9D03321C  00000000   NOP
9D033220  0B40CC8B   J 0x9D03322C
9D033224  00000000   NOP
214:                 
215:                 			// We received a discovery request, reply when we can
216:                 			DiscoverySM++;
9D0330C0  8F8280CC   LW V0, -32564(GP)
9D0330C4  24420001   ADDIU V0, V0, 1
9D0330C8  AF8280CC   SW V0, -32564(GP)
217:                 
218:                 			// Change the destination to the unicast address of the last received packet
219:                         	memcpy((void*)&UDPSocketInfo[MySocket].remote.remoteNode, (const void*)&remoteNode, sizeof(remoteNode));
9D0330CC  938280D0   LBU V0, -32560(GP)
9D0330D0  00401821   ADDU V1, V0, ZERO
9D0330D4  2402001C   ADDIU V0, ZERO, 28
9D0330D8  70621802   MUL V1, V1, V0
9D0330DC  3C02A000   LUI V0, -24576
9D0330E0  24420648   ADDIU V0, V0, 1608
9D0330E4  00621021   ADDU V0, V1, V0
9D0330E8  00402021   ADDU A0, V0, ZERO
9D0330EC  3C02A000   LUI V0, -24576
9D0330F0  2445063C   ADDIU A1, V0, 1596
9D0330F4  2406000A   ADDIU A2, ZERO, 10
9D0330F8  0F40D298   JAL 0x9D034A60
9D0330FC  00000000   NOP
220:                 			
221:                 			// No break needed.  If we get down here, we are now ready for the DISCOVERY_REQUEST_RECEIVED state
222:                 
223:                 		case DISCOVERY_REQUEST_RECEIVED:
224:                 			if(!UDPIsPutReady(MySocket))
9D033100  938280D0   LBU V0, -32560(GP)
9D033104  00402021   ADDU A0, V0, ZERO
9D033108  0F40A307   JAL UDPIsPutReady
9D03310C  00000000   NOP
9D033110  10400045   BEQ V0, ZERO, 0x9D033228
9D033114  00000000   NOP
225:                 				return;
9D033228  00000000   NOP
226:                 
227:                 			// Begin sending our MAC address in human readable form.
228:                 			// The MAC address theoretically could be obtained from the 
229:                 			// packet header when the computer receives our UDP packet, 
230:                 			// however, in practice, the OS will abstract away the useful
231:                 			// information and it would be difficult to obtain.  It also 
232:                 			// would be lost if this broadcast packet were forwarded by a
233:                 			// router to a different portion of the network (note that 
234:                 			// broadcasts are normally not forwarded by routers).
235:                 			UDPPutArray((BYTE*)AppConfig.NetBIOSName, sizeof(AppConfig.NetBIOSName)-1);
9D033118  3C02A000   LUI V0, -24576
9D03311C  24440744   ADDIU A0, V0, 1860
9D033120  2405000F   ADDIU A1, ZERO, 15
9D033124  0F40A34D   JAL UDPPutArray
9D033128  00000000   NOP
236:                 			UDPPut('\r');
9D03312C  2404000D   ADDIU A0, ZERO, 13
9D033130  0F40A32A   JAL UDPPut
9D033134  00000000   NOP
237:                 			UDPPut('\n');
9D033138  2404000A   ADDIU A0, ZERO, 10
9D03313C  0F40A32A   JAL UDPPut
9D033140  00000000   NOP
238:                 		
239:                 			// Convert the MAC address bytes to hex (text) and then send it
240:                 			i = 0;
9D033144  A3C00010   SB ZERO, 16(S8)
241:                 			while(1)
242:                 			{
243:                 				UDPPut(btohexa_high(AppConfig.MyMACAddr.v[i]));
9D033148  93C20010   LBU V0, 16(S8)
9D03314C  3C03A000   LUI V1, -24576
9D033150  24630728   ADDIU V1, V1, 1832
9D033154  00621021   ADDU V0, V1, V0
9D033158  9042002D   LBU V0, 45(V0)
9D03315C  00402021   ADDU A0, V0, ZERO
9D033160  0F409989   JAL btohexa_high
9D033164  00000000   NOP
9D033168  00402021   ADDU A0, V0, ZERO
9D03316C  0F40A32A   JAL UDPPut
9D033170  00000000   NOP
244:                 			    UDPPut(btohexa_low(AppConfig.MyMACAddr.v[i]));
9D033174  93C20010   LBU V0, 16(S8)
9D033178  3C03A000   LUI V1, -24576
9D03317C  24630728   ADDIU V1, V1, 1832
9D033180  00621021   ADDU V0, V1, V0
9D033184  9042002D   LBU V0, 45(V0)
9D033188  00402021   ADDU A0, V0, ZERO
9D03318C  0F4099A2   JAL btohexa_low
9D033190  00000000   NOP
9D033194  00402021   ADDU A0, V0, ZERO
9D033198  0F40A32A   JAL UDPPut
9D03319C  00000000   NOP
245:                 			    if(++i == 6u)
9D0331A0  93C20010   LBU V0, 16(S8)
9D0331A4  24420001   ADDIU V0, V0, 1
9D0331A8  304200FF   ANDI V0, V0, 255
9D0331AC  A3C20010   SB V0, 16(S8)
9D0331B0  93C30010   LBU V1, 16(S8)
9D0331B4  24020006   ADDIU V0, ZERO, 6
9D0331B8  1462000D   BNE V1, V0, 0x9D0331F0
9D0331BC  00000000   NOP
246:                 			    	break;
247:                 			    UDPPut('-');
9D0331F0  2404002D   ADDIU A0, ZERO, 45
9D0331F4  0F40A32A   JAL UDPPut
9D0331F8  00000000   NOP
248:                 			}
9D0331FC  0B40CC52   J 0x9D033148
9D033200  00000000   NOP
249:                 			UDPPut('\r');
9D0331C0  2404000D   ADDIU A0, ZERO, 13
9D0331C4  0F40A32A   JAL UDPPut
9D0331C8  00000000   NOP
250:                 			UDPPut('\n');
9D0331CC  2404000A   ADDIU A0, ZERO, 10
9D0331D0  0F40A32A   JAL UDPPut
9D0331D4  00000000   NOP
251:                 
252:                 			// Send the packet
253:                 			UDPFlush();
9D0331D8  0F40A38D   JAL UDPFlush
9D0331DC  00000000   NOP
254:                 
255:                 			// Listen for other discovery requests
256:                 			DiscoverySM = DISCOVERY_LISTEN;
9D0331E0  24020001   ADDIU V0, ZERO, 1
9D0331E4  AF8280CC   SW V0, -32564(GP)
257:                 			break;
9D0331E8  0B40CC8B   J 0x9D03322C
9D0331EC  00000000   NOP
258:                 
259:                 		case DISCOVERY_DISABLED:
260:                 			break;
9D033038  0B40CC8B   J 0x9D03322C
9D03303C  00000000   NOP
261:                 	}	
262:                 
263:                 }
9D03322C  03C0E821   ADDU SP, S8, ZERO
9D033230  8FBF001C   LW RA, 28(SP)
9D033234  8FBE0018   LW S8, 24(SP)
9D033238  27BD0020   ADDIU SP, SP, 32
9D03323C  03E00008   JR RA
9D033240  00000000   NOP
264:                 
265:                 
266:                 #endif //#if defined(STACK_USE_ANNOUNCE)
---  C:/Users/Diego/Documents/GitHub/pic32webFREERtos/Pic32Web.X/src/tcpip/src/ARP.c  -------------------
1:                   /*********************************************************************
2:                    *
3:                    *	Address Resolution Protocol (ARP) Client and Server
4:                    *  Module for Microchip TCP/IP Stack
5:                    *	 -Provides IP address to Ethernet MAC address translation
6:                    *	 -Reference: RFC 826
7:                    *
8:                    *********************************************************************
9:                    * FileName:        ARP.c
10:                   * Dependencies:    string.h
11:                   *                  StackTsk.h
12:                   *                  Helpers.h
13:                   *                  ARP.h
14:                   *                  MAC.h
15:                   * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32
16:                   * Compiler:        Microchip C32 v1.05 or higher
17:                   *					Microchip C30 v3.12 or higher
18:                   *					Microchip C18 v3.30 or higher
19:                   *					HI-TECH PICC-18 PRO 9.63PL2 or higher
20:                   * Company:         Microchip Technology, Inc.
21:                   *
22:                   * Software License Agreement
23:                   *
24:                   * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights
25:                   * reserved.
26:                   *
27:                   * Microchip licenses to you the right to use, modify, copy, and
28:                   * distribute:
29:                   * (i)  the Software when embedded on a Microchip microcontroller or
30:                   *      digital signal controller product ("Device") which is
31:                   *      integrated into Licensee's product; or
32:                   * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h,
33:                   *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device
34:                   *		used in conjunction with a Microchip ethernet controller for
35:                   *		the sole purpose of interfacing with the ethernet controller.
36:                   *
37:                   * You should refer to the license agreement accompanying this
38:                   * Software for additional information regarding your rights and
39:                   * obligations.
40:                   *
41:                   * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT
42:                   * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT
43:                   * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A
44:                   * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL
45:                   * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR
46:                   * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF
47:                   * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS
48:                   * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE
49:                   * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER
50:                   * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT
51:                   * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE.
52:                   *
53:                   *
54:                   * Author               Date    Comment
55:                   *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
56:                   * Nilesh Rajbharti     5/1/01  Original        (Rev 1.0)
57:                   * Nilesh Rajbharti     2/9/02  Cleanup
58:                   * Nilesh Rajbharti     5/22/02 Rev 2.0 (See version.log for detail)
59:                   * Howard Schlunder		8/17/06	Combined ARP.c and ARPTsk.c into ARP.c; 
60:                   *								rewrote some of it to look more linear
61:                   ********************************************************************/
62:                  #define __ARP_C
63:                  
64:                  #include <TCPIP Stack/TCPIP.h>
65:                  
66:                  /****************************************************************************
67:                    Section:
68:                  	Constants and Variables
69:                    ***************************************************************************/
70:                  #ifdef STACK_USE_ZEROCONF_LINK_LOCAL
71:                  //#define ARP_OPERATION_REQ       0x01u		// Operation code indicating an ARP Request
72:                  //#define ARP_OPERATION_RESP      0x02u		// Operation code indicating an ARP Response
73:                  
74:                  #define HW_ETHERNET             (0x0001u)	// ARP Hardware type as defined by IEEE 802.3
75:                  #define ARP_IP                  (0x0800u)	// ARP IP packet type as defined by IEEE 802.3
76:                  #endif
77:                  
78:                  #ifdef STACK_CLIENT_MODE
79:                  static NODE_INFO Cache;						// Cache for one ARP response
80:                  #endif
81:                  
82:                  #ifdef STACK_USE_ZEROCONF_LINK_LOCAL
83:                  #define MAX_REG_APPS            2           // MAX num allowed registrations of Modules/Apps
84:                  static struct arp_app_callbacks reg_apps[MAX_REG_APPS]; // Call-Backs storage for MAX of two Modules/Apps
85:                  /*
86:                  // ARP packet structure
87:                  typedef struct __attribute__((aligned(2), packed))
88:                  {
89:                      WORD        HardwareType;
90:                      WORD        Protocol;
91:                      BYTE        MACAddrLen;
92:                      BYTE        ProtocolLen;
93:                      WORD        Operation;
94:                      MAC_ADDR    SenderMACAddr;
95:                      IP_ADDR     SenderIPAddr;
96:                      MAC_ADDR    TargetMACAddr;
97:                      IP_ADDR     TargetIPAddr;
98:                  } ARP_PACKET;
99:                  */
100:                 #endif
101:                 
102:                 
103:                 /****************************************************************************
104:                   Section:
105:                 	Helper Function Prototypes
106:                   ***************************************************************************/
107:                 
108:                 static BOOL ARPPut(ARP_PACKET* packet);
109:                 
110:                 
111:                 /****************************************************************************
112:                   Section:
113:                 	Function Implementations
114:                   ***************************************************************************/
115:                 #ifdef STACK_USE_ZEROCONF_LINK_LOCAL
116:                 /************ User Application APIs ****************************************/
117:                 
118:                 /*****************************************************************************
119:                   Function:
120:                 	CHAR ARPRegisterCallbacks(struct arp_app_callbacks *app)
121:                 
122:                   Summary:
123:                 	Registering callback with ARP module to get notified about certian events.
124:                 	
125:                   Description:
126:                   	This function allows end user application to register with callbacks, which
127:                     will be called by ARP module to give notification to user-application about 
128:                     events occurred at ARP layer. For ex: when a ARP-packet is received, which is
129:                     conflicting with our own pair of addresses (MAC-Address and IP-address).
130:                     This is an extension for zeroconf protocol implementation (ZeroconfLL.c)
131:                 
132:                   Precondition:
133:                 	None
134:                 
135:                   Parameters:
136:                 	app - ARP-Application callbacks structure supplied by user-application 
137:                     
138:                   Returns:
139:                     id > 0 - Returns non-negative value that represents the id of registration
140:                              The same id needs to be used in de-registration
141:                     -1     - When registered applications exceed MAX_REG_APPS and there is no
142:                              free slot for registration
143:                  
144:                   ***************************************************************************/
145:                 CHAR ARPRegisterCallbacks(struct arp_app_callbacks *app)
146:                 {
147:                     BYTE i;
148:                     for(i=0; i<MAX_REG_APPS; i++)
149:                     {
150:                         if(!reg_apps[i].used)
151:                         {
152:                             reg_apps[i].ARPPkt_notify = app->ARPPkt_notify;
153:                             reg_apps[i].used = 1;
154:                             return (i+1); // Return Code. Should be used in deregister.
155:                         }
156:                     }
157:                     return -1; // No space for registration
158:                 }
159:                 
160:                 /*****************************************************************************
161:                   Function:
162:                 	BOOL ARPDeRegisterCallbacks(CHAR reg_id)
163:                 
164:                   Summary:
165:                 	De-Registering callbacks with ARP module that are registered previously.
166:                 	
167:                   Description:
168:                   	This function allows end user-application to de-register with callbacks, 
169:                     which were registered previously.
170:                     This is called by user-application, when its no longer interested in 
171:                     notifications from ARP-Module. This allows the other application to get 
172:                     registered with ARP-module.   
173:                 
174:                   Precondition:
175:                 	None
176:                 
177:                   Parameters:
178:                 	reg_id - Registration-id returned in ARPRegisterCallbacks call
179:                     
180:                   Returns:
181:                     TRUE  - On success
182:                     FALSE - Failure to indicate invalid reg_id  
183:                   ***************************************************************************/ 
184:                 BOOL ARPDeRegisterCallbacks(CHAR reg_id)
185:                 {
186:                     if(reg_id <= 0 || reg_id > MAX_REG_APPS)
187:                         return FALSE;
188:                 
189:                     reg_apps[reg_id-1].used = 0; // To indicate free slot for registration
190:                 	return TRUE;
191:                 }
192:                 
193:                 /*****************************************************************************
194:                   Function:
195:                 	void ARPProcessRxPkt(ARP_PACKET* packet)
196:                 
197:                   Summary:
198:                 	Processes Received-ARP packet (ARP request/Reply).
199:                 	
200:                   Description:
201:                   	This function is to pass-on the ARP-packet to registered application,
202:                     with the notification of Rx-ARP packet. 
203:                 
204:                   Precondition:
205:                 	ARP packet is received completely from MAC
206:                 
207:                   Parameters:
208:                 	packet - Rx packet to be processed     
209:                 
210:                   Returns:
211:                     None   
212:                   ***************************************************************************/
213:                 void ARPProcessRxPkt(ARP_PACKET* packet)
214:                 {
215:                     BYTE pass_on = 0; // Flag to indicate whether need to be forwarded
216:                     BYTE i;
217:                 
218:                     // Probing Stage
219:                     if(AppConfig.MyIPAddr.Val == 0x00)
220:                     {
221:                         pass_on = 1; // Pass to Registered-Application for further processing        
222:                     }
223:                     else if(AppConfig.MyIPAddr.Val)
224:                     {
225:                         /* Late-conflict */
226:                         if(packet->SenderIPAddr.Val == AppConfig.MyIPAddr.Val)
227:                         {
228:                             pass_on = 1;
229:                         }
230:                     }
231:                     if(pass_on)
232:                     {
233:                     
234:                         for(i =0; i< MAX_REG_APPS; i++)
235:                         {
236:                             if(reg_apps[i].used)
237:                             {
238:                                 reg_apps[i].ARPPkt_notify(packet->SenderIPAddr.Val,
239:                                                       packet->TargetIPAddr.Val,
240:                                                       &packet->SenderMACAddr,
241:                                                       &packet->TargetMACAddr,
242:                                                       packet->Operation);                
243:                             }
244:                         }
245:                     }
246:                 }
247:                 #endif
248:                 
249:                 /*****************************************************************************
250:                   Function:
251:                 	void ARPSendPkt(IP_ADDR* SrcIPAddr, IP_ADDR* DestIPAddr, int op_req )
252:                 
253:                   Summary:
254:                 	Transmits an ARP request/Reply initated by Application or external module.
255:                 	
256:                   Description:
257:                   	This function transmits and ARP request/reply to determine the hardware
258:                   	address of a given IP address (or) Announce self-address to all nodes in
259:                     network. Extended for zeroconf protocol. 
260:                 
261:                   Precondition:
262:                 	ARP packet is ready in the MAC buffer.
263:                 
264:                   Parameters:
265:                 	SrcIPAddr - The Source IP-address 
266:                     DestIPAddr - The Destination IP-Address
267:                     op_req     - Operation Request (ARP_REQ/ARP_RESP)
268:                 
269:                   Returns:
270:                     TRUE - The ARP packet was generated properly
271:                   	FALSE - Not possible return value
272:                 
273:                   Remarks:
274:                   	This API is to give control over AR-packet to external modules. 
275:                   ***************************************************************************/
276:                 BOOL ARPSendPkt(DWORD SrcIPAddr, DWORD DestIPAddr, BYTE op_req )
277:                 {
9D02EE2C  27BDFFC8   ADDIU SP, SP, -56
9D02EE30  AFBF0034   SW RA, 52(SP)
9D02EE34  AFBE0030   SW S8, 48(SP)
9D02EE38  03A0F021   ADDU S8, SP, ZERO
9D02EE3C  AFC40038   SW A0, 56(S8)
9D02EE40  AFC5003C   SW A1, 60(S8)
9D02EE44  00C01021   ADDU V0, A2, ZERO
9D02EE48  A3C20040   SB V0, 64(S8)
278:                     ARP_PACKET packet;
279:                 
280:                 #ifdef STACK_USE_ZEROCONF_LINK_LOCAL
281:                 #define KS_ARP_IP_MULTICAST_HACK y
282:                 #ifdef KS_ARP_IP_MULTICAST_HACK
283:                 	DWORD_VAL *DestAddr = (DWORD_VAL *)&DestIPAddr;
284:                 	if ((DestAddr->v[0] >= 224) &&(DestAddr->v[0] <= 239)) {
285:                 		// "Resolve" the IP to MAC address mapping for
286:                 		// IP multicast address range from 224.0.0.0 to 239.255.255.255
287:                 	
288:                 		Cache.MACAddr.v[0] = 0x01;
289:                 		Cache.MACAddr.v[1] = 0x00;
290:                 		Cache.MACAddr.v[2] = 0x5E;
291:                 		Cache.MACAddr.v[3] = 0x7f & DestAddr->v[1];
292:                 		Cache.MACAddr.v[4] = DestAddr->v[2];
293:                 		Cache.MACAddr.v[5] = DestAddr->v[3];
294:                 	
295:                 		Cache.IPAddr.Val = DestAddr->Val;
296:                 	
297:                 		return TRUE;
298:                 	}
299:                 #endif
300:                 #endif
301:                 
302:                     packet.Operation = op_req;
9D02EE4C  93C20040   LBU V0, 64(S8)
9D02EE50  3042FFFF   ANDI V0, V0, -1
9D02EE54  A7C20016   SH V0, 22(S8)
303:                 	packet.TargetMACAddr.v[0]   = 0xff;
9D02EE58  2402FFFF   ADDIU V0, ZERO, -1
9D02EE5C  A3C20022   SB V0, 34(S8)
304:                 	packet.TargetMACAddr.v[1]   = 0xff;
9D02EE60  2402FFFF   ADDIU V0, ZERO, -1
9D02EE64  A3C20023   SB V0, 35(S8)
305:                 	packet.TargetMACAddr.v[2]   = 0xff;
9D02EE68  2402FFFF   ADDIU V0, ZERO, -1
9D02EE6C  A3C20024   SB V0, 36(S8)
306:                 	packet.TargetMACAddr.v[3]   = 0xff;
9D02EE70  2402FFFF   ADDIU V0, ZERO, -1
9D02EE74  A3C20025   SB V0, 37(S8)
307:                 	packet.TargetMACAddr.v[4]   = 0xff;
9D02EE78  2402FFFF   ADDIU V0, ZERO, -1
9D02EE7C  A3C20026   SB V0, 38(S8)
308:                 	packet.TargetMACAddr.v[5]   = 0xff;
9D02EE80  2402FFFF   ADDIU V0, ZERO, -1
9D02EE84  A3C20027   SB V0, 39(S8)
309:                 
310:                     packet.TargetIPAddr.Val	= DestIPAddr;
9D02EE88  8FC2003C   LW V0, 60(S8)
9D02EE8C  AFC20028   SW V0, 40(S8)
311:                     packet.SenderIPAddr.Val = SrcIPAddr;
9D02EE90  8FC20038   LW V0, 56(S8)
9D02EE94  ABC20021   SWL V0, 33(S8)
9D02EE98  BBC2001E   SWR V0, 30(S8)
312:                 
313:                     return ( ARPPut(&packet) );
9D02EE9C  27C20010   ADDIU V0, S8, 16
9D02EEA0  00402021   ADDU A0, V0, ZERO
9D02EEA4  0F40BBB1   JAL 0x9D02EEC4
9D02EEA8  00000000   NOP
314:                 }
9D02EEAC  03C0E821   ADDU SP, S8, ZERO
9D02EEB0  8FBF0034   LW RA, 52(SP)
9D02EEB4  8FBE0030   LW S8, 48(SP)
9D02EEB8  27BD0038   ADDIU SP, SP, 56
9D02EEBC  03E00008   JR RA
9D02EEC0  00000000   NOP
315:                 
316:                 
317:                 /*****************************************************************************
318:                   Function:
319:                 	static BOOL ARPPut(ARP_PACKET* packet)
320:                 
321:                   Description:
322:                 	Writes an ARP packet to the MAC.
323:                 
324:                   Precondition:
325:                 	None
326:                 
327:                   Parameters:
328:                 	packet - A pointer to an ARP_PACKET structure with correct operation
329:                 				and target preconfigured.
330:                 
331:                   Return Values:
332:                   	TRUE - The ARP packet was generated properly
333:                   	FALSE - Not a possible return value
334:                   ***************************************************************************/
335:                 static BOOL ARPPut(ARP_PACKET* packet)
336:                 {
9D02EEC4  27BDFFE8   ADDIU SP, SP, -24
9D02EEC8  AFBF0014   SW RA, 20(SP)
9D02EECC  AFBE0010   SW S8, 16(SP)
9D02EED0  03A0F021   ADDU S8, SP, ZERO
9D02EED4  AFC40018   SW A0, 24(S8)
337:                 	while(!MACIsTxReady());
9D02EED8  00000000   NOP
9D02EEDC  0F40727E   JAL MACIsTxReady
9D02EEE0  00000000   NOP
9D02EEE4  1040FFFD   BEQ V0, ZERO, 0x9D02EEDC
9D02EEE8  00000000   NOP
338:                 	MACSetWritePtr(BASE_TX_ADDR);
9D02EEEC  00002021   ADDU A0, ZERO, ZERO
9D02EEF0  0F407410   JAL MACSetWritePtr
9D02EEF4  00000000   NOP
339:                 	
340:                 
341:                     packet->HardwareType  = HW_ETHERNET;
9D02EEF8  8FC20018   LW V0, 24(S8)
9D02EEFC  24030001   ADDIU V1, ZERO, 1
9D02EF00  A4430000   SH V1, 0(V0)
342:                     packet->Protocol      = ARP_IP;
9D02EF04  8FC20018   LW V0, 24(S8)
9D02EF08  24030800   ADDIU V1, ZERO, 2048
9D02EF0C  A4430002   SH V1, 2(V0)
343:                     packet->MACAddrLen    = sizeof(MAC_ADDR);
9D02EF10  8FC20018   LW V0, 24(S8)
9D02EF14  24030006   ADDIU V1, ZERO, 6
9D02EF18  A0430004   SB V1, 4(V0)
344:                     packet->ProtocolLen   = sizeof(IP_ADDR);
9D02EF1C  8FC20018   LW V0, 24(S8)
9D02EF20  24030004   ADDIU V1, ZERO, 4
9D02EF24  A0430005   SB V1, 5(V0)
345:                 //    packet->SenderMACAddr = AppConfig.MyMACAddr;	// HI-TECH PICC-18 compiler can't handle this statement, use memcpy() as a workaround
346:                 	memcpy(&packet->SenderMACAddr, (void*)&AppConfig.MyMACAddr, sizeof(packet->SenderMACAddr));
9D02EF28  8FC20018   LW V0, 24(S8)
9D02EF2C  24420008   ADDIU V0, V0, 8
9D02EF30  00402021   ADDU A0, V0, ZERO
9D02EF34  3C02A000   LUI V0, -24576
9D02EF38  24450755   ADDIU A1, V0, 1877
9D02EF3C  24060006   ADDIU A2, ZERO, 6
9D02EF40  0F40D298   JAL 0x9D034A60
9D02EF44  00000000   NOP
347:                 #ifdef STACK_USE_ZEROCONF_LINK_LOCAL
348:                     //packet->SenderIPAddr  = AppConfig.MyIPAddr; /* Removed for ZCLL, SenderIPAddr should be filled in */
349:                 #else
350:                     packet->SenderIPAddr  = AppConfig.MyIPAddr;
9D02EF48  8FC20018   LW V0, 24(S8)
9D02EF4C  3C03A000   LUI V1, -24576
9D02EF50  24640728   ADDIU A0, V1, 1832
9D02EF54  88840003   LWL A0, 3(A0)
9D02EF58  00802821   ADDU A1, A0, ZERO
9D02EF5C  98650728   LWR A1, 1832(V1)
9D02EF60  00A01821   ADDU V1, A1, ZERO
9D02EF64  A8430011   SWL V1, 17(V0)
9D02EF68  B843000E   SWR V1, 14(V0)
351:                 #endif
352:                 
353:                     SwapARPPacket(packet);
9D02EF6C  8FC40018   LW A0, 24(S8)
9D02EF70  0F40BD31   JAL SwapARPPacket
9D02EF74  00000000   NOP
354:                 
355:                     MACPutHeader(&packet->TargetMACAddr, MAC_ARP, sizeof(*packet));
9D02EF78  8FC20018   LW V0, 24(S8)
9D02EF7C  24420012   ADDIU V0, V0, 18
9D02EF80  00402021   ADDU A0, V0, ZERO
9D02EF84  24050006   ADDIU A1, ZERO, 6
9D02EF88  2406001C   ADDIU A2, ZERO, 28
9D02EF8C  0F407380   JAL MACPutHeader
9D02EF90  00000000   NOP
356:                     MACPutArray((BYTE*)packet, sizeof(*packet));
9D02EF94  8FC20018   LW V0, 24(S8)
9D02EF98  00402021   ADDU A0, V0, ZERO
9D02EF9C  2405001C   ADDIU A1, ZERO, 28
9D02EFA0  0F40759D   JAL MACPutArray
9D02EFA4  00000000   NOP
357:                     MACFlush();
9D02EFA8  0F4073B4   JAL MACFlush
9D02EFAC  00000000   NOP
358:                 	
359:                 	return TRUE;
9D02EFB0  24020001   ADDIU V0, ZERO, 1
360:                 }
9D02EFB4  03C0E821   ADDU SP, S8, ZERO
9D02EFB8  8FBF0014   LW RA, 20(SP)
9D02EFBC  8FBE0010   LW S8, 16(SP)
9D02EFC0  27BD0018   ADDIU SP, SP, 24
9D02EFC4  03E00008   JR RA
9D02EFC8  00000000   NOP
361:                 
362:                 
363:                 
364:                 /*****************************************************************************
365:                   Function:
366:                 	void ARPInit(void)
367:                 
368:                   Summary:
369:                 	Initializes the ARP module.
370:                 	
371:                   Description:
372:                   	Initializes the ARP module.  Call this function once at boot to 
373:                   	invalidate the cached lookup.
374:                 
375:                   Precondition:
376:                 	None
377:                 
378:                   Parameters:
379:                 	None
380:                 
381:                   Returns:
382:                   	None
383:                   
384:                   Remarks:
385:                   	This function is only required when the stack is a client, and therefore
386:                   	is only enabled when STACK_CLIENT_MODE is enabled.
387:                   ***************************************************************************/
388:                 #ifdef STACK_CLIENT_MODE
389:                 void ARPInit(void)
390:                 {
9D02EFCC  27BDFFF8   ADDIU SP, SP, -8
9D02EFD0  AFBE0004   SW S8, 4(SP)
9D02EFD4  03A0F021   ADDU S8, SP, ZERO
391:                     Cache.MACAddr.v[0] = 0xff;
9D02EFD8  3C02A000   LUI V0, -24576
9D02EFDC  244232AC   ADDIU V0, V0, 12972
9D02EFE0  2403FFFF   ADDIU V1, ZERO, -1
9D02EFE4  A0430004   SB V1, 4(V0)
392:                     Cache.MACAddr.v[1] = 0xff;
9D02EFE8  3C02A000   LUI V0, -24576
9D02EFEC  244232AC   ADDIU V0, V0, 12972
9D02EFF0  2403FFFF   ADDIU V1, ZERO, -1
9D02EFF4  A0430005   SB V1, 5(V0)
393:                     Cache.MACAddr.v[2] = 0xff;
9D02EFF8  3C02A000   LUI V0, -24576
9D02EFFC  244232AC   ADDIU V0, V0, 12972
9D02F000  2403FFFF   ADDIU V1, ZERO, -1
9D02F004  A0430006   SB V1, 6(V0)
394:                     Cache.MACAddr.v[3] = 0xff;
9D02F008  3C02A000   LUI V0, -24576
9D02F00C  244232AC   ADDIU V0, V0, 12972
9D02F010  2403FFFF   ADDIU V1, ZERO, -1
9D02F014  A0430007   SB V1, 7(V0)
395:                     Cache.MACAddr.v[4] = 0xff;
9D02F018  3C02A000   LUI V0, -24576
9D02F01C  244232AC   ADDIU V0, V0, 12972
9D02F020  2403FFFF   ADDIU V1, ZERO, -1
9D02F024  A0430008   SB V1, 8(V0)
396:                     Cache.MACAddr.v[5] = 0xff;
9D02F028  3C02A000   LUI V0, -24576
9D02F02C  244232AC   ADDIU V0, V0, 12972
9D02F030  2403FFFF   ADDIU V1, ZERO, -1
9D02F034  A0430009   SB V1, 9(V0)
397:                 
398:                 	Cache.IPAddr.Val = 0x0;
9D02F038  3C02A000   LUI V0, -24576
9D02F03C  AC4032AC   SW ZERO, 12972(V0)
399:                 }
9D02F040  03C0E821   ADDU SP, S8, ZERO
9D02F044  8FBE0004   LW S8, 4(SP)
9D02F048  27BD0008   ADDIU SP, SP, 8
9D02F04C  03E00008   JR RA
9D02F050  00000000   NOP
400:                 #endif
401:                 
402:                 
403:                 
404:                 /*****************************************************************************
405:                   Function:
406:                 	BOOL ARPProcess(void)
407:                 
408:                   Summary:
409:                 	Processes an incoming ARP packet.
410:                 	
411:                   Description:
412:                   	Retrieves an ARP packet from the MAC buffer and determines if it is a
413:                   	response to our request (in which case the ARP is resolved) or if it
414:                   	is a request requiring our response (in which case we transmit one.)
415:                 
416:                   Precondition:
417:                 	ARP packet is ready in the MAC buffer.
418:                 
419:                   Parameters:
420:                 	None
421:                 
422:                   Return Values:
423:                   	TRUE - All processing of this ARP packet is complete.  Do not call 
424:                   			again until a new ARP packet is waiting in the RX buffer.
425:                   	FALSE - This function must be called again.  More time is needed to 
426:                   			send an ARP response.
427:                   ***************************************************************************/
428:                 BOOL ARPProcess(void)
429:                 {
9D02F054  27BDFFC8   ADDIU SP, SP, -56
9D02F058  AFBF0034   SW RA, 52(SP)
9D02F05C  AFBE0030   SW S8, 48(SP)
9D02F060  03A0F021   ADDU S8, SP, ZERO
430:                 	ARP_PACKET packet;
431:                 	static NODE_INFO Target;
432:                     #if defined(STACK_USE_AUTO_IP)
433:                         BYTE i;
434:                     #endif
435:                 	static enum
436:                 	{
437:                 	    SM_ARP_IDLE = 0,
438:                 	    SM_ARP_REPLY
439:                 	} smARP = SM_ARP_IDLE;
440:                 
441:                     switch(smARP)
9D02F064  8F8280D4   LW V0, -32556(GP)
9D02F068  10400006   BEQ V0, ZERO, 0x9D02F084
9D02F06C  00000000   NOP
9D02F070  24030001   ADDIU V1, ZERO, 1
9D02F074  10430071   BEQ V0, V1, 0x9D02F23C
9D02F078  00000000   NOP
9D02F07C  0B40BCB9   J 0x9D02F2E4
9D02F080  00000000   NOP
442:                     {
443:                 	    case SM_ARP_IDLE:
444:                 			// Obtain the incoming ARP packet
445:                 		    MACGetArray((BYTE*)&packet, sizeof(packet));		
9D02F084  27C20014   ADDIU V0, S8, 20
9D02F088  00402021   ADDU A0, V0, ZERO
9D02F08C  2405001C   ADDIU A1, ZERO, 28
9D02F090  0F407560   JAL MACGetArray
9D02F094  00000000   NOP
446:                 		    MACDiscardRx();
9D02F098  0F40728D   JAL MACDiscardRx
9D02F09C  00000000   NOP
447:                 		    SwapARPPacket(&packet);
9D02F0A0  27C20014   ADDIU V0, S8, 20
9D02F0A4  00402021   ADDU A0, V0, ZERO
9D02F0A8  0F40BD31   JAL SwapARPPacket
9D02F0AC  00000000   NOP
448:                 		
449:                 			// Validate the ARP packet
450:                 		    if ( packet.HardwareType != HW_ETHERNET     ||
9D02F0B0  97C30014   LHU V1, 20(S8)
9D02F0B4  24020001   ADDIU V0, ZERO, 1
9D02F0B8  14620009   BNE V1, V0, 0x9D02F0E0
9D02F0BC  00000000   NOP
9D02F0C4  24020006   ADDIU V0, ZERO, 6
9D02F0C8  14620005   BNE V1, V0, 0x9D02F0E0
9D02F0CC  00000000   NOP
451:                 		         packet.MACAddrLen != sizeof(MAC_ADDR)  ||
9D02F0C0  93C30018   LBU V1, 24(S8)
9D02F0D4  24020004   ADDIU V0, ZERO, 4
9D02F0D8  10620004   BEQ V1, V0, 0x9D02F0EC
9D02F0DC  00000000   NOP
452:                 		         packet.ProtocolLen != sizeof(IP_ADDR) )
9D02F0D0  93C30019   LBU V1, 25(S8)
453:                 		    {
454:                 		         return TRUE;
9D02F0E0  24020001   ADDIU V0, ZERO, 1
9D02F0E4  0B40BCBA   J 0x9D02F2E8
9D02F0E8  00000000   NOP
455:                 		    }
456:                 #ifdef STACK_USE_ZEROCONF_LINK_LOCAL
457:                 			ARPProcessRxPkt(&packet);
458:                 #endif
459:                 
460:                 #ifdef STACK_USE_AUTO_IP
461:                             if (packet.SenderIPAddr.Val == AppConfig.MyIPAddr.Val)
9D02F0EC  8BC20025   LWL V0, 37(S8)
9D02F0F0  00401821   ADDU V1, V0, ZERO
9D02F0F4  9BC30022   LWR V1, 34(S8)
9D02F0F8  3C02A000   LUI V0, -24576
9D02F0FC  24440728   ADDIU A0, V0, 1832
9D02F100  88840003   LWL A0, 3(A0)
9D02F104  00802821   ADDU A1, A0, ZERO
9D02F108  98450728   LWR A1, 1832(V0)
9D02F10C  00A01021   ADDU V0, A1, ZERO
9D02F110  14620007   BNE V1, V0, 0x9D02F130
9D02F114  00000000   NOP
462:                             {
463:                                 AutoIPConflict(0);
9D02F118  00002021   ADDU A0, ZERO, ZERO
9D02F11C  0F40ABE5   JAL AutoIPConflict
9D02F120  00000000   NOP
464:                                 return TRUE;                
9D02F124  24020001   ADDIU V0, ZERO, 1
9D02F128  0B40BCBA   J 0x9D02F2E8
9D02F12C  00000000   NOP
465:                             }
466:                 #endif
467:                 
468:                 			// Handle incoming ARP responses
469:                 #ifdef STACK_CLIENT_MODE
470:                 			if(packet.Operation == ARP_OPERATION_RESP)
9D02F130  97C3001A   LHU V1, 26(S8)
9D02F134  24020002   ADDIU V0, ZERO, 2
9D02F138  1462000E   BNE V1, V0, 0x9D02F174
9D02F13C  00000000   NOP
471:                 			{
472:                 /*                #if defined(STACK_USE_AUTO_IP)
473:                                 for (i = 0; i < NETWORK_INTERFACES; i++)
474:                                     if (AutoIPConfigIsInProgress(i))
475:                                         AutoIPConflict(i);
476:                                 #endif*/
477:                 				Cache.MACAddr = packet.SenderMACAddr;
9D02F140  3C02A000   LUI V0, -24576
9D02F144  244232AC   ADDIU V0, V0, 12972
9D02F148  8FC3001C   LW V1, 28(S8)
9D02F14C  AC430004   SW V1, 4(V0)
9D02F150  97C30020   LHU V1, 32(S8)
9D02F154  A4430008   SH V1, 8(V0)
478:                 				Cache.IPAddr = packet.SenderIPAddr;
9D02F158  3C02A000   LUI V0, -24576
9D02F15C  8BC30025   LWL V1, 37(S8)
9D02F160  9BC30022   LWR V1, 34(S8)
9D02F164  AC4332AC   SW V1, 12972(V0)
479:                 				return TRUE;
9D02F168  24020001   ADDIU V0, ZERO, 1
9D02F16C  0B40BCBA   J 0x9D02F2E8
9D02F170  00000000   NOP
480:                 			}
481:                 #endif
482:                 
483:                 			// Handle incoming ARP requests for our MAC address
484:                 			if(packet.Operation == ARP_OPERATION_REQ)
9D02F174  97C3001A   LHU V1, 26(S8)
9D02F178  24020001   ADDIU V0, ZERO, 1
9D02F17C  1462002F   BNE V1, V0, 0x9D02F23C
9D02F180  00000000   NOP
485:                 			{
486:                 				if(packet.TargetIPAddr.Val != AppConfig.MyIPAddr.Val)
9D02F184  8FC3002C   LW V1, 44(S8)
9D02F188  3C02A000   LUI V0, -24576
9D02F18C  24440728   ADDIU A0, V0, 1832
9D02F190  88840003   LWL A0, 3(A0)
9D02F194  00802821   ADDU A1, A0, ZERO
9D02F198  98450728   LWR A1, 1832(V0)
9D02F19C  00A01021   ADDU V0, A1, ZERO
9D02F1A0  10620004   BEQ V1, V0, 0x9D02F1B4
9D02F1A4  00000000   NOP
487:                 				{
488:                 					return TRUE;
9D02F1A8  24020001   ADDIU V0, ZERO, 1
9D02F1AC  0B40BCBA   J 0x9D02F2E8
9D02F1B0  00000000   NOP
489:                 				}
490:                 #ifdef STACK_USE_ZEROCONF_LINK_LOCAL
491:                                                /* Fix for Loop-Back suppression:
492:                                                 * For ZCLL-Claim packets, host should not respond.
493:                                                 * Check Sender's MAC-address with own MAC-address and 
494:                                                 * if it is matched, response will not be sent back. This
495:                                                 * was leading to flooding of ARP-answeres */
496:                                                 if(!memcmp (&packet.SenderMACAddr, &AppConfig.MyMACAddr, 6))
497:                                                 {
498:                                                      putsUART("Loopback answer suppressed \r\n");
499:                                                      return TRUE;
500:                                                 }
501:                 #endif
502:                                 #if defined(STACK_USE_AUTO_IP)
503:                                 for (i = 0; i < NETWORK_INTERFACES; i++)
9D02F1B4  A3C00010   SB ZERO, 16(S8)
9D02F1B8  0B40BC80   J 0x9D02F200
9D02F1BC  00000000   NOP
9D02F1F4  93C20010   LBU V0, 16(S8)
9D02F1F8  24420001   ADDIU V0, V0, 1
9D02F1FC  A3C20010   SB V0, 16(S8)
9D02F200  93C20010   LBU V0, 16(S8)
9D02F204  1040FFEE   BEQ V0, ZERO, 0x9D02F1C0
9D02F208  00000000   NOP
504:                                     if (AutoIPConfigIsInProgress(i))
9D02F1C0  93C20010   LBU V0, 16(S8)
9D02F1C4  00402021   ADDU A0, V0, ZERO
9D02F1C8  0F40A95D   JAL AutoIPConfigIsInProgress
9D02F1CC  00000000   NOP
9D02F1D0  10400008   BEQ V0, ZERO, 0x9D02F1F4
9D02F1D4  00000000   NOP
505:                                     {
506:                                         AutoIPConflict(i);
9D02F1D8  93C20010   LBU V0, 16(S8)
9D02F1DC  00402021   ADDU A0, V0, ZERO
9D02F1E0  0F40ABE5   JAL AutoIPConflict
9D02F1E4  00000000   NOP
507:                                         return TRUE;
9D02F1E8  24020001   ADDIU V0, ZERO, 1
9D02F1EC  0B40BCBA   J 0x9D02F2E8
9D02F1F0  00000000   NOP
508:                                     }             
509:                                 #endif
510:                 				Target.IPAddr = packet.SenderIPAddr;
9D02F20C  3C02A000   LUI V0, -24576
9D02F210  8BC30025   LWL V1, 37(S8)
9D02F214  9BC30022   LWR V1, 34(S8)
9D02F218  AC4332B8   SW V1, 12984(V0)
511:                 				Target.MACAddr = packet.SenderMACAddr;
9D02F21C  3C02A000   LUI V0, -24576
9D02F220  244232B8   ADDIU V0, V0, 12984
9D02F224  8FC3001C   LW V1, 28(S8)
9D02F228  AC430004   SW V1, 4(V0)
9D02F22C  97C30020   LHU V1, 32(S8)
9D02F230  A4430008   SH V1, 8(V0)
512:                 
513:                 				smARP = SM_ARP_REPLY;
9D02F234  24020001   ADDIU V0, ZERO, 1
9D02F238  AF8280D4   SW V0, -32556(GP)
514:                 			}
515:                 			// Do not break.  If we get down here, we need to send a reply.	
516:                 
517:                 	    case SM_ARP_REPLY:
518:                 	        packet.Operation		= ARP_OPERATION_RESP;
9D02F23C  24020002   ADDIU V0, ZERO, 2
9D02F240  A7C2001A   SH V0, 26(S8)
519:                             #if defined(STACK_USE_AUTO_IP)
520:                             if (AutoIPIsConfigured(0))
9D02F244  00002021   ADDU A0, ZERO, ZERO
9D02F248  0F40A94F   JAL AutoIPIsConfigured
9D02F24C  00000000   NOP
9D02F250  1040000F   BEQ V0, ZERO, 0x9D02F290
9D02F254  00000000   NOP
521:                             {
522:                                 packet.TargetMACAddr.v[0] = 0xFF;
9D02F258  2402FFFF   ADDIU V0, ZERO, -1
9D02F25C  A3C20026   SB V0, 38(S8)
523:                                 packet.TargetMACAddr.v[1] = 0xFF;
9D02F260  2402FFFF   ADDIU V0, ZERO, -1
9D02F264  A3C20027   SB V0, 39(S8)
524:                                 packet.TargetMACAddr.v[2] = 0xFF;
9D02F268  2402FFFF   ADDIU V0, ZERO, -1
9D02F26C  A3C20028   SB V0, 40(S8)
525:                                 packet.TargetMACAddr.v[3] = 0xFF;
9D02F270  2402FFFF   ADDIU V0, ZERO, -1
9D02F274  A3C20029   SB V0, 41(S8)
526:                                 packet.TargetMACAddr.v[4] = 0xFF;
9D02F278  2402FFFF   ADDIU V0, ZERO, -1
9D02F27C  A3C2002A   SB V0, 42(S8)
527:                                 packet.TargetMACAddr.v[5] = 0xFF;
9D02F280  2402FFFF   ADDIU V0, ZERO, -1
9D02F284  A3C2002B   SB V0, 43(S8)
9D02F288  0B40BCAB   J 0x9D02F2AC
9D02F28C  00000000   NOP
528:                             }
529:                             else
530:                             #endif
531:                         	    packet.TargetMACAddr	= Target.MACAddr;
9D02F290  3C02A000   LUI V0, -24576
9D02F294  244232B8   ADDIU V0, V0, 12984
9D02F298  8C430004   LW V1, 4(V0)
9D02F29C  ABC30029   SWL V1, 41(S8)
9D02F2A0  BBC30026   SWR V1, 38(S8)
9D02F2A4  94420008   LHU V0, 8(V0)
9D02F2A8  A7C2002A   SH V0, 42(S8)
532:                     	    packet.TargetIPAddr		= Target.IPAddr;
9D02F2AC  3C02A000   LUI V0, -24576
9D02F2B0  8C4232B8   LW V0, 12984(V0)
9D02F2B4  AFC2002C   SW V0, 44(S8)
533:                 #ifdef STACK_USE_ZEROCONF_LINK_LOCAL
534:                             packet.SenderIPAddr		= AppConfig.MyIPAddr;
535:                 #endif
536:                 
537:                 			// Send an ARP response to a previously received request
538:                 			if(!ARPPut(&packet))
9D02F2B8  27C20014   ADDIU V0, S8, 20
9D02F2BC  00402021   ADDU A0, V0, ZERO
9D02F2C0  0F40BBB1   JAL 0x9D02EEC4
9D02F2C4  00000000   NOP
9D02F2C8  14400004   BNE V0, ZERO, 0x9D02F2DC
9D02F2CC  00000000   NOP
539:                 			{
540:                 	           return FALSE;
9D02F2D0  00001021   ADDU V0, ZERO, ZERO
9D02F2D4  0B40BCBA   J 0x9D02F2E8
9D02F2D8  00000000   NOP
541:                 			}
542:                 
543:                 			// Begin listening for ARP requests again
544:                 			smARP = SM_ARP_IDLE;
9D02F2DC  AF8080D4   SW ZERO, -32556(GP)
545:                 	        break;
9D02F2E0  00000000   NOP
546:                 	}
547:                 
548:                     return TRUE;
9D02F2E4  24020001   ADDIU V0, ZERO, 1
549:                 }
9D02F2E8  03C0E821   ADDU SP, S8, ZERO
9D02F2EC  8FBF0034   LW RA, 52(SP)
9D02F2F0  8FBE0030   LW S8, 48(SP)
9D02F2F4  27BD0038   ADDIU SP, SP, 56
9D02F2F8  03E00008   JR RA
9D02F2FC  00000000   NOP
550:                 
551:                 /*****************************************************************************
552:                   Function:
553:                 	void ARPResolve(IP_ADDR* IPAddr)
554:                 
555:                   Summary:
556:                 	Transmits an ARP request to resolve an IP address.
557:                 	
558:                   Description:
559:                   	This function transmits and ARP request to determine the hardware
560:                   	address of a given IP address.
561:                 
562:                   Precondition:
563:                 	None
564:                 
565:                   Parameters:
566:                 	IPAddr - The IP address to be resolved.  The address must be specified 
567:                 			 in network byte order (big endian).
568:                 
569:                   Returns:
570:                   	None
571:                 
572:                   Remarks:
573:                   	This function is only required when the stack is a client, and therefore
574:                   	is only enabled when STACK_CLIENT_MODE is enabled.
575:                 
576:                 	To retrieve the ARP query result, call the ARPIsResolved() function.
577:                   ***************************************************************************/
578:                 #ifdef STACK_CLIENT_MODE
579:                 void ARPResolve(IP_ADDR* IPAddr)
580:                 {
9D02F300  27BDFFC8   ADDIU SP, SP, -56
9D02F304  AFBF0034   SW RA, 52(SP)
9D02F308  AFBE0030   SW S8, 48(SP)
9D02F30C  03A0F021   ADDU S8, SP, ZERO
9D02F310  AFC40038   SW A0, 56(S8)
581:                     ARP_PACKET packet;
582:                 
583:                 #ifdef STACK_USE_ZEROCONF_LINK_LOCAL
584:                 #define KS_ARP_IP_MULTICAST_HACK y
585:                 #ifdef KS_ARP_IP_MULTICAST_HACK
586:                     if ((IPAddr->v[0] >= 224) &&(IPAddr->v[0] <= 239))
587:                     {
588:                 		// "Resolve" the IP to MAC address mapping for
589:                 		// IP multicast address range from 224.0.0.0 to 239.255.255.255
590:                 
591:                 		Cache.MACAddr.v[0] = 0x01;
592:                 		Cache.MACAddr.v[1] = 0x00;
593:                 		Cache.MACAddr.v[2] = 0x5E;
594:                 		Cache.MACAddr.v[3] = 0x7f & IPAddr->v[1];
595:                 		Cache.MACAddr.v[4] = IPAddr->v[2];
596:                 		Cache.MACAddr.v[5] = IPAddr->v[3];
597:                 
598:                 		Cache.IPAddr.Val = IPAddr->Val;
599:                 
600:                 		return;
601:                 	}
602:                 #endif
603:                 #endif
604:                 
605:                 	packet.Operation            = ARP_OPERATION_REQ;
9D02F314  24020001   ADDIU V0, ZERO, 1
9D02F318  A7C20016   SH V0, 22(S8)
606:                 	packet.TargetMACAddr.v[0]   = 0xff;
9D02F31C  2402FFFF   ADDIU V0, ZERO, -1
9D02F320  A3C20022   SB V0, 34(S8)
607:                 	packet.TargetMACAddr.v[1]   = 0xff;
9D02F324  2402FFFF   ADDIU V0, ZERO, -1
9D02F328  A3C20023   SB V0, 35(S8)
608:                 	packet.TargetMACAddr.v[2]   = 0xff;
9D02F32C  2402FFFF   ADDIU V0, ZERO, -1
9D02F330  A3C20024   SB V0, 36(S8)
609:                 	packet.TargetMACAddr.v[3]   = 0xff;
9D02F334  2402FFFF   ADDIU V0, ZERO, -1
9D02F338  A3C20025   SB V0, 37(S8)
610:                 	packet.TargetMACAddr.v[4]   = 0xff;
9D02F33C  2402FFFF   ADDIU V0, ZERO, -1
9D02F340  A3C20026   SB V0, 38(S8)
611:                 	packet.TargetMACAddr.v[5]   = 0xff;
9D02F344  2402FFFF   ADDIU V0, ZERO, -1
9D02F348  A3C20027   SB V0, 39(S8)
612:                 
613:                 
614:                     // ARP query either the IP address directly (on our subnet), or do an ARP query for our Gateway if off of our subnet
615:                 	packet.TargetIPAddr			= ((AppConfig.MyIPAddr.Val ^ IPAddr->Val) & AppConfig.MyMask.Val) ? AppConfig.MyGateway : *IPAddr;
9D02F34C  3C02A000   LUI V0, -24576
9D02F350  24430728   ADDIU V1, V0, 1832
9D02F354  88630003   LWL V1, 3(V1)
9D02F358  98430728   LWR V1, 1832(V0)
9D02F35C  8FC20038   LW V0, 56(S8)
9D02F360  8C420000   LW V0, 0(V0)
9D02F364  00621826   XOR V1, V1, V0
9D02F368  3C02A000   LUI V0, -24576
9D02F36C  24420728   ADDIU V0, V0, 1832
9D02F370  88440007   LWL A0, 7(V0)
9D02F374  00802821   ADDU A1, A0, ZERO
9D02F378  98450004   LWR A1, 4(V0)
9D02F37C  00A01021   ADDU V0, A1, ZERO
9D02F380  00621024   AND V0, V1, V0
9D02F384  1040000A   BEQ V0, ZERO, 0x9D02F3B0
9D02F388  00000000   NOP
9D02F38C  3C02A000   LUI V0, -24576
9D02F390  24420728   ADDIU V0, V0, 1832
9D02F394  8843000B   LWL V1, 11(V0)
9D02F398  00602021   ADDU A0, V1, ZERO
9D02F39C  98440008   LWR A0, 8(V0)
9D02F3A0  00801021   ADDU V0, A0, ZERO
9D02F3A4  AFC20028   SW V0, 40(S8)
9D02F3A8  0B40BCEF   J 0x9D02F3BC
9D02F3AC  00000000   NOP
9D02F3B0  8FC20038   LW V0, 56(S8)
9D02F3B4  8C420000   LW V0, 0(V0)
9D02F3B8  AFC20028   SW V0, 40(S8)
616:                 #ifdef STACK_USE_ZEROCONF_LINK_LOCAL
617:                 	packet.SenderIPAddr			= AppConfig.MyIPAddr;
618:                 #endif
619:                 
620:                     ARPPut(&packet);
9D02F3BC  27C20010   ADDIU V0, S8, 16
9D02F3C0  00402021   ADDU A0, V0, ZERO
9D02F3C4  0F40BBB1   JAL 0x9D02EEC4
9D02F3C8  00000000   NOP
621:                 }
9D02F3CC  03C0E821   ADDU SP, S8, ZERO
9D02F3D0  8FBF0034   LW RA, 52(SP)
9D02F3D4  8FBE0030   LW S8, 48(SP)
9D02F3D8  27BD0038   ADDIU SP, SP, 56
9D02F3DC  03E00008   JR RA
9D02F3E0  00000000   NOP
622:                 #endif
623:                 
624:                 
625:                 
626:                 
627:                 /*****************************************************************************
628:                   Function:
629:                 	BOOL ARPIsResolved(IP_ADDR* IPAddr, MAC_ADDR* MACAddr)
630:                 
631:                   Summary:
632:                 	Determines if an ARP request has been resolved yet.
633:                 	
634:                   Description:
635:                   	This function checks if an ARP request has been resolved yet, and if
636:                   	so, stores the resolved MAC address in the pointer provided.
637:                 
638:                   Precondition:
639:                 	ARP packet is ready in the MAC buffer.
640:                 
641:                   Parameters:
642:                 	IPAddr - The IP address to be resolved.  This must match the IP address 
643:                 			 provided to the ARPResolve() function call.
644:                 	MACAddr - A buffer to store the corresponding MAC address retrieved from 
645:                 			 the ARP query.
646:                 
647:                   Return Values:
648:                   	TRUE - The IP address has been resolved and MACAddr MAC address field
649:                 		   indicates the response.
650:                   	FALSE -	The IP address is not yet resolved.  Try calling ARPIsResolved() 
651:                 		   again at a later time.  If you don't get a response after a 
652:                 		   application specific timeout period, you may want to call 
653:                 		   ARPResolve() again to transmit another ARP query (in case if the 
654:                 		   original query or response was lost on the network).  If you never 
655:                 		   receive an ARP response, this may indicate that the IP address 
656:                 		   isn't in use.
657:                 
658:                   Remarks:
659:                   	This function is only required when the stack is a client, and therefore
660:                   	is only enabled when STACK_CLIENT_MODE is enabled.
661:                   ***************************************************************************/
662:                 #ifdef STACK_CLIENT_MODE
663:                 BOOL ARPIsResolved(IP_ADDR* IPAddr, MAC_ADDR* MACAddr)
664:                 {
9D02F3E4  27BDFFF8   ADDIU SP, SP, -8
9D02F3E8  AFBE0004   SW S8, 4(SP)
9D02F3EC  03A0F021   ADDU S8, SP, ZERO
9D02F3F0  AFC40008   SW A0, 8(S8)
9D02F3F4  AFC5000C   SW A1, 12(S8)
665:                     if((Cache.IPAddr.Val == IPAddr->Val) || 
9D02F3F8  3C02A000   LUI V0, -24576
9D02F3FC  8C4332AC   LW V1, 12972(V0)
9D02F400  8FC20008   LW V0, 8(S8)
9D02F404  8C420000   LW V0, 0(V0)
9D02F408  1062001B   BEQ V1, V0, 0x9D02F478
9D02F40C  00000000   NOP
9D02F430  1462001E   BNE V1, V0, 0x9D02F4AC
9D02F434  00000000   NOP
666:                 	  ((Cache.IPAddr.Val == AppConfig.MyGateway.Val) && ((AppConfig.MyIPAddr.Val ^ IPAddr->Val) & AppConfig.MyMask.Val)))
9D02F410  3C02A000   LUI V0, -24576
9D02F414  8C4332AC   LW V1, 12972(V0)
9D02F418  3C02A000   LUI V0, -24576
9D02F41C  24420728   ADDIU V0, V0, 1832
9D02F420  8844000B   LWL A0, 11(V0)
9D02F424  00802821   ADDU A1, A0, ZERO
9D02F428  98450008   LWR A1, 8(V0)
9D02F42C  00A01021   ADDU V0, A1, ZERO
9D02F438  3C02A000   LUI V0, -24576
9D02F43C  24430728   ADDIU V1, V0, 1832
9D02F440  88630003   LWL V1, 3(V1)
9D02F444  98430728   LWR V1, 1832(V0)
9D02F448  8FC20008   LW V0, 8(S8)
9D02F44C  8C420000   LW V0, 0(V0)
9D02F450  00621826   XOR V1, V1, V0
9D02F454  3C02A000   LUI V0, -24576
9D02F458  24420728   ADDIU V0, V0, 1832
9D02F45C  88440007   LWL A0, 7(V0)
9D02F460  00802821   ADDU A1, A0, ZERO
9D02F464  98450004   LWR A1, 4(V0)
9D02F468  00A01021   ADDU V0, A1, ZERO
9D02F46C  00621024   AND V0, V1, V0
9D02F470  1040000E   BEQ V0, ZERO, 0x9D02F4AC
9D02F474  00000000   NOP
667:                     {
668:                         *MACAddr = Cache.MACAddr;
9D02F478  8FC2000C   LW V0, 12(S8)
9D02F47C  3C03A000   LUI V1, -24576
9D02F480  246332AC   ADDIU V1, V1, 12972
9D02F484  8C640004   LW A0, 4(V1)
9D02F488  A8440003   SWL A0, 3(V0)
9D02F48C  B8440000   SWR A0, 0(V0)
9D02F490  90640008   LBU A0, 8(V1)
9D02F494  A0440004   SB A0, 4(V0)
9D02F498  90630009   LBU V1, 9(V1)
9D02F49C  A0430005   SB V1, 5(V0)
669:                         return TRUE;
9D02F4A0  24020001   ADDIU V0, ZERO, 1
9D02F4A4  0B40BD2C   J 0x9D02F4B0
9D02F4A8  00000000   NOP
670:                     }
671:                     return FALSE;
9D02F4AC  00001021   ADDU V0, ZERO, ZERO
672:                 }
9D02F4B0  03C0E821   ADDU SP, S8, ZERO
9D02F4B4  8FBE0004   LW S8, 4(SP)
9D02F4B8  27BD0008   ADDIU SP, SP, 8
9D02F4BC  03E00008   JR RA
9D02F4C0  00000000   NOP
673:                 #endif
674:                 
675:                 
676:                 
677:                 /*****************************************************************************
678:                   Function:
679:                 	void SwapARPPacket(ARP_PACKET* p)
680:                 
681:                   Description:
682:                   	Swaps endian-ness of header information in an ARP packet.
683:                 
684:                   Precondition:
685:                 	None
686:                 
687:                   Parameters:
688:                 	p - The ARP packet to be swapped
689:                 
690:                   Returns:
691:                   	None
692:                   ***************************************************************************/
693:                 void SwapARPPacket(ARP_PACKET* p)
694:                 {
9D02F4C4  27BDFFE8   ADDIU SP, SP, -24
9D02F4C8  AFBF0014   SW RA, 20(SP)
9D02F4CC  AFBE0010   SW S8, 16(SP)
9D02F4D0  03A0F021   ADDU S8, SP, ZERO
9D02F4D4  AFC40018   SW A0, 24(S8)
695:                     p->HardwareType     = swaps(p->HardwareType);
9D02F4D8  8FC20018   LW V0, 24(S8)
9D02F4DC  94420000   LHU V0, 0(V0)
9D02F4E0  00402021   ADDU A0, V0, ZERO
9D02F4E4  0F409A16   JAL swaps
9D02F4E8  00000000   NOP
9D02F4EC  00401821   ADDU V1, V0, ZERO
9D02F4F0  8FC20018   LW V0, 24(S8)
9D02F4F4  A4430000   SH V1, 0(V0)
696:                     p->Protocol         = swaps(p->Protocol);
9D02F4F8  8FC20018   LW V0, 24(S8)
9D02F4FC  94420002   LHU V0, 2(V0)
9D02F500  00402021   ADDU A0, V0, ZERO
9D02F504  0F409A16   JAL swaps
9D02F508  00000000   NOP
9D02F50C  00401821   ADDU V1, V0, ZERO
9D02F510  8FC20018   LW V0, 24(S8)
9D02F514  A4430002   SH V1, 2(V0)
697:                     p->Operation        = swaps(p->Operation);
9D02F518  8FC20018   LW V0, 24(S8)
9D02F51C  94420006   LHU V0, 6(V0)
9D02F520  00402021   ADDU A0, V0, ZERO
9D02F524  0F409A16   JAL swaps
9D02F528  00000000   NOP
9D02F52C  00401821   ADDU V1, V0, ZERO
9D02F530  8FC20018   LW V0, 24(S8)
9D02F534  A4430006   SH V1, 6(V0)
698:                 }
9D02F538  03C0E821   ADDU SP, S8, ZERO
9D02F53C  8FBF0014   LW RA, 20(SP)
9D02F540  8FBE0010   LW S8, 16(SP)
9D02F544  27BD0018   ADDIU SP, SP, 24
9D02F548  03E00008   JR RA
9D02F54C  00000000   NOP
---  C:/Users/Diego/Documents/GitHub/pic32webFREERtos/Pic32Web.X/src/main.c  ----------------------------
1:                   /*
2:                       FreeRTOS V7.5.3 - Copyright (C) 2013 Real Time Engineers Ltd.
3:                       All rights reserved
4:                   
5:                       VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
6:                   
7:                       ***************************************************************************
8:                        *                                                                       *
9:                        *    FreeRTOS provides completely free yet professionally developed,    *
10:                       *    robust, strictly quality controlled, supported, and cross          *
11:                       *    platform software that has become a de facto standard.             *
12:                       *                                                                       *
13:                       *    Help yourself get started quickly and support the FreeRTOS         *
14:                       *    project by purchasing a FreeRTOS tutorial book, reference          *
15:                       *    manual, or both from: http://www.FreeRTOS.org/Documentation        *
16:                       *                                                                       *
17:                       *    Thank you!                                                         *
18:                       *                                                                       *
19:                      ***************************************************************************
20:                  
21:                      This file is part of the FreeRTOS distribution.
22:                  
23:                      FreeRTOS is free software; you can redistribute it and/or modify it under
24:                      the terms of the GNU General Public License (version 2) as published by the
25:                      Free Software Foundation >>!AND MODIFIED BY!<< the FreeRTOS exception.
26:                  
27:                      >>! NOTE: The modification to the GPL is included to allow you to distribute
28:                      >>! a combined work that includes FreeRTOS without being obliged to provide
29:                      >>! the source code for proprietary components outside of the FreeRTOS
30:                      >>! kernel.
31:                  
32:                      FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
33:                      WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
34:                      FOR A PARTICULAR PURPOSE.  Full license text is available from the following
35:                      link: http://www.freertos.org/a00114.html
36:                  
37:                      1 tab == 4 spaces!
38:                  
39:                      ***************************************************************************
40:                       *                                                                       *
41:                       *    Having a problem?  Start by reading the FAQ "My application does   *
42:                       *    not run, what could be wrong?"                                     *
43:                       *                                                                       *
44:                       *    http://www.FreeRTOS.org/FAQHelp.html                               *
45:                       *                                                                       *
46:                      ***************************************************************************
47:                  
48:                      http://www.FreeRTOS.org - Documentation, books, training, latest versions,
49:                      license and Real Time Engineers Ltd. contact details.
50:                  
51:                      http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
52:                      including FreeRTOS+Trace - an indispensable productivity tool, a DOS
53:                      compatible FAT file system, and our tiny thread aware UDP/IP stack.
54:                  
55:                      http://www.OpenRTOS.com - Real Time Engineers ltd license FreeRTOS to High
56:                      Integrity Systems to sell under the OpenRTOS brand.  Low cost OpenRTOS
57:                      licenses offer ticketed support, indemnification and middleware.
58:                  
59:                      http://www.SafeRTOS.com - High Integrity Systems also provide a safety
60:                      engineered and independently SIL3 certified version for use in safety and
61:                      mission critical applications that require provable dependability.
62:                  
63:                      1 tab == 4 spaces!
64:                  */
65:                  
66:                  /******************************************************************************
67:                   * This project provides two demo applications.  A simple blinky style project,
68:                   * and a more comprehensive test and demo application.  The
69:                   * mainCREATE_SIMPLE_BLINKY_DEMO_ONLY setting (defined in this file) is used to
70:                   * select between the two.  The simply blinky demo is implemented and described
71:                   * in main_blinky.c.  The more comprehensive test and demo application is
72:                   * implemented and described in main_full.c.
73:                   *
74:                   * This file implements the code that is not demo specific, including the
75:                   * hardware setup and FreeRTOS hook functions.
76:                   */
77:                  
78:                  /* Kernel includes. */
79:                  #include <FreeRTOS.h>
80:                  #include "task.h"
81:                  
82:                  /// board stuff
83:                  #include "../drivers/board/board.h"
84:                  
85:                  /*
86:                   * Set up the hardware ready to run this demo.
87:                   */
88:                  static void prvSetupHardware( void );
89:                  static void InitAppConfig(void);
90:                  /*
91:                   * This macro uniquely defines this file as the main entry point.
92:                   * There should only be one such definition in the entire project,
93:                   * and this file must define the AppConfig variable as described below.
94:                   */
95:                  #define THIS_IS_STACK_APPLICATION
96:                  
97:                  // Include all headers for any enabled TCPIP Stack functions
98:                  #include "TCPIP Stack/TCPIP.h"
99:                  
100:                 #if defined(STACK_USE_ZEROCONF_LINK_LOCAL)
101:                 #include "TCPIP Stack/ZeroconfLinkLocal.h"
102:                 #endif
103:                 #if defined(STACK_USE_ZEROCONF_MDNS_SD)
104:                 #include "TCPIP Stack/ZeroconfMulticastDNS.h"
105:                 #endif
106:                 // Declare AppConfig structure and some other supporting stack variables
107:                 APP_CONFIG AppConfig;
108:                 static unsigned short wOriginalAppConfigChecksum;	// Checksum of the ROM defaults for AppConfig
109:                 BYTE AN0String[8];
110:                 
111:                 /*
112:                  * Create the demo tasks then start the scheduler.
113:                  */
114:                 static void prvQueueSendTask( void *pvParameters );
115:                 static void stackTasks(void *pvParameters);
116:                 void prvSetupHardware();
117:                 int main( void )
118:                 {
9D0314D4  27BDFFD0   ADDIU SP, SP, -48
9D0314D8  AFBF002C   SW RA, 44(SP)
9D0314DC  AFBE0028   SW S8, 40(SP)
9D0314E0  03A0F021   ADDU S8, SP, ZERO
119:                 	/* Prepare the hardware to run this demo. */
120:                         board_init();
9D0314E4  0F40C25F   JAL board_init
9D0314E8  00000000   NOP
121:                         portDISABLE_INTERRUPTS();
9D0314EC  40026000   MFC0 V0, Status
9D0314F0  AFC20020   SW V0, 32(S8)
9D0314F4  8FC20020   LW V0, 32(S8)
9D0314F8  3042FC00   ANDI V0, V0, -1024
9D0314FC  00021282   SRL V0, V0, 10
9D031500  2C420003   SLTIU V0, V0, 3
9D031504  1040000A   BEQ V0, ZERO, 0x9D031530
9D031508  00000000   NOP
9D03150C  8FC30020   LW V1, 32(S8)
9D031510  3C02FFFF   LUI V0, -1
9D031514  344203FF   ORI V0, V0, 1023
9D031518  00621024   AND V0, V1, V0
9D03151C  AFC20020   SW V0, 32(S8)
9D031520  8FC20020   LW V0, 32(S8)
9D031524  34420C00   ORI V0, V0, 3072
9D031528  40826000   MTC0 V0, Status
9D03152C  000000C0   EHB
122:                         xTaskCreate( prvQueueSendTask, ( signed char * ) "TX", configMINIMAL_STACK_SIZE, NULL, 4, NULL );
9D031530  24020004   ADDIU V0, ZERO, 4
9D031534  AFA20010   SW V0, 16(SP)
9D031538  AFA00014   SW ZERO, 20(SP)
9D03153C  AFA00018   SW ZERO, 24(SP)
9D031540  AFA0001C   SW ZERO, 28(SP)
9D031544  3C029D03   LUI V0, -25341
9D031548  24441624   ADDIU A0, V0, 5668
9D03154C  3C029D03   LUI V0, -25341
9D031550  24456194   ADDIU A1, V0, 24980
9D031554  240600BE   ADDIU A2, ZERO, 190
9D031558  00003821   ADDU A3, ZERO, ZERO
9D03155C  0F407AA6   JAL xTaskGenericCreate
9D031560  00000000   NOP
123:                         xTaskCreate( stackTasks, ( signed char * ) "TcpIp", configMINIMAL_STACK_SIZE, NULL, 4, NULL );
9D031564  24020004   ADDIU V0, ZERO, 4
9D031568  AFA20010   SW V0, 16(SP)
9D03156C  AFA00014   SW ZERO, 20(SP)
9D031570  AFA00018   SW ZERO, 24(SP)
9D031574  AFA0001C   SW ZERO, 28(SP)
9D031578  3C029D03   LUI V0, -25341
9D03157C  244415BC   ADDIU A0, V0, 5564
9D031580  3C029D03   LUI V0, -25341
9D031584  24456198   ADDIU A1, V0, 24984
9D031588  240600BE   ADDIU A2, ZERO, 190
9D03158C  00003821   ADDU A3, ZERO, ZERO
9D031590  0F407AA6   JAL xTaskGenericCreate
9D031594  00000000   NOP
124:                         vTaskStartScheduler();
9D031598  0F407DDF   JAL vTaskStartScheduler
9D03159C  00000000   NOP
125:                 	return 0;
9D0315A0  00001021   ADDU V0, ZERO, ZERO
126:                 }
9D0315A4  03C0E821   ADDU SP, S8, ZERO
9D0315A8  8FBF002C   LW RA, 44(SP)
9D0315AC  8FBE0028   LW S8, 40(SP)
9D0315B0  27BD0030   ADDIU SP, SP, 48
9D0315B4  03E00008   JR RA
9D0315B8  00000000   NOP
127:                 
128:                 void stackTasks(void* pvParameters)
129:                 {
9D0315BC  27BDFFE8   ADDIU SP, SP, -24
9D0315C0  AFBF0014   SW RA, 20(SP)
9D0315C4  AFBE0010   SW S8, 16(SP)
9D0315C8  03A0F021   ADDU S8, SP, ZERO
9D0315CC  AFC40018   SW A0, 24(S8)
130:                     prvSetupHardware();
9D0315D0  0F40C59F   JAL prvSetupHardware
9D0315D4  00000000   NOP
131:                     TickInit();
9D0315D8  0F40CD80   JAL TickInit
9D0315DC  00000000   NOP
132:                     MPFSInit();
9D0315E0  0F409B66   JAL MPFSInit
9D0315E4  00000000   NOP
133:                     InitAppConfig();
9D0315E8  0F40C60A   JAL InitAppConfig
9D0315EC  00000000   NOP
134:                     StackInit();
9D0315F0  0F40C776   JAL StackInit
9D0315F4  00000000   NOP
135:                     while(1)
136:                     {
137:                         StackTask();
9D0315F8  0F40C7AD   JAL StackTask
9D0315FC  00000000   NOP
138:                         StackApplications();
9D031600  0F40C86B   JAL StackApplications
9D031604  00000000   NOP
139:                         //GenericTCPClient();
140:                         //GenericTCPServer();
141:                         //BerkeleyTCPClientDemo();
142:                         BerkeleyTCPServerDemo();
9D031608  0F40CFF0   JAL BerkeleyTCPServerDemo
9D03160C  00000000   NOP
143:                         //BerkeleyUDPClientDemo();
144:                         vTaskDelay(10);
9D031610  2404000A   ADDIU A0, ZERO, 10
9D031614  0F407BB9   JAL vTaskDelay
9D031618  00000000   NOP
145:                     }
9D03161C  0B40C57E   J 0x9D0315F8
9D031620  00000000   NOP
146:                 }
147:                 
148:                 void prvQueueSendTask(void* pvParameters)
149:                 {
9D031624  27BDFFE8   ADDIU SP, SP, -24
9D031628  AFBF0014   SW RA, 20(SP)
9D03162C  AFBE0010   SW S8, 16(SP)
9D031630  03A0F021   ADDU S8, SP, ZERO
9D031634  AFC40018   SW A0, 24(S8)
150:                     while(1)
151:                     {
152:                         board_led1_toggle();
9D031638  0F40C381   JAL board_led1_toggle
9D03163C  00000000   NOP
153:                         vTaskDelay(250);
9D031640  240400FA   ADDIU A0, ZERO, 250
9D031644  0F407BB9   JAL vTaskDelay
9D031648  00000000   NOP
154:                         board_led2_toggle();
9D03164C  0F40C3AB   JAL board_led2_toggle
9D031650  00000000   NOP
155:                         vTaskDelay(250);
9D031654  240400FA   ADDIU A0, ZERO, 250
9D031658  0F407BB9   JAL vTaskDelay
9D03165C  00000000   NOP
156:                         board_led3_toggle();
9D031660  0F40C3D5   JAL board_led3_toggle
9D031664  00000000   NOP
157:                         vTaskDelay(250);
9D031668  240400FA   ADDIU A0, ZERO, 250
9D03166C  0F407BB9   JAL vTaskDelay
9D031670  00000000   NOP
158:                     }
9D031674  0B40C58E   J 0x9D031638
9D031678  00000000   NOP
159:                 }
160:                 
161:                 /*-----------------------------------------------------------*/
162:                 
163:                 static void prvSetupHardware( void )
164:                 {
9D03167C  27BDFFF8   ADDIU SP, SP, -8
9D031680  AFBE0004   SW S8, 4(SP)
9D031684  03A0F021   ADDU S8, SP, ZERO
165:                     // Deassert all chip select lines so there isn't any problem with
166:                     // initialization order.  Ex: When ENC28J60 is on SPI2 with Explorer 16,
167:                     // MAX3232 ROUT2 pin will drive RF12/U2CTS ENC28J60 CS line asserted,
168:                     // preventing proper 25LC256 EEPROM operation.
169:                     #if defined(ENC_CS_TRIS)
170:                             ENC_CS_IO = 1;
171:                             ENC_CS_TRIS = 0;
172:                     #endif
173:                     #if defined(ENC100_CS_TRIS)
174:                             ENC100_CS_IO = (ENC100_INTERFACE_MODE == 0);
9D031688  3C03BF88   LUI V1, -16504
9D03168C  8C626160   LW V0, 24928(V1)
9D031690  24040001   ADDIU A0, ZERO, 1
9D031694  7C826304   INS V0, A0, 12, 1
9D031698  AC626160   SW V0, 24928(V1)
175:                             ENC100_CS_TRIS = 0;
9D03169C  3C03BF88   LUI V1, -16504
9D0316A0  8C626140   LW V0, 24896(V1)
9D0316A4  7C026304   INS V0, ZERO, 12, 1
9D0316A8  AC626140   SW V0, 24896(V1)
176:                     #endif
177:                     #if defined(EEPROM_CS_TRIS)
178:                             EEPROM_CS_IO = 1;
179:                             EEPROM_CS_TRIS = 0;
180:                     #endif
181:                     #if defined(SPIRAM_CS_TRIS)
182:                             SPIRAM_CS_IO = 1;
183:                             SPIRAM_CS_TRIS = 0;
184:                     #endif
185:                     #if defined(SPIFLASH_CS_TRIS)
186:                             SPIFLASH_CS_IO = 1;
187:                             SPIFLASH_CS_TRIS = 0;
188:                     #endif
189:                     #if defined(WF_CS_TRIS)
190:                             WF_CS_IO = 1;
191:                             WF_CS_TRIS = 0;
192:                     #endif
193:                 
194:                 //	/* Configure the hardware for maximum performance. */
195:                 //	vHardwareConfigurePerformance();
196:                 //
197:                 //	/* Setup to use the external interrupt controller. */
198:                 //	vHardwareUseMultiVectoredInterrupts();
199:                 //
200:                 //	portDISABLE_INTERRUPTS();
201:                 //
202:                 //	/* Setup the digital IO for the LED's. */
203:                 //	vParTestInitialise();
204:                 }
9D0316AC  03C0E821   ADDU SP, S8, ZERO
9D0316B0  8FBE0004   LW S8, 4(SP)
9D0316B4  27BD0008   ADDIU SP, SP, 8
9D0316B8  03E00008   JR RA
9D0316BC  00000000   NOP
205:                 /*-----------------------------------------------------------*/
206:                 
207:                 void vApplicationMallocFailedHook( void )
208:                 {
9D0316C0  27BDFFF0   ADDIU SP, SP, -16
9D0316C4  AFBE000C   SW S8, 12(SP)
9D0316C8  03A0F021   ADDU S8, SP, ZERO
209:                 	/* vApplicationMallocFailedHook() will only be called if
210:                 	configUSE_MALLOC_FAILED_HOOK is set to 1 in FreeRTOSConfig.h.  It is a hook
211:                 	function that will get called if a call to pvPortMalloc() fails.
212:                 	pvPortMalloc() is called internally by the kernel whenever a task, queue,
213:                 	timer or semaphore is created.  It is also called by various parts of the
214:                 	demo application.  If heap_1.c or heap_2.c are used, then the size of the
215:                 	heap available to pvPortMalloc() is defined by configTOTAL_HEAP_SIZE in
216:                 	FreeRTOSConfig.h, and the xPortGetFreeHeapSize() API function can be used
217:                 	to query the size of free heap space that remains (although it does not
218:                 	provide information on how the remaining heap might be fragmented). */
219:                 	taskDISABLE_INTERRUPTS();
9D0316CC  40026000   MFC0 V0, Status
9D0316D0  AFC20000   SW V0, 0(S8)
9D0316D4  8FC20000   LW V0, 0(S8)
9D0316D8  3042FC00   ANDI V0, V0, -1024
9D0316DC  00021282   SRL V0, V0, 10
9D0316E0  2C420003   SLTIU V0, V0, 3
9D0316E4  1040000A   BEQ V0, ZERO, 0x9D031710
9D0316E8  00000000   NOP
9D0316EC  8FC30000   LW V1, 0(S8)
9D0316F0  3C02FFFF   LUI V0, -1
9D0316F4  344203FF   ORI V0, V0, 1023
9D0316F8  00621024   AND V0, V1, V0
9D0316FC  AFC20000   SW V0, 0(S8)
9D031700  8FC20000   LW V0, 0(S8)
9D031704  34420C00   ORI V0, V0, 3072
9D031708  40826000   MTC0 V0, Status
9D03170C  000000C0   EHB
220:                 	for( ;; );
9D031710  0B40C5C4   J 0x9D031710
9D031714  00000000   NOP
221:                 }
222:                 /*-----------------------------------------------------------*/
223:                 
224:                 void vApplicationIdleHook( void )
225:                 {
9D031718  27BDFFF8   ADDIU SP, SP, -8
9D03171C  AFBE0004   SW S8, 4(SP)
9D031720  03A0F021   ADDU S8, SP, ZERO
226:                 	/* vApplicationIdleHook() will only be called if configUSE_IDLE_HOOK is set
227:                 	to 1 in FreeRTOSConfig.h.  It will be called on each iteration of the idle
228:                 	task.  It is essential that code added to this hook function never attempts
229:                 	to block in any way (for example, call xQueueReceive() with a block time
230:                 	specified, or call vTaskDelay()).  If the application makes use of the
231:                 	vTaskDelete() API function (as this demo application does) then it is also
232:                 	important that vApplicationIdleHook() is permitted to return to its calling
233:                 	function, because it is the responsibility of the idle task to clean up
234:                 	memory allocated by the kernel to any task that has since been deleted. */
235:                 }
9D031724  03C0E821   ADDU SP, S8, ZERO
9D031728  8FBE0004   LW S8, 4(SP)
9D03172C  27BD0008   ADDIU SP, SP, 8
9D031730  03E00008   JR RA
9D031734  00000000   NOP
236:                 /*-----------------------------------------------------------*/
237:                 
238:                 void vApplicationStackOverflowHook( xTaskHandle pxTask, signed char *pcTaskName )
239:                 {
9D031738  27BDFFF0   ADDIU SP, SP, -16
9D03173C  AFBE000C   SW S8, 12(SP)
9D031740  03A0F021   ADDU S8, SP, ZERO
9D031744  AFC40010   SW A0, 16(S8)
9D031748  AFC50014   SW A1, 20(S8)
240:                 	( void ) pcTaskName;
241:                 	( void ) pxTask;
242:                 
243:                 	/* Run time task stack overflow checking is performed if
244:                 	configCHECK_FOR_STACK_OVERFLOW is defined to 1 or 2.  This hook	function is
245:                 	called if a task stack overflow is detected.  Note the system/interrupt
246:                 	stack is not checked. */
247:                 	taskDISABLE_INTERRUPTS();
9D03174C  40026000   MFC0 V0, Status
9D031750  AFC20000   SW V0, 0(S8)
9D031754  8FC20000   LW V0, 0(S8)
9D031758  3042FC00   ANDI V0, V0, -1024
9D03175C  00021282   SRL V0, V0, 10
9D031760  2C420003   SLTIU V0, V0, 3
9D031764  1040000A   BEQ V0, ZERO, 0x9D031790
9D031768  00000000   NOP
9D03176C  8FC30000   LW V1, 0(S8)
9D031770  3C02FFFF   LUI V0, -1
9D031774  344203FF   ORI V0, V0, 1023
9D031778  00621024   AND V0, V1, V0
9D03177C  AFC20000   SW V0, 0(S8)
9D031780  8FC20000   LW V0, 0(S8)
9D031784  34420C00   ORI V0, V0, 3072
9D031788  40826000   MTC0 V0, Status
9D03178C  000000C0   EHB
248:                 	for( ;; );
9D031790  0B40C5E4   J 0x9D031790
9D031794  00000000   NOP
249:                 }
250:                 /*-----------------------------------------------------------*/
251:                 
252:                 void vApplicationTickHook( void )
253:                 {
9D031798  27BDFFF8   ADDIU SP, SP, -8
9D03179C  AFBE0004   SW S8, 4(SP)
9D0317A0  03A0F021   ADDU S8, SP, ZERO
254:                 	/* This function will be called by each tick interrupt if
255:                 	configUSE_TICK_HOOK is set to 1 in FreeRTOSConfig.h.  User code can be
256:                 	added here, but the tick hook is called from an interrupt context, so
257:                 	code must not attempt to block, and only the interrupt safe FreeRTOS API
258:                 	functions can be used (those that end in FromISR()). */
259:                 }
9D0317A4  03C0E821   ADDU SP, S8, ZERO
9D0317A8  8FBE0004   LW S8, 4(SP)
9D0317AC  27BD0008   ADDIU SP, SP, 8
9D0317B0  03E00008   JR RA
9D0317B4  00000000   NOP
260:                 /*-----------------------------------------------------------*/
261:                 
262:                 void _general_exception_handler( unsigned long ulCause, unsigned long ulStatus )
263:                 {
9D0317B8  27BDFFF8   ADDIU SP, SP, -8
9D0317BC  AFBE0004   SW S8, 4(SP)
9D0317C0  03A0F021   ADDU S8, SP, ZERO
9D0317C4  AFC40008   SW A0, 8(S8)
9D0317C8  AFC5000C   SW A1, 12(S8)
264:                 	/* This overrides the definition provided by the kernel.  Other exceptions
265:                 	should be handled here. */
266:                 	for( ;; );
9D0317CC  0B40C5F3   J 0x9D0317CC
9D0317D0  00000000   NOP
267:                 }
268:                 /*-----------------------------------------------------------*/
269:                 
270:                 void vAssertCalled( const char * pcFile, unsigned long ulLine )
271:                 {
9D0317D4  27BDFFE0   ADDIU SP, SP, -32
9D0317D8  AFBF001C   SW RA, 28(SP)
9D0317DC  AFBE0018   SW S8, 24(SP)
9D0317E0  03A0F021   ADDU S8, SP, ZERO
9D0317E4  AFC40020   SW A0, 32(S8)
9D0317E8  AFC50024   SW A1, 36(S8)
272:                 volatile unsigned long ul = 0;
9D0317EC  0F40834C   JAL vTaskEnterCritical
273:                 
274:                 	( void ) pcFile;
275:                 	( void ) ulLine;
276:                 
277:                 	taskENTER_CRITICAL();
9D0317F0  AFC00010   SW ZERO, 16(S8)
278:                 	{
279:                 		/* Set ul to a non-zero value using the debugger to step out of this
280:                 		function. */
281:                 		while( ul == 0 )
9D0317F4  0B40C600   J 0x9D031800
9D0317F8  00000000   NOP
9D031800  8FC20010   LW V0, 16(S8)
9D031804  1040FFFD   BEQ V0, ZERO, 0x9D0317FC
9D031808  00000000   NOP
282:                 		{
283:                 			portNOP();
9D0317FC  00000000   NOP
284:                 		}
285:                 	}
286:                 	taskEXIT_CRITICAL();
9D03180C  0F40836C   JAL vTaskExitCritical
9D031810  00000000   NOP
287:                 }
9D031814  03C0E821   ADDU SP, S8, ZERO
9D031818  8FBF001C   LW RA, 28(SP)
9D03181C  8FBE0018   LW S8, 24(SP)
9D031820  03E00008   JR RA
9D031824  27BD0020   ADDIU SP, SP, 32
288:                 static ROM BYTE SerializedMACAddress[6] = {MY_DEFAULT_MAC_BYTE1, MY_DEFAULT_MAC_BYTE2, MY_DEFAULT_MAC_BYTE3, MY_DEFAULT_MAC_BYTE4, MY_DEFAULT_MAC_BYTE5, MY_DEFAULT_MAC_BYTE6};
289:                 //#pragma romdata
290:                 
291:                 static void InitAppConfig(void)
292:                 {
9D031828  27BDFFE8   ADDIU SP, SP, -24
9D03182C  AFBF0014   SW RA, 20(SP)
9D031830  AFBE0010   SW S8, 16(SP)
9D031834  03A0F021   ADDU S8, SP, ZERO
293:                 #if defined(EEPROM_CS_TRIS) || defined(SPIFLASH_CS_TRIS)
294:                 	unsigned char vNeedToSaveDefaults = 0;
295:                 #endif
296:                 
297:                 	while(1)
298:                 	{
299:                 		// Start out zeroing all AppConfig bytes to ensure all fields are
300:                 		// deterministic for checksum generation
301:                 		memset((void*)&AppConfig, 0x00, sizeof(AppConfig));
9D031838  3C02A000   LUI V0, -24576
9D03183C  24440728   ADDIU A0, V0, 1832
9D031840  00002821   ADDU A1, ZERO, ZERO
9D031844  24060033   ADDIU A2, ZERO, 51
9D031848  0F40D5EC   JAL 0x9D0357B0
9D03184C  00000000   NOP
302:                 
303:                 		AppConfig.Flags.bIsDHCPEnabled = TRUE;
9D031850  3C02A000   LUI V0, -24576
9D031854  24430728   ADDIU V1, V0, 1832
9D031858  8C62002C   LW V0, 44(V1)
9D03185C  24040001   ADDIU A0, ZERO, 1
9D031860  7C823184   INS V0, A0, 6, 1
9D031864  AC62002C   SW V0, 44(V1)
304:                 		AppConfig.Flags.bInConfigMode = TRUE;
9D031868  3C02A000   LUI V0, -24576
9D03186C  24430728   ADDIU V1, V0, 1832
9D031870  8C62002C   LW V0, 44(V1)
9D031874  24040001   ADDIU A0, ZERO, 1
9D031878  7C8239C4   INS V0, A0, 7, 1
9D03187C  AC62002C   SW V0, 44(V1)
305:                 		memcpypgm2ram((void*)&AppConfig.MyMACAddr, (ROM void*)SerializedMACAddress, sizeof(AppConfig.MyMACAddr));
9D031880  3C02A000   LUI V0, -24576
9D031884  24440755   ADDIU A0, V0, 1877
9D031888  3C029D03   LUI V0, -25341
9D03188C  244561A0   ADDIU A1, V0, 24992
9D031890  24060006   ADDIU A2, ZERO, 6
9D031894  0F40D298   JAL 0x9D034A60
9D031898  00000000   NOP
306:                 //		{
307:                 //			_prog_addressT MACAddressAddress;
308:                 //			MACAddressAddress.next = 0x157F8;
309:                 //			_memcpy_p2d24((char*)&AppConfig.MyMACAddr, MACAddressAddress, sizeof(AppConfig.MyMACAddr));
310:                 //		}
311:                 		AppConfig.MyIPAddr.Val = MY_DEFAULT_IP_ADDR_BYTE1 | MY_DEFAULT_IP_ADDR_BYTE2<<8ul | MY_DEFAULT_IP_ADDR_BYTE3<<16ul | MY_DEFAULT_IP_ADDR_BYTE4<<24ul;
9D03189C  3C02A000   LUI V0, -24576
9D0318A0  3C030101   LUI V1, 257
9D0318A4  3463FEA9   ORI V1, V1, -343
9D0318A8  AC430728   SW V1, 1832(V0)
312:                 		AppConfig.DefaultIPAddr.Val = AppConfig.MyIPAddr.Val;
9D0318AC  3C02A000   LUI V0, -24576
9D0318B0  8C430728   LW V1, 1832(V0)
9D0318B4  3C02A000   LUI V0, -24576
9D0318B8  24420728   ADDIU V0, V0, 1832
9D0318BC  AC430014   SW V1, 20(V0)
313:                 		AppConfig.MyMask.Val = MY_DEFAULT_MASK_BYTE1 | MY_DEFAULT_MASK_BYTE2<<8ul | MY_DEFAULT_MASK_BYTE3<<16ul | MY_DEFAULT_MASK_BYTE4<<24ul;
9D0318C0  3C02A000   LUI V0, -24576
9D0318C4  24420728   ADDIU V0, V0, 1832
9D0318C8  3403FFFF   ORI V1, ZERO, -1
9D0318CC  AC430004   SW V1, 4(V0)
314:                 		AppConfig.DefaultMask.Val = AppConfig.MyMask.Val;
9D0318D0  3C02A000   LUI V0, -24576
9D0318D4  24420728   ADDIU V0, V0, 1832
9D0318D8  8C430004   LW V1, 4(V0)
9D0318DC  3C02A000   LUI V0, -24576
9D0318E0  24420728   ADDIU V0, V0, 1832
9D0318E4  AC430018   SW V1, 24(V0)
315:                 		AppConfig.MyGateway.Val = MY_DEFAULT_GATE_BYTE1 | MY_DEFAULT_GATE_BYTE2<<8ul | MY_DEFAULT_GATE_BYTE3<<16ul | MY_DEFAULT_GATE_BYTE4<<24ul;
9D0318E8  3C02A000   LUI V0, -24576
9D0318EC  24420728   ADDIU V0, V0, 1832
9D0318F0  3C030101   LUI V1, 257
9D0318F4  3463FEA9   ORI V1, V1, -343
9D0318F8  AC430008   SW V1, 8(V0)
316:                 		AppConfig.PrimaryDNSServer.Val = MY_DEFAULT_PRIMARY_DNS_BYTE1 | MY_DEFAULT_PRIMARY_DNS_BYTE2<<8ul  | MY_DEFAULT_PRIMARY_DNS_BYTE3<<16ul  | MY_DEFAULT_PRIMARY_DNS_BYTE4<<24ul;
9D0318FC  3C02A000   LUI V0, -24576
9D031900  24420728   ADDIU V0, V0, 1832
9D031904  3C030101   LUI V1, 257
9D031908  3463FEA9   ORI V1, V1, -343
9D03190C  AC43000C   SW V1, 12(V0)
317:                 		AppConfig.SecondaryDNSServer.Val = MY_DEFAULT_SECONDARY_DNS_BYTE1 | MY_DEFAULT_SECONDARY_DNS_BYTE2<<8ul  | MY_DEFAULT_SECONDARY_DNS_BYTE3<<16ul  | MY_DEFAULT_SECONDARY_DNS_BYTE4<<24ul;
9D031910  3C02A000   LUI V0, -24576
9D031914  24420728   ADDIU V0, V0, 1832
9D031918  AC400010   SW ZERO, 16(V0)
318:                 
319:                 
320:                 		// SNMP Community String configuration
321:                 		#if defined(STACK_USE_SNMP_SERVER)
322:                 		{
323:                 			BYTE i;
324:                 			static ROM char * ROM cReadCommunities[] = SNMP_READ_COMMUNITIES;
325:                 			static ROM char * ROM cWriteCommunities[] = SNMP_WRITE_COMMUNITIES;
326:                 			ROM char * strCommunity;
327:                 
328:                 			for(i = 0; i < SNMP_MAX_COMMUNITY_SUPPORT; i++)
329:                 			{
330:                 				// Get a pointer to the next community string
331:                 				strCommunity = cReadCommunities[i];
332:                 				if(i >= sizeof(cReadCommunities)/sizeof(cReadCommunities[0]))
333:                 					strCommunity = "";
334:                 
335:                 				// Ensure we don't buffer overflow.  If your code gets stuck here,
336:                 				// it means your SNMP_COMMUNITY_MAX_LEN definition in TCPIPConfig.h
337:                 				// is either too small or one of your community string lengths
338:                 				// (SNMP_READ_COMMUNITIES) are too large.  Fix either.
339:                 				if(strlenpgm(strCommunity) >= sizeof(AppConfig.readCommunity[0]))
340:                 					while(1);
341:                 
342:                 				// Copy string into AppConfig
343:                 				strcpypgm2ram((char*)AppConfig.readCommunity[i], strCommunity);
344:                 
345:                 				// Get a pointer to the next community string
346:                 				strCommunity = cWriteCommunities[i];
347:                 				if(i >= sizeof(cWriteCommunities)/sizeof(cWriteCommunities[0]))
348:                 					strCommunity = "";
349:                 
350:                 				// Ensure we don't buffer overflow.  If your code gets stuck here,
351:                 				// it means your SNMP_COMMUNITY_MAX_LEN definition in TCPIPConfig.h
352:                 				// is either too small or one of your community string lengths
353:                 				// (SNMP_WRITE_COMMUNITIES) are too large.  Fix either.
354:                 				if(strlenpgm(strCommunity) >= sizeof(AppConfig.writeCommunity[0]))
355:                 					while(1);
356:                 
357:                 				// Copy string into AppConfig
358:                 				strcpypgm2ram((char*)AppConfig.writeCommunity[i], strCommunity);
359:                 			}
360:                 		}
361:                 		#endif
362:                 
363:                 		// Load the default NetBIOS Host Name
364:                 		memcpypgm2ram(AppConfig.NetBIOSName, (ROM void*)MY_DEFAULT_HOST_NAME, 16);
9D03191C  3C02A000   LUI V0, -24576
9D031920  24440744   ADDIU A0, V0, 1860
9D031924  3C029D03   LUI V0, -25341
9D031928  244561A8   ADDIU A1, V0, 25000
9D03192C  24060010   ADDIU A2, ZERO, 16
9D031930  0F40D298   JAL 0x9D034A60
9D031934  00000000   NOP
365:                 		FormatNetBIOSName(AppConfig.NetBIOSName);
9D031938  3C02A000   LUI V0, -24576
9D03193C  24440744   ADDIU A0, V0, 1860
9D031940  0F409AC4   JAL FormatNetBIOSName
9D031944  00000000   NOP
366:                 
367:                 		#if defined(WF_CS_TRIS)
368:                 			// Load the default SSID Name
369:                 			WF_ASSERT(sizeof(MY_DEFAULT_SSID_NAME) <= sizeof(AppConfig.MySSID));
370:                 			memcpypgm2ram(AppConfig.MySSID, (ROM void*)MY_DEFAULT_SSID_NAME, sizeof(MY_DEFAULT_SSID_NAME));
371:                 			AppConfig.SsidLength = sizeof(MY_DEFAULT_SSID_NAME) - 1;
372:                 
373:                 	        AppConfig.SecurityMode = MY_DEFAULT_WIFI_SECURITY_MODE;
374:                 
375:                 	        #if (MY_DEFAULT_WIFI_SECURITY_MODE == WF_SECURITY_OPEN)
376:                 	            memset(AppConfig.SecurityKey, 0x00, sizeof(AppConfig.SecurityKey));
377:                 	            AppConfig.SecurityKeyLength = 0;
378:                 
379:                 	        #elif MY_DEFAULT_WIFI_SECURITY_MODE == WF_SECURITY_WEP_40
380:                 				AppConfig.WepKeyIndex  = MY_DEFAULT_WEP_KEY_INDEX;
381:                 	            memcpypgm2ram(AppConfig.SecurityKey, (ROM void*)MY_DEFAULT_WEP_KEYS_40, sizeof(MY_DEFAULT_WEP_KEYS_40) - 1);
382:                 	            AppConfig.SecurityKeyLength = sizeof(MY_DEFAULT_WEP_KEYS_40) - 1;
383:                 
384:                 	        #elif MY_DEFAULT_WIFI_SECURITY_MODE == WF_SECURITY_WEP_104
385:                 				AppConfig.WepKeyIndex  = MY_DEFAULT_WEP_KEY_INDEX;
386:                 			    memcpypgm2ram(AppConfig.SecurityKey, (ROM void*)MY_DEFAULT_WEP_KEYS_104, sizeof(MY_DEFAULT_WEP_KEYS_104) - 1);
387:                 			    AppConfig.SecurityKeyLength = sizeof(MY_DEFAULT_WEP_KEYS_104) - 1;
388:                 
389:                 	        #elif (MY_DEFAULT_WIFI_SECURITY_MODE == WF_SECURITY_WPA_WITH_KEY)       || \
390:                 	              (MY_DEFAULT_WIFI_SECURITY_MODE == WF_SECURITY_WPA2_WITH_KEY)      || \
391:                 	              (MY_DEFAULT_WIFI_SECURITY_MODE == WF_SECURITY_WPA_AUTO_WITH_KEY)
392:                 			    memcpypgm2ram(AppConfig.SecurityKey, (ROM void*)MY_DEFAULT_PSK, sizeof(MY_DEFAULT_PSK) - 1);
393:                 			    AppConfig.SecurityKeyLength = sizeof(MY_DEFAULT_PSK) - 1;
394:                 
395:                 	        #elif (MY_DEFAULT_WIFI_SECURITY_MODE == WF_SECURITY_WPA_WITH_PASS_PHRASE)     || \
396:                 	              (MY_DEFAULT_WIFI_SECURITY_MODE == WF_SECURITY_WPA2_WITH_PASS_PHRASE)    || \
397:                 	              (MY_DEFAULT_WIFI_SECURITY_MODE == WF_SECURITY_WPA_AUTO_WITH_PASS_PHRASE)
398:                 	            memcpypgm2ram(AppConfig.SecurityKey, (ROM void*)MY_DEFAULT_PSK_PHRASE, sizeof(MY_DEFAULT_PSK_PHRASE) - 1);
399:                 	            AppConfig.SecurityKeyLength = sizeof(MY_DEFAULT_PSK_PHRASE) - 1;
400:                 			#elif (MY_DEFAULT_WIFI_SECURITY_MODE == WF_SECURITY_WPS_PUSH_BUTTON)
401:                 				memset(AppConfig.SecurityKey, 0x00, sizeof(AppConfig.SecurityKey));
402:                 	            AppConfig.SecurityKeyLength = 0;
403:                 			#elif (MY_DEFAULT_WIFI_SECURITY_MODE == WF_SECURITY_WPS_PIN)
404:                 				memcpypgm2ram(AppConfig.SecurityKey, (ROM void*)MY_DEFAULT_WPS_PIN, sizeof(MY_DEFAULT_WPS_PIN) - 1);
405:                 			    AppConfig.SecurityKeyLength = sizeof(MY_DEFAULT_WPS_PIN) - 1;
406:                 			#elif (MY_DEFAULT_WIFI_SECURITY_MODE == WF_SECURITY_EAP)
407:                 	            memset(AppConfig.SecurityKey, 0x00, sizeof(AppConfig.SecurityKey));
408:                 	            AppConfig.SecurityKeyLength = 0;
409:                 	        #else
410:                 	            #error "No security defined"
411:                 	        #endif /* MY_DEFAULT_WIFI_SECURITY_MODE */
412:                 
413:                 		#endif
414:                 
415:                 		// Compute the checksum of the AppConfig defaults as loaded from ROM
416:                 		wOriginalAppConfigChecksum = CalcIPChecksum((BYTE*)&AppConfig, sizeof(AppConfig));
9D031948  3C02A000   LUI V0, -24576
9D03194C  24440728   ADDIU A0, V0, 1832
9D031950  24050033   ADDIU A1, ZERO, 51
9D031954  0F409A63   JAL CalcIPChecksum
9D031958  00000000   NOP
9D03195C  A78281B8   SH V0, -32328(GP)
417:                 
418:                 		#if defined(EEPROM_CS_TRIS) || defined(SPIFLASH_CS_TRIS)
419:                 		{
420:                 			NVM_VALIDATION_STRUCT NVMValidationStruct;
421:                 
422:                 			// Check to see if we have a flag set indicating that we need to
423:                 			// save the ROM default AppConfig values.
424:                 			if(vNeedToSaveDefaults)
425:                 				SaveAppConfig(&AppConfig);
426:                 
427:                 			// Read the NVMValidation record and AppConfig struct out of EEPROM/Flash
428:                 			#if defined(EEPROM_CS_TRIS)
429:                 			{
430:                 				XEEReadArray(0x0000, (BYTE*)&NVMValidationStruct, sizeof(NVMValidationStruct));
431:                 				XEEReadArray(sizeof(NVMValidationStruct), (BYTE*)&AppConfig, sizeof(AppConfig));
432:                 			}
433:                 			#elif defined(SPIFLASH_CS_TRIS)
434:                 			{
435:                 				SPIFlashReadArray(0x0000, (BYTE*)&NVMValidationStruct, sizeof(NVMValidationStruct));
436:                 				SPIFlashReadArray(sizeof(NVMValidationStruct), (BYTE*)&AppConfig, sizeof(AppConfig));
437:                 			}
438:                 			#endif
439:                 
440:                 			// Check EEPROM/Flash validitity.  If it isn't valid, set a flag so
441:                 			// that we will save the ROM default values on the next loop
442:                 			// iteration.
443:                 			if((NVMValidationStruct.wConfigurationLength != sizeof(AppConfig)) ||
444:                 			   (NVMValidationStruct.wOriginalChecksum != wOriginalAppConfigChecksum) ||
445:                 			   (NVMValidationStruct.wCurrentChecksum != CalcIPChecksum((BYTE*)&AppConfig, sizeof(AppConfig))))
446:                 			{
447:                 				// Check to ensure that the vNeedToSaveDefaults flag is zero,
448:                 				// indicating that this is the first iteration through the do
449:                 				// loop.  If we have already saved the defaults once and the
450:                 				// EEPROM/Flash still doesn't pass the validity check, then it
451:                 				// means we aren't successfully reading or writing to the
452:                 				// EEPROM/Flash.  This means you have a hardware error and/or
453:                 				// SPI configuration error.
454:                 				if(vNeedToSaveDefaults)
455:                 				{
456:                 					while(1);
457:                 				}
458:                 
459:                 				// Set flag and restart loop to load ROM defaults and save them
460:                 				vNeedToSaveDefaults = 1;
461:                 				continue;
462:                 			}
463:                 
464:                 			// If we get down here, it means the EEPROM/Flash has valid contents
465:                 			// and either matches the ROM defaults or previously matched and
466:                 			// was run-time reconfigured by the user.  In this case, we shall
467:                 			// use the contents loaded from EEPROM/Flash.
468:                 			break;
469:                 		}
470:                 		#endif
471:                 		break;
472:                 	}
473:                 }
9D031960  03C0E821   ADDU SP, S8, ZERO
9D031964  8FBF0014   LW RA, 20(SP)
9D031968  8FBE0010   LW S8, 16(SP)
9D03196C  27BD0018   ADDIU SP, SP, 24
9D031970  03E00008   JR RA
9D031974  00000000   NOP
---  C:/Users/Diego/Documents/GitHub/pic32webFREERtos/Pic32Web.X/src/drivers/board/board.c  -------------
1:                   #include<../drivers/board/board.h>
2:                   #include <p32xxxx.h>
3:                   #include<peripheral/ports.h>
4:                   #include<peripheral/osc.h>
5:                   #include<peripheral/system.h>
6:                   
7:                   /**Fuses settings */
8:                   /* Core configuratin fuse settings */
9:                   #pragma config FPLLODIV = DIV_1, FPLLMUL = MUL_20
10:                  #pragma config FPLLIDIV = DIV_2, FWDTEN = OFF
11:                  #pragma config FPBDIV = DIV_1, POSCMOD = XT
12:                  #pragma config FNOSC = PRIPLL, CP = OFF
13:                  #pragma config DEBUG = ON, ICESEL = ICS_PGx2
14:                  
15:                  #define LED1_PORT   IOPORT_D
16:                  #define LED1_PIN    BIT_0
17:                  #define LED2_PORT   IOPORT_D
18:                  #define LED2_PIN    BIT_1
19:                  #define LED3_PORT   IOPORT_D
20:                  #define LED3_PIN    BIT_2
21:                  
22:                  void board_init()
23:                  {
9D03097C  27BDFF80   ADDIU SP, SP, -128
9D030980  AFBF007C   SW RA, 124(SP)
9D030984  AFBE0078   SW S8, 120(SP)
9D030988  03A0F021   ADDU S8, SP, ZERO
9D03098C  3C0204C4   LUI V0, 1220
9D030990  3442B400   ORI V0, V0, -19456
9D030994  AFC20010   SW V0, 16(S8)
9D030998  8FC20010   LW V0, 16(S8)
9D03099C  AFC20014   SW V0, 20(S8)
9D0309A0  8FC20014   LW V0, 20(S8)
9D0309A4  AFC20018   SW V0, 24(S8)
24:                      // Configure system for maximum performance
25:                      SYSTEMConfigPerformance(BOARD_CPU_CLK_HZ);
26:                  #if (BOARD_PB_CLK_DIV == 1)
27:                      mOSCSetPBDIV( OSC_PB_DIV_1 );
28:                  #elif (BOARD_PB_CLK_DIV == 2)
29:                      mOSCSetPBDIV( OSC_PB_DIV_2 );
30:                  #elif (BOARD_PB_CLK_DIV == 4 )
31:                      mOSCSetPBDIV(OSC_PB_DIV_4);
32:                  #elif (BOARD_PB_CLK_DIV == 8)
33:                      mOSCSetPBDIV(OSC_PB_DIV_8);
34:                  #else
35:                  #error Allowed values for the peripheral bus divisor (BOARD_PB_CLK_DIV) are 1,2,4 and 8
36:                  #endif
37:                      INTConfigureSystem(INT_SYSTEM_CONFIG_MULT_VECTOR);
9D030D40  00002021   ADDU A0, ZERO, ZERO
9D030D44  0F40D822   JAL INTConfigureSystem
9D030D48  00000000   NOP
38:                      PORTSetPinsDigitalOut(LED1_PORT,LED1_PIN);
9D030D4C  24040003   ADDIU A0, ZERO, 3
9D030D50  24050001   ADDIU A1, ZERO, 1
9D030D54  0F40D7EA   JAL PORTSetPinsDigitalOut
9D030D58  00000000   NOP
39:                      PORTSetPinsDigitalOut(LED2_PORT,LED2_PIN);
9D030D5C  24040003   ADDIU A0, ZERO, 3
9D030D60  24050002   ADDIU A1, ZERO, 2
9D030D64  0F40D7EA   JAL PORTSetPinsDigitalOut
9D030D68  00000000   NOP
40:                      PORTSetPinsDigitalOut(LED3_PORT,LED3_PIN);
9D030D6C  24040003   ADDIU A0, ZERO, 3
9D030D70  24050004   ADDIU A1, ZERO, 4
9D030D74  0F40D7EA   JAL PORTSetPinsDigitalOut
9D030D78  00000000   NOP
41:                  }
9D030D7C  03C0E821   ADDU SP, S8, ZERO
9D030D80  8FBF007C   LW RA, 124(SP)
9D030D84  8FBE0078   LW S8, 120(SP)
9D030D88  27BD0080   ADDIU SP, SP, 128
9D030D8C  03E00008   JR RA
9D030D90  00000000   NOP
42:                  
43:                  void board_led1_on(){PORTSetBits(LED1_PORT,LED1_PIN);}
9D030D94  27BDFFE8   ADDIU SP, SP, -24
9D030D98  AFBF0014   SW RA, 20(SP)
9D030D9C  AFBE0010   SW S8, 16(SP)
9D030DA0  03A0F021   ADDU S8, SP, ZERO
9D030DA4  24040003   ADDIU A0, ZERO, 3
9D030DA8  24050001   ADDIU A1, ZERO, 1
9D030DAC  0F40D84B   JAL PORTSetBits
9D030DB0  00000000   NOP
9D030DB4  03C0E821   ADDU SP, S8, ZERO
9D030DB8  8FBF0014   LW RA, 20(SP)
9D030DBC  8FBE0010   LW S8, 16(SP)
9D030DC0  27BD0018   ADDIU SP, SP, 24
9D030DC4  03E00008   JR RA
9D030DC8  00000000   NOP
44:                  void board_led1_off(){PORTClearBits(LED1_PORT,LED1_PIN);}
9D030DCC  27BDFFE8   ADDIU SP, SP, -24
9D030DD0  AFBF0014   SW RA, 20(SP)
9D030DD4  AFBE0010   SW S8, 16(SP)
9D030DD8  03A0F021   ADDU S8, SP, ZERO
9D030DDC  24040003   ADDIU A0, ZERO, 3
9D030DE0  24050001   ADDIU A1, ZERO, 1
9D030DE4  0F40D842   JAL PORTClearBits
9D030DE8  00000000   NOP
9D030DEC  03C0E821   ADDU SP, S8, ZERO
9D030DF0  8FBF0014   LW RA, 20(SP)
9D030DF4  8FBE0010   LW S8, 16(SP)
9D030DF8  27BD0018   ADDIU SP, SP, 24
9D030DFC  03E00008   JR RA
9D030E00  00000000   NOP
45:                  void board_led1_toggle(){PORTToggleBits(LED1_PORT,LED1_PIN);}
9D030E04  27BDFFE8   ADDIU SP, SP, -24
9D030E08  AFBF0014   SW RA, 20(SP)
9D030E0C  AFBE0010   SW S8, 16(SP)
9D030E10  03A0F021   ADDU S8, SP, ZERO
9D030E14  24040003   ADDIU A0, ZERO, 3
9D030E18  24050001   ADDIU A1, ZERO, 1
9D030E1C  0F40D854   JAL PORTToggleBits
9D030E20  00000000   NOP
9D030E24  03C0E821   ADDU SP, S8, ZERO
9D030E28  8FBF0014   LW RA, 20(SP)
9D030E2C  8FBE0010   LW S8, 16(SP)
9D030E30  27BD0018   ADDIU SP, SP, 24
9D030E34  03E00008   JR RA
9D030E38  00000000   NOP
46:                  
47:                  void board_led2_on(){PORTSetBits(LED2_PORT,LED2_PIN);}
9D030E3C  27BDFFE8   ADDIU SP, SP, -24
9D030E40  AFBF0014   SW RA, 20(SP)
9D030E44  AFBE0010   SW S8, 16(SP)
9D030E48  03A0F021   ADDU S8, SP, ZERO
9D030E4C  24040003   ADDIU A0, ZERO, 3
9D030E50  24050002   ADDIU A1, ZERO, 2
9D030E54  0F40D84B   JAL PORTSetBits
9D030E58  00000000   NOP
9D030E5C  03C0E821   ADDU SP, S8, ZERO
9D030E60  8FBF0014   LW RA, 20(SP)
9D030E64  8FBE0010   LW S8, 16(SP)
9D030E68  27BD0018   ADDIU SP, SP, 24
9D030E6C  03E00008   JR RA
9D030E70  00000000   NOP
48:                  void board_led2_off(){PORTClearBits(LED2_PORT,LED2_PIN);}
9D030E74  27BDFFE8   ADDIU SP, SP, -24
9D030E78  AFBF0014   SW RA, 20(SP)
9D030E7C  AFBE0010   SW S8, 16(SP)
9D030E80  03A0F021   ADDU S8, SP, ZERO
9D030E84  24040003   ADDIU A0, ZERO, 3
9D030E88  24050002   ADDIU A1, ZERO, 2
9D030E8C  0F40D842   JAL PORTClearBits
9D030E90  00000000   NOP
9D030E94  03C0E821   ADDU SP, S8, ZERO
9D030E98  8FBF0014   LW RA, 20(SP)
9D030E9C  8FBE0010   LW S8, 16(SP)
9D030EA0  27BD0018   ADDIU SP, SP, 24
9D030EA4  03E00008   JR RA
9D030EA8  00000000   NOP
49:                  void board_led2_toggle(){PORTToggleBits(LED2_PORT,LED2_PIN);}
9D030EAC  27BDFFE8   ADDIU SP, SP, -24
9D030EB0  AFBF0014   SW RA, 20(SP)
9D030EB4  AFBE0010   SW S8, 16(SP)
9D030EB8  03A0F021   ADDU S8, SP, ZERO
9D030EBC  24040003   ADDIU A0, ZERO, 3
9D030EC0  24050002   ADDIU A1, ZERO, 2
9D030EC4  0F40D854   JAL PORTToggleBits
9D030EC8  00000000   NOP
9D030ECC  03C0E821   ADDU SP, S8, ZERO
9D030ED0  8FBF0014   LW RA, 20(SP)
9D030ED4  8FBE0010   LW S8, 16(SP)
9D030ED8  27BD0018   ADDIU SP, SP, 24
9D030EDC  03E00008   JR RA
9D030EE0  00000000   NOP
50:                  
51:                  void board_led3_on(){PORTSetBits(LED3_PORT,LED3_PIN);}
9D030EE4  27BDFFE8   ADDIU SP, SP, -24
9D030EE8  AFBF0014   SW RA, 20(SP)
9D030EEC  AFBE0010   SW S8, 16(SP)
9D030EF0  03A0F021   ADDU S8, SP, ZERO
9D030EF4  24040003   ADDIU A0, ZERO, 3
9D030EF8  24050004   ADDIU A1, ZERO, 4
9D030EFC  0F40D84B   JAL PORTSetBits
9D030F00  00000000   NOP
9D030F04  03C0E821   ADDU SP, S8, ZERO
9D030F08  8FBF0014   LW RA, 20(SP)
9D030F0C  8FBE0010   LW S8, 16(SP)
9D030F10  27BD0018   ADDIU SP, SP, 24
9D030F14  03E00008   JR RA
9D030F18  00000000   NOP
52:                  void board_led3_off(){PORTClearBits(LED3_PORT,LED3_PIN);}
9D030F1C  27BDFFE8   ADDIU SP, SP, -24
9D030F20  AFBF0014   SW RA, 20(SP)
9D030F24  AFBE0010   SW S8, 16(SP)
9D030F28  03A0F021   ADDU S8, SP, ZERO
9D030F2C  24040003   ADDIU A0, ZERO, 3
9D030F30  24050004   ADDIU A1, ZERO, 4
9D030F34  0F40D842   JAL PORTClearBits
9D030F38  00000000   NOP
9D030F3C  03C0E821   ADDU SP, S8, ZERO
9D030F40  8FBF0014   LW RA, 20(SP)
9D030F44  8FBE0010   LW S8, 16(SP)
9D030F48  27BD0018   ADDIU SP, SP, 24
9D030F4C  03E00008   JR RA
9D030F50  00000000   NOP
53:                  void board_led3_toggle(){PORTToggleBits(LED3_PORT,LED3_PIN);}
9D030F54  27BDFFE8   ADDIU SP, SP, -24
9D030F58  AFBF0014   SW RA, 20(SP)
9D030F5C  AFBE0010   SW S8, 16(SP)
9D030F60  03A0F021   ADDU S8, SP, ZERO
9D030F64  24040003   ADDIU A0, ZERO, 3
9D030F68  24050004   ADDIU A1, ZERO, 4
9D030F6C  0F40D854   JAL PORTToggleBits
9D030F70  00000000   NOP
9D030F74  03C0E821   ADDU SP, S8, ZERO
9D030F78  8FBF0014   LW RA, 20(SP)
9D030F7C  8FBE0010   LW S8, 16(SP)
9D030F80  27BD0018   ADDIU SP, SP, 24
9D030F84  03E00008   JR RA
9D030F88  00000000   NOP
---  C:/Users/Diego/Documents/GitHub/pic32webFREERtos/Pic32Web.X/src/Unity/unity.c  ---------------------
1:                   /* ==========================================
2:                       Unity Project - A Test Framework for C
3:                       Copyright (c) 2007 Mike Karlesky, Mark VanderVoord, Greg Williams
4:                       [Released under MIT License. Please refer to license.txt for details]
5:                   ========================================== */
6:                   
7:                   #include "unity.h"
8:                   #include <stdio.h>
9:                   #include <string.h>
10:                  
11:                  #define UNITY_FAIL_AND_BAIL   { Unity.CurrentTestFailed  = 1; UNITY_OUTPUT_CHAR('\n'); longjmp(Unity.AbortFrame, 1); }
12:                  #define UNITY_IGNORE_AND_BAIL { Unity.CurrentTestIgnored = 1; UNITY_OUTPUT_CHAR('\n'); longjmp(Unity.AbortFrame, 1); }
13:                  /// return prematurely if we are already in failure or ignore state
14:                  #define UNITY_SKIP_EXECUTION  { if ((Unity.CurrentTestFailed != 0) || (Unity.CurrentTestIgnored != 0)) {return;} }
15:                  #define UNITY_PRINT_EOL       { UNITY_OUTPUT_CHAR('\n'); }
16:                  
17:                  struct _Unity Unity = { 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , {{{ 0 }}} };
18:                  
19:                  const char* UnityStrNull     = "NULL";
20:                  const char* UnityStrSpacer   = ". ";
21:                  const char* UnityStrExpected = " Expected ";
22:                  const char* UnityStrWas      = " Was ";
23:                  const char* UnityStrTo       = " To ";
24:                  const char* UnityStrElement  = " Element ";
25:                  const char* UnityStrByte     = " Byte ";
26:                  const char* UnityStrMemory   = " Memory Mismatch.";
27:                  const char* UnityStrDelta    = " Values Not Within Delta ";
28:                  const char* UnityStrPointless= " You Asked Me To Compare Nothing, Which Was Pointless.";
29:                  const char* UnityStrNullPointerForExpected= " Expected pointer to be NULL";
30:                  const char* UnityStrNullPointerForActual  = " Actual pointer was NULL";
31:                  const char* UnityStrInf      = "Infinity";
32:                  const char* UnityStrNegInf   = "Negative Infinity";
33:                  const char* UnityStrNaN      = "NaN";
34:                  
35:                  #ifndef UNITY_EXCLUDE_FLOAT
36:                  // Dividing by these constants produces +/- infinity.
37:                  // The rationale is given in UnityAssertFloatIsInf's body.
38:                  static const _UF f_zero = 0.0f;
39:                  #ifndef UNITY_EXCLUDE_DOUBLE
40:                  static const _UD d_zero = 0.0;
41:                  #endif
42:                  #endif
43:                  
44:                  // compiler-generic print formatting masks
45:                  const _U_UINT UnitySizeMask[] =
46:                  {
47:                      255u,         // 0xFF
48:                      65535u,       // 0xFFFF
49:                      65535u,
50:                      4294967295u,  // 0xFFFFFFFF
51:                      4294967295u,
52:                      4294967295u,
53:                      4294967295u
54:                  #ifdef UNITY_SUPPORT_64
55:                      ,0xFFFFFFFFFFFFFFFF
56:                  #endif
57:                  };
58:                  
59:                  void UnityPrintFail(void);
60:                  void UnityPrintOk(void);
61:                  
62:                  //-----------------------------------------------
63:                  // Pretty Printers & Test Result Output Handlers
64:                  //-----------------------------------------------
65:                  
66:                  void UnityPrint(const char* string)
67:                  {
9D019D5C  27BDFFE0   ADDIU SP, SP, -32
9D019D60  AFBF001C   SW RA, 28(SP)
9D019D64  AFBE0018   SW S8, 24(SP)
9D019D68  03A0F021   ADDU S8, SP, ZERO
9D019D6C  AFC40020   SW A0, 32(S8)
68:                      const char* pch = string;
9D019D70  8FC20020   LW V0, 32(S8)
9D019D74  AFC20010   SW V0, 16(S8)
69:                  
70:                      if (pch != NULL)
9D019D78  8FC20010   LW V0, 16(S8)
9D019D7C  1040004A   BEQ V0, ZERO, 0x9D019EA8
9D019D80  00000000   NOP
71:                      {
72:                          while (*pch)
9D019D84  0B4067A6   J 0x9D019E98
9D019D88  00000000   NOP
9D019E98  8FC20010   LW V0, 16(S8)
9D019E9C  80420000   LB V0, 0(V0)
9D019EA0  1440FFBA   BNE V0, ZERO, 0x9D019D8C
9D019EA4  00000000   NOP
73:                          {
74:                              // printable characters plus CR & LF are printed
75:                              if ((*pch <= 126) && (*pch >= 32))
9D019D8C  8FC20010   LW V0, 16(S8)
9D019D90  80430000   LB V1, 0(V0)
9D019D94  2402007F   ADDIU V0, ZERO, 127
9D019D98  1062000F   BEQ V1, V0, 0x9D019DD8
9D019D9C  00000000   NOP
9D019DA0  8FC20010   LW V0, 16(S8)
9D019DA4  80420000   LB V0, 0(V0)
9D019DA8  28420020   SLTI V0, V0, 32
9D019DAC  1440000A   BNE V0, ZERO, 0x9D019DD8
9D019DB0  00000000   NOP
76:                              {
77:                                  UNITY_OUTPUT_CHAR(*pch);
9D019DB4  8FC20010   LW V0, 16(S8)
9D019DB8  80420000   LB V0, 0(V0)
9D019DBC  00402021   ADDU A0, V0, ZERO
9D019DC0  3C02A000   LUI V0, -24576
9D019DC4  24452FF4   ADDIU A1, V0, 12276
9D019DC8  0F40D3F2   JAL fputc
9D019DCC  00000000   NOP
9D019DD0  0B4067A3   J 0x9D019E8C
9D019DD4  00000000   NOP
78:                              }
79:                              //write escaped carriage returns
80:                              else if (*pch == 13)
9D019DD8  8FC20010   LW V0, 16(S8)
9D019DDC  80430000   LB V1, 0(V0)
9D019DE0  2402000D   ADDIU V0, ZERO, 13
9D019DE4  1462000D   BNE V1, V0, 0x9D019E1C
9D019DE8  00000000   NOP
81:                              {
82:                                  UNITY_OUTPUT_CHAR('\\');
9D019DEC  2404005C   ADDIU A0, ZERO, 92
9D019DF0  3C02A000   LUI V0, -24576
9D019DF4  24452FF4   ADDIU A1, V0, 12276
9D019DF8  0F40D3F2   JAL fputc
9D019DFC  00000000   NOP
83:                                  UNITY_OUTPUT_CHAR('r');
9D019E00  24040072   ADDIU A0, ZERO, 114
9D019E04  3C02A000   LUI V0, -24576
9D019E08  24452FF4   ADDIU A1, V0, 12276
9D019E0C  0F40D3F2   JAL fputc
9D019E10  00000000   NOP
9D019E14  0B4067A3   J 0x9D019E8C
9D019E18  00000000   NOP
84:                              }
85:                              //write escaped line feeds
86:                              else if (*pch == 10)
9D019E1C  8FC20010   LW V0, 16(S8)
9D019E20  80430000   LB V1, 0(V0)
9D019E24  2402000A   ADDIU V0, ZERO, 10
9D019E28  1462000D   BNE V1, V0, 0x9D019E60
9D019E2C  00000000   NOP
87:                              {
88:                                  UNITY_OUTPUT_CHAR('\\');
9D019E30  2404005C   ADDIU A0, ZERO, 92
9D019E34  3C02A000   LUI V0, -24576
9D019E38  24452FF4   ADDIU A1, V0, 12276
9D019E3C  0F40D3F2   JAL fputc
9D019E40  00000000   NOP
89:                                  UNITY_OUTPUT_CHAR('n');
9D019E44  2404006E   ADDIU A0, ZERO, 110
9D019E48  3C02A000   LUI V0, -24576
9D019E4C  24452FF4   ADDIU A1, V0, 12276
9D019E50  0F40D3F2   JAL fputc
9D019E54  00000000   NOP
9D019E58  0B4067A3   J 0x9D019E8C
9D019E5C  00000000   NOP
90:                              }
91:                              // unprintable characters are shown as codes
92:                              else
93:                              {
94:                                  UNITY_OUTPUT_CHAR('\\');
9D019E60  2404005C   ADDIU A0, ZERO, 92
9D019E64  3C02A000   LUI V0, -24576
9D019E68  24452FF4   ADDIU A1, V0, 12276
9D019E6C  0F40D3F2   JAL fputc
9D019E70  00000000   NOP
95:                                  UnityPrintNumberHex((_U_SINT)*pch, 2);
9D019E74  8FC20010   LW V0, 16(S8)
9D019E78  80420000   LB V0, 0(V0)
9D019E7C  00402021   ADDU A0, V0, ZERO
9D019E80  24050002   ADDIU A1, ZERO, 2
9D019E84  0F40687A   JAL UnityPrintNumberHex
9D019E88  00000000   NOP
96:                              }
97:                              pch++;
9D019E8C  8FC20010   LW V0, 16(S8)
9D019E90  24420001   ADDIU V0, V0, 1
9D019E94  AFC20010   SW V0, 16(S8)
98:                          }
99:                      }
100:                 }
9D019EA8  03C0E821   ADDU SP, S8, ZERO
9D019EAC  8FBF001C   LW RA, 28(SP)
9D019EB0  8FBE0018   LW S8, 24(SP)
9D019EB4  27BD0020   ADDIU SP, SP, 32
9D019EB8  03E00008   JR RA
9D019EBC  00000000   NOP
101:                 
102:                 //-----------------------------------------------
103:                 void UnityPrintNumberByStyle(const _U_SINT number, const UNITY_DISPLAY_STYLE_T style)
104:                 {
9D019EC0  27BDFFE8   ADDIU SP, SP, -24
9D019EC4  AFBF0014   SW RA, 20(SP)
9D019EC8  AFBE0010   SW S8, 16(SP)
9D019ECC  03A0F021   ADDU S8, SP, ZERO
9D019ED0  AFC40018   SW A0, 24(S8)
9D019ED4  AFC5001C   SW A1, 28(S8)
105:                     if ((style & UNITY_DISPLAY_RANGE_INT) == UNITY_DISPLAY_RANGE_INT)
9D019ED8  8FC2001C   LW V0, 28(S8)
9D019EDC  30420010   ANDI V0, V0, 16
9D019EE0  10400006   BEQ V0, ZERO, 0x9D019EFC
9D019EE4  00000000   NOP
106:                     {
107:                         UnityPrintNumber(number);
9D019EE8  8FC40018   LW A0, 24(S8)
9D019EEC  0F4067E1   JAL UnityPrintNumber
9D019EF0  00000000   NOP
9D019EF4  0B4067DB   J 0x9D019F6C
9D019EF8  00000000   NOP
108:                     }
109:                     else if ((style & UNITY_DISPLAY_RANGE_UINT) == UNITY_DISPLAY_RANGE_UINT)
9D019EFC  8FC2001C   LW V0, 28(S8)
9D019F00  30420020   ANDI V0, V0, 32
9D019F04  10400010   BEQ V0, ZERO, 0x9D019F48
9D019F08  00000000   NOP
110:                     {
111:                         UnityPrintNumberUnsigned(  (_U_UINT)number  &  UnitySizeMask[((_U_UINT)style & (_U_UINT)0x0F) - 1]  );
9D019F0C  8FC2001C   LW V0, 28(S8)
9D019F10  3042000F   ANDI V0, V0, 15
9D019F14  2443FFFF   ADDIU V1, V0, -1
9D019F18  3C029D03   LUI V0, -25341
9D019F1C  00031880   SLL V1, V1, 2
9D019F20  244249DC   ADDIU V0, V0, 18908
9D019F24  00621021   ADDU V0, V1, V0
9D019F28  8C430000   LW V1, 0(V0)
9D019F2C  8FC20018   LW V0, 24(S8)
9D019F30  00621024   AND V0, V1, V0
9D019F34  00402021   ADDU A0, V0, ZERO
9D019F38  0F406835   JAL UnityPrintNumberUnsigned
9D019F3C  00000000   NOP
9D019F40  0B4067DB   J 0x9D019F6C
9D019F44  00000000   NOP
112:                     }
113:                     else
114:                     {
115:                         UnityPrintNumberHex((_U_UINT)number, (style & 0x000F) << 1);
9D019F48  8FC30018   LW V1, 24(S8)
9D019F4C  8FC2001C   LW V0, 28(S8)
9D019F50  3042000F   ANDI V0, V0, 15
9D019F54  00021040   SLL V0, V0, 1
9D019F58  7C021420   SEB V0, V0
9D019F5C  00602021   ADDU A0, V1, ZERO
9D019F60  00402821   ADDU A1, V0, ZERO
9D019F64  0F40687A   JAL UnityPrintNumberHex
9D019F68  00000000   NOP
116:                     }
117:                 }
9D019F6C  03C0E821   ADDU SP, S8, ZERO
9D019F70  8FBF0014   LW RA, 20(SP)
9D019F74  8FBE0010   LW S8, 16(SP)
9D019F78  27BD0018   ADDIU SP, SP, 24
9D019F7C  03E00008   JR RA
9D019F80  00000000   NOP
118:                 
119:                 //-----------------------------------------------
120:                 /// basically do an itoa using as little ram as possible
121:                 void UnityPrintNumber(const _U_SINT number_to_print)
122:                 {
9D019F84  27BDFFD8   ADDIU SP, SP, -40
9D019F88  AFBF0024   SW RA, 36(SP)
9D019F8C  AFBE0020   SW S8, 32(SP)
9D019F90  03A0F021   ADDU S8, SP, ZERO
9D019F94  AFC40028   SW A0, 40(S8)
123:                     _U_SINT divisor = 1;
9D019F98  24020001   ADDIU V0, ZERO, 1
9D019F9C  AFC20010   SW V0, 16(S8)
124:                     _U_SINT next_divisor;
125:                     _U_SINT number = number_to_print;
9D019FA0  8FC20028   LW V0, 40(S8)
9D019FA4  AFC20014   SW V0, 20(S8)
126:                 
127:                     if (number < 0)
9D019FA8  8FC20014   LW V0, 20(S8)
9D019FAC  04410018   BGEZ V0, 0x9D01A010
9D019FB0  00000000   NOP
128:                     {
129:                         UNITY_OUTPUT_CHAR('-');
9D019FB4  2404002D   ADDIU A0, ZERO, 45
9D019FB8  3C02A000   LUI V0, -24576
9D019FBC  24452FF4   ADDIU A1, V0, 12276
9D019FC0  0F40D3F2   JAL fputc
9D019FC4  00000000   NOP
130:                         number = -number;
9D019FC8  8FC20014   LW V0, 20(S8)
9D019FCC  00021023   SUBU V0, ZERO, V0
9D019FD0  AFC20014   SW V0, 20(S8)
131:                     }
132:                 
133:                     // figure out initial divisor
134:                     while (number / divisor > 9)
9D019FD4  0B406805   J 0x9D01A014
9D019FD8  00000000   NOP
9D01A010  00000000   NOP
9D01A014  8FC30014   LW V1, 20(S8)
9D01A018  8FC20010   LW V0, 16(S8)
9D01A01C  0062001A   DIV V1, V0
9D01A020  004001F4   TEQ V0, ZERO
9D01A024  00001810   MFHI V1, 0
9D01A028  00001012   MFLO V0, 0
9D01A02C  2842000A   SLTI V0, V0, 10
9D01A030  1040FFEA   BEQ V0, ZERO, 0x9D019FDC
9D01A034  00000000   NOP
9D01A038  0B406811   J 0x9D01A044
9D01A03C  00000000   NOP
135:                     {
136:                         next_divisor = divisor * 10;
9D019FDC  8FC30010   LW V1, 16(S8)
9D019FE0  2402000A   ADDIU V0, ZERO, 10
9D019FE4  70621002   MUL V0, V1, V0
9D019FE8  AFC20018   SW V0, 24(S8)
137:                         if (next_divisor > divisor)
9D019FEC  8FC30018   LW V1, 24(S8)
9D019FF0  8FC20010   LW V0, 16(S8)
9D019FF4  0043102A   SLT V0, V0, V1
9D019FF8  10400011   BEQ V0, ZERO, 0x9D01A040
9D019FFC  00000000   NOP
138:                             divisor = next_divisor;
9D01A000  8FC20018   LW V0, 24(S8)
9D01A004  AFC20010   SW V0, 16(S8)
9D01A008  0B406805   J 0x9D01A014
9D01A00C  00000000   NOP
139:                         else
140:                             break;
9D01A040  00000000   NOP
141:                     }
142:                 
143:                     // now mod and print, then divide divisor
144:                     do
145:                     {
146:                         UNITY_OUTPUT_CHAR((char)('0' + (number / divisor % 10)));
9D01A044  8FC30014   LW V1, 20(S8)
9D01A048  8FC20010   LW V0, 16(S8)
9D01A04C  0062001A   DIV V1, V0
9D01A050  004001F4   TEQ V0, ZERO
9D01A054  00001810   MFHI V1, 0
9D01A058  00001012   MFLO V0, 0
9D01A05C  00401821   ADDU V1, V0, ZERO
9D01A060  2402000A   ADDIU V0, ZERO, 10
9D01A064  0062001A   DIV V1, V0
9D01A068  004001F4   TEQ V0, ZERO
9D01A06C  00001010   MFHI V0, 0
9D01A070  304200FF   ANDI V0, V0, 255
9D01A074  24420030   ADDIU V0, V0, 48
9D01A078  304200FF   ANDI V0, V0, 255
9D01A07C  7C021420   SEB V0, V0
9D01A080  00402021   ADDU A0, V0, ZERO
9D01A084  3C02A000   LUI V0, -24576
9D01A088  24452FF4   ADDIU A1, V0, 12276
9D01A08C  0F40D3F2   JAL fputc
9D01A090  00000000   NOP
147:                         divisor /= 10;
9D01A094  8FC30010   LW V1, 16(S8)
9D01A098  2402000A   ADDIU V0, ZERO, 10
9D01A09C  0062001A   DIV V1, V0
9D01A0A0  004001F4   TEQ V0, ZERO
9D01A0A4  00001810   MFHI V1, 0
9D01A0A8  00001012   MFLO V0, 0
9D01A0AC  AFC20010   SW V0, 16(S8)
148:                     }
149:                     while (divisor > 0);
9D01A0B0  8FC20010   LW V0, 16(S8)
9D01A0B4  1C40FFE3   BGTZ V0, 0x9D01A044
9D01A0B8  00000000   NOP
150:                 }
9D01A0BC  03C0E821   ADDU SP, S8, ZERO
9D01A0C0  8FBF0024   LW RA, 36(SP)
9D01A0C4  8FBE0020   LW S8, 32(SP)
9D01A0C8  27BD0028   ADDIU SP, SP, 40
9D01A0CC  03E00008   JR RA
9D01A0D0  00000000   NOP
151:                 
152:                 //-----------------------------------------------
153:                 /// basically do an itoa using as little ram as possible
154:                 void UnityPrintNumberUnsigned(const _U_UINT number)
155:                 {
9D01A0D4  27BDFFE0   ADDIU SP, SP, -32
9D01A0D8  AFBF001C   SW RA, 28(SP)
9D01A0DC  AFBE0018   SW S8, 24(SP)
9D01A0E0  03A0F021   ADDU S8, SP, ZERO
9D01A0E4  AFC40020   SW A0, 32(S8)
156:                     _U_UINT divisor = 1;
9D01A0E8  24020001   ADDIU V0, ZERO, 1
9D01A0EC  AFC20010   SW V0, 16(S8)
157:                     _U_UINT next_divisor;
158:                 
159:                     // figure out initial divisor
160:                     while (number / divisor > 9)
9D01A0F0  0B406849   J 0x9D01A124
9D01A0F4  00000000   NOP
9D01A124  8FC30020   LW V1, 32(S8)
9D01A128  8FC20010   LW V0, 16(S8)
9D01A12C  0062001B   DIVU V1, V0
9D01A130  004001F4   TEQ V0, ZERO
9D01A134  00001810   MFHI V1, 0
9D01A138  00001012   MFLO V0, 0
9D01A13C  2C42000A   SLTIU V0, V0, 10
9D01A140  1040FFED   BEQ V0, ZERO, 0x9D01A0F8
9D01A144  00000000   NOP
9D01A148  0B406855   J 0x9D01A154
9D01A14C  00000000   NOP
161:                     {
162:                         next_divisor = divisor * 10;
9D01A0F8  8FC30010   LW V1, 16(S8)
9D01A0FC  2402000A   ADDIU V0, ZERO, 10
9D01A100  70621002   MUL V0, V1, V0
9D01A104  AFC20014   SW V0, 20(S8)
163:                         if (next_divisor > divisor)
9D01A108  8FC30014   LW V1, 20(S8)
9D01A10C  8FC20010   LW V0, 16(S8)
9D01A110  0043102B   SLTU V0, V0, V1
9D01A114  1040000E   BEQ V0, ZERO, 0x9D01A150
9D01A118  00000000   NOP
164:                             divisor = next_divisor;
9D01A11C  8FC20014   LW V0, 20(S8)
9D01A120  AFC20010   SW V0, 16(S8)
165:                         else
166:                             break;
9D01A150  00000000   NOP
167:                     }
168:                 
169:                     // now mod and print, then divide divisor
170:                     do
171:                     {
172:                         UNITY_OUTPUT_CHAR((char)('0' + (number / divisor % 10)));
9D01A154  8FC30020   LW V1, 32(S8)
9D01A158  8FC20010   LW V0, 16(S8)
9D01A15C  0062001B   DIVU V1, V0
9D01A160  004001F4   TEQ V0, ZERO
9D01A164  00001810   MFHI V1, 0
9D01A168  00001012   MFLO V0, 0
9D01A16C  00401821   ADDU V1, V0, ZERO
9D01A170  2402000A   ADDIU V0, ZERO, 10
9D01A174  0062001B   DIVU V1, V0
9D01A178  004001F4   TEQ V0, ZERO
9D01A17C  00001010   MFHI V0, 0
9D01A180  304200FF   ANDI V0, V0, 255
9D01A184  24420030   ADDIU V0, V0, 48
9D01A188  304200FF   ANDI V0, V0, 255
9D01A18C  7C021420   SEB V0, V0
9D01A190  00402021   ADDU A0, V0, ZERO
9D01A194  3C02A000   LUI V0, -24576
9D01A198  24452FF4   ADDIU A1, V0, 12276
9D01A19C  0F40D3F2   JAL fputc
9D01A1A0  00000000   NOP
173:                         divisor /= 10;
9D01A1A4  8FC30010   LW V1, 16(S8)
9D01A1A8  3C02CCCC   LUI V0, -13108
9D01A1AC  3442CCCD   ORI V0, V0, -13107
9D01A1B0  00620019   MULTU 0, V1, V0
9D01A1B4  00001012   MFLO V0, 0
9D01A1B8  00001810   MFHI V1, 0
9D01A1BC  000310C2   SRL V0, V1, 3
9D01A1C0  AFC20010   SW V0, 16(S8)
174:                     }
175:                     while (divisor > 0);
9D01A1C4  8FC20010   LW V0, 16(S8)
9D01A1C8  1440FFE2   BNE V0, ZERO, 0x9D01A154
9D01A1CC  00000000   NOP
176:                 }
9D01A1D0  03C0E821   ADDU SP, S8, ZERO
9D01A1D4  8FBF001C   LW RA, 28(SP)
9D01A1D8  8FBE0018   LW S8, 24(SP)
9D01A1DC  27BD0020   ADDIU SP, SP, 32
9D01A1E0  03E00008   JR RA
9D01A1E4  00000000   NOP
177:                 
178:                 //-----------------------------------------------
179:                 void UnityPrintNumberHex(const _U_UINT number, const char nibbles_to_print)
180:                 {
9D01A1E8  27BDFFE0   ADDIU SP, SP, -32
9D01A1EC  AFBF001C   SW RA, 28(SP)
9D01A1F0  AFBE0018   SW S8, 24(SP)
9D01A1F4  03A0F021   ADDU S8, SP, ZERO
9D01A1F8  AFC40020   SW A0, 32(S8)
9D01A1FC  00A01021   ADDU V0, A1, ZERO
9D01A200  A3C20024   SB V0, 36(S8)
181:                     _U_UINT nibble;
182:                     char nibbles = nibbles_to_print;
9D01A204  93C20024   LBU V0, 36(S8)
9D01A208  A3C20010   SB V0, 16(S8)
183:                     UNITY_OUTPUT_CHAR('0');
9D01A20C  24040030   ADDIU A0, ZERO, 48
9D01A210  3C02A000   LUI V0, -24576
9D01A214  24452FF4   ADDIU A1, V0, 12276
9D01A218  0F40D3F2   JAL fputc
9D01A21C  00000000   NOP
184:                     UNITY_OUTPUT_CHAR('x');
9D01A220  24040078   ADDIU A0, ZERO, 120
9D01A224  3C02A000   LUI V0, -24576
9D01A228  24452FF4   ADDIU A1, V0, 12276
9D01A22C  0F40D3F2   JAL fputc
9D01A230  00000000   NOP
185:                 
186:                     while (nibbles > 0)
9D01A234  0B4068B2   J 0x9D01A2C8
9D01A238  00000000   NOP
9D01A2C8  83C20010   LB V0, 16(S8)
9D01A2CC  1C40FFDB   BGTZ V0, 0x9D01A23C
9D01A2D0  00000000   NOP
187:                     {
188:                         nibble = (number >> (--nibbles << 2)) & 0x0000000F;
9D01A23C  93C20010   LBU V0, 16(S8)
9D01A240  2442FFFF   ADDIU V0, V0, -1
9D01A244  A3C20010   SB V0, 16(S8)
9D01A248  83C20010   LB V0, 16(S8)
9D01A24C  00021080   SLL V0, V0, 2
9D01A250  8FC30020   LW V1, 32(S8)
9D01A254  00431006   SRLV V0, V1, V0
9D01A258  3042000F   ANDI V0, V0, 15
9D01A25C  AFC20014   SW V0, 20(S8)
189:                         if (nibble <= 9)
9D01A260  8FC20014   LW V0, 20(S8)
9D01A264  2C42000A   SLTIU V0, V0, 10
9D01A268  1040000D   BEQ V0, ZERO, 0x9D01A2A0
9D01A26C  00000000   NOP
190:                         {
191:                             UNITY_OUTPUT_CHAR((char)('0' + nibble));
9D01A270  8FC20014   LW V0, 20(S8)
9D01A274  304200FF   ANDI V0, V0, 255
9D01A278  24420030   ADDIU V0, V0, 48
9D01A27C  304200FF   ANDI V0, V0, 255
9D01A280  7C021420   SEB V0, V0
9D01A284  00402021   ADDU A0, V0, ZERO
9D01A288  3C02A000   LUI V0, -24576
9D01A28C  24452FF4   ADDIU A1, V0, 12276
9D01A290  0F40D3F2   JAL fputc
9D01A294  00000000   NOP
9D01A298  0B4068B2   J 0x9D01A2C8
9D01A29C  00000000   NOP
192:                         }
193:                         else
194:                         {
195:                             UNITY_OUTPUT_CHAR((char)('A' - 10 + nibble));
9D01A2A0  8FC20014   LW V0, 20(S8)
9D01A2A4  304200FF   ANDI V0, V0, 255
9D01A2A8  24420037   ADDIU V0, V0, 55
9D01A2AC  304200FF   ANDI V0, V0, 255
9D01A2B0  7C021420   SEB V0, V0
9D01A2B4  00402021   ADDU A0, V0, ZERO
9D01A2B8  3C02A000   LUI V0, -24576
9D01A2BC  24452FF4   ADDIU A1, V0, 12276
9D01A2C0  0F40D3F2   JAL fputc
9D01A2C4  00000000   NOP
196:                         }
197:                     }
198:                 }
9D01A2D4  03C0E821   ADDU SP, S8, ZERO
9D01A2D8  8FBF001C   LW RA, 28(SP)
9D01A2DC  8FBE0018   LW S8, 24(SP)
9D01A2E0  27BD0020   ADDIU SP, SP, 32
9D01A2E4  03E00008   JR RA
9D01A2E8  00000000   NOP
199:                 
200:                 //-----------------------------------------------
201:                 void UnityPrintMask(const _U_UINT mask, const _U_UINT number)
202:                 {
9D01A2EC  27BDFFE0   ADDIU SP, SP, -32
9D01A2F0  AFBF001C   SW RA, 28(SP)
9D01A2F4  AFBE0018   SW S8, 24(SP)
9D01A2F8  03A0F021   ADDU S8, SP, ZERO
9D01A2FC  AFC40020   SW A0, 32(S8)
9D01A300  AFC50024   SW A1, 36(S8)
203:                     _U_UINT current_bit = (_U_UINT)1 << (UNITY_INT_WIDTH - 1);
9D01A304  3C028000   LUI V0, -32768
9D01A308  AFC20010   SW V0, 16(S8)
204:                     _US32 i;
205:                 
206:                     for (i = 0; i < UNITY_INT_WIDTH; i++)
9D01A30C  AFC00014   SW ZERO, 20(S8)
9D01A310  0B4068E9   J 0x9D01A3A4
9D01A314  00000000   NOP
9D01A398  8FC20014   LW V0, 20(S8)
9D01A39C  24420001   ADDIU V0, V0, 1
9D01A3A0  AFC20014   SW V0, 20(S8)
9D01A3A4  8FC20014   LW V0, 20(S8)
9D01A3A8  28420020   SLTI V0, V0, 32
9D01A3AC  1440FFDA   BNE V0, ZERO, 0x9D01A318
9D01A3B0  00000000   NOP
207:                     {
208:                         if (current_bit & mask)
9D01A318  8FC30010   LW V1, 16(S8)
9D01A31C  8FC20020   LW V0, 32(S8)
9D01A320  00621024   AND V0, V1, V0
9D01A324  10400014   BEQ V0, ZERO, 0x9D01A378
9D01A328  00000000   NOP
209:                         {
210:                             if (current_bit & number)
9D01A32C  8FC30010   LW V1, 16(S8)
9D01A330  8FC20024   LW V0, 36(S8)
9D01A334  00621024   AND V0, V1, V0
9D01A338  10400008   BEQ V0, ZERO, 0x9D01A35C
9D01A33C  00000000   NOP
211:                             {
212:                                 UNITY_OUTPUT_CHAR('1');
9D01A340  24040031   ADDIU A0, ZERO, 49
9D01A344  3C02A000   LUI V0, -24576
9D01A348  24452FF4   ADDIU A1, V0, 12276
9D01A34C  0F40D3F2   JAL fputc
9D01A350  00000000   NOP
9D01A354  0B4068E3   J 0x9D01A38C
9D01A358  00000000   NOP
213:                             }
214:                             else
215:                             {
216:                                 UNITY_OUTPUT_CHAR('0');
9D01A35C  24040030   ADDIU A0, ZERO, 48
9D01A360  3C02A000   LUI V0, -24576
9D01A364  24452FF4   ADDIU A1, V0, 12276
9D01A368  0F40D3F2   JAL fputc
9D01A36C  00000000   NOP
9D01A370  0B4068E3   J 0x9D01A38C
9D01A374  00000000   NOP
217:                             }
218:                         }
219:                         else
220:                         {
221:                             UNITY_OUTPUT_CHAR('X');
9D01A378  24040058   ADDIU A0, ZERO, 88
9D01A37C  3C02A000   LUI V0, -24576
9D01A380  24452FF4   ADDIU A1, V0, 12276
9D01A384  0F40D3F2   JAL fputc
9D01A388  00000000   NOP
222:                         }
223:                         current_bit = current_bit >> 1;
9D01A38C  8FC20010   LW V0, 16(S8)
9D01A390  00021042   SRL V0, V0, 1
9D01A394  AFC20010   SW V0, 16(S8)
224:                     }
225:                 }
9D01A3B4  03C0E821   ADDU SP, S8, ZERO
9D01A3B8  8FBF001C   LW RA, 28(SP)
9D01A3BC  8FBE0018   LW S8, 24(SP)
9D01A3C0  27BD0020   ADDIU SP, SP, 32
9D01A3C4  03E00008   JR RA
9D01A3C8  00000000   NOP
226:                 
227:                 //-----------------------------------------------
228:                 #ifdef UNITY_FLOAT_VERBOSE
229:                 void UnityPrintFloat(_UF number)
230:                 {
231:                     char TempBuffer[32];
232:                     sprintf(TempBuffer, "%.6f", number);
233:                     UnityPrint(TempBuffer);
234:                 }
235:                 #endif
236:                 
237:                 //-----------------------------------------------
238:                 
239:                 void UnityPrintFail(void)
240:                 {
9D01A3CC  27BDFFE8   ADDIU SP, SP, -24
9D01A3D0  AFBF0014   SW RA, 20(SP)
9D01A3D4  AFBE0010   SW S8, 16(SP)
9D01A3D8  03A0F021   ADDU S8, SP, ZERO
241:                     UnityPrint("FAIL");
9D01A3DC  3C029D03   LUI V0, -25341
9D01A3E0  244449F8   ADDIU A0, V0, 18936
9D01A3E4  0F406757   JAL UnityPrint
9D01A3E8  00000000   NOP
242:                 }
9D01A3EC  03C0E821   ADDU SP, S8, ZERO
9D01A3F0  8FBF0014   LW RA, 20(SP)
9D01A3F4  8FBE0010   LW S8, 16(SP)
9D01A3F8  27BD0018   ADDIU SP, SP, 24
9D01A3FC  03E00008   JR RA
9D01A400  00000000   NOP
243:                 
244:                 void UnityPrintOk(void)
245:                 {
9D01A404  27BDFFE8   ADDIU SP, SP, -24
9D01A408  AFBF0014   SW RA, 20(SP)
9D01A40C  AFBE0010   SW S8, 16(SP)
9D01A410  03A0F021   ADDU S8, SP, ZERO
246:                     UnityPrint("OK");
9D01A414  3C029D03   LUI V0, -25341
9D01A418  24444A00   ADDIU A0, V0, 18944
9D01A41C  0F406757   JAL UnityPrint
9D01A420  00000000   NOP
247:                 }
9D01A424  03C0E821   ADDU SP, S8, ZERO
9D01A428  8FBF0014   LW RA, 20(SP)
9D01A42C  8FBE0010   LW S8, 16(SP)
9D01A430  27BD0018   ADDIU SP, SP, 24
9D01A434  03E00008   JR RA
9D01A438  00000000   NOP
248:                 
249:                 //-----------------------------------------------
250:                 void UnityTestResultsBegin(const char* file, const UNITY_LINE_TYPE line)
251:                 {
9D01A43C  27BDFFE8   ADDIU SP, SP, -24
9D01A440  AFBF0014   SW RA, 20(SP)
9D01A444  AFBE0010   SW S8, 16(SP)
9D01A448  03A0F021   ADDU S8, SP, ZERO
9D01A44C  AFC40018   SW A0, 24(S8)
9D01A450  AFC5001C   SW A1, 28(S8)
252:                     UnityPrint(file);
9D01A454  8FC40018   LW A0, 24(S8)
9D01A458  0F406757   JAL UnityPrint
9D01A45C  00000000   NOP
253:                     UNITY_OUTPUT_CHAR(':');
9D01A460  2404003A   ADDIU A0, ZERO, 58
9D01A464  3C02A000   LUI V0, -24576
9D01A468  24452FF4   ADDIU A1, V0, 12276
9D01A46C  0F40D3F2   JAL fputc
9D01A470  00000000   NOP
254:                     UnityPrintNumber(line);
9D01A474  8FC2001C   LW V0, 28(S8)
9D01A478  00402021   ADDU A0, V0, ZERO
9D01A47C  0F4067E1   JAL UnityPrintNumber
9D01A480  00000000   NOP
255:                     UNITY_OUTPUT_CHAR(':');
9D01A484  2404003A   ADDIU A0, ZERO, 58
9D01A488  3C02A000   LUI V0, -24576
9D01A48C  24452FF4   ADDIU A1, V0, 12276
9D01A490  0F40D3F2   JAL fputc
9D01A494  00000000   NOP
256:                     UnityPrint(Unity.CurrentTestName);
9D01A498  3C02A000   LUI V0, -24576
9D01A49C  24422F00   ADDIU V0, V0, 12032
9D01A4A0  8C420004   LW V0, 4(V0)
9D01A4A4  00402021   ADDU A0, V0, ZERO
9D01A4A8  0F406757   JAL UnityPrint
9D01A4AC  00000000   NOP
257:                     UNITY_OUTPUT_CHAR(':');
9D01A4B0  2404003A   ADDIU A0, ZERO, 58
9D01A4B4  3C02A000   LUI V0, -24576
9D01A4B8  24452FF4   ADDIU A1, V0, 12276
9D01A4BC  0F40D3F2   JAL fputc
9D01A4C0  00000000   NOP
258:                 }
9D01A4C4  03C0E821   ADDU SP, S8, ZERO
9D01A4C8  8FBF0014   LW RA, 20(SP)
9D01A4CC  8FBE0010   LW S8, 16(SP)
9D01A4D0  27BD0018   ADDIU SP, SP, 24
9D01A4D4  03E00008   JR RA
9D01A4D8  00000000   NOP
259:                 
260:                 //-----------------------------------------------
261:                 void UnityTestResultsFailBegin(const UNITY_LINE_TYPE line)
262:                 {
9D01A4DC  27BDFFE8   ADDIU SP, SP, -24
9D01A4E0  AFBF0014   SW RA, 20(SP)
9D01A4E4  AFBE0010   SW S8, 16(SP)
9D01A4E8  03A0F021   ADDU S8, SP, ZERO
9D01A4EC  AFC40018   SW A0, 24(S8)
263:                     UnityTestResultsBegin(Unity.TestFile, line);
9D01A4F0  3C02A000   LUI V0, -24576
9D01A4F4  8C422F00   LW V0, 12032(V0)
9D01A4F8  00402021   ADDU A0, V0, ZERO
9D01A4FC  8FC50018   LW A1, 24(S8)
9D01A500  0F40690F   JAL UnityTestResultsBegin
9D01A504  00000000   NOP
264:                     UnityPrint("FAIL:");
9D01A508  3C029D03   LUI V0, -25341
9D01A50C  24444A04   ADDIU A0, V0, 18948
9D01A510  0F406757   JAL UnityPrint
9D01A514  00000000   NOP
265:                 }
9D01A518  03C0E821   ADDU SP, S8, ZERO
9D01A51C  8FBF0014   LW RA, 20(SP)
9D01A520  8FBE0010   LW S8, 16(SP)
9D01A524  27BD0018   ADDIU SP, SP, 24
9D01A528  03E00008   JR RA
9D01A52C  00000000   NOP
266:                 
267:                 //-----------------------------------------------
268:                 void UnityConcludeTest(void)
269:                 {
9D01A530  27BDFFE8   ADDIU SP, SP, -24
9D01A534  AFBF0014   SW RA, 20(SP)
9D01A538  AFBE0010   SW S8, 16(SP)
9D01A53C  03A0F021   ADDU S8, SP, ZERO
270:                     if (Unity.CurrentTestIgnored)
9D01A540  3C02A000   LUI V0, -24576
9D01A544  24422F00   ADDIU V0, V0, 12032
9D01A548  8C42001C   LW V0, 28(V0)
9D01A54C  1040000A   BEQ V0, ZERO, 0x9D01A578
9D01A550  00000000   NOP
271:                     {
272:                         Unity.TestIgnores++;
9D01A554  3C02A000   LUI V0, -24576
9D01A558  24422F00   ADDIU V0, V0, 12032
9D01A55C  8C420014   LW V0, 20(V0)
9D01A560  24430001   ADDIU V1, V0, 1
9D01A564  3C02A000   LUI V0, -24576
9D01A568  24422F00   ADDIU V0, V0, 12032
9D01A56C  AC430014   SW V1, 20(V0)
9D01A570  0B40697E   J 0x9D01A5F8
9D01A574  00000000   NOP
273:                     }
274:                     else if (!Unity.CurrentTestFailed)
9D01A578  3C02A000   LUI V0, -24576
9D01A57C  24422F00   ADDIU V0, V0, 12032
9D01A580  8C420018   LW V0, 24(V0)
9D01A584  14400015   BNE V0, ZERO, 0x9D01A5DC
9D01A588  00000000   NOP
275:                     {
276:                         UnityTestResultsBegin(Unity.TestFile, Unity.CurrentTestLineNumber);
9D01A58C  3C02A000   LUI V0, -24576
9D01A590  8C432F00   LW V1, 12032(V0)
9D01A594  3C02A000   LUI V0, -24576
9D01A598  24422F00   ADDIU V0, V0, 12032
9D01A59C  8C420008   LW V0, 8(V0)
9D01A5A0  00602021   ADDU A0, V1, ZERO
9D01A5A4  00402821   ADDU A1, V0, ZERO
9D01A5A8  0F40690F   JAL UnityTestResultsBegin
9D01A5AC  00000000   NOP
277:                         UnityPrint("PASS");
9D01A5B0  3C029D03   LUI V0, -25341
9D01A5B4  24444A0C   ADDIU A0, V0, 18956
9D01A5B8  0F406757   JAL UnityPrint
9D01A5BC  00000000   NOP
278:                         UNITY_PRINT_EOL;
9D01A5C0  2404000A   ADDIU A0, ZERO, 10
9D01A5C4  3C02A000   LUI V0, -24576
9D01A5C8  24452FF4   ADDIU A1, V0, 12276
9D01A5CC  0F40D3F2   JAL fputc
9D01A5D0  00000000   NOP
9D01A5D4  0B40697E   J 0x9D01A5F8
9D01A5D8  00000000   NOP
279:                     }
280:                     else
281:                     {
282:                         Unity.TestFailures++;
9D01A5DC  3C02A000   LUI V0, -24576
9D01A5E0  24422F00   ADDIU V0, V0, 12032
9D01A5E4  8C420010   LW V0, 16(V0)
9D01A5E8  24430001   ADDIU V1, V0, 1
9D01A5EC  3C02A000   LUI V0, -24576
9D01A5F0  24422F00   ADDIU V0, V0, 12032
9D01A5F4  AC430010   SW V1, 16(V0)
283:                     }
284:                 
285:                     Unity.CurrentTestFailed = 0;
9D01A5F8  3C02A000   LUI V0, -24576
9D01A5FC  24422F00   ADDIU V0, V0, 12032
9D01A600  AC400018   SW ZERO, 24(V0)
286:                     Unity.CurrentTestIgnored = 0;
9D01A604  3C02A000   LUI V0, -24576
9D01A608  24422F00   ADDIU V0, V0, 12032
9D01A60C  AC40001C   SW ZERO, 28(V0)
287:                 }
9D01A610  03C0E821   ADDU SP, S8, ZERO
9D01A614  8FBF0014   LW RA, 20(SP)
9D01A618  8FBE0010   LW S8, 16(SP)
9D01A61C  27BD0018   ADDIU SP, SP, 24
9D01A620  03E00008   JR RA
9D01A624  00000000   NOP
288:                 
289:                 //-----------------------------------------------
290:                 void UnityAddMsgIfSpecified(const char* msg)
291:                 {
9D01A628  27BDFFE8   ADDIU SP, SP, -24
9D01A62C  AFBF0014   SW RA, 20(SP)
9D01A630  AFBE0010   SW S8, 16(SP)
9D01A634  03A0F021   ADDU S8, SP, ZERO
9D01A638  AFC40018   SW A0, 24(S8)
292:                     if (msg)
9D01A63C  8FC20018   LW V0, 24(S8)
9D01A640  10400008   BEQ V0, ZERO, 0x9D01A664
9D01A644  00000000   NOP
293:                     {
294:                         UnityPrint(UnityStrSpacer);
9D01A648  8F828034   LW V0, -32716(GP)
9D01A64C  00402021   ADDU A0, V0, ZERO
9D01A650  0F406757   JAL UnityPrint
9D01A654  00000000   NOP
295:                         UnityPrint(msg);
9D01A658  8FC40018   LW A0, 24(S8)
9D01A65C  0F406757   JAL UnityPrint
9D01A660  00000000   NOP
296:                     }
297:                 }
9D01A664  03C0E821   ADDU SP, S8, ZERO
9D01A668  8FBF0014   LW RA, 20(SP)
9D01A66C  8FBE0010   LW S8, 16(SP)
9D01A670  27BD0018   ADDIU SP, SP, 24
9D01A674  03E00008   JR RA
9D01A678  00000000   NOP
298:                 
299:                 //-----------------------------------------------
300:                 void UnityPrintExpectedAndActualStrings(const char* expected, const char* actual)
301:                 {
9D01A67C  27BDFFE8   ADDIU SP, SP, -24
9D01A680  AFBF0014   SW RA, 20(SP)
9D01A684  AFBE0010   SW S8, 16(SP)
9D01A688  03A0F021   ADDU S8, SP, ZERO
9D01A68C  AFC40018   SW A0, 24(S8)
9D01A690  AFC5001C   SW A1, 28(S8)
302:                     UnityPrint(UnityStrExpected);
9D01A694  8F828038   LW V0, -32712(GP)
9D01A698  00402021   ADDU A0, V0, ZERO
9D01A69C  0F406757   JAL UnityPrint
9D01A6A0  00000000   NOP
303:                     if (expected != NULL)
9D01A6A4  8FC20018   LW V0, 24(S8)
9D01A6A8  10400010   BEQ V0, ZERO, 0x9D01A6EC
9D01A6AC  00000000   NOP
304:                     {
305:                         UNITY_OUTPUT_CHAR('\'');
9D01A6B0  24040027   ADDIU A0, ZERO, 39
9D01A6B4  3C02A000   LUI V0, -24576
9D01A6B8  24452FF4   ADDIU A1, V0, 12276
9D01A6BC  0F40D3F2   JAL fputc
9D01A6C0  00000000   NOP
306:                         UnityPrint(expected);
9D01A6C4  8FC40018   LW A0, 24(S8)
9D01A6C8  0F406757   JAL UnityPrint
9D01A6CC  00000000   NOP
307:                         UNITY_OUTPUT_CHAR('\'');
9D01A6D0  24040027   ADDIU A0, ZERO, 39
9D01A6D4  3C02A000   LUI V0, -24576
9D01A6D8  24452FF4   ADDIU A1, V0, 12276
9D01A6DC  0F40D3F2   JAL fputc
9D01A6E0  00000000   NOP
9D01A6E4  0B4069BF   J 0x9D01A6FC
9D01A6E8  00000000   NOP
308:                     }
309:                     else
310:                     {
311:                       UnityPrint(UnityStrNull);
9D01A6EC  8F828030   LW V0, -32720(GP)
9D01A6F0  00402021   ADDU A0, V0, ZERO
9D01A6F4  0F406757   JAL UnityPrint
9D01A6F8  00000000   NOP
312:                     }
313:                     UnityPrint(UnityStrWas);
9D01A6FC  8F82803C   LW V0, -32708(GP)
9D01A700  00402021   ADDU A0, V0, ZERO
9D01A704  0F406757   JAL UnityPrint
9D01A708  00000000   NOP
314:                     if (actual != NULL)
9D01A70C  8FC2001C   LW V0, 28(S8)
9D01A710  10400010   BEQ V0, ZERO, 0x9D01A754
9D01A714  00000000   NOP
315:                     {
316:                         UNITY_OUTPUT_CHAR('\'');
9D01A718  24040027   ADDIU A0, ZERO, 39
9D01A71C  3C02A000   LUI V0, -24576
9D01A720  24452FF4   ADDIU A1, V0, 12276
9D01A724  0F40D3F2   JAL fputc
9D01A728  00000000   NOP
317:                         UnityPrint(actual);
9D01A72C  8FC4001C   LW A0, 28(S8)
9D01A730  0F406757   JAL UnityPrint
9D01A734  00000000   NOP
318:                         UNITY_OUTPUT_CHAR('\'');
9D01A738  24040027   ADDIU A0, ZERO, 39
9D01A73C  3C02A000   LUI V0, -24576
9D01A740  24452FF4   ADDIU A1, V0, 12276
9D01A744  0F40D3F2   JAL fputc
9D01A748  00000000   NOP
9D01A74C  0B4069D9   J 0x9D01A764
9D01A750  00000000   NOP
319:                     }
320:                     else
321:                     {
322:                       UnityPrint(UnityStrNull);
9D01A754  8F828030   LW V0, -32720(GP)
9D01A758  00402021   ADDU A0, V0, ZERO
9D01A75C  0F406757   JAL UnityPrint
9D01A760  00000000   NOP
323:                     }
324:                 }
9D01A764  03C0E821   ADDU SP, S8, ZERO
9D01A768  8FBF0014   LW RA, 20(SP)
9D01A76C  8FBE0010   LW S8, 16(SP)
9D01A770  27BD0018   ADDIU SP, SP, 24
9D01A774  03E00008   JR RA
9D01A778  00000000   NOP
325:                 
326:                 //-----------------------------------------------
327:                 // Assertion & Control Helpers
328:                 //-----------------------------------------------
329:                 
330:                 int UnityCheckArraysForNull(UNITY_PTR_ATTRIBUTE const void* expected, UNITY_PTR_ATTRIBUTE const void* actual, const UNITY_LINE_TYPE lineNumber, const char* msg)
331:                 {
9D01A77C  27BDFFE8   ADDIU SP, SP, -24
9D01A780  AFBF0014   SW RA, 20(SP)
9D01A784  AFBE0010   SW S8, 16(SP)
9D01A788  03A0F021   ADDU S8, SP, ZERO
9D01A78C  AFC40018   SW A0, 24(S8)
9D01A790  AFC5001C   SW A1, 28(S8)
9D01A794  AFC60020   SW A2, 32(S8)
9D01A798  AFC70024   SW A3, 36(S8)
332:                     //return true if they are both NULL
333:                     if ((expected == NULL) && (actual == NULL))
9D01A79C  8FC20018   LW V0, 24(S8)
9D01A7A0  14400007   BNE V0, ZERO, 0x9D01A7C0
9D01A7A4  00000000   NOP
9D01A7A8  8FC2001C   LW V0, 28(S8)
9D01A7AC  14400004   BNE V0, ZERO, 0x9D01A7C0
9D01A7B0  00000000   NOP
334:                         return 1;
9D01A7B4  24020001   ADDIU V0, ZERO, 1
9D01A7B8  0B406A27   J 0x9D01A89C
9D01A7BC  00000000   NOP
335:                 
336:                     //throw error if just expected is NULL
337:                     if (expected == NULL)
9D01A7C0  8FC20018   LW V0, 24(S8)
9D01A7C4  14400019   BNE V0, ZERO, 0x9D01A82C
9D01A7C8  00000000   NOP
338:                     {
339:                         UnityTestResultsFailBegin(lineNumber);
9D01A7CC  8FC40020   LW A0, 32(S8)
9D01A7D0  0F406937   JAL UnityTestResultsFailBegin
9D01A7D4  00000000   NOP
340:                         UnityPrint(UnityStrNullPointerForExpected);
9D01A7D8  8F828058   LW V0, -32680(GP)
9D01A7DC  00402021   ADDU A0, V0, ZERO
9D01A7E0  0F406757   JAL UnityPrint
9D01A7E4  00000000   NOP
341:                         UnityAddMsgIfSpecified(msg);
9D01A7E8  8FC40024   LW A0, 36(S8)
9D01A7EC  0F40698A   JAL UnityAddMsgIfSpecified
9D01A7F0  00000000   NOP
342:                         UNITY_FAIL_AND_BAIL;
9D01A7F4  3C02A000   LUI V0, -24576
9D01A7F8  24422F00   ADDIU V0, V0, 12032
9D01A7FC  24030001   ADDIU V1, ZERO, 1
9D01A800  AC430018   SW V1, 24(V0)
9D01A804  2404000A   ADDIU A0, ZERO, 10
9D01A808  3C02A000   LUI V0, -24576
9D01A80C  24452FF4   ADDIU A1, V0, 12276
9D01A810  0F40D3F2   JAL fputc
9D01A814  00000000   NOP
9D01A818  3C02A000   LUI V0, -24576
9D01A81C  24442F20   ADDIU A0, V0, 12064
9D01A820  24050001   ADDIU A1, ZERO, 1
9D01A824  0F40D4F1   JAL 0x9D0353C4
9D01A828  00000000   NOP
343:                     }
344:                 
345:                     //throw error if just actual is NULL
346:                     if (actual == NULL)
9D01A82C  8FC2001C   LW V0, 28(S8)
9D01A830  14400019   BNE V0, ZERO, 0x9D01A898
9D01A834  00000000   NOP
347:                     {
348:                         UnityTestResultsFailBegin(lineNumber);
9D01A838  8FC40020   LW A0, 32(S8)
9D01A83C  0F406937   JAL UnityTestResultsFailBegin
9D01A840  00000000   NOP
349:                         UnityPrint(UnityStrNullPointerForActual);
9D01A844  8F82805C   LW V0, -32676(GP)
9D01A848  00402021   ADDU A0, V0, ZERO
9D01A84C  0F406757   JAL UnityPrint
9D01A850  00000000   NOP
350:                         UnityAddMsgIfSpecified(msg);
9D01A854  8FC40024   LW A0, 36(S8)
9D01A858  0F40698A   JAL UnityAddMsgIfSpecified
9D01A85C  00000000   NOP
351:                         UNITY_FAIL_AND_BAIL;
9D01A860  3C02A000   LUI V0, -24576
9D01A864  24422F00   ADDIU V0, V0, 12032
9D01A868  24030001   ADDIU V1, ZERO, 1
9D01A86C  AC430018   SW V1, 24(V0)
9D01A870  2404000A   ADDIU A0, ZERO, 10
9D01A874  3C02A000   LUI V0, -24576
9D01A878  24452FF4   ADDIU A1, V0, 12276
9D01A87C  0F40D3F2   JAL fputc
9D01A880  00000000   NOP
9D01A884  3C02A000   LUI V0, -24576
9D01A888  24442F20   ADDIU A0, V0, 12064
9D01A88C  24050001   ADDIU A1, ZERO, 1
9D01A890  0F40D4F1   JAL 0x9D0353C4
9D01A894  00000000   NOP
352:                     }
353:                 
354:                     //return false if neither is NULL
355:                     return 0;
9D01A898  00001021   ADDU V0, ZERO, ZERO
356:                 }
9D01A89C  03C0E821   ADDU SP, S8, ZERO
9D01A8A0  8FBF0014   LW RA, 20(SP)
9D01A8A4  8FBE0010   LW S8, 16(SP)
9D01A8A8  27BD0018   ADDIU SP, SP, 24
9D01A8AC  03E00008   JR RA
9D01A8B0  00000000   NOP
357:                 
358:                 //-----------------------------------------------
359:                 // Assertion Functions
360:                 //-----------------------------------------------
361:                 
362:                 void UnityAssertBits(const _U_SINT mask,
363:                                      const _U_SINT expected,
364:                                      const _U_SINT actual,
365:                                      const char* msg,
366:                                      const UNITY_LINE_TYPE lineNumber)
367:                 {
9D01A8B4  27BDFFE8   ADDIU SP, SP, -24
9D01A8B8  AFBF0014   SW RA, 20(SP)
9D01A8BC  AFBE0010   SW S8, 16(SP)
9D01A8C0  03A0F021   ADDU S8, SP, ZERO
9D01A8C4  AFC40018   SW A0, 24(S8)
9D01A8C8  AFC5001C   SW A1, 28(S8)
9D01A8CC  AFC60020   SW A2, 32(S8)
9D01A8D0  AFC70024   SW A3, 36(S8)
368:                     UNITY_SKIP_EXECUTION;
9D01A8D4  3C02A000   LUI V0, -24576
9D01A8D8  24422F00   ADDIU V0, V0, 12032
9D01A8DC  8C420018   LW V0, 24(V0)
9D01A8E0  14400035   BNE V0, ZERO, 0x9D01A9B8
9D01A8E4  00000000   NOP
9D01A8E8  3C02A000   LUI V0, -24576
9D01A8EC  24422F00   ADDIU V0, V0, 12032
9D01A8F0  8C42001C   LW V0, 28(V0)
9D01A8F4  14400030   BNE V0, ZERO, 0x9D01A9B8
9D01A8F8  00000000   NOP
369:                 
370:                     if ((mask & expected) != (mask & actual))
9D01A8FC  8FC3001C   LW V1, 28(S8)
9D01A900  8FC20020   LW V0, 32(S8)
9D01A904  00621826   XOR V1, V1, V0
9D01A908  8FC20018   LW V0, 24(S8)
9D01A90C  00621024   AND V0, V1, V0
9D01A910  10400029   BEQ V0, ZERO, 0x9D01A9B8
9D01A914  00000000   NOP
371:                     {
372:                         UnityTestResultsFailBegin(lineNumber);
9D01A918  8FC40028   LW A0, 40(S8)
9D01A91C  0F406937   JAL UnityTestResultsFailBegin
9D01A920  00000000   NOP
373:                         UnityPrint(UnityStrExpected);
9D01A924  8F828038   LW V0, -32712(GP)
9D01A928  00402021   ADDU A0, V0, ZERO
9D01A92C  0F406757   JAL UnityPrint
9D01A930  00000000   NOP
374:                         UnityPrintMask(mask, expected);
9D01A934  8FC30018   LW V1, 24(S8)
9D01A938  8FC2001C   LW V0, 28(S8)
9D01A93C  00602021   ADDU A0, V1, ZERO
9D01A940  00402821   ADDU A1, V0, ZERO
9D01A944  0F4068BB   JAL UnityPrintMask
9D01A948  00000000   NOP
375:                         UnityPrint(UnityStrWas);
9D01A94C  8F82803C   LW V0, -32708(GP)
9D01A950  00402021   ADDU A0, V0, ZERO
9D01A954  0F406757   JAL UnityPrint
9D01A958  00000000   NOP
376:                         UnityPrintMask(mask, actual);
9D01A95C  8FC30018   LW V1, 24(S8)
9D01A960  8FC20020   LW V0, 32(S8)
9D01A964  00602021   ADDU A0, V1, ZERO
9D01A968  00402821   ADDU A1, V0, ZERO
9D01A96C  0F4068BB   JAL UnityPrintMask
9D01A970  00000000   NOP
377:                         UnityAddMsgIfSpecified(msg);
9D01A974  8FC40024   LW A0, 36(S8)
9D01A978  0F40698A   JAL UnityAddMsgIfSpecified
9D01A97C  00000000   NOP
378:                         UNITY_FAIL_AND_BAIL;
9D01A980  3C02A000   LUI V0, -24576
9D01A984  24422F00   ADDIU V0, V0, 12032
9D01A988  24030001   ADDIU V1, ZERO, 1
9D01A98C  AC430018   SW V1, 24(V0)
9D01A990  2404000A   ADDIU A0, ZERO, 10
9D01A994  3C02A000   LUI V0, -24576
9D01A998  24452FF4   ADDIU A1, V0, 12276
9D01A99C  0F40D3F2   JAL fputc
9D01A9A0  00000000   NOP
9D01A9A4  3C02A000   LUI V0, -24576
9D01A9A8  24442F20   ADDIU A0, V0, 12064
9D01A9AC  24050001   ADDIU A1, ZERO, 1
9D01A9B0  0F40D4F1   JAL 0x9D0353C4
9D01A9B4  00000000   NOP
379:                     }
380:                 }
9D01A9B8  03C0E821   ADDU SP, S8, ZERO
9D01A9BC  8FBF0014   LW RA, 20(SP)
9D01A9C0  8FBE0010   LW S8, 16(SP)
9D01A9C4  27BD0018   ADDIU SP, SP, 24
9D01A9C8  03E00008   JR RA
9D01A9CC  00000000   NOP
381:                 
382:                 //-----------------------------------------------
383:                 void UnityAssertEqualNumber(const _U_SINT expected,
384:                                             const _U_SINT actual,
385:                                             const char* msg,
386:                                             const UNITY_LINE_TYPE lineNumber,
387:                                             const UNITY_DISPLAY_STYLE_T style)
388:                 {
9D01A9D0  27BDFFE8   ADDIU SP, SP, -24
9D01A9D4  AFBF0014   SW RA, 20(SP)
9D01A9D8  AFBE0010   SW S8, 16(SP)
9D01A9DC  03A0F021   ADDU S8, SP, ZERO
9D01A9E0  AFC40018   SW A0, 24(S8)
9D01A9E4  AFC5001C   SW A1, 28(S8)
9D01A9E8  AFC60020   SW A2, 32(S8)
9D01A9EC  AFC70024   SW A3, 36(S8)
389:                     UNITY_SKIP_EXECUTION;
9D01A9F0  3C02A000   LUI V0, -24576
9D01A9F4  24422F00   ADDIU V0, V0, 12032
9D01A9F8  8C420018   LW V0, 24(V0)
9D01A9FC  1440002E   BNE V0, ZERO, 0x9D01AAB8
9D01AA00  00000000   NOP
9D01AA04  3C02A000   LUI V0, -24576
9D01AA08  24422F00   ADDIU V0, V0, 12032
9D01AA0C  8C42001C   LW V0, 28(V0)
9D01AA10  14400029   BNE V0, ZERO, 0x9D01AAB8
9D01AA14  00000000   NOP
390:                 
391:                     if (expected != actual)
9D01AA18  8FC30018   LW V1, 24(S8)
9D01AA1C  8FC2001C   LW V0, 28(S8)
9D01AA20  10620025   BEQ V1, V0, 0x9D01AAB8
9D01AA24  00000000   NOP
392:                     {
393:                         UnityTestResultsFailBegin(lineNumber);
9D01AA28  8FC40024   LW A0, 36(S8)
9D01AA2C  0F406937   JAL UnityTestResultsFailBegin
9D01AA30  00000000   NOP
394:                         UnityPrint(UnityStrExpected);
9D01AA34  8F828038   LW V0, -32712(GP)
9D01AA38  00402021   ADDU A0, V0, ZERO
9D01AA3C  0F406757   JAL UnityPrint
9D01AA40  00000000   NOP
395:                         UnityPrintNumberByStyle(expected, style);
9D01AA44  8FC40018   LW A0, 24(S8)
9D01AA48  8FC50028   LW A1, 40(S8)
9D01AA4C  0F4067B0   JAL UnityPrintNumberByStyle
9D01AA50  00000000   NOP
396:                         UnityPrint(UnityStrWas);
9D01AA54  8F82803C   LW V0, -32708(GP)
9D01AA58  00402021   ADDU A0, V0, ZERO
9D01AA5C  0F406757   JAL UnityPrint
9D01AA60  00000000   NOP
397:                         UnityPrintNumberByStyle(actual, style);
9D01AA64  8FC4001C   LW A0, 28(S8)
9D01AA68  8FC50028   LW A1, 40(S8)
9D01AA6C  0F4067B0   JAL UnityPrintNumberByStyle
9D01AA70  00000000   NOP
398:                         UnityAddMsgIfSpecified(msg);
9D01AA74  8FC40020   LW A0, 32(S8)
9D01AA78  0F40698A   JAL UnityAddMsgIfSpecified
9D01AA7C  00000000   NOP
399:                         UNITY_FAIL_AND_BAIL;
9D01AA80  3C02A000   LUI V0, -24576
9D01AA84  24422F00   ADDIU V0, V0, 12032
9D01AA88  24030001   ADDIU V1, ZERO, 1
9D01AA8C  AC430018   SW V1, 24(V0)
9D01AA90  2404000A   ADDIU A0, ZERO, 10
9D01AA94  3C02A000   LUI V0, -24576
9D01AA98  24452FF4   ADDIU A1, V0, 12276
9D01AA9C  0F40D3F2   JAL fputc
9D01AAA0  00000000   NOP
9D01AAA4  3C02A000   LUI V0, -24576
9D01AAA8  24442F20   ADDIU A0, V0, 12064
9D01AAAC  24050001   ADDIU A1, ZERO, 1
9D01AAB0  0F40D4F1   JAL 0x9D0353C4
9D01AAB4  00000000   NOP
400:                     }
401:                 }
9D01AAB8  03C0E821   ADDU SP, S8, ZERO
9D01AABC  8FBF0014   LW RA, 20(SP)
9D01AAC0  8FBE0010   LW S8, 16(SP)
9D01AAC4  27BD0018   ADDIU SP, SP, 24
9D01AAC8  03E00008   JR RA
9D01AACC  00000000   NOP
402:                 
403:                 //-----------------------------------------------
404:                 void UnityAssertEqualIntArray(UNITY_PTR_ATTRIBUTE const void* expected,
405:                                               UNITY_PTR_ATTRIBUTE const void* actual,
406:                                               const _UU32 num_elements,
407:                                               const char* msg,
408:                                               const UNITY_LINE_TYPE lineNumber,
409:                                               const UNITY_DISPLAY_STYLE_T style)
410:                 {
9D01AAD0  27BDFFD8   ADDIU SP, SP, -40
9D01AAD4  AFBF0024   SW RA, 36(SP)
9D01AAD8  AFBE0020   SW S8, 32(SP)
9D01AADC  03A0F021   ADDU S8, SP, ZERO
9D01AAE0  AFC40028   SW A0, 40(S8)
9D01AAE4  AFC5002C   SW A1, 44(S8)
9D01AAE8  AFC60030   SW A2, 48(S8)
9D01AAEC  AFC70034   SW A3, 52(S8)
411:                     _UU32 elements = num_elements;
9D01AAF0  8FC20030   LW V0, 48(S8)
9D01AAF4  AFC20010   SW V0, 16(S8)
412:                     UNITY_PTR_ATTRIBUTE const _US8* ptr_exp = (UNITY_PTR_ATTRIBUTE _US8*)expected;
9D01AAF8  8FC20028   LW V0, 40(S8)
9D01AAFC  AFC20014   SW V0, 20(S8)
413:                     UNITY_PTR_ATTRIBUTE const _US8* ptr_act = (UNITY_PTR_ATTRIBUTE _US8*)actual;
9D01AB00  8FC2002C   LW V0, 44(S8)
9D01AB04  AFC20018   SW V0, 24(S8)
414:                 
415:                     UNITY_SKIP_EXECUTION;
9D01AB08  3C02A000   LUI V0, -24576
9D01AB0C  24422F00   ADDIU V0, V0, 12032
9D01AB10  8C420018   LW V0, 24(V0)
9D01AB14  14400156   BNE V0, ZERO, 0x9D01B070
9D01AB18  00000000   NOP
9D01AB1C  3C02A000   LUI V0, -24576
9D01AB20  24422F00   ADDIU V0, V0, 12032
9D01AB24  8C42001C   LW V0, 28(V0)
9D01AB28  14400151   BNE V0, ZERO, 0x9D01B070
9D01AB2C  00000000   NOP
416:                 
417:                     if (elements == 0)
9D01AB30  8FC20010   LW V0, 16(S8)
9D01AB34  14400019   BNE V0, ZERO, 0x9D01AB9C
9D01AB38  00000000   NOP
418:                     {
419:                         UnityTestResultsFailBegin(lineNumber);
9D01AB3C  8FC40038   LW A0, 56(S8)
9D01AB40  0F406937   JAL UnityTestResultsFailBegin
9D01AB44  00000000   NOP
420:                         UnityPrint(UnityStrPointless);
9D01AB48  8F828054   LW V0, -32684(GP)
9D01AB4C  00402021   ADDU A0, V0, ZERO
9D01AB50  0F406757   JAL UnityPrint
9D01AB54  00000000   NOP
421:                         UnityAddMsgIfSpecified(msg);
9D01AB58  8FC40034   LW A0, 52(S8)
9D01AB5C  0F40698A   JAL UnityAddMsgIfSpecified
9D01AB60  00000000   NOP
422:                         UNITY_FAIL_AND_BAIL;
9D01AB64  3C02A000   LUI V0, -24576
9D01AB68  24422F00   ADDIU V0, V0, 12032
9D01AB6C  24030001   ADDIU V1, ZERO, 1
9D01AB70  AC430018   SW V1, 24(V0)
9D01AB74  2404000A   ADDIU A0, ZERO, 10
9D01AB78  3C02A000   LUI V0, -24576
9D01AB7C  24452FF4   ADDIU A1, V0, 12276
9D01AB80  0F40D3F2   JAL fputc
9D01AB84  00000000   NOP
9D01AB88  3C02A000   LUI V0, -24576
9D01AB8C  24442F20   ADDIU A0, V0, 12064
9D01AB90  24050001   ADDIU A1, ZERO, 1
9D01AB94  0F40D4F1   JAL 0x9D0353C4
9D01AB98  00000000   NOP
423:                     }
424:                 
425:                     if (UnityCheckArraysForNull((UNITY_PTR_ATTRIBUTE void*)expected, (UNITY_PTR_ATTRIBUTE void*)actual, lineNumber, msg) == 1)
9D01AB9C  8FC40028   LW A0, 40(S8)
9D01ABA0  8FC5002C   LW A1, 44(S8)
9D01ABA4  8FC60038   LW A2, 56(S8)
9D01ABA8  8FC70034   LW A3, 52(S8)
9D01ABAC  0F4069DF   JAL UnityCheckArraysForNull
9D01ABB0  00000000   NOP
9D01ABB4  00401821   ADDU V1, V0, ZERO
9D01ABB8  24020001   ADDIU V0, ZERO, 1
9D01ABBC  1062012B   BEQ V1, V0, 0x9D01B06C
9D01ABC0  00000000   NOP
426:                         return;
9D01B06C  00000000   NOP
427:                 
428:                     // If style is UNITY_DISPLAY_STYLE_INT, we'll fall into the default case rather than the INT16 or INT32 (etc) case
429:                     // as UNITY_DISPLAY_STYLE_INT includes a flag for UNITY_DISPLAY_RANGE_AUTO, which the width-specific
430:                     // variants do not. Therefore remove this flag.
431:                     switch(style & ~UNITY_DISPLAY_RANGE_AUTO)
9D01ABC4  8FC3003C   LW V1, 60(S8)
9D01ABC8  2402FF7F   ADDIU V0, ZERO, -129
9D01ABCC  00621024   AND V0, V1, V0
9D01ABD0  2442FFEF   ADDIU V0, V0, -17
9D01ABD4  2C430032   SLTIU V1, V0, 50
9D01ABD8  10600116   BEQ V1, ZERO, 0x9D01B034
9D01ABDC  00000000   NOP
9D01ABE0  00021880   SLL V1, V0, 2
9D01ABE4  3C029D02   LUI V0, -25342
9D01ABE8  2442ABFC   ADDIU V0, V0, -21508
9D01ABEC  00621021   ADDU V0, V1, V0
9D01ABF0  8C420000   LW V0, 0(V0)
9D01ABF4  00400008   JR V0
9D01ABF8  00000000   NOP
432:                     {
433:                         case UNITY_DISPLAY_STYLE_HEX8:
434:                         case UNITY_DISPLAY_STYLE_INT8:
435:                         case UNITY_DISPLAY_STYLE_UINT8:
436:                             while (elements--)
9D01ADCC  00000000   NOP
9D01ADD0  8FC20010   LW V0, 16(S8)
9D01ADD4  0002102B   SLTU V0, ZERO, V0
9D01ADD8  304200FF   ANDI V0, V0, 255
9D01ADDC  8FC30010   LW V1, 16(S8)
9D01ADE0  2463FFFF   ADDIU V1, V1, -1
9D01ADE4  AFC30010   SW V1, 16(S8)
9D01ADE8  1440FFB6   BNE V0, ZERO, 0x9D01ACC4
9D01ADEC  00000000   NOP
437:                             {
438:                                 if (*ptr_exp != *ptr_act)
9D01ACC4  8FC20014   LW V0, 20(S8)
9D01ACC8  80430000   LB V1, 0(V0)
9D01ACCC  8FC20018   LW V0, 24(S8)
9D01ACD0  80420000   LB V0, 0(V0)
9D01ACD4  10620035   BEQ V1, V0, 0x9D01ADAC
9D01ACD8  00000000   NOP
439:                                 {
440:                                     UnityTestResultsFailBegin(lineNumber);
9D01ACDC  8FC40038   LW A0, 56(S8)
9D01ACE0  0F406937   JAL UnityTestResultsFailBegin
9D01ACE4  00000000   NOP
441:                                     UnityPrint(UnityStrElement);
9D01ACE8  8F828044   LW V0, -32700(GP)
9D01ACEC  00402021   ADDU A0, V0, ZERO
9D01ACF0  0F406757   JAL UnityPrint
9D01ACF4  00000000   NOP
442:                                     UnityPrintNumberByStyle((num_elements - elements - 1), UNITY_DISPLAY_STYLE_UINT);
9D01ACF8  8FC30030   LW V1, 48(S8)
9D01ACFC  8FC20010   LW V0, 16(S8)
9D01AD00  00621023   SUBU V0, V1, V0
9D01AD04  2442FFFF   ADDIU V0, V0, -1
9D01AD08  00402021   ADDU A0, V0, ZERO
9D01AD0C  240500A4   ADDIU A1, ZERO, 164
9D01AD10  0F4067B0   JAL UnityPrintNumberByStyle
9D01AD14  00000000   NOP
443:                                     UnityPrint(UnityStrExpected);
9D01AD18  8F828038   LW V0, -32712(GP)
9D01AD1C  00402021   ADDU A0, V0, ZERO
9D01AD20  0F406757   JAL UnityPrint
9D01AD24  00000000   NOP
444:                                     UnityPrintNumberByStyle(*ptr_exp, style);
9D01AD28  8FC20014   LW V0, 20(S8)
9D01AD2C  80420000   LB V0, 0(V0)
9D01AD30  00402021   ADDU A0, V0, ZERO
9D01AD34  8FC5003C   LW A1, 60(S8)
9D01AD38  0F4067B0   JAL UnityPrintNumberByStyle
9D01AD3C  00000000   NOP
445:                                     UnityPrint(UnityStrWas);
9D01AD40  8F82803C   LW V0, -32708(GP)
9D01AD44  00402021   ADDU A0, V0, ZERO
9D01AD48  0F406757   JAL UnityPrint
9D01AD4C  00000000   NOP
446:                                     UnityPrintNumberByStyle(*ptr_act, style);
9D01AD50  8FC20018   LW V0, 24(S8)
9D01AD54  80420000   LB V0, 0(V0)
9D01AD58  00402021   ADDU A0, V0, ZERO
9D01AD5C  8FC5003C   LW A1, 60(S8)
9D01AD60  0F4067B0   JAL UnityPrintNumberByStyle
9D01AD64  00000000   NOP
447:                                     UnityAddMsgIfSpecified(msg);
9D01AD68  8FC40034   LW A0, 52(S8)
9D01AD6C  0F40698A   JAL UnityAddMsgIfSpecified
9D01AD70  00000000   NOP
448:                                     UNITY_FAIL_AND_BAIL;
9D01AD74  3C02A000   LUI V0, -24576
9D01AD78  24422F00   ADDIU V0, V0, 12032
9D01AD7C  24030001   ADDIU V1, ZERO, 1
9D01AD80  AC430018   SW V1, 24(V0)
9D01AD84  2404000A   ADDIU A0, ZERO, 10
9D01AD88  3C02A000   LUI V0, -24576
9D01AD8C  24452FF4   ADDIU A1, V0, 12276
9D01AD90  0F40D3F2   JAL fputc
9D01AD94  00000000   NOP
9D01AD98  3C02A000   LUI V0, -24576
9D01AD9C  24442F20   ADDIU A0, V0, 12064
9D01ADA0  24050001   ADDIU A1, ZERO, 1
9D01ADA4  0F40D4F1   JAL 0x9D0353C4
9D01ADA8  00000000   NOP
449:                                 }
450:                                 ptr_exp += 1;
9D01ADAC  8FC20014   LW V0, 20(S8)
9D01ADB0  24420001   ADDIU V0, V0, 1
9D01ADB4  AFC20014   SW V0, 20(S8)
451:                                 ptr_act += 1;
9D01ADB8  8FC20018   LW V0, 24(S8)
9D01ADBC  24420001   ADDIU V0, V0, 1
9D01ADC0  AFC20018   SW V0, 24(S8)
9D01ADC4  0B406B74   J 0x9D01ADD0
9D01ADC8  00000000   NOP
452:                             }
453:                             break;
9D01ADF0  0B406C1C   J 0x9D01B070
9D01ADF4  00000000   NOP
454:                         case UNITY_DISPLAY_STYLE_HEX16:
455:                         case UNITY_DISPLAY_STYLE_INT16:
456:                         case UNITY_DISPLAY_STYLE_UINT16:
457:                             while (elements--)
9D01AF00  00000000   NOP
9D01AF04  8FC20010   LW V0, 16(S8)
9D01AF08  0002102B   SLTU V0, ZERO, V0
9D01AF0C  304200FF   ANDI V0, V0, 255
9D01AF10  8FC30010   LW V1, 16(S8)
9D01AF14  2463FFFF   ADDIU V1, V1, -1
9D01AF18  AFC30010   SW V1, 16(S8)
9D01AF1C  1440FFB6   BNE V0, ZERO, 0x9D01ADF8
9D01AF20  00000000   NOP
458:                             {
459:                                 if (*(UNITY_PTR_ATTRIBUTE _US16*)ptr_exp != *(UNITY_PTR_ATTRIBUTE _US16*)ptr_act)
9D01ADF8  8FC20014   LW V0, 20(S8)
9D01ADFC  84430000   LH V1, 0(V0)
9D01AE00  8FC20018   LW V0, 24(S8)
9D01AE04  84420000   LH V0, 0(V0)
9D01AE08  10620035   BEQ V1, V0, 0x9D01AEE0
9D01AE0C  00000000   NOP
460:                                 {
461:                                     UnityTestResultsFailBegin(lineNumber);
9D01AE10  8FC40038   LW A0, 56(S8)
9D01AE14  0F406937   JAL UnityTestResultsFailBegin
9D01AE18  00000000   NOP
462:                                     UnityPrint(UnityStrElement);
9D01AE1C  8F828044   LW V0, -32700(GP)
9D01AE20  00402021   ADDU A0, V0, ZERO
9D01AE24  0F406757   JAL UnityPrint
9D01AE28  00000000   NOP
463:                                     UnityPrintNumberByStyle((num_elements - elements - 1), UNITY_DISPLAY_STYLE_UINT);
9D01AE2C  8FC30030   LW V1, 48(S8)
9D01AE30  8FC20010   LW V0, 16(S8)
9D01AE34  00621023   SUBU V0, V1, V0
9D01AE38  2442FFFF   ADDIU V0, V0, -1
9D01AE3C  00402021   ADDU A0, V0, ZERO
9D01AE40  240500A4   ADDIU A1, ZERO, 164
9D01AE44  0F4067B0   JAL UnityPrintNumberByStyle
9D01AE48  00000000   NOP
464:                                     UnityPrint(UnityStrExpected);
9D01AE4C  8F828038   LW V0, -32712(GP)
9D01AE50  00402021   ADDU A0, V0, ZERO
9D01AE54  0F406757   JAL UnityPrint
9D01AE58  00000000   NOP
465:                                     UnityPrintNumberByStyle(*(UNITY_PTR_ATTRIBUTE _US16*)ptr_exp, style);
9D01AE5C  8FC20014   LW V0, 20(S8)
9D01AE60  84420000   LH V0, 0(V0)
9D01AE64  00402021   ADDU A0, V0, ZERO
9D01AE68  8FC5003C   LW A1, 60(S8)
9D01AE6C  0F4067B0   JAL UnityPrintNumberByStyle
9D01AE70  00000000   NOP
466:                                     UnityPrint(UnityStrWas);
9D01AE74  8F82803C   LW V0, -32708(GP)
9D01AE78  00402021   ADDU A0, V0, ZERO
9D01AE7C  0F406757   JAL UnityPrint
9D01AE80  00000000   NOP
467:                                     UnityPrintNumberByStyle(*(UNITY_PTR_ATTRIBUTE _US16*)ptr_act, style);
9D01AE84  8FC20018   LW V0, 24(S8)
9D01AE88  84420000   LH V0, 0(V0)
9D01AE8C  00402021   ADDU A0, V0, ZERO
9D01AE90  8FC5003C   LW A1, 60(S8)
9D01AE94  0F4067B0   JAL UnityPrintNumberByStyle
9D01AE98  00000000   NOP
468:                                     UnityAddMsgIfSpecified(msg);
9D01AE9C  8FC40034   LW A0, 52(S8)
9D01AEA0  0F40698A   JAL UnityAddMsgIfSpecified
9D01AEA4  00000000   NOP
469:                                     UNITY_FAIL_AND_BAIL;
9D01AEA8  3C02A000   LUI V0, -24576
9D01AEAC  24422F00   ADDIU V0, V0, 12032
9D01AEB0  24030001   ADDIU V1, ZERO, 1
9D01AEB4  AC430018   SW V1, 24(V0)
9D01AEB8  2404000A   ADDIU A0, ZERO, 10
9D01AEBC  3C02A000   LUI V0, -24576
9D01AEC0  24452FF4   ADDIU A1, V0, 12276
9D01AEC4  0F40D3F2   JAL fputc
9D01AEC8  00000000   NOP
9D01AECC  3C02A000   LUI V0, -24576
9D01AED0  24442F20   ADDIU A0, V0, 12064
9D01AED4  24050001   ADDIU A1, ZERO, 1
9D01AED8  0F40D4F1   JAL 0x9D0353C4
9D01AEDC  00000000   NOP
470:                                 }
471:                                 ptr_exp += 2;
9D01AEE0  8FC20014   LW V0, 20(S8)
9D01AEE4  24420002   ADDIU V0, V0, 2
9D01AEE8  AFC20014   SW V0, 20(S8)
472:                                 ptr_act += 2;
9D01AEEC  8FC20018   LW V0, 24(S8)
9D01AEF0  24420002   ADDIU V0, V0, 2
9D01AEF4  AFC20018   SW V0, 24(S8)
9D01AEF8  0B406BC1   J 0x9D01AF04
9D01AEFC  00000000   NOP
473:                             }
474:                             break;
9D01AF24  0B406C1C   J 0x9D01B070
9D01AF28  00000000   NOP
475:                 #ifdef UNITY_SUPPORT_64
476:                         case UNITY_DISPLAY_STYLE_HEX64:
477:                         case UNITY_DISPLAY_STYLE_INT64:
478:                         case UNITY_DISPLAY_STYLE_UINT64:
479:                             while (elements--)
480:                             {
481:                                 if (*(UNITY_PTR_ATTRIBUTE _US64*)ptr_exp != *(UNITY_PTR_ATTRIBUTE _US64*)ptr_act)
482:                                 {
483:                                     UnityTestResultsFailBegin(lineNumber);
484:                                     UnityPrint(UnityStrElement);
485:                                     UnityPrintNumberByStyle((num_elements - elements - 1), UNITY_DISPLAY_STYLE_UINT);
486:                                     UnityPrint(UnityStrExpected);
487:                                     UnityPrintNumberByStyle(*(UNITY_PTR_ATTRIBUTE _US64*)ptr_exp, style);
488:                                     UnityPrint(UnityStrWas);
489:                                     UnityPrintNumberByStyle(*(UNITY_PTR_ATTRIBUTE _US64*)ptr_act, style);
490:                                     UnityAddMsgIfSpecified(msg);
491:                                     UNITY_FAIL_AND_BAIL;
492:                                 }
493:                                 ptr_exp += 8;
494:                                 ptr_act += 8;
495:                             }
496:                             break;
497:                 #endif
498:                         default:
499:                             while (elements--)
9D01B034  00000000   NOP
9D01B038  0B406C11   J 0x9D01B044
9D01B03C  00000000   NOP
9D01B040  00000000   NOP
9D01B044  8FC20010   LW V0, 16(S8)
9D01B048  0002102B   SLTU V0, ZERO, V0
9D01B04C  304200FF   ANDI V0, V0, 255
9D01B050  8FC30010   LW V1, 16(S8)
9D01B054  2463FFFF   ADDIU V1, V1, -1
9D01B058  AFC30010   SW V1, 16(S8)
9D01B05C  1440FFB3   BNE V0, ZERO, 0x9D01AF2C
9D01B060  00000000   NOP
500:                             {
501:                                 if (*(UNITY_PTR_ATTRIBUTE _US32*)ptr_exp != *(UNITY_PTR_ATTRIBUTE _US32*)ptr_act)
9D01AF2C  8FC20014   LW V0, 20(S8)
9D01AF30  8C430000   LW V1, 0(V0)
9D01AF34  8FC20018   LW V0, 24(S8)
9D01AF38  8C420000   LW V0, 0(V0)
9D01AF3C  10620035   BEQ V1, V0, 0x9D01B014
9D01AF40  00000000   NOP
502:                                 {
503:                                     UnityTestResultsFailBegin(lineNumber);
9D01AF44  8FC40038   LW A0, 56(S8)
9D01AF48  0F406937   JAL UnityTestResultsFailBegin
9D01AF4C  00000000   NOP
504:                                     UnityPrint(UnityStrElement);
9D01AF50  8F828044   LW V0, -32700(GP)
9D01AF54  00402021   ADDU A0, V0, ZERO
9D01AF58  0F406757   JAL UnityPrint
9D01AF5C  00000000   NOP
505:                                     UnityPrintNumberByStyle((num_elements - elements - 1), UNITY_DISPLAY_STYLE_UINT);
9D01AF60  8FC30030   LW V1, 48(S8)
9D01AF64  8FC20010   LW V0, 16(S8)
9D01AF68  00621023   SUBU V0, V1, V0
9D01AF6C  2442FFFF   ADDIU V0, V0, -1
9D01AF70  00402021   ADDU A0, V0, ZERO
9D01AF74  240500A4   ADDIU A1, ZERO, 164
9D01AF78  0F4067B0   JAL UnityPrintNumberByStyle
9D01AF7C  00000000   NOP
506:                                     UnityPrint(UnityStrExpected);
9D01AF80  8F828038   LW V0, -32712(GP)
9D01AF84  00402021   ADDU A0, V0, ZERO
9D01AF88  0F406757   JAL UnityPrint
9D01AF8C  00000000   NOP
507:                                     UnityPrintNumberByStyle(*(UNITY_PTR_ATTRIBUTE _US32*)ptr_exp, style);
9D01AF90  8FC20014   LW V0, 20(S8)
9D01AF94  8C420000   LW V0, 0(V0)
9D01AF98  00402021   ADDU A0, V0, ZERO
9D01AF9C  8FC5003C   LW A1, 60(S8)
9D01AFA0  0F4067B0   JAL UnityPrintNumberByStyle
9D01AFA4  00000000   NOP
508:                                     UnityPrint(UnityStrWas);
9D01AFA8  8F82803C   LW V0, -32708(GP)
9D01AFAC  00402021   ADDU A0, V0, ZERO
9D01AFB0  0F406757   JAL UnityPrint
9D01AFB4  00000000   NOP
509:                                     UnityPrintNumberByStyle(*(UNITY_PTR_ATTRIBUTE _US32*)ptr_act, style);
9D01AFB8  8FC20018   LW V0, 24(S8)
9D01AFBC  8C420000   LW V0, 0(V0)
9D01AFC0  00402021   ADDU A0, V0, ZERO
9D01AFC4  8FC5003C   LW A1, 60(S8)
9D01AFC8  0F4067B0   JAL UnityPrintNumberByStyle
9D01AFCC  00000000   NOP
510:                                     UnityAddMsgIfSpecified(msg);
9D01AFD0  8FC40034   LW A0, 52(S8)
9D01AFD4  0F40698A   JAL UnityAddMsgIfSpecified
9D01AFD8  00000000   NOP
511:                                     UNITY_FAIL_AND_BAIL;
9D01AFDC  3C02A000   LUI V0, -24576
9D01AFE0  24422F00   ADDIU V0, V0, 12032
9D01AFE4  24030001   ADDIU V1, ZERO, 1
9D01AFE8  AC430018   SW V1, 24(V0)
9D01AFEC  2404000A   ADDIU A0, ZERO, 10
9D01AFF0  3C02A000   LUI V0, -24576
9D01AFF4  24452FF4   ADDIU A1, V0, 12276
9D01AFF8  0F40D3F2   JAL fputc
9D01AFFC  00000000   NOP
9D01B000  3C02A000   LUI V0, -24576
9D01B004  24442F20   ADDIU A0, V0, 12064
9D01B008  24050001   ADDIU A1, ZERO, 1
9D01B00C  0F40D4F1   JAL 0x9D0353C4
9D01B010  00000000   NOP
512:                                 }
513:                                 ptr_exp += 4;
9D01B014  8FC20014   LW V0, 20(S8)
9D01B018  24420004   ADDIU V0, V0, 4
9D01B01C  AFC20014   SW V0, 20(S8)
514:                                 ptr_act += 4;
9D01B020  8FC20018   LW V0, 24(S8)
9D01B024  24420004   ADDIU V0, V0, 4
9D01B028  AFC20018   SW V0, 24(S8)
9D01B02C  0B406C11   J 0x9D01B044
9D01B030  00000000   NOP
515:                             }
516:                             break;
9D01B064  0B406C1C   J 0x9D01B070
9D01B068  00000000   NOP
517:                     }
518:                 }
9D01B070  03C0E821   ADDU SP, S8, ZERO
9D01B074  8FBF0024   LW RA, 36(SP)
9D01B078  8FBE0020   LW S8, 32(SP)
9D01B07C  27BD0028   ADDIU SP, SP, 40
9D01B080  03E00008   JR RA
9D01B084  00000000   NOP
519:                 
520:                 //-----------------------------------------------
521:                 #ifndef UNITY_EXCLUDE_FLOAT
522:                 void UnityAssertEqualFloatArray(UNITY_PTR_ATTRIBUTE const _UF* expected,
523:                                                 UNITY_PTR_ATTRIBUTE const _UF* actual,
524:                                                 const _UU32 num_elements,
525:                                                 const char* msg,
526:                                                 const UNITY_LINE_TYPE lineNumber)
527:                 {
9D01B088  27BDFFC8   ADDIU SP, SP, -56
9D01B08C  AFBF0034   SW RA, 52(SP)
9D01B090  AFBE0030   SW S8, 48(SP)
9D01B094  AFB0002C   SW S0, 44(SP)
9D01B098  03A0F021   ADDU S8, SP, ZERO
9D01B09C  AFC40038   SW A0, 56(S8)
9D01B0A0  AFC5003C   SW A1, 60(S8)
9D01B0A4  AFC60040   SW A2, 64(S8)
9D01B0A8  AFC70044   SW A3, 68(S8)
528:                     _UU32 elements = num_elements;
9D01B0AC  8FC20040   LW V0, 64(S8)
9D01B0B0  AFC20010   SW V0, 16(S8)
529:                     UNITY_PTR_ATTRIBUTE const _UF* ptr_expected = expected;
9D01B0B4  8FC20038   LW V0, 56(S8)
9D01B0B8  AFC20014   SW V0, 20(S8)
530:                     UNITY_PTR_ATTRIBUTE const _UF* ptr_actual = actual;
9D01B0BC  8FC2003C   LW V0, 60(S8)
9D01B0C0  AFC20018   SW V0, 24(S8)
531:                     _UF diff, tol;
532:                 
533:                     UNITY_SKIP_EXECUTION;
9D01B0C4  3C02A000   LUI V0, -24576
9D01B0C8  24422F00   ADDIU V0, V0, 12032
9D01B0CC  8C420018   LW V0, 24(V0)
9D01B0D0  144000A8   BNE V0, ZERO, 0x9D01B374
9D01B0D4  00000000   NOP
9D01B0D8  3C02A000   LUI V0, -24576
9D01B0DC  24422F00   ADDIU V0, V0, 12032
9D01B0E0  8C42001C   LW V0, 28(V0)
9D01B0E4  144000A3   BNE V0, ZERO, 0x9D01B374
9D01B0E8  00000000   NOP
534:                 
535:                     if (elements == 0)
9D01B0EC  8FC20010   LW V0, 16(S8)
9D01B0F0  14400019   BNE V0, ZERO, 0x9D01B158
9D01B0F4  00000000   NOP
536:                     {
537:                         UnityTestResultsFailBegin(lineNumber);
9D01B0F8  8FC40048   LW A0, 72(S8)
9D01B0FC  0F406937   JAL UnityTestResultsFailBegin
9D01B100  00000000   NOP
538:                         UnityPrint(UnityStrPointless);
9D01B104  8F828054   LW V0, -32684(GP)
9D01B108  00402021   ADDU A0, V0, ZERO
9D01B10C  0F406757   JAL UnityPrint
9D01B110  00000000   NOP
539:                         UnityAddMsgIfSpecified(msg);
9D01B114  8FC40044   LW A0, 68(S8)
9D01B118  0F40698A   JAL UnityAddMsgIfSpecified
9D01B11C  00000000   NOP
540:                         UNITY_FAIL_AND_BAIL;
9D01B120  3C02A000   LUI V0, -24576
9D01B124  24422F00   ADDIU V0, V0, 12032
9D01B128  24030001   ADDIU V1, ZERO, 1
9D01B12C  AC430018   SW V1, 24(V0)
9D01B130  2404000A   ADDIU A0, ZERO, 10
9D01B134  3C02A000   LUI V0, -24576
9D01B138  24452FF4   ADDIU A1, V0, 12276
9D01B13C  0F40D3F2   JAL fputc
9D01B140  00000000   NOP
9D01B144  3C02A000   LUI V0, -24576
9D01B148  24442F20   ADDIU A0, V0, 12064
9D01B14C  24050001   ADDIU A1, ZERO, 1
9D01B150  0F40D4F1   JAL 0x9D0353C4
9D01B154  00000000   NOP
541:                     }
542:                 
543:                     if (UnityCheckArraysForNull((UNITY_PTR_ATTRIBUTE void*)expected, (UNITY_PTR_ATTRIBUTE void*)actual, lineNumber, msg) == 1)
9D01B158  8FC40038   LW A0, 56(S8)
9D01B15C  8FC5003C   LW A1, 60(S8)
9D01B160  8FC60048   LW A2, 72(S8)
9D01B164  8FC70044   LW A3, 68(S8)
9D01B168  0F4069DF   JAL UnityCheckArraysForNull
9D01B16C  00000000   NOP
9D01B170  00401821   ADDU V1, V0, ZERO
9D01B174  24020001   ADDIU V0, ZERO, 1
9D01B178  14620075   BNE V1, V0, 0x9D01B350
9D01B17C  00000000   NOP
544:                         return;
9D01B180  0B406CDD   J 0x9D01B374
9D01B184  00000000   NOP
545:                 
546:                     while (elements--)
9D01B350  00000000   NOP
9D01B354  8FC20010   LW V0, 16(S8)
9D01B358  0002102B   SLTU V0, ZERO, V0
9D01B35C  304200FF   ANDI V0, V0, 255
9D01B360  8FC30010   LW V1, 16(S8)
9D01B364  2463FFFF   ADDIU V1, V1, -1
9D01B368  AFC30010   SW V1, 16(S8)
9D01B36C  1440FF86   BNE V0, ZERO, 0x9D01B188
9D01B370  00000000   NOP
547:                     {
548:                         diff = *ptr_expected - *ptr_actual;
9D01B188  8FC20014   LW V0, 20(S8)
9D01B18C  8C430000   LW V1, 0(V0)
9D01B190  8FC20018   LW V0, 24(S8)
9D01B194  8C420000   LW V0, 0(V0)
9D01B198  00602021   ADDU A0, V1, ZERO
9D01B19C  00402821   ADDU A1, V0, ZERO
9D01B1A0  0F40B56C   JAL __subsf3
9D01B1A4  00000000   NOP
9D01B1A8  AFC2001C   SW V0, 28(S8)
549:                         if (diff < 0.0f)
9D01B1AC  24100001   ADDIU S0, ZERO, 1
9D01B1B0  8FC4001C   LW A0, 28(S8)
9D01B1B4  00002821   ADDU A1, ZERO, ZERO
9D01B1B8  0F40B767   JAL __lesf2
9D01B1BC  00000000   NOP
9D01B1C0  04400002   BLTZ V0, 0x9D01B1CC
9D01B1C4  00000000   NOP
9D01B1C8  00008021   ADDU S0, ZERO, ZERO
9D01B1CC  320200FF   ANDI V0, S0, 255
9D01B1D0  10400006   BEQ V0, ZERO, 0x9D01B1EC
9D01B1D4  00000000   NOP
550:                           diff = 0.0f - diff;
9D01B1D8  00002021   ADDU A0, ZERO, ZERO
9D01B1DC  8FC5001C   LW A1, 28(S8)
9D01B1E0  0F40B56C   JAL __subsf3
9D01B1E4  00000000   NOP
9D01B1E8  AFC2001C   SW V0, 28(S8)
551:                         tol = UNITY_FLOAT_PRECISION * *ptr_expected;
9D01B1EC  8FC20014   LW V0, 20(S8)
9D01B1F0  8C430000   LW V1, 0(V0)
9D01B1F4  3C029D03   LUI V0, -25341
9D01B1F8  00602021   ADDU A0, V1, ZERO
9D01B1FC  8C454A54   LW A1, 19028(V0)
9D01B200  0F40B609   JAL __mulsf3
9D01B204  00000000   NOP
9D01B208  AFC20020   SW V0, 32(S8)
552:                         if (tol < 0.0f)
9D01B20C  24100001   ADDIU S0, ZERO, 1
9D01B210  8FC40020   LW A0, 32(S8)
9D01B214  00002821   ADDU A1, ZERO, ZERO
9D01B218  0F40B767   JAL __lesf2
9D01B21C  00000000   NOP
9D01B220  04400002   BLTZ V0, 0x9D01B22C
9D01B224  00000000   NOP
9D01B228  00008021   ADDU S0, ZERO, ZERO
9D01B22C  320200FF   ANDI V0, S0, 255
9D01B230  10400006   BEQ V0, ZERO, 0x9D01B24C
9D01B234  00000000   NOP
553:                             tol = 0.0f - tol;
9D01B238  00002021   ADDU A0, ZERO, ZERO
9D01B23C  8FC50020   LW A1, 32(S8)
9D01B240  0F40B56C   JAL __subsf3
9D01B244  00000000   NOP
9D01B248  AFC20020   SW V0, 32(S8)
554:                 
555:                         //This first part of this condition will catch any NaN or Infinite values
556:                         if ((diff * 0.0f != 0.0f) || (diff > tol))
9D01B24C  8FC4001C   LW A0, 28(S8)
9D01B250  00002821   ADDU A1, ZERO, ZERO
9D01B254  0F40B609   JAL __mulsf3
9D01B258  00000000   NOP
9D01B25C  00402021   ADDU A0, V0, ZERO
9D01B260  00002821   ADDU A1, ZERO, ZERO
9D01B264  0F40B767   JAL __lesf2
9D01B268  00000000   NOP
9D01B26C  1440000C   BNE V0, ZERO, 0x9D01B2A0
9D01B270  00000000   NOP
9D01B274  24100001   ADDIU S0, ZERO, 1
9D01B278  8FC40020   LW A0, 32(S8)
9D01B27C  8FC5001C   LW A1, 28(S8)
9D01B280  0F40B767   JAL __lesf2
9D01B284  00000000   NOP
9D01B288  04400002   BLTZ V0, 0x9D01B294
9D01B28C  00000000   NOP
9D01B290  00008021   ADDU S0, ZERO, ZERO
9D01B294  320200FF   ANDI V0, S0, 255
9D01B298  10400025   BEQ V0, ZERO, 0x9D01B330
9D01B29C  00000000   NOP
557:                         {
558:                             UnityTestResultsFailBegin(lineNumber);
9D01B2A0  8FC40048   LW A0, 72(S8)
9D01B2A4  0F406937   JAL UnityTestResultsFailBegin
9D01B2A8  00000000   NOP
559:                             UnityPrint(UnityStrElement);
9D01B2AC  8F828044   LW V0, -32700(GP)
9D01B2B0  00402021   ADDU A0, V0, ZERO
9D01B2B4  0F406757   JAL UnityPrint
9D01B2B8  00000000   NOP
560:                             UnityPrintNumberByStyle((num_elements - elements - 1), UNITY_DISPLAY_STYLE_UINT);
9D01B2BC  8FC30040   LW V1, 64(S8)
9D01B2C0  8FC20010   LW V0, 16(S8)
9D01B2C4  00621023   SUBU V0, V1, V0
9D01B2C8  2442FFFF   ADDIU V0, V0, -1
9D01B2CC  00402021   ADDU A0, V0, ZERO
9D01B2D0  240500A4   ADDIU A1, ZERO, 164
9D01B2D4  0F4067B0   JAL UnityPrintNumberByStyle
9D01B2D8  00000000   NOP
561:                 #ifdef UNITY_FLOAT_VERBOSE
562:                             UnityPrint(UnityStrExpected);
563:                             UnityPrintFloat(*ptr_expected);
564:                             UnityPrint(UnityStrWas);
565:                             UnityPrintFloat(*ptr_actual);
566:                 #else
567:                             UnityPrint(UnityStrDelta);
9D01B2DC  8F828050   LW V0, -32688(GP)
9D01B2E0  00402021   ADDU A0, V0, ZERO
9D01B2E4  0F406757   JAL UnityPrint
9D01B2E8  00000000   NOP
568:                 #endif
569:                             UnityAddMsgIfSpecified(msg);
9D01B2EC  8FC40044   LW A0, 68(S8)
9D01B2F0  0F40698A   JAL UnityAddMsgIfSpecified
9D01B2F4  00000000   NOP
570:                             UNITY_FAIL_AND_BAIL;
9D01B2F8  3C02A000   LUI V0, -24576
9D01B2FC  24422F00   ADDIU V0, V0, 12032
9D01B300  24030001   ADDIU V1, ZERO, 1
9D01B304  AC430018   SW V1, 24(V0)
9D01B308  2404000A   ADDIU A0, ZERO, 10
9D01B30C  3C02A000   LUI V0, -24576
9D01B310  24452FF4   ADDIU A1, V0, 12276
9D01B314  0F40D3F2   JAL fputc
9D01B318  00000000   NOP
9D01B31C  3C02A000   LUI V0, -24576
9D01B320  24442F20   ADDIU A0, V0, 12064
9D01B324  24050001   ADDIU A1, ZERO, 1
9D01B328  0F40D4F1   JAL 0x9D0353C4
9D01B32C  00000000   NOP
571:                         }
572:                         ptr_expected++;
9D01B330  8FC20014   LW V0, 20(S8)
9D01B334  24420004   ADDIU V0, V0, 4
9D01B338  AFC20014   SW V0, 20(S8)
573:                         ptr_actual++;
9D01B33C  8FC20018   LW V0, 24(S8)
9D01B340  24420004   ADDIU V0, V0, 4
9D01B344  AFC20018   SW V0, 24(S8)
9D01B348  0B406CD5   J 0x9D01B354
9D01B34C  00000000   NOP
574:                     }
575:                 }
9D01B374  03C0E821   ADDU SP, S8, ZERO
9D01B378  8FBF0034   LW RA, 52(SP)
9D01B37C  8FBE0030   LW S8, 48(SP)
9D01B380  8FB0002C   LW S0, 44(SP)
9D01B384  27BD0038   ADDIU SP, SP, 56
9D01B388  03E00008   JR RA
9D01B38C  00000000   NOP
576:                 
577:                 //-----------------------------------------------
578:                 void UnityAssertFloatsWithin(const _UF delta,
579:                                              const _UF expected,
580:                                              const _UF actual,
581:                                              const char* msg,
582:                                              const UNITY_LINE_TYPE lineNumber)
583:                 {
9D01B390  27BDFFD8   ADDIU SP, SP, -40
9D01B394  AFBF0024   SW RA, 36(SP)
9D01B398  AFBE0020   SW S8, 32(SP)
9D01B39C  AFB0001C   SW S0, 28(SP)
9D01B3A0  03A0F021   ADDU S8, SP, ZERO
9D01B3A4  AFC40028   SW A0, 40(S8)
9D01B3A8  AFC5002C   SW A1, 44(S8)
9D01B3AC  AFC60030   SW A2, 48(S8)
9D01B3B0  AFC70034   SW A3, 52(S8)
584:                     _UF diff = actual - expected;
9D01B3B4  8FC40030   LW A0, 48(S8)
9D01B3B8  8FC5002C   LW A1, 44(S8)
9D01B3BC  0F40B56C   JAL __subsf3
9D01B3C0  00000000   NOP
9D01B3C4  AFC20010   SW V0, 16(S8)
585:                     _UF pos_delta = delta;
9D01B3C8  8FC20028   LW V0, 40(S8)
9D01B3CC  AFC20014   SW V0, 20(S8)
586:                 
587:                     UNITY_SKIP_EXECUTION;
9D01B3D0  3C02A000   LUI V0, -24576
9D01B3D4  24422F00   ADDIU V0, V0, 12032
9D01B3D8  8C420018   LW V0, 24(V0)
9D01B3DC  14400053   BNE V0, ZERO, 0x9D01B52C
9D01B3E0  00000000   NOP
9D01B3E4  3C02A000   LUI V0, -24576
9D01B3E8  24422F00   ADDIU V0, V0, 12032
9D01B3EC  8C42001C   LW V0, 28(V0)
9D01B3F0  1440004E   BNE V0, ZERO, 0x9D01B52C
9D01B3F4  00000000   NOP
588:                 
589:                     if (diff < 0.0f)
9D01B3F8  24100001   ADDIU S0, ZERO, 1
9D01B3FC  8FC40010   LW A0, 16(S8)
9D01B400  00002821   ADDU A1, ZERO, ZERO
9D01B404  0F40B767   JAL __lesf2
9D01B408  00000000   NOP
9D01B40C  04400002   BLTZ V0, 0x9D01B418
9D01B410  00000000   NOP
9D01B414  00008021   ADDU S0, ZERO, ZERO
9D01B418  320200FF   ANDI V0, S0, 255
9D01B41C  10400006   BEQ V0, ZERO, 0x9D01B438
9D01B420  00000000   NOP
590:                     {
591:                         diff = 0.0f - diff;
9D01B424  00002021   ADDU A0, ZERO, ZERO
9D01B428  8FC50010   LW A1, 16(S8)
9D01B42C  0F40B56C   JAL __subsf3
9D01B430  00000000   NOP
9D01B434  AFC20010   SW V0, 16(S8)
592:                     }
593:                     if (pos_delta < 0.0f)
9D01B438  24100001   ADDIU S0, ZERO, 1
9D01B43C  8FC40014   LW A0, 20(S8)
9D01B440  00002821   ADDU A1, ZERO, ZERO
9D01B444  0F40B767   JAL __lesf2
9D01B448  00000000   NOP
9D01B44C  04400002   BLTZ V0, 0x9D01B458
9D01B450  00000000   NOP
9D01B454  00008021   ADDU S0, ZERO, ZERO
9D01B458  320200FF   ANDI V0, S0, 255
9D01B45C  10400006   BEQ V0, ZERO, 0x9D01B478
9D01B460  00000000   NOP
594:                     {
595:                         pos_delta = 0.0f - pos_delta;
9D01B464  00002021   ADDU A0, ZERO, ZERO
9D01B468  8FC50014   LW A1, 20(S8)
9D01B46C  0F40B56C   JAL __subsf3
9D01B470  00000000   NOP
9D01B474  AFC20014   SW V0, 20(S8)
596:                     }
597:                 
598:                     //This first part of this condition will catch any NaN or Infinite values
599:                     if ((diff * 0.0f != 0.0f) || (pos_delta < diff))
9D01B478  8FC40010   LW A0, 16(S8)
9D01B47C  00002821   ADDU A1, ZERO, ZERO
9D01B480  0F40B609   JAL __mulsf3
9D01B484  00000000   NOP
9D01B488  00402021   ADDU A0, V0, ZERO
9D01B48C  00002821   ADDU A1, ZERO, ZERO
9D01B490  0F40B767   JAL __lesf2
9D01B494  00000000   NOP
9D01B498  1440000C   BNE V0, ZERO, 0x9D01B4CC
9D01B49C  00000000   NOP
9D01B4A0  24100001   ADDIU S0, ZERO, 1
9D01B4A4  8FC40014   LW A0, 20(S8)
9D01B4A8  8FC50010   LW A1, 16(S8)
9D01B4AC  0F40B767   JAL __lesf2
9D01B4B0  00000000   NOP
9D01B4B4  04400002   BLTZ V0, 0x9D01B4C0
9D01B4B8  00000000   NOP
9D01B4BC  00008021   ADDU S0, ZERO, ZERO
9D01B4C0  320200FF   ANDI V0, S0, 255
9D01B4C4  10400019   BEQ V0, ZERO, 0x9D01B52C
9D01B4C8  00000000   NOP
600:                     {
601:                         UnityTestResultsFailBegin(lineNumber);
9D01B4CC  8FC40038   LW A0, 56(S8)
9D01B4D0  0F406937   JAL UnityTestResultsFailBegin
9D01B4D4  00000000   NOP
602:                 #ifdef UNITY_FLOAT_VERBOSE
603:                         UnityPrint(UnityStrExpected);
604:                         UnityPrintFloat(expected);
605:                         UnityPrint(UnityStrWas);
606:                         UnityPrintFloat(actual);
607:                 #else
608:                         UnityPrint(UnityStrDelta);
9D01B4D8  8F828050   LW V0, -32688(GP)
9D01B4DC  00402021   ADDU A0, V0, ZERO
9D01B4E0  0F406757   JAL UnityPrint
9D01B4E4  00000000   NOP
609:                 #endif
610:                         UnityAddMsgIfSpecified(msg);
9D01B4E8  8FC40034   LW A0, 52(S8)
9D01B4EC  0F40698A   JAL UnityAddMsgIfSpecified
9D01B4F0  00000000   NOP
611:                         UNITY_FAIL_AND_BAIL;
9D01B4F4  3C02A000   LUI V0, -24576
9D01B4F8  24422F00   ADDIU V0, V0, 12032
9D01B4FC  24030001   ADDIU V1, ZERO, 1
9D01B500  AC430018   SW V1, 24(V0)
9D01B504  2404000A   ADDIU A0, ZERO, 10
9D01B508  3C02A000   LUI V0, -24576
9D01B50C  24452FF4   ADDIU A1, V0, 12276
9D01B510  0F40D3F2   JAL fputc
9D01B514  00000000   NOP
9D01B518  3C02A000   LUI V0, -24576
9D01B51C  24442F20   ADDIU A0, V0, 12064
9D01B520  24050001   ADDIU A1, ZERO, 1
9D01B524  0F40D4F1   JAL 0x9D0353C4
9D01B528  00000000   NOP
612:                     }
613:                 }
9D01B52C  03C0E821   ADDU SP, S8, ZERO
9D01B530  8FBF0024   LW RA, 36(SP)
9D01B534  8FBE0020   LW S8, 32(SP)
9D01B538  8FB0001C   LW S0, 28(SP)
9D01B53C  27BD0028   ADDIU SP, SP, 40
9D01B540  03E00008   JR RA
9D01B544  00000000   NOP
614:                 
615:                 //-----------------------------------------------
616:                 void UnityAssertFloatIsInf(const _UF actual,
617:                                            const char* msg,
618:                                            const UNITY_LINE_TYPE lineNumber)
619:                 {
9D01B548  27BDFFE8   ADDIU SP, SP, -24
9D01B54C  AFBF0014   SW RA, 20(SP)
9D01B550  AFBE0010   SW S8, 16(SP)
9D01B554  03A0F021   ADDU S8, SP, ZERO
9D01B558  AFC40018   SW A0, 24(S8)
9D01B55C  AFC5001C   SW A1, 28(S8)
9D01B560  AFC60020   SW A2, 32(S8)
620:                     UNITY_SKIP_EXECUTION;
9D01B564  3C02A000   LUI V0, -24576
9D01B568  24422F00   ADDIU V0, V0, 12032
9D01B56C  8C420018   LW V0, 24(V0)
9D01B570  1440002B   BNE V0, ZERO, 0x9D01B620
9D01B574  00000000   NOP
9D01B578  3C02A000   LUI V0, -24576
9D01B57C  24422F00   ADDIU V0, V0, 12032
9D01B580  8C42001C   LW V0, 28(V0)
9D01B584  14400026   BNE V0, ZERO, 0x9D01B620
9D01B588  00000000   NOP
621:                 
622:                     // In Microsoft Visual C++ Express Edition 2008,
623:                     //   if ((1.0f / f_zero) != actual)
624:                     // produces
625:                     //   error C2124: divide or mod by zero
626:                     // As a workaround, place 0 into a variable.
627:                     if ((1.0f / f_zero) != actual)
9D01B58C  3C029D03   LUI V0, -25341
9D01B590  8C4249D8   LW V0, 18904(V0)
9D01B594  3C039D03   LUI V1, -25341
9D01B598  8C644A58   LW A0, 19032(V1)
9D01B59C  00402821   ADDU A1, V0, ZERO
9D01B5A0  0F40B677   JAL __divsf3
9D01B5A4  00000000   NOP
9D01B5A8  00402021   ADDU A0, V0, ZERO
9D01B5AC  8FC50018   LW A1, 24(S8)
9D01B5B0  0F40B767   JAL __lesf2
9D01B5B4  00000000   NOP
9D01B5B8  10400019   BEQ V0, ZERO, 0x9D01B620
9D01B5BC  00000000   NOP
628:                     {
629:                         UnityTestResultsFailBegin(lineNumber);
9D01B5C0  8FC40020   LW A0, 32(S8)
9D01B5C4  0F406937   JAL UnityTestResultsFailBegin
9D01B5C8  00000000   NOP
630:                 #ifdef UNITY_FLOAT_VERBOSE
631:                         UnityPrint(UnityStrExpected);
632:                         UnityPrint(UnityStrInf);
633:                         UnityPrint(UnityStrWas);
634:                         UnityPrintFloat(actual);
635:                 #else
636:                         UnityPrint(UnityStrDelta);
9D01B5CC  8F828050   LW V0, -32688(GP)
9D01B5D0  00402021   ADDU A0, V0, ZERO
9D01B5D4  0F406757   JAL UnityPrint
9D01B5D8  00000000   NOP
637:                 #endif
638:                         UnityAddMsgIfSpecified(msg);
9D01B5DC  8FC4001C   LW A0, 28(S8)
9D01B5E0  0F40698A   JAL UnityAddMsgIfSpecified
9D01B5E4  00000000   NOP
639:                         UNITY_FAIL_AND_BAIL;
9D01B5E8  3C02A000   LUI V0, -24576
9D01B5EC  24422F00   ADDIU V0, V0, 12032
9D01B5F0  24030001   ADDIU V1, ZERO, 1
9D01B5F4  AC430018   SW V1, 24(V0)
9D01B5F8  2404000A   ADDIU A0, ZERO, 10
9D01B5FC  3C02A000   LUI V0, -24576
9D01B600  24452FF4   ADDIU A1, V0, 12276
9D01B604  0F40D3F2   JAL fputc
9D01B608  00000000   NOP
9D01B60C  3C02A000   LUI V0, -24576
9D01B610  24442F20   ADDIU A0, V0, 12064
9D01B614  24050001   ADDIU A1, ZERO, 1
9D01B618  0F40D4F1   JAL 0x9D0353C4
9D01B61C  00000000   NOP
640:                     }
641:                 }
9D01B620  03C0E821   ADDU SP, S8, ZERO
9D01B624  8FBF0014   LW RA, 20(SP)
9D01B628  8FBE0010   LW S8, 16(SP)
9D01B62C  27BD0018   ADDIU SP, SP, 24
9D01B630  03E00008   JR RA
9D01B634  00000000   NOP
642:                 
643:                 //-----------------------------------------------
644:                 void UnityAssertFloatIsNegInf(const _UF actual,
645:                                               const char* msg,
646:                                               const UNITY_LINE_TYPE lineNumber)
647:                 {
9D01B638  27BDFFE8   ADDIU SP, SP, -24
9D01B63C  AFBF0014   SW RA, 20(SP)
9D01B640  AFBE0010   SW S8, 16(SP)
9D01B644  03A0F021   ADDU S8, SP, ZERO
9D01B648  AFC40018   SW A0, 24(S8)
9D01B64C  AFC5001C   SW A1, 28(S8)
9D01B650  AFC60020   SW A2, 32(S8)
648:                     UNITY_SKIP_EXECUTION;
9D01B654  3C02A000   LUI V0, -24576
9D01B658  24422F00   ADDIU V0, V0, 12032
9D01B65C  8C420018   LW V0, 24(V0)
9D01B660  1440002B   BNE V0, ZERO, 0x9D01B710
9D01B664  00000000   NOP
9D01B668  3C02A000   LUI V0, -24576
9D01B66C  24422F00   ADDIU V0, V0, 12032
9D01B670  8C42001C   LW V0, 28(V0)
9D01B674  14400026   BNE V0, ZERO, 0x9D01B710
9D01B678  00000000   NOP
649:                 
650:                     // The rationale for not using 1.0f/0.0f is given in UnityAssertFloatIsInf's body.
651:                     if ((-1.0f / f_zero) != actual)
9D01B67C  3C029D03   LUI V0, -25341
9D01B680  8C4249D8   LW V0, 18904(V0)
9D01B684  3C039D03   LUI V1, -25341
9D01B688  8C644A5C   LW A0, 19036(V1)
9D01B68C  00402821   ADDU A1, V0, ZERO
9D01B690  0F40B677   JAL __divsf3
9D01B694  00000000   NOP
9D01B698  00402021   ADDU A0, V0, ZERO
9D01B69C  8FC50018   LW A1, 24(S8)
9D01B6A0  0F40B767   JAL __lesf2
9D01B6A4  00000000   NOP
9D01B6A8  10400019   BEQ V0, ZERO, 0x9D01B710
9D01B6AC  00000000   NOP
652:                     {
653:                         UnityTestResultsFailBegin(lineNumber);
9D01B6B0  8FC40020   LW A0, 32(S8)
9D01B6B4  0F406937   JAL UnityTestResultsFailBegin
9D01B6B8  00000000   NOP
654:                 #ifdef UNITY_FLOAT_VERBOSE
655:                         UnityPrint(UnityStrExpected);
656:                         UnityPrint(UnityStrNegInf);
657:                         UnityPrint(UnityStrWas);
658:                         UnityPrintFloat(actual);
659:                 #else
660:                         UnityPrint(UnityStrDelta);
9D01B6BC  8F828050   LW V0, -32688(GP)
9D01B6C0  00402021   ADDU A0, V0, ZERO
9D01B6C4  0F406757   JAL UnityPrint
9D01B6C8  00000000   NOP
661:                 #endif
662:                         UnityAddMsgIfSpecified(msg);
9D01B6CC  8FC4001C   LW A0, 28(S8)
9D01B6D0  0F40698A   JAL UnityAddMsgIfSpecified
9D01B6D4  00000000   NOP
663:                         UNITY_FAIL_AND_BAIL;
9D01B6D8  3C02A000   LUI V0, -24576
9D01B6DC  24422F00   ADDIU V0, V0, 12032
9D01B6E0  24030001   ADDIU V1, ZERO, 1
9D01B6E4  AC430018   SW V1, 24(V0)
9D01B6E8  2404000A   ADDIU A0, ZERO, 10
9D01B6EC  3C02A000   LUI V0, -24576
9D01B6F0  24452FF4   ADDIU A1, V0, 12276
9D01B6F4  0F40D3F2   JAL fputc
9D01B6F8  00000000   NOP
9D01B6FC  3C02A000   LUI V0, -24576
9D01B700  24442F20   ADDIU A0, V0, 12064
9D01B704  24050001   ADDIU A1, ZERO, 1
9D01B708  0F40D4F1   JAL 0x9D0353C4
9D01B70C  00000000   NOP
664:                     }
665:                 }
9D01B710  03C0E821   ADDU SP, S8, ZERO
9D01B714  8FBF0014   LW RA, 20(SP)
9D01B718  8FBE0010   LW S8, 16(SP)
9D01B71C  27BD0018   ADDIU SP, SP, 24
9D01B720  03E00008   JR RA
9D01B724  00000000   NOP
666:                 
667:                 //-----------------------------------------------
668:                 void UnityAssertFloatIsNaN(const _UF actual,
669:                                            const char* msg,
670:                                            const UNITY_LINE_TYPE lineNumber)
671:                 {
9D01B728  27BDFFE8   ADDIU SP, SP, -24
9D01B72C  AFBF0014   SW RA, 20(SP)
9D01B730  AFBE0010   SW S8, 16(SP)
9D01B734  03A0F021   ADDU S8, SP, ZERO
9D01B738  AFC40018   SW A0, 24(S8)
9D01B73C  AFC5001C   SW A1, 28(S8)
9D01B740  AFC60020   SW A2, 32(S8)
672:                     UNITY_SKIP_EXECUTION;
9D01B744  3C02A000   LUI V0, -24576
9D01B748  24422F00   ADDIU V0, V0, 12032
9D01B74C  8C420018   LW V0, 24(V0)
9D01B750  14400024   BNE V0, ZERO, 0x9D01B7E4
9D01B754  00000000   NOP
9D01B758  3C02A000   LUI V0, -24576
9D01B75C  24422F00   ADDIU V0, V0, 12032
9D01B760  8C42001C   LW V0, 28(V0)
9D01B764  1440001F   BNE V0, ZERO, 0x9D01B7E4
9D01B768  00000000   NOP
673:                 
674:                     if (actual == actual)
9D01B76C  8FC40018   LW A0, 24(S8)
9D01B770  8FC50018   LW A1, 24(S8)
9D01B774  0F40B767   JAL __lesf2
9D01B778  00000000   NOP
9D01B77C  14400019   BNE V0, ZERO, 0x9D01B7E4
9D01B780  00000000   NOP
675:                     {
676:                         UnityTestResultsFailBegin(lineNumber);
9D01B784  8FC40020   LW A0, 32(S8)
9D01B788  0F406937   JAL UnityTestResultsFailBegin
9D01B78C  00000000   NOP
677:                 #ifdef UNITY_FLOAT_VERBOSE
678:                         UnityPrint(UnityStrExpected);
679:                         UnityPrint(UnityStrNaN);
680:                         UnityPrint(UnityStrWas);
681:                         UnityPrintFloat(actual);
682:                 #else
683:                         UnityPrint(UnityStrDelta);
9D01B790  8F828050   LW V0, -32688(GP)
9D01B794  00402021   ADDU A0, V0, ZERO
9D01B798  0F406757   JAL UnityPrint
9D01B79C  00000000   NOP
684:                 #endif
685:                         UnityAddMsgIfSpecified(msg);
9D01B7A0  8FC4001C   LW A0, 28(S8)
9D01B7A4  0F40698A   JAL UnityAddMsgIfSpecified
9D01B7A8  00000000   NOP
686:                         UNITY_FAIL_AND_BAIL;
9D01B7AC  3C02A000   LUI V0, -24576
9D01B7B0  24422F00   ADDIU V0, V0, 12032
9D01B7B4  24030001   ADDIU V1, ZERO, 1
9D01B7B8  AC430018   SW V1, 24(V0)
9D01B7BC  2404000A   ADDIU A0, ZERO, 10
9D01B7C0  3C02A000   LUI V0, -24576
9D01B7C4  24452FF4   ADDIU A1, V0, 12276
9D01B7C8  0F40D3F2   JAL fputc
9D01B7CC  00000000   NOP
9D01B7D0  3C02A000   LUI V0, -24576
9D01B7D4  24442F20   ADDIU A0, V0, 12064
9D01B7D8  24050001   ADDIU A1, ZERO, 1
9D01B7DC  0F40D4F1   JAL 0x9D0353C4
9D01B7E0  00000000   NOP
687:                     }
688:                 }
9D01B7E4  03C0E821   ADDU SP, S8, ZERO
9D01B7E8  8FBF0014   LW RA, 20(SP)
9D01B7EC  8FBE0010   LW S8, 16(SP)
9D01B7F0  27BD0018   ADDIU SP, SP, 24
9D01B7F4  03E00008   JR RA
9D01B7F8  00000000   NOP
689:                 
690:                 #endif //not UNITY_EXCLUDE_FLOAT
691:                 
692:                 //-----------------------------------------------
693:                 #ifndef UNITY_EXCLUDE_DOUBLE
694:                 void UnityAssertEqualDoubleArray(UNITY_PTR_ATTRIBUTE const _UD* expected,
695:                                                  UNITY_PTR_ATTRIBUTE const _UD* actual,
696:                                                  const _UU32 num_elements,
697:                                                  const char* msg,
698:                                                  const UNITY_LINE_TYPE lineNumber)
699:                 {
700:                     _UU32 elements = num_elements;
701:                     UNITY_PTR_ATTRIBUTE const _UD* ptr_expected = expected;
702:                     UNITY_PTR_ATTRIBUTE const _UD* ptr_actual = actual;
703:                     _UD diff, tol;
704:                 
705:                     UNITY_SKIP_EXECUTION;
706:                 
707:                     if (elements == 0)
708:                     {
709:                         UnityTestResultsFailBegin(lineNumber);
710:                         UnityPrint(UnityStrPointless);
711:                         UnityAddMsgIfSpecified(msg);
712:                         UNITY_FAIL_AND_BAIL;
713:                     }
714:                 
715:                     if (UnityCheckArraysForNull((UNITY_PTR_ATTRIBUTE void*)expected, (UNITY_PTR_ATTRIBUTE void*)actual, lineNumber, msg) == 1)
716:                         return;
717:                 
718:                     while (elements--)
719:                     {
720:                         diff = *ptr_expected - *ptr_actual;
721:                         if (diff < 0.0)
722:                           diff = 0.0 - diff;
723:                         tol = UNITY_DOUBLE_PRECISION * *ptr_expected;
724:                         if (tol < 0.0)
725:                             tol = 0.0 - tol;
726:                 
727:                         //This first part of this condition will catch any NaN or Infinite values
728:                         if ((diff * 0.0 != 0.0) || (diff > tol))
729:                         {
730:                             UnityTestResultsFailBegin(lineNumber);
731:                             UnityPrint(UnityStrElement);
732:                             UnityPrintNumberByStyle((num_elements - elements - 1), UNITY_DISPLAY_STYLE_UINT);
733:                 #ifdef UNITY_DOUBLE_VERBOSE
734:                             UnityPrint(UnityStrExpected);
735:                             UnityPrintFloat((float)(*ptr_expected));
736:                             UnityPrint(UnityStrWas);
737:                             UnityPrintFloat((float)(*ptr_actual));
738:                 #else
739:                             UnityPrint(UnityStrDelta);
740:                 #endif
741:                             UnityAddMsgIfSpecified(msg);
742:                             UNITY_FAIL_AND_BAIL;
743:                         }
744:                         ptr_expected++;
745:                         ptr_actual++;
746:                     }
747:                 }
748:                 
749:                 //-----------------------------------------------
750:                 void UnityAssertDoublesWithin(const _UD delta,
751:                                               const _UD expected,
752:                                               const _UD actual,
753:                                               const char* msg,
754:                                               const UNITY_LINE_TYPE lineNumber)
755:                 {
756:                     _UD diff = actual - expected;
757:                     _UD pos_delta = delta;
758:                 
759:                     UNITY_SKIP_EXECUTION;
760:                 
761:                     if (diff < 0.0)
762:                     {
763:                         diff = 0.0 - diff;
764:                     }
765:                     if (pos_delta < 0.0)
766:                     {
767:                         pos_delta = 0.0 - pos_delta;
768:                     }
769:                 
770:                     //This first part of this condition will catch any NaN or Infinite values
771:                     if ((diff * 0.0 != 0.0) || (pos_delta < diff))
772:                     {
773:                         UnityTestResultsFailBegin(lineNumber);
774:                 #ifdef UNITY_DOUBLE_VERBOSE
775:                         UnityPrint(UnityStrExpected);
776:                         UnityPrintFloat((float)expected);
777:                         UnityPrint(UnityStrWas);
778:                         UnityPrintFloat((float)actual);
779:                 #else
780:                         UnityPrint(UnityStrDelta);
781:                 #endif
782:                         UnityAddMsgIfSpecified(msg);
783:                         UNITY_FAIL_AND_BAIL;
784:                     }
785:                 }
786:                 
787:                 //-----------------------------------------------
788:                 void UnityAssertDoubleIsInf(const _UD actual,
789:                                             const char* msg,
790:                                             const UNITY_LINE_TYPE lineNumber)
791:                 {
792:                     UNITY_SKIP_EXECUTION;
793:                 
794:                     // The rationale for not using 1.0/0.0 is given in UnityAssertFloatIsInf's body.
795:                     if ((1.0 / d_zero) != actual)
796:                     {
797:                         UnityTestResultsFailBegin(lineNumber);
798:                 #ifdef UNITY_DOUBLE_VERBOSE
799:                         UnityPrint(UnityStrExpected);
800:                         UnityPrint(UnityStrInf);
801:                         UnityPrint(UnityStrWas);
802:                         UnityPrintFloat((float)actual);
803:                 #else
804:                         UnityPrint(UnityStrDelta);
805:                 #endif
806:                         UnityAddMsgIfSpecified(msg);
807:                         UNITY_FAIL_AND_BAIL;
808:                     }
809:                 }
810:                 
811:                 //-----------------------------------------------
812:                 void UnityAssertDoubleIsNegInf(const _UD actual,
813:                                                const char* msg,
814:                                                const UNITY_LINE_TYPE lineNumber)
815:                 {
816:                     UNITY_SKIP_EXECUTION;
817:                 
818:                     // The rationale for not using 1.0/0.0 is given in UnityAssertFloatIsInf's body.
819:                     if ((-1.0 / d_zero) != actual)
820:                     {
821:                         UnityTestResultsFailBegin(lineNumber);
822:                 #ifdef UNITY_DOUBLE_VERBOSE
823:                         UnityPrint(UnityStrExpected);
824:                         UnityPrint(UnityStrNegInf);
825:                         UnityPrint(UnityStrWas);
826:                         UnityPrintFloat((float)actual);
827:                 #else
828:                         UnityPrint(UnityStrDelta);
829:                 #endif
830:                         UnityAddMsgIfSpecified(msg);
831:                         UNITY_FAIL_AND_BAIL;
832:                     }
833:                 }
834:                 
835:                 //-----------------------------------------------
836:                 void UnityAssertDoubleIsNaN(const _UD actual,
837:                                             const char* msg,
838:                                             const UNITY_LINE_TYPE lineNumber)
839:                 {
840:                     UNITY_SKIP_EXECUTION;
841:                 
842:                     if (actual == actual)
843:                     {
844:                         UnityTestResultsFailBegin(lineNumber);
845:                 #ifdef UNITY_DOUBLE_VERBOSE
846:                         UnityPrint(UnityStrExpected);
847:                         UnityPrint(UnityStrNaN);
848:                         UnityPrint(UnityStrWas);
849:                         UnityPrintFloat((float)actual);
850:                 #else
851:                         UnityPrint(UnityStrDelta);
852:                 #endif
853:                         UnityAddMsgIfSpecified(msg);
854:                         UNITY_FAIL_AND_BAIL;
855:                     }
856:                 }
857:                 
858:                 #endif // not UNITY_EXCLUDE_DOUBLE
859:                 
860:                 //-----------------------------------------------
861:                 void UnityAssertNumbersWithin( const _U_SINT delta,
862:                                                const _U_SINT expected,
863:                                                const _U_SINT actual,
864:                                                const char* msg,
865:                                                const UNITY_LINE_TYPE lineNumber,
866:                                                const UNITY_DISPLAY_STYLE_T style)
867:                 {
9D01B7FC  27BDFFE8   ADDIU SP, SP, -24
9D01B800  AFBF0014   SW RA, 20(SP)
9D01B804  AFBE0010   SW S8, 16(SP)
9D01B808  03A0F021   ADDU S8, SP, ZERO
9D01B80C  AFC40018   SW A0, 24(S8)
9D01B810  AFC5001C   SW A1, 28(S8)
9D01B814  AFC60020   SW A2, 32(S8)
9D01B818  AFC70024   SW A3, 36(S8)
868:                     UNITY_SKIP_EXECUTION;
9D01B81C  3C02A000   LUI V0, -24576
9D01B820  24422F00   ADDIU V0, V0, 12032
9D01B824  8C420018   LW V0, 24(V0)
9D01B828  1440006D   BNE V0, ZERO, 0x9D01B9E0
9D01B82C  00000000   NOP
9D01B830  3C02A000   LUI V0, -24576
9D01B834  24422F00   ADDIU V0, V0, 12032
9D01B838  8C42001C   LW V0, 28(V0)
9D01B83C  14400068   BNE V0, ZERO, 0x9D01B9E0
9D01B840  00000000   NOP
869:                 
870:                     if ((style & UNITY_DISPLAY_RANGE_INT) == UNITY_DISPLAY_RANGE_INT)
9D01B844  8FC2002C   LW V0, 44(S8)
9D01B848  30420010   ANDI V0, V0, 16
9D01B84C  1040001A   BEQ V0, ZERO, 0x9D01B8B8
9D01B850  00000000   NOP
871:                     {
872:                         if (actual > expected)
9D01B854  8FC30020   LW V1, 32(S8)
9D01B858  8FC2001C   LW V0, 28(S8)
9D01B85C  0043102A   SLT V0, V0, V1
9D01B860  1040000B   BEQ V0, ZERO, 0x9D01B890
9D01B864  00000000   NOP
873:                           Unity.CurrentTestFailed = ((actual - expected) > delta);
9D01B868  8FC30020   LW V1, 32(S8)
9D01B86C  8FC2001C   LW V0, 28(S8)
9D01B870  00621823   SUBU V1, V1, V0
9D01B874  8FC20018   LW V0, 24(S8)
9D01B878  0043182A   SLT V1, V0, V1
9D01B87C  3C02A000   LUI V0, -24576
9D01B880  24422F00   ADDIU V0, V0, 12032
9D01B884  AC430018   SW V1, 24(V0)
9D01B888  0B406E47   J 0x9D01B91C
9D01B88C  00000000   NOP
874:                         else
875:                           Unity.CurrentTestFailed = ((expected - actual) > delta);
9D01B890  8FC3001C   LW V1, 28(S8)
9D01B894  8FC20020   LW V0, 32(S8)
9D01B898  00621823   SUBU V1, V1, V0
9D01B89C  8FC20018   LW V0, 24(S8)
9D01B8A0  0043182A   SLT V1, V0, V1
9D01B8A4  3C02A000   LUI V0, -24576
9D01B8A8  24422F00   ADDIU V0, V0, 12032
9D01B8AC  AC430018   SW V1, 24(V0)
9D01B8B0  0B406E47   J 0x9D01B91C
9D01B8B4  00000000   NOP
876:                     }
877:                     else
878:                     {
879:                         if ((_U_UINT)actual > (_U_UINT)expected)
9D01B8B8  8FC30020   LW V1, 32(S8)
9D01B8BC  8FC2001C   LW V0, 28(S8)
9D01B8C0  0043102B   SLTU V0, V0, V1
9D01B8C4  1040000C   BEQ V0, ZERO, 0x9D01B8F8
9D01B8C8  00000000   NOP
880:                             Unity.CurrentTestFailed = ((_U_UINT)(actual - expected) > (_U_UINT)delta);
9D01B8CC  8FC30020   LW V1, 32(S8)
9D01B8D0  8FC2001C   LW V0, 28(S8)
9D01B8D4  00621023   SUBU V0, V1, V0
9D01B8D8  00401821   ADDU V1, V0, ZERO
9D01B8DC  8FC20018   LW V0, 24(S8)
9D01B8E0  0043182B   SLTU V1, V0, V1
9D01B8E4  3C02A000   LUI V0, -24576
9D01B8E8  24422F00   ADDIU V0, V0, 12032
9D01B8EC  AC430018   SW V1, 24(V0)
9D01B8F0  0B406E47   J 0x9D01B91C
9D01B8F4  00000000   NOP
881:                         else
882:                             Unity.CurrentTestFailed = ((_U_UINT)(expected - actual) > (_U_UINT)delta);
9D01B8F8  8FC3001C   LW V1, 28(S8)
9D01B8FC  8FC20020   LW V0, 32(S8)
9D01B900  00621023   SUBU V0, V1, V0
9D01B904  00401821   ADDU V1, V0, ZERO
9D01B908  8FC20018   LW V0, 24(S8)
9D01B90C  0043182B   SLTU V1, V0, V1
9D01B910  3C02A000   LUI V0, -24576
9D01B914  24422F00   ADDIU V0, V0, 12032
9D01B918  AC430018   SW V1, 24(V0)
883:                     }
884:                 
885:                     if (Unity.CurrentTestFailed)
9D01B91C  3C02A000   LUI V0, -24576
9D01B920  24422F00   ADDIU V0, V0, 12032
9D01B924  8C420018   LW V0, 24(V0)
9D01B928  1040002D   BEQ V0, ZERO, 0x9D01B9E0
9D01B92C  00000000   NOP
886:                     {
887:                         UnityTestResultsFailBegin(lineNumber);
9D01B930  8FC40028   LW A0, 40(S8)
9D01B934  0F406937   JAL UnityTestResultsFailBegin
9D01B938  00000000   NOP
888:                         UnityPrint(UnityStrDelta);
9D01B93C  8F828050   LW V0, -32688(GP)
9D01B940  00402021   ADDU A0, V0, ZERO
9D01B944  0F406757   JAL UnityPrint
9D01B948  00000000   NOP
889:                         UnityPrintNumberByStyle(delta, style);
9D01B94C  8FC40018   LW A0, 24(S8)
9D01B950  8FC5002C   LW A1, 44(S8)
9D01B954  0F4067B0   JAL UnityPrintNumberByStyle
9D01B958  00000000   NOP
890:                         UnityPrint(UnityStrExpected);
9D01B95C  8F828038   LW V0, -32712(GP)
9D01B960  00402021   ADDU A0, V0, ZERO
9D01B964  0F406757   JAL UnityPrint
9D01B968  00000000   NOP
891:                         UnityPrintNumberByStyle(expected, style);
9D01B96C  8FC4001C   LW A0, 28(S8)
9D01B970  8FC5002C   LW A1, 44(S8)
9D01B974  0F4067B0   JAL UnityPrintNumberByStyle
9D01B978  00000000   NOP
892:                         UnityPrint(UnityStrWas);
9D01B97C  8F82803C   LW V0, -32708(GP)
9D01B980  00402021   ADDU A0, V0, ZERO
9D01B984  0F406757   JAL UnityPrint
9D01B988  00000000   NOP
893:                         UnityPrintNumberByStyle(actual, style);
9D01B98C  8FC40020   LW A0, 32(S8)
9D01B990  8FC5002C   LW A1, 44(S8)
9D01B994  0F4067B0   JAL UnityPrintNumberByStyle
9D01B998  00000000   NOP
894:                         UnityAddMsgIfSpecified(msg);
9D01B99C  8FC40024   LW A0, 36(S8)
9D01B9A0  0F40698A   JAL UnityAddMsgIfSpecified
9D01B9A4  00000000   NOP
895:                         UNITY_FAIL_AND_BAIL;
9D01B9A8  3C02A000   LUI V0, -24576
9D01B9AC  24422F00   ADDIU V0, V0, 12032
9D01B9B0  24030001   ADDIU V1, ZERO, 1
9D01B9B4  AC430018   SW V1, 24(V0)
9D01B9B8  2404000A   ADDIU A0, ZERO, 10
9D01B9BC  3C02A000   LUI V0, -24576
9D01B9C0  24452FF4   ADDIU A1, V0, 12276
9D01B9C4  0F40D3F2   JAL fputc
9D01B9C8  00000000   NOP
9D01B9CC  3C02A000   LUI V0, -24576
9D01B9D0  24442F20   ADDIU A0, V0, 12064
9D01B9D4  24050001   ADDIU A1, ZERO, 1
9D01B9D8  0F40D4F1   JAL 0x9D0353C4
9D01B9DC  00000000   NOP
896:                     }
897:                 }
9D01B9E0  03C0E821   ADDU SP, S8, ZERO
9D01B9E4  8FBF0014   LW RA, 20(SP)
9D01B9E8  8FBE0010   LW S8, 16(SP)
9D01B9EC  27BD0018   ADDIU SP, SP, 24
9D01B9F0  03E00008   JR RA
9D01B9F4  00000000   NOP
898:                 
899:                 //-----------------------------------------------
900:                 void UnityAssertEqualString(const char* expected,
901:                                             const char* actual,
902:                                             const char* msg,
903:                                             const UNITY_LINE_TYPE lineNumber)
904:                 {
9D01B9F8  27BDFFE0   ADDIU SP, SP, -32
9D01B9FC  AFBF001C   SW RA, 28(SP)
9D01BA00  AFBE0018   SW S8, 24(SP)
9D01BA04  03A0F021   ADDU S8, SP, ZERO
9D01BA08  AFC40020   SW A0, 32(S8)
9D01BA0C  AFC50024   SW A1, 36(S8)
9D01BA10  AFC60028   SW A2, 40(S8)
9D01BA14  AFC7002C   SW A3, 44(S8)
905:                     _UU32 i;
906:                 
907:                     UNITY_SKIP_EXECUTION;
9D01BA18  3C02A000   LUI V0, -24576
9D01BA1C  24422F00   ADDIU V0, V0, 12032
9D01BA20  8C420018   LW V0, 24(V0)
9D01BA24  14400056   BNE V0, ZERO, 0x9D01BB80
9D01BA28  00000000   NOP
9D01BA2C  3C02A000   LUI V0, -24576
9D01BA30  24422F00   ADDIU V0, V0, 12032
9D01BA34  8C42001C   LW V0, 28(V0)
9D01BA38  14400051   BNE V0, ZERO, 0x9D01BB80
9D01BA3C  00000000   NOP
908:                 
909:                     // if both pointers not null compare the strings
910:                     if (expected && actual)
9D01BA40  8FC20020   LW V0, 32(S8)
9D01BA44  10400029   BEQ V0, ZERO, 0x9D01BAEC
9D01BA48  00000000   NOP
9D01BA4C  8FC20024   LW V0, 36(S8)
9D01BA50  10400026   BEQ V0, ZERO, 0x9D01BAEC
9D01BA54  00000000   NOP
9D01BAA0  0B406EC3   J 0x9D01BB0C
9D01BAA4  00000000   NOP
9D01BAE4  0B406EC3   J 0x9D01BB0C
9D01BAE8  00000000   NOP
911:                     {
912:                         for (i = 0; expected[i] || actual[i]; i++)
9D01BA58  AFC00010   SW ZERO, 16(S8)
9D01BA5C  0B406EAD   J 0x9D01BAB4
9D01BA60  00000000   NOP
9D01BAA8  8FC20010   LW V0, 16(S8)
9D01BAAC  24420001   ADDIU V0, V0, 1
9D01BAB0  AFC20010   SW V0, 16(S8)
9D01BAB4  8FC30020   LW V1, 32(S8)
9D01BAB8  8FC20010   LW V0, 16(S8)
9D01BABC  00621021   ADDU V0, V1, V0
9D01BAC0  80420000   LB V0, 0(V0)
9D01BAC4  1440FFE7   BNE V0, ZERO, 0x9D01BA64
9D01BAC8  00000000   NOP
9D01BACC  8FC30024   LW V1, 36(S8)
9D01BAD0  8FC20010   LW V0, 16(S8)
9D01BAD4  00621021   ADDU V0, V1, V0
9D01BAD8  80420000   LB V0, 0(V0)
9D01BADC  1440FFE1   BNE V0, ZERO, 0x9D01BA64
9D01BAE0  00000000   NOP
913:                         {
914:                             if (expected[i] != actual[i])
9D01BA64  8FC30020   LW V1, 32(S8)
9D01BA68  8FC20010   LW V0, 16(S8)
9D01BA6C  00621021   ADDU V0, V1, V0
9D01BA70  80430000   LB V1, 0(V0)
9D01BA74  8FC40024   LW A0, 36(S8)
9D01BA78  8FC20010   LW V0, 16(S8)
9D01BA7C  00821021   ADDU V0, A0, V0
9D01BA80  80420000   LB V0, 0(V0)
9D01BA84  10620008   BEQ V1, V0, 0x9D01BAA8
9D01BA88  00000000   NOP
915:                             {
916:                                 Unity.CurrentTestFailed = 1;
9D01BA8C  3C02A000   LUI V0, -24576
9D01BA90  24422F00   ADDIU V0, V0, 12032
9D01BA94  24030001   ADDIU V1, ZERO, 1
9D01BA98  AC430018   SW V1, 24(V0)
917:                                 break;
9D01BA9C  00000000   NOP
918:                             }
919:                         }
920:                     }
921:                     else
922:                     { // handle case of one pointers being null (if both null, test should pass)
923:                         if (expected != actual)
9D01BAEC  8FC30020   LW V1, 32(S8)
9D01BAF0  8FC20024   LW V0, 36(S8)
9D01BAF4  10620005   BEQ V1, V0, 0x9D01BB0C
9D01BAF8  00000000   NOP
924:                         {
925:                             Unity.CurrentTestFailed = 1;
9D01BAFC  3C02A000   LUI V0, -24576
9D01BB00  24422F00   ADDIU V0, V0, 12032
9D01BB04  24030001   ADDIU V1, ZERO, 1
9D01BB08  AC430018   SW V1, 24(V0)
926:                         }
927:                     }
928:                 
929:                     if (Unity.CurrentTestFailed)
9D01BB0C  3C02A000   LUI V0, -24576
9D01BB10  24422F00   ADDIU V0, V0, 12032
9D01BB14  8C420018   LW V0, 24(V0)
9D01BB18  10400019   BEQ V0, ZERO, 0x9D01BB80
9D01BB1C  00000000   NOP
930:                     {
931:                       UnityTestResultsFailBegin(lineNumber);
9D01BB20  8FC4002C   LW A0, 44(S8)
9D01BB24  0F406937   JAL UnityTestResultsFailBegin
9D01BB28  00000000   NOP
932:                       UnityPrintExpectedAndActualStrings(expected, actual);
9D01BB2C  8FC40020   LW A0, 32(S8)
9D01BB30  8FC50024   LW A1, 36(S8)
9D01BB34  0F40699F   JAL UnityPrintExpectedAndActualStrings
9D01BB38  00000000   NOP
933:                       UnityAddMsgIfSpecified(msg);
9D01BB3C  8FC40028   LW A0, 40(S8)
9D01BB40  0F40698A   JAL UnityAddMsgIfSpecified
9D01BB44  00000000   NOP
934:                       UNITY_FAIL_AND_BAIL;
9D01BB48  3C02A000   LUI V0, -24576
9D01BB4C  24422F00   ADDIU V0, V0, 12032
9D01BB50  24030001   ADDIU V1, ZERO, 1
9D01BB54  AC430018   SW V1, 24(V0)
9D01BB58  2404000A   ADDIU A0, ZERO, 10
9D01BB5C  3C02A000   LUI V0, -24576
9D01BB60  24452FF4   ADDIU A1, V0, 12276
9D01BB64  0F40D3F2   JAL fputc
9D01BB68  00000000   NOP
9D01BB6C  3C02A000   LUI V0, -24576
9D01BB70  24442F20   ADDIU A0, V0, 12064
9D01BB74  24050001   ADDIU A1, ZERO, 1
9D01BB78  0F40D4F1   JAL 0x9D0353C4
9D01BB7C  00000000   NOP
935:                     }
936:                 }
9D01BB80  03C0E821   ADDU SP, S8, ZERO
9D01BB84  8FBF001C   LW RA, 28(SP)
9D01BB88  8FBE0018   LW S8, 24(SP)
9D01BB8C  27BD0020   ADDIU SP, SP, 32
9D01BB90  03E00008   JR RA
9D01BB94  00000000   NOP
937:                 
938:                 //-----------------------------------------------
939:                 void UnityAssertEqualStringArray( const char** expected,
940:                                                   const char** actual,
941:                                                   const _UU32 num_elements,
942:                                                   const char* msg,
943:                                                   const UNITY_LINE_TYPE lineNumber)
944:                 {
9D01BB98  27BDFFE0   ADDIU SP, SP, -32
9D01BB9C  AFBF001C   SW RA, 28(SP)
9D01BBA0  AFBE0018   SW S8, 24(SP)
9D01BBA4  03A0F021   ADDU S8, SP, ZERO
9D01BBA8  AFC40020   SW A0, 32(S8)
9D01BBAC  AFC50024   SW A1, 36(S8)
9D01BBB0  AFC60028   SW A2, 40(S8)
9D01BBB4  AFC7002C   SW A3, 44(S8)
945:                     _UU32 i, j = 0;
9D01BBB8  AFC00014   SW ZERO, 20(S8)
946:                 
947:                     UNITY_SKIP_EXECUTION;
9D01BBBC  3C02A000   LUI V0, -24576
9D01BBC0  24422F00   ADDIU V0, V0, 12032
9D01BBC4  8C420018   LW V0, 24(V0)
9D01BBC8  144000BD   BNE V0, ZERO, 0x9D01BEC0
9D01BBCC  00000000   NOP
9D01BBD0  3C02A000   LUI V0, -24576
9D01BBD4  24422F00   ADDIU V0, V0, 12032
9D01BBD8  8C42001C   LW V0, 28(V0)
9D01BBDC  144000B8   BNE V0, ZERO, 0x9D01BEC0
9D01BBE0  00000000   NOP
948:                 
949:                     // if no elements, it's an error
950:                     if (num_elements == 0)
9D01BBE4  8FC20028   LW V0, 40(S8)
9D01BBE8  14400019   BNE V0, ZERO, 0x9D01BC50
9D01BBEC  00000000   NOP
951:                     {
952:                         UnityTestResultsFailBegin(lineNumber);
9D01BBF0  8FC40030   LW A0, 48(S8)
9D01BBF4  0F406937   JAL UnityTestResultsFailBegin
9D01BBF8  00000000   NOP
953:                         UnityPrint(UnityStrPointless);
9D01BBFC  8F828054   LW V0, -32684(GP)
9D01BC00  00402021   ADDU A0, V0, ZERO
9D01BC04  0F406757   JAL UnityPrint
9D01BC08  00000000   NOP
954:                         UnityAddMsgIfSpecified(msg);
9D01BC0C  8FC4002C   LW A0, 44(S8)
9D01BC10  0F40698A   JAL UnityAddMsgIfSpecified
9D01BC14  00000000   NOP
955:                         UNITY_FAIL_AND_BAIL;
9D01BC18  3C02A000   LUI V0, -24576
9D01BC1C  24422F00   ADDIU V0, V0, 12032
9D01BC20  24030001   ADDIU V1, ZERO, 1
9D01BC24  AC430018   SW V1, 24(V0)
9D01BC28  2404000A   ADDIU A0, ZERO, 10
9D01BC2C  3C02A000   LUI V0, -24576
9D01BC30  24452FF4   ADDIU A1, V0, 12276
9D01BC34  0F40D3F2   JAL fputc
9D01BC38  00000000   NOP
9D01BC3C  3C02A000   LUI V0, -24576
9D01BC40  24442F20   ADDIU A0, V0, 12064
9D01BC44  24050001   ADDIU A1, ZERO, 1
9D01BC48  0F40D4F1   JAL 0x9D0353C4
9D01BC4C  00000000   NOP
956:                     }
957:                 
958:                     if (UnityCheckArraysForNull((UNITY_PTR_ATTRIBUTE void*)expected, (UNITY_PTR_ATTRIBUTE void*)actual, lineNumber, msg) == 1)
9D01BC50  8FC40020   LW A0, 32(S8)
9D01BC54  8FC50024   LW A1, 36(S8)
9D01BC58  8FC60030   LW A2, 48(S8)
9D01BC5C  8FC7002C   LW A3, 44(S8)
9D01BC60  0F4069DF   JAL UnityCheckArraysForNull
9D01BC64  00000000   NOP
9D01BC68  00401821   ADDU V1, V0, ZERO
9D01BC6C  24020001   ADDIU V0, ZERO, 1
9D01BC70  10620092   BEQ V1, V0, 0x9D01BEBC
9D01BC74  00000000   NOP
959:                         return;
9D01BEBC  00000000   NOP
960:                 
961:                     do
962:                     {
963:                         // if both pointers not null compare the strings
964:                         if (expected[j] && actual[j])
9D01BC78  8FC20014   LW V0, 20(S8)
9D01BC7C  00021080   SLL V0, V0, 2
9D01BC80  8FC30020   LW V1, 32(S8)
9D01BC84  00621021   ADDU V0, V1, V0
9D01BC88  8C420000   LW V0, 0(V0)
9D01BC8C  1040003D   BEQ V0, ZERO, 0x9D01BD84
9D01BC90  00000000   NOP
9D01BC94  8FC20014   LW V0, 20(S8)
9D01BC98  00021080   SLL V0, V0, 2
9D01BC9C  8FC30024   LW V1, 36(S8)
9D01BCA0  00621021   ADDU V0, V1, V0
9D01BCA4  8C420000   LW V0, 0(V0)
9D01BCA8  10400036   BEQ V0, ZERO, 0x9D01BD84
9D01BCAC  00000000   NOP
9D01BD18  0B406F71   J 0x9D01BDC4
9D01BD1C  00000000   NOP
9D01BD7C  0B406F71   J 0x9D01BDC4
9D01BD80  00000000   NOP
965:                         {
966:                             for (i = 0; expected[j][i] || actual[j][i]; i++)
9D01BCB0  AFC00010   SW ZERO, 16(S8)
9D01BCB4  0B406F4B   J 0x9D01BD2C
9D01BCB8  00000000   NOP
9D01BD20  8FC20010   LW V0, 16(S8)
9D01BD24  24420001   ADDIU V0, V0, 1
9D01BD28  AFC20010   SW V0, 16(S8)
9D01BD2C  8FC20014   LW V0, 20(S8)
9D01BD30  00021080   SLL V0, V0, 2
9D01BD34  8FC30020   LW V1, 32(S8)
9D01BD38  00621021   ADDU V0, V1, V0
9D01BD3C  8C430000   LW V1, 0(V0)
9D01BD40  8FC20010   LW V0, 16(S8)
9D01BD44  00621021   ADDU V0, V1, V0
9D01BD48  80420000   LB V0, 0(V0)
9D01BD4C  1440FFDB   BNE V0, ZERO, 0x9D01BCBC
9D01BD50  00000000   NOP
9D01BD54  8FC20014   LW V0, 20(S8)
9D01BD58  00021080   SLL V0, V0, 2
9D01BD5C  8FC30024   LW V1, 36(S8)
9D01BD60  00621021   ADDU V0, V1, V0
9D01BD64  8C430000   LW V1, 0(V0)
9D01BD68  8FC20010   LW V0, 16(S8)
9D01BD6C  00621021   ADDU V0, V1, V0
9D01BD70  80420000   LB V0, 0(V0)
9D01BD74  1440FFD1   BNE V0, ZERO, 0x9D01BCBC
9D01BD78  00000000   NOP
967:                             {
968:                                 if (expected[j][i] != actual[j][i])
9D01BCBC  8FC20014   LW V0, 20(S8)
9D01BCC0  00021080   SLL V0, V0, 2
9D01BCC4  8FC30020   LW V1, 32(S8)
9D01BCC8  00621021   ADDU V0, V1, V0
9D01BCCC  8C430000   LW V1, 0(V0)
9D01BCD0  8FC20010   LW V0, 16(S8)
9D01BCD4  00621021   ADDU V0, V1, V0
9D01BCD8  80430000   LB V1, 0(V0)
9D01BCDC  8FC20014   LW V0, 20(S8)
9D01BCE0  00021080   SLL V0, V0, 2
9D01BCE4  8FC40024   LW A0, 36(S8)
9D01BCE8  00821021   ADDU V0, A0, V0
9D01BCEC  8C440000   LW A0, 0(V0)
9D01BCF0  8FC20010   LW V0, 16(S8)
9D01BCF4  00821021   ADDU V0, A0, V0
9D01BCF8  80420000   LB V0, 0(V0)
9D01BCFC  10620008   BEQ V1, V0, 0x9D01BD20
9D01BD00  00000000   NOP
969:                                 {
970:                                     Unity.CurrentTestFailed = 1;
9D01BD04  3C02A000   LUI V0, -24576
9D01BD08  24422F00   ADDIU V0, V0, 12032
9D01BD0C  24030001   ADDIU V1, ZERO, 1
9D01BD10  AC430018   SW V1, 24(V0)
971:                                     break;
9D01BD14  00000000   NOP
972:                                 }
973:                             }
974:                         }
975:                         else
976:                         { // handle case of one pointers being null (if both null, test should pass)
977:                             if (expected[j] != actual[j])
9D01BD84  8FC20014   LW V0, 20(S8)
9D01BD88  00021080   SLL V0, V0, 2
9D01BD8C  8FC30020   LW V1, 32(S8)
9D01BD90  00621021   ADDU V0, V1, V0
9D01BD94  8C430000   LW V1, 0(V0)
9D01BD98  8FC20014   LW V0, 20(S8)
9D01BD9C  00021080   SLL V0, V0, 2
9D01BDA0  8FC40024   LW A0, 36(S8)
9D01BDA4  00821021   ADDU V0, A0, V0
9D01BDA8  8C420000   LW V0, 0(V0)
9D01BDAC  10620005   BEQ V1, V0, 0x9D01BDC4
9D01BDB0  00000000   NOP
978:                             {
979:                                 Unity.CurrentTestFailed = 1;
9D01BDB4  3C02A000   LUI V0, -24576
9D01BDB8  24422F00   ADDIU V0, V0, 12032
9D01BDBC  24030001   ADDIU V1, ZERO, 1
9D01BDC0  AC430018   SW V1, 24(V0)
980:                             }
981:                         }
982:                 
983:                         if (Unity.CurrentTestFailed)
9D01BDC4  3C02A000   LUI V0, -24576
9D01BDC8  24422F00   ADDIU V0, V0, 12032
9D01BDCC  8C420018   LW V0, 24(V0)
9D01BDD0  10400030   BEQ V0, ZERO, 0x9D01BE94
9D01BDD4  00000000   NOP
984:                         {
985:                             UnityTestResultsFailBegin(lineNumber);
9D01BDD8  8FC40030   LW A0, 48(S8)
9D01BDDC  0F406937   JAL UnityTestResultsFailBegin
9D01BDE0  00000000   NOP
986:                             if (num_elements > 1)
9D01BDE4  8FC20028   LW V0, 40(S8)
9D01BDE8  2C420002   SLTIU V0, V0, 2
9D01BDEC  1440000A   BNE V0, ZERO, 0x9D01BE18
9D01BDF0  00000000   NOP
987:                             {
988:                                 UnityPrint(UnityStrElement);
9D01BDF4  8F828044   LW V0, -32700(GP)
9D01BDF8  00402021   ADDU A0, V0, ZERO
9D01BDFC  0F406757   JAL UnityPrint
9D01BE00  00000000   NOP
989:                                 UnityPrintNumberByStyle((j), UNITY_DISPLAY_STYLE_UINT);
9D01BE04  8FC20014   LW V0, 20(S8)
9D01BE08  00402021   ADDU A0, V0, ZERO
9D01BE0C  240500A4   ADDIU A1, ZERO, 164
9D01BE10  0F4067B0   JAL UnityPrintNumberByStyle
9D01BE14  00000000   NOP
990:                             }
991:                             UnityPrintExpectedAndActualStrings((const char*)(expected[j]), (const char*)(actual[j]));
9D01BE18  8FC20014   LW V0, 20(S8)
9D01BE1C  00021080   SLL V0, V0, 2
9D01BE20  8FC30020   LW V1, 32(S8)
9D01BE24  00621021   ADDU V0, V1, V0
9D01BE28  8C430000   LW V1, 0(V0)
9D01BE2C  8FC20014   LW V0, 20(S8)
9D01BE30  00021080   SLL V0, V0, 2
9D01BE34  8FC40024   LW A0, 36(S8)
9D01BE38  00821021   ADDU V0, A0, V0
9D01BE3C  8C420000   LW V0, 0(V0)
9D01BE40  00602021   ADDU A0, V1, ZERO
9D01BE44  00402821   ADDU A1, V0, ZERO
9D01BE48  0F40699F   JAL UnityPrintExpectedAndActualStrings
9D01BE4C  00000000   NOP
992:                             UnityAddMsgIfSpecified(msg);
9D01BE50  8FC4002C   LW A0, 44(S8)
9D01BE54  0F40698A   JAL UnityAddMsgIfSpecified
9D01BE58  00000000   NOP
993:                             UNITY_FAIL_AND_BAIL;
9D01BE5C  3C02A000   LUI V0, -24576
9D01BE60  24422F00   ADDIU V0, V0, 12032
9D01BE64  24030001   ADDIU V1, ZERO, 1
9D01BE68  AC430018   SW V1, 24(V0)
9D01BE6C  2404000A   ADDIU A0, ZERO, 10
9D01BE70  3C02A000   LUI V0, -24576
9D01BE74  24452FF4   ADDIU A1, V0, 12276
9D01BE78  0F40D3F2   JAL fputc
9D01BE7C  00000000   NOP
9D01BE80  3C02A000   LUI V0, -24576
9D01BE84  24442F20   ADDIU A0, V0, 12064
9D01BE88  24050001   ADDIU A1, ZERO, 1
9D01BE8C  0F40D4F1   JAL 0x9D0353C4
9D01BE90  00000000   NOP
994:                         }
995:                     } while (++j < num_elements);
9D01BE94  8FC20014   LW V0, 20(S8)
9D01BE98  24420001   ADDIU V0, V0, 1
9D01BE9C  AFC20014   SW V0, 20(S8)
9D01BEA0  8FC30014   LW V1, 20(S8)
9D01BEA4  8FC20028   LW V0, 40(S8)
9D01BEA8  0062102B   SLTU V0, V1, V0
9D01BEAC  1440FF72   BNE V0, ZERO, 0x9D01BC78
9D01BEB0  00000000   NOP
9D01BEB4  0B406FB0   J 0x9D01BEC0
9D01BEB8  00000000   NOP
996:                 }
9D01BEC0  03C0E821   ADDU SP, S8, ZERO
9D01BEC4  8FBF001C   LW RA, 28(SP)
9D01BEC8  8FBE0018   LW S8, 24(SP)
9D01BECC  27BD0020   ADDIU SP, SP, 32
9D01BED0  03E00008   JR RA
9D01BED4  00000000   NOP
997:                 
998:                 //-----------------------------------------------
999:                 void UnityAssertEqualMemory( UNITY_PTR_ATTRIBUTE const void* expected,
1000:                                             UNITY_PTR_ATTRIBUTE const void* actual,
1001:                                             const _UU32 length,
1002:                                             const _UU32 num_elements,
1003:                                             const char* msg,
1004:                                             const UNITY_LINE_TYPE lineNumber)
1005:                {
9D01BED8  27BDFFD8   ADDIU SP, SP, -40
9D01BEDC  AFBF0024   SW RA, 36(SP)
9D01BEE0  AFBE0020   SW S8, 32(SP)
9D01BEE4  03A0F021   ADDU S8, SP, ZERO
9D01BEE8  AFC40028   SW A0, 40(S8)
9D01BEEC  AFC5002C   SW A1, 44(S8)
9D01BEF0  AFC60030   SW A2, 48(S8)
9D01BEF4  AFC70034   SW A3, 52(S8)
1006:                    UNITY_PTR_ATTRIBUTE unsigned char* ptr_exp = (UNITY_PTR_ATTRIBUTE unsigned char*)expected;
9D01BEF8  8FC20028   LW V0, 40(S8)
9D01BEFC  AFC20010   SW V0, 16(S8)
1007:                    UNITY_PTR_ATTRIBUTE unsigned char* ptr_act = (UNITY_PTR_ATTRIBUTE unsigned char*)actual;
9D01BF00  8FC2002C   LW V0, 44(S8)
9D01BF04  AFC20014   SW V0, 20(S8)
1008:                    _UU32 elements = num_elements;
9D01BF08  8FC20034   LW V0, 52(S8)
9D01BF0C  AFC20018   SW V0, 24(S8)
1009:                    _UU32 bytes;
1010:                
1011:                    UNITY_SKIP_EXECUTION;
9D01BF10  3C02A000   LUI V0, -24576
9D01BF14  24422F00   ADDIU V0, V0, 12032
9D01BF18  8C420018   LW V0, 24(V0)
9D01BF1C  1440009B   BNE V0, ZERO, 0x9D01C18C
9D01BF20  00000000   NOP
9D01BF24  3C02A000   LUI V0, -24576
9D01BF28  24422F00   ADDIU V0, V0, 12032
9D01BF2C  8C42001C   LW V0, 28(V0)
9D01BF30  14400096   BNE V0, ZERO, 0x9D01C18C
9D01BF34  00000000   NOP
1012:                
1013:                    if ((elements == 0) || (length == 0))
9D01BF38  8FC20018   LW V0, 24(S8)
9D01BF3C  10400004   BEQ V0, ZERO, 0x9D01BF50
9D01BF40  00000000   NOP
9D01BF44  8FC20030   LW V0, 48(S8)
9D01BF48  14400019   BNE V0, ZERO, 0x9D01BFB0
9D01BF4C  00000000   NOP
1014:                    {
1015:                        UnityTestResultsFailBegin(lineNumber);
9D01BF50  8FC4003C   LW A0, 60(S8)
9D01BF54  0F406937   JAL UnityTestResultsFailBegin
9D01BF58  00000000   NOP
1016:                        UnityPrint(UnityStrPointless);
9D01BF5C  8F828054   LW V0, -32684(GP)
9D01BF60  00402021   ADDU A0, V0, ZERO
9D01BF64  0F406757   JAL UnityPrint
9D01BF68  00000000   NOP
1017:                        UnityAddMsgIfSpecified(msg);
9D01BF6C  8FC40038   LW A0, 56(S8)
9D01BF70  0F40698A   JAL UnityAddMsgIfSpecified
9D01BF74  00000000   NOP
1018:                        UNITY_FAIL_AND_BAIL;
9D01BF78  3C02A000   LUI V0, -24576
9D01BF7C  24422F00   ADDIU V0, V0, 12032
9D01BF80  24030001   ADDIU V1, ZERO, 1
9D01BF84  AC430018   SW V1, 24(V0)
9D01BF88  2404000A   ADDIU A0, ZERO, 10
9D01BF8C  3C02A000   LUI V0, -24576
9D01BF90  24452FF4   ADDIU A1, V0, 12276
9D01BF94  0F40D3F2   JAL fputc
9D01BF98  00000000   NOP
9D01BF9C  3C02A000   LUI V0, -24576
9D01BFA0  24442F20   ADDIU A0, V0, 12064
9D01BFA4  24050001   ADDIU A1, ZERO, 1
9D01BFA8  0F40D4F1   JAL 0x9D0353C4
9D01BFAC  00000000   NOP
1019:                    }
1020:                
1021:                    if (UnityCheckArraysForNull((UNITY_PTR_ATTRIBUTE void*)expected, (UNITY_PTR_ATTRIBUTE void*)actual, lineNumber, msg) == 1)
9D01BFB0  8FC40028   LW A0, 40(S8)
9D01BFB4  8FC5002C   LW A1, 44(S8)
9D01BFB8  8FC6003C   LW A2, 60(S8)
9D01BFBC  8FC70038   LW A3, 56(S8)
9D01BFC0  0F4069DF   JAL UnityCheckArraysForNull
9D01BFC4  00000000   NOP
9D01BFC8  00401821   ADDU V1, V0, ZERO
9D01BFCC  24020001   ADDIU V0, ZERO, 1
9D01BFD0  14620065   BNE V1, V0, 0x9D01C168
9D01BFD4  00000000   NOP
1022:                        return;
9D01BFD8  0B407063   J 0x9D01C18C
9D01BFDC  00000000   NOP
1023:                
1024:                    while (elements--)
9D01C168  00000000   NOP
9D01C16C  8FC20018   LW V0, 24(S8)
9D01C170  0002102B   SLTU V0, ZERO, V0
9D01C174  304200FF   ANDI V0, V0, 255
9D01C178  8FC30018   LW V1, 24(S8)
9D01C17C  2463FFFF   ADDIU V1, V1, -1
9D01C180  AFC30018   SW V1, 24(S8)
9D01C184  1440FF96   BNE V0, ZERO, 0x9D01BFE0
9D01C188  00000000   NOP
1025:                    {
1026:                        /////////////////////////////////////
1027:                        bytes = length;
9D01BFE0  8FC20030   LW V0, 48(S8)
9D01BFE4  AFC2001C   SW V0, 28(S8)
1028:                        while (bytes--)
9D01BFE8  0B407050   J 0x9D01C140
9D01BFEC  00000000   NOP
9D01C140  8FC2001C   LW V0, 28(S8)
9D01C144  0002102B   SLTU V0, ZERO, V0
9D01C148  304200FF   ANDI V0, V0, 255
9D01C14C  8FC3001C   LW V1, 28(S8)
9D01C150  2463FFFF   ADDIU V1, V1, -1
9D01C154  AFC3001C   SW V1, 28(S8)
9D01C158  1440FFA5   BNE V0, ZERO, 0x9D01BFF0
9D01C15C  00000000   NOP
9D01C160  0B40705B   J 0x9D01C16C
9D01C164  00000000   NOP
1029:                        {
1030:                            if (*ptr_exp != *ptr_act)
9D01BFF0  8FC20010   LW V0, 16(S8)
9D01BFF4  90430000   LBU V1, 0(V0)
9D01BFF8  8FC20014   LW V0, 20(S8)
9D01BFFC  90420000   LBU V0, 0(V0)
9D01C000  10620049   BEQ V1, V0, 0x9D01C128
9D01C004  00000000   NOP
1031:                            {
1032:                                UnityTestResultsFailBegin(lineNumber);
9D01C008  8FC4003C   LW A0, 60(S8)
9D01C00C  0F406937   JAL UnityTestResultsFailBegin
9D01C010  00000000   NOP
1033:                                UnityPrint(UnityStrMemory);
9D01C014  8F82804C   LW V0, -32692(GP)
9D01C018  00402021   ADDU A0, V0, ZERO
9D01C01C  0F406757   JAL UnityPrint
9D01C020  00000000   NOP
1034:                                if (num_elements > 1)
9D01C024  8FC20034   LW V0, 52(S8)
9D01C028  2C420002   SLTIU V0, V0, 2
9D01C02C  1440000D   BNE V0, ZERO, 0x9D01C064
9D01C030  00000000   NOP
1035:                                {
1036:                                    UnityPrint(UnityStrElement);
9D01C034  8F828044   LW V0, -32700(GP)
9D01C038  00402021   ADDU A0, V0, ZERO
9D01C03C  0F406757   JAL UnityPrint
9D01C040  00000000   NOP
1037:                                    UnityPrintNumberByStyle((num_elements - elements - 1), UNITY_DISPLAY_STYLE_UINT);
9D01C044  8FC30034   LW V1, 52(S8)
9D01C048  8FC20018   LW V0, 24(S8)
9D01C04C  00621023   SUBU V0, V1, V0
9D01C050  2442FFFF   ADDIU V0, V0, -1
9D01C054  00402021   ADDU A0, V0, ZERO
9D01C058  240500A4   ADDIU A1, ZERO, 164
9D01C05C  0F4067B0   JAL UnityPrintNumberByStyle
9D01C060  00000000   NOP
1038:                                }
1039:                                UnityPrint(UnityStrByte);
9D01C064  8F828048   LW V0, -32696(GP)
9D01C068  00402021   ADDU A0, V0, ZERO
9D01C06C  0F406757   JAL UnityPrint
9D01C070  00000000   NOP
1040:                                UnityPrintNumberByStyle((length - bytes - 1), UNITY_DISPLAY_STYLE_UINT);
9D01C074  8FC30030   LW V1, 48(S8)
9D01C078  8FC2001C   LW V0, 28(S8)
9D01C07C  00621023   SUBU V0, V1, V0
9D01C080  2442FFFF   ADDIU V0, V0, -1
9D01C084  00402021   ADDU A0, V0, ZERO
9D01C088  240500A4   ADDIU A1, ZERO, 164
9D01C08C  0F4067B0   JAL UnityPrintNumberByStyle
9D01C090  00000000   NOP
1041:                                UnityPrint(UnityStrExpected);
9D01C094  8F828038   LW V0, -32712(GP)
9D01C098  00402021   ADDU A0, V0, ZERO
9D01C09C  0F406757   JAL UnityPrint
9D01C0A0  00000000   NOP
1042:                                UnityPrintNumberByStyle(*ptr_exp, UNITY_DISPLAY_STYLE_HEX8);
9D01C0A4  8FC20010   LW V0, 16(S8)
9D01C0A8  90420000   LBU V0, 0(V0)
9D01C0AC  00402021   ADDU A0, V0, ZERO
9D01C0B0  24050041   ADDIU A1, ZERO, 65
9D01C0B4  0F4067B0   JAL UnityPrintNumberByStyle
9D01C0B8  00000000   NOP
1043:                                UnityPrint(UnityStrWas);
9D01C0BC  8F82803C   LW V0, -32708(GP)
9D01C0C0  00402021   ADDU A0, V0, ZERO
9D01C0C4  0F406757   JAL UnityPrint
9D01C0C8  00000000   NOP
1044:                                UnityPrintNumberByStyle(*ptr_act, UNITY_DISPLAY_STYLE_HEX8);
9D01C0CC  8FC20014   LW V0, 20(S8)
9D01C0D0  90420000   LBU V0, 0(V0)
9D01C0D4  00402021   ADDU A0, V0, ZERO
9D01C0D8  24050041   ADDIU A1, ZERO, 65
9D01C0DC  0F4067B0   JAL UnityPrintNumberByStyle
9D01C0E0  00000000   NOP
1045:                                UnityAddMsgIfSpecified(msg);
9D01C0E4  8FC40038   LW A0, 56(S8)
9D01C0E8  0F40698A   JAL UnityAddMsgIfSpecified
9D01C0EC  00000000   NOP
1046:                                UNITY_FAIL_AND_BAIL;
9D01C0F0  3C02A000   LUI V0, -24576
9D01C0F4  24422F00   ADDIU V0, V0, 12032
9D01C0F8  24030001   ADDIU V1, ZERO, 1
9D01C0FC  AC430018   SW V1, 24(V0)
9D01C100  2404000A   ADDIU A0, ZERO, 10
9D01C104  3C02A000   LUI V0, -24576
9D01C108  24452FF4   ADDIU A1, V0, 12276
9D01C10C  0F40D3F2   JAL fputc
9D01C110  00000000   NOP
9D01C114  3C02A000   LUI V0, -24576
9D01C118  24442F20   ADDIU A0, V0, 12064
9D01C11C  24050001   ADDIU A1, ZERO, 1
9D01C120  0F40D4F1   JAL 0x9D0353C4
9D01C124  00000000   NOP
1047:                            }
1048:                            ptr_exp += 1;
9D01C128  8FC20010   LW V0, 16(S8)
9D01C12C  24420001   ADDIU V0, V0, 1
9D01C130  AFC20010   SW V0, 16(S8)
1049:                            ptr_act += 1;
9D01C134  8FC20014   LW V0, 20(S8)
9D01C138  24420001   ADDIU V0, V0, 1
9D01C13C  AFC20014   SW V0, 20(S8)
1050:                        }
1051:                        /////////////////////////////////////
1052:                
1053:                    }
1054:                }
9D01C18C  03C0E821   ADDU SP, S8, ZERO
9D01C190  8FBF0024   LW RA, 36(SP)
9D01C194  8FBE0020   LW S8, 32(SP)
9D01C198  27BD0028   ADDIU SP, SP, 40
9D01C19C  03E00008   JR RA
9D01C1A0  00000000   NOP
1055:                
1056:                //-----------------------------------------------
1057:                // Control Functions
1058:                //-----------------------------------------------
1059:                
1060:                void UnityFail(const char* msg, const UNITY_LINE_TYPE line)
1061:                {
9D01C1A4  27BDFFE8   ADDIU SP, SP, -24
9D01C1A8  AFBF0014   SW RA, 20(SP)
9D01C1AC  AFBE0010   SW S8, 16(SP)
9D01C1B0  03A0F021   ADDU S8, SP, ZERO
9D01C1B4  AFC40018   SW A0, 24(S8)
9D01C1B8  AFC5001C   SW A1, 28(S8)
1062:                    UNITY_SKIP_EXECUTION;
9D01C1BC  3C02A000   LUI V0, -24576
9D01C1C0  24422F00   ADDIU V0, V0, 12032
9D01C1C4  8C420018   LW V0, 24(V0)
9D01C1C8  14400031   BNE V0, ZERO, 0x9D01C290
9D01C1CC  00000000   NOP
9D01C1D0  3C02A000   LUI V0, -24576
9D01C1D4  24422F00   ADDIU V0, V0, 12032
9D01C1D8  8C42001C   LW V0, 28(V0)
9D01C1DC  1440002C   BNE V0, ZERO, 0x9D01C290
9D01C1E0  00000000   NOP
1063:                
1064:                    UnityTestResultsBegin(Unity.TestFile, line);
9D01C1E4  3C02A000   LUI V0, -24576
9D01C1E8  8C422F00   LW V0, 12032(V0)
9D01C1EC  00402021   ADDU A0, V0, ZERO
9D01C1F0  8FC5001C   LW A1, 28(S8)
9D01C1F4  0F40690F   JAL UnityTestResultsBegin
9D01C1F8  00000000   NOP
1065:                    UnityPrintFail();
9D01C1FC  0F4068F3   JAL UnityPrintFail
9D01C200  00000000   NOP
1066:                    if (msg != NULL)
9D01C204  8FC20018   LW V0, 24(S8)
9D01C208  10400013   BEQ V0, ZERO, 0x9D01C258
9D01C20C  00000000   NOP
1067:                    {
1068:                      UNITY_OUTPUT_CHAR(':');
9D01C210  2404003A   ADDIU A0, ZERO, 58
9D01C214  3C02A000   LUI V0, -24576
9D01C218  24452FF4   ADDIU A1, V0, 12276
9D01C21C  0F40D3F2   JAL fputc
9D01C220  00000000   NOP
1069:                      if (msg[0] != ' ')
9D01C224  8FC20018   LW V0, 24(S8)
9D01C228  80430000   LB V1, 0(V0)
9D01C22C  24020020   ADDIU V0, ZERO, 32
9D01C230  10620006   BEQ V1, V0, 0x9D01C24C
9D01C234  00000000   NOP
1070:                      {
1071:                        UNITY_OUTPUT_CHAR(' ');
9D01C238  24040020   ADDIU A0, ZERO, 32
9D01C23C  3C02A000   LUI V0, -24576
9D01C240  24452FF4   ADDIU A1, V0, 12276
9D01C244  0F40D3F2   JAL fputc
9D01C248  00000000   NOP
1072:                      }
1073:                      UnityPrint(msg);
9D01C24C  8FC40018   LW A0, 24(S8)
9D01C250  0F406757   JAL UnityPrint
9D01C254  00000000   NOP
1074:                    }
1075:                    UNITY_FAIL_AND_BAIL;
9D01C258  3C02A000   LUI V0, -24576
9D01C25C  24422F00   ADDIU V0, V0, 12032
9D01C260  24030001   ADDIU V1, ZERO, 1
9D01C264  AC430018   SW V1, 24(V0)
9D01C268  2404000A   ADDIU A0, ZERO, 10
9D01C26C  3C02A000   LUI V0, -24576
9D01C270  24452FF4   ADDIU A1, V0, 12276
9D01C274  0F40D3F2   JAL fputc
9D01C278  00000000   NOP
9D01C27C  3C02A000   LUI V0, -24576
9D01C280  24442F20   ADDIU A0, V0, 12064
9D01C284  24050001   ADDIU A1, ZERO, 1
9D01C288  0F40D4F1   JAL 0x9D0353C4
9D01C28C  00000000   NOP
1076:                }
9D01C290  03C0E821   ADDU SP, S8, ZERO
9D01C294  8FBF0014   LW RA, 20(SP)
9D01C298  8FBE0010   LW S8, 16(SP)
9D01C29C  27BD0018   ADDIU SP, SP, 24
9D01C2A0  03E00008   JR RA
9D01C2A4  00000000   NOP
1077:                
1078:                //-----------------------------------------------
1079:                void UnityIgnore(const char* msg, const UNITY_LINE_TYPE line)
1080:                {
9D01C2A8  27BDFFE8   ADDIU SP, SP, -24
9D01C2AC  AFBF0014   SW RA, 20(SP)
9D01C2B0  AFBE0010   SW S8, 16(SP)
9D01C2B4  03A0F021   ADDU S8, SP, ZERO
9D01C2B8  AFC40018   SW A0, 24(S8)
9D01C2BC  AFC5001C   SW A1, 28(S8)
1081:                    UNITY_SKIP_EXECUTION;
9D01C2C0  3C02A000   LUI V0, -24576
9D01C2C4  24422F00   ADDIU V0, V0, 12032
9D01C2C8  8C420018   LW V0, 24(V0)
9D01C2CC  1440002E   BNE V0, ZERO, 0x9D01C388
9D01C2D0  00000000   NOP
9D01C2D4  3C02A000   LUI V0, -24576
9D01C2D8  24422F00   ADDIU V0, V0, 12032
9D01C2DC  8C42001C   LW V0, 28(V0)
9D01C2E0  14400029   BNE V0, ZERO, 0x9D01C388
9D01C2E4  00000000   NOP
1082:                
1083:                    UnityTestResultsBegin(Unity.TestFile, line);
9D01C2E8  3C02A000   LUI V0, -24576
9D01C2EC  8C422F00   LW V0, 12032(V0)
9D01C2F0  00402021   ADDU A0, V0, ZERO
9D01C2F4  8FC5001C   LW A1, 28(S8)
9D01C2F8  0F40690F   JAL UnityTestResultsBegin
9D01C2FC  00000000   NOP
1084:                    UnityPrint("IGNORE");
9D01C300  3C029D03   LUI V0, -25341
9D01C304  24444A14   ADDIU A0, V0, 18964
9D01C308  0F406757   JAL UnityPrint
9D01C30C  00000000   NOP
1085:                    if (msg != NULL)
9D01C310  8FC20018   LW V0, 24(S8)
9D01C314  1040000E   BEQ V0, ZERO, 0x9D01C350
9D01C318  00000000   NOP
1086:                    {
1087:                      UNITY_OUTPUT_CHAR(':');
9D01C31C  2404003A   ADDIU A0, ZERO, 58
9D01C320  3C02A000   LUI V0, -24576
9D01C324  24452FF4   ADDIU A1, V0, 12276
9D01C328  0F40D3F2   JAL fputc
9D01C32C  00000000   NOP
1088:                      UNITY_OUTPUT_CHAR(' ');
9D01C330  24040020   ADDIU A0, ZERO, 32
9D01C334  3C02A000   LUI V0, -24576
9D01C338  24452FF4   ADDIU A1, V0, 12276
9D01C33C  0F40D3F2   JAL fputc
9D01C340  00000000   NOP
1089:                      UnityPrint(msg);
9D01C344  8FC40018   LW A0, 24(S8)
9D01C348  0F406757   JAL UnityPrint
9D01C34C  00000000   NOP
1090:                    }
1091:                    UNITY_IGNORE_AND_BAIL;
9D01C350  3C02A000   LUI V0, -24576
9D01C354  24422F00   ADDIU V0, V0, 12032
9D01C358  24030001   ADDIU V1, ZERO, 1
9D01C35C  AC43001C   SW V1, 28(V0)
9D01C360  2404000A   ADDIU A0, ZERO, 10
9D01C364  3C02A000   LUI V0, -24576
9D01C368  24452FF4   ADDIU A1, V0, 12276
9D01C36C  0F40D3F2   JAL fputc
9D01C370  00000000   NOP
9D01C374  3C02A000   LUI V0, -24576
9D01C378  24442F20   ADDIU A0, V0, 12064
9D01C37C  24050001   ADDIU A1, ZERO, 1
9D01C380  0F40D4F1   JAL 0x9D0353C4
9D01C384  00000000   NOP
1092:                }
9D01C388  03C0E821   ADDU SP, S8, ZERO
9D01C38C  8FBF0014   LW RA, 20(SP)
9D01C390  8FBE0010   LW S8, 16(SP)
9D01C394  27BD0018   ADDIU SP, SP, 24
9D01C398  03E00008   JR RA
9D01C39C  00000000   NOP
1093:                
1094:                //-----------------------------------------------
1095:                void setUp(void);
1096:                void tearDown(void);
1097:                void UnityDefaultTestRun(UnityTestFunction Func, const char* FuncName, const int FuncLineNum)
1098:                {
9D01C3A0  27BDFFE8   ADDIU SP, SP, -24
9D01C3A4  AFBF0014   SW RA, 20(SP)
9D01C3A8  AFBE0010   SW S8, 16(SP)
9D01C3AC  03A0F021   ADDU S8, SP, ZERO
9D01C3B0  AFC40018   SW A0, 24(S8)
9D01C3B4  AFC5001C   SW A1, 28(S8)
9D01C3B8  AFC60020   SW A2, 32(S8)
1099:                    Unity.CurrentTestName = FuncName;
9D01C3BC  3C02A000   LUI V0, -24576
9D01C3C0  24422F00   ADDIU V0, V0, 12032
9D01C3C4  8FC3001C   LW V1, 28(S8)
9D01C3C8  AC430004   SW V1, 4(V0)
1100:                    Unity.CurrentTestLineNumber = FuncLineNum;
9D01C3CC  8FC30020   LW V1, 32(S8)
9D01C3D0  3C02A000   LUI V0, -24576
9D01C3D4  24422F00   ADDIU V0, V0, 12032
9D01C3D8  AC430008   SW V1, 8(V0)
1101:                    Unity.NumberOfTests++;
9D01C3DC  3C02A000   LUI V0, -24576
9D01C3E0  24422F00   ADDIU V0, V0, 12032
9D01C3E4  8C42000C   LW V0, 12(V0)
9D01C3E8  24430001   ADDIU V1, V0, 1
9D01C3EC  3C02A000   LUI V0, -24576
9D01C3F0  24422F00   ADDIU V0, V0, 12032
9D01C3F4  AC43000C   SW V1, 12(V0)
1102:                    if (TEST_PROTECT())
9D01C3F8  3C02A000   LUI V0, -24576
9D01C3FC  24442F20   ADDIU A0, V0, 12064
9D01C400  0F40D4D5   JAL 0x9D035354
9D01C404  00000000   NOP
9D01C408  14400006   BNE V0, ZERO, 0x9D01C424
9D01C40C  00000000   NOP
1103:                    {
1104:                        setUp();
9D01C410  0F40D7CA   JAL setUp
9D01C414  00000000   NOP
1105:                        Func();
9D01C418  8FC20018   LW V0, 24(S8)
9D01C41C  0040F809   JALR V0
9D01C420  00000000   NOP
1106:                    }
1107:                    if (TEST_PROTECT() && !(Unity.CurrentTestIgnored))
9D01C424  3C02A000   LUI V0, -24576
9D01C428  24442F20   ADDIU A0, V0, 12064
9D01C42C  0F40D4D5   JAL 0x9D035354
9D01C430  00000000   NOP
9D01C434  14400008   BNE V0, ZERO, 0x9D01C458
9D01C438  00000000   NOP
9D01C43C  3C02A000   LUI V0, -24576
9D01C440  24422F00   ADDIU V0, V0, 12032
9D01C444  8C42001C   LW V0, 28(V0)
9D01C448  14400003   BNE V0, ZERO, 0x9D01C458
9D01C44C  00000000   NOP
1108:                    {
1109:                        tearDown();
9D01C450  0F40D7D2   JAL tearDown
9D01C454  00000000   NOP
1110:                    }
1111:                    UnityConcludeTest();
9D01C458  0F40694C   JAL UnityConcludeTest
9D01C45C  00000000   NOP
1112:                }
9D01C460  03C0E821   ADDU SP, S8, ZERO
9D01C464  8FBF0014   LW RA, 20(SP)
9D01C468  8FBE0010   LW S8, 16(SP)
9D01C46C  27BD0018   ADDIU SP, SP, 24
9D01C470  03E00008   JR RA
9D01C474  00000000   NOP
1113:                
1114:                //-----------------------------------------------
1115:                void UnityBegin(void)
1116:                {
9D01C478  27BDFFF8   ADDIU SP, SP, -8
9D01C47C  AFBE0004   SW S8, 4(SP)
9D01C480  03A0F021   ADDU S8, SP, ZERO
1117:                    Unity.NumberOfTests = 0;
9D01C484  3C02A000   LUI V0, -24576
9D01C488  24422F00   ADDIU V0, V0, 12032
9D01C48C  AC40000C   SW ZERO, 12(V0)
1118:                    Unity.TestFailures = 0;
9D01C490  3C02A000   LUI V0, -24576
9D01C494  24422F00   ADDIU V0, V0, 12032
9D01C498  AC400010   SW ZERO, 16(V0)
1119:                    Unity.TestIgnores = 0;
9D01C49C  3C02A000   LUI V0, -24576
9D01C4A0  24422F00   ADDIU V0, V0, 12032
9D01C4A4  AC400014   SW ZERO, 20(V0)
1120:                    Unity.CurrentTestFailed = 0;
9D01C4A8  3C02A000   LUI V0, -24576
9D01C4AC  24422F00   ADDIU V0, V0, 12032
9D01C4B0  AC400018   SW ZERO, 24(V0)
1121:                    Unity.CurrentTestIgnored = 0;
9D01C4B4  3C02A000   LUI V0, -24576
9D01C4B8  24422F00   ADDIU V0, V0, 12032
9D01C4BC  AC40001C   SW ZERO, 28(V0)
1122:                }
9D01C4C0  03C0E821   ADDU SP, S8, ZERO
9D01C4C4  8FBE0004   LW S8, 4(SP)
9D01C4C8  27BD0008   ADDIU SP, SP, 8
9D01C4CC  03E00008   JR RA
9D01C4D0  00000000   NOP
1123:                
1124:                //-----------------------------------------------
1125:                int UnityEnd(void)
1126:                {
9D01C4D4  27BDFFE8   ADDIU SP, SP, -24
9D01C4D8  AFBF0014   SW RA, 20(SP)
9D01C4DC  AFBE0010   SW S8, 16(SP)
9D01C4E0  03A0F021   ADDU S8, SP, ZERO
1127:                    UnityPrint("-----------------------");
9D01C4E4  3C029D03   LUI V0, -25341
9D01C4E8  24444A1C   ADDIU A0, V0, 18972
9D01C4EC  0F406757   JAL UnityPrint
9D01C4F0  00000000   NOP
1128:                    UNITY_PRINT_EOL;
9D01C4F4  2404000A   ADDIU A0, ZERO, 10
9D01C4F8  3C02A000   LUI V0, -24576
9D01C4FC  24452FF4   ADDIU A1, V0, 12276
9D01C500  0F40D3F2   JAL fputc
9D01C504  00000000   NOP
1129:                    UnityPrintNumber(Unity.NumberOfTests);
9D01C508  3C02A000   LUI V0, -24576
9D01C50C  24422F00   ADDIU V0, V0, 12032
9D01C510  8C42000C   LW V0, 12(V0)
9D01C514  00402021   ADDU A0, V0, ZERO
9D01C518  0F4067E1   JAL UnityPrintNumber
9D01C51C  00000000   NOP
1130:                    UnityPrint(" Tests ");
9D01C520  3C029D03   LUI V0, -25341
9D01C524  24444A34   ADDIU A0, V0, 18996
9D01C528  0F406757   JAL UnityPrint
9D01C52C  00000000   NOP
1131:                    UnityPrintNumber(Unity.TestFailures);
9D01C530  3C02A000   LUI V0, -24576
9D01C534  24422F00   ADDIU V0, V0, 12032
9D01C538  8C420010   LW V0, 16(V0)
9D01C53C  00402021   ADDU A0, V0, ZERO
9D01C540  0F4067E1   JAL UnityPrintNumber
9D01C544  00000000   NOP
1132:                    UnityPrint(" Failures ");
9D01C548  3C029D03   LUI V0, -25341
9D01C54C  24444A3C   ADDIU A0, V0, 19004
9D01C550  0F406757   JAL UnityPrint
9D01C554  00000000   NOP
1133:                    UnityPrintNumber(Unity.TestIgnores);
9D01C558  3C02A000   LUI V0, -24576
9D01C55C  24422F00   ADDIU V0, V0, 12032
9D01C560  8C420014   LW V0, 20(V0)
9D01C564  00402021   ADDU A0, V0, ZERO
9D01C568  0F4067E1   JAL UnityPrintNumber
9D01C56C  00000000   NOP
1134:                    UnityPrint(" Ignored");
9D01C570  3C029D03   LUI V0, -25341
9D01C574  24444A48   ADDIU A0, V0, 19016
9D01C578  0F406757   JAL UnityPrint
9D01C57C  00000000   NOP
1135:                    UNITY_PRINT_EOL;
9D01C580  2404000A   ADDIU A0, ZERO, 10
9D01C584  3C02A000   LUI V0, -24576
9D01C588  24452FF4   ADDIU A1, V0, 12276
9D01C58C  0F40D3F2   JAL fputc
9D01C590  00000000   NOP
1136:                    if (Unity.TestFailures == 0U)
9D01C594  3C02A000   LUI V0, -24576
9D01C598  24422F00   ADDIU V0, V0, 12032
9D01C59C  8C420010   LW V0, 16(V0)
9D01C5A0  14400005   BNE V0, ZERO, 0x9D01C5B8
9D01C5A4  00000000   NOP
1137:                    {
1138:                        UnityPrintOk();
9D01C5A8  0F406901   JAL UnityPrintOk
9D01C5AC  00000000   NOP
9D01C5B0  0B407170   J 0x9D01C5C0
9D01C5B4  00000000   NOP
1139:                    }
1140:                    else
1141:                    {
1142:                        UnityPrintFail();
9D01C5B8  0F4068F3   JAL UnityPrintFail
9D01C5BC  00000000   NOP
1143:                    }
1144:                    UNITY_PRINT_EOL;
9D01C5C0  2404000A   ADDIU A0, ZERO, 10
9D01C5C4  3C02A000   LUI V0, -24576
9D01C5C8  24452FF4   ADDIU A1, V0, 12276
9D01C5CC  0F40D3F2   JAL fputc
9D01C5D0  00000000   NOP
1145:                    return Unity.TestFailures;
9D01C5D4  3C02A000   LUI V0, -24576
9D01C5D8  24422F00   ADDIU V0, V0, 12032
9D01C5DC  8C420010   LW V0, 16(V0)
1146:                }
9D01C5E0  03C0E821   ADDU SP, S8, ZERO
9D01C5E4  8FBF0014   LW RA, 20(SP)
9D01C5E8  8FBE0010   LW S8, 16(SP)
9D01C5EC  27BD0018   ADDIU SP, SP, 24
9D01C5F0  03E00008   JR RA
9D01C5F4  00000000   NOP
---  C:/Users/Diego/Documents/GitHub/pic32webFREERtos/Pic32Web.X/src/UnitTests/sampletest.c  ------------
1:                   /* 
2:                    * File:   sampletest.c
3:                    * Author: Diego
4:                    *
5:                    * Created on 25. Oktober 2013, 18:37
6:                    */
7:                   
8:                   #include <stdio.h>
9:                   #include <stdlib.h>
10:                  
11:                  /*
12:                   * 
13:                   */
14:                  
15:                  void setUp()
16:                  {
9D035F28  27BDFFF8   ADDIU SP, SP, -8
9D035F2C  AFBE0004   SW S8, 4(SP)
9D035F30  03A0F021   ADDU S8, SP, ZERO
17:                  
18:                  }
9D035F34  03C0E821   ADDU SP, S8, ZERO
9D035F38  8FBE0004   LW S8, 4(SP)
9D035F3C  27BD0008   ADDIU SP, SP, 8
9D035F40  03E00008   JR RA
9D035F44  00000000   NOP
19:                  
20:                  void tearDown()
21:                  {
9D035F48  27BDFFF8   ADDIU SP, SP, -8
9D035F4C  AFBE0004   SW S8, 4(SP)
9D035F50  03A0F021   ADDU S8, SP, ZERO
22:                      
23:                  }
9D035F54  03C0E821   ADDU SP, S8, ZERO
9D035F58  8FBE0004   LW S8, 4(SP)
9D035F5C  27BD0008   ADDIU SP, SP, 8
9D035F60  03E00008   JR RA
9D035F64  00000000   NOP
---  C:/Users/Diego/Documents/GitHub/pic32webFREERtos/Pic32Web.X/src/FreeRTOS/timers.c  -----------------
1:                   /*
2:                       FreeRTOS V7.5.3 - Copyright (C) 2013 Real Time Engineers Ltd. 
3:                       All rights reserved
4:                   
5:                       VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
6:                   
7:                       ***************************************************************************
8:                        *                                                                       *
9:                        *    FreeRTOS provides completely free yet professionally developed,    *
10:                       *    robust, strictly quality controlled, supported, and cross          *
11:                       *    platform software that has become a de facto standard.             *
12:                       *                                                                       *
13:                       *    Help yourself get started quickly and support the FreeRTOS         *
14:                       *    project by purchasing a FreeRTOS tutorial book, reference          *
15:                       *    manual, or both from: http://www.FreeRTOS.org/Documentation        *
16:                       *                                                                       *
17:                       *    Thank you!                                                         *
18:                       *                                                                       *
19:                      ***************************************************************************
20:                  
21:                      This file is part of the FreeRTOS distribution.
22:                  
23:                      FreeRTOS is free software; you can redistribute it and/or modify it under
24:                      the terms of the GNU General Public License (version 2) as published by the
25:                      Free Software Foundation >>!AND MODIFIED BY!<< the FreeRTOS exception.
26:                  
27:                      >>! NOTE: The modification to the GPL is included to allow you to distribute
28:                      >>! a combined work that includes FreeRTOS without being obliged to provide
29:                      >>! the source code for proprietary components outside of the FreeRTOS
30:                      >>! kernel.
31:                  
32:                      FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
33:                      WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
34:                      FOR A PARTICULAR PURPOSE.  Full license text is available from the following
35:                      link: http://www.freertos.org/a00114.html
36:                  
37:                      1 tab == 4 spaces!
38:                  
39:                      ***************************************************************************
40:                       *                                                                       *
41:                       *    Having a problem?  Start by reading the FAQ "My application does   *
42:                       *    not run, what could be wrong?"                                     *
43:                       *                                                                       *
44:                       *    http://www.FreeRTOS.org/FAQHelp.html                               *
45:                       *                                                                       *
46:                      ***************************************************************************
47:                  
48:                      http://www.FreeRTOS.org - Documentation, books, training, latest versions,
49:                      license and Real Time Engineers Ltd. contact details.
50:                  
51:                      http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
52:                      including FreeRTOS+Trace - an indispensable productivity tool, a DOS
53:                      compatible FAT file system, and our tiny thread aware UDP/IP stack.
54:                  
55:                      http://www.OpenRTOS.com - Real Time Engineers ltd license FreeRTOS to High
56:                      Integrity Systems to sell under the OpenRTOS brand.  Low cost OpenRTOS
57:                      licenses offer ticketed support, indemnification and middleware.
58:                  
59:                      http://www.SafeRTOS.com - High Integrity Systems also provide a safety
60:                      engineered and independently SIL3 certified version for use in safety and
61:                      mission critical applications that require provable dependability.
62:                  
63:                      1 tab == 4 spaces!
64:                  */
65:                  
66:                  /* Standard includes. */
67:                  #include <stdlib.h>
68:                  
69:                  /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
70:                  all the API functions to use the MPU wrappers.  That should only be done when
71:                  task.h is included from an application file. */
72:                  #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
73:                  
74:                  #include "FreeRTOS.h"
75:                  #include "task.h"
76:                  #include "queue.h"
77:                  #include "timers.h"
78:                  
79:                  /* Lint e961 and e750 are suppressed as a MISRA exception justified because the
80:                  MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined for the
81:                  header files above, but not in this file, in order to generate the correct
82:                  privileged Vs unprivileged linkage and placement. */
83:                  #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE /*lint !e961 !e750. */
84:                  
85:                  
86:                  /* This entire source file will be skipped if the application is not configured
87:                  to include software timer functionality.  This #if is closed at the very bottom
88:                  of this file.  If you want to include software timer functionality then ensure
89:                  configUSE_TIMERS is set to 1 in FreeRTOSConfig.h. */
90:                  #if ( configUSE_TIMERS == 1 )
91:                  
92:                  /* Misc definitions. */
93:                  #define tmrNO_DELAY		( portTickType ) 0U
94:                  
95:                  /* The definition of the timers themselves. */
96:                  typedef struct tmrTimerControl
97:                  {
98:                  	const signed char		*pcTimerName;		/*<< Text name.  This is not used by the kernel, it is included simply to make debugging easier. */
99:                  	xListItem				xTimerListItem;		/*<< Standard linked list item as used by all kernel features for event management. */
100:                 	portTickType			xTimerPeriodInTicks;/*<< How quickly and often the timer expires. */
101:                 	unsigned portBASE_TYPE	uxAutoReload;		/*<< Set to pdTRUE if the timer should be automatically restarted once expired.  Set to pdFALSE if the timer is, in effect, a one shot timer. */
102:                 	void 					*pvTimerID;			/*<< An ID to identify the timer.  This allows the timer to be identified when the same callback is used for multiple timers. */
103:                 	tmrTIMER_CALLBACK		pxCallbackFunction;	/*<< The function that will be called when the timer expires. */
104:                 } xTIMER;
105:                 
106:                 /* The definition of messages that can be sent and received on the timer
107:                 queue. */
108:                 typedef struct tmrTimerQueueMessage
109:                 {
110:                 	portBASE_TYPE			xMessageID;			/*<< The command being sent to the timer service task. */
111:                 	portTickType			xMessageValue;		/*<< An optional value used by a subset of commands, for example, when changing the period of a timer. */
112:                 	xTIMER *				pxTimer;			/*<< The timer to which the command will be applied. */
113:                 } xTIMER_MESSAGE;
114:                 
115:                 /*lint -e956 A manual analysis and inspection has been used to determine which
116:                 static variables must be declared volatile. */
117:                 
118:                 /* The list in which active timers are stored.  Timers are referenced in expire
119:                 time order, with the nearest expiry time at the front of the list.  Only the
120:                 timer service task is allowed to access xActiveTimerList. */
121:                 PRIVILEGED_DATA static xList xActiveTimerList1;
122:                 PRIVILEGED_DATA static xList xActiveTimerList2;
123:                 PRIVILEGED_DATA static xList *pxCurrentTimerList;
124:                 PRIVILEGED_DATA static xList *pxOverflowTimerList;
125:                 
126:                 /* A queue that is used to send commands to the timer service task. */
127:                 PRIVILEGED_DATA static xQueueHandle xTimerQueue = NULL;
128:                 
129:                 #if ( INCLUDE_xTimerGetTimerDaemonTaskHandle == 1 )
130:                 
131:                 	PRIVILEGED_DATA static xTaskHandle xTimerTaskHandle = NULL;
132:                 
133:                 #endif
134:                 
135:                 /*lint +e956 */
136:                 
137:                 /*-----------------------------------------------------------*/
138:                 
139:                 /*
140:                  * Initialise the infrastructure used by the timer service task if it has not
141:                  * been initialised already.
142:                  */
143:                 static void prvCheckForValidListAndQueue( void ) PRIVILEGED_FUNCTION;
144:                 
145:                 /*
146:                  * The timer service task (daemon).  Timer functionality is controlled by this
147:                  * task.  Other tasks communicate with the timer service task using the
148:                  * xTimerQueue queue.
149:                  */
150:                 static void prvTimerTask( void *pvParameters ) PRIVILEGED_FUNCTION;
151:                 
152:                 /*
153:                  * Called by the timer service task to interpret and process a command it
154:                  * received on the timer queue.
155:                  */
156:                 static void	prvProcessReceivedCommands( void ) PRIVILEGED_FUNCTION;
157:                 
158:                 /*
159:                  * Insert the timer into either xActiveTimerList1, or xActiveTimerList2,
160:                  * depending on if the expire time causes a timer counter overflow.
161:                  */
162:                 static portBASE_TYPE prvInsertTimerInActiveList( xTIMER *pxTimer, portTickType xNextExpiryTime, portTickType xTimeNow, portTickType xCommandTime ) PRIVILEGED_FUNCTION;
163:                 
164:                 /*
165:                  * An active timer has reached its expire time.  Reload the timer if it is an
166:                  * auto reload timer, then call its callback.
167:                  */
168:                 static void prvProcessExpiredTimer( portTickType xNextExpireTime, portTickType xTimeNow ) PRIVILEGED_FUNCTION;
169:                 
170:                 /*
171:                  * The tick count has overflowed.  Switch the timer lists after ensuring the
172:                  * current timer list does not still reference some timers.
173:                  */
174:                 static void prvSwitchTimerLists( portTickType xLastTime ) PRIVILEGED_FUNCTION;
175:                 
176:                 /*
177:                  * Obtain the current tick count, setting *pxTimerListsWereSwitched to pdTRUE
178:                  * if a tick count overflow occurred since prvSampleTimeNow() was last called.
179:                  */
180:                 static portTickType prvSampleTimeNow( portBASE_TYPE *pxTimerListsWereSwitched ) PRIVILEGED_FUNCTION;
181:                 
182:                 /*
183:                  * If the timer list contains any active timers then return the expire time of
184:                  * the timer that will expire first and set *pxListWasEmpty to false.  If the
185:                  * timer list does not contain any timers then return 0 and set *pxListWasEmpty
186:                  * to pdTRUE.
187:                  */
188:                 static portTickType prvGetNextExpireTime( portBASE_TYPE *pxListWasEmpty ) PRIVILEGED_FUNCTION;
189:                 
190:                 /*
191:                  * If a timer has expired, process it.  Otherwise, block the timer service task
192:                  * until either a timer does expire or a command is received.
193:                  */
194:                 static void prvProcessTimerOrBlockTask( portTickType xNextExpireTime, portBASE_TYPE xListWasEmpty ) PRIVILEGED_FUNCTION;
195:                 
196:                 /*-----------------------------------------------------------*/
197:                 
198:                 portBASE_TYPE xTimerCreateTimerTask( void )
199:                 {
9D02BEDC  27BDFFD0   ADDIU SP, SP, -48
9D02BEE0  AFBF002C   SW RA, 44(SP)
9D02BEE4  AFBE0028   SW S8, 40(SP)
9D02BEE8  03A0F021   ADDU S8, SP, ZERO
200:                 portBASE_TYPE xReturn = pdFAIL;
9D02BEEC  AFC00020   SW ZERO, 32(S8)
201:                 
202:                 	/* This function is called when the scheduler is started if
203:                 	configUSE_TIMERS is set to 1.  Check that the infrastructure used by the
204:                 	timer service task has been created/initialised.  If timers have already
205:                 	been created then the initialisation will already have been performed. */
206:                 	prvCheckForValidListAndQueue();
9D02BEF0  0F40B250   JAL 0x9D02C940
9D02BEF4  00000000   NOP
207:                 
208:                 	if( xTimerQueue != NULL )
9D02BEF8  8F8280C4   LW V0, -32572(GP)
9D02BEFC  1040000F   BEQ V0, ZERO, 0x9D02BF3C
9D02BF00  00000000   NOP
209:                 	{
210:                 		#if ( INCLUDE_xTimerGetTimerDaemonTaskHandle == 1 )
211:                 		{
212:                 			/* Create the timer task, storing its handle in xTimerTaskHandle so
213:                 			it can be returned by the xTimerGetTimerDaemonTaskHandle() function. */
214:                 			xReturn = xTaskCreate( prvTimerTask, ( const signed char * ) "Tmr Svc", ( unsigned short ) configTIMER_TASK_STACK_DEPTH, NULL, ( ( unsigned portBASE_TYPE ) configTIMER_TASK_PRIORITY ) | portPRIVILEGE_BIT, &xTimerTaskHandle );
215:                 		}
216:                 		#else
217:                 		{
218:                 			/* Create the timer task without storing its handle. */
219:                 			xReturn = xTaskCreate( prvTimerTask, ( const signed char * ) "Tmr Svc", ( unsigned short ) configTIMER_TASK_STACK_DEPTH, NULL, ( ( unsigned portBASE_TYPE ) configTIMER_TASK_PRIORITY ) | portPRIVILEGE_BIT, NULL);
9D02BF04  24020002   ADDIU V0, ZERO, 2
9D02BF08  AFA20010   SW V0, 16(SP)
9D02BF0C  AFA00014   SW ZERO, 20(SP)
9D02BF10  AFA00018   SW ZERO, 24(SP)
9D02BF14  AFA0001C   SW ZERO, 28(SP)
9D02BF18  3C029D03   LUI V0, -25341
9D02BF1C  2444C258   ADDIU A0, V0, -15784
9D02BF20  3C029D03   LUI V0, -25341
9D02BF24  24456174   ADDIU A1, V0, 24948
9D02BF28  2406017C   ADDIU A2, ZERO, 380
9D02BF2C  00003821   ADDU A3, ZERO, ZERO
9D02BF30  0F407AA6   JAL xTaskGenericCreate
9D02BF34  00000000   NOP
9D02BF38  AFC20020   SW V0, 32(S8)
220:                 		}
221:                 		#endif
222:                 	}
223:                 
224:                 	configASSERT( xReturn );
9D02BF3C  8FC20020   LW V0, 32(S8)
9D02BF40  14400006   BNE V0, ZERO, 0x9D02BF5C
9D02BF44  00000000   NOP
9D02BF48  3C029D03   LUI V0, -25341
9D02BF4C  2444617C   ADDIU A0, V0, 24956
9D02BF50  240500E0   ADDIU A1, ZERO, 224
9D02BF54  0F40C5F5   JAL vAssertCalled
9D02BF58  00000000   NOP
225:                 	return xReturn;
9D02BF5C  8FC20020   LW V0, 32(S8)
226:                 }
9D02BF60  03C0E821   ADDU SP, S8, ZERO
9D02BF64  8FBF002C   LW RA, 44(SP)
9D02BF68  8FBE0028   LW S8, 40(SP)
9D02BF6C  27BD0030   ADDIU SP, SP, 48
9D02BF70  03E00008   JR RA
9D02BF74  00000000   NOP
227:                 /*-----------------------------------------------------------*/
228:                 
229:                 xTimerHandle xTimerCreate( const signed char * const pcTimerName, portTickType xTimerPeriodInTicks, unsigned portBASE_TYPE uxAutoReload, void *pvTimerID, tmrTIMER_CALLBACK pxCallbackFunction )
230:                 {
9D02BF78  27BDFFE0   ADDIU SP, SP, -32
9D02BF7C  AFBF001C   SW RA, 28(SP)
9D02BF80  AFBE0018   SW S8, 24(SP)
9D02BF84  03A0F021   ADDU S8, SP, ZERO
9D02BF88  AFC40020   SW A0, 32(S8)
9D02BF8C  AFC50024   SW A1, 36(S8)
9D02BF90  AFC60028   SW A2, 40(S8)
9D02BF94  AFC7002C   SW A3, 44(S8)
231:                 xTIMER *pxNewTimer;
232:                 
233:                 	/* Allocate the timer structure. */
234:                 	if( xTimerPeriodInTicks == ( portTickType ) 0U )
9D02BF98  8FC20024   LW V0, 36(S8)
9D02BF9C  14400004   BNE V0, ZERO, 0x9D02BFB0
9D02BFA0  00000000   NOP
235:                 	{
236:                 		pxNewTimer = NULL;
9D02BFA4  AFC00010   SW ZERO, 16(S8)
9D02BFA8  0B40B009   J 0x9D02C024
9D02BFAC  00000000   NOP
237:                 	}
238:                 	else
239:                 	{
240:                 		pxNewTimer = ( xTIMER * ) pvPortMalloc( sizeof( xTIMER ) );
9D02BFB0  24040028   ADDIU A0, ZERO, 40
9D02BFB4  0F40D1D2   JAL pvPortMalloc
9D02BFB8  00000000   NOP
9D02BFBC  AFC20010   SW V0, 16(S8)
241:                 		if( pxNewTimer != NULL )
9D02BFC0  8FC20010   LW V0, 16(S8)
9D02BFC4  10400017   BEQ V0, ZERO, 0x9D02C024
9D02BFC8  00000000   NOP
242:                 		{
243:                 			/* Ensure the infrastructure used by the timer service task has been
244:                 			created/initialised. */
245:                 			prvCheckForValidListAndQueue();
9D02BFCC  0F40B250   JAL 0x9D02C940
9D02BFD0  00000000   NOP
246:                 
247:                 			/* Initialise the timer structure members using the function parameters. */
248:                 			pxNewTimer->pcTimerName = pcTimerName;
9D02BFD4  8FC20010   LW V0, 16(S8)
9D02BFD8  8FC30020   LW V1, 32(S8)
9D02BFDC  AC430000   SW V1, 0(V0)
249:                 			pxNewTimer->xTimerPeriodInTicks = xTimerPeriodInTicks;
9D02BFE0  8FC20010   LW V0, 16(S8)
9D02BFE4  8FC30024   LW V1, 36(S8)
9D02BFE8  AC430018   SW V1, 24(V0)
250:                 			pxNewTimer->uxAutoReload = uxAutoReload;
9D02BFEC  8FC20010   LW V0, 16(S8)
9D02BFF0  8FC30028   LW V1, 40(S8)
9D02BFF4  AC43001C   SW V1, 28(V0)
251:                 			pxNewTimer->pvTimerID = pvTimerID;
9D02BFF8  8FC20010   LW V0, 16(S8)
9D02BFFC  8FC3002C   LW V1, 44(S8)
9D02C000  AC430020   SW V1, 32(V0)
252:                 			pxNewTimer->pxCallbackFunction = pxCallbackFunction;
9D02C004  8FC20010   LW V0, 16(S8)
9D02C008  8FC30030   LW V1, 48(S8)
9D02C00C  AC430024   SW V1, 36(V0)
253:                 			vListInitialiseItem( &( pxNewTimer->xTimerListItem ) );
9D02C010  8FC20010   LW V0, 16(S8)
9D02C014  24420004   ADDIU V0, V0, 4
9D02C018  00402021   ADDU A0, V0, ZERO
9D02C01C  0F40D0C8   JAL vListInitialiseItem
9D02C020  00000000   NOP
254:                 
255:                 			traceTIMER_CREATE( pxNewTimer );
256:                 		}
257:                 		else
258:                 		{
259:                 			traceTIMER_CREATE_FAILED();
260:                 		}
261:                 	}
262:                 
263:                 	/* 0 is not a valid value for xTimerPeriodInTicks. */
264:                 	configASSERT( ( xTimerPeriodInTicks > 0 ) );
9D02C024  8FC20024   LW V0, 36(S8)
9D02C028  14400006   BNE V0, ZERO, 0x9D02C044
9D02C02C  00000000   NOP
9D02C030  3C029D03   LUI V0, -25341
9D02C034  2444617C   ADDIU A0, V0, 24956
9D02C038  24050108   ADDIU A1, ZERO, 264
9D02C03C  0F40C5F5   JAL vAssertCalled
9D02C040  00000000   NOP
265:                 
266:                 	return ( xTimerHandle ) pxNewTimer;
9D02C044  8FC20010   LW V0, 16(S8)
267:                 }
9D02C048  03C0E821   ADDU SP, S8, ZERO
9D02C04C  8FBF001C   LW RA, 28(SP)
9D02C050  8FBE0018   LW S8, 24(SP)
9D02C054  27BD0020   ADDIU SP, SP, 32
9D02C058  03E00008   JR RA
9D02C05C  00000000   NOP
268:                 /*-----------------------------------------------------------*/
269:                 
270:                 portBASE_TYPE xTimerGenericCommand( xTimerHandle xTimer, portBASE_TYPE xCommandID, portTickType xOptionalValue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portTickType xBlockTime )
271:                 {
9D02C060  27BDFFD8   ADDIU SP, SP, -40
9D02C064  AFBF0024   SW RA, 36(SP)
9D02C068  AFBE0020   SW S8, 32(SP)
9D02C06C  03A0F021   ADDU S8, SP, ZERO
9D02C070  AFC40028   SW A0, 40(S8)
9D02C074  AFC5002C   SW A1, 44(S8)
9D02C078  AFC60030   SW A2, 48(S8)
9D02C07C  AFC70034   SW A3, 52(S8)
272:                 portBASE_TYPE xReturn = pdFAIL;
9D02C080  AFC00010   SW ZERO, 16(S8)
273:                 xTIMER_MESSAGE xMessage;
274:                 
275:                 	/* Send a message to the timer service task to perform a particular action
276:                 	on a particular timer definition. */
277:                 	if( xTimerQueue != NULL )
9D02C084  8F8280C4   LW V0, -32572(GP)
9D02C088  1040002F   BEQ V0, ZERO, 0x9D02C148
9D02C08C  00000000   NOP
278:                 	{
279:                 		/* Send a command to the timer service task to start the xTimer timer. */
280:                 		xMessage.xMessageID = xCommandID;
9D02C090  8FC2002C   LW V0, 44(S8)
9D02C094  AFC20014   SW V0, 20(S8)
281:                 		xMessage.xMessageValue = xOptionalValue;
9D02C098  8FC20030   LW V0, 48(S8)
9D02C09C  AFC20018   SW V0, 24(S8)
282:                 		xMessage.pxTimer = ( xTIMER * ) xTimer;
9D02C0A0  8FC20028   LW V0, 40(S8)
9D02C0A4  AFC2001C   SW V0, 28(S8)
283:                 
284:                 		if( pxHigherPriorityTaskWoken == NULL )
9D02C0A8  8FC20034   LW V0, 52(S8)
9D02C0AC  1440001D   BNE V0, ZERO, 0x9D02C124
9D02C0B0  00000000   NOP
285:                 		{
286:                 			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
9D02C0B4  0F408282   JAL xTaskGetSchedulerState
9D02C0B8  00000000   NOP
9D02C0BC  00401821   ADDU V1, V0, ZERO
9D02C0C0  24020001   ADDIU V0, ZERO, 1
9D02C0C4  1462000C   BNE V1, V0, 0x9D02C0F8
9D02C0C8  00000000   NOP
287:                 			{
288:                 				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xBlockTime );
9D02C0CC  8F8380C4   LW V1, -32572(GP)
9D02C0D0  27C20014   ADDIU V0, S8, 20
9D02C0D4  00602021   ADDU A0, V1, ZERO
9D02C0D8  00402821   ADDU A1, V0, ZERO
9D02C0DC  8FC60038   LW A2, 56(S8)
9D02C0E0  00003821   ADDU A3, ZERO, ZERO
9D02C0E4  0F4084FB   JAL xQueueGenericSend
9D02C0E8  00000000   NOP
9D02C0EC  AFC20010   SW V0, 16(S8)
9D02C0F0  0B40B052   J 0x9D02C148
9D02C0F4  00000000   NOP
289:                 			}
290:                 			else
291:                 			{
292:                 				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
9D02C0F8  8F8380C4   LW V1, -32572(GP)
9D02C0FC  27C20014   ADDIU V0, S8, 20
9D02C100  00602021   ADDU A0, V1, ZERO
9D02C104  00402821   ADDU A1, V0, ZERO
9D02C108  00003021   ADDU A2, ZERO, ZERO
9D02C10C  00003821   ADDU A3, ZERO, ZERO
9D02C110  0F4084FB   JAL xQueueGenericSend
9D02C114  00000000   NOP
9D02C118  AFC20010   SW V0, 16(S8)
9D02C11C  0B40B052   J 0x9D02C148
9D02C120  00000000   NOP
293:                 			}
294:                 		}
295:                 		else
296:                 		{
297:                 			xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
9D02C124  8F8380C4   LW V1, -32572(GP)
9D02C128  27C20014   ADDIU V0, S8, 20
9D02C12C  00602021   ADDU A0, V1, ZERO
9D02C130  00402821   ADDU A1, V0, ZERO
9D02C134  8FC60034   LW A2, 52(S8)
9D02C138  00003821   ADDU A3, ZERO, ZERO
9D02C13C  0F4085C2   JAL xQueueGenericSendFromISR
9D02C140  00000000   NOP
9D02C144  AFC20010   SW V0, 16(S8)
298:                 		}
299:                 
300:                 		traceTIMER_COMMAND_SEND( xTimer, xCommandID, xOptionalValue, xReturn );
301:                 	}
302:                 
303:                 	return xReturn;
9D02C148  8FC20010   LW V0, 16(S8)
304:                 }
9D02C14C  03C0E821   ADDU SP, S8, ZERO
9D02C150  8FBF0024   LW RA, 36(SP)
9D02C154  8FBE0020   LW S8, 32(SP)
9D02C158  27BD0028   ADDIU SP, SP, 40
9D02C15C  03E00008   JR RA
9D02C160  00000000   NOP
305:                 /*-----------------------------------------------------------*/
306:                 
307:                 #if ( INCLUDE_xTimerGetTimerDaemonTaskHandle == 1 )
308:                 
309:                 	xTaskHandle xTimerGetTimerDaemonTaskHandle( void )
310:                 	{
311:                 		/* If xTimerGetTimerDaemonTaskHandle() is called before the scheduler has been
312:                 		started, then xTimerTaskHandle will be NULL. */
313:                 		configASSERT( ( xTimerTaskHandle != NULL ) );
314:                 		return xTimerTaskHandle;
315:                 	}
316:                 
317:                 #endif
318:                 /*-----------------------------------------------------------*/
319:                 
320:                 static void prvProcessExpiredTimer( portTickType xNextExpireTime, portTickType xTimeNow )
321:                 {
9D02C164  27BDFFD8   ADDIU SP, SP, -40
9D02C168  AFBF0024   SW RA, 36(SP)
9D02C16C  AFBE0020   SW S8, 32(SP)
9D02C170  03A0F021   ADDU S8, SP, ZERO
9D02C174  AFC40028   SW A0, 40(S8)
9D02C178  AFC5002C   SW A1, 44(S8)
322:                 xTIMER *pxTimer;
323:                 portBASE_TYPE xResult;
324:                 
325:                 	/* Remove the timer from the list of active timers.  A check has already
326:                 	been performed to ensure the list is not empty. */
327:                 	pxTimer = ( xTIMER * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
9D02C17C  8F8280BC   LW V0, -32580(GP)
9D02C180  8C42000C   LW V0, 12(V0)
9D02C184  8C42000C   LW V0, 12(V0)
9D02C188  AFC20018   SW V0, 24(S8)
328:                 	( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
9D02C18C  8FC20018   LW V0, 24(S8)
9D02C190  24420004   ADDIU V0, V0, 4
9D02C194  00402021   ADDU A0, V0, ZERO
9D02C198  0F40D131   JAL uxListRemove
9D02C19C  00000000   NOP
329:                 	traceTIMER_EXPIRED( pxTimer );
330:                 
331:                 	/* If the timer is an auto reload timer then calculate the next
332:                 	expiry time and re-insert the timer in the list of active timers. */
333:                 	if( pxTimer->uxAutoReload == ( unsigned portBASE_TYPE ) pdTRUE )
9D02C1A0  8FC20018   LW V0, 24(S8)
9D02C1A4  8C43001C   LW V1, 28(V0)
9D02C1A8  24020001   ADDIU V0, ZERO, 1
9D02C1AC  1462001F   BNE V1, V0, 0x9D02C22C
9D02C1B0  00000000   NOP
334:                 	{
335:                 		/* This is the only time a timer is inserted into a list using
336:                 		a time relative to anything other than the current time.  It
337:                 		will therefore be inserted into the correct list relative to
338:                 		the time this task thinks it is now, even if a command to
339:                 		switch lists due to a tick count overflow is already waiting in
340:                 		the timer queue. */
341:                 		if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) == pdTRUE )
9D02C1B4  8FC20018   LW V0, 24(S8)
9D02C1B8  8C430018   LW V1, 24(V0)
9D02C1BC  8FC20028   LW V0, 40(S8)
9D02C1C0  00621021   ADDU V0, V1, V0
9D02C1C4  8FC40018   LW A0, 24(S8)
9D02C1C8  00402821   ADDU A1, V0, ZERO
9D02C1CC  8FC6002C   LW A2, 44(S8)
9D02C1D0  8FC70028   LW A3, 40(S8)
9D02C1D4  0F40B125   JAL 0x9D02C494
9D02C1D8  00000000   NOP
9D02C1DC  00401821   ADDU V1, V0, ZERO
9D02C1E0  24020001   ADDIU V0, ZERO, 1
9D02C1E4  14620011   BNE V1, V0, 0x9D02C22C
9D02C1E8  00000000   NOP
342:                 		{
343:                 			/* The timer expired before it was added to the active timer
344:                 			list.  Reload it now.  */
345:                 			xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START, xNextExpireTime, NULL, tmrNO_DELAY );
9D02C1EC  AFA00010   SW ZERO, 16(SP)
9D02C1F0  8FC40018   LW A0, 24(S8)
9D02C1F4  00002821   ADDU A1, ZERO, ZERO
9D02C1F8  8FC60028   LW A2, 40(S8)
9D02C1FC  00003821   ADDU A3, ZERO, ZERO
9D02C200  0F40B018   JAL xTimerGenericCommand
9D02C204  00000000   NOP
9D02C208  AFC2001C   SW V0, 28(S8)
346:                 			configASSERT( xResult );
9D02C20C  8FC2001C   LW V0, 28(S8)
9D02C210  14400006   BNE V0, ZERO, 0x9D02C22C
9D02C214  00000000   NOP
9D02C218  3C029D03   LUI V0, -25341
9D02C21C  2444617C   ADDIU A0, V0, 24956
9D02C220  2405015A   ADDIU A1, ZERO, 346
9D02C224  0F40C5F5   JAL vAssertCalled
9D02C228  00000000   NOP
347:                 			( void ) xResult;
348:                 		}
349:                 	}
350:                 
351:                 	/* Call the timer callback. */
352:                 	pxTimer->pxCallbackFunction( ( xTimerHandle ) pxTimer );
9D02C22C  8FC20018   LW V0, 24(S8)
9D02C230  8C420024   LW V0, 36(V0)
9D02C234  8FC40018   LW A0, 24(S8)
9D02C238  0040F809   JALR V0
9D02C23C  00000000   NOP
353:                 }
9D02C240  03C0E821   ADDU SP, S8, ZERO
9D02C244  8FBF0024   LW RA, 36(SP)
9D02C248  8FBE0020   LW S8, 32(SP)
9D02C24C  27BD0028   ADDIU SP, SP, 40
9D02C250  03E00008   JR RA
9D02C254  00000000   NOP
354:                 /*-----------------------------------------------------------*/
355:                 
356:                 static void prvTimerTask( void *pvParameters )
357:                 {
9D02C258  27BDFFE0   ADDIU SP, SP, -32
9D02C25C  AFBF001C   SW RA, 28(SP)
9D02C260  AFBE0018   SW S8, 24(SP)
9D02C264  03A0F021   ADDU S8, SP, ZERO
9D02C268  AFC40020   SW A0, 32(S8)
358:                 portTickType xNextExpireTime;
359:                 portBASE_TYPE xListWasEmpty;
360:                 
361:                 	/* Just to avoid compiler warnings. */
362:                 	( void ) pvParameters;
363:                 
364:                 	for( ;; )
365:                 	{
366:                 		/* Query the timers list to see if it contains any timers, and if so,
367:                 		obtain the time at which the next timer will expire. */
368:                 		xNextExpireTime = prvGetNextExpireTime( &xListWasEmpty );
9D02C26C  27C20014   ADDIU V0, S8, 20
9D02C270  00402021   ADDU A0, V0, ZERO
9D02C274  0F40B0EA   JAL 0x9D02C3A8
9D02C278  00000000   NOP
9D02C27C  AFC20010   SW V0, 16(S8)
369:                 
370:                 		/* If a timer has expired, process it.  Otherwise, block this task
371:                 		until either a timer does expire, or a command is received. */
372:                 		prvProcessTimerOrBlockTask( xNextExpireTime, xListWasEmpty );
9D02C280  8FC20014   LW V0, 20(S8)
9D02C284  8FC40010   LW A0, 16(S8)
9D02C288  00402821   ADDU A1, V0, ZERO
9D02C28C  0F40B0A9   JAL 0x9D02C2A4
9D02C290  00000000   NOP
373:                 
374:                 		/* Empty the command queue. */
375:                 		prvProcessReceivedCommands();
9D02C294  0F40B16A   JAL 0x9D02C5A8
9D02C298  00000000   NOP
376:                 	}
9D02C29C  0B40B09B   J 0x9D02C26C
9D02C2A0  00000000   NOP
377:                 }
378:                 /*-----------------------------------------------------------*/
379:                 
380:                 static void prvProcessTimerOrBlockTask( portTickType xNextExpireTime, portBASE_TYPE xListWasEmpty )
381:                 {
9D02C2A4  27BDFFD8   ADDIU SP, SP, -40
9D02C2A8  AFBF0024   SW RA, 36(SP)
9D02C2AC  AFBE0020   SW S8, 32(SP)
9D02C2B0  03A0F021   ADDU S8, SP, ZERO
9D02C2B4  AFC40028   SW A0, 40(S8)
9D02C2B8  AFC5002C   SW A1, 44(S8)
382:                 portTickType xTimeNow;
383:                 portBASE_TYPE xTimerListsWereSwitched;
384:                 
385:                 	vTaskSuspendAll();
9D02C2BC  0F407E3F   JAL vTaskSuspendAll
9D02C2C0  00000000   NOP
386:                 	{
387:                 		/* Obtain the time now to make an assessment as to whether the timer
388:                 		has expired or not.  If obtaining the time causes the lists to switch
389:                 		then don't process this timer as any timers that remained in the list
390:                 		when the lists were switched will have been processed within the
391:                 		prvSampelTimeNow() function. */
392:                 		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
9D02C2C4  27C20018   ADDIU V0, S8, 24
9D02C2C8  00402021   ADDU A0, V0, ZERO
9D02C2CC  0F40B104   JAL 0x9D02C410
9D02C2D0  00000000   NOP
9D02C2D4  AFC20010   SW V0, 16(S8)
393:                 		if( xTimerListsWereSwitched == pdFALSE )
9D02C2D8  8FC20018   LW V0, 24(S8)
9D02C2DC  14400027   BNE V0, ZERO, 0x9D02C37C
9D02C2E0  00000000   NOP
394:                 		{
395:                 			/* The tick count has not overflowed, has the timer expired? */
396:                 			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
9D02C2E4  8FC2002C   LW V0, 44(S8)
9D02C2E8  1440000E   BNE V0, ZERO, 0x9D02C324
9D02C2EC  00000000   NOP
9D02C2F0  8FC30028   LW V1, 40(S8)
9D02C2F4  8FC20010   LW V0, 16(S8)
9D02C2F8  0043102B   SLTU V0, V0, V1
9D02C2FC  14400009   BNE V0, ZERO, 0x9D02C324
9D02C300  00000000   NOP
397:                 			{
398:                 				( void ) xTaskResumeAll();
9D02C304  0F407E4A   JAL xTaskResumeAll
9D02C308  00000000   NOP
399:                 				prvProcessExpiredTimer( xNextExpireTime, xTimeNow );
9D02C30C  8FC40028   LW A0, 40(S8)
9D02C310  8FC50010   LW A1, 16(S8)
9D02C314  0F40B059   JAL 0x9D02C164
9D02C318  00000000   NOP
9D02C31C  0B40B0E4   J 0x9D02C390
9D02C320  00000000   NOP
400:                 			}
401:                 			else
402:                 			{
403:                 				/* The tick count has not overflowed, and the next expire
404:                 				time has not been reached yet.  This task should therefore
405:                 				block to wait for the next expire time or a command to be
406:                 				received - whichever comes first.  The following line cannot
407:                 				be reached unless xNextExpireTime > xTimeNow, except in the
408:                 				case when the current timer list is empty. */
409:                 				vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ) );
9D02C324  8F8380C4   LW V1, -32572(GP)
9D02C328  8FC40028   LW A0, 40(S8)
9D02C32C  8FC20010   LW V0, 16(S8)
9D02C330  00821023   SUBU V0, A0, V0
9D02C334  00602021   ADDU A0, V1, ZERO
9D02C338  00402821   ADDU A1, V0, ZERO
9D02C33C  0F4089A8   JAL vQueueWaitForMessageRestricted
9D02C340  00000000   NOP
410:                 
411:                 				if( xTaskResumeAll() == pdFALSE )
9D02C344  0F407E4A   JAL xTaskResumeAll
9D02C348  00000000   NOP
9D02C34C  1440000F   BNE V0, ZERO, 0x9D02C38C
9D02C350  00000000   NOP
412:                 				{
413:                 					/* Yield to wait for either a command to arrive, or the block time
414:                 					to expire.  If a command arrived between the critical section being
415:                 					exited and this yield then the yield will not cause the task
416:                 					to block. */
417:                 					portYIELD_WITHIN_API();
9D02C354  40026800   MFC0 V0, Cause
9D02C358  AFC20014   SW V0, 20(S8)
9D02C35C  8FC20014   LW V0, 20(S8)
9D02C360  34420100   ORI V0, V0, 256
9D02C364  AFC20014   SW V0, 20(S8)
9D02C368  8FC20014   LW V0, 20(S8)
9D02C36C  40826800   MTC0 V0, Cause
9D02C370  000000C0   EHB
9D02C374  0B40B0E4   J 0x9D02C390
9D02C378  00000000   NOP
9D02C38C  00000000   NOP
418:                 				}
419:                 			}
420:                 		}
421:                 		else
422:                 		{
423:                 			( void ) xTaskResumeAll();
9D02C37C  0F407E4A   JAL xTaskResumeAll
9D02C380  00000000   NOP
9D02C384  0B40B0E4   J 0x9D02C390
9D02C388  00000000   NOP
424:                 		}
425:                 	}
426:                 }
9D02C390  03C0E821   ADDU SP, S8, ZERO
9D02C394  8FBF0024   LW RA, 36(SP)
9D02C398  8FBE0020   LW S8, 32(SP)
9D02C39C  27BD0028   ADDIU SP, SP, 40
9D02C3A0  03E00008   JR RA
9D02C3A4  00000000   NOP
427:                 /*-----------------------------------------------------------*/
428:                 
429:                 static portTickType prvGetNextExpireTime( portBASE_TYPE *pxListWasEmpty )
430:                 {
9D02C3A8  27BDFFF0   ADDIU SP, SP, -16
9D02C3AC  AFBE000C   SW S8, 12(SP)
9D02C3B0  03A0F021   ADDU S8, SP, ZERO
9D02C3B4  AFC40010   SW A0, 16(S8)
431:                 portTickType xNextExpireTime;
432:                 
433:                 	/* Timers are listed in expiry time order, with the head of the list
434:                 	referencing the task that will expire first.  Obtain the time at which
435:                 	the timer with the nearest expiry time will expire.  If there are no
436:                 	active timers then just set the next expire time to 0.  That will cause
437:                 	this task to unblock when the tick count overflows, at which point the
438:                 	timer lists will be switched and the next expiry time can be
439:                 	re-assessed.  */
440:                 	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
9D02C3B8  8F8280BC   LW V0, -32580(GP)
9D02C3BC  8C420000   LW V0, 0(V0)
9D02C3C0  2C430001   SLTIU V1, V0, 1
9D02C3C4  8FC20010   LW V0, 16(S8)
9D02C3C8  AC430000   SW V1, 0(V0)
441:                 	if( *pxListWasEmpty == pdFALSE )
9D02C3CC  8FC20010   LW V0, 16(S8)
9D02C3D0  8C420000   LW V0, 0(V0)
9D02C3D4  14400007   BNE V0, ZERO, 0x9D02C3F4
9D02C3D8  00000000   NOP
442:                 	{
443:                 		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
9D02C3DC  8F8280BC   LW V0, -32580(GP)
9D02C3E0  8C42000C   LW V0, 12(V0)
9D02C3E4  8C420000   LW V0, 0(V0)
9D02C3E8  AFC20000   SW V0, 0(S8)
9D02C3EC  0B40B0FE   J 0x9D02C3F8
9D02C3F0  00000000   NOP
444:                 	}
445:                 	else
446:                 	{
447:                 		/* Ensure the task unblocks when the tick count rolls over. */
448:                 		xNextExpireTime = ( portTickType ) 0U;
9D02C3F4  AFC00000   SW ZERO, 0(S8)
449:                 	}
450:                 
451:                 	return xNextExpireTime;
9D02C3F8  8FC20000   LW V0, 0(S8)
452:                 }
9D02C3FC  03C0E821   ADDU SP, S8, ZERO
9D02C400  8FBE000C   LW S8, 12(SP)
9D02C404  27BD0010   ADDIU SP, SP, 16
9D02C408  03E00008   JR RA
9D02C40C  00000000   NOP
453:                 /*-----------------------------------------------------------*/
454:                 
455:                 static portTickType prvSampleTimeNow( portBASE_TYPE *pxTimerListsWereSwitched )
456:                 {
9D02C410  27BDFFE0   ADDIU SP, SP, -32
9D02C414  AFBF001C   SW RA, 28(SP)
9D02C418  AFBE0018   SW S8, 24(SP)
9D02C41C  03A0F021   ADDU S8, SP, ZERO
9D02C420  AFC40020   SW A0, 32(S8)
457:                 portTickType xTimeNow;
458:                 PRIVILEGED_DATA static portTickType xLastTime = ( portTickType ) 0U; /*lint !e956 Variable is only accessible to one task. */
459:                 
460:                 	xTimeNow = xTaskGetTickCount();
9D02C424  0F407EBC   JAL xTaskGetTickCount
9D02C428  00000000   NOP
9D02C42C  AFC20010   SW V0, 16(S8)
461:                 
462:                 	if( xTimeNow < xLastTime )
9D02C430  8F8280C8   LW V0, -32568(GP)
9D02C434  8FC30010   LW V1, 16(S8)
9D02C438  0062102B   SLTU V0, V1, V0
9D02C43C  1040000A   BEQ V0, ZERO, 0x9D02C468
9D02C440  00000000   NOP
463:                 	{
464:                 		prvSwitchTimerLists( xLastTime );
9D02C444  8F8280C8   LW V0, -32568(GP)
9D02C448  00402021   ADDU A0, V0, ZERO
9D02C44C  0F40B1F9   JAL 0x9D02C7E4
9D02C450  00000000   NOP
465:                 		*pxTimerListsWereSwitched = pdTRUE;
9D02C454  8FC20020   LW V0, 32(S8)
9D02C458  24030001   ADDIU V1, ZERO, 1
9D02C45C  AC430000   SW V1, 0(V0)
9D02C460  0B40B11C   J 0x9D02C470
9D02C464  00000000   NOP
466:                 	}
467:                 	else
468:                 	{
469:                 		*pxTimerListsWereSwitched = pdFALSE;
9D02C468  8FC20020   LW V0, 32(S8)
9D02C46C  AC400000   SW ZERO, 0(V0)
470:                 	}
471:                 
472:                 	xLastTime = xTimeNow;
9D02C470  8FC20010   LW V0, 16(S8)
9D02C474  AF8280C8   SW V0, -32568(GP)
473:                 
474:                 	return xTimeNow;
9D02C478  8FC20010   LW V0, 16(S8)
475:                 }
9D02C47C  03C0E821   ADDU SP, S8, ZERO
9D02C480  8FBF001C   LW RA, 28(SP)
9D02C484  8FBE0018   LW S8, 24(SP)
9D02C488  27BD0020   ADDIU SP, SP, 32
9D02C48C  03E00008   JR RA
9D02C490  00000000   NOP
476:                 /*-----------------------------------------------------------*/
477:                 
478:                 static portBASE_TYPE prvInsertTimerInActiveList( xTIMER *pxTimer, portTickType xNextExpiryTime, portTickType xTimeNow, portTickType xCommandTime )
479:                 {
9D02C494  27BDFFE0   ADDIU SP, SP, -32
9D02C498  AFBF001C   SW RA, 28(SP)
9D02C49C  AFBE0018   SW S8, 24(SP)
9D02C4A0  03A0F021   ADDU S8, SP, ZERO
9D02C4A4  AFC40020   SW A0, 32(S8)
9D02C4A8  AFC50024   SW A1, 36(S8)
9D02C4AC  AFC60028   SW A2, 40(S8)
9D02C4B0  AFC7002C   SW A3, 44(S8)
480:                 portBASE_TYPE xProcessTimerNow = pdFALSE;
9D02C4B4  AFC00010   SW ZERO, 16(S8)
481:                 
482:                 	listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
9D02C4B8  8FC20020   LW V0, 32(S8)
9D02C4BC  8FC30024   LW V1, 36(S8)
9D02C4C0  AC430004   SW V1, 4(V0)
483:                 	listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
9D02C4C4  8FC20020   LW V0, 32(S8)
9D02C4C8  8FC30020   LW V1, 32(S8)
9D02C4CC  AC430010   SW V1, 16(V0)
484:                 
485:                 	if( xNextExpiryTime <= xTimeNow )
9D02C4D0  8FC30024   LW V1, 36(S8)
9D02C4D4  8FC20028   LW V0, 40(S8)
9D02C4D8  0043102B   SLTU V0, V0, V1
9D02C4DC  14400016   BNE V0, ZERO, 0x9D02C538
9D02C4E0  00000000   NOP
486:                 	{
487:                 		/* Has the expiry time elapsed between the command to start/reset a
488:                 		timer was issued, and the time the command was processed? */
489:                 		if( ( xTimeNow - xCommandTime ) >= pxTimer->xTimerPeriodInTicks )
9D02C4E4  8FC30028   LW V1, 40(S8)
9D02C4E8  8FC2002C   LW V0, 44(S8)
9D02C4EC  00621823   SUBU V1, V1, V0
9D02C4F0  8FC20020   LW V0, 32(S8)
9D02C4F4  8C420018   LW V0, 24(V0)
9D02C4F8  0062102B   SLTU V0, V1, V0
9D02C4FC  14400005   BNE V0, ZERO, 0x9D02C514
9D02C500  00000000   NOP
490:                 		{
491:                 			/* The time between a command being issued and the command being
492:                 			processed actually exceeds the timers period.  */
493:                 			xProcessTimerNow = pdTRUE;
9D02C504  24020001   ADDIU V0, ZERO, 1
9D02C508  AFC20010   SW V0, 16(S8)
9D02C50C  0B40B163   J 0x9D02C58C
9D02C510  00000000   NOP
494:                 		}
495:                 		else
496:                 		{
497:                 			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
9D02C514  8F8380C0   LW V1, -32576(GP)
9D02C518  8FC20020   LW V0, 32(S8)
9D02C51C  24420004   ADDIU V0, V0, 4
9D02C520  00602021   ADDU A0, V1, ZERO
9D02C524  00402821   ADDU A1, V0, ZERO
9D02C528  0F40D0F6   JAL vListInsert
9D02C52C  00000000   NOP
9D02C530  0B40B163   J 0x9D02C58C
9D02C534  00000000   NOP
498:                 		}
499:                 	}
500:                 	else
501:                 	{
502:                 		if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
9D02C538  8FC30028   LW V1, 40(S8)
9D02C53C  8FC2002C   LW V0, 44(S8)
9D02C540  0062102B   SLTU V0, V1, V0
9D02C544  1040000A   BEQ V0, ZERO, 0x9D02C570
9D02C548  00000000   NOP
9D02C54C  8FC30024   LW V1, 36(S8)
9D02C550  8FC2002C   LW V0, 44(S8)
9D02C554  0062102B   SLTU V0, V1, V0
9D02C558  14400005   BNE V0, ZERO, 0x9D02C570
9D02C55C  00000000   NOP
503:                 		{
504:                 			/* If, since the command was issued, the tick count has overflowed
505:                 			but the expiry time has not, then the timer must have already passed
506:                 			its expiry time and should be processed immediately. */
507:                 			xProcessTimerNow = pdTRUE;
9D02C560  24020001   ADDIU V0, ZERO, 1
9D02C564  AFC20010   SW V0, 16(S8)
9D02C568  0B40B163   J 0x9D02C58C
9D02C56C  00000000   NOP
508:                 		}
509:                 		else
510:                 		{
511:                 			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
9D02C570  8F8380BC   LW V1, -32580(GP)
9D02C574  8FC20020   LW V0, 32(S8)
9D02C578  24420004   ADDIU V0, V0, 4
9D02C57C  00602021   ADDU A0, V1, ZERO
9D02C580  00402821   ADDU A1, V0, ZERO
9D02C584  0F40D0F6   JAL vListInsert
9D02C588  00000000   NOP
512:                 		}
513:                 	}
514:                 
515:                 	return xProcessTimerNow;
9D02C58C  8FC20010   LW V0, 16(S8)
516:                 }
9D02C590  03C0E821   ADDU SP, S8, ZERO
9D02C594  8FBF001C   LW RA, 28(SP)
9D02C598  8FBE0018   LW S8, 24(SP)
9D02C59C  27BD0020   ADDIU SP, SP, 32
9D02C5A0  03E00008   JR RA
9D02C5A4  00000000   NOP
517:                 /*-----------------------------------------------------------*/
518:                 
519:                 static void	prvProcessReceivedCommands( void )
520:                 {
9D02C5A8  27BDFFC0   ADDIU SP, SP, -64
9D02C5AC  AFBF003C   SW RA, 60(SP)
9D02C5B0  AFBE0038   SW S8, 56(SP)
9D02C5B4  03A0F021   ADDU S8, SP, ZERO
521:                 xTIMER_MESSAGE xMessage;
522:                 xTIMER *pxTimer;
523:                 portBASE_TYPE xTimerListsWereSwitched, xResult;
524:                 portTickType xTimeNow;
525:                 
526:                 	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
9D02C5B8  0B40B1E9   J 0x9D02C7A4
9D02C5BC  00000000   NOP
9D02C7A4  8F8380C4   LW V1, -32572(GP)
9D02C7A8  27C20024   ADDIU V0, S8, 36
9D02C7AC  00602021   ADDU A0, V1, ZERO
9D02C7B0  00402821   ADDU A1, V0, ZERO
9D02C7B4  00003021   ADDU A2, ZERO, ZERO
9D02C7B8  00003821   ADDU A3, ZERO, ZERO
9D02C7BC  0F408644   JAL xQueueGenericReceive
9D02C7C0  00000000   NOP
9D02C7C4  1440FF7E   BNE V0, ZERO, 0x9D02C5C0
9D02C7C8  00000000   NOP
527:                 	{
528:                 		pxTimer = xMessage.pxTimer;
9D02C5C0  8FC2002C   LW V0, 44(S8)
9D02C5C4  AFC20018   SW V0, 24(S8)
529:                 
530:                 		if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE )
9D02C5C8  8FC20018   LW V0, 24(S8)
9D02C5CC  8C420014   LW V0, 20(V0)
9D02C5D0  10400006   BEQ V0, ZERO, 0x9D02C5EC
9D02C5D4  00000000   NOP
531:                 		{
532:                 			/* The timer is in a list, remove it. */
533:                 			( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
9D02C5D8  8FC20018   LW V0, 24(S8)
9D02C5DC  24420004   ADDIU V0, V0, 4
9D02C5E0  00402021   ADDU A0, V0, ZERO
9D02C5E4  0F40D131   JAL uxListRemove
9D02C5E8  00000000   NOP
534:                 		}
535:                 
536:                 		traceTIMER_COMMAND_RECEIVED( pxTimer, xMessage.xMessageID, xMessage.xMessageValue );
537:                 
538:                 		/* In this case the xTimerListsWereSwitched parameter is not used, but 
539:                 		it must be present in the function call.  prvSampleTimeNow() must be 
540:                 		called after the message is received from xTimerQueue so there is no 
541:                 		possibility of a higher priority task adding a message to the message
542:                 		queue with a time that is ahead of the timer daemon task (because it
543:                 		pre-empted the timer daemon task after the xTimeNow value was set). */
544:                 		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
9D02C5EC  27C20030   ADDIU V0, S8, 48
9D02C5F0  00402021   ADDU A0, V0, ZERO
9D02C5F4  0F40B104   JAL 0x9D02C410
9D02C5F8  00000000   NOP
9D02C5FC  AFC2001C   SW V0, 28(S8)
545:                 
546:                 		switch( xMessage.xMessageID )
9D02C600  8FC20024   LW V0, 36(S8)
9D02C604  24030001   ADDIU V1, ZERO, 1
9D02C608  1043005C   BEQ V0, V1, 0x9D02C77C
9D02C60C  00000000   NOP
9D02C610  28430002   SLTI V1, V0, 2
9D02C614  10600005   BEQ V1, ZERO, 0x9D02C62C
9D02C618  00000000   NOP
9D02C61C  1040000B   BEQ V0, ZERO, 0x9D02C64C
9D02C620  00000000   NOP
9D02C62C  24030002   ADDIU V1, ZERO, 2
9D02C630  10430035   BEQ V0, V1, 0x9D02C708
9D02C634  00000000   NOP
9D02C638  24030003   ADDIU V1, ZERO, 3
9D02C63C  1043004A   BEQ V0, V1, 0x9D02C768
9D02C640  00000000   NOP
547:                 		{
548:                 			case tmrCOMMAND_START :
549:                 				/* Start or restart a timer. */
550:                 				if( prvInsertTimerInActiveList( pxTimer,  xMessage.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.xMessageValue ) == pdTRUE )
9D02C64C  8FC30028   LW V1, 40(S8)
9D02C650  8FC20018   LW V0, 24(S8)
9D02C654  8C420018   LW V0, 24(V0)
9D02C658  00621821   ADDU V1, V1, V0
9D02C65C  8FC20028   LW V0, 40(S8)
9D02C660  8FC40018   LW A0, 24(S8)
9D02C664  00602821   ADDU A1, V1, ZERO
9D02C668  8FC6001C   LW A2, 28(S8)
9D02C66C  00403821   ADDU A3, V0, ZERO
9D02C670  0F40B125   JAL 0x9D02C494
9D02C674  00000000   NOP
9D02C678  00401821   ADDU V1, V0, ZERO
9D02C67C  24020001   ADDIU V0, ZERO, 1
9D02C680  14620041   BNE V1, V0, 0x9D02C788
9D02C684  00000000   NOP
551:                 				{
552:                 					/* The timer expired before it was added to the active timer
553:                 					list.  Process it now. */
554:                 					pxTimer->pxCallbackFunction( ( xTimerHandle ) pxTimer );
9D02C688  8FC20018   LW V0, 24(S8)
9D02C68C  8C420024   LW V0, 36(V0)
9D02C690  8FC40018   LW A0, 24(S8)
9D02C694  0040F809   JALR V0
9D02C698  00000000   NOP
555:                 
556:                 					if( pxTimer->uxAutoReload == ( unsigned portBASE_TYPE ) pdTRUE )
9D02C69C  8FC20018   LW V0, 24(S8)
9D02C6A0  8C43001C   LW V1, 28(V0)
9D02C6A4  24020001   ADDIU V0, ZERO, 1
9D02C6A8  1462003A   BNE V1, V0, 0x9D02C794
9D02C6AC  00000000   NOP
557:                 					{
558:                 						xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START, xMessage.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
9D02C6B0  8FC30028   LW V1, 40(S8)
9D02C6B4  8FC20018   LW V0, 24(S8)
9D02C6B8  8C420018   LW V0, 24(V0)
9D02C6BC  00621021   ADDU V0, V1, V0
9D02C6C0  AFA00010   SW ZERO, 16(SP)
9D02C6C4  8FC40018   LW A0, 24(S8)
9D02C6C8  00002821   ADDU A1, ZERO, ZERO
9D02C6CC  00403021   ADDU A2, V0, ZERO
9D02C6D0  00003821   ADDU A3, ZERO, ZERO
9D02C6D4  0F40B018   JAL xTimerGenericCommand
9D02C6D8  00000000   NOP
9D02C6DC  AFC20020   SW V0, 32(S8)
559:                 						configASSERT( xResult );
9D02C6E0  8FC20020   LW V0, 32(S8)
9D02C6E4  1440002E   BNE V0, ZERO, 0x9D02C7A0
9D02C6E8  00000000   NOP
9D02C6EC  3C029D03   LUI V0, -25341
9D02C6F0  2444617C   ADDIU A0, V0, 24956
9D02C6F4  2405022F   ADDIU A1, ZERO, 559
9D02C6F8  0F40C5F5   JAL vAssertCalled
9D02C6FC  00000000   NOP
560:                 						( void ) xResult;
561:                 					}
562:                 				}
563:                 				break;
9D02C700  0B40B1E9   J 0x9D02C7A4
9D02C704  00000000   NOP
9D02C788  00000000   NOP
9D02C78C  0B40B1E9   J 0x9D02C7A4
9D02C790  00000000   NOP
9D02C794  00000000   NOP
9D02C798  0B40B1E9   J 0x9D02C7A4
9D02C79C  00000000   NOP
9D02C7A0  00000000   NOP
564:                 
565:                 			case tmrCOMMAND_STOP :
566:                 				/* The timer has already been removed from the active list.
567:                 				There is nothing to do here. */
568:                 				break;
9D02C77C  00000000   NOP
9D02C780  0B40B1E9   J 0x9D02C7A4
9D02C784  00000000   NOP
569:                 
570:                 			case tmrCOMMAND_CHANGE_PERIOD :
571:                 				pxTimer->xTimerPeriodInTicks = xMessage.xMessageValue;
9D02C708  8FC30028   LW V1, 40(S8)
9D02C70C  8FC20018   LW V0, 24(S8)
9D02C710  AC430018   SW V1, 24(V0)
572:                 				configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
9D02C714  8FC20018   LW V0, 24(S8)
9D02C718  8C420018   LW V0, 24(V0)
9D02C71C  14400006   BNE V0, ZERO, 0x9D02C738
9D02C720  00000000   NOP
9D02C724  3C029D03   LUI V0, -25341
9D02C728  2444617C   ADDIU A0, V0, 24956
9D02C72C  2405023C   ADDIU A1, ZERO, 572
9D02C730  0F40C5F5   JAL vAssertCalled
9D02C734  00000000   NOP
573:                 
574:                 				/* The new period does not really have a reference, and can be
575:                 				longer or shorter than the old one.  The command time is 
576:                 				therefore set to the current time, and as the period cannot be
577:                 				zero the next expiry time can only be in the future, meaning
578:                 				(unlike for the xTimerStart() case above) there is no fail case
579:                 				that needs to be handled here. */
580:                 				( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
9D02C738  8FC20018   LW V0, 24(S8)
9D02C73C  8C430018   LW V1, 24(V0)
9D02C740  8FC2001C   LW V0, 28(S8)
9D02C744  00621021   ADDU V0, V1, V0
9D02C748  8FC40018   LW A0, 24(S8)
9D02C74C  00402821   ADDU A1, V0, ZERO
9D02C750  8FC6001C   LW A2, 28(S8)
9D02C754  8FC7001C   LW A3, 28(S8)
9D02C758  0F40B125   JAL 0x9D02C494
9D02C75C  00000000   NOP
581:                 				break;
9D02C760  0B40B1E9   J 0x9D02C7A4
9D02C764  00000000   NOP
582:                 
583:                 			case tmrCOMMAND_DELETE :
584:                 				/* The timer has already been removed from the active list,
585:                 				just free up the memory. */
586:                 				vPortFree( pxTimer );
9D02C768  8FC40018   LW A0, 24(S8)
9D02C76C  0F40D20E   JAL vPortFree
9D02C770  00000000   NOP
587:                 				break;
9D02C774  0B40B1E9   J 0x9D02C7A4
9D02C778  00000000   NOP
588:                 
589:                 			default	:
590:                 				/* Don't expect to get here. */
591:                 				break;
9D02C624  0B40B1E9   J 0x9D02C7A4
9D02C628  00000000   NOP
9D02C644  0B40B1E9   J 0x9D02C7A4
9D02C648  00000000   NOP
592:                 		}
593:                 	}
594:                 }
9D02C7CC  03C0E821   ADDU SP, S8, ZERO
9D02C7D0  8FBF003C   LW RA, 60(SP)
9D02C7D4  8FBE0038   LW S8, 56(SP)
9D02C7D8  27BD0040   ADDIU SP, SP, 64
9D02C7DC  03E00008   JR RA
9D02C7E0  00000000   NOP
595:                 /*-----------------------------------------------------------*/
596:                 
597:                 static void prvSwitchTimerLists( portTickType xLastTime )
598:                 {
9D02C7E4  27BDFFC8   ADDIU SP, SP, -56
9D02C7E8  AFBF0034   SW RA, 52(SP)
9D02C7EC  AFBE0030   SW S8, 48(SP)
9D02C7F0  03A0F021   ADDU S8, SP, ZERO
9D02C7F4  AFC40038   SW A0, 56(S8)
599:                 portTickType xNextExpireTime, xReloadTime;
600:                 xList *pxTemp;
601:                 xTIMER *pxTimer;
602:                 portBASE_TYPE xResult;
603:                 
604:                 	/* Remove compiler warnings if configASSERT() is not defined. */
605:                 	( void ) xLastTime;
606:                 
607:                 	/* The tick count has overflowed.  The timer lists must be switched.
608:                 	If there are any timers still referenced from the current timer list
609:                 	then they must have expired and should be processed before the lists
610:                 	are switched. */
611:                 	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
9D02C7F8  0B40B240   J 0x9D02C900
9D02C7FC  00000000   NOP
9D02C900  8F8280BC   LW V0, -32580(GP)
9D02C904  8C420000   LW V0, 0(V0)
9D02C908  1440FFBD   BNE V0, ZERO, 0x9D02C800
9D02C90C  00000000   NOP
612:                 	{
613:                 		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
9D02C800  8F8280BC   LW V0, -32580(GP)
9D02C804  8C42000C   LW V0, 12(V0)
9D02C808  8C420000   LW V0, 0(V0)
9D02C80C  AFC20018   SW V0, 24(S8)
614:                 
615:                 		/* Remove the timer from the list. */
616:                 		pxTimer = ( xTIMER * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
9D02C810  8F8280BC   LW V0, -32580(GP)
9D02C814  8C42000C   LW V0, 12(V0)
9D02C818  8C42000C   LW V0, 12(V0)
9D02C81C  AFC2001C   SW V0, 28(S8)
617:                 		( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
9D02C820  8FC2001C   LW V0, 28(S8)
9D02C824  24420004   ADDIU V0, V0, 4
9D02C828  00402021   ADDU A0, V0, ZERO
9D02C82C  0F40D131   JAL uxListRemove
9D02C830  00000000   NOP
618:                 
619:                 		/* Execute its callback, then send a command to restart the timer if
620:                 		it is an auto-reload timer.  It cannot be restarted here as the lists
621:                 		have not yet been switched. */
622:                 		pxTimer->pxCallbackFunction( ( xTimerHandle ) pxTimer );
9D02C834  8FC2001C   LW V0, 28(S8)
9D02C838  8C420024   LW V0, 36(V0)
9D02C83C  8FC4001C   LW A0, 28(S8)
9D02C840  0040F809   JALR V0
9D02C844  00000000   NOP
623:                 
624:                 		if( pxTimer->uxAutoReload == ( unsigned portBASE_TYPE ) pdTRUE )
9D02C848  8FC2001C   LW V0, 28(S8)
9D02C84C  8C43001C   LW V1, 28(V0)
9D02C850  24020001   ADDIU V0, ZERO, 1
9D02C854  1462002A   BNE V1, V0, 0x9D02C900
9D02C858  00000000   NOP
625:                 		{
626:                 			/* Calculate the reload value, and if the reload value results in
627:                 			the timer going into the same timer list then it has already expired
628:                 			and the timer should be re-inserted into the current list so it is
629:                 			processed again within this loop.  Otherwise a command should be sent
630:                 			to restart the timer to ensure it is only inserted into a list after
631:                 			the lists have been swapped. */
632:                 			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
9D02C85C  8FC2001C   LW V0, 28(S8)
9D02C860  8C430018   LW V1, 24(V0)
9D02C864  8FC20018   LW V0, 24(S8)
9D02C868  00621021   ADDU V0, V1, V0
9D02C86C  AFC20020   SW V0, 32(S8)
633:                 			if( xReloadTime > xNextExpireTime )
9D02C870  8FC30020   LW V1, 32(S8)
9D02C874  8FC20018   LW V0, 24(S8)
9D02C878  0043102B   SLTU V0, V0, V1
9D02C87C  10400010   BEQ V0, ZERO, 0x9D02C8C0
9D02C880  00000000   NOP
634:                 			{
635:                 				listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
9D02C884  8FC2001C   LW V0, 28(S8)
9D02C888  8FC30020   LW V1, 32(S8)
9D02C88C  AC430004   SW V1, 4(V0)
636:                 				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
9D02C890  8FC2001C   LW V0, 28(S8)
9D02C894  8FC3001C   LW V1, 28(S8)
9D02C898  AC430010   SW V1, 16(V0)
637:                 				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
9D02C89C  8F8380BC   LW V1, -32580(GP)
9D02C8A0  8FC2001C   LW V0, 28(S8)
9D02C8A4  24420004   ADDIU V0, V0, 4
9D02C8A8  00602021   ADDU A0, V1, ZERO
9D02C8AC  00402821   ADDU A1, V0, ZERO
9D02C8B0  0F40D0F6   JAL vListInsert
9D02C8B4  00000000   NOP
9D02C8B8  0B40B240   J 0x9D02C900
9D02C8BC  00000000   NOP
638:                 			}
639:                 			else
640:                 			{
641:                 				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START, xNextExpireTime, NULL, tmrNO_DELAY );
9D02C8C0  AFA00010   SW ZERO, 16(SP)
9D02C8C4  8FC4001C   LW A0, 28(S8)
9D02C8C8  00002821   ADDU A1, ZERO, ZERO
9D02C8CC  8FC60018   LW A2, 24(S8)
9D02C8D0  00003821   ADDU A3, ZERO, ZERO
9D02C8D4  0F40B018   JAL xTimerGenericCommand
9D02C8D8  00000000   NOP
9D02C8DC  AFC20024   SW V0, 36(S8)
642:                 				configASSERT( xResult );
9D02C8E0  8FC20024   LW V0, 36(S8)
9D02C8E4  14400006   BNE V0, ZERO, 0x9D02C900
9D02C8E8  00000000   NOP
9D02C8EC  3C029D03   LUI V0, -25341
9D02C8F0  2444617C   ADDIU A0, V0, 24956
9D02C8F4  24050282   ADDIU A1, ZERO, 642
9D02C8F8  0F40C5F5   JAL vAssertCalled
9D02C8FC  00000000   NOP
643:                 				( void ) xResult;
644:                 			}
645:                 		}
646:                 	}
647:                 
648:                 	pxTemp = pxCurrentTimerList;
9D02C910  8F8280BC   LW V0, -32580(GP)
9D02C914  AFC20028   SW V0, 40(S8)
649:                 	pxCurrentTimerList = pxOverflowTimerList;
9D02C918  8F8280C0   LW V0, -32576(GP)
9D02C91C  AF8280BC   SW V0, -32580(GP)
650:                 	pxOverflowTimerList = pxTemp;
9D02C920  8FC20028   LW V0, 40(S8)
9D02C924  AF8280C0   SW V0, -32576(GP)
651:                 }
9D02C928  03C0E821   ADDU SP, S8, ZERO
9D02C92C  8FBF0034   LW RA, 52(SP)
9D02C930  8FBE0030   LW S8, 48(SP)
9D02C934  27BD0038   ADDIU SP, SP, 56
9D02C938  03E00008   JR RA
9D02C93C  00000000   NOP
652:                 /*-----------------------------------------------------------*/
653:                 
654:                 static void prvCheckForValidListAndQueue( void )
655:                 {
9D02C940  27BDFFE8   ADDIU SP, SP, -24
9D02C944  AFBF0014   SW RA, 20(SP)
9D02C948  AFBE0010   SW S8, 16(SP)
9D02C94C  03A0F021   ADDU S8, SP, ZERO
656:                 	/* Check that the list from which active timers are referenced, and the
657:                 	queue used to communicate with the timer service, have been
658:                 	initialised. */
659:                 	taskENTER_CRITICAL();
9D02C950  0F40834C   JAL vTaskEnterCritical
9D02C954  00000000   NOP
660:                 	{
661:                 		if( xTimerQueue == NULL )
9D02C958  8F8280C4   LW V0, -32572(GP)
9D02C95C  14400015   BNE V0, ZERO, 0x9D02C9B4
9D02C960  00000000   NOP
662:                 		{
663:                 			vListInitialise( &xActiveTimerList1 );
9D02C964  3C02A000   LUI V0, -24576
9D02C968  24443284   ADDIU A0, V0, 12932
9D02C96C  0F40D0AB   JAL vListInitialise
9D02C970  00000000   NOP
664:                 			vListInitialise( &xActiveTimerList2 );
9D02C974  3C02A000   LUI V0, -24576
9D02C978  24443298   ADDIU A0, V0, 12952
9D02C97C  0F40D0AB   JAL vListInitialise
9D02C980  00000000   NOP
665:                 			pxCurrentTimerList = &xActiveTimerList1;
9D02C984  3C02A000   LUI V0, -24576
9D02C988  24423284   ADDIU V0, V0, 12932
9D02C98C  AF8280BC   SW V0, -32580(GP)
666:                 			pxOverflowTimerList = &xActiveTimerList2;
9D02C990  3C02A000   LUI V0, -24576
9D02C994  24423298   ADDIU V0, V0, 12952
9D02C998  AF8280C0   SW V0, -32576(GP)
667:                 			xTimerQueue = xQueueCreate( ( unsigned portBASE_TYPE ) configTIMER_QUEUE_LENGTH, sizeof( xTIMER_MESSAGE ) );
9D02C99C  24040005   ADDIU A0, ZERO, 5
9D02C9A0  2405000C   ADDIU A1, ZERO, 12
9D02C9A4  00003021   ADDU A2, ZERO, ZERO
9D02C9A8  0F4083ED   JAL xQueueGenericCreate
9D02C9AC  00000000   NOP
9D02C9B0  AF8280C4   SW V0, -32572(GP)
668:                 		}
669:                 	}
670:                 	taskEXIT_CRITICAL();
9D02C9B4  0F40836C   JAL vTaskExitCritical
9D02C9B8  00000000   NOP
671:                 }
9D02C9BC  03C0E821   ADDU SP, S8, ZERO
9D02C9C0  8FBF0014   LW RA, 20(SP)
9D02C9C4  8FBE0010   LW S8, 16(SP)
9D02C9C8  27BD0018   ADDIU SP, SP, 24
9D02C9CC  03E00008   JR RA
9D02C9D0  00000000   NOP
672:                 /*-----------------------------------------------------------*/
673:                 
674:                 portBASE_TYPE xTimerIsTimerActive( xTimerHandle xTimer )
675:                 {
9D02C9D4  27BDFFE0   ADDIU SP, SP, -32
9D02C9D8  AFBF001C   SW RA, 28(SP)
9D02C9DC  AFBE0018   SW S8, 24(SP)
9D02C9E0  03A0F021   ADDU S8, SP, ZERO
9D02C9E4  AFC40020   SW A0, 32(S8)
676:                 portBASE_TYPE xTimerIsInActiveList;
677:                 xTIMER *pxTimer = ( xTIMER * ) xTimer;
9D02C9E8  8FC20020   LW V0, 32(S8)
9D02C9EC  AFC20010   SW V0, 16(S8)
678:                 
679:                 	/* Is the timer in the list of active timers? */
680:                 	taskENTER_CRITICAL();
9D02C9F0  0F40834C   JAL vTaskEnterCritical
9D02C9F4  00000000   NOP
681:                 	{
682:                 		/* Checking to see if it is in the NULL list in effect checks to see if
683:                 		it is referenced from either the current or the overflow timer lists in
684:                 		one go, but the logic has to be reversed, hence the '!'. */
685:                 		xTimerIsInActiveList = !( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) );
9D02C9F8  8FC20010   LW V0, 16(S8)
9D02C9FC  8C420014   LW V0, 20(V0)
9D02CA00  0002102B   SLTU V0, ZERO, V0
9D02CA04  AFC20014   SW V0, 20(S8)
686:                 	}
687:                 	taskEXIT_CRITICAL();
9D02CA08  0F40836C   JAL vTaskExitCritical
9D02CA0C  00000000   NOP
688:                 
689:                 	return xTimerIsInActiveList;
9D02CA10  8FC20014   LW V0, 20(S8)
690:                 }
9D02CA14  03C0E821   ADDU SP, S8, ZERO
9D02CA18  8FBF001C   LW RA, 28(SP)
9D02CA1C  8FBE0018   LW S8, 24(SP)
9D02CA20  27BD0020   ADDIU SP, SP, 32
9D02CA24  03E00008   JR RA
9D02CA28  00000000   NOP
691:                 /*-----------------------------------------------------------*/
692:                 
693:                 void *pvTimerGetTimerID( xTimerHandle xTimer )
694:                 {
9D02CA2C  27BDFFF0   ADDIU SP, SP, -16
9D02CA30  AFBE000C   SW S8, 12(SP)
9D02CA34  03A0F021   ADDU S8, SP, ZERO
9D02CA38  AFC40010   SW A0, 16(S8)
695:                 xTIMER *pxTimer = ( xTIMER * ) xTimer;
9D02CA3C  8FC20010   LW V0, 16(S8)
9D02CA40  AFC20000   SW V0, 0(S8)
696:                 
697:                 	return pxTimer->pvTimerID;
9D02CA44  8FC20000   LW V0, 0(S8)
9D02CA48  8C420020   LW V0, 32(V0)
698:                 }
9D02CA4C  03C0E821   ADDU SP, S8, ZERO
9D02CA50  8FBE000C   LW S8, 12(SP)
9D02CA54  27BD0010   ADDIU SP, SP, 16
9D02CA58  03E00008   JR RA
9D02CA5C  00000000   NOP
699:                 /*-----------------------------------------------------------*/
700:                 
701:                 /* This entire source file will be skipped if the application is not configured
702:                 to include software timer functionality.  If you want to include software timer
703:                 functionality then ensure configUSE_TIMERS is set to 1 in FreeRTOSConfig.h. */
704:                 #endif /* configUSE_TIMERS == 1 */
705:                 
706:                 
707:                 
---  C:/Users/Diego/Documents/GitHub/pic32webFREERtos/Pic32Web.X/src/FreeRTOS/tasks.c  ------------------
1:                   /*
2:                       FreeRTOS V7.5.3 - Copyright (C) 2013 Real Time Engineers Ltd. 
3:                       All rights reserved
4:                   
5:                       VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
6:                   
7:                       ***************************************************************************
8:                        *                                                                       *
9:                        *    FreeRTOS provides completely free yet professionally developed,    *
10:                       *    robust, strictly quality controlled, supported, and cross          *
11:                       *    platform software that has become a de facto standard.             *
12:                       *                                                                       *
13:                       *    Help yourself get started quickly and support the FreeRTOS         *
14:                       *    project by purchasing a FreeRTOS tutorial book, reference          *
15:                       *    manual, or both from: http://www.FreeRTOS.org/Documentation        *
16:                       *                                                                       *
17:                       *    Thank you!                                                         *
18:                       *                                                                       *
19:                      ***************************************************************************
20:                  
21:                      This file is part of the FreeRTOS distribution.
22:                  
23:                      FreeRTOS is free software; you can redistribute it and/or modify it under
24:                      the terms of the GNU General Public License (version 2) as published by the
25:                      Free Software Foundation >>!AND MODIFIED BY!<< the FreeRTOS exception.
26:                  
27:                      >>! NOTE: The modification to the GPL is included to allow you to distribute
28:                      >>! a combined work that includes FreeRTOS without being obliged to provide
29:                      >>! the source code for proprietary components outside of the FreeRTOS
30:                      >>! kernel.
31:                  
32:                      FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
33:                      WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
34:                      FOR A PARTICULAR PURPOSE.  Full license text is available from the following
35:                      link: http://www.freertos.org/a00114.html
36:                  
37:                      1 tab == 4 spaces!
38:                  
39:                      ***************************************************************************
40:                       *                                                                       *
41:                       *    Having a problem?  Start by reading the FAQ "My application does   *
42:                       *    not run, what could be wrong?"                                     *
43:                       *                                                                       *
44:                       *    http://www.FreeRTOS.org/FAQHelp.html                               *
45:                       *                                                                       *
46:                      ***************************************************************************
47:                  
48:                      http://www.FreeRTOS.org - Documentation, books, training, latest versions,
49:                      license and Real Time Engineers Ltd. contact details.
50:                  
51:                      http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
52:                      including FreeRTOS+Trace - an indispensable productivity tool, a DOS
53:                      compatible FAT file system, and our tiny thread aware UDP/IP stack.
54:                  
55:                      http://www.OpenRTOS.com - Real Time Engineers ltd license FreeRTOS to High
56:                      Integrity Systems to sell under the OpenRTOS brand.  Low cost OpenRTOS
57:                      licenses offer ticketed support, indemnification and middleware.
58:                  
59:                      http://www.SafeRTOS.com - High Integrity Systems also provide a safety
60:                      engineered and independently SIL3 certified version for use in safety and
61:                      mission critical applications that require provable dependability.
62:                  
63:                      1 tab == 4 spaces!
64:                  */
65:                  
66:                  /* Standard includes. */
67:                  #include <stdlib.h>
68:                  #include <string.h>
69:                  
70:                  /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
71:                  all the API functions to use the MPU wrappers.  That should only be done when
72:                  task.h is included from an application file. */
73:                  #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
74:                  
75:                  /* FreeRTOS includes. */
76:                  #include "FreeRTOS.h"
77:                  #include "task.h"
78:                  #include "timers.h"
79:                  #include "StackMacros.h"
80:                  
81:                  /* Lint e961 and e750 are suppressed as a MISRA exception justified because the
82:                  MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined for the
83:                  header files above, but not in this file, in order to generate the correct
84:                  privileged Vs unprivileged linkage and placement. */
85:                  #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE /*lint !e961 !e750. */
86:                  
87:                  #if ( configUSE_STATS_FORMATTING_FUNCTIONS == 1 )
88:                  	/* At the bottom of this file are two optional functions that can be used
89:                  	to generate human readable text from the raw data generated by the
90:                  	uxTaskGetSystemState() function.  Note the formatting functions are provided
91:                  	for convenience only, and are NOT considered part of the kernel. */
92:                  	#include <stdio.h>
93:                  #endif /* configUSE_STATS_FORMATTING_FUNCTIONS == 1 ) */
94:                  
95:                  /* Sanity check the configuration. */
96:                  #if configUSE_TICKLESS_IDLE != 0
97:                  	#if INCLUDE_vTaskSuspend != 1
98:                  		#error INCLUDE_vTaskSuspend must be set to 1 if configUSE_TICKLESS_IDLE is not set to 0
99:                  	#endif /* INCLUDE_vTaskSuspend */
100:                 #endif /* configUSE_TICKLESS_IDLE */
101:                 
102:                 /*
103:                  * Defines the size, in words, of the stack allocated to the idle task.
104:                  */
105:                 #define tskIDLE_STACK_SIZE	configMINIMAL_STACK_SIZE
106:                 
107:                 /*
108:                  * Task control block.  A task control block (TCB) is allocated for each task,
109:                  * and stores task state information, including a pointer to the task's context
110:                  * (the task's run time environment, including register values)
111:                  */
112:                 typedef struct tskTaskControlBlock
113:                 {
114:                 	volatile portSTACK_TYPE	*pxTopOfStack;		/*< Points to the location of the last item placed on the tasks stack.  THIS MUST BE THE FIRST MEMBER OF THE TCB STRUCT. */
115:                 
116:                 	#if ( portUSING_MPU_WRAPPERS == 1 )
117:                 		xMPU_SETTINGS xMPUSettings;				/*< The MPU settings are defined as part of the port layer.  THIS MUST BE THE SECOND MEMBER OF THE TCB STRUCT. */
118:                 	#endif
119:                 
120:                 	xListItem				xGenericListItem;	/*< The list that the state list item of a task is reference from denotes the state of that task (Ready, Blocked, Suspended ). */
121:                 	xListItem				xEventListItem;		/*< Used to reference a task from an event list. */
122:                 	unsigned portBASE_TYPE	uxPriority;			/*< The priority of the task.  0 is the lowest priority. */
123:                 	portSTACK_TYPE			*pxStack;			/*< Points to the start of the stack. */
124:                 	signed char				pcTaskName[ configMAX_TASK_NAME_LEN ];/*< Descriptive name given to the task when created.  Facilitates debugging only. */
125:                 
126:                 	#if ( portSTACK_GROWTH > 0 )
127:                 		portSTACK_TYPE *pxEndOfStack;			/*< Points to the end of the stack on architectures where the stack grows up from low memory. */
128:                 	#endif
129:                 
130:                 	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
131:                 		unsigned portBASE_TYPE uxCriticalNesting; /*< Holds the critical section nesting depth for ports that do not maintain their own count in the port layer. */
132:                 	#endif
133:                 
134:                 	#if ( configUSE_TRACE_FACILITY == 1 )
135:                 		unsigned portBASE_TYPE	uxTCBNumber;	/*< Stores a number that increments each time a TCB is created.  It allows debuggers to determine when a task has been deleted and then recreated. */
136:                 		unsigned portBASE_TYPE  uxTaskNumber;	/*< Stores a number specifically for use by third party trace code. */
137:                 	#endif
138:                 
139:                 	#if ( configUSE_MUTEXES == 1 )
140:                 		unsigned portBASE_TYPE uxBasePriority;	/*< The priority last assigned to the task - used by the priority inheritance mechanism. */
141:                 	#endif
142:                 
143:                 	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
144:                 		pdTASK_HOOK_CODE pxTaskTag;
145:                 	#endif
146:                 
147:                 	#if ( configGENERATE_RUN_TIME_STATS == 1 )
148:                 		unsigned long ulRunTimeCounter;			/*< Stores the amount of time the task has spent in the Running state. */
149:                 	#endif
150:                 
151:                 	#if ( configUSE_NEWLIB_REENTRANT == 1 )
152:                 		/* Allocate a Newlib reent structure that is specific to this task.
153:                 		Note Newlib support has been included by popular demand, but is not
154:                 		used by the FreeRTOS maintainers themselves.  FreeRTOS is not
155:                 		responsible for resulting newlib operation.  User must be familiar with
156:                 		newlib and must provide system-wide implementations of the necessary
157:                 		stubs. Be warned that (at the time of writing) the current newlib design
158:                 		implements a system-wide malloc() that must be provided with locks. */
159:                 		struct _reent xNewLib_reent;
160:                 	#endif
161:                 
162:                 } tskTCB;
163:                 
164:                 
165:                 /*
166:                  * Some kernel aware debuggers require the data the debugger needs access to to
167:                  * be global, rather than file scope.
168:                  */
169:                 #ifdef portREMOVE_STATIC_QUALIFIER
170:                 	#define static
171:                 #endif
172:                 
173:                 /*lint -e956 A manual analysis and inspection has been used to determine which
174:                 static variables must be declared volatile. */
175:                 
176:                 PRIVILEGED_DATA tskTCB * volatile pxCurrentTCB = NULL;
177:                 
178:                 /* Lists for ready and blocked tasks. --------------------*/
179:                 PRIVILEGED_DATA static xList pxReadyTasksLists[ configMAX_PRIORITIES ];	/*< Prioritised ready tasks. */
180:                 PRIVILEGED_DATA static xList xDelayedTaskList1;							/*< Delayed tasks. */
181:                 PRIVILEGED_DATA static xList xDelayedTaskList2;							/*< Delayed tasks (two lists are used - one for delays that have overflowed the current tick count. */
182:                 PRIVILEGED_DATA static xList * volatile pxDelayedTaskList;				/*< Points to the delayed task list currently being used. */
183:                 PRIVILEGED_DATA static xList * volatile pxOverflowDelayedTaskList;		/*< Points to the delayed task list currently being used to hold tasks that have overflowed the current tick count. */
184:                 PRIVILEGED_DATA static xList xPendingReadyList;							/*< Tasks that have been readied while the scheduler was suspended.  They will be moved to the ready list when the scheduler is resumed. */
185:                 
186:                 #if ( INCLUDE_vTaskDelete == 1 )
187:                 
188:                 	PRIVILEGED_DATA static xList xTasksWaitingTermination;				/*< Tasks that have been deleted - but the their memory not yet freed. */
189:                 	PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxTasksDeleted = ( unsigned portBASE_TYPE ) 0U;
190:                 
191:                 #endif
192:                 
193:                 #if ( INCLUDE_vTaskSuspend == 1 )
194:                 
195:                 	PRIVILEGED_DATA static xList xSuspendedTaskList;					/*< Tasks that are currently suspended. */
196:                 
197:                 #endif
198:                 
199:                 #if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
200:                 
201:                 	PRIVILEGED_DATA static xTaskHandle xIdleTaskHandle = NULL;			/*< Holds the handle of the idle task.  The idle task is created automatically when the scheduler is started. */
202:                 
203:                 #endif
204:                 
205:                 /* Other file private variables. --------------------------------*/
206:                 PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxCurrentNumberOfTasks 	= ( unsigned portBASE_TYPE ) 0U;
207:                 PRIVILEGED_DATA static volatile portTickType xTickCount 						= ( portTickType ) 0U;
208:                 PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxTopReadyPriority 		= tskIDLE_PRIORITY;
209:                 PRIVILEGED_DATA static volatile signed portBASE_TYPE xSchedulerRunning 			= pdFALSE;
210:                 PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxSchedulerSuspended	 	= ( unsigned portBASE_TYPE ) pdFALSE;
211:                 PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxPendedTicks 			= ( unsigned portBASE_TYPE ) 0U;
212:                 PRIVILEGED_DATA static volatile portBASE_TYPE xYieldPending 					= pdFALSE;
213:                 PRIVILEGED_DATA static volatile portBASE_TYPE xNumOfOverflows 					= ( portBASE_TYPE ) 0;
214:                 PRIVILEGED_DATA static unsigned portBASE_TYPE uxTaskNumber 						= ( unsigned portBASE_TYPE ) 0U;
215:                 PRIVILEGED_DATA static volatile portTickType xNextTaskUnblockTime				= portMAX_DELAY;
216:                 
217:                 #if ( configGENERATE_RUN_TIME_STATS == 1 )
218:                 
219:                 	PRIVILEGED_DATA static unsigned long ulTaskSwitchedInTime = 0UL;	/*< Holds the value of a timer/counter the last time a task was switched in. */
220:                 	PRIVILEGED_DATA static unsigned long ulTotalRunTime = 0UL;			/*< Holds the total amount of execution time as defined by the run time counter clock. */
221:                 
222:                 #endif
223:                 
224:                 /*lint +e956 */
225:                 
226:                 /* Debugging and trace facilities private variables and macros. ------------*/
227:                 
228:                 /*
229:                  * The value used to fill the stack of a task when the task is created.  This
230:                  * is used purely for checking the high water mark for tasks.
231:                  */
232:                 #define tskSTACK_FILL_BYTE	( 0xa5U )
233:                 
234:                 /*
235:                  * Macros used by vListTask to indicate which state a task is in.
236:                  */
237:                 #define tskBLOCKED_CHAR		( ( signed char ) 'B' )
238:                 #define tskREADY_CHAR		( ( signed char ) 'R' )
239:                 #define tskDELETED_CHAR		( ( signed char ) 'D' )
240:                 #define tskSUSPENDED_CHAR	( ( signed char ) 'S' )
241:                 
242:                 /*-----------------------------------------------------------*/
243:                 
244:                 #if ( configUSE_PORT_OPTIMISED_TASK_SELECTION == 0 )
245:                 
246:                 	/* If configUSE_PORT_OPTIMISED_TASK_SELECTION is 0 then task selection is
247:                 	performed in a generic way that is not optimised to any particular
248:                 	microcontroller architecture. */
249:                 
250:                 	/* uxTopReadyPriority holds the priority of the highest priority ready
251:                 	state task. */
252:                 	#define taskRECORD_READY_PRIORITY( uxPriority )																		\
253:                 	{																													\
254:                 		if( ( uxPriority ) > uxTopReadyPriority )																		\
255:                 		{																												\
256:                 			uxTopReadyPriority = ( uxPriority );																		\
257:                 		}																												\
258:                 	} /* taskRECORD_READY_PRIORITY */
259:                 
260:                 	/*-----------------------------------------------------------*/
261:                 
262:                 	#define taskSELECT_HIGHEST_PRIORITY_TASK()																			\
263:                 	{																													\
264:                 		/* Find the highest priority queue that contains ready tasks. */												\
265:                 		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )										\
266:                 		{																												\
267:                 			configASSERT( uxTopReadyPriority );																			\
268:                 			--uxTopReadyPriority;																						\
269:                 		}																												\
270:                 																														\
271:                 		/* listGET_OWNER_OF_NEXT_ENTRY indexes through the list, so the tasks of										\
272:                 		the	same priority get an equal share of the processor time. */													\
273:                 		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );						\
274:                 	} /* taskSELECT_HIGHEST_PRIORITY_TASK */
275:                 
276:                 	/*-----------------------------------------------------------*/
277:                 
278:                 	/* Define away taskRESET_READY_PRIORITY() and portRESET_READY_PRIORITY() as
279:                 	they are only required when a port optimised method of task selection is
280:                 	being used. */
281:                 	#define taskRESET_READY_PRIORITY( uxPriority )
282:                 	#define portRESET_READY_PRIORITY( uxPriority, uxTopReadyPriority )
283:                 
284:                 #else /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
285:                 
286:                 	/* If configUSE_PORT_OPTIMISED_TASK_SELECTION is 1 then task selection is
287:                 	performed in a way that is tailored to the particular microcontroller
288:                 	architecture being used. */
289:                 
290:                 	/* A port optimised version is provided.  Call the port defined macros. */
291:                 	#define taskRECORD_READY_PRIORITY( uxPriority )	portRECORD_READY_PRIORITY( uxPriority, uxTopReadyPriority )
292:                 
293:                 	/*-----------------------------------------------------------*/
294:                 
295:                 	#define taskSELECT_HIGHEST_PRIORITY_TASK()														\
296:                 	{																								\
297:                 	unsigned portBASE_TYPE uxTopPriority;															\
298:                 																									\
299:                 		/* Find the highest priority queue that contains ready tasks. */							\
300:                 		portGET_HIGHEST_PRIORITY( uxTopPriority, uxTopReadyPriority );								\
301:                 		configASSERT( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ uxTopPriority ] ) ) > 0 );		\
302:                 		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopPriority ] ) );		\
303:                 	} /* taskSELECT_HIGHEST_PRIORITY_TASK() */
304:                 
305:                 	/*-----------------------------------------------------------*/
306:                 
307:                 	/* A port optimised version is provided, call it only if the TCB being reset
308:                 	is being referenced from a ready list.  If it is referenced from a delayed
309:                 	or suspended list then it won't be in a ready list. */
310:                 	#define taskRESET_READY_PRIORITY( uxPriority )													\
311:                 	{																								\
312:                 		if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ ( uxPriority ) ] ) ) == 0 )				\
313:                 		{																							\
314:                 			portRESET_READY_PRIORITY( ( uxPriority ), ( uxTopReadyPriority ) );						\
315:                 		}																							\
316:                 	}
317:                 
318:                 #endif /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
319:                 
320:                 /*-----------------------------------------------------------*/
321:                 
322:                 /* pxDelayedTaskList and pxOverflowDelayedTaskList are switched when the tick
323:                 count overflows. */
324:                 #define taskSWITCH_DELAYED_LISTS()																	\
325:                 {																									\
326:                 	xList *pxTemp;																					\
327:                 																									\
328:                 	/* The delayed tasks list should be empty when the lists are switched. */						\
329:                 	configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );										\
330:                 																									\
331:                 	pxTemp = pxDelayedTaskList;																		\
332:                 	pxDelayedTaskList = pxOverflowDelayedTaskList;													\
333:                 	pxOverflowDelayedTaskList = pxTemp;																\
334:                 	xNumOfOverflows++;																				\
335:                 																									\
336:                 	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )											\
337:                 	{																								\
338:                 		/* The new current delayed list is empty.  Set												\
339:                 		xNextTaskUnblockTime to the maximum possible value so it is									\
340:                 		extremely unlikely that the																	\
341:                 		if( xTickCount >= xNextTaskUnblockTime ) test will pass until								\
342:                 		there is an item in the delayed list. */													\
343:                 		xNextTaskUnblockTime = portMAX_DELAY;														\
344:                 	}																								\
345:                 	else																							\
346:                 	{																								\
347:                 		/* The new current delayed list is not empty, get the value of								\
348:                 		the item at the head of the delayed list.  This is the time at								\
349:                 		which the task at the head of the delayed list should be removed							\
350:                 		from the Blocked state. */																	\
351:                 		pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );						\
352:                 		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );				\
353:                 	}																								\
354:                 }
355:                 
356:                 /*-----------------------------------------------------------*/
357:                 
358:                 /*
359:                  * Place the task represented by pxTCB into the appropriate ready list for
360:                  * the task.  It is inserted at the end of the list.
361:                  */
362:                 #define prvAddTaskToReadyList( pxTCB )																				\
363:                 	traceMOVED_TASK_TO_READY_STATE( pxTCB )																			\
364:                 	taskRECORD_READY_PRIORITY( ( pxTCB )->uxPriority );																\
365:                 	vListInsertEnd( &( pxReadyTasksLists[ ( pxTCB )->uxPriority ] ), &( ( pxTCB )->xGenericListItem ) )
366:                 /*-----------------------------------------------------------*/
367:                 
368:                 /*
369:                  * Several functions take an xTaskHandle parameter that can optionally be NULL,
370:                  * where NULL is used to indicate that the handle of the currently executing
371:                  * task should be used in place of the parameter.  This macro simply checks to
372:                  * see if the parameter is NULL and returns a pointer to the appropriate TCB.
373:                  */
374:                 #define prvGetTCBFromHandle( pxHandle ) ( ( ( pxHandle ) == NULL ) ? ( tskTCB * ) pxCurrentTCB : ( tskTCB * ) ( pxHandle ) )
375:                 
376:                 /* Callback function prototypes. --------------------------*/
377:                 extern void vApplicationStackOverflowHook( xTaskHandle xTask, signed char *pcTaskName );
378:                 extern void vApplicationTickHook( void );
379:                 
380:                 /* File private functions. --------------------------------*/
381:                 
382:                 /*
383:                  * Utility to ready a TCB for a given task.  Mainly just copies the parameters
384:                  * into the TCB structure.
385:                  */
386:                 static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned portBASE_TYPE uxPriority, const xMemoryRegion * const xRegions, unsigned short usStackDepth ) PRIVILEGED_FUNCTION;
387:                 
388:                 /*
389:                  * Utility to ready all the lists used by the scheduler.  This is called
390:                  * automatically upon the creation of the first task.
391:                  */
392:                 static void prvInitialiseTaskLists( void ) PRIVILEGED_FUNCTION;
393:                 
394:                 /*
395:                  * The idle task, which as all tasks is implemented as a never ending loop.
396:                  * The idle task is automatically created and added to the ready lists upon
397:                  * creation of the first user task.
398:                  *
399:                  * The portTASK_FUNCTION_PROTO() macro is used to allow port/compiler specific
400:                  * language extensions.  The equivalent prototype for this function is:
401:                  *
402:                  * void prvIdleTask( void *pvParameters );
403:                  *
404:                  */
405:                 static portTASK_FUNCTION_PROTO( prvIdleTask, pvParameters );
406:                 
407:                 /*
408:                  * Utility to free all memory allocated by the scheduler to hold a TCB,
409:                  * including the stack pointed to by the TCB.
410:                  *
411:                  * This does not free memory allocated by the task itself (i.e. memory
412:                  * allocated by calls to pvPortMalloc from within the tasks application code).
413:                  */
414:                 #if ( INCLUDE_vTaskDelete == 1 )
415:                 
416:                 	static void prvDeleteTCB( tskTCB *pxTCB ) PRIVILEGED_FUNCTION;
417:                 
418:                 #endif
419:                 
420:                 /*
421:                  * Used only by the idle task.  This checks to see if anything has been placed
422:                  * in the list of tasks waiting to be deleted.  If so the task is cleaned up
423:                  * and its TCB deleted.
424:                  */
425:                 static void prvCheckTasksWaitingTermination( void ) PRIVILEGED_FUNCTION;
426:                 
427:                 /*
428:                  * The currently executing task is entering the Blocked state.  Add the task to
429:                  * either the current or the overflow delayed task list.
430:                  */
431:                 static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake ) PRIVILEGED_FUNCTION;
432:                 
433:                 /*
434:                  * Allocates memory from the heap for a TCB and associated stack.  Checks the
435:                  * allocation was successful.
436:                  */
437:                 static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer ) PRIVILEGED_FUNCTION;
438:                 
439:                 /*
440:                  * Fills an xTaskStatusType structure with information on each task that is
441:                  * referenced from the pxList list (which may be a ready list, a delayed list,
442:                  * a suspended list, etc.).
443:                  *
444:                  * THIS FUNCTION IS INTENDED FOR DEBUGGING ONLY, AND SHOULD NOT BE CALLED FROM
445:                  * NORMAL APPLICATION CODE.
446:                  */
447:                 #if ( configUSE_TRACE_FACILITY == 1 )
448:                 
449:                 	static unsigned portBASE_TYPE prvListTaskWithinSingleList( xTaskStatusType *pxTaskStatusArray, xList *pxList, eTaskState eState ) PRIVILEGED_FUNCTION;
450:                 
451:                 #endif
452:                 
453:                 /*
454:                  * When a task is created, the stack of the task is filled with a known value.
455:                  * This function determines the 'high water mark' of the task stack by
456:                  * determining how much of the stack remains at the original preset value.
457:                  */
458:                 #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
459:                 
460:                 	static unsigned short prvTaskCheckFreeStackSpace( const unsigned char * pucStackByte ) PRIVILEGED_FUNCTION;
461:                 
462:                 #endif
463:                 
464:                 /*
465:                  * Return the amount of time, in ticks, that will pass before the kernel will
466:                  * next move a task from the Blocked state to the Running state.
467:                  *
468:                  * This conditional compilation should use inequality to 0, not equality to 1.
469:                  * This is to ensure portSUPPRESS_TICKS_AND_SLEEP() can be called when user
470:                  * defined low power mode implementations require configUSE_TICKLESS_IDLE to be
471:                  * set to a value other than 1.
472:                  */
473:                 #if ( configUSE_TICKLESS_IDLE != 0 )
474:                 
475:                 	static portTickType prvGetExpectedIdleTime( void ) PRIVILEGED_FUNCTION;
476:                 
477:                 #endif
478:                 
479:                 signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
480:                 {
9D01EA98  27BDFFD0   ADDIU SP, SP, -48
9D01EA9C  AFBF002C   SW RA, 44(SP)
9D01EAA0  AFBE0028   SW S8, 40(SP)
9D01EAA4  03A0F021   ADDU S8, SP, ZERO
9D01EAA8  AFC40030   SW A0, 48(S8)
9D01EAAC  AFC50034   SW A1, 52(S8)
9D01EAB0  00C01021   ADDU V0, A2, ZERO
9D01EAB4  AFC7003C   SW A3, 60(S8)
9D01EAB8  A7C20038   SH V0, 56(S8)
481:                 signed portBASE_TYPE xReturn;
482:                 tskTCB * pxNewTCB;
483:                 
484:                 	configASSERT( pxTaskCode );
9D01EABC  8FC20030   LW V0, 48(S8)
9D01EAC0  14400006   BNE V0, ZERO, 0x9D01EADC
9D01EAC4  00000000   NOP
9D01EAC8  3C029D03   LUI V0, -25341
9D01EACC  24446054   ADDIU A0, V0, 24660
9D01EAD0  240501E4   ADDIU A1, ZERO, 484
9D01EAD4  0F40C5F5   JAL vAssertCalled
9D01EAD8  00000000   NOP
485:                 	configASSERT( ( ( uxPriority & ( ~portPRIVILEGE_BIT ) ) < configMAX_PRIORITIES ) );
9D01EADC  8FC20040   LW V0, 64(S8)
9D01EAE0  2C420005   SLTIU V0, V0, 5
9D01EAE4  14400006   BNE V0, ZERO, 0x9D01EB00
9D01EAE8  00000000   NOP
9D01EAEC  3C029D03   LUI V0, -25341
9D01EAF0  24446054   ADDIU A0, V0, 24660
9D01EAF4  240501E5   ADDIU A1, ZERO, 485
9D01EAF8  0F40C5F5   JAL vAssertCalled
9D01EAFC  00000000   NOP
486:                 
487:                 	/* Allocate the memory required by the TCB and stack for the new task,
488:                 	checking that the allocation was successful. */
489:                 	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
9D01EB00  97C20038   LHU V0, 56(S8)
9D01EB04  00402021   ADDU A0, V0, ZERO
9D01EB08  8FC50048   LW A1, 72(S8)
9D01EB0C  0F40820C   JAL prvAllocateTCBAndStack
9D01EB10  00000000   NOP
9D01EB14  AFC2001C   SW V0, 28(S8)
490:                 
491:                 	if( pxNewTCB != NULL )
9D01EB18  8FC2001C   LW V0, 28(S8)
9D01EB1C  10400065   BEQ V0, ZERO, 0x9D01ECB4
9D01EB20  00000000   NOP
492:                 	{
493:                 		portSTACK_TYPE *pxTopOfStack;
494:                 
495:                 		#if( portUSING_MPU_WRAPPERS == 1 )
496:                 			/* Should the task be created in privileged mode? */
497:                 			portBASE_TYPE xRunPrivileged;
498:                 			if( ( uxPriority & portPRIVILEGE_BIT ) != 0U )
499:                 			{
500:                 				xRunPrivileged = pdTRUE;
501:                 			}
502:                 			else
503:                 			{
504:                 				xRunPrivileged = pdFALSE;
505:                 			}
506:                 			uxPriority &= ~portPRIVILEGE_BIT;
507:                 		#endif /* portUSING_MPU_WRAPPERS == 1 */
508:                 
509:                 		/* Calculate the top of stack address.  This depends on whether the
510:                 		stack grows from high memory to low (as per the 80x86) or visa versa.
511:                 		portSTACK_GROWTH is used to make the result positive or negative as
512:                 		required by the port. */
513:                 		#if( portSTACK_GROWTH < 0 )
514:                 		{
515:                 			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
9D01EB24  8FC2001C   LW V0, 28(S8)
9D01EB28  8C430030   LW V1, 48(V0)
9D01EB2C  97C20038   LHU V0, 56(S8)
9D01EB30  2442FFFF   ADDIU V0, V0, -1
9D01EB34  00021080   SLL V0, V0, 2
9D01EB38  00621021   ADDU V0, V1, V0
9D01EB3C  AFC20020   SW V0, 32(S8)
516:                 			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK  ) ); /*lint !e923 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type. */
9D01EB40  8FC30020   LW V1, 32(S8)
9D01EB44  2402FFF8   ADDIU V0, ZERO, -8
9D01EB48  00621024   AND V0, V1, V0
9D01EB4C  AFC20020   SW V0, 32(S8)
517:                 
518:                 			/* Check the alignment of the calculated top of stack is correct. */
519:                 			configASSERT( ( ( ( unsigned long ) pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );
9D01EB50  8FC20020   LW V0, 32(S8)
9D01EB54  30420007   ANDI V0, V0, 7
9D01EB58  10400006   BEQ V0, ZERO, 0x9D01EB74
9D01EB5C  00000000   NOP
9D01EB60  3C029D03   LUI V0, -25341
9D01EB64  24446054   ADDIU A0, V0, 24660
9D01EB68  24050207   ADDIU A1, ZERO, 519
9D01EB6C  0F40C5F5   JAL vAssertCalled
9D01EB70  00000000   NOP
520:                 		}
521:                 		#else /* portSTACK_GROWTH */
522:                 		{
523:                 			pxTopOfStack = pxNewTCB->pxStack;
524:                 
525:                 			/* Check the alignment of the stack buffer is correct. */
526:                 			configASSERT( ( ( ( unsigned long ) pxNewTCB->pxStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );
527:                 
528:                 			/* If we want to use stack checking on architectures that use
529:                 			a positive stack growth direction then we also need to store the
530:                 			other extreme of the stack space. */
531:                 			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
532:                 		}
533:                 		#endif /* portSTACK_GROWTH */
534:                 
535:                 		/* Setup the newly allocated TCB with the initial state of the task. */
536:                 		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
9D01EB74  97C20038   LHU V0, 56(S8)
9D01EB78  AFA20010   SW V0, 16(SP)
9D01EB7C  8FC4001C   LW A0, 28(S8)
9D01EB80  8FC50034   LW A1, 52(S8)
9D01EB84  8FC60040   LW A2, 64(S8)
9D01EB88  8FC7004C   LW A3, 76(S8)
9D01EB8C  0F408157   JAL prvInitialiseTCBVariables
9D01EB90  00000000   NOP
537:                 
538:                 		/* Initialize the TCB stack to look as if the task was already running,
539:                 		but had been interrupted by the scheduler.  The return address is set
540:                 		to the start of the task function. Once the stack has been initialised
541:                 		the	top of stack variable is updated. */
542:                 		#if( portUSING_MPU_WRAPPERS == 1 )
543:                 		{
544:                 			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
545:                 		}
546:                 		#else /* portUSING_MPU_WRAPPERS */
547:                 		{
548:                 			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
9D01EB94  8FC40020   LW A0, 32(S8)
9D01EB98  8FC50030   LW A1, 48(S8)
9D01EB9C  8FC6003C   LW A2, 60(S8)
9D01EBA0  0F40CF28   JAL pxPortInitialiseStack
9D01EBA4  00000000   NOP
9D01EBA8  00401821   ADDU V1, V0, ZERO
9D01EBAC  8FC2001C   LW V0, 28(S8)
9D01EBB0  AC430000   SW V1, 0(V0)
549:                 		}
550:                 		#endif /* portUSING_MPU_WRAPPERS */
551:                 
552:                 		if( ( void * ) pxCreatedTask != NULL )
9D01EBB4  8FC20044   LW V0, 68(S8)
9D01EBB8  10400004   BEQ V0, ZERO, 0x9D01EBCC
9D01EBBC  00000000   NOP
553:                 		{
554:                 			/* Pass the TCB out - in an anonymous way.  The calling function/
555:                 			task can use this as a handle to delete the task later if
556:                 			required.*/
557:                 			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
9D01EBC0  8FC20044   LW V0, 68(S8)
9D01EBC4  8FC3001C   LW V1, 28(S8)
9D01EBC8  AC430000   SW V1, 0(V0)
558:                 		}
559:                 
560:                 		/* Ensure interrupts don't access the task lists while they are being
561:                 		updated. */
562:                 		taskENTER_CRITICAL();
9D01EBCC  0F40834C   JAL vTaskEnterCritical
9D01EBD0  00000000   NOP
563:                 		{
564:                 			uxCurrentNumberOfTasks++;
9D01EBD4  8F828098   LW V0, -32616(GP)
9D01EBD8  24420001   ADDIU V0, V0, 1
9D01EBDC  AF828098   SW V0, -32616(GP)
565:                 			if( pxCurrentTCB == NULL )
9D01EBE0  8F828094   LW V0, -32620(GP)
9D01EBE4  1440000B   BNE V0, ZERO, 0x9D01EC14
9D01EBE8  00000000   NOP
566:                 			{
567:                 				/* There are no other tasks, or all the other tasks are in
568:                 				the suspended state - make this the current task. */
569:                 				pxCurrentTCB =  pxNewTCB;
9D01EBEC  8FC2001C   LW V0, 28(S8)
9D01EBF0  AF828094   SW V0, -32620(GP)
570:                 
571:                 				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
9D01EBF4  8F838098   LW V1, -32616(GP)
9D01EBF8  24020001   ADDIU V0, ZERO, 1
9D01EBFC  14620010   BNE V1, V0, 0x9D01EC40
9D01EC00  00000000   NOP
572:                 				{
573:                 					/* This is the first task to be created so do the preliminary
574:                 					initialisation required.  We will not recover if this call
575:                 					fails, but we will report the failure. */
576:                 					prvInitialiseTaskLists();
9D01EC04  0F4081A7   JAL prvInitialiseTaskLists
9D01EC08  00000000   NOP
9D01EC0C  0B407B10   J 0x9D01EC40
9D01EC10  00000000   NOP
577:                 				}
578:                 			}
579:                 			else
580:                 			{
581:                 				/* If the scheduler is not already running, make this task the
582:                 				current task if it is the highest priority task to be created
583:                 				so far. */
584:                 				if( xSchedulerRunning == pdFALSE )
9D01EC14  8F8280A4   LW V0, -32604(GP)
9D01EC18  14400009   BNE V0, ZERO, 0x9D01EC40
9D01EC1C  00000000   NOP
585:                 				{
586:                 					if( pxCurrentTCB->uxPriority <= uxPriority )
9D01EC20  8F828094   LW V0, -32620(GP)
9D01EC24  8C43002C   LW V1, 44(V0)
9D01EC28  8FC20040   LW V0, 64(S8)
9D01EC2C  0043102B   SLTU V0, V0, V1
9D01EC30  14400003   BNE V0, ZERO, 0x9D01EC40
9D01EC34  00000000   NOP
587:                 					{
588:                 						pxCurrentTCB = pxNewTCB;
9D01EC38  8FC2001C   LW V0, 28(S8)
9D01EC3C  AF828094   SW V0, -32620(GP)
589:                 					}
590:                 				}
591:                 			}
592:                 
593:                 			uxTaskNumber++;
9D01EC40  8F8280B8   LW V0, -32584(GP)
9D01EC44  24420001   ADDIU V0, V0, 1
9D01EC48  AF8280B8   SW V0, -32584(GP)
594:                 
595:                 			#if ( configUSE_TRACE_FACILITY == 1 )
596:                 			{
597:                 				/* Add a counter into the TCB for tracing only. */
598:                 				pxNewTCB->uxTCBNumber = uxTaskNumber;
599:                 			}
600:                 			#endif /* configUSE_TRACE_FACILITY */
601:                 			traceTASK_CREATE( pxNewTCB );
602:                 
603:                 			prvAddTaskToReadyList( pxNewTCB );
9D01EC4C  8FC2001C   LW V0, 28(S8)
9D01EC50  8C42002C   LW V0, 44(V0)
9D01EC54  24030001   ADDIU V1, ZERO, 1
9D01EC58  00431804   SLLV V1, V1, V0
9D01EC5C  8F8280A0   LW V0, -32608(GP)
9D01EC60  00621025   OR V0, V1, V0
9D01EC64  AF8280A0   SW V0, -32608(GP)
9D01EC68  8FC2001C   LW V0, 28(S8)
9D01EC6C  8C43002C   LW V1, 44(V0)
9D01EC70  24020014   ADDIU V0, ZERO, 20
9D01EC74  70621802   MUL V1, V1, V0
9D01EC78  3C02A000   LUI V0, -24576
9D01EC7C  24420480   ADDIU V0, V0, 1152
9D01EC80  00621821   ADDU V1, V1, V0
9D01EC84  8FC2001C   LW V0, 28(S8)
9D01EC88  24420004   ADDIU V0, V0, 4
9D01EC8C  00602021   ADDU A0, V1, ZERO
9D01EC90  00402821   ADDU A1, V0, ZERO
9D01EC94  0F40D0D3   JAL vListInsertEnd
9D01EC98  00000000   NOP
604:                 
605:                 			xReturn = pdPASS;
9D01EC9C  24020001   ADDIU V0, ZERO, 1
9D01ECA0  AFC20018   SW V0, 24(S8)
606:                 			portSETUP_TCB( pxNewTCB );
607:                 		}
608:                 		taskEXIT_CRITICAL();
9D01ECA4  0F40836C   JAL vTaskExitCritical
9D01ECA8  00000000   NOP
9D01ECAC  0B407B2F   J 0x9D01ECBC
9D01ECB0  00000000   NOP
609:                 	}
610:                 	else
611:                 	{
612:                 		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
9D01ECB4  2402FFFF   ADDIU V0, ZERO, -1
9D01ECB8  AFC20018   SW V0, 24(S8)
613:                 		traceTASK_CREATE_FAILED();
614:                 	}
615:                 
616:                 	if( xReturn == pdPASS )
9D01ECBC  8FC30018   LW V1, 24(S8)
9D01ECC0  24020001   ADDIU V0, ZERO, 1
9D01ECC4  14620012   BNE V1, V0, 0x9D01ED10
9D01ECC8  00000000   NOP
617:                 	{
618:                 		if( xSchedulerRunning != pdFALSE )
9D01ECCC  8F8280A4   LW V0, -32604(GP)
9D01ECD0  1040000F   BEQ V0, ZERO, 0x9D01ED10
9D01ECD4  00000000   NOP
619:                 		{
620:                 			/* If the created task is of a higher priority than the current task
621:                 			then it should run now. */
622:                 			if( pxCurrentTCB->uxPriority < uxPriority )
9D01ECD8  8F828094   LW V0, -32620(GP)
9D01ECDC  8C43002C   LW V1, 44(V0)
9D01ECE0  8FC20040   LW V0, 64(S8)
9D01ECE4  0062102B   SLTU V0, V1, V0
9D01ECE8  10400009   BEQ V0, ZERO, 0x9D01ED10
9D01ECEC  00000000   NOP
623:                 			{
624:                 				portYIELD_WITHIN_API();
9D01ECF0  40026800   MFC0 V0, Cause
9D01ECF4  AFC20024   SW V0, 36(S8)
9D01ECF8  8FC20024   LW V0, 36(S8)
9D01ECFC  34420100   ORI V0, V0, 256
9D01ED00  AFC20024   SW V0, 36(S8)
9D01ED04  8FC20024   LW V0, 36(S8)
9D01ED08  40826800   MTC0 V0, Cause
9D01ED0C  000000C0   EHB
625:                 			}
626:                 		}
627:                 	}
628:                 
629:                 	return xReturn;
9D01ED10  8FC20018   LW V0, 24(S8)
630:                 }
9D01ED14  03C0E821   ADDU SP, S8, ZERO
9D01ED18  8FBF002C   LW RA, 44(SP)
9D01ED1C  8FBE0028   LW S8, 40(SP)
9D01ED20  27BD0030   ADDIU SP, SP, 48
9D01ED24  03E00008   JR RA
9D01ED28  00000000   NOP
631:                 /*-----------------------------------------------------------*/
632:                 
633:                 #if ( INCLUDE_vTaskDelete == 1 )
634:                 
635:                 	void vTaskDelete( xTaskHandle xTaskToDelete )
636:                 	{
637:                 	tskTCB *pxTCB;
638:                 
639:                 		taskENTER_CRITICAL();
640:                 		{
641:                 			/* If null is passed in here then we are deleting ourselves. */
642:                 			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
643:                 
644:                 			/* Remove task from the ready list and place in the	termination list.
645:                 			This will stop the task from be scheduled.  The idle task will check
646:                 			the termination list and free up any memory allocated by the
647:                 			scheduler for the TCB and stack. */
648:                 			if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( unsigned portBASE_TYPE ) 0 )
649:                 			{
650:                 				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
651:                 			}
652:                 
653:                 			/* Is the task waiting on an event also? */
654:                 			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
655:                 			{
656:                 				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
657:                 			}
658:                 
659:                 			vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
660:                 
661:                 			/* Increment the ucTasksDeleted variable so the idle task knows
662:                 			there is a task that has been deleted and that it should therefore
663:                 			check the xTasksWaitingTermination list. */
664:                 			++uxTasksDeleted;
665:                 
666:                 			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
667:                 			can detect that the task lists need re-generating. */
668:                 			uxTaskNumber++;
669:                 
670:                 			traceTASK_DELETE( pxTCB );
671:                 		}
672:                 		taskEXIT_CRITICAL();
673:                 
674:                 		/* Force a reschedule if we have just deleted the current task. */
675:                 		if( xSchedulerRunning != pdFALSE )
676:                 		{
677:                 			if( pxTCB == pxCurrentTCB )
678:                 			{
679:                 				portYIELD_WITHIN_API();
680:                 			}
681:                 		}
682:                 	}
683:                 
684:                 #endif /* INCLUDE_vTaskDelete */
685:                 /*-----------------------------------------------------------*/
686:                 
687:                 #if ( INCLUDE_vTaskDelayUntil == 1 )
688:                 
689:                 	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
690:                 	{
9D01ED2C  27BDFFD0   ADDIU SP, SP, -48
9D01ED30  AFBF002C   SW RA, 44(SP)
9D01ED34  AFBE0028   SW S8, 40(SP)
9D01ED38  03A0F021   ADDU S8, SP, ZERO
9D01ED3C  AFC40030   SW A0, 48(S8)
9D01ED40  AFC50034   SW A1, 52(S8)
691:                 	portTickType xTimeToWake;
692:                 	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
9D01ED44  AFC00010   SW ZERO, 16(S8)
693:                 
694:                 		configASSERT( pxPreviousWakeTime );
9D01ED48  8FC20030   LW V0, 48(S8)
9D01ED4C  14400006   BNE V0, ZERO, 0x9D01ED68
9D01ED50  00000000   NOP
9D01ED54  3C029D03   LUI V0, -25341
9D01ED58  24446054   ADDIU A0, V0, 24660
9D01ED5C  240502B6   ADDIU A1, ZERO, 694
9D01ED60  0F40C5F5   JAL vAssertCalled
9D01ED64  00000000   NOP
695:                 		configASSERT( ( xTimeIncrement > 0U ) );
9D01ED68  8FC20034   LW V0, 52(S8)
9D01ED6C  14400006   BNE V0, ZERO, 0x9D01ED88
9D01ED70  00000000   NOP
9D01ED74  3C029D03   LUI V0, -25341
9D01ED78  24446054   ADDIU A0, V0, 24660
9D01ED7C  240502B7   ADDIU A1, ZERO, 695
9D01ED80  0F40C5F5   JAL vAssertCalled
9D01ED84  00000000   NOP
696:                 
697:                 		vTaskSuspendAll();
9D01ED88  0F407E3F   JAL vTaskSuspendAll
9D01ED8C  00000000   NOP
698:                 		{
699:                 			/* Minor optimisation.  The tick count cannot change in this
700:                 			block. */
701:                 			const portTickType xConstTickCount = xTickCount;
9D01ED90  8F82809C   LW V0, -32612(GP)
9D01ED94  AFC20014   SW V0, 20(S8)
702:                 
703:                 			/* Generate the tick time at which the task wants to wake. */
704:                 			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
9D01ED98  8FC20030   LW V0, 48(S8)
9D01ED9C  8C430000   LW V1, 0(V0)
9D01EDA0  8FC20034   LW V0, 52(S8)
9D01EDA4  00621021   ADDU V0, V1, V0
9D01EDA8  AFC20018   SW V0, 24(S8)
705:                 
706:                 			if( xConstTickCount < *pxPreviousWakeTime )
9D01EDAC  8FC20030   LW V0, 48(S8)
9D01EDB0  8C430000   LW V1, 0(V0)
9D01EDB4  8FC20014   LW V0, 20(S8)
9D01EDB8  0043102B   SLTU V0, V0, V1
9D01EDBC  10400010   BEQ V0, ZERO, 0x9D01EE00
9D01EDC0  00000000   NOP
707:                 			{
708:                 				/* The tick count has overflowed since this function was
709:                 				lasted called.  In this case the only time we should ever
710:                 				actually delay is if the wake time has also	overflowed,
711:                 				and the wake time is greater than the tick time.  When this
712:                 				is the case it is as if neither time had overflowed. */
713:                 				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
9D01EDC4  8FC20030   LW V0, 48(S8)
9D01EDC8  8C430000   LW V1, 0(V0)
9D01EDCC  8FC20018   LW V0, 24(S8)
9D01EDD0  0043102B   SLTU V0, V0, V1
9D01EDD4  10400017   BEQ V0, ZERO, 0x9D01EE34
9D01EDD8  00000000   NOP
9D01EDDC  8FC30018   LW V1, 24(S8)
9D01EDE0  8FC20014   LW V0, 20(S8)
9D01EDE4  0043102B   SLTU V0, V0, V1
9D01EDE8  10400012   BEQ V0, ZERO, 0x9D01EE34
9D01EDEC  00000000   NOP
714:                 				{
715:                 					xShouldDelay = pdTRUE;
9D01EDF0  24020001   ADDIU V0, ZERO, 1
9D01EDF4  AFC20010   SW V0, 16(S8)
9D01EDF8  0B407B8D   J 0x9D01EE34
9D01EDFC  00000000   NOP
716:                 				}
717:                 			}
718:                 			else
719:                 			{
720:                 				/* The tick time has not overflowed.  In this case we will
721:                 				delay if either the wake time has overflowed, and/or the
722:                 				tick time is less than the wake time. */
723:                 				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
9D01EE00  8FC20030   LW V0, 48(S8)
9D01EE04  8C430000   LW V1, 0(V0)
9D01EE08  8FC20018   LW V0, 24(S8)
9D01EE0C  0043102B   SLTU V0, V0, V1
9D01EE10  14400006   BNE V0, ZERO, 0x9D01EE2C
9D01EE14  00000000   NOP
9D01EE18  8FC30018   LW V1, 24(S8)
9D01EE1C  8FC20014   LW V0, 20(S8)
9D01EE20  0043102B   SLTU V0, V0, V1
9D01EE24  10400003   BEQ V0, ZERO, 0x9D01EE34
9D01EE28  00000000   NOP
724:                 				{
725:                 					xShouldDelay = pdTRUE;
9D01EE2C  24020001   ADDIU V0, ZERO, 1
9D01EE30  AFC20010   SW V0, 16(S8)
726:                 				}
727:                 			}
728:                 
729:                 			/* Update the wake time ready for the next call. */
730:                 			*pxPreviousWakeTime = xTimeToWake;
9D01EE34  8FC20030   LW V0, 48(S8)
9D01EE38  8FC30018   LW V1, 24(S8)
9D01EE3C  AC430000   SW V1, 0(V0)
731:                 
732:                 			if( xShouldDelay != pdFALSE )
9D01EE40  8FC20010   LW V0, 16(S8)
9D01EE44  10400013   BEQ V0, ZERO, 0x9D01EE94
9D01EE48  00000000   NOP
733:                 			{
734:                 				traceTASK_DELAY_UNTIL();
735:                 
736:                 				/* We must remove ourselves from the ready list before adding
737:                 				ourselves to the blocked list as the same list item is used for
738:                 				both lists. */
739:                 				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( unsigned portBASE_TYPE ) 0 )
9D01EE4C  8F828094   LW V0, -32620(GP)
9D01EE50  24420004   ADDIU V0, V0, 4
9D01EE54  00402021   ADDU A0, V0, ZERO
9D01EE58  0F40D131   JAL uxListRemove
9D01EE5C  00000000   NOP
9D01EE60  14400009   BNE V0, ZERO, 0x9D01EE88
9D01EE64  00000000   NOP
740:                 				{
741:                 					/* The current task must be in a ready list, so there is
742:                 					no need to check, and the port reset macro can be called
743:                 					directly. */
744:                 					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
9D01EE68  8F828094   LW V0, -32620(GP)
9D01EE6C  8C42002C   LW V0, 44(V0)
9D01EE70  24030001   ADDIU V1, ZERO, 1
9D01EE74  00431004   SLLV V0, V1, V0
9D01EE78  00021827   NOR V1, ZERO, V0
9D01EE7C  8F8280A0   LW V0, -32608(GP)
9D01EE80  00621024   AND V0, V1, V0
9D01EE84  AF8280A0   SW V0, -32608(GP)
745:                 				}
746:                 
747:                 				prvAddCurrentTaskToDelayedList( xTimeToWake );
9D01EE88  8FC40018   LW A0, 24(S8)
9D01EE8C  0F4081E2   JAL prvAddCurrentTaskToDelayedList
9D01EE90  00000000   NOP
748:                 			}
749:                 		}
750:                 		xAlreadyYielded = xTaskResumeAll();
9D01EE94  0F407E4A   JAL xTaskResumeAll
9D01EE98  00000000   NOP
9D01EE9C  AFC2001C   SW V0, 28(S8)
751:                 
752:                 		/* Force a reschedule if xTaskResumeAll has not already done so, we may
753:                 		have put ourselves to sleep. */
754:                 		if( xAlreadyYielded == pdFALSE )
9D01EEA0  8FC2001C   LW V0, 28(S8)
9D01EEA4  14400009   BNE V0, ZERO, 0x9D01EECC
9D01EEA8  00000000   NOP
755:                 		{
756:                 			portYIELD_WITHIN_API();
9D01EEAC  40026800   MFC0 V0, Cause
9D01EEB0  AFC20020   SW V0, 32(S8)
9D01EEB4  8FC20020   LW V0, 32(S8)
9D01EEB8  34420100   ORI V0, V0, 256
9D01EEBC  AFC20020   SW V0, 32(S8)
9D01EEC0  8FC20020   LW V0, 32(S8)
9D01EEC4  40826800   MTC0 V0, Cause
9D01EEC8  000000C0   EHB
757:                 		}
758:                 	}
9D01EECC  03C0E821   ADDU SP, S8, ZERO
9D01EED0  8FBF002C   LW RA, 44(SP)
9D01EED4  8FBE0028   LW S8, 40(SP)
9D01EED8  27BD0030   ADDIU SP, SP, 48
9D01EEDC  03E00008   JR RA
9D01EEE0  00000000   NOP
759:                 
760:                 #endif /* INCLUDE_vTaskDelayUntil */
761:                 /*-----------------------------------------------------------*/
762:                 
763:                 #if ( INCLUDE_vTaskDelay == 1 )
764:                 
765:                 	void vTaskDelay( portTickType xTicksToDelay )
766:                 	{
9D01EEE4  27BDFFD8   ADDIU SP, SP, -40
9D01EEE8  AFBF0024   SW RA, 36(SP)
9D01EEEC  AFBE0020   SW S8, 32(SP)
9D01EEF0  03A0F021   ADDU S8, SP, ZERO
9D01EEF4  AFC40028   SW A0, 40(S8)
767:                 	portTickType xTimeToWake;
768:                 	signed portBASE_TYPE xAlreadyYielded = pdFALSE;
9D01EEF8  AFC00010   SW ZERO, 16(S8)
769:                 
770:                 		/* A delay time of zero just forces a reschedule. */
771:                 		if( xTicksToDelay > ( portTickType ) 0U )
9D01EEFC  8FC20028   LW V0, 40(S8)
9D01EF00  1040001C   BEQ V0, ZERO, 0x9D01EF74
9D01EF04  00000000   NOP
772:                 		{
773:                 			vTaskSuspendAll();
9D01EF08  0F407E3F   JAL vTaskSuspendAll
9D01EF0C  00000000   NOP
774:                 			{
775:                 				traceTASK_DELAY();
776:                 
777:                 				/* A task that is removed from the event list while the
778:                 				scheduler is suspended will not get placed in the ready
779:                 				list or removed from the blocked list until the scheduler
780:                 				is resumed.
781:                 
782:                 				This task cannot be in an event list as it is the currently
783:                 				executing task. */
784:                 
785:                 				/* Calculate the time to wake - this may overflow but this is
786:                 				not a problem. */
787:                 				xTimeToWake = xTickCount + xTicksToDelay;
9D01EF10  8F83809C   LW V1, -32612(GP)
9D01EF14  8FC20028   LW V0, 40(S8)
9D01EF18  00621021   ADDU V0, V1, V0
9D01EF1C  AFC20014   SW V0, 20(S8)
788:                 
789:                 				/* We must remove ourselves from the ready list before adding
790:                 				ourselves to the blocked list as the same list item is used for
791:                 				both lists. */
792:                 				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( unsigned portBASE_TYPE ) 0 )
9D01EF20  8F828094   LW V0, -32620(GP)
9D01EF24  24420004   ADDIU V0, V0, 4
9D01EF28  00402021   ADDU A0, V0, ZERO
9D01EF2C  0F40D131   JAL uxListRemove
9D01EF30  00000000   NOP
9D01EF34  14400009   BNE V0, ZERO, 0x9D01EF5C
9D01EF38  00000000   NOP
793:                 				{
794:                 					/* The current task must be in a ready list, so there is
795:                 					no need to check, and the port reset macro can be called
796:                 					directly. */
797:                 					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
9D01EF3C  8F828094   LW V0, -32620(GP)
9D01EF40  8C42002C   LW V0, 44(V0)
9D01EF44  24030001   ADDIU V1, ZERO, 1
9D01EF48  00431004   SLLV V0, V1, V0
9D01EF4C  00021827   NOR V1, ZERO, V0
9D01EF50  8F8280A0   LW V0, -32608(GP)
9D01EF54  00621024   AND V0, V1, V0
9D01EF58  AF8280A0   SW V0, -32608(GP)
798:                 				}
799:                 				prvAddCurrentTaskToDelayedList( xTimeToWake );
9D01EF5C  8FC40014   LW A0, 20(S8)
9D01EF60  0F4081E2   JAL prvAddCurrentTaskToDelayedList
9D01EF64  00000000   NOP
800:                 			}
801:                 			xAlreadyYielded = xTaskResumeAll();
9D01EF68  0F407E4A   JAL xTaskResumeAll
9D01EF6C  00000000   NOP
9D01EF70  AFC20010   SW V0, 16(S8)
802:                 		}
803:                 
804:                 		/* Force a reschedule if xTaskResumeAll has not already done so, we may
805:                 		have put ourselves to sleep. */
806:                 		if( xAlreadyYielded == pdFALSE )
9D01EF74  8FC20010   LW V0, 16(S8)
9D01EF78  14400009   BNE V0, ZERO, 0x9D01EFA0
9D01EF7C  00000000   NOP
807:                 		{
808:                 			portYIELD_WITHIN_API();
9D01EF80  40026800   MFC0 V0, Cause
9D01EF84  AFC20018   SW V0, 24(S8)
9D01EF88  8FC20018   LW V0, 24(S8)
9D01EF8C  34420100   ORI V0, V0, 256
9D01EF90  AFC20018   SW V0, 24(S8)
9D01EF94  8FC20018   LW V0, 24(S8)
9D01EF98  40826800   MTC0 V0, Cause
9D01EF9C  000000C0   EHB
809:                 		}
810:                 	}
9D01EFA0  03C0E821   ADDU SP, S8, ZERO
9D01EFA4  8FBF0024   LW RA, 36(SP)
9D01EFA8  8FBE0020   LW S8, 32(SP)
9D01EFAC  27BD0028   ADDIU SP, SP, 40
9D01EFB0  03E00008   JR RA
9D01EFB4  00000000   NOP
811:                 
812:                 #endif /* INCLUDE_vTaskDelay */
813:                 /*-----------------------------------------------------------*/
814:                 
815:                 #if ( INCLUDE_eTaskGetState == 1 )
816:                 
817:                 	eTaskState eTaskGetState( xTaskHandle xTask )
818:                 	{
819:                 	eTaskState eReturn;
820:                 	xList *pxStateList;
821:                 	const tskTCB * const pxTCB = ( tskTCB * ) xTask;
822:                 
823:                 		if( pxTCB == pxCurrentTCB )
824:                 		{
825:                 			/* The task calling this function is querying its own state. */
826:                 			eReturn = eRunning;
827:                 		}
828:                 		else
829:                 		{
830:                 			taskENTER_CRITICAL();
831:                 			{
832:                 				pxStateList = ( xList * ) listLIST_ITEM_CONTAINER( &( pxTCB->xGenericListItem ) );
833:                 			}
834:                 			taskEXIT_CRITICAL();
835:                 
836:                 			if( ( pxStateList == pxDelayedTaskList ) || ( pxStateList == pxOverflowDelayedTaskList ) )
837:                 			{
838:                 				/* The task being queried is referenced from one of the Blocked
839:                 				lists. */
840:                 				eReturn = eBlocked;
841:                 			}
842:                 
843:                 			#if ( INCLUDE_vTaskSuspend == 1 )
844:                 				else if( pxStateList == &xSuspendedTaskList )
845:                 				{
846:                 					/* The task being queried is referenced from the suspended
847:                 					list. */
848:                 					eReturn = eSuspended;
849:                 				}
850:                 			#endif
851:                 
852:                 			#if ( INCLUDE_vTaskDelete == 1 )
853:                 				else if( pxStateList == &xTasksWaitingTermination )
854:                 				{
855:                 					/* The task being queried is referenced from the deleted
856:                 					tasks list. */
857:                 					eReturn = eDeleted;
858:                 				}
859:                 			#endif
860:                 
861:                 			else
862:                 			{
863:                 				/* If the task is not in any other state, it must be in the
864:                 				Ready (including pending ready) state. */
865:                 				eReturn = eReady;
866:                 			}
867:                 		}
868:                 
869:                 		return eReturn;
870:                 	}
871:                 
872:                 #endif /* INCLUDE_eTaskGetState */
873:                 /*-----------------------------------------------------------*/
874:                 
875:                 #if ( INCLUDE_uxTaskPriorityGet == 1 )
876:                 
877:                 	unsigned portBASE_TYPE uxTaskPriorityGet( xTaskHandle xTask )
878:                 	{
9D01EFB8  27BDFFE0   ADDIU SP, SP, -32
9D01EFBC  AFBF001C   SW RA, 28(SP)
9D01EFC0  AFBE0018   SW S8, 24(SP)
9D01EFC4  03A0F021   ADDU S8, SP, ZERO
9D01EFC8  AFC40020   SW A0, 32(S8)
879:                 	tskTCB *pxTCB;
880:                 	unsigned portBASE_TYPE uxReturn;
881:                 
882:                 		taskENTER_CRITICAL();
9D01EFCC  0F40834C   JAL vTaskEnterCritical
9D01EFD0  00000000   NOP
883:                 		{
884:                 			/* If null is passed in here then we are changing the
885:                 			priority of the calling function. */
886:                 			pxTCB = prvGetTCBFromHandle( xTask );
9D01EFD4  8FC20020   LW V0, 32(S8)
9D01EFD8  14400004   BNE V0, ZERO, 0x9D01EFEC
9D01EFDC  00000000   NOP
9D01EFE0  8F828094   LW V0, -32620(GP)
9D01EFE4  0B407BFC   J 0x9D01EFF0
9D01EFE8  00000000   NOP
9D01EFEC  8FC20020   LW V0, 32(S8)
9D01EFF0  AFC20010   SW V0, 16(S8)
887:                 			uxReturn = pxTCB->uxPriority;
9D01EFF4  8FC20010   LW V0, 16(S8)
9D01EFF8  8C42002C   LW V0, 44(V0)
9D01EFFC  AFC20014   SW V0, 20(S8)
888:                 		}
889:                 		taskEXIT_CRITICAL();
9D01F000  0F40836C   JAL vTaskExitCritical
9D01F004  00000000   NOP
890:                 
891:                 		return uxReturn;
9D01F008  8FC20014   LW V0, 20(S8)
892:                 	}
9D01F00C  03C0E821   ADDU SP, S8, ZERO
9D01F010  8FBF001C   LW RA, 28(SP)
9D01F014  8FBE0018   LW S8, 24(SP)
9D01F018  27BD0020   ADDIU SP, SP, 32
9D01F01C  03E00008   JR RA
9D01F020  00000000   NOP
893:                 
894:                 #endif /* INCLUDE_uxTaskPriorityGet */
895:                 /*-----------------------------------------------------------*/
896:                 
897:                 #if ( INCLUDE_vTaskPrioritySet == 1 )
898:                 
899:                 	void vTaskPrioritySet( xTaskHandle xTask, unsigned portBASE_TYPE uxNewPriority )
900:                 	{
9D01F024  27BDFFD0   ADDIU SP, SP, -48
9D01F028  AFBF002C   SW RA, 44(SP)
9D01F02C  AFBE0028   SW S8, 40(SP)
9D01F030  03A0F021   ADDU S8, SP, ZERO
9D01F034  AFC40030   SW A0, 48(S8)
9D01F038  AFC50034   SW A1, 52(S8)
901:                 	tskTCB *pxTCB;
902:                 	unsigned portBASE_TYPE uxCurrentBasePriority, uxPriorityUsedOnEntry;
903:                 	portBASE_TYPE xYieldRequired = pdFALSE;
9D01F03C  AFC00010   SW ZERO, 16(S8)
904:                 
905:                 		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );
9D01F040  8FC20034   LW V0, 52(S8)
9D01F044  2C420005   SLTIU V0, V0, 5
9D01F048  14400006   BNE V0, ZERO, 0x9D01F064
9D01F04C  00000000   NOP
9D01F050  3C029D03   LUI V0, -25341
9D01F054  24446054   ADDIU A0, V0, 24660
9D01F058  24050389   ADDIU A1, ZERO, 905
9D01F05C  0F40C5F5   JAL vAssertCalled
9D01F060  00000000   NOP
906:                 
907:                 		/* Ensure the new priority is valid. */
908:                 		if( uxNewPriority >= ( unsigned portBASE_TYPE ) configMAX_PRIORITIES )
9D01F064  8FC20034   LW V0, 52(S8)
9D01F068  2C420005   SLTIU V0, V0, 5
9D01F06C  14400003   BNE V0, ZERO, 0x9D01F07C
9D01F070  00000000   NOP
909:                 		{
910:                 			uxNewPriority = ( unsigned portBASE_TYPE ) configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
9D01F074  24020004   ADDIU V0, ZERO, 4
9D01F078  AFC20034   SW V0, 52(S8)
911:                 		}
912:                 
913:                 		taskENTER_CRITICAL();
9D01F07C  0F40834C   JAL vTaskEnterCritical
9D01F080  00000000   NOP
914:                 		{
915:                 			/* If null is passed in here then it is the priority of the calling
916:                 			task that is being changed. */
917:                 			pxTCB = prvGetTCBFromHandle( xTask );
9D01F084  8FC20030   LW V0, 48(S8)
9D01F088  14400004   BNE V0, ZERO, 0x9D01F09C
9D01F08C  00000000   NOP
9D01F090  8F828094   LW V0, -32620(GP)
9D01F094  0B407C28   J 0x9D01F0A0
9D01F098  00000000   NOP
9D01F09C  8FC20030   LW V0, 48(S8)
9D01F0A0  AFC20014   SW V0, 20(S8)
918:                 
919:                 			traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );
920:                 
921:                 			#if ( configUSE_MUTEXES == 1 )
922:                 			{
923:                 				uxCurrentBasePriority = pxTCB->uxBasePriority;
9D01F0A4  8FC20014   LW V0, 20(S8)
9D01F0A8  8C420040   LW V0, 64(V0)
9D01F0AC  AFC20018   SW V0, 24(S8)
924:                 			}
925:                 			#else
926:                 			{
927:                 				uxCurrentBasePriority = pxTCB->uxPriority;
928:                 			}
929:                 			#endif
930:                 
931:                 			if( uxCurrentBasePriority != uxNewPriority )
9D01F0B0  8FC30018   LW V1, 24(S8)
9D01F0B4  8FC20034   LW V0, 52(S8)
9D01F0B8  1062006C   BEQ V1, V0, 0x9D01F26C
9D01F0BC  00000000   NOP
932:                 			{
933:                 				/* The priority change may have readied a task of higher
934:                 				priority than the calling task. */
935:                 				if( uxNewPriority > uxCurrentBasePriority )
9D01F0C0  8FC30034   LW V1, 52(S8)
9D01F0C4  8FC20018   LW V0, 24(S8)
9D01F0C8  0043102B   SLTU V0, V0, V1
9D01F0CC  1040000F   BEQ V0, ZERO, 0x9D01F10C
9D01F0D0  00000000   NOP
936:                 				{
937:                 					if( pxTCB != pxCurrentTCB )
9D01F0D4  8F828094   LW V0, -32620(GP)
9D01F0D8  8FC30014   LW V1, 20(S8)
9D01F0DC  10620011   BEQ V1, V0, 0x9D01F124
9D01F0E0  00000000   NOP
938:                 					{
939:                 						/* The priority of a task other than the currently
940:                 						running task is being raised.  Is the priority being
941:                 						raised above that of the running task? */
942:                 						if( uxNewPriority >= pxCurrentTCB->uxPriority )
9D01F0E4  8F828094   LW V0, -32620(GP)
9D01F0E8  8C43002C   LW V1, 44(V0)
9D01F0EC  8FC20034   LW V0, 52(S8)
9D01F0F0  0043102B   SLTU V0, V0, V1
9D01F0F4  1440000B   BNE V0, ZERO, 0x9D01F124
9D01F0F8  00000000   NOP
943:                 						{
944:                 							xYieldRequired = pdTRUE;
9D01F0FC  24020001   ADDIU V0, ZERO, 1
9D01F100  AFC20010   SW V0, 16(S8)
9D01F104  0B407C49   J 0x9D01F124
9D01F108  00000000   NOP
945:                 						}
946:                 					}
947:                 					else
948:                 					{
949:                 						/* The priority of the running task is being raised,
950:                 						but the running task must already be the highest
951:                 						priority task able to run so no yield is required. */
952:                 					}
953:                 				}
954:                 				else if( pxTCB == pxCurrentTCB )
9D01F10C  8F828094   LW V0, -32620(GP)
9D01F110  8FC30014   LW V1, 20(S8)
9D01F114  14620003   BNE V1, V0, 0x9D01F124
9D01F118  00000000   NOP
955:                 				{
956:                 					/* Setting the priority of the running task down means
957:                 					there may now be another task of higher priority that
958:                 					is ready to execute. */
959:                 					xYieldRequired = pdTRUE;
9D01F11C  24020001   ADDIU V0, ZERO, 1
9D01F120  AFC20010   SW V0, 16(S8)
960:                 				}
961:                 				else
962:                 				{
963:                 					/* Setting the priority of any other task down does not
964:                 					require a yield as the running task must be above the
965:                 					new priority of the task being modified. */
966:                 				}
967:                 
968:                 				/* Remember the ready list the task might be referenced from
969:                 				before its uxPriority member is changed so the
970:                 				taskRESET_READY_PRIORITY() macro can function correctly. */
971:                 				uxPriorityUsedOnEntry = pxTCB->uxPriority;
9D01F124  8FC20014   LW V0, 20(S8)
9D01F128  8C42002C   LW V0, 44(V0)
9D01F12C  AFC2001C   SW V0, 28(S8)
972:                 
973:                 				#if ( configUSE_MUTEXES == 1 )
974:                 				{
975:                 					/* Only change the priority being used if the task is not
976:                 					currently using an inherited priority. */
977:                 					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
9D01F130  8FC20014   LW V0, 20(S8)
9D01F134  8C430040   LW V1, 64(V0)
9D01F138  8FC20014   LW V0, 20(S8)
9D01F13C  8C42002C   LW V0, 44(V0)
9D01F140  14620004   BNE V1, V0, 0x9D01F154
9D01F144  00000000   NOP
978:                 					{
979:                 						pxTCB->uxPriority = uxNewPriority;
9D01F148  8FC20014   LW V0, 20(S8)
9D01F14C  8FC30034   LW V1, 52(S8)
9D01F150  AC43002C   SW V1, 44(V0)
980:                 					}
981:                 
982:                 					/* The base priority gets set whatever. */
983:                 					pxTCB->uxBasePriority = uxNewPriority;
9D01F154  8FC20014   LW V0, 20(S8)
9D01F158  8FC30034   LW V1, 52(S8)
9D01F15C  AC430040   SW V1, 64(V0)
984:                 				}
985:                 				#else
986:                 				{
987:                 					pxTCB->uxPriority = uxNewPriority;
988:                 				}
989:                 				#endif
990:                 
991:                 				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( portTickType ) configMAX_PRIORITIES - ( portTickType ) uxNewPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
9D01F160  24030005   ADDIU V1, ZERO, 5
9D01F164  8FC20034   LW V0, 52(S8)
9D01F168  00621823   SUBU V1, V1, V0
9D01F16C  8FC20014   LW V0, 20(S8)
9D01F170  AC430018   SW V1, 24(V0)
992:                 
993:                 				/* If the task is in the blocked or suspended list we need do
994:                 				nothing more than change it's priority variable. However, if
995:                 				the task is in a ready list it needs to be removed and placed
996:                 				in the list appropriate to its new priority. */
997:                 				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
9D01F174  8FC20014   LW V0, 20(S8)
9D01F178  8C430014   LW V1, 20(V0)
9D01F17C  8FC4001C   LW A0, 28(S8)
9D01F180  24020014   ADDIU V0, ZERO, 20
9D01F184  70822002   MUL A0, A0, V0
9D01F188  3C02A000   LUI V0, -24576
9D01F18C  24420480   ADDIU V0, V0, 1152
9D01F190  00821021   ADDU V0, A0, V0
9D01F194  14620004   BNE V1, V0, 0x9D01F1A8
9D01F198  00000000   NOP
9D01F19C  24020001   ADDIU V0, ZERO, 1
9D01F1A0  0B407C6B   J 0x9D01F1AC
9D01F1A4  00000000   NOP
9D01F1A8  00001021   ADDU V0, ZERO, ZERO
9D01F1AC  10400023   BEQ V0, ZERO, 0x9D01F23C
9D01F1B0  00000000   NOP
998:                 				{
999:                 					/* The task is currently in its ready list - remove before adding
1000:                					it to it's new ready list.  As we are in a critical section we
1001:                					can do this even if the scheduler is suspended. */
1002:                					if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( unsigned portBASE_TYPE ) 0 )
9D01F1B4  8FC20014   LW V0, 20(S8)
9D01F1B8  24420004   ADDIU V0, V0, 4
9D01F1BC  00402021   ADDU A0, V0, ZERO
9D01F1C0  0F40D131   JAL uxListRemove
9D01F1C4  00000000   NOP
9D01F1C8  14400008   BNE V0, ZERO, 0x9D01F1EC
9D01F1CC  00000000   NOP
1003:                					{
1004:                						/* It is known that the task is in its ready list so
1005:                						there is no need to check again and the port level
1006:                						reset macro can be called directly. */
1007:                						portRESET_READY_PRIORITY( uxPriorityUsedOnEntry, uxTopReadyPriority );
9D01F1D0  8FC2001C   LW V0, 28(S8)
9D01F1D4  24030001   ADDIU V1, ZERO, 1
9D01F1D8  00431004   SLLV V0, V1, V0
9D01F1DC  00021827   NOR V1, ZERO, V0
9D01F1E0  8F8280A0   LW V0, -32608(GP)
9D01F1E4  00621024   AND V0, V1, V0
9D01F1E8  AF8280A0   SW V0, -32608(GP)
1008:                					}
1009:                					prvAddTaskToReadyList( pxTCB );
9D01F1EC  8FC20014   LW V0, 20(S8)
9D01F1F0  8C42002C   LW V0, 44(V0)
9D01F1F4  24030001   ADDIU V1, ZERO, 1
9D01F1F8  00431804   SLLV V1, V1, V0
9D01F1FC  8F8280A0   LW V0, -32608(GP)
9D01F200  00621025   OR V0, V1, V0
9D01F204  AF8280A0   SW V0, -32608(GP)
9D01F208  8FC20014   LW V0, 20(S8)
9D01F20C  8C43002C   LW V1, 44(V0)
9D01F210  24020014   ADDIU V0, ZERO, 20
9D01F214  70621802   MUL V1, V1, V0
9D01F218  3C02A000   LUI V0, -24576
9D01F21C  24420480   ADDIU V0, V0, 1152
9D01F220  00621821   ADDU V1, V1, V0
9D01F224  8FC20014   LW V0, 20(S8)
9D01F228  24420004   ADDIU V0, V0, 4
9D01F22C  00602021   ADDU A0, V1, ZERO
9D01F230  00402821   ADDU A1, V0, ZERO
9D01F234  0F40D0D3   JAL vListInsertEnd
9D01F238  00000000   NOP
1010:                				}
1011:                
1012:                				if( xYieldRequired == pdTRUE )
9D01F23C  8FC30010   LW V1, 16(S8)
9D01F240  24020001   ADDIU V0, ZERO, 1
9D01F244  14620009   BNE V1, V0, 0x9D01F26C
9D01F248  00000000   NOP
1013:                				{
1014:                					portYIELD_WITHIN_API();
9D01F24C  40026800   MFC0 V0, Cause
9D01F250  AFC20020   SW V0, 32(S8)
9D01F254  8FC20020   LW V0, 32(S8)
9D01F258  34420100   ORI V0, V0, 256
9D01F25C  AFC20020   SW V0, 32(S8)
9D01F260  8FC20020   LW V0, 32(S8)
9D01F264  40826800   MTC0 V0, Cause
9D01F268  000000C0   EHB
1015:                				}
1016:                
1017:                				/* Remove compiler warning about unused variables when the port
1018:                				optimised task selection is not being used. */
1019:                				( void ) uxPriorityUsedOnEntry;
1020:                			}
1021:                		}
1022:                		taskEXIT_CRITICAL();
9D01F26C  0F40836C   JAL vTaskExitCritical
9D01F270  00000000   NOP
1023:                	}
9D01F274  03C0E821   ADDU SP, S8, ZERO
9D01F278  8FBF002C   LW RA, 44(SP)
9D01F27C  8FBE0028   LW S8, 40(SP)
9D01F280  27BD0030   ADDIU SP, SP, 48
9D01F284  03E00008   JR RA
9D01F288  00000000   NOP
1024:                
1025:                #endif /* INCLUDE_vTaskPrioritySet */
1026:                /*-----------------------------------------------------------*/
1027:                
1028:                #if ( INCLUDE_vTaskSuspend == 1 )
1029:                
1030:                	void vTaskSuspend( xTaskHandle xTaskToSuspend )
1031:                	{
9D01F28C  27BDFFE0   ADDIU SP, SP, -32
9D01F290  AFBF001C   SW RA, 28(SP)
9D01F294  AFBE0018   SW S8, 24(SP)
9D01F298  03A0F021   ADDU S8, SP, ZERO
9D01F29C  AFC40020   SW A0, 32(S8)
1032:                	tskTCB *pxTCB;
1033:                
1034:                		taskENTER_CRITICAL();
9D01F2A0  0F40834C   JAL vTaskEnterCritical
9D01F2A4  00000000   NOP
1035:                		{
1036:                			/* If null is passed in here then it is the running task that is
1037:                			being suspended. */
1038:                			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
9D01F2A8  8FC20020   LW V0, 32(S8)
9D01F2AC  14400004   BNE V0, ZERO, 0x9D01F2C0
9D01F2B0  00000000   NOP
9D01F2B4  8F828094   LW V0, -32620(GP)
9D01F2B8  0B407CB1   J 0x9D01F2C4
9D01F2BC  00000000   NOP
9D01F2C0  8FC20020   LW V0, 32(S8)
9D01F2C4  AFC20010   SW V0, 16(S8)
1039:                
1040:                			traceTASK_SUSPEND( pxTCB );
1041:                
1042:                			/* Remove task from the ready/delayed list and place in the	suspended list. */
1043:                			if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( unsigned portBASE_TYPE ) 0 )
9D01F2C8  8FC20010   LW V0, 16(S8)
9D01F2CC  24420004   ADDIU V0, V0, 4
9D01F2D0  00402021   ADDU A0, V0, ZERO
9D01F2D4  0F40D131   JAL uxListRemove
9D01F2D8  00000000   NOP
9D01F2DC  14400013   BNE V0, ZERO, 0x9D01F32C
9D01F2E0  00000000   NOP
1044:                			{
1045:                				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
9D01F2E4  8FC20010   LW V0, 16(S8)
9D01F2E8  8C43002C   LW V1, 44(V0)
9D01F2EC  24020014   ADDIU V0, ZERO, 20
9D01F2F0  70621802   MUL V1, V1, V0
9D01F2F4  3C02A000   LUI V0, -24576
9D01F2F8  24420480   ADDIU V0, V0, 1152
9D01F2FC  00621021   ADDU V0, V1, V0
9D01F300  8C420000   LW V0, 0(V0)
9D01F304  14400009   BNE V0, ZERO, 0x9D01F32C
9D01F308  00000000   NOP
9D01F30C  8FC20010   LW V0, 16(S8)
9D01F310  8C42002C   LW V0, 44(V0)
9D01F314  24030001   ADDIU V1, ZERO, 1
9D01F318  00431004   SLLV V0, V1, V0
9D01F31C  00021827   NOR V1, ZERO, V0
9D01F320  8F8280A0   LW V0, -32608(GP)
9D01F324  00621024   AND V0, V1, V0
9D01F328  AF8280A0   SW V0, -32608(GP)
1046:                			}
1047:                
1048:                			/* Is the task waiting on an event also? */
1049:                			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
9D01F32C  8FC20010   LW V0, 16(S8)
9D01F330  8C420028   LW V0, 40(V0)
9D01F334  10400006   BEQ V0, ZERO, 0x9D01F350
9D01F338  00000000   NOP
1050:                			{
1051:                				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
9D01F33C  8FC20010   LW V0, 16(S8)
9D01F340  24420018   ADDIU V0, V0, 24
9D01F344  00402021   ADDU A0, V0, ZERO
9D01F348  0F40D131   JAL uxListRemove
9D01F34C  00000000   NOP
1052:                			}
1053:                
1054:                			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) );
9D01F350  8FC20010   LW V0, 16(S8)
9D01F354  24420004   ADDIU V0, V0, 4
9D01F358  3C03A000   LUI V1, -24576
9D01F35C  246404F8   ADDIU A0, V1, 1272
9D01F360  00402821   ADDU A1, V0, ZERO
9D01F364  0F40D0D3   JAL vListInsertEnd
9D01F368  00000000   NOP
1055:                		}
1056:                		taskEXIT_CRITICAL();
9D01F36C  0F40836C   JAL vTaskExitCritical
9D01F370  00000000   NOP
1057:                
1058:                		if( pxTCB == pxCurrentTCB )
9D01F374  8F828094   LW V0, -32620(GP)
9D01F378  8FC30010   LW V1, 16(S8)
9D01F37C  14620018   BNE V1, V0, 0x9D01F3E0
9D01F380  00000000   NOP
1059:                		{
1060:                			if( xSchedulerRunning != pdFALSE )
9D01F384  8F8280A4   LW V0, -32604(GP)
9D01F388  1040000B   BEQ V0, ZERO, 0x9D01F3B8
9D01F38C  00000000   NOP
1061:                			{
1062:                				/* The current task has just been suspended. */
1063:                				portYIELD_WITHIN_API();
9D01F390  40026800   MFC0 V0, Cause
9D01F394  AFC20014   SW V0, 20(S8)
9D01F398  8FC20014   LW V0, 20(S8)
9D01F39C  34420100   ORI V0, V0, 256
9D01F3A0  AFC20014   SW V0, 20(S8)
9D01F3A4  8FC20014   LW V0, 20(S8)
9D01F3A8  40826800   MTC0 V0, Cause
9D01F3AC  000000C0   EHB
9D01F3B0  0B407CF8   J 0x9D01F3E0
9D01F3B4  00000000   NOP
1064:                			}
1065:                			else
1066:                			{
1067:                				/* The scheduler is not running, but the task that was pointed
1068:                				to by pxCurrentTCB has just been suspended and pxCurrentTCB
1069:                				must be adjusted to point to a different task. */
1070:                				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
9D01F3B8  3C02A000   LUI V0, -24576
9D01F3BC  8C4304F8   LW V1, 1272(V0)
9D01F3C0  8F828098   LW V0, -32616(GP)
9D01F3C4  14620004   BNE V1, V0, 0x9D01F3D8
9D01F3C8  00000000   NOP
1071:                				{
1072:                					/* No other tasks are ready, so set pxCurrentTCB back to
1073:                					NULL so when the next task is created pxCurrentTCB will
1074:                					be set to point to it no matter what its relative priority
1075:                					is. */
1076:                					pxCurrentTCB = NULL;
9D01F3CC  AF808094   SW ZERO, -32620(GP)
9D01F3D0  0B407CF8   J 0x9D01F3E0
9D01F3D4  00000000   NOP
1077:                				}
1078:                				else
1079:                				{
1080:                					vTaskSwitchContext();
9D01F3D8  0F407F9C   JAL vTaskSwitchContext
9D01F3DC  00000000   NOP
1081:                				}
1082:                			}
1083:                		}
1084:                	}
9D01F3E0  03C0E821   ADDU SP, S8, ZERO
9D01F3E4  8FBF001C   LW RA, 28(SP)
9D01F3E8  8FBE0018   LW S8, 24(SP)
9D01F3EC  27BD0020   ADDIU SP, SP, 32
9D01F3F0  03E00008   JR RA
9D01F3F4  00000000   NOP
1085:                
1086:                #endif /* INCLUDE_vTaskSuspend */
1087:                /*-----------------------------------------------------------*/
1088:                
1089:                #if ( INCLUDE_vTaskSuspend == 1 )
1090:                
1091:                	signed portBASE_TYPE xTaskIsTaskSuspended( xTaskHandle xTask )
1092:                	{
9D01F3F8  27BDFFE0   ADDIU SP, SP, -32
9D01F3FC  AFBF001C   SW RA, 28(SP)
9D01F400  AFBE0018   SW S8, 24(SP)
9D01F404  03A0F021   ADDU S8, SP, ZERO
9D01F408  AFC40020   SW A0, 32(S8)
1093:                	portBASE_TYPE xReturn = pdFALSE;
9D01F40C  AFC00010   SW ZERO, 16(S8)
1094:                	const tskTCB * const pxTCB = ( tskTCB * ) xTask;
9D01F410  8FC20020   LW V0, 32(S8)
9D01F414  AFC20014   SW V0, 20(S8)
1095:                
1096:                		/* It does not make sense to check if the calling task is suspended. */
1097:                		configASSERT( xTask );
9D01F418  8FC20020   LW V0, 32(S8)
9D01F41C  14400006   BNE V0, ZERO, 0x9D01F438
9D01F420  00000000   NOP
9D01F424  3C029D03   LUI V0, -25341
9D01F428  24446054   ADDIU A0, V0, 24660
9D01F42C  24050449   ADDIU A1, ZERO, 1097
9D01F430  0F40C5F5   JAL vAssertCalled
9D01F434  00000000   NOP
1098:                
1099:                		/* Is the task we are attempting to resume actually in the
1100:                		suspended list? */
1101:                		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
9D01F438  8FC20014   LW V0, 20(S8)
9D01F43C  8C430014   LW V1, 20(V0)
9D01F440  3C02A000   LUI V0, -24576
9D01F444  244204F8   ADDIU V0, V0, 1272
9D01F448  14620004   BNE V1, V0, 0x9D01F45C
9D01F44C  00000000   NOP
9D01F450  24020001   ADDIU V0, ZERO, 1
9D01F454  0B407D18   J 0x9D01F460
9D01F458  00000000   NOP
9D01F45C  00001021   ADDU V0, ZERO, ZERO
9D01F460  10400013   BEQ V0, ZERO, 0x9D01F4B0
9D01F464  00000000   NOP
1102:                		{
1103:                			/* Has the task already been resumed from within an ISR? */
1104:                			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
9D01F468  8FC20014   LW V0, 20(S8)
9D01F46C  8C430028   LW V1, 40(V0)
9D01F470  3C02A000   LUI V0, -24576
9D01F474  244204E4   ADDIU V0, V0, 1252
9D01F478  1062000D   BEQ V1, V0, 0x9D01F4B0
9D01F47C  00000000   NOP
1105:                			{
1106:                				/* Is it in the suspended list because it is in the
1107:                				Suspended state?  It is possible to be in the suspended
1108:                				list because it is blocked on a task with no timeout
1109:                				specified. */
1110:                				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE )
9D01F480  8FC20014   LW V0, 20(S8)
9D01F484  8C420028   LW V0, 40(V0)
9D01F488  14400004   BNE V0, ZERO, 0x9D01F49C
9D01F48C  00000000   NOP
9D01F490  24020001   ADDIU V0, ZERO, 1
9D01F494  0B407D28   J 0x9D01F4A0
9D01F498  00000000   NOP
9D01F49C  00001021   ADDU V0, ZERO, ZERO
9D01F4A0  10400003   BEQ V0, ZERO, 0x9D01F4B0
9D01F4A4  00000000   NOP
1111:                				{
1112:                					xReturn = pdTRUE;
9D01F4A8  24020001   ADDIU V0, ZERO, 1
9D01F4AC  AFC20010   SW V0, 16(S8)
1113:                				}
1114:                			}
1115:                		}
1116:                
1117:                		return xReturn;
9D01F4B0  8FC20010   LW V0, 16(S8)
1118:                	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
9D01F4B4  03C0E821   ADDU SP, S8, ZERO
9D01F4B8  8FBF001C   LW RA, 28(SP)
9D01F4BC  8FBE0018   LW S8, 24(SP)
9D01F4C0  27BD0020   ADDIU SP, SP, 32
9D01F4C4  03E00008   JR RA
9D01F4C8  00000000   NOP
1119:                
1120:                #endif /* INCLUDE_vTaskSuspend */
1121:                /*-----------------------------------------------------------*/
1122:                
1123:                #if ( INCLUDE_vTaskSuspend == 1 )
1124:                
1125:                	void vTaskResume( xTaskHandle xTaskToResume )
1126:                	{
9D01F4CC  27BDFFE0   ADDIU SP, SP, -32
9D01F4D0  AFBF001C   SW RA, 28(SP)
9D01F4D4  AFBE0018   SW S8, 24(SP)
9D01F4D8  03A0F021   ADDU S8, SP, ZERO
9D01F4DC  AFC40020   SW A0, 32(S8)
1127:                	tskTCB * const pxTCB = ( tskTCB * ) xTaskToResume;
9D01F4E0  8FC20020   LW V0, 32(S8)
9D01F4E4  AFC20010   SW V0, 16(S8)
1128:                
1129:                		/* It does not make sense to resume the calling task. */
1130:                		configASSERT( xTaskToResume );
9D01F4E8  8FC20020   LW V0, 32(S8)
9D01F4EC  14400006   BNE V0, ZERO, 0x9D01F508
9D01F4F0  00000000   NOP
9D01F4F4  3C029D03   LUI V0, -25341
9D01F4F8  24446054   ADDIU A0, V0, 24660
9D01F4FC  2405046A   ADDIU A1, ZERO, 1130
9D01F500  0F40C5F5   JAL vAssertCalled
9D01F504  00000000   NOP
1131:                
1132:                		/* The parameter cannot be NULL as it is impossible to resume the
1133:                		currently executing task. */
1134:                		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
9D01F508  8FC20010   LW V0, 16(S8)
9D01F50C  10400038   BEQ V0, ZERO, 0x9D01F5F0
9D01F510  00000000   NOP
9D01F514  8F828094   LW V0, -32620(GP)
9D01F518  8FC30010   LW V1, 16(S8)
9D01F51C  10620034   BEQ V1, V0, 0x9D01F5F0
9D01F520  00000000   NOP
1135:                		{
1136:                			taskENTER_CRITICAL();
9D01F524  0F40834C   JAL vTaskEnterCritical
9D01F528  00000000   NOP
1137:                			{
1138:                				if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
9D01F52C  8FC40010   LW A0, 16(S8)
9D01F530  0F407CFE   JAL xTaskIsTaskSuspended
9D01F534  00000000   NOP
9D01F538  00401821   ADDU V1, V0, ZERO
9D01F53C  24020001   ADDIU V0, ZERO, 1
9D01F540  14620029   BNE V1, V0, 0x9D01F5E8
9D01F544  00000000   NOP
1139:                				{
1140:                					traceTASK_RESUME( pxTCB );
1141:                
1142:                					/* As we are in a critical section we can access the ready
1143:                					lists even if the scheduler is suspended. */
1144:                					( void ) uxListRemove(  &( pxTCB->xGenericListItem ) );
9D01F548  8FC20010   LW V0, 16(S8)
9D01F54C  24420004   ADDIU V0, V0, 4
9D01F550  00402021   ADDU A0, V0, ZERO
9D01F554  0F40D131   JAL uxListRemove
9D01F558  00000000   NOP
1145:                					prvAddTaskToReadyList( pxTCB );
9D01F55C  8FC20010   LW V0, 16(S8)
9D01F560  8C42002C   LW V0, 44(V0)
9D01F564  24030001   ADDIU V1, ZERO, 1
9D01F568  00431804   SLLV V1, V1, V0
9D01F56C  8F8280A0   LW V0, -32608(GP)
9D01F570  00621025   OR V0, V1, V0
9D01F574  AF8280A0   SW V0, -32608(GP)
9D01F578  8FC20010   LW V0, 16(S8)
9D01F57C  8C43002C   LW V1, 44(V0)
9D01F580  24020014   ADDIU V0, ZERO, 20
9D01F584  70621802   MUL V1, V1, V0
9D01F588  3C02A000   LUI V0, -24576
9D01F58C  24420480   ADDIU V0, V0, 1152
9D01F590  00621821   ADDU V1, V1, V0
9D01F594  8FC20010   LW V0, 16(S8)
9D01F598  24420004   ADDIU V0, V0, 4
9D01F59C  00602021   ADDU A0, V1, ZERO
9D01F5A0  00402821   ADDU A1, V0, ZERO
9D01F5A4  0F40D0D3   JAL vListInsertEnd
9D01F5A8  00000000   NOP
1146:                
1147:                					/* We may have just resumed a higher priority task. */
1148:                					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
9D01F5AC  8FC20010   LW V0, 16(S8)
9D01F5B0  8C43002C   LW V1, 44(V0)
9D01F5B4  8F828094   LW V0, -32620(GP)
9D01F5B8  8C42002C   LW V0, 44(V0)
9D01F5BC  0062102B   SLTU V0, V1, V0
9D01F5C0  14400009   BNE V0, ZERO, 0x9D01F5E8
9D01F5C4  00000000   NOP
1149:                					{
1150:                						/* This yield may not cause the task just resumed to run, but
1151:                						will leave the lists in the correct state for the next yield. */
1152:                						portYIELD_WITHIN_API();
9D01F5C8  40026800   MFC0 V0, Cause
9D01F5CC  AFC20014   SW V0, 20(S8)
9D01F5D0  8FC20014   LW V0, 20(S8)
9D01F5D4  34420100   ORI V0, V0, 256
9D01F5D8  AFC20014   SW V0, 20(S8)
9D01F5DC  8FC20014   LW V0, 20(S8)
9D01F5E0  40826800   MTC0 V0, Cause
9D01F5E4  000000C0   EHB
1153:                					}
1154:                				}
1155:                			}
1156:                			taskEXIT_CRITICAL();
9D01F5E8  0F40836C   JAL vTaskExitCritical
9D01F5EC  00000000   NOP
1157:                		}
1158:                	}
9D01F5F0  03C0E821   ADDU SP, S8, ZERO
9D01F5F4  8FBF001C   LW RA, 28(SP)
9D01F5F8  8FBE0018   LW S8, 24(SP)
9D01F5FC  27BD0020   ADDIU SP, SP, 32
9D01F600  03E00008   JR RA
9D01F604  00000000   NOP
1159:                
1160:                #endif /* INCLUDE_vTaskSuspend */
1161:                
1162:                /*-----------------------------------------------------------*/
1163:                
1164:                #if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )
1165:                
1166:                	portBASE_TYPE xTaskResumeFromISR( xTaskHandle xTaskToResume )
1167:                	{
9D01F608  27BDFFD8   ADDIU SP, SP, -40
9D01F60C  AFBF0024   SW RA, 36(SP)
9D01F610  AFBE0020   SW S8, 32(SP)
9D01F614  03A0F021   ADDU S8, SP, ZERO
9D01F618  AFC40028   SW A0, 40(S8)
1168:                	portBASE_TYPE xYieldRequired = pdFALSE;
9D01F61C  AFC00010   SW ZERO, 16(S8)
1169:                	tskTCB * const pxTCB = ( tskTCB * ) xTaskToResume;
9D01F620  8FC20028   LW V0, 40(S8)
9D01F624  AFC20014   SW V0, 20(S8)
1170:                	unsigned portBASE_TYPE uxSavedInterruptStatus;
1171:                
1172:                		configASSERT( xTaskToResume );
9D01F628  8FC20028   LW V0, 40(S8)
9D01F62C  14400006   BNE V0, ZERO, 0x9D01F648
9D01F630  00000000   NOP
9D01F634  3C029D03   LUI V0, -25341
9D01F638  24446054   ADDIU A0, V0, 24660
9D01F63C  24050494   ADDIU A1, ZERO, 1172
9D01F640  0F40C5F5   JAL vAssertCalled
9D01F644  00000000   NOP
1173:                
1174:                		/* RTOS ports that support interrupt nesting have the concept of a
1175:                		maximum	system call (or maximum API call) interrupt priority.
1176:                		Interrupts that are	above the maximum system call priority are keep
1177:                		permanently enabled, even when the RTOS kernel is in a critical section,
1178:                		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
1179:                		is defined in FreeRTOSConfig.h then
1180:                		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1181:                		failure if a FreeRTOS API function is called from an interrupt that has
1182:                		been assigned a priority above the configured maximum system call
1183:                		priority.  Only FreeRTOS functions that end in FromISR can be called
1184:                		from interrupts	that have been assigned a priority at or (logically)
1185:                		below the maximum system call interrupt priority.  FreeRTOS maintains a
1186:                		separate interrupt safe API to ensure interrupt entry is as fast and as
1187:                		simple as possible.  More information (albeit Cortex-M specific) is
1188:                		provided on the following link:
1189:                		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1190:                		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
9D01F648  40026000   MFC0 V0, Status
9D01F64C  3042FC00   ANDI V0, V0, -1024
9D01F650  00021282   SRL V0, V0, 10
9D01F654  2C420004   SLTIU V0, V0, 4
9D01F658  14400006   BNE V0, ZERO, 0x9D01F674
9D01F65C  00000000   NOP
9D01F660  3C029D03   LUI V0, -25341
9D01F664  24446054   ADDIU A0, V0, 24660
9D01F668  240504A6   ADDIU A1, ZERO, 1190
9D01F66C  0F40C5F5   JAL vAssertCalled
9D01F670  00000000   NOP
1191:                
1192:                		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
9D01F674  0F40CFD1   JAL uxPortSetInterruptMaskFromISR
9D01F678  00000000   NOP
9D01F67C  AFC20018   SW V0, 24(S8)
1193:                		{
1194:                			if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
9D01F680  8FC40014   LW A0, 20(S8)
9D01F684  0F407CFE   JAL xTaskIsTaskSuspended
9D01F688  00000000   NOP
9D01F68C  00401821   ADDU V1, V0, ZERO
9D01F690  24020001   ADDIU V0, ZERO, 1
9D01F694  1462002F   BNE V1, V0, 0x9D01F754
9D01F698  00000000   NOP
1195:                			{
1196:                				traceTASK_RESUME_FROM_ISR( pxTCB );
1197:                
1198:                				if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
9D01F69C  8F8280A8   LW V0, -32600(GP)
9D01F6A0  14400025   BNE V0, ZERO, 0x9D01F738
9D01F6A4  00000000   NOP
1199:                				{
1200:                					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
9D01F6A8  8FC20014   LW V0, 20(S8)
9D01F6AC  8C43002C   LW V1, 44(V0)
9D01F6B0  8F828094   LW V0, -32620(GP)
9D01F6B4  8C42002C   LW V0, 44(V0)
9D01F6B8  0062102B   SLTU V0, V1, V0
9D01F6BC  14400003   BNE V0, ZERO, 0x9D01F6CC
9D01F6C0  00000000   NOP
1201:                					{
1202:                						xYieldRequired = pdTRUE;
9D01F6C4  24020001   ADDIU V0, ZERO, 1
9D01F6C8  AFC20010   SW V0, 16(S8)
1203:                					}
1204:                
1205:                					( void ) uxListRemove(  &( pxTCB->xGenericListItem ) );
9D01F6CC  8FC20014   LW V0, 20(S8)
9D01F6D0  24420004   ADDIU V0, V0, 4
9D01F6D4  00402021   ADDU A0, V0, ZERO
9D01F6D8  0F40D131   JAL uxListRemove
9D01F6DC  00000000   NOP
1206:                					prvAddTaskToReadyList( pxTCB );
9D01F6E0  8FC20014   LW V0, 20(S8)
9D01F6E4  8C42002C   LW V0, 44(V0)
9D01F6E8  24030001   ADDIU V1, ZERO, 1
9D01F6EC  00431804   SLLV V1, V1, V0
9D01F6F0  8F8280A0   LW V0, -32608(GP)
9D01F6F4  00621025   OR V0, V1, V0
9D01F6F8  AF8280A0   SW V0, -32608(GP)
9D01F6FC  8FC20014   LW V0, 20(S8)
9D01F700  8C43002C   LW V1, 44(V0)
9D01F704  24020014   ADDIU V0, ZERO, 20
9D01F708  70621802   MUL V1, V1, V0
9D01F70C  3C02A000   LUI V0, -24576
9D01F710  24420480   ADDIU V0, V0, 1152
9D01F714  00621821   ADDU V1, V1, V0
9D01F718  8FC20014   LW V0, 20(S8)
9D01F71C  24420004   ADDIU V0, V0, 4
9D01F720  00602021   ADDU A0, V1, ZERO
9D01F724  00402821   ADDU A1, V0, ZERO
9D01F728  0F40D0D3   JAL vListInsertEnd
9D01F72C  00000000   NOP
9D01F730  0B407DD5   J 0x9D01F754
9D01F734  00000000   NOP
1207:                				}
1208:                				else
1209:                				{
1210:                					/* We cannot access the delayed or ready lists, so will hold this
1211:                					task pending until the scheduler is resumed, at which point a
1212:                					yield will be performed if necessary. */
1213:                					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
9D01F738  8FC20014   LW V0, 20(S8)
9D01F73C  24420018   ADDIU V0, V0, 24
9D01F740  3C03A000   LUI V1, -24576
9D01F744  246404E4   ADDIU A0, V1, 1252
9D01F748  00402821   ADDU A1, V0, ZERO
9D01F74C  0F40D0D3   JAL vListInsertEnd
9D01F750  00000000   NOP
1214:                				}
1215:                			}
1216:                		}
1217:                		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
9D01F754  8FC40018   LW A0, 24(S8)
9D01F758  0F40CFE4   JAL vPortClearInterruptMaskFromISR
9D01F75C  00000000   NOP
1218:                
1219:                		return xYieldRequired;
9D01F760  8FC20010   LW V0, 16(S8)
1220:                	}
9D01F764  03C0E821   ADDU SP, S8, ZERO
9D01F768  8FBF0024   LW RA, 36(SP)
9D01F76C  8FBE0020   LW S8, 32(SP)
9D01F770  27BD0028   ADDIU SP, SP, 40
9D01F774  03E00008   JR RA
9D01F778  00000000   NOP
1221:                
1222:                #endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
1223:                /*-----------------------------------------------------------*/
1224:                
1225:                void vTaskStartScheduler( void )
1226:                {
9D01F77C  27BDFFD0   ADDIU SP, SP, -48
9D01F780  AFBF002C   SW RA, 44(SP)
9D01F784  AFBE0028   SW S8, 40(SP)
9D01F788  03A0F021   ADDU S8, SP, ZERO
1227:                portBASE_TYPE xReturn;
1228:                
1229:                	/* Add the idle task at the lowest priority. */
1230:                	#if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
1231:                	{
1232:                		/* Create the idle task, storing its handle in xIdleTaskHandle so it can
1233:                		be returned by the xTaskGetIdleTaskHandle() function. */
1234:                		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
1235:                	}
1236:                	#else
1237:                	{
1238:                		/* Create the idle task without storing its handle. */
1239:                		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );  /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
9D01F78C  AFA00010   SW ZERO, 16(SP)
9D01F790  AFA00014   SW ZERO, 20(SP)
9D01F794  AFA00018   SW ZERO, 24(SP)
9D01F798  AFA0001C   SW ZERO, 28(SP)
9D01F79C  3C029D02   LUI V0, -25342
9D01F7A0  244404F8   ADDIU A0, V0, 1272
9D01F7A4  3C029D03   LUI V0, -25341
9D01F7A8  2445606C   ADDIU A1, V0, 24684
9D01F7AC  240600BE   ADDIU A2, ZERO, 190
9D01F7B0  00003821   ADDU A3, ZERO, ZERO
9D01F7B4  0F407AA6   JAL xTaskGenericCreate
9D01F7B8  00000000   NOP
9D01F7BC  AFC20020   SW V0, 32(S8)
1240:                	}
1241:                	#endif /* INCLUDE_xTaskGetIdleTaskHandle */
1242:                
1243:                	#if ( configUSE_TIMERS == 1 )
1244:                	{
1245:                		if( xReturn == pdPASS )
9D01F7C0  8FC30020   LW V1, 32(S8)
9D01F7C4  24020001   ADDIU V0, ZERO, 1
9D01F7C8  14620004   BNE V1, V0, 0x9D01F7DC
9D01F7CC  00000000   NOP
1246:                		{
1247:                			xReturn = xTimerCreateTimerTask();
9D01F7D0  0F40AFB7   JAL xTimerCreateTimerTask
9D01F7D4  00000000   NOP
9D01F7D8  AFC20020   SW V0, 32(S8)
1248:                		}
1249:                	}
1250:                	#endif /* configUSE_TIMERS */
1251:                
1252:                	if( xReturn == pdPASS )
9D01F7DC  8FC30020   LW V1, 32(S8)
9D01F7E0  24020001   ADDIU V0, ZERO, 1
9D01F7E4  14620019   BNE V1, V0, 0x9D01F84C
9D01F7E8  00000000   NOP
1253:                	{
1254:                		/* Interrupts are turned off here, to ensure a tick does not occur
1255:                		before or during the call to xPortStartScheduler().  The stacks of
1256:                		the created tasks contain a status word with interrupts switched on
1257:                		so interrupts will automatically get re-enabled when the first task
1258:                		starts to run. */
1259:                		portDISABLE_INTERRUPTS();
9D01F7EC  40026000   MFC0 V0, Status
9D01F7F0  AFC20024   SW V0, 36(S8)
9D01F7F4  8FC20024   LW V0, 36(S8)
9D01F7F8  3042FC00   ANDI V0, V0, -1024
9D01F7FC  00021282   SRL V0, V0, 10
9D01F800  2C420003   SLTIU V0, V0, 3
9D01F804  1040000A   BEQ V0, ZERO, 0x9D01F830
9D01F808  00000000   NOP
9D01F80C  8FC30024   LW V1, 36(S8)
9D01F810  3C02FFFF   LUI V0, -1
9D01F814  344203FF   ORI V0, V0, 1023
9D01F818  00621024   AND V0, V1, V0
9D01F81C  AFC20024   SW V0, 36(S8)
9D01F820  8FC20024   LW V0, 36(S8)
9D01F824  34420C00   ORI V0, V0, 3072
9D01F828  40826000   MTC0 V0, Status
9D01F82C  000000C0   EHB
1260:                
1261:                		#if ( configUSE_NEWLIB_REENTRANT == 1 )
1262:                		{
1263:                			/* Switch Newlib's _impure_ptr variable to point to the _reent
1264:                			structure specific to the task that will run first. */
1265:                			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
1266:                		}
1267:                		#endif /* configUSE_NEWLIB_REENTRANT */
1268:                
1269:                		xSchedulerRunning = pdTRUE;
9D01F830  24020001   ADDIU V0, ZERO, 1
9D01F834  AF8280A4   SW V0, -32604(GP)
1270:                		xTickCount = ( portTickType ) 0U;
9D01F838  AF80809C   SW ZERO, -32612(GP)
1271:                
1272:                		/* If configGENERATE_RUN_TIME_STATS is defined then the following
1273:                		macro must be defined to configure the timer/counter used to generate
1274:                		the run time counter time base. */
1275:                		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
1276:                
1277:                		/* Setting up the timer tick is hardware specific and thus in the
1278:                		portable interface. */
1279:                		if( xPortStartScheduler() != pdFALSE )
9D01F83C  0F40CF93   JAL xPortStartScheduler
9D01F840  00000000   NOP
9D01F844  0B407E1B   J 0x9D01F86C
9D01F848  00000000   NOP
1280:                		{
1281:                			/* Should not reach here as if the scheduler is running the
1282:                			function will not return. */
1283:                		}
1284:                		else
1285:                		{
1286:                			/* Should only reach here if a task calls xTaskEndScheduler(). */
1287:                		}
1288:                	}
1289:                	else
1290:                	{
1291:                		/* This line will only be reached if the kernel could not be started,
1292:                		because there was not enough FreeRTOS heap to create the idle task
1293:                		or the timer task. */
1294:                		configASSERT( xReturn );
9D01F84C  8FC20020   LW V0, 32(S8)
9D01F850  14400006   BNE V0, ZERO, 0x9D01F86C
9D01F854  00000000   NOP
9D01F858  3C029D03   LUI V0, -25341
9D01F85C  24446054   ADDIU A0, V0, 24660
9D01F860  2405050E   ADDIU A1, ZERO, 1294
9D01F864  0F40C5F5   JAL vAssertCalled
9D01F868  00000000   NOP
1295:                	}
1296:                }
9D01F86C  03C0E821   ADDU SP, S8, ZERO
9D01F870  8FBF002C   LW RA, 44(SP)
9D01F874  8FBE0028   LW S8, 40(SP)
9D01F878  27BD0030   ADDIU SP, SP, 48
9D01F87C  03E00008   JR RA
9D01F880  00000000   NOP
1297:                /*-----------------------------------------------------------*/
1298:                
1299:                void vTaskEndScheduler( void )
1300:                {
9D01F884  27BDFFE0   ADDIU SP, SP, -32
9D01F888  AFBF001C   SW RA, 28(SP)
9D01F88C  AFBE0018   SW S8, 24(SP)
9D01F890  03A0F021   ADDU S8, SP, ZERO
1301:                	/* Stop the scheduler interrupts and call the portable scheduler end
1302:                	routine so the original ISRs can be restored if necessary.  The port
1303:                	layer must ensure interrupts enable	bit is left in the correct state. */
1304:                	portDISABLE_INTERRUPTS();
9D01F894  40026000   MFC0 V0, Status
9D01F898  AFC20010   SW V0, 16(S8)
9D01F89C  8FC20010   LW V0, 16(S8)
9D01F8A0  3042FC00   ANDI V0, V0, -1024
9D01F8A4  00021282   SRL V0, V0, 10
9D01F8A8  2C420003   SLTIU V0, V0, 3
9D01F8AC  1040000A   BEQ V0, ZERO, 0x9D01F8D8
9D01F8B0  00000000   NOP
9D01F8B4  8FC30010   LW V1, 16(S8)
9D01F8B8  3C02FFFF   LUI V0, -1
9D01F8BC  344203FF   ORI V0, V0, 1023
9D01F8C0  00621024   AND V0, V1, V0
9D01F8C4  AFC20010   SW V0, 16(S8)
9D01F8C8  8FC20010   LW V0, 16(S8)
9D01F8CC  34420C00   ORI V0, V0, 3072
9D01F8D0  40826000   MTC0 V0, Status
9D01F8D4  000000C0   EHB
1305:                	xSchedulerRunning = pdFALSE;
9D01F8D8  AF8080A4   SW ZERO, -32604(GP)
1306:                	vPortEndScheduler();
9D01F8DC  0F40CF8E   JAL vPortEndScheduler
9D01F8E0  00000000   NOP
1307:                }
9D01F8E4  03C0E821   ADDU SP, S8, ZERO
9D01F8E8  8FBF001C   LW RA, 28(SP)
9D01F8EC  8FBE0018   LW S8, 24(SP)
9D01F8F0  27BD0020   ADDIU SP, SP, 32
9D01F8F4  03E00008   JR RA
9D01F8F8  00000000   NOP
1308:                /*----------------------------------------------------------*/
1309:                
1310:                void vTaskSuspendAll( void )
1311:                {
9D01F8FC  27BDFFF8   ADDIU SP, SP, -8
9D01F900  AFBE0004   SW S8, 4(SP)
9D01F904  03A0F021   ADDU S8, SP, ZERO
1312:                	/* A critical section is not required as the variable is of type
1313:                	portBASE_TYPE. */
1314:                	++uxSchedulerSuspended;
9D01F908  8F8280A8   LW V0, -32600(GP)
9D01F90C  24420001   ADDIU V0, V0, 1
9D01F910  AF8280A8   SW V0, -32600(GP)
1315:                }
9D01F914  03C0E821   ADDU SP, S8, ZERO
9D01F918  8FBE0004   LW S8, 4(SP)
9D01F91C  27BD0008   ADDIU SP, SP, 8
9D01F920  03E00008   JR RA
9D01F924  00000000   NOP
1316:                /*----------------------------------------------------------*/
1317:                
1318:                #if ( configUSE_TICKLESS_IDLE != 0 )
1319:                
1320:                	static portTickType prvGetExpectedIdleTime( void )
1321:                	{
1322:                	portTickType xReturn;
1323:                
1324:                		if( pxCurrentTCB->uxPriority > tskIDLE_PRIORITY )
1325:                		{
1326:                			xReturn = 0;
1327:                		}
1328:                		else if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > 1 )
1329:                		{
1330:                			/* There are other idle priority tasks in the ready state.  If
1331:                			time slicing is used then the very next tick interrupt must be
1332:                			processed. */
1333:                			xReturn = 0;
1334:                		}
1335:                		else
1336:                		{
1337:                			xReturn = xNextTaskUnblockTime - xTickCount;
1338:                		}
1339:                
1340:                		return xReturn;
1341:                	}
1342:                
1343:                #endif /* configUSE_TICKLESS_IDLE */
1344:                /*----------------------------------------------------------*/
1345:                
1346:                signed portBASE_TYPE xTaskResumeAll( void )
1347:                {
9D01F928  27BDFFD8   ADDIU SP, SP, -40
9D01F92C  AFBF0024   SW RA, 36(SP)
9D01F930  AFBE0020   SW S8, 32(SP)
9D01F934  03A0F021   ADDU S8, SP, ZERO
1348:                tskTCB *pxTCB;
1349:                portBASE_TYPE xAlreadyYielded = pdFALSE;
9D01F938  AFC00010   SW ZERO, 16(S8)
1350:                
1351:                	/* If uxSchedulerSuspended is zero then this function does not match a
1352:                	previous call to vTaskSuspendAll(). */
1353:                	configASSERT( uxSchedulerSuspended );
9D01F93C  8F8280A8   LW V0, -32600(GP)
9D01F940  14400006   BNE V0, ZERO, 0x9D01F95C
9D01F944  00000000   NOP
9D01F948  3C029D03   LUI V0, -25341
9D01F94C  24446054   ADDIU A0, V0, 24660
9D01F950  24050549   ADDIU A1, ZERO, 1353
9D01F954  0F40C5F5   JAL vAssertCalled
9D01F958  00000000   NOP
1354:                
1355:                	/* It is possible that an ISR caused a task to be removed from an event
1356:                	list while the scheduler was suspended.  If this was the case then the
1357:                	removed task will have been added to the xPendingReadyList.  Once the
1358:                	scheduler has been resumed it is safe to move all the pending ready
1359:                	tasks from this list into their appropriate ready list. */
1360:                	taskENTER_CRITICAL();
9D01F95C  0F40834C   JAL vTaskEnterCritical
9D01F960  00000000   NOP
1361:                	{
1362:                		--uxSchedulerSuspended;
9D01F964  8F8280A8   LW V0, -32600(GP)
9D01F968  2442FFFF   ADDIU V0, V0, -1
9D01F96C  AF8280A8   SW V0, -32600(GP)
1363:                
1364:                		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
9D01F970  8F8280A8   LW V0, -32600(GP)
9D01F974  14400055   BNE V0, ZERO, 0x9D01FACC
9D01F978  00000000   NOP
1365:                		{
1366:                			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
9D01F97C  8F828098   LW V0, -32616(GP)
9D01F980  10400052   BEQ V0, ZERO, 0x9D01FACC
9D01F984  00000000   NOP
1367:                			{
1368:                				/* Move any readied tasks from the pending list into the
1369:                				appropriate ready list. */
1370:                				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
9D01F988  0B407E90   J 0x9D01FA40
9D01F98C  00000000   NOP
9D01FA40  3C02A000   LUI V0, -24576
9D01FA44  8C4204E4   LW V0, 1252(V0)
9D01FA48  1440FFD1   BNE V0, ZERO, 0x9D01F990
9D01FA4C  00000000   NOP
1371:                				{
1372:                					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
9D01F990  3C02A000   LUI V0, -24576
9D01F994  244204E4   ADDIU V0, V0, 1252
9D01F998  8C42000C   LW V0, 12(V0)
9D01F99C  8C42000C   LW V0, 12(V0)
9D01F9A0  AFC20014   SW V0, 20(S8)
1373:                					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
9D01F9A4  8FC20014   LW V0, 20(S8)
9D01F9A8  24420018   ADDIU V0, V0, 24
9D01F9AC  00402021   ADDU A0, V0, ZERO
9D01F9B0  0F40D131   JAL uxListRemove
9D01F9B4  00000000   NOP
1374:                					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
9D01F9B8  8FC20014   LW V0, 20(S8)
9D01F9BC  24420004   ADDIU V0, V0, 4
9D01F9C0  00402021   ADDU A0, V0, ZERO
9D01F9C4  0F40D131   JAL uxListRemove
9D01F9C8  00000000   NOP
1375:                					prvAddTaskToReadyList( pxTCB );
9D01F9CC  8FC20014   LW V0, 20(S8)
9D01F9D0  8C42002C   LW V0, 44(V0)
9D01F9D4  24030001   ADDIU V1, ZERO, 1
9D01F9D8  00431804   SLLV V1, V1, V0
9D01F9DC  8F8280A0   LW V0, -32608(GP)
9D01F9E0  00621025   OR V0, V1, V0
9D01F9E4  AF8280A0   SW V0, -32608(GP)
9D01F9E8  8FC20014   LW V0, 20(S8)
9D01F9EC  8C43002C   LW V1, 44(V0)
9D01F9F0  24020014   ADDIU V0, ZERO, 20
9D01F9F4  70621802   MUL V1, V1, V0
9D01F9F8  3C02A000   LUI V0, -24576
9D01F9FC  24420480   ADDIU V0, V0, 1152
9D01FA00  00621821   ADDU V1, V1, V0
9D01FA04  8FC20014   LW V0, 20(S8)
9D01FA08  24420004   ADDIU V0, V0, 4
9D01FA0C  00602021   ADDU A0, V1, ZERO
9D01FA10  00402821   ADDU A1, V0, ZERO
9D01FA14  0F40D0D3   JAL vListInsertEnd
9D01FA18  00000000   NOP
1376:                
1377:                					/* If we have moved a task that has a priority higher than
1378:                					the current task then we should yield. */
1379:                					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
9D01FA1C  8FC20014   LW V0, 20(S8)
9D01FA20  8C43002C   LW V1, 44(V0)
9D01FA24  8F828094   LW V0, -32620(GP)
9D01FA28  8C42002C   LW V0, 44(V0)
9D01FA2C  0062102B   SLTU V0, V1, V0
9D01FA30  14400003   BNE V0, ZERO, 0x9D01FA40
9D01FA34  00000000   NOP
1380:                					{
1381:                						xYieldPending = pdTRUE;
9D01FA38  24020001   ADDIU V0, ZERO, 1
9D01FA3C  AF8280B0   SW V0, -32592(GP)
1382:                					}
1383:                				}
1384:                
1385:                				/* If any ticks occurred while the scheduler was suspended then
1386:                				they should be processed now.  This ensures the tick count does not
1387:                				slip, and that any delayed tasks are resumed at the correct time. */
1388:                				if( uxPendedTicks > ( unsigned portBASE_TYPE ) 0U )
9D01FA50  8F8280AC   LW V0, -32596(GP)
9D01FA54  1040000F   BEQ V0, ZERO, 0x9D01FA94
9D01FA58  00000000   NOP
1389:                				{
1390:                					while( uxPendedTicks > ( unsigned portBASE_TYPE ) 0U )
9D01FA5C  0B407EA2   J 0x9D01FA88
9D01FA60  00000000   NOP
9D01FA88  8F8280AC   LW V0, -32596(GP)
9D01FA8C  1440FFF5   BNE V0, ZERO, 0x9D01FA64
9D01FA90  00000000   NOP
1391:                					{
1392:                						if( xTaskIncrementTick() != pdFALSE )
9D01FA64  0F407EF4   JAL xTaskIncrementTick
9D01FA68  00000000   NOP
9D01FA6C  10400003   BEQ V0, ZERO, 0x9D01FA7C
9D01FA70  00000000   NOP
1393:                						{
1394:                							xYieldPending = pdTRUE;
9D01FA74  24020001   ADDIU V0, ZERO, 1
9D01FA78  AF8280B0   SW V0, -32592(GP)
1395:                						}
1396:                						--uxPendedTicks;
9D01FA7C  8F8280AC   LW V0, -32596(GP)
9D01FA80  2442FFFF   ADDIU V0, V0, -1
9D01FA84  AF8280AC   SW V0, -32596(GP)
1397:                					}
1398:                				}
1399:                
1400:                				if( xYieldPending == pdTRUE )
9D01FA94  8F8380B0   LW V1, -32592(GP)
9D01FA98  24020001   ADDIU V0, ZERO, 1
9D01FA9C  1462000B   BNE V1, V0, 0x9D01FACC
9D01FAA0  00000000   NOP
1401:                				{
1402:                					xAlreadyYielded = pdTRUE;
9D01FAA4  24020001   ADDIU V0, ZERO, 1
9D01FAA8  AFC20010   SW V0, 16(S8)
1403:                					portYIELD_WITHIN_API();
9D01FAAC  40026800   MFC0 V0, Cause
9D01FAB0  AFC20018   SW V0, 24(S8)
9D01FAB4  8FC20018   LW V0, 24(S8)
9D01FAB8  34420100   ORI V0, V0, 256
9D01FABC  AFC20018   SW V0, 24(S8)
9D01FAC0  8FC20018   LW V0, 24(S8)
9D01FAC4  40826800   MTC0 V0, Cause
9D01FAC8  000000C0   EHB
1404:                				}
1405:                			}
1406:                		}
1407:                	}
1408:                	taskEXIT_CRITICAL();
9D01FACC  0F40836C   JAL vTaskExitCritical
9D01FAD0  00000000   NOP
1409:                
1410:                	return xAlreadyYielded;
9D01FAD4  8FC20010   LW V0, 16(S8)
1411:                }
9D01FAD8  03C0E821   ADDU SP, S8, ZERO
9D01FADC  8FBF0024   LW RA, 36(SP)
9D01FAE0  8FBE0020   LW S8, 32(SP)
9D01FAE4  27BD0028   ADDIU SP, SP, 40
9D01FAE8  03E00008   JR RA
9D01FAEC  00000000   NOP
1412:                /*-----------------------------------------------------------*/
1413:                
1414:                portTickType xTaskGetTickCount( void )
1415:                {
9D01FAF0  27BDFFE0   ADDIU SP, SP, -32
9D01FAF4  AFBF001C   SW RA, 28(SP)
9D01FAF8  AFBE0018   SW S8, 24(SP)
9D01FAFC  03A0F021   ADDU S8, SP, ZERO
1416:                portTickType xTicks;
1417:                
1418:                	/* Critical section required if running on a 16 bit processor. */
1419:                	taskENTER_CRITICAL();
9D01FB00  0F40834C   JAL vTaskEnterCritical
9D01FB04  00000000   NOP
1420:                	{
1421:                		xTicks = xTickCount;
9D01FB08  8F82809C   LW V0, -32612(GP)
9D01FB0C  AFC20010   SW V0, 16(S8)
1422:                	}
1423:                	taskEXIT_CRITICAL();
9D01FB10  0F40836C   JAL vTaskExitCritical
9D01FB14  00000000   NOP
1424:                
1425:                	return xTicks;
9D01FB18  8FC20010   LW V0, 16(S8)
1426:                }
9D01FB1C  03C0E821   ADDU SP, S8, ZERO
9D01FB20  8FBF001C   LW RA, 28(SP)
9D01FB24  8FBE0018   LW S8, 24(SP)
9D01FB28  27BD0020   ADDIU SP, SP, 32
9D01FB2C  03E00008   JR RA
9D01FB30  00000000   NOP
1427:                /*-----------------------------------------------------------*/
1428:                
1429:                portTickType xTaskGetTickCountFromISR( void )
1430:                {
9D01FB34  27BDFFE0   ADDIU SP, SP, -32
9D01FB38  AFBF001C   SW RA, 28(SP)
9D01FB3C  AFBE0018   SW S8, 24(SP)
9D01FB40  03A0F021   ADDU S8, SP, ZERO
1431:                portTickType xReturn;
1432:                unsigned portBASE_TYPE uxSavedInterruptStatus;
1433:                
1434:                	/* RTOS ports that support interrupt nesting have the concept of a maximum
1435:                	system call (or maximum API call) interrupt priority.  Interrupts that are
1436:                	above the maximum system call priority are keep permanently enabled, even
1437:                	when the RTOS kernel is in a critical section, but cannot make any calls to
1438:                	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
1439:                	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1440:                	failure if a FreeRTOS API function is called from an interrupt that has been
1441:                	assigned a priority above the configured maximum system call priority.
1442:                	Only FreeRTOS functions that end in FromISR can be called from interrupts
1443:                	that have been assigned a priority at or (logically) below the maximum
1444:                	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
1445:                	safe API to ensure interrupt entry is as fast and as simple as possible.
1446:                	More information (albeit Cortex-M specific) is provided on the following
1447:                	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1448:                	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
9D01FB44  40026000   MFC0 V0, Status
9D01FB48  3042FC00   ANDI V0, V0, -1024
9D01FB4C  00021282   SRL V0, V0, 10
9D01FB50  2C420004   SLTIU V0, V0, 4
9D01FB54  14400006   BNE V0, ZERO, 0x9D01FB70
9D01FB58  00000000   NOP
9D01FB5C  3C029D03   LUI V0, -25341
9D01FB60  24446054   ADDIU A0, V0, 24660
9D01FB64  240505A8   ADDIU A1, ZERO, 1448
9D01FB68  0F40C5F5   JAL vAssertCalled
9D01FB6C  00000000   NOP
1449:                
1450:                	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
9D01FB70  0F40CFD1   JAL uxPortSetInterruptMaskFromISR
9D01FB74  00000000   NOP
9D01FB78  AFC20010   SW V0, 16(S8)
1451:                	xReturn = xTickCount;
9D01FB7C  8F82809C   LW V0, -32612(GP)
9D01FB80  AFC20014   SW V0, 20(S8)
1452:                	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
9D01FB84  8FC40010   LW A0, 16(S8)
9D01FB88  0F40CFE4   JAL vPortClearInterruptMaskFromISR
9D01FB8C  00000000   NOP
1453:                
1454:                	return xReturn;
9D01FB90  8FC20014   LW V0, 20(S8)
1455:                }
9D01FB94  03C0E821   ADDU SP, S8, ZERO
9D01FB98  8FBF001C   LW RA, 28(SP)
9D01FB9C  8FBE0018   LW S8, 24(SP)
9D01FBA0  27BD0020   ADDIU SP, SP, 32
9D01FBA4  03E00008   JR RA
9D01FBA8  00000000   NOP
1456:                /*-----------------------------------------------------------*/
1457:                
1458:                unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
1459:                {
9D01FBAC  27BDFFF8   ADDIU SP, SP, -8
9D01FBB0  AFBE0004   SW S8, 4(SP)
9D01FBB4  03A0F021   ADDU S8, SP, ZERO
1460:                	/* A critical section is not required because the variables are of type
1461:                	portBASE_TYPE. */
1462:                	return uxCurrentNumberOfTasks;
9D01FBB8  8F828098   LW V0, -32616(GP)
1463:                }
9D01FBBC  03C0E821   ADDU SP, S8, ZERO
9D01FBC0  8FBE0004   LW S8, 4(SP)
9D01FBC4  27BD0008   ADDIU SP, SP, 8
9D01FBC8  03E00008   JR RA
9D01FBCC  00000000   NOP
1464:                /*-----------------------------------------------------------*/
1465:                
1466:                #if ( INCLUDE_pcTaskGetTaskName == 1 )
1467:                
1468:                	signed char *pcTaskGetTaskName( xTaskHandle xTaskToQuery )
1469:                	{
1470:                	tskTCB *pxTCB;
1471:                
1472:                		/* If null is passed in here then the name of the calling task is being queried. */
1473:                		pxTCB = prvGetTCBFromHandle( xTaskToQuery );
1474:                		configASSERT( pxTCB );
1475:                		return &( pxTCB->pcTaskName[ 0 ] );
1476:                	}
1477:                
1478:                #endif /* INCLUDE_pcTaskGetTaskName */
1479:                /*-----------------------------------------------------------*/
1480:                
1481:                #if ( configUSE_TRACE_FACILITY == 1 )
1482:                
1483:                	unsigned portBASE_TYPE uxTaskGetSystemState( xTaskStatusType *pxTaskStatusArray, unsigned portBASE_TYPE uxArraySize, unsigned long *pulTotalRunTime )
1484:                	{
1485:                	unsigned portBASE_TYPE uxTask = 0, uxQueue = configMAX_PRIORITIES;
1486:                
1487:                		vTaskSuspendAll();
1488:                		{
1489:                			/* Is there a space in the array for each task in the system? */
1490:                			if( uxArraySize >= uxCurrentNumberOfTasks )
1491:                			{
1492:                				/* Fill in an xTaskStatusType structure with information on each
1493:                				task in the Ready state. */
1494:                				do
1495:                				{
1496:                					uxQueue--;
1497:                					uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &( pxReadyTasksLists[ uxQueue ] ), eReady );
1498:                
1499:                				} while( uxQueue > ( unsigned portBASE_TYPE ) tskIDLE_PRIORITY ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
1500:                
1501:                				/* Fill in an xTaskStatusType structure with information on each
1502:                				task in the Blocked state. */
1503:                				uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( xList * ) pxDelayedTaskList, eBlocked );
1504:                				uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( xList * ) pxOverflowDelayedTaskList, eBlocked );
1505:                
1506:                				#if( INCLUDE_vTaskDelete == 1 )
1507:                				{
1508:                					/* Fill in an xTaskStatusType structure with information on
1509:                					each task that has been deleted but not yet cleaned up. */
1510:                					uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xTasksWaitingTermination, eDeleted );
1511:                				}
1512:                				#endif
1513:                
1514:                				#if ( INCLUDE_vTaskSuspend == 1 )
1515:                				{
1516:                					/* Fill in an xTaskStatusType structure with information on
1517:                					each task in the Suspended state. */
1518:                					uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xSuspendedTaskList, eSuspended );
1519:                				}
1520:                				#endif
1521:                
1522:                				#if ( configGENERATE_RUN_TIME_STATS == 1)
1523:                				{
1524:                					if( pulTotalRunTime != NULL )
1525:                					{
1526:                						#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
1527:                							portALT_GET_RUN_TIME_COUNTER_VALUE( ( *pulTotalRunTime ) );
1528:                						#else
1529:                							*pulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
1530:                						#endif
1531:                					}
1532:                				}
1533:                				#else
1534:                				{
1535:                					if( pulTotalRunTime != NULL )
1536:                					{
1537:                						*pulTotalRunTime = 0;
1538:                					}
1539:                				}
1540:                				#endif
1541:                			}
1542:                		}
1543:                		( void ) xTaskResumeAll();
1544:                
1545:                		return uxTask;
1546:                	}
1547:                
1548:                #endif /* configUSE_TRACE_FACILITY */
1549:                /*----------------------------------------------------------*/
1550:                
1551:                #if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
1552:                
1553:                	xTaskHandle xTaskGetIdleTaskHandle( void )
1554:                	{
1555:                		/* If xTaskGetIdleTaskHandle() is called before the scheduler has been
1556:                		started, then xIdleTaskHandle will be NULL. */
1557:                		configASSERT( ( xIdleTaskHandle != NULL ) );
1558:                		return xIdleTaskHandle;
1559:                	}
1560:                
1561:                #endif /* INCLUDE_xTaskGetIdleTaskHandle */
1562:                /*----------------------------------------------------------*/
1563:                
1564:                /* This conditional compilation should use inequality to 0, not equality to 1.
1565:                This is to ensure vTaskStepTick() is available when user defined low power mode
1566:                implementations require configUSE_TICKLESS_IDLE to be set to a value other than
1567:                1. */
1568:                #if ( configUSE_TICKLESS_IDLE != 0 )
1569:                
1570:                	void vTaskStepTick( portTickType xTicksToJump )
1571:                	{
1572:                		/* Correct the tick count value after a period during which the tick
1573:                		was suppressed.  Note this does *not* call the tick hook function for
1574:                		each stepped tick. */
1575:                		configASSERT( ( xTickCount + xTicksToJump ) <= xNextTaskUnblockTime );
1576:                		xTickCount += xTicksToJump;
1577:                		traceINCREASE_TICK_COUNT( xTicksToJump );
1578:                	}
1579:                
1580:                #endif /* configUSE_TICKLESS_IDLE */
1581:                /*----------------------------------------------------------*/
1582:                
1583:                portBASE_TYPE xTaskIncrementTick( void )
1584:                {
9D01FBD0  27BDFFD0   ADDIU SP, SP, -48
9D01FBD4  AFBF002C   SW RA, 44(SP)
9D01FBD8  AFBE0028   SW S8, 40(SP)
9D01FBDC  03A0F021   ADDU S8, SP, ZERO
1585:                tskTCB * pxTCB;
1586:                portTickType xItemValue;
1587:                portBASE_TYPE xSwitchRequired = pdFALSE;
9D01FBE0  AFC00010   SW ZERO, 16(S8)
1588:                
1589:                	/* Called by the portable layer each time a tick interrupt occurs.
1590:                	Increments the tick then checks to see if the new tick value will cause any
1591:                	tasks to be unblocked. */
1592:                	traceTASK_INCREMENT_TICK( xTickCount );
1593:                	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
9D01FBE4  8F8280A8   LW V0, -32600(GP)
9D01FBE8  14400092   BNE V0, ZERO, 0x9D01FE34
9D01FBEC  00000000   NOP
1594:                	{
1595:                		/* Increment the RTOS tick, switching the delayed and overflowed
1596:                		delayed lists if it wraps to 0. */
1597:                		++xTickCount;
9D01FBF0  8F82809C   LW V0, -32612(GP)
9D01FBF4  24420001   ADDIU V0, V0, 1
9D01FBF8  AF82809C   SW V0, -32612(GP)
1598:                
1599:                		{
1600:                			/* Minor optimisation.  The tick count cannot change in this
1601:                			block. */
1602:                			const portTickType xConstTickCount = xTickCount;
9D01FBFC  8F82809C   LW V0, -32612(GP)
9D01FC00  AFC20014   SW V0, 20(S8)
1603:                
1604:                			if( xConstTickCount == ( portTickType ) 0U )
9D01FC04  8FC20014   LW V0, 20(S8)
9D01FC08  14400028   BNE V0, ZERO, 0x9D01FCAC
9D01FC0C  00000000   NOP
1605:                			{
1606:                				taskSWITCH_DELAYED_LISTS();
9D01FC10  8F8281E0   LW V0, -32288(GP)
9D01FC14  8C420000   LW V0, 0(V0)
9D01FC18  10400006   BEQ V0, ZERO, 0x9D01FC34
9D01FC1C  00000000   NOP
9D01FC20  3C029D03   LUI V0, -25341
9D01FC24  24446054   ADDIU A0, V0, 24660
9D01FC28  24050646   ADDIU A1, ZERO, 1606
9D01FC2C  0F40C5F5   JAL vAssertCalled
9D01FC30  00000000   NOP
9D01FC34  8F8281E0   LW V0, -32288(GP)
9D01FC38  AFC20018   SW V0, 24(S8)
9D01FC3C  8F8281E4   LW V0, -32284(GP)
9D01FC40  AF8281E0   SW V0, -32288(GP)
9D01FC44  8FC20018   LW V0, 24(S8)
9D01FC48  AF8281E4   SW V0, -32284(GP)
9D01FC4C  8F8280B4   LW V0, -32588(GP)
9D01FC50  24420001   ADDIU V0, V0, 1
9D01FC54  AF8280B4   SW V0, -32588(GP)
9D01FC58  8F8281E0   LW V0, -32288(GP)
9D01FC5C  8C420000   LW V0, 0(V0)
9D01FC60  14400004   BNE V0, ZERO, 0x9D01FC74
9D01FC64  00000000   NOP
9D01FC68  24020001   ADDIU V0, ZERO, 1
9D01FC6C  0B407F1E   J 0x9D01FC78
9D01FC70  00000000   NOP
9D01FC74  00001021   ADDU V0, ZERO, ZERO
9D01FC78  10400005   BEQ V0, ZERO, 0x9D01FC90
9D01FC7C  00000000   NOP
9D01FC80  2402FFFF   ADDIU V0, ZERO, -1
9D01FC84  AF82800C   SW V0, -32756(GP)
9D01FC88  0B407F2B   J 0x9D01FCAC
9D01FC8C  00000000   NOP
9D01FC90  8F8281E0   LW V0, -32288(GP)
9D01FC94  8C42000C   LW V0, 12(V0)
9D01FC98  8C42000C   LW V0, 12(V0)
9D01FC9C  AFC2001C   SW V0, 28(S8)
9D01FCA0  8FC2001C   LW V0, 28(S8)
9D01FCA4  8C420004   LW V0, 4(V0)
9D01FCA8  AF82800C   SW V0, -32756(GP)
1607:                			}
1608:                
1609:                			/* See if this tick has made a timeout expire.  Tasks are stored in the
1610:                			queue in the order of their wake time - meaning once one tasks has been
1611:                			found whose block time has not expired there is no need not look any
1612:                			further	down the list. */
1613:                			if( xConstTickCount >= xNextTaskUnblockTime )
9D01FCAC  8F82800C   LW V0, -32756(GP)
9D01FCB0  8FC30014   LW V1, 20(S8)
9D01FCB4  0062102B   SLTU V0, V1, V0
9D01FCB8  1440004F   BNE V0, ZERO, 0x9D01FDF8
9D01FCBC  00000000   NOP
9D01FCC0  0B407F33   J 0x9D01FCCC
9D01FCC4  00000000   NOP
1614:                			{
1615:                				for( ;; )
1616:                				{
1617:                					if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
9D01FCCC  8F8281E0   LW V0, -32288(GP)
9D01FCD0  8C420000   LW V0, 0(V0)
9D01FCD4  14400004   BNE V0, ZERO, 0x9D01FCE8
9D01FCD8  00000000   NOP
9D01FCDC  24020001   ADDIU V0, ZERO, 1
9D01FCE0  0B407F3B   J 0x9D01FCEC
9D01FCE4  00000000   NOP
9D01FCE8  00001021   ADDU V0, ZERO, ZERO
9D01FCEC  10400005   BEQ V0, ZERO, 0x9D01FD04
9D01FCF0  00000000   NOP
1618:                					{
1619:                						/* The delayed list is empty.  Set xNextTaskUnblockTime to
1620:                						the	maximum possible value so it is extremely unlikely that
1621:                						the if( xTickCount >= xNextTaskUnblockTime ) test will pass
1622:                						next time through. */
1623:                						xNextTaskUnblockTime = portMAX_DELAY;
9D01FCF4  2402FFFF   ADDIU V0, ZERO, -1
9D01FCF8  AF82800C   SW V0, -32756(GP)
1624:                						break;
9D01FCFC  0B407F7E   J 0x9D01FDF8
9D01FD00  00000000   NOP
1625:                					}
1626:                					else
1627:                					{
1628:                						/* The delayed list is not empty, get the value of the item
1629:                						at the head of the delayed list.  This is the time at which
1630:                						the task at the head of the delayed list must be removed
1631:                						from the Blocked state. */
1632:                						pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
9D01FD04  8F8281E0   LW V0, -32288(GP)
9D01FD08  8C42000C   LW V0, 12(V0)
9D01FD0C  8C42000C   LW V0, 12(V0)
9D01FD10  AFC2001C   SW V0, 28(S8)
1633:                						xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
9D01FD14  8FC2001C   LW V0, 28(S8)
9D01FD18  8C420004   LW V0, 4(V0)
9D01FD1C  AFC20020   SW V0, 32(S8)
1634:                
1635:                						if( xConstTickCount < xItemValue )
9D01FD20  8FC30014   LW V1, 20(S8)
9D01FD24  8FC20020   LW V0, 32(S8)
9D01FD28  0062102B   SLTU V0, V1, V0
9D01FD2C  10400005   BEQ V0, ZERO, 0x9D01FD44
9D01FD30  00000000   NOP
1636:                						{
1637:                							/* It is not time to unblock this item yet, but the item
1638:                							value is the time at which the task at the head of the
1639:                							blocked list must be removed from the Blocked state -
1640:                							so record the item value in xNextTaskUnblockTime. */
1641:                							xNextTaskUnblockTime = xItemValue;
9D01FD34  8FC20020   LW V0, 32(S8)
9D01FD38  AF82800C   SW V0, -32756(GP)
1642:                							break;
9D01FD3C  0B407F7E   J 0x9D01FDF8
9D01FD40  00000000   NOP
1643:                						}
1644:                
1645:                						/* It is time to remove the item from the Blocked state. */
1646:                						( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
9D01FD44  8FC2001C   LW V0, 28(S8)
9D01FD48  24420004   ADDIU V0, V0, 4
9D01FD4C  00402021   ADDU A0, V0, ZERO
9D01FD50  0F40D131   JAL uxListRemove
9D01FD54  00000000   NOP
1647:                
1648:                						/* Is the task waiting on an event also?  If so remove it
1649:                						from the event list. */
1650:                						if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
9D01FD58  8FC2001C   LW V0, 28(S8)
9D01FD5C  8C420028   LW V0, 40(V0)
9D01FD60  10400006   BEQ V0, ZERO, 0x9D01FD7C
9D01FD64  00000000   NOP
1651:                						{
1652:                							( void ) uxListRemove( &( pxTCB->xEventListItem ) );
9D01FD68  8FC2001C   LW V0, 28(S8)
9D01FD6C  24420018   ADDIU V0, V0, 24
9D01FD70  00402021   ADDU A0, V0, ZERO
9D01FD74  0F40D131   JAL uxListRemove
9D01FD78  00000000   NOP
1653:                						}
1654:                
1655:                						/* Place the unblocked task into the appropriate ready
1656:                						list. */
1657:                						prvAddTaskToReadyList( pxTCB );
9D01FD7C  8FC2001C   LW V0, 28(S8)
9D01FD80  8C42002C   LW V0, 44(V0)
9D01FD84  24030001   ADDIU V1, ZERO, 1
9D01FD88  00431804   SLLV V1, V1, V0
9D01FD8C  8F8280A0   LW V0, -32608(GP)
9D01FD90  00621025   OR V0, V1, V0
9D01FD94  AF8280A0   SW V0, -32608(GP)
9D01FD98  8FC2001C   LW V0, 28(S8)
9D01FD9C  8C43002C   LW V1, 44(V0)
9D01FDA0  24020014   ADDIU V0, ZERO, 20
9D01FDA4  70621802   MUL V1, V1, V0
9D01FDA8  3C02A000   LUI V0, -24576
9D01FDAC  24420480   ADDIU V0, V0, 1152
9D01FDB0  00621821   ADDU V1, V1, V0
9D01FDB4  8FC2001C   LW V0, 28(S8)
9D01FDB8  24420004   ADDIU V0, V0, 4
9D01FDBC  00602021   ADDU A0, V1, ZERO
9D01FDC0  00402821   ADDU A1, V0, ZERO
9D01FDC4  0F40D0D3   JAL vListInsertEnd
9D01FDC8  00000000   NOP
1658:                
1659:                						/* A task being unblocked cannot cause an immediate context
1660:                						switch if preemption is turned off. */
1661:                						#if (  configUSE_PREEMPTION == 1 )
1662:                						{
1663:                							/* Preemption is on, but a context switch should only
1664:                							be performed if the unblocked task has a priority that
1665:                							is equal to or higher than the currently executing
1666:                							task. */
1667:                							if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
9D01FDCC  8FC2001C   LW V0, 28(S8)
9D01FDD0  8C43002C   LW V1, 44(V0)
9D01FDD4  8F828094   LW V0, -32620(GP)
9D01FDD8  8C42002C   LW V0, 44(V0)
9D01FDDC  0062102B   SLTU V0, V1, V0
9D01FDE0  1440FFB9   BNE V0, ZERO, 0x9D01FCC8
9D01FDE4  00000000   NOP
1668:                							{
1669:                								xSwitchRequired = pdTRUE;
9D01FDE8  24020001   ADDIU V0, ZERO, 1
9D01FDEC  AFC20010   SW V0, 16(S8)
1670:                							}
1671:                						}
1672:                						#endif /* configUSE_PREEMPTION */
1673:                					}
1674:                				}
9D01FCC8  00000000   NOP
9D01FDF0  0B407F33   J 0x9D01FCCC
9D01FDF4  00000000   NOP
1675:                			}
1676:                		}
1677:                
1678:                		/* Tasks of equal priority to the currently running task will share
1679:                		processing time (time slice) if preemption is on, and the application
1680:                		writer has not explicitly turned time slicing off. */
1681:                		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
1682:                		{
1683:                			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( unsigned portBASE_TYPE ) 1 )
9D01FDF8  8F828094   LW V0, -32620(GP)
9D01FDFC  8C43002C   LW V1, 44(V0)
9D01FE00  24020014   ADDIU V0, ZERO, 20
9D01FE04  70621802   MUL V1, V1, V0
9D01FE08  3C02A000   LUI V0, -24576
9D01FE0C  24420480   ADDIU V0, V0, 1152
9D01FE10  00621021   ADDU V0, V1, V0
9D01FE14  8C420000   LW V0, 0(V0)
9D01FE18  2C420002   SLTIU V0, V0, 2
9D01FE1C  14400008   BNE V0, ZERO, 0x9D01FE40
9D01FE20  00000000   NOP
1684:                			{
1685:                				xSwitchRequired = pdTRUE;
9D01FE24  24020001   ADDIU V0, ZERO, 1
9D01FE28  AFC20010   SW V0, 16(S8)
9D01FE2C  0B407F90   J 0x9D01FE40
9D01FE30  00000000   NOP
1686:                			}
1687:                		}
1688:                		#endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) ) */
1689:                		
1690:                		#if ( configUSE_TICK_HOOK == 1 )
1691:                		{
1692:                			/* Guard against the tick hook being called when the pended tick
1693:                			count is being unwound (when the scheduler is being unlocked). */
1694:                			if( uxPendedTicks == ( unsigned portBASE_TYPE ) 0U )
1695:                			{
1696:                				vApplicationTickHook();
1697:                			}
1698:                		}
1699:                		#endif /* configUSE_TICK_HOOK */		
1700:                	}
1701:                	else
1702:                	{
1703:                		++uxPendedTicks;
9D01FE34  8F8280AC   LW V0, -32596(GP)
9D01FE38  24420001   ADDIU V0, V0, 1
9D01FE3C  AF8280AC   SW V0, -32596(GP)
1704:                
1705:                		/* The tick hook gets called at regular intervals, even if the
1706:                		scheduler is locked. */
1707:                		#if ( configUSE_TICK_HOOK == 1 )
1708:                		{
1709:                			vApplicationTickHook();
1710:                		}
1711:                		#endif
1712:                	}
1713:                
1714:                	#if ( configUSE_PREEMPTION == 1 )
1715:                	{
1716:                		if( xYieldPending != pdFALSE )
9D01FE40  8F8280B0   LW V0, -32592(GP)
9D01FE44  10400003   BEQ V0, ZERO, 0x9D01FE54
9D01FE48  00000000   NOP
1717:                		{
1718:                			xSwitchRequired = pdTRUE;
9D01FE4C  24020001   ADDIU V0, ZERO, 1
9D01FE50  AFC20010   SW V0, 16(S8)
1719:                		}
1720:                	}
1721:                	#endif /* configUSE_PREEMPTION */
1722:                
1723:                	return xSwitchRequired;
9D01FE54  8FC20010   LW V0, 16(S8)
1724:                }
9D01FE58  03C0E821   ADDU SP, S8, ZERO
9D01FE5C  8FBF002C   LW RA, 44(SP)
9D01FE60  8FBE0028   LW S8, 40(SP)
9D01FE64  27BD0030   ADDIU SP, SP, 48
9D01FE68  03E00008   JR RA
9D01FE6C  00000000   NOP
1725:                /*-----------------------------------------------------------*/
1726:                
1727:                #if ( configUSE_APPLICATION_TASK_TAG == 1 )
1728:                
1729:                	void vTaskSetApplicationTaskTag( xTaskHandle xTask, pdTASK_HOOK_CODE pxHookFunction )
1730:                	{
1731:                	tskTCB *xTCB;
1732:                
1733:                		/* If xTask is NULL then we are setting our own task hook. */
1734:                		if( xTask == NULL )
1735:                		{
1736:                			xTCB = ( tskTCB * ) pxCurrentTCB;
1737:                		}
1738:                		else
1739:                		{
1740:                			xTCB = ( tskTCB * ) xTask;
1741:                		}
1742:                
1743:                		/* Save the hook function in the TCB.  A critical section is required as
1744:                		the value can be accessed from an interrupt. */
1745:                		taskENTER_CRITICAL();
1746:                			xTCB->pxTaskTag = pxHookFunction;
1747:                		taskEXIT_CRITICAL();
1748:                	}
1749:                
1750:                #endif /* configUSE_APPLICATION_TASK_TAG */
1751:                /*-----------------------------------------------------------*/
1752:                
1753:                #if ( configUSE_APPLICATION_TASK_TAG == 1 )
1754:                
1755:                	pdTASK_HOOK_CODE xTaskGetApplicationTaskTag( xTaskHandle xTask )
1756:                	{
1757:                	tskTCB *xTCB;
1758:                	pdTASK_HOOK_CODE xReturn;
1759:                
1760:                		/* If xTask is NULL then we are setting our own task hook. */
1761:                		if( xTask == NULL )
1762:                		{
1763:                			xTCB = ( tskTCB * ) pxCurrentTCB;
1764:                		}
1765:                		else
1766:                		{
1767:                			xTCB = ( tskTCB * ) xTask;
1768:                		}
1769:                
1770:                		/* Save the hook function in the TCB.  A critical section is required as
1771:                		the value can be accessed from an interrupt. */
1772:                		taskENTER_CRITICAL();
1773:                			xReturn = xTCB->pxTaskTag;
1774:                		taskEXIT_CRITICAL();
1775:                
1776:                		return xReturn;
1777:                	}
1778:                
1779:                #endif /* configUSE_APPLICATION_TASK_TAG */
1780:                /*-----------------------------------------------------------*/
1781:                
1782:                #if ( configUSE_APPLICATION_TASK_TAG == 1 )
1783:                
1784:                	portBASE_TYPE xTaskCallApplicationTaskHook( xTaskHandle xTask, void *pvParameter )
1785:                	{
1786:                	tskTCB *xTCB;
1787:                	portBASE_TYPE xReturn;
1788:                
1789:                		/* If xTask is NULL then we are calling our own task hook. */
1790:                		if( xTask == NULL )
1791:                		{
1792:                			xTCB = ( tskTCB * ) pxCurrentTCB;
1793:                		}
1794:                		else
1795:                		{
1796:                			xTCB = ( tskTCB * ) xTask;
1797:                		}
1798:                
1799:                		if( xTCB->pxTaskTag != NULL )
1800:                		{
1801:                			xReturn = xTCB->pxTaskTag( pvParameter );
1802:                		}
1803:                		else
1804:                		{
1805:                			xReturn = pdFAIL;
1806:                		}
1807:                
1808:                		return xReturn;
1809:                	}
1810:                
1811:                #endif /* configUSE_APPLICATION_TASK_TAG */
1812:                /*-----------------------------------------------------------*/
1813:                
1814:                void vTaskSwitchContext( void )
1815:                {
9D01FE70  27BDFFC8   ADDIU SP, SP, -56
9D01FE74  AFBF0034   SW RA, 52(SP)
9D01FE78  AFBE0030   SW S8, 48(SP)
9D01FE7C  03A0F021   ADDU S8, SP, ZERO
1816:                	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
9D01FE80  8F8280A8   LW V0, -32600(GP)
9D01FE84  10400005   BEQ V0, ZERO, 0x9D01FE9C
9D01FE88  00000000   NOP
1817:                	{
1818:                		/* The scheduler is currently suspended - do not allow a context
1819:                		switch. */
1820:                		xYieldPending = pdTRUE;
9D01FE8C  24020001   ADDIU V0, ZERO, 1
9D01FE90  AF8280B0   SW V0, -32592(GP)
9D01FE94  0B408004   J 0x9D020010
9D01FE98  00000000   NOP
1821:                	}
1822:                	else
1823:                	{
1824:                		xYieldPending = pdFALSE;
9D01FE9C  AF8080B0   SW ZERO, -32592(GP)
1825:                		traceTASK_SWITCHED_OUT();
1826:                
1827:                		#if ( configGENERATE_RUN_TIME_STATS == 1 )
1828:                		{
1829:                				#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
1830:                					portALT_GET_RUN_TIME_COUNTER_VALUE( ulTotalRunTime );
1831:                				#else
1832:                					ulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
1833:                				#endif
1834:                
1835:                				/* Add the amount of time the task has been running to the
1836:                				accumulated	time so far.  The time the task started running was
1837:                				stored in ulTaskSwitchedInTime.  Note that there is no overflow
1838:                				protection here	so count values are only valid until the timer
1839:                				overflows.  The guard against negative values is to protect
1840:                				against suspect run time stat counter implementations - which
1841:                				are provided by the application, not the kernel. */
1842:                				if( ulTotalRunTime > ulTaskSwitchedInTime )
1843:                				{
1844:                					pxCurrentTCB->ulRunTimeCounter += ( ulTotalRunTime - ulTaskSwitchedInTime );
1845:                				}
1846:                				ulTaskSwitchedInTime = ulTotalRunTime;
1847:                		}
1848:                		#endif /* configGENERATE_RUN_TIME_STATS */
1849:                
1850:                		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
9D01FEA0  8F828094   LW V0, -32620(GP)
9D01FEA4  8C430000   LW V1, 0(V0)
9D01FEA8  8F828094   LW V0, -32620(GP)
9D01FEAC  8C420030   LW V0, 48(V0)
9D01FEB0  0043102B   SLTU V0, V0, V1
9D01FEB4  14400008   BNE V0, ZERO, 0x9D01FED8
9D01FEB8  00000000   NOP
9D01FEBC  8F838094   LW V1, -32620(GP)
9D01FEC0  8F828094   LW V0, -32620(GP)
9D01FEC4  24420034   ADDIU V0, V0, 52
9D01FEC8  00602021   ADDU A0, V1, ZERO
9D01FECC  00402821   ADDU A1, V0, ZERO
9D01FED0  0F40C5CE   JAL vApplicationStackOverflowHook
9D01FED4  00000000   NOP
1851:                		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
9D01FED8  3C029D03   LUI V0, -25341
9D01FEDC  8C466074   LW A2, 24692(V0)
9D01FEE0  24436074   ADDIU V1, V0, 24692
9D01FEE4  8C650004   LW A1, 4(V1)
9D01FEE8  24436074   ADDIU V1, V0, 24692
9D01FEEC  8C640008   LW A0, 8(V1)
9D01FEF0  24436074   ADDIU V1, V0, 24692
9D01FEF4  8C63000C   LW V1, 12(V1)
9D01FEF8  24426074   ADDIU V0, V0, 24692
9D01FEFC  8C420010   LW V0, 16(V0)
9D01FF00  AFC60018   SW A2, 24(S8)
9D01FF04  AFC5001C   SW A1, 28(S8)
9D01FF08  AFC40020   SW A0, 32(S8)
9D01FF0C  AFC30024   SW V1, 36(S8)
9D01FF10  AFC20028   SW V0, 40(S8)
9D01FF14  8F828094   LW V0, -32620(GP)
9D01FF18  8C430030   LW V1, 48(V0)
9D01FF1C  27C20018   ADDIU V0, S8, 24
9D01FF20  00602021   ADDU A0, V1, ZERO
9D01FF24  00402821   ADDU A1, V0, ZERO
9D01FF28  24060014   ADDIU A2, ZERO, 20
9D01FF2C  0F40D6D9   JAL 0x9D035B64
9D01FF30  00000000   NOP
9D01FF34  10400008   BEQ V0, ZERO, 0x9D01FF58
9D01FF38  00000000   NOP
9D01FF3C  8F838094   LW V1, -32620(GP)
9D01FF40  8F828094   LW V0, -32620(GP)
9D01FF44  24420034   ADDIU V0, V0, 52
9D01FF48  00602021   ADDU A0, V1, ZERO
9D01FF4C  00402821   ADDU A1, V0, ZERO
9D01FF50  0F40C5CE   JAL vApplicationStackOverflowHook
9D01FF54  00000000   NOP
1852:                
1853:                		taskSELECT_HIGHEST_PRIORITY_TASK();
9D01FF58  8F8280A0   LW V0, -32608(GP)
9D01FF5C  70421020   CLZ V0, V0
9D01FF60  2403001F   ADDIU V1, ZERO, 31
9D01FF64  00621023   SUBU V0, V1, V0
9D01FF68  AFC20010   SW V0, 16(S8)
9D01FF6C  8FC30010   LW V1, 16(S8)
9D01FF70  24020014   ADDIU V0, ZERO, 20
9D01FF74  70621802   MUL V1, V1, V0
9D01FF78  3C02A000   LUI V0, -24576
9D01FF7C  24420480   ADDIU V0, V0, 1152
9D01FF80  00621021   ADDU V0, V1, V0
9D01FF84  8C420000   LW V0, 0(V0)
9D01FF88  14400006   BNE V0, ZERO, 0x9D01FFA4
9D01FF8C  00000000   NOP
9D01FF90  3C029D03   LUI V0, -25341
9D01FF94  24446054   ADDIU A0, V0, 24660
9D01FF98  2405073D   ADDIU A1, ZERO, 1853
9D01FF9C  0F40C5F5   JAL vAssertCalled
9D01FFA0  00000000   NOP
9D01FFA4  8FC30010   LW V1, 16(S8)
9D01FFA8  24020014   ADDIU V0, ZERO, 20
9D01FFAC  70621802   MUL V1, V1, V0
9D01FFB0  3C02A000   LUI V0, -24576
9D01FFB4  24420480   ADDIU V0, V0, 1152
9D01FFB8  00621021   ADDU V0, V1, V0
9D01FFBC  AFC20014   SW V0, 20(S8)
9D01FFC0  8FC20014   LW V0, 20(S8)
9D01FFC4  8C420004   LW V0, 4(V0)
9D01FFC8  8C430004   LW V1, 4(V0)
9D01FFCC  8FC20014   LW V0, 20(S8)
9D01FFD0  AC430004   SW V1, 4(V0)
9D01FFD4  8FC20014   LW V0, 20(S8)
9D01FFD8  8C430004   LW V1, 4(V0)
9D01FFDC  8FC20014   LW V0, 20(S8)
9D01FFE0  24420008   ADDIU V0, V0, 8
9D01FFE4  14620006   BNE V1, V0, 0x9D020000
9D01FFE8  00000000   NOP
9D01FFEC  8FC20014   LW V0, 20(S8)
9D01FFF0  8C420004   LW V0, 4(V0)
9D01FFF4  8C430004   LW V1, 4(V0)
9D01FFF8  8FC20014   LW V0, 20(S8)
9D01FFFC  AC430004   SW V1, 4(V0)
9D020000  8FC20014   LW V0, 20(S8)
9D020004  8C420004   LW V0, 4(V0)
9D020008  8C42000C   LW V0, 12(V0)
9D02000C  AF828094   SW V0, -32620(GP)
1854:                
1855:                		traceTASK_SWITCHED_IN();
1856:                
1857:                		#if ( configUSE_NEWLIB_REENTRANT == 1 )
1858:                		{
1859:                			/* Switch Newlib's _impure_ptr variable to point to the _reent
1860:                			structure specific to this task. */
1861:                			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
1862:                		}
1863:                		#endif /* configUSE_NEWLIB_REENTRANT */
1864:                	}
1865:                }
9D020010  03C0E821   ADDU SP, S8, ZERO
9D020014  8FBF0034   LW RA, 52(SP)
9D020018  8FBE0030   LW S8, 48(SP)
9D02001C  27BD0038   ADDIU SP, SP, 56
9D020020  03E00008   JR RA
9D020024  00000000   NOP
1866:                /*-----------------------------------------------------------*/
1867:                
1868:                void vTaskPlaceOnEventList( xList * const pxEventList, portTickType xTicksToWait )
1869:                {
9D020028  27BDFFE0   ADDIU SP, SP, -32
9D02002C  AFBF001C   SW RA, 28(SP)
9D020030  AFBE0018   SW S8, 24(SP)
9D020034  03A0F021   ADDU S8, SP, ZERO
9D020038  AFC40020   SW A0, 32(S8)
9D02003C  AFC50024   SW A1, 36(S8)
1870:                portTickType xTimeToWake;
1871:                
1872:                	configASSERT( pxEventList );
9D020040  8FC20020   LW V0, 32(S8)
9D020044  14400006   BNE V0, ZERO, 0x9D020060
9D020048  00000000   NOP
9D02004C  3C029D03   LUI V0, -25341
9D020050  24446054   ADDIU A0, V0, 24660
9D020054  24050750   ADDIU A1, ZERO, 1872
9D020058  0F40C5F5   JAL vAssertCalled
9D02005C  00000000   NOP
1873:                
1874:                	/* THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED OR THE
1875:                	SCHEDULER SUSPENDED. */
1876:                
1877:                	/* Place the event list item of the TCB in the appropriate event list.
1878:                	This is placed in the list in priority order so the highest priority task
1879:                	is the first to be woken by the event. */
1880:                	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
9D020060  8F828094   LW V0, -32620(GP)
9D020064  24420018   ADDIU V0, V0, 24
9D020068  8FC40020   LW A0, 32(S8)
9D02006C  00402821   ADDU A1, V0, ZERO
9D020070  0F40D0F6   JAL vListInsert
9D020074  00000000   NOP
1881:                
1882:                	/* We must remove ourselves from the ready list before adding ourselves
1883:                	to the blocked list as the same list item is used for both lists.  We have
1884:                	exclusive access to the ready lists as the scheduler is locked. */
1885:                	if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( unsigned portBASE_TYPE ) 0 )
9D020078  8F828094   LW V0, -32620(GP)
9D02007C  24420004   ADDIU V0, V0, 4
9D020080  00402021   ADDU A0, V0, ZERO
9D020084  0F40D131   JAL uxListRemove
9D020088  00000000   NOP
9D02008C  14400009   BNE V0, ZERO, 0x9D0200B4
9D020090  00000000   NOP
1886:                	{
1887:                		/* The current task must be in a ready list, so there is no need to
1888:                		check, and the port reset macro can be called directly. */
1889:                		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
9D020094  8F828094   LW V0, -32620(GP)
9D020098  8C42002C   LW V0, 44(V0)
9D02009C  24030001   ADDIU V1, ZERO, 1
9D0200A0  00431004   SLLV V0, V1, V0
9D0200A4  00021827   NOR V1, ZERO, V0
9D0200A8  8F8280A0   LW V0, -32608(GP)
9D0200AC  00621024   AND V0, V1, V0
9D0200B0  AF8280A0   SW V0, -32608(GP)
1890:                	}
1891:                
1892:                	#if ( INCLUDE_vTaskSuspend == 1 )
1893:                	{
1894:                		if( xTicksToWait == portMAX_DELAY )
9D0200B4  8FC30024   LW V1, 36(S8)
9D0200B8  2402FFFF   ADDIU V0, ZERO, -1
9D0200BC  1462000A   BNE V1, V0, 0x9D0200E8
9D0200C0  00000000   NOP
1895:                		{
1896:                			/* Add ourselves to the suspended task list instead of a delayed task
1897:                			list to ensure we are not woken by a timing event.  We will block
1898:                			indefinitely. */
1899:                			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
9D0200C4  8F828094   LW V0, -32620(GP)
9D0200C8  24420004   ADDIU V0, V0, 4
9D0200CC  3C03A000   LUI V1, -24576
9D0200D0  246404F8   ADDIU A0, V1, 1272
9D0200D4  00402821   ADDU A1, V0, ZERO
9D0200D8  0F40D0D3   JAL vListInsertEnd
9D0200DC  00000000   NOP
9D0200E0  0B408041   J 0x9D020104
9D0200E4  00000000   NOP
1900:                		}
1901:                		else
1902:                		{
1903:                			/* Calculate the time at which the task should be woken if the event does
1904:                			not occur.  This may overflow but this doesn't matter. */
1905:                			xTimeToWake = xTickCount + xTicksToWait;
9D0200E8  8F83809C   LW V1, -32612(GP)
9D0200EC  8FC20024   LW V0, 36(S8)
9D0200F0  00621021   ADDU V0, V1, V0
9D0200F4  AFC20010   SW V0, 16(S8)
1906:                			prvAddCurrentTaskToDelayedList( xTimeToWake );
9D0200F8  8FC40010   LW A0, 16(S8)
9D0200FC  0F4081E2   JAL prvAddCurrentTaskToDelayedList
9D020100  00000000   NOP
1907:                		}
1908:                	}
1909:                	#else /* INCLUDE_vTaskSuspend */
1910:                	{
1911:                			/* Calculate the time at which the task should be woken if the event does
1912:                			not occur.  This may overflow but this doesn't matter. */
1913:                			xTimeToWake = xTickCount + xTicksToWait;
1914:                			prvAddCurrentTaskToDelayedList( xTimeToWake );
1915:                	}
1916:                	#endif /* INCLUDE_vTaskSuspend */
1917:                }
9D020104  03C0E821   ADDU SP, S8, ZERO
9D020108  8FBF001C   LW RA, 28(SP)
9D02010C  8FBE0018   LW S8, 24(SP)
9D020110  27BD0020   ADDIU SP, SP, 32
9D020114  03E00008   JR RA
9D020118  00000000   NOP
1918:                /*-----------------------------------------------------------*/
1919:                
1920:                #if configUSE_TIMERS == 1
1921:                
1922:                	void vTaskPlaceOnEventListRestricted( xList * const pxEventList, portTickType xTicksToWait )
1923:                	{
9D02011C  27BDFFE0   ADDIU SP, SP, -32
9D020120  AFBF001C   SW RA, 28(SP)
9D020124  AFBE0018   SW S8, 24(SP)
9D020128  03A0F021   ADDU S8, SP, ZERO
9D02012C  AFC40020   SW A0, 32(S8)
9D020130  AFC50024   SW A1, 36(S8)
1924:                	portTickType xTimeToWake;
1925:                
1926:                		configASSERT( pxEventList );
9D020134  8FC20020   LW V0, 32(S8)
9D020138  14400006   BNE V0, ZERO, 0x9D020154
9D02013C  00000000   NOP
9D020140  3C029D03   LUI V0, -25341
9D020144  24446054   ADDIU A0, V0, 24660
9D020148  24050786   ADDIU A1, ZERO, 1926
9D02014C  0F40C5F5   JAL vAssertCalled
9D020150  00000000   NOP
1927:                
1928:                		/* This function should not be called by application code hence the
1929:                		'Restricted' in its name.  It is not part of the public API.  It is
1930:                		designed for use by kernel code, and has special calling requirements -
1931:                		it should be called from a critical section. */
1932:                
1933:                
1934:                		/* Place the event list item of the TCB in the appropriate event list.
1935:                		In this case it is assume that this is the only task that is going to
1936:                		be waiting on this event list, so the faster vListInsertEnd() function
1937:                		can be used in place of vListInsert. */
1938:                		vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
9D020154  8F828094   LW V0, -32620(GP)
9D020158  24420018   ADDIU V0, V0, 24
9D02015C  8FC40020   LW A0, 32(S8)
9D020160  00402821   ADDU A1, V0, ZERO
9D020164  0F40D0D3   JAL vListInsertEnd
9D020168  00000000   NOP
1939:                
1940:                		/* We must remove this task from the ready list before adding it to the
1941:                		blocked list as the same list item is used for both lists.  This
1942:                		function is called form a critical section. */
1943:                		if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( unsigned portBASE_TYPE ) 0 )
9D02016C  8F828094   LW V0, -32620(GP)
9D020170  24420004   ADDIU V0, V0, 4
9D020174  00402021   ADDU A0, V0, ZERO
9D020178  0F40D131   JAL uxListRemove
9D02017C  00000000   NOP
9D020180  14400009   BNE V0, ZERO, 0x9D0201A8
9D020184  00000000   NOP
1944:                		{
1945:                			/* The current task must be in a ready list, so there is no need to
1946:                			check, and the port reset macro can be called directly. */
1947:                			portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
9D020188  8F828094   LW V0, -32620(GP)
9D02018C  8C42002C   LW V0, 44(V0)
9D020190  24030001   ADDIU V1, ZERO, 1
9D020194  00431004   SLLV V0, V1, V0
9D020198  00021827   NOR V1, ZERO, V0
9D02019C  8F8280A0   LW V0, -32608(GP)
9D0201A0  00621024   AND V0, V1, V0
9D0201A4  AF8280A0   SW V0, -32608(GP)
1948:                		}
1949:                
1950:                		/* Calculate the time at which the task should be woken if the event does
1951:                		not occur.  This may overflow but this doesn't matter. */
1952:                		xTimeToWake = xTickCount + xTicksToWait;
9D0201A8  8F83809C   LW V1, -32612(GP)
9D0201AC  8FC20024   LW V0, 36(S8)
9D0201B0  00621021   ADDU V0, V1, V0
9D0201B4  AFC20010   SW V0, 16(S8)
1953:                
1954:                		traceTASK_DELAY_UNTIL();
1955:                		prvAddCurrentTaskToDelayedList( xTimeToWake );
9D0201B8  8FC40010   LW A0, 16(S8)
9D0201BC  0F4081E2   JAL prvAddCurrentTaskToDelayedList
9D0201C0  00000000   NOP
1956:                	}
9D0201C4  03C0E821   ADDU SP, S8, ZERO
9D0201C8  8FBF001C   LW RA, 28(SP)
9D0201CC  8FBE0018   LW S8, 24(SP)
9D0201D0  27BD0020   ADDIU SP, SP, 32
9D0201D4  03E00008   JR RA
9D0201D8  00000000   NOP
1957:                
1958:                #endif /* configUSE_TIMERS */
1959:                /*-----------------------------------------------------------*/
1960:                
1961:                signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
1962:                {
9D0201DC  27BDFFE0   ADDIU SP, SP, -32
9D0201E0  AFBF001C   SW RA, 28(SP)
9D0201E4  AFBE0018   SW S8, 24(SP)
9D0201E8  03A0F021   ADDU S8, SP, ZERO
9D0201EC  AFC40020   SW A0, 32(S8)
1963:                tskTCB *pxUnblockedTCB;
1964:                portBASE_TYPE xReturn;
1965:                
1966:                	/* THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED OR THE
1967:                	SCHEDULER SUSPENDED.  It can also be called from within an ISR. */
1968:                
1969:                	/* The event list is sorted in priority order, so we can remove the
1970:                	first in the list, remove the TCB from the delayed list, and add
1971:                	it to the ready list.
1972:                
1973:                	If an event is for a queue that is locked then this function will never
1974:                	get called - the lock count on the queue will get modified instead.  This
1975:                	means we can always expect exclusive access to the event list here.
1976:                
1977:                	This function assumes that a check has already been made to ensure that
1978:                	pxEventList is not empty. */
1979:                	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
9D0201F0  8FC20020   LW V0, 32(S8)
9D0201F4  8C42000C   LW V0, 12(V0)
9D0201F8  8C42000C   LW V0, 12(V0)
9D0201FC  AFC20014   SW V0, 20(S8)
1980:                	configASSERT( pxUnblockedTCB );
9D020200  8FC20014   LW V0, 20(S8)
9D020204  14400006   BNE V0, ZERO, 0x9D020220
9D020208  00000000   NOP
9D02020C  3C029D03   LUI V0, -25341
9D020210  24446054   ADDIU A0, V0, 24660
9D020214  240507BC   ADDIU A1, ZERO, 1980
9D020218  0F40C5F5   JAL vAssertCalled
9D02021C  00000000   NOP
1981:                	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
9D020220  8FC20014   LW V0, 20(S8)
9D020224  24420018   ADDIU V0, V0, 24
9D020228  00402021   ADDU A0, V0, ZERO
9D02022C  0F40D131   JAL uxListRemove
9D020230  00000000   NOP
1982:                
1983:                	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
9D020234  8F8280A8   LW V0, -32600(GP)
9D020238  1440001C   BNE V0, ZERO, 0x9D0202AC
9D02023C  00000000   NOP
1984:                	{
1985:                		( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
9D020240  8FC20014   LW V0, 20(S8)
9D020244  24420004   ADDIU V0, V0, 4
9D020248  00402021   ADDU A0, V0, ZERO
9D02024C  0F40D131   JAL uxListRemove
9D020250  00000000   NOP
1986:                		prvAddTaskToReadyList( pxUnblockedTCB );
9D020254  8FC20014   LW V0, 20(S8)
9D020258  8C42002C   LW V0, 44(V0)
9D02025C  24030001   ADDIU V1, ZERO, 1
9D020260  00431804   SLLV V1, V1, V0
9D020264  8F8280A0   LW V0, -32608(GP)
9D020268  00621025   OR V0, V1, V0
9D02026C  AF8280A0   SW V0, -32608(GP)
9D020270  8FC20014   LW V0, 20(S8)
9D020274  8C43002C   LW V1, 44(V0)
9D020278  24020014   ADDIU V0, ZERO, 20
9D02027C  70621802   MUL V1, V1, V0
9D020280  3C02A000   LUI V0, -24576
9D020284  24420480   ADDIU V0, V0, 1152
9D020288  00621821   ADDU V1, V1, V0
9D02028C  8FC20014   LW V0, 20(S8)
9D020290  24420004   ADDIU V0, V0, 4
9D020294  00602021   ADDU A0, V1, ZERO
9D020298  00402821   ADDU A1, V0, ZERO
9D02029C  0F40D0D3   JAL vListInsertEnd
9D0202A0  00000000   NOP
9D0202A4  0B4080B2   J 0x9D0202C8
9D0202A8  00000000   NOP
1987:                	}
1988:                	else
1989:                	{
1990:                		/* We cannot access the delayed or ready lists, so will hold this
1991:                		task pending until the scheduler is resumed. */
1992:                		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
9D0202AC  8FC20014   LW V0, 20(S8)
9D0202B0  24420018   ADDIU V0, V0, 24
9D0202B4  3C03A000   LUI V1, -24576
9D0202B8  246404E4   ADDIU A0, V1, 1252
9D0202BC  00402821   ADDU A1, V0, ZERO
9D0202C0  0F40D0D3   JAL vListInsertEnd
9D0202C4  00000000   NOP
1993:                	}
1994:                
1995:                	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
9D0202C8  8FC20014   LW V0, 20(S8)
9D0202CC  8C43002C   LW V1, 44(V0)
9D0202D0  8F828094   LW V0, -32620(GP)
9D0202D4  8C42002C   LW V0, 44(V0)
9D0202D8  0062102B   SLTU V0, V1, V0
9D0202DC  14400007   BNE V0, ZERO, 0x9D0202FC
9D0202E0  00000000   NOP
1996:                	{
1997:                		/* Return true if the task removed from the event list has
1998:                		a higher priority than the calling task.  This allows
1999:                		the calling task to know if it should force a context
2000:                		switch now. */
2001:                		xReturn = pdTRUE;
9D0202E4  24020001   ADDIU V0, ZERO, 1
9D0202E8  AFC20010   SW V0, 16(S8)
2002:                
2003:                		/* Mark that a yield is pending in case the user is not using the
2004:                		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
2005:                		xYieldPending = pdTRUE;
9D0202EC  24020001   ADDIU V0, ZERO, 1
9D0202F0  AF8280B0   SW V0, -32592(GP)
9D0202F4  0B4080C0   J 0x9D020300
9D0202F8  00000000   NOP
2006:                	}
2007:                	else
2008:                	{
2009:                		xReturn = pdFALSE;
9D0202FC  AFC00010   SW ZERO, 16(S8)
2010:                	}
2011:                
2012:                	return xReturn;
9D020300  8FC20010   LW V0, 16(S8)
2013:                }
9D020304  03C0E821   ADDU SP, S8, ZERO
9D020308  8FBF001C   LW RA, 28(SP)
9D02030C  8FBE0018   LW S8, 24(SP)
9D020310  27BD0020   ADDIU SP, SP, 32
9D020314  03E00008   JR RA
9D020318  00000000   NOP
2014:                /*-----------------------------------------------------------*/
2015:                
2016:                void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
2017:                {
9D02031C  27BDFFE8   ADDIU SP, SP, -24
9D020320  AFBF0014   SW RA, 20(SP)
9D020324  AFBE0010   SW S8, 16(SP)
9D020328  03A0F021   ADDU S8, SP, ZERO
9D02032C  AFC40018   SW A0, 24(S8)
2018:                	configASSERT( pxTimeOut );
9D020330  8FC20018   LW V0, 24(S8)
9D020334  14400006   BNE V0, ZERO, 0x9D020350
9D020338  00000000   NOP
9D02033C  3C029D03   LUI V0, -25341
9D020340  24446054   ADDIU A0, V0, 24660
9D020344  240507E2   ADDIU A1, ZERO, 2018
9D020348  0F40C5F5   JAL vAssertCalled
9D02034C  00000000   NOP
2019:                	pxTimeOut->xOverflowCount = xNumOfOverflows;
9D020350  8F8380B4   LW V1, -32588(GP)
9D020354  8FC20018   LW V0, 24(S8)
9D020358  AC430000   SW V1, 0(V0)
2020:                	pxTimeOut->xTimeOnEntering = xTickCount;
9D02035C  8F83809C   LW V1, -32612(GP)
9D020360  8FC20018   LW V0, 24(S8)
9D020364  AC430004   SW V1, 4(V0)
2021:                }
9D020368  03C0E821   ADDU SP, S8, ZERO
9D02036C  8FBF0014   LW RA, 20(SP)
9D020370  8FBE0010   LW S8, 16(SP)
9D020374  27BD0018   ADDIU SP, SP, 24
9D020378  03E00008   JR RA
9D02037C  00000000   NOP
2022:                /*-----------------------------------------------------------*/
2023:                
2024:                portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
2025:                {
9D020380  27BDFFE0   ADDIU SP, SP, -32
9D020384  AFBF001C   SW RA, 28(SP)
9D020388  AFBE0018   SW S8, 24(SP)
9D02038C  03A0F021   ADDU S8, SP, ZERO
9D020390  AFC40020   SW A0, 32(S8)
9D020394  AFC50024   SW A1, 36(S8)
2026:                portBASE_TYPE xReturn;
2027:                
2028:                	configASSERT( pxTimeOut );
9D020398  8FC20020   LW V0, 32(S8)
9D02039C  14400006   BNE V0, ZERO, 0x9D0203B8
9D0203A0  00000000   NOP
9D0203A4  3C029D03   LUI V0, -25341
9D0203A8  24446054   ADDIU A0, V0, 24660
9D0203AC  240507EC   ADDIU A1, ZERO, 2028
9D0203B0  0F40C5F5   JAL vAssertCalled
9D0203B4  00000000   NOP
2029:                	configASSERT( pxTicksToWait );
9D0203B8  8FC20024   LW V0, 36(S8)
9D0203BC  14400006   BNE V0, ZERO, 0x9D0203D8
9D0203C0  00000000   NOP
9D0203C4  3C029D03   LUI V0, -25341
9D0203C8  24446054   ADDIU A0, V0, 24660
9D0203CC  240507ED   ADDIU A1, ZERO, 2029
9D0203D0  0F40C5F5   JAL vAssertCalled
9D0203D4  00000000   NOP
2030:                
2031:                	taskENTER_CRITICAL();
9D0203D8  0F40834C   JAL vTaskEnterCritical
9D0203DC  00000000   NOP
2032:                	{
2033:                		/* Minor optimisation.  The tick count cannot change in this block. */
2034:                		const portTickType xConstTickCount = xTickCount;
9D0203E0  8F82809C   LW V0, -32612(GP)
9D0203E4  AFC20014   SW V0, 20(S8)
2035:                
2036:                		#if ( INCLUDE_vTaskSuspend == 1 )
2037:                			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
2038:                			the maximum block time then the task should block indefinitely, and
2039:                			therefore never time out. */
2040:                			if( *pxTicksToWait == portMAX_DELAY )
9D0203E8  8FC20024   LW V0, 36(S8)
9D0203EC  8C430000   LW V1, 0(V0)
9D0203F0  2402FFFF   ADDIU V0, ZERO, -1
9D0203F4  14620004   BNE V1, V0, 0x9D020408
9D0203F8  00000000   NOP
2041:                			{
2042:                				xReturn = pdFALSE;
9D0203FC  AFC00010   SW ZERO, 16(S8)
9D020400  0B40812B   J 0x9D0204AC
9D020404  00000000   NOP
2043:                			}
2044:                			else /* We are not blocking indefinitely, perform the checks below. */
2045:                		#endif
2046:                
2047:                		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
9D020408  8FC20020   LW V0, 32(S8)
9D02040C  8C430000   LW V1, 0(V0)
9D020410  8F8280B4   LW V0, -32588(GP)
9D020414  1062000B   BEQ V1, V0, 0x9D020444
9D020418  00000000   NOP
9D02041C  8FC20020   LW V0, 32(S8)
9D020420  8C430004   LW V1, 4(V0)
9D020424  8FC20014   LW V0, 20(S8)
9D020428  0043102B   SLTU V0, V0, V1
9D02042C  14400005   BNE V0, ZERO, 0x9D020444
9D020430  00000000   NOP
2048:                		{
2049:                			/* The tick count is greater than the time at which vTaskSetTimeout()
2050:                			was called, but has also overflowed since vTaskSetTimeOut() was called.
2051:                			It must have wrapped all the way around and gone past us again. This
2052:                			passed since vTaskSetTimeout() was called. */
2053:                			xReturn = pdTRUE;
9D020434  24020001   ADDIU V0, ZERO, 1
9D020438  AFC20010   SW V0, 16(S8)
9D02043C  0B40812B   J 0x9D0204AC
9D020440  00000000   NOP
2054:                		}
2055:                		else if( ( xConstTickCount - pxTimeOut->xTimeOnEntering ) < *pxTicksToWait )
9D020444  8FC20020   LW V0, 32(S8)
9D020448  8C420004   LW V0, 4(V0)
9D02044C  8FC30014   LW V1, 20(S8)
9D020450  00621823   SUBU V1, V1, V0
9D020454  8FC20024   LW V0, 36(S8)
9D020458  8C420000   LW V0, 0(V0)
9D02045C  0062102B   SLTU V0, V1, V0
9D020460  10400010   BEQ V0, ZERO, 0x9D0204A4
9D020464  00000000   NOP
2056:                		{
2057:                			/* Not a genuine timeout. Adjust parameters for time remaining. */
2058:                			*pxTicksToWait -= ( xConstTickCount -  pxTimeOut->xTimeOnEntering );
9D020468  8FC20024   LW V0, 36(S8)
9D02046C  8C430000   LW V1, 0(V0)
9D020470  8FC20020   LW V0, 32(S8)
9D020474  8C440004   LW A0, 4(V0)
9D020478  8FC20014   LW V0, 20(S8)
9D02047C  00821023   SUBU V0, A0, V0
9D020480  00621821   ADDU V1, V1, V0
9D020484  8FC20024   LW V0, 36(S8)
9D020488  AC430000   SW V1, 0(V0)
2059:                			vTaskSetTimeOutState( pxTimeOut );
9D02048C  8FC40020   LW A0, 32(S8)
9D020490  0F4080C7   JAL vTaskSetTimeOutState
9D020494  00000000   NOP
2060:                			xReturn = pdFALSE;
9D020498  AFC00010   SW ZERO, 16(S8)
9D02049C  0B40812B   J 0x9D0204AC
9D0204A0  00000000   NOP
2061:                		}
2062:                		else
2063:                		{
2064:                			xReturn = pdTRUE;
9D0204A4  24020001   ADDIU V0, ZERO, 1
9D0204A8  AFC20010   SW V0, 16(S8)
2065:                		}
2066:                	}
2067:                	taskEXIT_CRITICAL();
9D0204AC  0F40836C   JAL vTaskExitCritical
9D0204B0  00000000   NOP
2068:                
2069:                	return xReturn;
9D0204B4  8FC20010   LW V0, 16(S8)
2070:                }
9D0204B8  03C0E821   ADDU SP, S8, ZERO
9D0204BC  8FBF001C   LW RA, 28(SP)
9D0204C0  8FBE0018   LW S8, 24(SP)
9D0204C4  27BD0020   ADDIU SP, SP, 32
9D0204C8  03E00008   JR RA
9D0204CC  00000000   NOP
2071:                /*-----------------------------------------------------------*/
2072:                
2073:                void vTaskMissedYield( void )
2074:                {
9D0204D0  27BDFFF8   ADDIU SP, SP, -8
9D0204D4  AFBE0004   SW S8, 4(SP)
9D0204D8  03A0F021   ADDU S8, SP, ZERO
2075:                	xYieldPending = pdTRUE;
9D0204DC  24020001   ADDIU V0, ZERO, 1
9D0204E0  AF8280B0   SW V0, -32592(GP)
2076:                }
9D0204E4  03C0E821   ADDU SP, S8, ZERO
9D0204E8  8FBE0004   LW S8, 4(SP)
9D0204EC  27BD0008   ADDIU SP, SP, 8
9D0204F0  03E00008   JR RA
9D0204F4  00000000   NOP
2077:                /*-----------------------------------------------------------*/
2078:                
2079:                #if ( configUSE_TRACE_FACILITY == 1 )
2080:                
2081:                	unsigned portBASE_TYPE uxTaskGetTaskNumber( xTaskHandle xTask )
2082:                	{
2083:                	unsigned portBASE_TYPE uxReturn;
2084:                	tskTCB *pxTCB;
2085:                
2086:                		if( xTask != NULL )
2087:                		{
2088:                			pxTCB = ( tskTCB * ) xTask;
2089:                			uxReturn = pxTCB->uxTaskNumber;
2090:                		}
2091:                		else
2092:                		{
2093:                			uxReturn = 0U;
2094:                		}
2095:                
2096:                		return uxReturn;
2097:                	}
2098:                
2099:                #endif /* configUSE_TRACE_FACILITY */
2100:                /*-----------------------------------------------------------*/
2101:                
2102:                #if ( configUSE_TRACE_FACILITY == 1 )
2103:                
2104:                	void vTaskSetTaskNumber( xTaskHandle xTask, unsigned portBASE_TYPE uxHandle )
2105:                	{
2106:                	tskTCB *pxTCB;
2107:                
2108:                		if( xTask != NULL )
2109:                		{
2110:                			pxTCB = ( tskTCB * ) xTask;
2111:                			pxTCB->uxTaskNumber = uxHandle;
2112:                		}
2113:                	}
2114:                
2115:                #endif /* configUSE_TRACE_FACILITY */
2116:                
2117:                /*
2118:                 * -----------------------------------------------------------
2119:                 * The Idle task.
2120:                 * ----------------------------------------------------------
2121:                 *
2122:                 * The portTASK_FUNCTION() macro is used to allow port/compiler specific
2123:                 * language extensions.  The equivalent prototype for this function is:
2124:                 *
2125:                 * void prvIdleTask( void *pvParameters );
2126:                 *
2127:                 */
2128:                static portTASK_FUNCTION( prvIdleTask, pvParameters )
2129:                {
9D0204F8  27BDFFE0   ADDIU SP, SP, -32
9D0204FC  AFBF001C   SW RA, 28(SP)
9D020500  AFBE0018   SW S8, 24(SP)
9D020504  03A0F021   ADDU S8, SP, ZERO
9D020508  AFC40020   SW A0, 32(S8)
9D02050C  0B408146   J 0x9D020518
9D020510  00000000   NOP
2130:                	/* Stop warnings. */
2131:                	( void ) pvParameters;
2132:                
2133:                	for( ;; )
2134:                	{
2135:                		/* See if any tasks have been deleted. */
2136:                		prvCheckTasksWaitingTermination();
9D020518  0F4081DA   JAL prvCheckTasksWaitingTermination
9D02051C  00000000   NOP
2137:                
2138:                		#if ( configUSE_PREEMPTION == 0 )
2139:                		{
2140:                			/* If we are not using preemption we keep forcing a task switch to
2141:                			see if any other task has become available.  If we are using
2142:                			preemption we don't need to do this as any task becoming available
2143:                			will automatically get the processor anyway. */
2144:                			taskYIELD();
2145:                		}
2146:                		#endif /* configUSE_PREEMPTION */
2147:                
2148:                		#if ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) )
2149:                		{
2150:                			/* When using preemption tasks of equal priority will be
2151:                			timesliced.  If a task that is sharing the idle priority is ready
2152:                			to run then the idle task should yield before the end of the
2153:                			timeslice.
2154:                
2155:                			A critical region is not required here as we are just reading from
2156:                			the list, and an occasional incorrect value will not matter.  If
2157:                			the ready list at the idle priority contains more than one task
2158:                			then a task other than the idle task is ready to execute. */
2159:                			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
9D020520  3C02A000   LUI V0, -24576
9D020524  8C420480   LW V0, 1152(V0)
9D020528  2C420002   SLTIU V0, V0, 2
9D02052C  1440FFF9   BNE V0, ZERO, 0x9D020514
9D020530  00000000   NOP
2160:                			{
2161:                				taskYIELD();
9D020534  40026800   MFC0 V0, Cause
9D020538  AFC20010   SW V0, 16(S8)
9D02053C  8FC20010   LW V0, 16(S8)
9D020540  34420100   ORI V0, V0, 256
9D020544  AFC20010   SW V0, 16(S8)
9D020548  8FC20010   LW V0, 16(S8)
9D02054C  40826800   MTC0 V0, Cause
9D020550  000000C0   EHB
2162:                			}
2163:                		}
2164:                		#endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) ) */
2165:                
2166:                		#if ( configUSE_IDLE_HOOK == 1 )
2167:                		{
2168:                			extern void vApplicationIdleHook( void );
2169:                
2170:                			/* Call the user defined function from within the idle task.  This
2171:                			allows the application designer to add background functionality
2172:                			without the overhead of a separate task.
2173:                			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
2174:                			CALL A FUNCTION THAT MIGHT BLOCK. */
2175:                			vApplicationIdleHook();
2176:                		}
2177:                		#endif /* configUSE_IDLE_HOOK */
2178:                
2179:                		/* This conditional compilation should use inequality to 0, not equality
2180:                		to 1.  This is to ensure portSUPPRESS_TICKS_AND_SLEEP() is called when
2181:                		user defined low power mode	implementations require
2182:                		configUSE_TICKLESS_IDLE to be set to a value other than 1. */
2183:                		#if ( configUSE_TICKLESS_IDLE != 0 )
2184:                		{
2185:                		portTickType xExpectedIdleTime;
2186:                
2187:                			/* It is not desirable to suspend then resume the scheduler on
2188:                			each iteration of the idle task.  Therefore, a preliminary
2189:                			test of the expected idle time is performed without the
2190:                			scheduler suspended.  The result here is not necessarily
2191:                			valid. */
2192:                			xExpectedIdleTime = prvGetExpectedIdleTime();
2193:                
2194:                			if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
2195:                			{
2196:                				vTaskSuspendAll();
2197:                				{
2198:                					/* Now the scheduler is suspended, the expected idle
2199:                					time can be sampled again, and this time its value can
2200:                					be used. */
2201:                					configASSERT( xNextTaskUnblockTime >= xTickCount );
2202:                					xExpectedIdleTime = prvGetExpectedIdleTime();
2203:                
2204:                					if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
2205:                					{
2206:                						traceLOW_POWER_IDLE_BEGIN();
2207:                						portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime );
2208:                						traceLOW_POWER_IDLE_END();
2209:                					}
2210:                				}
2211:                				( void ) xTaskResumeAll();
2212:                			}
2213:                		}
2214:                		#endif /* configUSE_TICKLESS_IDLE */
2215:                	}
9D020514  00000000   NOP
9D020554  0B408146   J 0x9D020518
9D020558  00000000   NOP
2216:                }
2217:                /*-----------------------------------------------------------*/
2218:                
2219:                #if configUSE_TICKLESS_IDLE != 0
2220:                
2221:                	eSleepModeStatus eTaskConfirmSleepModeStatus( void )
2222:                	{
2223:                	eSleepModeStatus eReturn = eStandardSleep;
2224:                
2225:                		if( listCURRENT_LIST_LENGTH( &xPendingReadyList ) != 0 )
2226:                		{
2227:                			/* A task was made ready while the scheduler was suspended. */
2228:                			eReturn = eAbortSleep;
2229:                		}
2230:                		else if( xYieldPending != pdFALSE )
2231:                		{
2232:                			/* A yield was pended while the scheduler was suspended. */
2233:                			eReturn = eAbortSleep;
2234:                		}
2235:                		else
2236:                		{
2237:                			#if configUSE_TIMERS == 0
2238:                			{
2239:                				/* The idle task exists in addition to the application tasks. */
2240:                				const unsigned portBASE_TYPE uxNonApplicationTasks = 1;
2241:                
2242:                				/* If timers are not being used and all the tasks are in the
2243:                				suspended list (which might mean they have an infinite block
2244:                				time rather than actually being suspended) then it is safe to
2245:                				turn all clocks off and just wait for external interrupts. */
2246:                				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == ( uxCurrentNumberOfTasks - uxNonApplicationTasks ) )
2247:                				{
2248:                					eReturn = eNoTasksWaitingTimeout;
2249:                				}
2250:                			}
2251:                			#endif /* configUSE_TIMERS */
2252:                		}
2253:                
2254:                		return eReturn;
2255:                	}
2256:                #endif /* configUSE_TICKLESS_IDLE */
2257:                /*-----------------------------------------------------------*/
2258:                
2259:                static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned portBASE_TYPE uxPriority, const xMemoryRegion * const xRegions, unsigned short usStackDepth )
2260:                {
9D02055C  27BDFFD8   ADDIU SP, SP, -40
9D020560  AFBF0024   SW RA, 36(SP)
9D020564  AFBE0020   SW S8, 32(SP)
9D020568  03A0F021   ADDU S8, SP, ZERO
9D02056C  AFC40028   SW A0, 40(S8)
9D020570  AFC5002C   SW A1, 44(S8)
9D020574  AFC60030   SW A2, 48(S8)
9D020578  AFC70034   SW A3, 52(S8)
9D02057C  8FC20038   LW V0, 56(S8)
9D020580  A7C20018   SH V0, 24(S8)
2261:                unsigned portBASE_TYPE x;
2262:                
2263:                	/* Store the task name in the TCB. */
2264:                	for( x = ( unsigned portBASE_TYPE ) 0; x < ( unsigned portBASE_TYPE ) configMAX_TASK_NAME_LEN; x++ )
9D020584  AFC00010   SW ZERO, 16(S8)
9D020588  0B408175   J 0x9D0205D4
9D02058C  00000000   NOP
9D0205C8  8FC20010   LW V0, 16(S8)
9D0205CC  24420001   ADDIU V0, V0, 1
9D0205D0  AFC20010   SW V0, 16(S8)
9D0205D4  8FC20010   LW V0, 16(S8)
9D0205D8  2C420008   SLTIU V0, V0, 8
9D0205DC  1440FFEC   BNE V0, ZERO, 0x9D020590
9D0205E0  00000000   NOP
9D0205E4  0B40817C   J 0x9D0205F0
9D0205E8  00000000   NOP
2265:                	{
2266:                		pxTCB->pcTaskName[ x ] = pcName[ x ];
9D020590  8FC3002C   LW V1, 44(S8)
9D020594  8FC20010   LW V0, 16(S8)
9D020598  00621021   ADDU V0, V1, V0
9D02059C  80430000   LB V1, 0(V0)
9D0205A0  8FC40028   LW A0, 40(S8)
9D0205A4  8FC20010   LW V0, 16(S8)
9D0205A8  00821021   ADDU V0, A0, V0
9D0205AC  A0430034   SB V1, 52(V0)
2267:                
2268:                		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
2269:                		configMAX_TASK_NAME_LEN characters just in case the memory after the
2270:                		string is not accessible (extremely unlikely). */
2271:                		if( pcName[ x ] == 0x00 )
9D0205B0  8FC3002C   LW V1, 44(S8)
9D0205B4  8FC20010   LW V0, 16(S8)
9D0205B8  00621021   ADDU V0, V1, V0
9D0205BC  80420000   LB V0, 0(V0)
9D0205C0  1040000A   BEQ V0, ZERO, 0x9D0205EC
9D0205C4  00000000   NOP
2272:                		{
2273:                			break;
9D0205EC  00000000   NOP
2274:                		}
2275:                	}
2276:                
2277:                	/* Ensure the name string is terminated in the case that the string length
2278:                	was greater or equal to configMAX_TASK_NAME_LEN. */
2279:                	pxTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = ( signed char ) '\0';
9D0205F0  8FC20028   LW V0, 40(S8)
9D0205F4  A040003B   SB ZERO, 59(V0)
2280:                
2281:                	/* This is used as an array index so must ensure it's not too large.  First
2282:                	remove the privilege bit if one is present. */
2283:                	if( uxPriority >= ( unsigned portBASE_TYPE ) configMAX_PRIORITIES )
9D0205F8  8FC20030   LW V0, 48(S8)
9D0205FC  2C420005   SLTIU V0, V0, 5
9D020600  14400003   BNE V0, ZERO, 0x9D020610
9D020604  00000000   NOP
2284:                	{
2285:                		uxPriority = ( unsigned portBASE_TYPE ) configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
9D020608  24020004   ADDIU V0, ZERO, 4
9D02060C  AFC20030   SW V0, 48(S8)
2286:                	}
2287:                
2288:                	pxTCB->uxPriority = uxPriority;
9D020610  8FC20028   LW V0, 40(S8)
9D020614  8FC30030   LW V1, 48(S8)
9D020618  AC43002C   SW V1, 44(V0)
2289:                	#if ( configUSE_MUTEXES == 1 )
2290:                	{
2291:                		pxTCB->uxBasePriority = uxPriority;
9D02061C  8FC20028   LW V0, 40(S8)
9D020620  8FC30030   LW V1, 48(S8)
9D020624  AC430040   SW V1, 64(V0)
2292:                	}
2293:                	#endif /* configUSE_MUTEXES */
2294:                
2295:                	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
9D020628  8FC20028   LW V0, 40(S8)
9D02062C  24420004   ADDIU V0, V0, 4
9D020630  00402021   ADDU A0, V0, ZERO
9D020634  0F40D0C8   JAL vListInitialiseItem
9D020638  00000000   NOP
2296:                	vListInitialiseItem( &( pxTCB->xEventListItem ) );
9D02063C  8FC20028   LW V0, 40(S8)
9D020640  24420018   ADDIU V0, V0, 24
9D020644  00402021   ADDU A0, V0, ZERO
9D020648  0F40D0C8   JAL vListInitialiseItem
9D02064C  00000000   NOP
2297:                
2298:                	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
2299:                	back to	the containing TCB from a generic item in a list. */
2300:                	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
9D020650  8FC20028   LW V0, 40(S8)
9D020654  8FC30028   LW V1, 40(S8)
9D020658  AC430010   SW V1, 16(V0)
2301:                
2302:                	/* Event lists are always in priority order. */
2303:                	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( portTickType ) configMAX_PRIORITIES - ( portTickType ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
9D02065C  24030005   ADDIU V1, ZERO, 5
9D020660  8FC20030   LW V0, 48(S8)
9D020664  00621823   SUBU V1, V1, V0
9D020668  8FC20028   LW V0, 40(S8)
9D02066C  AC430018   SW V1, 24(V0)
2304:                	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
9D020670  8FC20028   LW V0, 40(S8)
9D020674  8FC30028   LW V1, 40(S8)
9D020678  AC430024   SW V1, 36(V0)
2305:                
2306:                	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
2307:                	{
2308:                		pxTCB->uxCriticalNesting = ( unsigned portBASE_TYPE ) 0U;
9D02067C  8FC20028   LW V0, 40(S8)
9D020680  AC40003C   SW ZERO, 60(V0)
2309:                	}
2310:                	#endif /* portCRITICAL_NESTING_IN_TCB */
2311:                
2312:                	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
2313:                	{
2314:                		pxTCB->pxTaskTag = NULL;
2315:                	}
2316:                	#endif /* configUSE_APPLICATION_TASK_TAG */
2317:                
2318:                	#if ( configGENERATE_RUN_TIME_STATS == 1 )
2319:                	{
2320:                		pxTCB->ulRunTimeCounter = 0UL;
2321:                	}
2322:                	#endif /* configGENERATE_RUN_TIME_STATS */
2323:                
2324:                	#if ( portUSING_MPU_WRAPPERS == 1 )
2325:                	{
2326:                		vPortStoreTaskMPUSettings( &( pxTCB->xMPUSettings ), xRegions, pxTCB->pxStack, usStackDepth );
2327:                	}
2328:                	#else /* portUSING_MPU_WRAPPERS */
2329:                	{
2330:                		( void ) xRegions;
2331:                		( void ) usStackDepth;
2332:                	}
2333:                	#endif /* portUSING_MPU_WRAPPERS */
2334:                
2335:                	#if ( configUSE_NEWLIB_REENTRANT == 1 )
2336:                	{
2337:                		/* Initialise this task's Newlib reent structure. */
2338:                		_REENT_INIT_PTR( ( &( pxTCB->xNewLib_reent ) ) );
2339:                	}
2340:                	#endif /* configUSE_NEWLIB_REENTRANT */
2341:                }
9D020684  03C0E821   ADDU SP, S8, ZERO
9D020688  8FBF0024   LW RA, 36(SP)
9D02068C  8FBE0020   LW S8, 32(SP)
9D020690  27BD0028   ADDIU SP, SP, 40
9D020694  03E00008   JR RA
9D020698  00000000   NOP
2342:                /*-----------------------------------------------------------*/
2343:                
2344:                #if ( portUSING_MPU_WRAPPERS == 1 )
2345:                
2346:                	void vTaskAllocateMPURegions( xTaskHandle xTaskToModify, const xMemoryRegion * const xRegions )
2347:                	{
2348:                	tskTCB *pxTCB;
2349:                
2350:                		/* If null is passed in here then we are deleting ourselves. */
2351:                		pxTCB = prvGetTCBFromHandle( xTaskToModify );
2352:                
2353:                        vPortStoreTaskMPUSettings( &( pxTCB->xMPUSettings ), xRegions, NULL, 0 );
2354:                	}
2355:                
2356:                #endif /* portUSING_MPU_WRAPPERS */
2357:                /*-----------------------------------------------------------*/
2358:                
2359:                static void prvInitialiseTaskLists( void )
2360:                {
9D02069C  27BDFFE0   ADDIU SP, SP, -32
9D0206A0  AFBF001C   SW RA, 28(SP)
9D0206A4  AFBE0018   SW S8, 24(SP)
9D0206A8  03A0F021   ADDU S8, SP, ZERO
2361:                unsigned portBASE_TYPE uxPriority;
2362:                
2363:                	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < ( unsigned portBASE_TYPE ) configMAX_PRIORITIES; uxPriority++ )
9D0206AC  AFC00010   SW ZERO, 16(S8)
9D0206B0  0B4081BA   J 0x9D0206E8
9D0206B4  00000000   NOP
9D0206DC  8FC20010   LW V0, 16(S8)
9D0206E0  24420001   ADDIU V0, V0, 1
9D0206E4  AFC20010   SW V0, 16(S8)
9D0206E8  8FC20010   LW V0, 16(S8)
9D0206EC  2C420005   SLTIU V0, V0, 5
9D0206F0  1440FFF1   BNE V0, ZERO, 0x9D0206B8
9D0206F4  00000000   NOP
2364:                	{
2365:                		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
9D0206B8  8FC30010   LW V1, 16(S8)
9D0206BC  24020014   ADDIU V0, ZERO, 20
9D0206C0  70621802   MUL V1, V1, V0
9D0206C4  3C02A000   LUI V0, -24576
9D0206C8  24420480   ADDIU V0, V0, 1152
9D0206CC  00621021   ADDU V0, V1, V0
9D0206D0  00402021   ADDU A0, V0, ZERO
9D0206D4  0F40D0AB   JAL vListInitialise
9D0206D8  00000000   NOP
2366:                	}
2367:                
2368:                	vListInitialise( &xDelayedTaskList1 );
9D0206F8  3C02A000   LUI V0, -24576
9D0206FC  2444050C   ADDIU A0, V0, 1292
9D020700  0F40D0AB   JAL vListInitialise
9D020704  00000000   NOP
2369:                	vListInitialise( &xDelayedTaskList2 );
9D020708  3C02A000   LUI V0, -24576
9D02070C  24440520   ADDIU A0, V0, 1312
9D020710  0F40D0AB   JAL vListInitialise
9D020714  00000000   NOP
2370:                	vListInitialise( &xPendingReadyList );
9D020718  3C02A000   LUI V0, -24576
9D02071C  244404E4   ADDIU A0, V0, 1252
9D020720  0F40D0AB   JAL vListInitialise
9D020724  00000000   NOP
2371:                
2372:                	#if ( INCLUDE_vTaskDelete == 1 )
2373:                	{
2374:                		vListInitialise( &xTasksWaitingTermination );
2375:                	}
2376:                	#endif /* INCLUDE_vTaskDelete */
2377:                
2378:                	#if ( INCLUDE_vTaskSuspend == 1 )
2379:                	{
2380:                		vListInitialise( &xSuspendedTaskList );
9D020728  3C02A000   LUI V0, -24576
9D02072C  244404F8   ADDIU A0, V0, 1272
9D020730  0F40D0AB   JAL vListInitialise
9D020734  00000000   NOP
2381:                	}
2382:                	#endif /* INCLUDE_vTaskSuspend */
2383:                
2384:                	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
2385:                	using list2. */
2386:                	pxDelayedTaskList = &xDelayedTaskList1;
9D020738  3C02A000   LUI V0, -24576
9D02073C  2442050C   ADDIU V0, V0, 1292
9D020740  AF8281E0   SW V0, -32288(GP)
2387:                	pxOverflowDelayedTaskList = &xDelayedTaskList2;
9D020744  3C02A000   LUI V0, -24576
9D020748  24420520   ADDIU V0, V0, 1312
9D02074C  AF8281E4   SW V0, -32284(GP)
2388:                }
9D020750  03C0E821   ADDU SP, S8, ZERO
9D020754  8FBF001C   LW RA, 28(SP)
9D020758  8FBE0018   LW S8, 24(SP)
9D02075C  27BD0020   ADDIU SP, SP, 32
9D020760  03E00008   JR RA
9D020764  00000000   NOP
2389:                /*-----------------------------------------------------------*/
2390:                
2391:                static void prvCheckTasksWaitingTermination( void )
2392:                {
9D020768  27BDFFF8   ADDIU SP, SP, -8
9D02076C  AFBE0004   SW S8, 4(SP)
9D020770  03A0F021   ADDU S8, SP, ZERO
2393:                	#if ( INCLUDE_vTaskDelete == 1 )
2394:                	{
2395:                		portBASE_TYPE xListIsEmpty;
2396:                
2397:                		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
2398:                		too often in the idle task. */
2399:                		while( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
2400:                		{
2401:                			vTaskSuspendAll();
2402:                				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
2403:                			( void ) xTaskResumeAll();
2404:                
2405:                			if( xListIsEmpty == pdFALSE )
2406:                			{
2407:                				tskTCB *pxTCB;
2408:                
2409:                				taskENTER_CRITICAL();
2410:                				{
2411:                					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
2412:                					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
2413:                					--uxCurrentNumberOfTasks;
2414:                					--uxTasksDeleted;
2415:                				}
2416:                				taskEXIT_CRITICAL();
2417:                
2418:                				prvDeleteTCB( pxTCB );
2419:                			}
2420:                		}
2421:                	}
2422:                	#endif /* vTaskDelete */
2423:                }
9D020774  03C0E821   ADDU SP, S8, ZERO
9D020778  8FBE0004   LW S8, 4(SP)
9D02077C  27BD0008   ADDIU SP, SP, 8
9D020780  03E00008   JR RA
9D020784  00000000   NOP
2424:                /*-----------------------------------------------------------*/
2425:                
2426:                static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
2427:                {
9D020788  27BDFFE8   ADDIU SP, SP, -24
9D02078C  AFBF0014   SW RA, 20(SP)
9D020790  AFBE0010   SW S8, 16(SP)
9D020794  03A0F021   ADDU S8, SP, ZERO
9D020798  AFC40018   SW A0, 24(S8)
2428:                	/* The list item will be inserted in wake time order. */
2429:                	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
9D02079C  8F828094   LW V0, -32620(GP)
9D0207A0  8FC30018   LW V1, 24(S8)
9D0207A4  AC430004   SW V1, 4(V0)
2430:                
2431:                	if( xTimeToWake < xTickCount )
9D0207A8  8F82809C   LW V0, -32612(GP)
9D0207AC  8FC30018   LW V1, 24(S8)
9D0207B0  0062102B   SLTU V0, V1, V0
9D0207B4  1040000A   BEQ V0, ZERO, 0x9D0207E0
9D0207B8  00000000   NOP
2432:                	{
2433:                		/* Wake time has overflowed.  Place this item in the overflow list. */
2434:                		vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
9D0207BC  8F8381E4   LW V1, -32284(GP)
9D0207C0  8F828094   LW V0, -32620(GP)
9D0207C4  24420004   ADDIU V0, V0, 4
9D0207C8  00602021   ADDU A0, V1, ZERO
9D0207CC  00402821   ADDU A1, V0, ZERO
9D0207D0  0F40D0F6   JAL vListInsert
9D0207D4  00000000   NOP
9D0207D8  0B408206   J 0x9D020818
9D0207DC  00000000   NOP
2435:                	}
2436:                	else
2437:                	{
2438:                		/* The wake time has not overflowed, so we can use the current block list. */
2439:                		vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
9D0207E0  8F8381E0   LW V1, -32288(GP)
9D0207E4  8F828094   LW V0, -32620(GP)
9D0207E8  24420004   ADDIU V0, V0, 4
9D0207EC  00602021   ADDU A0, V1, ZERO
9D0207F0  00402821   ADDU A1, V0, ZERO
9D0207F4  0F40D0F6   JAL vListInsert
9D0207F8  00000000   NOP
2440:                
2441:                		/* If the task entering the blocked state was placed at the head of the
2442:                		list of blocked tasks then xNextTaskUnblockTime needs to be updated
2443:                		too. */
2444:                		if( xTimeToWake < xNextTaskUnblockTime )
9D0207FC  8F82800C   LW V0, -32756(GP)
9D020800  8FC30018   LW V1, 24(S8)
9D020804  0062102B   SLTU V0, V1, V0
9D020808  10400003   BEQ V0, ZERO, 0x9D020818
9D02080C  00000000   NOP
2445:                		{
2446:                			xNextTaskUnblockTime = xTimeToWake;
9D020810  8FC20018   LW V0, 24(S8)
9D020814  AF82800C   SW V0, -32756(GP)
2447:                		}
2448:                	}
2449:                }
9D020818  03C0E821   ADDU SP, S8, ZERO
9D02081C  8FBF0014   LW RA, 20(SP)
9D020820  8FBE0010   LW S8, 16(SP)
9D020824  27BD0018   ADDIU SP, SP, 24
9D020828  03E00008   JR RA
9D02082C  00000000   NOP
2450:                /*-----------------------------------------------------------*/
2451:                
2452:                static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer )
2453:                {
9D020830  27BDFFE0   ADDIU SP, SP, -32
9D020834  AFBF001C   SW RA, 28(SP)
9D020838  AFBE0018   SW S8, 24(SP)
9D02083C  03A0F021   ADDU S8, SP, ZERO
9D020840  00801021   ADDU V0, A0, ZERO
9D020844  AFC50024   SW A1, 36(S8)
9D020848  A7C20020   SH V0, 32(S8)
2454:                tskTCB *pxNewTCB;
2455:                
2456:                	/* Allocate space for the TCB.  Where the memory comes from depends on
2457:                	the implementation of the port malloc function. */
2458:                	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
9D02084C  24040044   ADDIU A0, ZERO, 68
9D020850  0F40D1D2   JAL pvPortMalloc
9D020854  00000000   NOP
9D020858  AFC20010   SW V0, 16(S8)
2459:                
2460:                	if( pxNewTCB != NULL )
9D02085C  8FC20010   LW V0, 16(S8)
9D020860  10400021   BEQ V0, ZERO, 0x9D0208E8
9D020864  00000000   NOP
2461:                	{
2462:                		/* Allocate space for the stack used by the task being created.
2463:                		The base of the stack memory stored in the TCB so the task can
2464:                		be deleted later if required. */
2465:                		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t ) usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
9D020868  8FC20024   LW V0, 36(S8)
9D02086C  14400008   BNE V0, ZERO, 0x9D020890
9D020870  00000000   NOP
9D020874  97C20020   LHU V0, 32(S8)
9D020878  00021080   SLL V0, V0, 2
9D02087C  00402021   ADDU A0, V0, ZERO
9D020880  0F40D1D2   JAL pvPortMalloc
9D020884  00000000   NOP
9D020888  0B408225   J 0x9D020894
9D02088C  00000000   NOP
9D020890  8FC20024   LW V0, 36(S8)
9D020894  8FC30010   LW V1, 16(S8)
9D020898  AC620030   SW V0, 48(V1)
2466:                
2467:                		if( pxNewTCB->pxStack == NULL )
9D02089C  8FC20010   LW V0, 16(S8)
9D0208A0  8C420030   LW V0, 48(V0)
9D0208A4  14400007   BNE V0, ZERO, 0x9D0208C4
9D0208A8  00000000   NOP
2468:                		{
2469:                			/* Could not allocate the stack.  Delete the allocated TCB. */
2470:                			vPortFree( pxNewTCB );
9D0208AC  8FC40010   LW A0, 16(S8)
9D0208B0  0F40D20E   JAL vPortFree
9D0208B4  00000000   NOP
2471:                			pxNewTCB = NULL;
9D0208B8  AFC00010   SW ZERO, 16(S8)
9D0208BC  0B40823A   J 0x9D0208E8
9D0208C0  00000000   NOP
2472:                		}
2473:                		else
2474:                		{
2475:                			/* Just to help debugging. */
2476:                			( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTACK_TYPE ) );
9D0208C4  8FC20010   LW V0, 16(S8)
9D0208C8  8C430030   LW V1, 48(V0)
9D0208CC  97C20020   LHU V0, 32(S8)
9D0208D0  00021080   SLL V0, V0, 2
9D0208D4  00602021   ADDU A0, V1, ZERO
9D0208D8  240500A5   ADDIU A1, ZERO, 165
9D0208DC  00403021   ADDU A2, V0, ZERO
9D0208E0  0F40D5EC   JAL 0x9D0357B0
9D0208E4  00000000   NOP
2477:                		}
2478:                	}
2479:                
2480:                	return pxNewTCB;
9D0208E8  8FC20010   LW V0, 16(S8)
2481:                }
9D0208EC  03C0E821   ADDU SP, S8, ZERO
9D0208F0  8FBF001C   LW RA, 28(SP)
9D0208F4  8FBE0018   LW S8, 24(SP)
9D0208F8  27BD0020   ADDIU SP, SP, 32
9D0208FC  03E00008   JR RA
9D020900  00000000   NOP
2482:                /*-----------------------------------------------------------*/
2483:                
2484:                #if ( configUSE_TRACE_FACILITY == 1 )
2485:                
2486:                	static unsigned portBASE_TYPE prvListTaskWithinSingleList( xTaskStatusType *pxTaskStatusArray, xList *pxList, eTaskState eState )
2487:                	{
2488:                	volatile tskTCB *pxNextTCB, *pxFirstTCB;
2489:                	unsigned portBASE_TYPE uxTask = 0;
2490:                
2491:                		if( listCURRENT_LIST_LENGTH( pxList ) > ( unsigned portBASE_TYPE ) 0 )
2492:                		{
2493:                			listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
2494:                
2495:                			/* Populate an xTaskStatusType structure within the
2496:                			pxTaskStatusArray array for each task that is referenced from
2497:                			pxList.  See the definition of xTaskStatusType in task.h for the
2498:                			meaning of each xTaskStatusType structure member. */
2499:                			do
2500:                			{
2501:                				listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
2502:                
2503:                				pxTaskStatusArray[ uxTask ].xHandle = ( xTaskHandle ) pxNextTCB;
2504:                				pxTaskStatusArray[ uxTask ].pcTaskName = ( const signed char * ) &( pxNextTCB->pcTaskName [ 0 ] );
2505:                				pxTaskStatusArray[ uxTask ].xTaskNumber = pxNextTCB->uxTCBNumber;
2506:                				pxTaskStatusArray[ uxTask ].eCurrentState = eState;
2507:                				pxTaskStatusArray[ uxTask ].uxCurrentPriority = pxNextTCB->uxPriority;
2508:                
2509:                				#if ( configUSE_MUTEXES == 1 )
2510:                				{
2511:                					pxTaskStatusArray[ uxTask ].uxBasePriority = pxNextTCB->uxBasePriority;
2512:                				}
2513:                				#else
2514:                				{
2515:                					pxTaskStatusArray[ uxTask ].uxBasePriority = 0;
2516:                				}
2517:                				#endif
2518:                
2519:                				#if ( configGENERATE_RUN_TIME_STATS == 1 )
2520:                				{
2521:                					pxTaskStatusArray[ uxTask ].ulRunTimeCounter = pxNextTCB->ulRunTimeCounter;
2522:                				}
2523:                				#else
2524:                				{
2525:                					pxTaskStatusArray[ uxTask ].ulRunTimeCounter = 0;
2526:                				}
2527:                				#endif
2528:                
2529:                				#if ( portSTACK_GROWTH > 0 )
2530:                				{
2531:                					ppxTaskStatusArray[ uxTask ].usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( unsigned char * ) pxNextTCB->pxEndOfStack );
2532:                				}
2533:                				#else
2534:                				{
2535:                					pxTaskStatusArray[ uxTask ].usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( unsigned char * ) pxNextTCB->pxStack );
2536:                				}
2537:                				#endif
2538:                
2539:                				uxTask++;
2540:                
2541:                			} while( pxNextTCB != pxFirstTCB );
2542:                		}
2543:                
2544:                		return uxTask;
2545:                	}
2546:                
2547:                #endif /* configUSE_TRACE_FACILITY */
2548:                /*-----------------------------------------------------------*/
2549:                
2550:                #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
2551:                
2552:                	static unsigned short prvTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
2553:                	{
9D020904  27BDFFF0   ADDIU SP, SP, -16
9D020908  AFBE000C   SW S8, 12(SP)
9D02090C  03A0F021   ADDU S8, SP, ZERO
9D020910  AFC40010   SW A0, 16(S8)
2554:                	unsigned short usCount = 0U;
9D020914  A7C00000   SH ZERO, 0(S8)
2555:                
2556:                		while( *pucStackByte == tskSTACK_FILL_BYTE )
9D020918  0B40824E   J 0x9D020938
9D02091C  00000000   NOP
9D020938  8FC20010   LW V0, 16(S8)
9D02093C  90430000   LBU V1, 0(V0)
9D020940  240200A5   ADDIU V0, ZERO, 165
9D020944  1062FFF6   BEQ V1, V0, 0x9D020920
9D020948  00000000   NOP
2557:                		{
2558:                			pucStackByte -= portSTACK_GROWTH;
9D020920  8FC20010   LW V0, 16(S8)
9D020924  24420001   ADDIU V0, V0, 1
9D020928  AFC20010   SW V0, 16(S8)
2559:                			usCount++;
9D02092C  97C20000   LHU V0, 0(S8)
9D020930  24420001   ADDIU V0, V0, 1
9D020934  A7C20000   SH V0, 0(S8)
2560:                		}
2561:                
2562:                		usCount /= sizeof( portSTACK_TYPE );
9D02094C  97C20000   LHU V0, 0(S8)
9D020950  00021082   SRL V0, V0, 2
9D020954  A7C20000   SH V0, 0(S8)
2563:                
2564:                		return usCount;
9D020958  97C20000   LHU V0, 0(S8)
2565:                	}
9D02095C  03C0E821   ADDU SP, S8, ZERO
9D020960  8FBE000C   LW S8, 12(SP)
9D020964  27BD0010   ADDIU SP, SP, 16
9D020968  03E00008   JR RA
9D02096C  00000000   NOP
2566:                
2567:                #endif /* ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) ) */
2568:                /*-----------------------------------------------------------*/
2569:                
2570:                #if ( INCLUDE_uxTaskGetStackHighWaterMark == 1 )
2571:                
2572:                	unsigned portBASE_TYPE uxTaskGetStackHighWaterMark( xTaskHandle xTask )
2573:                	{
9D020970  27BDFFD8   ADDIU SP, SP, -40
9D020974  AFBF0024   SW RA, 36(SP)
9D020978  AFBE0020   SW S8, 32(SP)
9D02097C  03A0F021   ADDU S8, SP, ZERO
9D020980  AFC40028   SW A0, 40(S8)
2574:                	tskTCB *pxTCB;
2575:                	unsigned char *pcEndOfStack;
2576:                	unsigned portBASE_TYPE uxReturn;
2577:                
2578:                		pxTCB = prvGetTCBFromHandle( xTask );
9D020984  8FC20028   LW V0, 40(S8)
9D020988  14400004   BNE V0, ZERO, 0x9D02099C
9D02098C  00000000   NOP
9D020990  8F828094   LW V0, -32620(GP)
9D020994  0B408268   J 0x9D0209A0
9D020998  00000000   NOP
9D02099C  8FC20028   LW V0, 40(S8)
9D0209A0  AFC20010   SW V0, 16(S8)
2579:                
2580:                		#if portSTACK_GROWTH < 0
2581:                		{
2582:                			pcEndOfStack = ( unsigned char * ) pxTCB->pxStack;
9D0209A4  8FC20010   LW V0, 16(S8)
9D0209A8  8C420030   LW V0, 48(V0)
9D0209AC  AFC20014   SW V0, 20(S8)
2583:                		}
2584:                		#else
2585:                		{
2586:                			pcEndOfStack = ( unsigned char * ) pxTCB->pxEndOfStack;
2587:                		}
2588:                		#endif
2589:                
2590:                		uxReturn = ( unsigned portBASE_TYPE ) prvTaskCheckFreeStackSpace( pcEndOfStack );
9D0209B0  8FC40014   LW A0, 20(S8)
9D0209B4  0F408241   JAL prvTaskCheckFreeStackSpace
9D0209B8  00000000   NOP
9D0209BC  AFC20018   SW V0, 24(S8)
2591:                
2592:                		return uxReturn;
9D0209C0  8FC20018   LW V0, 24(S8)
2593:                	}
9D0209C4  03C0E821   ADDU SP, S8, ZERO
9D0209C8  8FBF0024   LW RA, 36(SP)
9D0209CC  8FBE0020   LW S8, 32(SP)
9D0209D0  27BD0028   ADDIU SP, SP, 40
9D0209D4  03E00008   JR RA
9D0209D8  00000000   NOP
2594:                
2595:                #endif /* INCLUDE_uxTaskGetStackHighWaterMark */
2596:                /*-----------------------------------------------------------*/
2597:                
2598:                #if ( INCLUDE_vTaskDelete == 1 )
2599:                
2600:                	static void prvDeleteTCB( tskTCB *pxTCB )
2601:                	{
2602:                		/* This call is required specifically for the TriCore port.  It must be
2603:                		above the vPortFree() calls.  The call is also used by ports/demos that
2604:                		want to allocate and clean RAM statically. */
2605:                		portCLEAN_UP_TCB( pxTCB );
2606:                
2607:                		/* Free up the memory allocated by the scheduler for the task.  It is up to
2608:                		the task to free any memory allocated at the application level. */
2609:                		vPortFreeAligned( pxTCB->pxStack );
2610:                		vPortFree( pxTCB );
2611:                	}
2612:                
2613:                #endif /* INCLUDE_vTaskDelete */
2614:                /*-----------------------------------------------------------*/
2615:                
2616:                #if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )
2617:                
2618:                	xTaskHandle xTaskGetCurrentTaskHandle( void )
2619:                	{
9D0209DC  27BDFFF0   ADDIU SP, SP, -16
9D0209E0  AFBE000C   SW S8, 12(SP)
9D0209E4  03A0F021   ADDU S8, SP, ZERO
2620:                	xTaskHandle xReturn;
2621:                
2622:                		/* A critical section is not required as this is not called from
2623:                		an interrupt and the current TCB will always be the same for any
2624:                		individual execution thread. */
2625:                		xReturn = pxCurrentTCB;
9D0209E8  8F828094   LW V0, -32620(GP)
9D0209EC  AFC20000   SW V0, 0(S8)
2626:                
2627:                		return xReturn;
9D0209F0  8FC20000   LW V0, 0(S8)
2628:                	}
9D0209F4  03C0E821   ADDU SP, S8, ZERO
9D0209F8  8FBE000C   LW S8, 12(SP)
9D0209FC  27BD0010   ADDIU SP, SP, 16
9D020A00  03E00008   JR RA
9D020A04  00000000   NOP
2629:                
2630:                #endif /* ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) ) */
2631:                /*-----------------------------------------------------------*/
2632:                
2633:                #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
2634:                
2635:                	portBASE_TYPE xTaskGetSchedulerState( void )
2636:                	{
9D020A08  27BDFFF0   ADDIU SP, SP, -16
9D020A0C  AFBE000C   SW S8, 12(SP)
9D020A10  03A0F021   ADDU S8, SP, ZERO
2637:                	portBASE_TYPE xReturn;
2638:                
2639:                		if( xSchedulerRunning == pdFALSE )
9D020A14  8F8280A4   LW V0, -32604(GP)
9D020A18  14400004   BNE V0, ZERO, 0x9D020A2C
9D020A1C  00000000   NOP
2640:                		{
2641:                			xReturn = taskSCHEDULER_NOT_STARTED;
9D020A20  AFC00000   SW ZERO, 0(S8)
9D020A24  0B408294   J 0x9D020A50
9D020A28  00000000   NOP
2642:                		}
2643:                		else
2644:                		{
2645:                			if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
9D020A2C  8F8280A8   LW V0, -32600(GP)
9D020A30  14400005   BNE V0, ZERO, 0x9D020A48
9D020A34  00000000   NOP
2646:                			{
2647:                				xReturn = taskSCHEDULER_RUNNING;
9D020A38  24020001   ADDIU V0, ZERO, 1
9D020A3C  AFC20000   SW V0, 0(S8)
9D020A40  0B408294   J 0x9D020A50
9D020A44  00000000   NOP
2648:                			}
2649:                			else
2650:                			{
2651:                				xReturn = taskSCHEDULER_SUSPENDED;
9D020A48  24020002   ADDIU V0, ZERO, 2
9D020A4C  AFC20000   SW V0, 0(S8)
2652:                			}
2653:                		}
2654:                
2655:                		return xReturn;
9D020A50  8FC20000   LW V0, 0(S8)
2656:                	}
9D020A54  03C0E821   ADDU SP, S8, ZERO
9D020A58  8FBE000C   LW S8, 12(SP)
9D020A5C  27BD0010   ADDIU SP, SP, 16
9D020A60  03E00008   JR RA
9D020A64  00000000   NOP
2657:                
2658:                #endif /* ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) ) */
2659:                /*-----------------------------------------------------------*/
2660:                
2661:                #if ( configUSE_MUTEXES == 1 )
2662:                
2663:                	void vTaskPriorityInherit( xTaskHandle const pxMutexHolder )
2664:                	{
9D020A68  27BDFFE0   ADDIU SP, SP, -32
9D020A6C  AFBF001C   SW RA, 28(SP)
9D020A70  AFBE0018   SW S8, 24(SP)
9D020A74  03A0F021   ADDU S8, SP, ZERO
9D020A78  AFC40020   SW A0, 32(S8)
2665:                	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
9D020A7C  8FC20020   LW V0, 32(S8)
9D020A80  AFC20010   SW V0, 16(S8)
2666:                
2667:                		/* If the mutex was given back by an interrupt while the queue was
2668:                		locked then the mutex holder might now be NULL. */
2669:                		if( pxMutexHolder != NULL )
9D020A84  8FC20020   LW V0, 32(S8)
9D020A88  10400056   BEQ V0, ZERO, 0x9D020BE4
9D020A8C  00000000   NOP
2670:                		{
2671:                			if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
9D020A90  8FC20010   LW V0, 16(S8)
9D020A94  8C43002C   LW V1, 44(V0)
9D020A98  8F828094   LW V0, -32620(GP)
9D020A9C  8C42002C   LW V0, 44(V0)
9D020AA0  0062102B   SLTU V0, V1, V0
9D020AA4  1040004F   BEQ V0, ZERO, 0x9D020BE4
9D020AA8  00000000   NOP
2672:                			{
2673:                				/* Adjust the mutex holder state to account for its new priority. */
2674:                				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( portTickType ) configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
9D020AAC  8F828094   LW V0, -32620(GP)
9D020AB0  8C42002C   LW V0, 44(V0)
9D020AB4  24030005   ADDIU V1, ZERO, 5
9D020AB8  00621823   SUBU V1, V1, V0
9D020ABC  8FC20010   LW V0, 16(S8)
9D020AC0  AC430018   SW V1, 24(V0)
2675:                
2676:                				/* If the task being modified is in the ready state it will need to
2677:                				be moved into a new list. */
2678:                				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
9D020AC4  8FC20010   LW V0, 16(S8)
9D020AC8  8C430014   LW V1, 20(V0)
9D020ACC  8FC20010   LW V0, 16(S8)
9D020AD0  8C44002C   LW A0, 44(V0)
9D020AD4  24020014   ADDIU V0, ZERO, 20
9D020AD8  70822002   MUL A0, A0, V0
9D020ADC  3C02A000   LUI V0, -24576
9D020AE0  24420480   ADDIU V0, V0, 1152
9D020AE4  00821021   ADDU V0, A0, V0
9D020AE8  14620004   BNE V1, V0, 0x9D020AFC
9D020AEC  00000000   NOP
9D020AF0  24020001   ADDIU V0, ZERO, 1
9D020AF4  0B4082C0   J 0x9D020B00
9D020AF8  00000000   NOP
9D020AFC  00001021   ADDU V0, ZERO, ZERO
9D020B00  10400034   BEQ V0, ZERO, 0x9D020BD4
9D020B04  00000000   NOP
2679:                				{
2680:                					if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( unsigned portBASE_TYPE ) 0 )
9D020B08  8FC20010   LW V0, 16(S8)
9D020B0C  24420004   ADDIU V0, V0, 4
9D020B10  00402021   ADDU A0, V0, ZERO
9D020B14  0F40D131   JAL uxListRemove
9D020B18  00000000   NOP
9D020B1C  14400013   BNE V0, ZERO, 0x9D020B6C
9D020B20  00000000   NOP
2681:                					{
2682:                						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
9D020B24  8FC20010   LW V0, 16(S8)
9D020B28  8C43002C   LW V1, 44(V0)
9D020B2C  24020014   ADDIU V0, ZERO, 20
9D020B30  70621802   MUL V1, V1, V0
9D020B34  3C02A000   LUI V0, -24576
9D020B38  24420480   ADDIU V0, V0, 1152
9D020B3C  00621021   ADDU V0, V1, V0
9D020B40  8C420000   LW V0, 0(V0)
9D020B44  14400009   BNE V0, ZERO, 0x9D020B6C
9D020B48  00000000   NOP
9D020B4C  8FC20010   LW V0, 16(S8)
9D020B50  8C42002C   LW V0, 44(V0)
9D020B54  24030001   ADDIU V1, ZERO, 1
9D020B58  00431004   SLLV V0, V1, V0
9D020B5C  00021827   NOR V1, ZERO, V0
9D020B60  8F8280A0   LW V0, -32608(GP)
9D020B64  00621024   AND V0, V1, V0
9D020B68  AF8280A0   SW V0, -32608(GP)
2683:                					}
2684:                
2685:                					/* Inherit the priority before being moved into the new list. */
2686:                					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
9D020B6C  8F828094   LW V0, -32620(GP)
9D020B70  8C43002C   LW V1, 44(V0)
9D020B74  8FC20010   LW V0, 16(S8)
9D020B78  AC43002C   SW V1, 44(V0)
2687:                					prvAddTaskToReadyList( pxTCB );
9D020B7C  8FC20010   LW V0, 16(S8)
9D020B80  8C42002C   LW V0, 44(V0)
9D020B84  24030001   ADDIU V1, ZERO, 1
9D020B88  00431804   SLLV V1, V1, V0
9D020B8C  8F8280A0   LW V0, -32608(GP)
9D020B90  00621025   OR V0, V1, V0
9D020B94  AF8280A0   SW V0, -32608(GP)
9D020B98  8FC20010   LW V0, 16(S8)
9D020B9C  8C43002C   LW V1, 44(V0)
9D020BA0  24020014   ADDIU V0, ZERO, 20
9D020BA4  70621802   MUL V1, V1, V0
9D020BA8  3C02A000   LUI V0, -24576
9D020BAC  24420480   ADDIU V0, V0, 1152
9D020BB0  00621821   ADDU V1, V1, V0
9D020BB4  8FC20010   LW V0, 16(S8)
9D020BB8  24420004   ADDIU V0, V0, 4
9D020BBC  00602021   ADDU A0, V1, ZERO
9D020BC0  00402821   ADDU A1, V0, ZERO
9D020BC4  0F40D0D3   JAL vListInsertEnd
9D020BC8  00000000   NOP
9D020BCC  0B4082F9   J 0x9D020BE4
9D020BD0  00000000   NOP
2688:                				}
2689:                				else
2690:                				{
2691:                					/* Just inherit the priority. */
2692:                					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
9D020BD4  8F828094   LW V0, -32620(GP)
9D020BD8  8C43002C   LW V1, 44(V0)
9D020BDC  8FC20010   LW V0, 16(S8)
9D020BE0  AC43002C   SW V1, 44(V0)
2693:                				}
2694:                
2695:                				traceTASK_PRIORITY_INHERIT( pxTCB, pxCurrentTCB->uxPriority );
2696:                			}
2697:                		}
2698:                	}
9D020BE4  03C0E821   ADDU SP, S8, ZERO
9D020BE8  8FBF001C   LW RA, 28(SP)
9D020BEC  8FBE0018   LW S8, 24(SP)
9D020BF0  27BD0020   ADDIU SP, SP, 32
9D020BF4  03E00008   JR RA
9D020BF8  00000000   NOP
2699:                
2700:                #endif /* configUSE_MUTEXES */
2701:                /*-----------------------------------------------------------*/
2702:                
2703:                #if ( configUSE_MUTEXES == 1 )
2704:                
2705:                	void vTaskPriorityDisinherit( xTaskHandle const pxMutexHolder )
2706:                	{
9D020BFC  27BDFFE0   ADDIU SP, SP, -32
9D020C00  AFBF001C   SW RA, 28(SP)
9D020C04  AFBE0018   SW S8, 24(SP)
9D020C08  03A0F021   ADDU S8, SP, ZERO
9D020C0C  AFC40020   SW A0, 32(S8)
2707:                	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
9D020C10  8FC20020   LW V0, 32(S8)
9D020C14  AFC20010   SW V0, 16(S8)
2708:                
2709:                		if( pxMutexHolder != NULL )
9D020C18  8FC20020   LW V0, 32(S8)
9D020C1C  1040003E   BEQ V0, ZERO, 0x9D020D18
9D020C20  00000000   NOP
2710:                		{
2711:                			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
9D020C24  8FC20010   LW V0, 16(S8)
9D020C28  8C43002C   LW V1, 44(V0)
9D020C2C  8FC20010   LW V0, 16(S8)
9D020C30  8C420040   LW V0, 64(V0)
9D020C34  10620038   BEQ V1, V0, 0x9D020D18
9D020C38  00000000   NOP
2712:                			{
2713:                				/* We must be the running task to be able to give the mutex back.
2714:                				Remove ourselves from the ready list we currently appear in. */
2715:                				if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( unsigned portBASE_TYPE ) 0 )
9D020C3C  8FC20010   LW V0, 16(S8)
9D020C40  24420004   ADDIU V0, V0, 4
9D020C44  00402021   ADDU A0, V0, ZERO
9D020C48  0F40D131   JAL uxListRemove
9D020C4C  00000000   NOP
9D020C50  14400013   BNE V0, ZERO, 0x9D020CA0
9D020C54  00000000   NOP
2716:                				{
2717:                					taskRESET_READY_PRIORITY( pxTCB->uxPriority );
9D020C58  8FC20010   LW V0, 16(S8)
9D020C5C  8C43002C   LW V1, 44(V0)
9D020C60  24020014   ADDIU V0, ZERO, 20
9D020C64  70621802   MUL V1, V1, V0
9D020C68  3C02A000   LUI V0, -24576
9D020C6C  24420480   ADDIU V0, V0, 1152
9D020C70  00621021   ADDU V0, V1, V0
9D020C74  8C420000   LW V0, 0(V0)
9D020C78  14400009   BNE V0, ZERO, 0x9D020CA0
9D020C7C  00000000   NOP
9D020C80  8FC20010   LW V0, 16(S8)
9D020C84  8C42002C   LW V0, 44(V0)
9D020C88  24030001   ADDIU V1, ZERO, 1
9D020C8C  00431004   SLLV V0, V1, V0
9D020C90  00021827   NOR V1, ZERO, V0
9D020C94  8F8280A0   LW V0, -32608(GP)
9D020C98  00621024   AND V0, V1, V0
9D020C9C  AF8280A0   SW V0, -32608(GP)
2718:                				}
2719:                
2720:                				/* Disinherit the priority before adding the task into the new
2721:                				ready list. */
2722:                				traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
2723:                				pxTCB->uxPriority = pxTCB->uxBasePriority;
9D020CA0  8FC20010   LW V0, 16(S8)
9D020CA4  8C430040   LW V1, 64(V0)
9D020CA8  8FC20010   LW V0, 16(S8)
9D020CAC  AC43002C   SW V1, 44(V0)
2724:                				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( portTickType ) configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
9D020CB0  8FC20010   LW V0, 16(S8)
9D020CB4  8C42002C   LW V0, 44(V0)
9D020CB8  24030005   ADDIU V1, ZERO, 5
9D020CBC  00621823   SUBU V1, V1, V0
9D020CC0  8FC20010   LW V0, 16(S8)
9D020CC4  AC430018   SW V1, 24(V0)
2725:                				prvAddTaskToReadyList( pxTCB );
9D020CC8  8FC20010   LW V0, 16(S8)
9D020CCC  8C42002C   LW V0, 44(V0)
9D020CD0  24030001   ADDIU V1, ZERO, 1
9D020CD4  00431804   SLLV V1, V1, V0
9D020CD8  8F8280A0   LW V0, -32608(GP)
9D020CDC  00621025   OR V0, V1, V0
9D020CE0  AF8280A0   SW V0, -32608(GP)
9D020CE4  8FC20010   LW V0, 16(S8)
9D020CE8  8C43002C   LW V1, 44(V0)
9D020CEC  24020014   ADDIU V0, ZERO, 20
9D020CF0  70621802   MUL V1, V1, V0
9D020CF4  3C02A000   LUI V0, -24576
9D020CF8  24420480   ADDIU V0, V0, 1152
9D020CFC  00621821   ADDU V1, V1, V0
9D020D00  8FC20010   LW V0, 16(S8)
9D020D04  24420004   ADDIU V0, V0, 4
9D020D08  00602021   ADDU A0, V1, ZERO
9D020D0C  00402821   ADDU A1, V0, ZERO
9D020D10  0F40D0D3   JAL vListInsertEnd
9D020D14  00000000   NOP
2726:                			}
2727:                		}
2728:                	}
9D020D18  03C0E821   ADDU SP, S8, ZERO
9D020D1C  8FBF001C   LW RA, 28(SP)
9D020D20  8FBE0018   LW S8, 24(SP)
9D020D24  27BD0020   ADDIU SP, SP, 32
9D020D28  03E00008   JR RA
9D020D2C  00000000   NOP
2729:                
2730:                #endif /* configUSE_MUTEXES */
2731:                /*-----------------------------------------------------------*/
2732:                
2733:                #if ( portCRITICAL_NESTING_IN_TCB == 1 )
2734:                
2735:                	void vTaskEnterCritical( void )
2736:                	{
9D020D30  27BDFFF0   ADDIU SP, SP, -16
9D020D34  AFBE000C   SW S8, 12(SP)
9D020D38  03A0F021   ADDU S8, SP, ZERO
2737:                		portDISABLE_INTERRUPTS();
9D020D3C  40026000   MFC0 V0, Status
9D020D40  AFC20000   SW V0, 0(S8)
9D020D44  8FC20000   LW V0, 0(S8)
9D020D48  3042FC00   ANDI V0, V0, -1024
9D020D4C  00021282   SRL V0, V0, 10
9D020D50  2C420003   SLTIU V0, V0, 3
9D020D54  1040000A   BEQ V0, ZERO, 0x9D020D80
9D020D58  00000000   NOP
9D020D5C  8FC30000   LW V1, 0(S8)
9D020D60  3C02FFFF   LUI V0, -1
9D020D64  344203FF   ORI V0, V0, 1023
9D020D68  00621024   AND V0, V1, V0
9D020D6C  AFC20000   SW V0, 0(S8)
9D020D70  8FC20000   LW V0, 0(S8)
9D020D74  34420C00   ORI V0, V0, 3072
9D020D78  40826000   MTC0 V0, Status
9D020D7C  000000C0   EHB
2738:                
2739:                		if( xSchedulerRunning != pdFALSE )
9D020D80  8F8280A4   LW V0, -32604(GP)
9D020D84  10400005   BEQ V0, ZERO, 0x9D020D9C
9D020D88  00000000   NOP
2740:                		{
2741:                			( pxCurrentTCB->uxCriticalNesting )++;
9D020D8C  8F828094   LW V0, -32620(GP)
9D020D90  8C43003C   LW V1, 60(V0)
9D020D94  24630001   ADDIU V1, V1, 1
9D020D98  AC43003C   SW V1, 60(V0)
2742:                		}
2743:                	}
9D020D9C  03C0E821   ADDU SP, S8, ZERO
9D020DA0  8FBE000C   LW S8, 12(SP)
9D020DA4  27BD0010   ADDIU SP, SP, 16
9D020DA8  03E00008   JR RA
9D020DAC  00000000   NOP
2744:                
2745:                #endif /* portCRITICAL_NESTING_IN_TCB */
2746:                /*-----------------------------------------------------------*/
2747:                
2748:                #if ( portCRITICAL_NESTING_IN_TCB == 1 )
2749:                
2750:                	void vTaskExitCritical( void )
2751:                	{
9D020DB0  27BDFFF0   ADDIU SP, SP, -16
9D020DB4  AFBE000C   SW S8, 12(SP)
9D020DB8  03A0F021   ADDU S8, SP, ZERO
2752:                		if( xSchedulerRunning != pdFALSE )
9D020DBC  8F8280A4   LW V0, -32604(GP)
9D020DC0  10400017   BEQ V0, ZERO, 0x9D020E20
9D020DC4  00000000   NOP
2753:                		{
2754:                			if( pxCurrentTCB->uxCriticalNesting > 0U )
9D020DC8  8F828094   LW V0, -32620(GP)
9D020DCC  8C42003C   LW V0, 60(V0)
9D020DD0  10400013   BEQ V0, ZERO, 0x9D020E20
9D020DD4  00000000   NOP
2755:                			{
2756:                				( pxCurrentTCB->uxCriticalNesting )--;
9D020DD8  8F828094   LW V0, -32620(GP)
9D020DDC  8C43003C   LW V1, 60(V0)
9D020DE0  2463FFFF   ADDIU V1, V1, -1
9D020DE4  AC43003C   SW V1, 60(V0)
2757:                
2758:                				if( pxCurrentTCB->uxCriticalNesting == 0U )
9D020DE8  8F828094   LW V0, -32620(GP)
9D020DEC  8C42003C   LW V0, 60(V0)
9D020DF0  1440000B   BNE V0, ZERO, 0x9D020E20
9D020DF4  00000000   NOP
2759:                				{
2760:                					portENABLE_INTERRUPTS();
9D020DF8  40026000   MFC0 V0, Status
9D020DFC  AFC20000   SW V0, 0(S8)
9D020E00  8FC30000   LW V1, 0(S8)
9D020E04  3C02FFFF   LUI V0, -1
9D020E08  344203FF   ORI V0, V0, 1023
9D020E0C  00621024   AND V0, V1, V0
9D020E10  AFC20000   SW V0, 0(S8)
9D020E14  8FC20000   LW V0, 0(S8)
9D020E18  40826000   MTC0 V0, Status
9D020E1C  000000C0   EHB
2761:                				}
2762:                			}
2763:                		}
2764:                	}
9D020E20  03C0E821   ADDU SP, S8, ZERO
9D020E24  8FBE000C   LW S8, 12(SP)
9D020E28  27BD0010   ADDIU SP, SP, 16
9D020E2C  03E00008   JR RA
9D020E30  00000000   NOP
2765:                
2766:                #endif /* portCRITICAL_NESTING_IN_TCB */
2767:                /*-----------------------------------------------------------*/
2768:                
2769:                #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS == 1 ) )
2770:                
2771:                	void vTaskList( signed char *pcWriteBuffer )
2772:                	{
2773:                	xTaskStatusType *pxTaskStatusArray;
2774:                	volatile unsigned portBASE_TYPE uxArraySize, x;
2775:                	char cStatus;
2776:                
2777:                		/*
2778:                		 * PLEASE NOTE:
2779:                		 *
2780:                		 * This function is provided for convenience only, and is used by many
2781:                		 * of the demo applications.  Do not consider it to be part of the
2782:                		 * scheduler.
2783:                		 *
2784:                		 * vTaskList() calls uxTaskGetSystemState(), then formats part of the
2785:                		 * uxTaskGetSystemState() output into a human readable table that
2786:                		 * displays task names, states and stack usage.
2787:                		 *
2788:                		 * vTaskList() has a dependency on the sprintf() C library function that
2789:                		 * might bloat the code size, use a lot of stack, and provide different
2790:                		 * results on different platforms.  An alternative, tiny, third party,
2791:                		 * and limited functionality implementation of sprintf() is provided in
2792:                		 * many of the FreeRTOS/Demo sub-directories in a file called
2793:                		 * printf-stdarg.c (note printf-stdarg.c does not provide a full
2794:                		 * snprintf() implementation!).
2795:                		 *
2796:                		 * It is recommended that production systems call uxTaskGetSystemState()
2797:                		 * directly to get access to raw stats data, rather than indirectly
2798:                		 * through a call to vTaskList().
2799:                		 */
2800:                
2801:                
2802:                		/* Make sure the write buffer does not contain a string. */
2803:                		*pcWriteBuffer = 0x00;
2804:                
2805:                		/* Take a snapshot of the number of tasks in case it changes while this
2806:                		function is executing. */
2807:                		uxArraySize = uxCurrentNumberOfTasks;
2808:                
2809:                		/* Allocate an array index for each task. */
2810:                		pxTaskStatusArray = pvPortMalloc( uxCurrentNumberOfTasks * sizeof( xTaskStatusType ) );
2811:                
2812:                		if( pxTaskStatusArray != NULL )
2813:                		{
2814:                			/* Generate the (binary) data. */
2815:                			uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, NULL );
2816:                
2817:                			/* Create a human readable table from the binary data. */
2818:                			for( x = 0; x < uxArraySize; x++ )
2819:                			{
2820:                				switch( pxTaskStatusArray[ x ].eCurrentState )
2821:                				{
2822:                				case eReady:		cStatus = tskREADY_CHAR;
2823:                									break;
2824:                
2825:                				case eBlocked:		cStatus = tskBLOCKED_CHAR;
2826:                									break;
2827:                
2828:                				case eSuspended:	cStatus = tskSUSPENDED_CHAR;
2829:                									break;
2830:                
2831:                				case eDeleted:		cStatus = tskDELETED_CHAR;
2832:                									break;
2833:                
2834:                				default:			/* Should not get here, but it is included
2835:                									to prevent static checking errors. */
2836:                									cStatus = 0x00;
2837:                									break;
2838:                				}
2839:                
2840:                				sprintf( ( char * ) pcWriteBuffer, ( char * ) "%s\t\t%c\t%u\t%u\t%u\r\n", pxTaskStatusArray[ x ].pcTaskName, cStatus, ( unsigned int ) pxTaskStatusArray[ x ].uxCurrentPriority, ( unsigned int ) pxTaskStatusArray[ x ].usStackHighWaterMark, ( unsigned int ) pxTaskStatusArray[ x ].xTaskNumber );
2841:                				pcWriteBuffer += strlen( ( char * ) pcWriteBuffer );
2842:                			}
2843:                
2844:                			/* Free the array again. */
2845:                			vPortFree( pxTaskStatusArray );
2846:                		}
2847:                	}
2848:                
2849:                #endif /* configUSE_TRACE_FACILITY */
2850:                /*----------------------------------------------------------*/
2851:                
2852:                #if ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS == 1 ) )
2853:                
2854:                	void vTaskGetRunTimeStats( signed char *pcWriteBuffer )
2855:                	{
2856:                	xTaskStatusType *pxTaskStatusArray;
2857:                	volatile unsigned portBASE_TYPE uxArraySize, x;
2858:                	unsigned long ulTotalTime, ulStatsAsPercentage;
2859:                
2860:                		/*
2861:                		 * PLEASE NOTE:
2862:                		 *
2863:                		 * This function is provided for convenience only, and is used by many
2864:                		 * of the demo applications.  Do not consider it to be part of the
2865:                		 * scheduler.
2866:                		 *
2867:                		 * vTaskGetRunTimeStats() calls uxTaskGetSystemState(), then formats part
2868:                		 * of the uxTaskGetSystemState() output into a human readable table that
2869:                		 * displays the amount of time each task has spent in the Running state
2870:                		 * in both absolute and percentage terms.
2871:                		 *
2872:                		 * vTaskGetRunTimeStats() has a dependency on the sprintf() C library
2873:                		 * function that might bloat the code size, use a lot of stack, and
2874:                		 * provide different results on different platforms.  An alternative,
2875:                		 * tiny, third party, and limited functionality implementation of
2876:                		 * sprintf() is provided in many of the FreeRTOS/Demo sub-directories in
2877:                		 * a file called printf-stdarg.c (note printf-stdarg.c does not provide
2878:                		 * a full snprintf() implementation!).
2879:                		 *
2880:                		 * It is recommended that production systems call uxTaskGetSystemState()
2881:                		 * directly to get access to raw stats data, rather than indirectly
2882:                		 * through a call to vTaskGetRunTimeStats().
2883:                		 */
2884:                
2885:                		/* Make sure the write buffer does not contain a string. */
2886:                		*pcWriteBuffer = 0x00;
2887:                
2888:                		/* Take a snapshot of the number of tasks in case it changes while this
2889:                		function is executing. */
2890:                		uxArraySize = uxCurrentNumberOfTasks;
2891:                
2892:                		/* Allocate an array index for each task. */
2893:                		pxTaskStatusArray = pvPortMalloc( uxCurrentNumberOfTasks * sizeof( xTaskStatusType ) );
2894:                
2895:                		if( pxTaskStatusArray != NULL )
2896:                		{
2897:                			/* Generate the (binary) data. */
2898:                			uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, &ulTotalTime );
2899:                
2900:                			/* For percentage calculations. */
2901:                			ulTotalTime /= 100UL;
2902:                
2903:                			/* Avoid divide by zero errors. */
2904:                			if( ulTotalTime > 0 )
2905:                			{
2906:                				/* Create a human readable table from the binary data. */
2907:                				for( x = 0; x < uxArraySize; x++ )
2908:                				{
2909:                					/* What percentage of the total run time has the task used?
2910:                					This will always be rounded down to the nearest integer.
2911:                					ulTotalRunTimeDiv100 has already been divided by 100. */
2912:                					ulStatsAsPercentage = pxTaskStatusArray[ x ].ulRunTimeCounter / ulTotalTime;
2913:                
2914:                					if( ulStatsAsPercentage > 0UL )
2915:                					{
2916:                						#ifdef portLU_PRINTF_SPECIFIER_REQUIRED
2917:                						{
2918:                							sprintf( ( char * ) pcWriteBuffer, ( char * ) "%s\t\t%lu\t\t%lu%%\r\n", pxTaskStatusArray[ x ].pcTaskName, pxTaskStatusArray[ x ].ulRunTimeCounter, ulStatsAsPercentage );
2919:                						}
2920:                						#else
2921:                						{
2922:                							/* sizeof( int ) == sizeof( long ) so a smaller
2923:                							printf() library can be used. */
2924:                							sprintf( ( char * ) pcWriteBuffer, ( char * ) "%s\t\t%u\t\t%u%%\r\n", pxTaskStatusArray[ x ].pcTaskName, ( unsigned int ) pxTaskStatusArray[ x ].ulRunTimeCounter, ( unsigned int ) ulStatsAsPercentage );
2925:                						}
2926:                						#endif
2927:                					}
2928:                					else
2929:                					{
2930:                						/* If the percentage is zero here then the task has
2931:                						consumed less than 1% of the total run time. */
2932:                						#ifdef portLU_PRINTF_SPECIFIER_REQUIRED
2933:                						{
2934:                							sprintf( ( char * ) pcWriteBuffer, ( char * ) "%s\t\t%lu\t\t<1%%\r\n", pxTaskStatusArray[ x ].pcTaskName, pxTaskStatusArray[ x ].ulRunTimeCounter );
2935:                						}
2936:                						#else
2937:                						{
2938:                							/* sizeof( int ) == sizeof( long ) so a smaller
2939:                							printf() library can be used. */
2940:                							sprintf( ( char * ) pcWriteBuffer, ( char * ) "%s\t\t%u\t\t<1%%\r\n", pxTaskStatusArray[ x ].pcTaskName, ( unsigned int ) pxTaskStatusArray[ x ].ulRunTimeCounter );
2941:                						}
2942:                						#endif
2943:                					}
2944:                
2945:                					pcWriteBuffer += strlen( ( char * ) pcWriteBuffer );
2946:                				}
2947:                			}
2948:                
2949:                			/* Free the array again. */
2950:                			vPortFree( pxTaskStatusArray );
2951:                		}
2952:                	}
2953:                
2954:                #endif /* configGENERATE_RUN_TIME_STATS */
2955:                
2956:                
2957:                
---  C:/Users/Diego/Documents/GitHub/pic32webFREERtos/Pic32Web.X/src/FreeRTOS/queue.c  ------------------
1:                   /*
2:                       FreeRTOS V7.5.3 - Copyright (C) 2013 Real Time Engineers Ltd. 
3:                       All rights reserved
4:                   
5:                       VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
6:                   
7:                       ***************************************************************************
8:                        *                                                                       *
9:                        *    FreeRTOS provides completely free yet professionally developed,    *
10:                       *    robust, strictly quality controlled, supported, and cross          *
11:                       *    platform software that has become a de facto standard.             *
12:                       *                                                                       *
13:                       *    Help yourself get started quickly and support the FreeRTOS         *
14:                       *    project by purchasing a FreeRTOS tutorial book, reference          *
15:                       *    manual, or both from: http://www.FreeRTOS.org/Documentation        *
16:                       *                                                                       *
17:                       *    Thank you!                                                         *
18:                       *                                                                       *
19:                      ***************************************************************************
20:                  
21:                      This file is part of the FreeRTOS distribution.
22:                  
23:                      FreeRTOS is free software; you can redistribute it and/or modify it under
24:                      the terms of the GNU General Public License (version 2) as published by the
25:                      Free Software Foundation >>!AND MODIFIED BY!<< the FreeRTOS exception.
26:                  
27:                      >>! NOTE: The modification to the GPL is included to allow you to distribute
28:                      >>! a combined work that includes FreeRTOS without being obliged to provide
29:                      >>! the source code for proprietary components outside of the FreeRTOS
30:                      >>! kernel.
31:                  
32:                      FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
33:                      WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
34:                      FOR A PARTICULAR PURPOSE.  Full license text is available from the following
35:                      link: http://www.freertos.org/a00114.html
36:                  
37:                      1 tab == 4 spaces!
38:                  
39:                      ***************************************************************************
40:                       *                                                                       *
41:                       *    Having a problem?  Start by reading the FAQ "My application does   *
42:                       *    not run, what could be wrong?"                                     *
43:                       *                                                                       *
44:                       *    http://www.FreeRTOS.org/FAQHelp.html                               *
45:                       *                                                                       *
46:                      ***************************************************************************
47:                  
48:                      http://www.FreeRTOS.org - Documentation, books, training, latest versions,
49:                      license and Real Time Engineers Ltd. contact details.
50:                  
51:                      http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
52:                      including FreeRTOS+Trace - an indispensable productivity tool, a DOS
53:                      compatible FAT file system, and our tiny thread aware UDP/IP stack.
54:                  
55:                      http://www.OpenRTOS.com - Real Time Engineers ltd license FreeRTOS to High
56:                      Integrity Systems to sell under the OpenRTOS brand.  Low cost OpenRTOS
57:                      licenses offer ticketed support, indemnification and middleware.
58:                  
59:                      http://www.SafeRTOS.com - High Integrity Systems also provide a safety
60:                      engineered and independently SIL3 certified version for use in safety and
61:                      mission critical applications that require provable dependability.
62:                  
63:                      1 tab == 4 spaces!
64:                  */
65:                  
66:                  #include <stdlib.h>
67:                  #include <string.h>
68:                  
69:                  /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
70:                  all the API functions to use the MPU wrappers.  That should only be done when
71:                  task.h is included from an application file. */
72:                  #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
73:                  
74:                  #include "FreeRTOS.h"
75:                  #include "task.h"
76:                  #include "queue.h"
77:                  
78:                  #if ( configUSE_CO_ROUTINES == 1 )
79:                  	#include "croutine.h"
80:                  #endif
81:                  
82:                  /* Lint e961 and e750 are suppressed as a MISRA exception justified because the
83:                  MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined for the
84:                  header files above, but not in this file, in order to generate the correct
85:                  privileged Vs unprivileged linkage and placement. */
86:                  #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE /*lint !e961 !e750. */
87:                  
88:                  
89:                  /* Constants used with the cRxLock and xTxLock structure members. */
90:                  #define queueUNLOCKED					( ( signed portBASE_TYPE ) -1 )
91:                  #define queueLOCKED_UNMODIFIED			( ( signed portBASE_TYPE ) 0 )
92:                  
93:                  /* When the xQUEUE structure is used to represent a base queue its pcHead and
94:                  pcTail members are used as pointers into the queue storage area.  When the
95:                  xQUEUE structure is used to represent a mutex pcHead and pcTail pointers are
96:                  not necessary, and the pcHead pointer is set to NULL to indicate that the
97:                  pcTail pointer actually points to the mutex holder (if any).  Map alternative
98:                  names to the pcHead and pcTail structure members to ensure the readability of
99:                  the code is maintained despite this dual use of two structure members.  An
100:                 alternative implementation would be to use a union, but use of a union is
101:                 against the coding standard (although an exception to the standard has been
102:                 permitted where the dual use also significantly changes the type of the
103:                 structure member). */
104:                 #define pxMutexHolder					pcTail
105:                 #define uxQueueType						pcHead
106:                 #define queueQUEUE_IS_MUTEX				NULL
107:                 
108:                 /* Semaphores do not actually store or copy data, so have an item size of
109:                 zero. */
110:                 #define queueSEMAPHORE_QUEUE_ITEM_LENGTH ( ( unsigned portBASE_TYPE ) 0 )
111:                 #define queueMUTEX_GIVE_BLOCK_TIME		 ( ( portTickType ) 0U )
112:                 
113:                 
114:                 /*
115:                  * Definition of the queue used by the scheduler.
116:                  * Items are queued by copy, not reference.
117:                  */
118:                 typedef struct QueueDefinition
119:                 {
120:                 	signed char *pcHead;					/*< Points to the beginning of the queue storage area. */
121:                 	signed char *pcTail;					/*< Points to the byte at the end of the queue storage area.  Once more byte is allocated than necessary to store the queue items, this is used as a marker. */
122:                 
123:                 	signed char *pcWriteTo;					/*< Points to the free next place in the storage area. */
124:                 
125:                 	union									/* Use of a union is an exception to the coding standard to ensure two mutually exclusive structure members don't appear simultaneously (wasting RAM). */
126:                 	{
127:                 		signed char *pcReadFrom;			/*< Points to the last place that a queued item was read from when the structure is used as a queue. */
128:                 		unsigned portBASE_TYPE uxRecursiveCallCount;/*< Maintains a count of the numebr of times a recursive mutex has been recursively 'taken' when the structure is used as a mutex. */
129:                 	} u;
130:                 
131:                 	xList xTasksWaitingToSend;				/*< List of tasks that are blocked waiting to post onto this queue.  Stored in priority order. */
132:                 	xList xTasksWaitingToReceive;			/*< List of tasks that are blocked waiting to read from this queue.  Stored in priority order. */
133:                 
134:                 	volatile unsigned portBASE_TYPE uxMessagesWaiting;/*< The number of items currently in the queue. */
135:                 	unsigned portBASE_TYPE uxLength;		/*< The length of the queue defined as the number of items it will hold, not the number of bytes. */
136:                 	unsigned portBASE_TYPE uxItemSize;		/*< The size of each items that the queue will hold. */
137:                 
138:                 	volatile signed portBASE_TYPE xRxLock;	/*< Stores the number of items received from the queue (removed from the queue) while the queue was locked.  Set to queueUNLOCKED when the queue is not locked. */
139:                 	volatile signed portBASE_TYPE xTxLock;	/*< Stores the number of items transmitted to the queue (added to the queue) while the queue was locked.  Set to queueUNLOCKED when the queue is not locked. */
140:                 
141:                 	#if ( configUSE_TRACE_FACILITY == 1 )
142:                 		unsigned char ucQueueNumber;
143:                 		unsigned char ucQueueType;
144:                 	#endif
145:                 
146:                 	#if ( configUSE_QUEUE_SETS == 1 )
147:                 		struct QueueDefinition *pxQueueSetContainer;
148:                 	#endif
149:                 
150:                 } xQUEUE;
151:                 /*-----------------------------------------------------------*/
152:                 
153:                 /*
154:                  * The queue registry is just a means for kernel aware debuggers to locate
155:                  * queue structures.  It has no other purpose so is an optional component.
156:                  */
157:                 #if ( configQUEUE_REGISTRY_SIZE > 0 )
158:                 
159:                 	/* The type stored within the queue registry array.  This allows a name
160:                 	to be assigned to each queue making kernel aware debugging a little
161:                 	more user friendly. */
162:                 	typedef struct QUEUE_REGISTRY_ITEM
163:                 	{
164:                 		signed char *pcQueueName;
165:                 		xQueueHandle xHandle;
166:                 	} xQueueRegistryItem;
167:                 
168:                 	/* The queue registry is simply an array of xQueueRegistryItem structures.
169:                 	The pcQueueName member of a structure being NULL is indicative of the
170:                 	array position being vacant. */
171:                 	xQueueRegistryItem xQueueRegistry[ configQUEUE_REGISTRY_SIZE ];
172:                 
173:                 #endif /* configQUEUE_REGISTRY_SIZE */
174:                 
175:                 /*
176:                  * Unlocks a queue locked by a call to prvLockQueue.  Locking a queue does not
177:                  * prevent an ISR from adding or removing items to the queue, but does prevent
178:                  * an ISR from removing tasks from the queue event lists.  If an ISR finds a
179:                  * queue is locked it will instead increment the appropriate queue lock count
180:                  * to indicate that a task may require unblocking.  When the queue in unlocked
181:                  * these lock counts are inspected, and the appropriate action taken.
182:                  */
183:                 static void prvUnlockQueue( xQUEUE *pxQueue ) PRIVILEGED_FUNCTION;
184:                 
185:                 /*
186:                  * Uses a critical section to determine if there is any data in a queue.
187:                  *
188:                  * @return pdTRUE if the queue contains no items, otherwise pdFALSE.
189:                  */
190:                 static signed portBASE_TYPE prvIsQueueEmpty( const xQUEUE *pxQueue ) PRIVILEGED_FUNCTION;
191:                 
192:                 /*
193:                  * Uses a critical section to determine if there is any space in a queue.
194:                  *
195:                  * @return pdTRUE if there is no space, otherwise pdFALSE;
196:                  */
197:                 static signed portBASE_TYPE prvIsQueueFull( const xQUEUE *pxQueue ) PRIVILEGED_FUNCTION;
198:                 
199:                 /*
200:                  * Copies an item into the queue, either at the front of the queue or the
201:                  * back of the queue.
202:                  */
203:                 static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition ) PRIVILEGED_FUNCTION;
204:                 
205:                 /*
206:                  * Copies an item out of a queue.
207:                  */
208:                 static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void * const pvBuffer ) PRIVILEGED_FUNCTION;
209:                 
210:                 #if ( configUSE_QUEUE_SETS == 1 )
211:                 	/*
212:                 	 * Checks to see if a queue is a member of a queue set, and if so, notifies
213:                 	 * the queue set that the queue contains data.
214:                 	 */
215:                 	static portBASE_TYPE prvNotifyQueueSetContainer( const xQUEUE * const pxQueue, portBASE_TYPE xCopyPosition ) PRIVILEGED_FUNCTION;
216:                 #endif
217:                 
218:                 /*-----------------------------------------------------------*/
219:                 
220:                 /*
221:                  * Macro to mark a queue as locked.  Locking a queue prevents an ISR from
222:                  * accessing the queue event lists.
223:                  */
224:                 #define prvLockQueue( pxQueue )								\
225:                 	taskENTER_CRITICAL();									\
226:                 	{														\
227:                 		if( ( pxQueue )->xRxLock == queueUNLOCKED )			\
228:                 		{													\
229:                 			( pxQueue )->xRxLock = queueLOCKED_UNMODIFIED;	\
230:                 		}													\
231:                 		if( ( pxQueue )->xTxLock == queueUNLOCKED )			\
232:                 		{													\
233:                 			( pxQueue )->xTxLock = queueLOCKED_UNMODIFIED;	\
234:                 		}													\
235:                 	}														\
236:                 	taskEXIT_CRITICAL()
237:                 /*-----------------------------------------------------------*/
238:                 
239:                 portBASE_TYPE xQueueGenericReset( xQueueHandle xQueue, portBASE_TYPE xNewQueue )
240:                 {
9D020E34  27BDFFE0   ADDIU SP, SP, -32
9D020E38  AFBF001C   SW RA, 28(SP)
9D020E3C  AFBE0018   SW S8, 24(SP)
9D020E40  03A0F021   ADDU S8, SP, ZERO
9D020E44  AFC40020   SW A0, 32(S8)
9D020E48  AFC50024   SW A1, 36(S8)
241:                 xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;
9D020E4C  8FC20020   LW V0, 32(S8)
9D020E50  AFC20010   SW V0, 16(S8)
242:                 
243:                 	configASSERT( pxQueue );
9D020E54  8FC20010   LW V0, 16(S8)
9D020E58  14400006   BNE V0, ZERO, 0x9D020E74
9D020E5C  00000000   NOP
9D020E60  3C029D03   LUI V0, -25341
9D020E64  244461EC   ADDIU A0, V0, 25068
9D020E68  240500F3   ADDIU A1, ZERO, 243
9D020E6C  0F40C5F5   JAL vAssertCalled
9D020E70  00000000   NOP
244:                 
245:                 	taskENTER_CRITICAL();
9D020E74  0F40834C   JAL vTaskEnterCritical
9D020E78  00000000   NOP
246:                 	{
247:                 		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
9D020E7C  8FC20010   LW V0, 16(S8)
9D020E80  8C420000   LW V0, 0(V0)
9D020E84  8FC30010   LW V1, 16(S8)
9D020E88  8C64003C   LW A0, 60(V1)
9D020E8C  8FC30010   LW V1, 16(S8)
9D020E90  8C630040   LW V1, 64(V1)
9D020E94  70831802   MUL V1, A0, V1
9D020E98  00431821   ADDU V1, V0, V1
9D020E9C  8FC20010   LW V0, 16(S8)
9D020EA0  AC430004   SW V1, 4(V0)
248:                 		pxQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
9D020EA4  8FC20010   LW V0, 16(S8)
9D020EA8  AC400038   SW ZERO, 56(V0)
249:                 		pxQueue->pcWriteTo = pxQueue->pcHead;
9D020EAC  8FC20010   LW V0, 16(S8)
9D020EB0  8C430000   LW V1, 0(V0)
9D020EB4  8FC20010   LW V0, 16(S8)
9D020EB8  AC430008   SW V1, 8(V0)
250:                 		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( unsigned portBASE_TYPE ) 1U ) * pxQueue->uxItemSize );
9D020EBC  8FC20010   LW V0, 16(S8)
9D020EC0  8C420000   LW V0, 0(V0)
9D020EC4  8FC30010   LW V1, 16(S8)
9D020EC8  8C63003C   LW V1, 60(V1)
9D020ECC  2464FFFF   ADDIU A0, V1, -1
9D020ED0  8FC30010   LW V1, 16(S8)
9D020ED4  8C630040   LW V1, 64(V1)
9D020ED8  70831802   MUL V1, A0, V1
9D020EDC  00431821   ADDU V1, V0, V1
9D020EE0  8FC20010   LW V0, 16(S8)
9D020EE4  AC43000C   SW V1, 12(V0)
251:                 		pxQueue->xRxLock = queueUNLOCKED;
9D020EE8  8FC20010   LW V0, 16(S8)
9D020EEC  2403FFFF   ADDIU V1, ZERO, -1
9D020EF0  AC430044   SW V1, 68(V0)
252:                 		pxQueue->xTxLock = queueUNLOCKED;
9D020EF4  8FC20010   LW V0, 16(S8)
9D020EF8  2403FFFF   ADDIU V1, ZERO, -1
9D020EFC  AC430048   SW V1, 72(V0)
253:                 
254:                 		if( xNewQueue == pdFALSE )
9D020F00  8FC20024   LW V0, 36(S8)
9D020F04  14400018   BNE V0, ZERO, 0x9D020F68
9D020F08  00000000   NOP
255:                 		{
256:                 			/* If there are tasks blocked waiting to read from the queue, then
257:                 			the tasks will remain blocked as after this function exits the queue
258:                 			will still be empty.  If there are tasks blocked waiting to	write to
259:                 			the queue, then one should be unblocked as after this function exits
260:                 			it will be possible to write to it. */
261:                 			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
9D020F0C  8FC20010   LW V0, 16(S8)
9D020F10  8C420010   LW V0, 16(V0)
9D020F14  1040001E   BEQ V0, ZERO, 0x9D020F90
9D020F18  00000000   NOP
262:                 			{
263:                 				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
9D020F1C  8FC20010   LW V0, 16(S8)
9D020F20  24420010   ADDIU V0, V0, 16
9D020F24  00402021   ADDU A0, V0, ZERO
9D020F28  0F408077   JAL xTaskRemoveFromEventList
9D020F2C  00000000   NOP
9D020F30  00401821   ADDU V1, V0, ZERO
9D020F34  24020001   ADDIU V0, ZERO, 1
9D020F38  14620015   BNE V1, V0, 0x9D020F90
9D020F3C  00000000   NOP
264:                 				{
265:                 					portYIELD_WITHIN_API();
9D020F40  40026800   MFC0 V0, Cause
9D020F44  AFC20014   SW V0, 20(S8)
9D020F48  8FC20014   LW V0, 20(S8)
9D020F4C  34420100   ORI V0, V0, 256
9D020F50  AFC20014   SW V0, 20(S8)
9D020F54  8FC20014   LW V0, 20(S8)
9D020F58  40826800   MTC0 V0, Cause
9D020F5C  000000C0   EHB
9D020F60  0B4083E4   J 0x9D020F90
9D020F64  00000000   NOP
266:                 				}
267:                 			}
268:                 		}
269:                 		else
270:                 		{
271:                 			/* Ensure the event queues start in the correct state. */
272:                 			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
9D020F68  8FC20010   LW V0, 16(S8)
9D020F6C  24420010   ADDIU V0, V0, 16
9D020F70  00402021   ADDU A0, V0, ZERO
9D020F74  0F40D0AB   JAL vListInitialise
9D020F78  00000000   NOP
273:                 			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
9D020F7C  8FC20010   LW V0, 16(S8)
9D020F80  24420024   ADDIU V0, V0, 36
9D020F84  00402021   ADDU A0, V0, ZERO
9D020F88  0F40D0AB   JAL vListInitialise
9D020F8C  00000000   NOP
274:                 		}
275:                 	}
276:                 	taskEXIT_CRITICAL();
9D020F90  0F40836C   JAL vTaskExitCritical
9D020F94  00000000   NOP
277:                 
278:                 	/* A value is returned for calling semantic consistency with previous
279:                 	versions. */
280:                 	return pdPASS;
9D020F98  24020001   ADDIU V0, ZERO, 1
281:                 }
9D020F9C  03C0E821   ADDU SP, S8, ZERO
9D020FA0  8FBF001C   LW RA, 28(SP)
9D020FA4  8FBE0018   LW S8, 24(SP)
9D020FA8  27BD0020   ADDIU SP, SP, 32
9D020FAC  03E00008   JR RA
9D020FB0  00000000   NOP
282:                 /*-----------------------------------------------------------*/
283:                 
284:                 xQueueHandle xQueueGenericCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize, unsigned char ucQueueType )
285:                 {
9D020FB4  27BDFFD8   ADDIU SP, SP, -40
9D020FB8  AFBF0024   SW RA, 36(SP)
9D020FBC  AFBE0020   SW S8, 32(SP)
9D020FC0  03A0F021   ADDU S8, SP, ZERO
9D020FC4  AFC40028   SW A0, 40(S8)
9D020FC8  AFC5002C   SW A1, 44(S8)
9D020FCC  00C01021   ADDU V0, A2, ZERO
9D020FD0  A3C20030   SB V0, 48(S8)
286:                 xQUEUE *pxNewQueue;
287:                 size_t xQueueSizeInBytes;
288:                 xQueueHandle xReturn = NULL;
9D020FD4  AFC00010   SW ZERO, 16(S8)
289:                 
290:                 	/* Remove compiler warnings about unused parameters should
291:                 	configUSE_TRACE_FACILITY not be set to 1. */
292:                 	( void ) ucQueueType;
293:                 
294:                 	/* Allocate the new queue structure. */
295:                 	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
9D020FD8  8FC20028   LW V0, 40(S8)
9D020FDC  10400028   BEQ V0, ZERO, 0x9D021080
9D020FE0  00000000   NOP
296:                 	{
297:                 		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
9D020FE4  2404004C   ADDIU A0, ZERO, 76
9D020FE8  0F40D1D2   JAL pvPortMalloc
9D020FEC  00000000   NOP
9D020FF0  AFC20014   SW V0, 20(S8)
298:                 		if( pxNewQueue != NULL )
9D020FF4  8FC20014   LW V0, 20(S8)
9D020FF8  10400021   BEQ V0, ZERO, 0x9D021080
9D020FFC  00000000   NOP
299:                 		{
300:                 			/* Create the list of pointers to queue items.  The queue is one byte
301:                 			longer than asked for to make wrap checking easier/faster. */
302:                 			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
9D021000  8FC30028   LW V1, 40(S8)
9D021004  8FC2002C   LW V0, 44(S8)
9D021008  70621002   MUL V0, V1, V0
9D02100C  24420001   ADDIU V0, V0, 1
9D021010  AFC20018   SW V0, 24(S8)
303:                 
304:                 			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
9D021014  8FC40018   LW A0, 24(S8)
9D021018  0F40D1D2   JAL pvPortMalloc
9D02101C  00000000   NOP
9D021020  00401821   ADDU V1, V0, ZERO
9D021024  8FC20014   LW V0, 20(S8)
9D021028  AC430000   SW V1, 0(V0)
305:                 			if( pxNewQueue->pcHead != NULL )
9D02102C  8FC20014   LW V0, 20(S8)
9D021030  8C420000   LW V0, 0(V0)
9D021034  1040000F   BEQ V0, ZERO, 0x9D021074
9D021038  00000000   NOP
306:                 			{
307:                 				/* Initialise the queue members as described above where the
308:                 				queue type is defined. */
309:                 				pxNewQueue->uxLength = uxQueueLength;
9D02103C  8FC20014   LW V0, 20(S8)
9D021040  8FC30028   LW V1, 40(S8)
9D021044  AC43003C   SW V1, 60(V0)
310:                 				pxNewQueue->uxItemSize = uxItemSize;
9D021048  8FC20014   LW V0, 20(S8)
9D02104C  8FC3002C   LW V1, 44(S8)
9D021050  AC430040   SW V1, 64(V0)
311:                 				( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
9D021054  8FC40014   LW A0, 20(S8)
9D021058  24050001   ADDIU A1, ZERO, 1
9D02105C  0F40838D   JAL xQueueGenericReset
9D021060  00000000   NOP
312:                 
313:                 				#if ( configUSE_TRACE_FACILITY == 1 )
314:                 				{
315:                 					pxNewQueue->ucQueueType = ucQueueType;
316:                 				}
317:                 				#endif /* configUSE_TRACE_FACILITY */
318:                 
319:                 				#if( configUSE_QUEUE_SETS == 1 )
320:                 				{
321:                 					pxNewQueue->pxQueueSetContainer = NULL;
322:                 				}
323:                 				#endif /* configUSE_QUEUE_SETS */
324:                 
325:                 				traceQUEUE_CREATE( pxNewQueue );
326:                 				xReturn = pxNewQueue;
9D021064  8FC20014   LW V0, 20(S8)
9D021068  AFC20010   SW V0, 16(S8)
9D02106C  0B408420   J 0x9D021080
9D021070  00000000   NOP
327:                 			}
328:                 			else
329:                 			{
330:                 				traceQUEUE_CREATE_FAILED( ucQueueType );
331:                 				vPortFree( pxNewQueue );
9D021074  8FC40014   LW A0, 20(S8)
9D021078  0F40D20E   JAL vPortFree
9D02107C  00000000   NOP
332:                 			}
333:                 		}
334:                 	}
335:                 
336:                 	configASSERT( xReturn );
9D021080  8FC20010   LW V0, 16(S8)
9D021084  14400006   BNE V0, ZERO, 0x9D0210A0
9D021088  00000000   NOP
9D02108C  3C029D03   LUI V0, -25341
9D021090  244461EC   ADDIU A0, V0, 25068
9D021094  24050150   ADDIU A1, ZERO, 336
9D021098  0F40C5F5   JAL vAssertCalled
9D02109C  00000000   NOP
337:                 
338:                 	return xReturn;
9D0210A0  8FC20010   LW V0, 16(S8)
339:                 }
9D0210A4  03C0E821   ADDU SP, S8, ZERO
9D0210A8  8FBF0024   LW RA, 36(SP)
9D0210AC  8FBE0020   LW S8, 32(SP)
9D0210B0  27BD0028   ADDIU SP, SP, 40
9D0210B4  03E00008   JR RA
9D0210B8  00000000   NOP
340:                 /*-----------------------------------------------------------*/
341:                 
342:                 #if ( configUSE_MUTEXES == 1 )
343:                 
344:                 	xQueueHandle xQueueCreateMutex( unsigned char ucQueueType )
345:                 	{
9D0210BC  27BDFFE0   ADDIU SP, SP, -32
9D0210C0  AFBF001C   SW RA, 28(SP)
9D0210C4  AFBE0018   SW S8, 24(SP)
9D0210C8  03A0F021   ADDU S8, SP, ZERO
9D0210CC  00801021   ADDU V0, A0, ZERO
9D0210D0  A3C20020   SB V0, 32(S8)
346:                 	xQUEUE *pxNewQueue;
347:                 
348:                 		/* Prevent compiler warnings about unused parameters if
349:                 		configUSE_TRACE_FACILITY does not equal 1. */
350:                 		( void ) ucQueueType;
351:                 
352:                 		/* Allocate the new queue structure. */
353:                 		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
9D0210D4  2404004C   ADDIU A0, ZERO, 76
9D0210D8  0F40D1D2   JAL pvPortMalloc
9D0210DC  00000000   NOP
9D0210E0  AFC20010   SW V0, 16(S8)
354:                 		if( pxNewQueue != NULL )
9D0210E4  8FC20010   LW V0, 16(S8)
9D0210E8  10400026   BEQ V0, ZERO, 0x9D021184
9D0210EC  00000000   NOP
355:                 		{
356:                 			/* Information required for priority inheritance. */
357:                 			pxNewQueue->pxMutexHolder = NULL;
9D0210F0  8FC20010   LW V0, 16(S8)
9D0210F4  AC400004   SW ZERO, 4(V0)
358:                 			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
9D0210F8  8FC20010   LW V0, 16(S8)
9D0210FC  AC400000   SW ZERO, 0(V0)
359:                 
360:                 			/* Queues used as a mutex no data is actually copied into or out
361:                 			of the queue. */
362:                 			pxNewQueue->pcWriteTo = NULL;
9D021100  8FC20010   LW V0, 16(S8)
9D021104  AC400008   SW ZERO, 8(V0)
363:                 			pxNewQueue->u.pcReadFrom = NULL;
9D021108  8FC20010   LW V0, 16(S8)
9D02110C  AC40000C   SW ZERO, 12(V0)
364:                 
365:                 			/* Each mutex has a length of 1 (like a binary semaphore) and
366:                 			an item size of 0 as nothing is actually copied into or out
367:                 			of the mutex. */
368:                 			pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
9D021110  8FC20010   LW V0, 16(S8)
9D021114  AC400038   SW ZERO, 56(V0)
369:                 			pxNewQueue->uxLength = ( unsigned portBASE_TYPE ) 1U;
9D021118  8FC20010   LW V0, 16(S8)
9D02111C  24030001   ADDIU V1, ZERO, 1
9D021120  AC43003C   SW V1, 60(V0)
370:                 			pxNewQueue->uxItemSize = ( unsigned portBASE_TYPE ) 0U;
9D021124  8FC20010   LW V0, 16(S8)
9D021128  AC400040   SW ZERO, 64(V0)
371:                 			pxNewQueue->xRxLock = queueUNLOCKED;
9D02112C  8FC20010   LW V0, 16(S8)
9D021130  2403FFFF   ADDIU V1, ZERO, -1
9D021134  AC430044   SW V1, 68(V0)
372:                 			pxNewQueue->xTxLock = queueUNLOCKED;
9D021138  8FC20010   LW V0, 16(S8)
9D02113C  2403FFFF   ADDIU V1, ZERO, -1
9D021140  AC430048   SW V1, 72(V0)
373:                 
374:                 			#if ( configUSE_TRACE_FACILITY == 1 )
375:                 			{
376:                 				pxNewQueue->ucQueueType = ucQueueType;
377:                 			}
378:                 			#endif
379:                 
380:                 			#if ( configUSE_QUEUE_SETS == 1 )
381:                 			{
382:                 				pxNewQueue->pxQueueSetContainer = NULL;
383:                 			}
384:                 			#endif
385:                 
386:                 			/* Ensure the event queues start with the correct state. */
387:                 			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
9D021144  8FC20010   LW V0, 16(S8)
9D021148  24420010   ADDIU V0, V0, 16
9D02114C  00402021   ADDU A0, V0, ZERO
9D021150  0F40D0AB   JAL vListInitialise
9D021154  00000000   NOP
388:                 			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
9D021158  8FC20010   LW V0, 16(S8)
9D02115C  24420024   ADDIU V0, V0, 36
9D021160  00402021   ADDU A0, V0, ZERO
9D021164  0F40D0AB   JAL vListInitialise
9D021168  00000000   NOP
389:                 
390:                 			traceCREATE_MUTEX( pxNewQueue );
391:                 
392:                 			/* Start with the semaphore in the expected state. */
393:                 			( void ) xQueueGenericSend( pxNewQueue, NULL, ( portTickType ) 0U, queueSEND_TO_BACK );
9D02116C  8FC40010   LW A0, 16(S8)
9D021170  00002821   ADDU A1, ZERO, ZERO
9D021174  00003021   ADDU A2, ZERO, ZERO
9D021178  00003821   ADDU A3, ZERO, ZERO
9D02117C  0F4084FB   JAL xQueueGenericSend
9D021180  00000000   NOP
394:                 		}
395:                 		else
396:                 		{
397:                 			traceCREATE_MUTEX_FAILED();
398:                 		}
399:                 
400:                 		configASSERT( pxNewQueue );
9D021184  8FC20010   LW V0, 16(S8)
9D021188  14400006   BNE V0, ZERO, 0x9D0211A4
9D02118C  00000000   NOP
9D021190  3C029D03   LUI V0, -25341
9D021194  244461EC   ADDIU A0, V0, 25068
9D021198  24050190   ADDIU A1, ZERO, 400
9D02119C  0F40C5F5   JAL vAssertCalled
9D0211A0  00000000   NOP
401:                 		return pxNewQueue;
9D0211A4  8FC20010   LW V0, 16(S8)
402:                 	}
9D0211A8  03C0E821   ADDU SP, S8, ZERO
9D0211AC  8FBF001C   LW RA, 28(SP)
9D0211B0  8FBE0018   LW S8, 24(SP)
9D0211B4  27BD0020   ADDIU SP, SP, 32
9D0211B8  03E00008   JR RA
9D0211BC  00000000   NOP
403:                 
404:                 #endif /* configUSE_MUTEXES */
405:                 /*-----------------------------------------------------------*/
406:                 
407:                 #if ( ( configUSE_MUTEXES == 1 ) && ( INCLUDE_xSemaphoreGetMutexHolder == 1 ) )
408:                 
409:                 	void* xQueueGetMutexHolder( xQueueHandle xSemaphore )
410:                 	{
411:                 	void *pxReturn;
412:                 
413:                 		/* This function is called by xSemaphoreGetMutexHolder(), and should not
414:                 		be called directly.  Note:  This is is a good way of determining if the
415:                 		calling task is the mutex holder, but not a good way of determining the
416:                 		identity of the mutex holder, as the holder may change between the
417:                 		following critical section exiting and the function returning. */
418:                 		taskENTER_CRITICAL();
419:                 		{
420:                 			if( ( ( xQUEUE * ) xSemaphore )->uxQueueType == queueQUEUE_IS_MUTEX )
421:                 			{
422:                 				pxReturn = ( void * ) ( ( xQUEUE * ) xSemaphore )->pxMutexHolder;
423:                 			}
424:                 			else
425:                 			{
426:                 				pxReturn = NULL;
427:                 			}
428:                 		}
429:                 		taskEXIT_CRITICAL();
430:                 
431:                 		return pxReturn;
432:                 	}
433:                 
434:                 #endif
435:                 /*-----------------------------------------------------------*/
436:                 
437:                 #if ( configUSE_RECURSIVE_MUTEXES == 1 )
438:                 
439:                 	portBASE_TYPE xQueueGiveMutexRecursive( xQueueHandle xMutex )
440:                 	{
9D0211C0  27BDFFD8   ADDIU SP, SP, -40
9D0211C4  AFBF0024   SW RA, 36(SP)
9D0211C8  AFBE0020   SW S8, 32(SP)
9D0211CC  AFB0001C   SW S0, 28(SP)
9D0211D0  03A0F021   ADDU S8, SP, ZERO
9D0211D4  AFC40028   SW A0, 40(S8)
441:                 	portBASE_TYPE xReturn;
442:                 	xQUEUE * const pxMutex = ( xQUEUE * ) xMutex;
9D0211D8  8FC20028   LW V0, 40(S8)
9D0211DC  AFC20014   SW V0, 20(S8)
443:                 
444:                 		configASSERT( pxMutex );
9D0211E0  8FC20014   LW V0, 20(S8)
9D0211E4  14400006   BNE V0, ZERO, 0x9D021200
9D0211E8  00000000   NOP
9D0211EC  3C029D03   LUI V0, -25341
9D0211F0  244461EC   ADDIU A0, V0, 25068
9D0211F4  240501BC   ADDIU A1, ZERO, 444
9D0211F8  0F40C5F5   JAL vAssertCalled
9D0211FC  00000000   NOP
445:                 
446:                 		/* If this is the task that holds the mutex then pxMutexHolder will not
447:                 		change outside of this task.  If this task does not hold the mutex then
448:                 		pxMutexHolder can never coincidentally equal the tasks handle, and as
449:                 		this is the only condition we are interested in it does not matter if
450:                 		pxMutexHolder is accessed simultaneously by another task.  Therefore no
451:                 		mutual exclusion is required to test the pxMutexHolder variable. */
452:                 		if( pxMutex->pxMutexHolder == ( void * ) xTaskGetCurrentTaskHandle() ) /*lint !e961 Not a redundant cast as xTaskHandle is a typedef. */
9D021200  8FC20014   LW V0, 20(S8)
9D021204  8C500004   LW S0, 4(V0)
9D021208  0F408277   JAL xTaskGetCurrentTaskHandle
9D02120C  00000000   NOP
9D021210  16020014   BNE S0, V0, 0x9D021264
9D021214  00000000   NOP
453:                 		{
454:                 			traceGIVE_MUTEX_RECURSIVE( pxMutex );
455:                 
456:                 			/* uxRecursiveCallCount cannot be zero if pxMutexHolder is equal to
457:                 			the task handle, therefore no underflow check is required.  Also,
458:                 			uxRecursiveCallCount is only modified by the mutex holder, and as
459:                 			there can only be one, no mutual exclusion is required to modify the
460:                 			uxRecursiveCallCount member. */
461:                 			( pxMutex->u.uxRecursiveCallCount )--;
9D021218  8FC20014   LW V0, 20(S8)
9D02121C  8C42000C   LW V0, 12(V0)
9D021220  2443FFFF   ADDIU V1, V0, -1
9D021224  8FC20014   LW V0, 20(S8)
9D021228  AC43000C   SW V1, 12(V0)
462:                 
463:                 			/* Have we unwound the call count? */
464:                 			if( pxMutex->u.uxRecursiveCallCount == ( unsigned portBASE_TYPE ) 0 )
9D02122C  8FC20014   LW V0, 20(S8)
9D021230  8C42000C   LW V0, 12(V0)
9D021234  14400007   BNE V0, ZERO, 0x9D021254
9D021238  00000000   NOP
465:                 			{
466:                 				/* Return the mutex.  This will automatically unblock any other
467:                 				task that might be waiting to access the mutex. */
468:                 				( void ) xQueueGenericSend( pxMutex, NULL, queueMUTEX_GIVE_BLOCK_TIME, queueSEND_TO_BACK );
9D02123C  8FC40014   LW A0, 20(S8)
9D021240  00002821   ADDU A1, ZERO, ZERO
9D021244  00003021   ADDU A2, ZERO, ZERO
9D021248  00003821   ADDU A3, ZERO, ZERO
9D02124C  0F4084FB   JAL xQueueGenericSend
9D021250  00000000   NOP
469:                 			}
470:                 
471:                 			xReturn = pdPASS;
9D021254  24020001   ADDIU V0, ZERO, 1
9D021258  AFC20010   SW V0, 16(S8)
9D02125C  0B40849A   J 0x9D021268
9D021260  00000000   NOP
472:                 		}
473:                 		else
474:                 		{
475:                 			/* We cannot give the mutex because we are not the holder. */
476:                 			xReturn = pdFAIL;
9D021264  AFC00010   SW ZERO, 16(S8)
477:                 
478:                 			traceGIVE_MUTEX_RECURSIVE_FAILED( pxMutex );
479:                 		}
480:                 
481:                 		return xReturn;
9D021268  8FC20010   LW V0, 16(S8)
482:                 	}
9D02126C  03C0E821   ADDU SP, S8, ZERO
9D021270  8FBF0024   LW RA, 36(SP)
9D021274  8FBE0020   LW S8, 32(SP)
9D021278  8FB0001C   LW S0, 28(SP)
9D02127C  27BD0028   ADDIU SP, SP, 40
9D021280  03E00008   JR RA
9D021284  00000000   NOP
483:                 
484:                 #endif /* configUSE_RECURSIVE_MUTEXES */
485:                 /*-----------------------------------------------------------*/
486:                 
487:                 #if ( configUSE_RECURSIVE_MUTEXES == 1 )
488:                 
489:                 	portBASE_TYPE xQueueTakeMutexRecursive( xQueueHandle xMutex, portTickType xBlockTime )
490:                 	{
9D021288  27BDFFD8   ADDIU SP, SP, -40
9D02128C  AFBF0024   SW RA, 36(SP)
9D021290  AFBE0020   SW S8, 32(SP)
9D021294  AFB0001C   SW S0, 28(SP)
9D021298  03A0F021   ADDU S8, SP, ZERO
9D02129C  AFC40028   SW A0, 40(S8)
9D0212A0  AFC5002C   SW A1, 44(S8)
491:                 	portBASE_TYPE xReturn;
492:                 	xQUEUE * const pxMutex = ( xQUEUE * ) xMutex;
9D0212A4  8FC20028   LW V0, 40(S8)
9D0212A8  AFC20014   SW V0, 20(S8)
493:                 
494:                 		configASSERT( pxMutex );
9D0212AC  8FC20014   LW V0, 20(S8)
9D0212B0  14400006   BNE V0, ZERO, 0x9D0212CC
9D0212B4  00000000   NOP
9D0212B8  3C029D03   LUI V0, -25341
9D0212BC  244461EC   ADDIU A0, V0, 25068
9D0212C0  240501EE   ADDIU A1, ZERO, 494
9D0212C4  0F40C5F5   JAL vAssertCalled
9D0212C8  00000000   NOP
495:                 
496:                 		/* Comments regarding mutual exclusion as per those within
497:                 		xQueueGiveMutexRecursive(). */
498:                 
499:                 		traceTAKE_MUTEX_RECURSIVE( pxMutex );
500:                 
501:                 		if( pxMutex->pxMutexHolder == ( void * ) xTaskGetCurrentTaskHandle() ) /*lint !e961 Cast is not redundant as xTaskHandle is a typedef. */
9D0212CC  8FC20014   LW V0, 20(S8)
9D0212D0  8C500004   LW S0, 4(V0)
9D0212D4  0F408277   JAL xTaskGetCurrentTaskHandle
9D0212D8  00000000   NOP
9D0212DC  1602000A   BNE S0, V0, 0x9D021308
9D0212E0  00000000   NOP
502:                 		{
503:                 			( pxMutex->u.uxRecursiveCallCount )++;
9D0212E4  8FC20014   LW V0, 20(S8)
9D0212E8  8C42000C   LW V0, 12(V0)
9D0212EC  24430001   ADDIU V1, V0, 1
9D0212F0  8FC20014   LW V0, 20(S8)
9D0212F4  AC43000C   SW V1, 12(V0)
504:                 			xReturn = pdPASS;
9D0212F8  24020001   ADDIU V0, ZERO, 1
9D0212FC  AFC20010   SW V0, 16(S8)
9D021300  0B4084D2   J 0x9D021348
9D021304  00000000   NOP
505:                 		}
506:                 		else
507:                 		{
508:                 			xReturn = xQueueGenericReceive( pxMutex, NULL, xBlockTime, pdFALSE );
9D021308  8FC40014   LW A0, 20(S8)
9D02130C  00002821   ADDU A1, ZERO, ZERO
9D021310  8FC6002C   LW A2, 44(S8)
9D021314  00003821   ADDU A3, ZERO, ZERO
9D021318  0F408644   JAL xQueueGenericReceive
9D02131C  00000000   NOP
9D021320  AFC20010   SW V0, 16(S8)
509:                 
510:                 			/* pdPASS will only be returned if we successfully obtained the mutex,
511:                 			we may have blocked to reach here. */
512:                 			if( xReturn == pdPASS )
9D021324  8FC30010   LW V1, 16(S8)
9D021328  24020001   ADDIU V0, ZERO, 1
9D02132C  14620006   BNE V1, V0, 0x9D021348
9D021330  00000000   NOP
513:                 			{
514:                 				( pxMutex->u.uxRecursiveCallCount )++;
9D021334  8FC20014   LW V0, 20(S8)
9D021338  8C42000C   LW V0, 12(V0)
9D02133C  24430001   ADDIU V1, V0, 1
9D021340  8FC20014   LW V0, 20(S8)
9D021344  AC43000C   SW V1, 12(V0)
515:                 			}
516:                 			else
517:                 			{
518:                 				traceTAKE_MUTEX_RECURSIVE_FAILED( pxMutex );
519:                 			}
520:                 		}
521:                 
522:                 		return xReturn;
9D021348  8FC20010   LW V0, 16(S8)
523:                 	}
9D02134C  03C0E821   ADDU SP, S8, ZERO
9D021350  8FBF0024   LW RA, 36(SP)
9D021354  8FBE0020   LW S8, 32(SP)
9D021358  8FB0001C   LW S0, 28(SP)
9D02135C  27BD0028   ADDIU SP, SP, 40
9D021360  03E00008   JR RA
9D021364  00000000   NOP
524:                 
525:                 #endif /* configUSE_RECURSIVE_MUTEXES */
526:                 /*-----------------------------------------------------------*/
527:                 
528:                 #if ( configUSE_COUNTING_SEMAPHORES == 1 )
529:                 
530:                 	xQueueHandle xQueueCreateCountingSemaphore( unsigned portBASE_TYPE uxCountValue, unsigned portBASE_TYPE uxInitialCount )
531:                 	{
9D021368  27BDFFE0   ADDIU SP, SP, -32
9D02136C  AFBF001C   SW RA, 28(SP)
9D021370  AFBE0018   SW S8, 24(SP)
9D021374  03A0F021   ADDU S8, SP, ZERO
9D021378  AFC40020   SW A0, 32(S8)
9D02137C  AFC50024   SW A1, 36(S8)
532:                 	xQueueHandle xHandle;
533:                 
534:                 		xHandle = xQueueGenericCreate( uxCountValue, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_COUNTING_SEMAPHORE );
9D021380  8FC40020   LW A0, 32(S8)
9D021384  00002821   ADDU A1, ZERO, ZERO
9D021388  24060002   ADDIU A2, ZERO, 2
9D02138C  0F4083ED   JAL xQueueGenericCreate
9D021390  00000000   NOP
9D021394  AFC20010   SW V0, 16(S8)
535:                 
536:                 		if( xHandle != NULL )
9D021398  8FC20010   LW V0, 16(S8)
9D02139C  10400004   BEQ V0, ZERO, 0x9D0213B0
9D0213A0  00000000   NOP
537:                 		{
538:                 			( ( xQUEUE * ) xHandle )->uxMessagesWaiting = uxInitialCount;
9D0213A4  8FC20010   LW V0, 16(S8)
9D0213A8  8FC30024   LW V1, 36(S8)
9D0213AC  AC430038   SW V1, 56(V0)
539:                 
540:                 			traceCREATE_COUNTING_SEMAPHORE();
541:                 		}
542:                 		else
543:                 		{
544:                 			traceCREATE_COUNTING_SEMAPHORE_FAILED();
545:                 		}
546:                 
547:                 		configASSERT( xHandle );
9D0213B0  8FC20010   LW V0, 16(S8)
9D0213B4  14400006   BNE V0, ZERO, 0x9D0213D0
9D0213B8  00000000   NOP
9D0213BC  3C029D03   LUI V0, -25341
9D0213C0  244461EC   ADDIU A0, V0, 25068
9D0213C4  24050223   ADDIU A1, ZERO, 547
9D0213C8  0F40C5F5   JAL vAssertCalled
9D0213CC  00000000   NOP
548:                 		return xHandle;
9D0213D0  8FC20010   LW V0, 16(S8)
549:                 	}
9D0213D4  03C0E821   ADDU SP, S8, ZERO
9D0213D8  8FBF001C   LW RA, 28(SP)
9D0213DC  8FBE0018   LW S8, 24(SP)
9D0213E0  27BD0020   ADDIU SP, SP, 32
9D0213E4  03E00008   JR RA
9D0213E8  00000000   NOP
550:                 
551:                 #endif /* configUSE_COUNTING_SEMAPHORES */
552:                 /*-----------------------------------------------------------*/
553:                 
554:                 signed portBASE_TYPE xQueueGenericSend( xQueueHandle xQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
555:                 {
9D0213EC  27BDFFD0   ADDIU SP, SP, -48
9D0213F0  AFBF002C   SW RA, 44(SP)
9D0213F4  AFBE0028   SW S8, 40(SP)
9D0213F8  03A0F021   ADDU S8, SP, ZERO
9D0213FC  AFC40030   SW A0, 48(S8)
9D021400  AFC50034   SW A1, 52(S8)
9D021404  AFC60038   SW A2, 56(S8)
9D021408  AFC7003C   SW A3, 60(S8)
556:                 signed portBASE_TYPE xEntryTimeSet = pdFALSE;
9D02140C  AFC00010   SW ZERO, 16(S8)
557:                 xTimeOutType xTimeOut;
558:                 xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;
9D021410  8FC20030   LW V0, 48(S8)
9D021414  AFC20014   SW V0, 20(S8)
559:                 
560:                 	configASSERT( pxQueue );
9D021418  8FC20014   LW V0, 20(S8)
9D02141C  14400006   BNE V0, ZERO, 0x9D021438
9D021420  00000000   NOP
9D021424  3C029D03   LUI V0, -25341
9D021428  244461EC   ADDIU A0, V0, 25068
9D02142C  24050230   ADDIU A1, ZERO, 560
9D021430  0F40C5F5   JAL vAssertCalled
9D021434  00000000   NOP
561:                 	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );
9D021438  8FC20034   LW V0, 52(S8)
9D02143C  14400005   BNE V0, ZERO, 0x9D021454
9D021440  00000000   NOP
9D021444  8FC20014   LW V0, 20(S8)
9D021448  8C420040   LW V0, 64(V0)
9D02144C  14400004   BNE V0, ZERO, 0x9D021460
9D021450  00000000   NOP
9D021454  24020001   ADDIU V0, ZERO, 1
9D021458  0B408519   J 0x9D021464
9D02145C  00000000   NOP
9D021460  00001021   ADDU V0, ZERO, ZERO
9D021464  14400006   BNE V0, ZERO, 0x9D021480
9D021468  00000000   NOP
9D02146C  3C029D03   LUI V0, -25341
9D021470  244461EC   ADDIU A0, V0, 25068
9D021474  24050231   ADDIU A1, ZERO, 561
9D021478  0F40C5F5   JAL vAssertCalled
9D02147C  00000000   NOP
562:                 	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
9D021480  8FC3003C   LW V1, 60(S8)
9D021484  24020002   ADDIU V0, ZERO, 2
9D021488  14620006   BNE V1, V0, 0x9D0214A4
9D02148C  00000000   NOP
9D021490  8FC20014   LW V0, 20(S8)
9D021494  8C43003C   LW V1, 60(V0)
9D021498  24020001   ADDIU V0, ZERO, 1
9D02149C  14620004   BNE V1, V0, 0x9D0214B0
9D0214A0  00000000   NOP
9D0214A4  24020001   ADDIU V0, ZERO, 1
9D0214A8  0B40852D   J 0x9D0214B4
9D0214AC  00000000   NOP
9D0214B0  00001021   ADDU V0, ZERO, ZERO
9D0214B4  14400009   BNE V0, ZERO, 0x9D0214DC
9D0214B8  00000000   NOP
9D0214BC  3C029D03   LUI V0, -25341
9D0214C0  244461EC   ADDIU A0, V0, 25068
9D0214C4  24050232   ADDIU A1, ZERO, 562
9D0214C8  0F40C5F5   JAL vAssertCalled
9D0214CC  00000000   NOP
9D0214D0  0B408537   J 0x9D0214DC
9D0214D4  00000000   NOP
563:                 
564:                 	/* This function relaxes the coding standard somewhat to allow return
565:                 	statements within the function itself.  This is done in the interest
566:                 	of execution time efficiency. */
567:                 	for( ;; )
568:                 	{
569:                 		taskENTER_CRITICAL();
9D0214DC  0F40834C   JAL vTaskEnterCritical
9D0214E0  00000000   NOP
570:                 		{
571:                 			/* Is there room on the queue now?  The running task must be
572:                 			the highest priority task wanting to access the queue.  If
573:                 			the head item in the queue is to be overwritten then it does
574:                 			not matter if the queue is full. */
575:                 			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
9D0214E4  8FC20014   LW V0, 20(S8)
9D0214E8  8C430038   LW V1, 56(V0)
9D0214EC  8FC20014   LW V0, 20(S8)
9D0214F0  8C42003C   LW V0, 60(V0)
9D0214F4  0062102B   SLTU V0, V1, V0
9D0214F8  14400005   BNE V0, ZERO, 0x9D021510
9D0214FC  00000000   NOP
9D021500  8FC3003C   LW V1, 60(S8)
9D021504  24020002   ADDIU V0, ZERO, 2
9D021508  14620020   BNE V1, V0, 0x9D02158C
9D02150C  00000000   NOP
576:                 			{
577:                 				traceQUEUE_SEND( pxQueue );
578:                 				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
9D021510  8FC40014   LW A0, 20(S8)
9D021514  8FC50034   LW A1, 52(S8)
9D021518  8FC6003C   LW A2, 60(S8)
9D02151C  0F40884E   JAL 0x9D022138
9D021520  00000000   NOP
579:                 
580:                 				#if ( configUSE_QUEUE_SETS == 1 )
581:                 				{
582:                 					if( pxQueue->pxQueueSetContainer != NULL )
583:                 					{
584:                 						if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) == pdTRUE )
585:                 						{
586:                 							/* The queue is a member of a queue set, and posting
587:                 							to the queue set caused a higher priority task to
588:                 							unblock. A context switch is required. */
589:                 							portYIELD_WITHIN_API();
590:                 						}
591:                 					}
592:                 					else
593:                 					{
594:                 						/* If there was a task waiting for data to arrive on the
595:                 						queue then unblock it now. */
596:                 						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
597:                 						{
598:                 							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
599:                 							{
600:                 								/* The unblocked task has a priority higher than
601:                 								our own so yield immediately.  Yes it is ok to
602:                 								do this from within the critical section - the
603:                 								kernel takes care of that. */
604:                 								portYIELD_WITHIN_API();
605:                 							}
606:                 						}
607:                 					}
608:                 				}
609:                 				#else /* configUSE_QUEUE_SETS */
610:                 				{
611:                 					/* If there was a task waiting for data to arrive on the
612:                 					queue then unblock it now. */
613:                 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
9D021524  8FC20014   LW V0, 20(S8)
9D021528  8C420024   LW V0, 36(V0)
9D02152C  10400012   BEQ V0, ZERO, 0x9D021578
9D021530  00000000   NOP
614:                 					{
615:                 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
9D021534  8FC20014   LW V0, 20(S8)
9D021538  24420024   ADDIU V0, V0, 36
9D02153C  00402021   ADDU A0, V0, ZERO
9D021540  0F408077   JAL xTaskRemoveFromEventList
9D021544  00000000   NOP
9D021548  00401821   ADDU V1, V0, ZERO
9D02154C  24020001   ADDIU V0, ZERO, 1
9D021550  14620009   BNE V1, V0, 0x9D021578
9D021554  00000000   NOP
616:                 						{
617:                 							/* The unblocked task has a priority higher than
618:                 							our own so yield immediately.  Yes it is ok to do
619:                 							this from within the critical section - the kernel
620:                 							takes care of that. */
621:                 							portYIELD_WITHIN_API();
9D021558  40026800   MFC0 V0, Cause
9D02155C  AFC2001C   SW V0, 28(S8)
9D021560  8FC2001C   LW V0, 28(S8)
9D021564  34420100   ORI V0, V0, 256
9D021568  AFC2001C   SW V0, 28(S8)
9D02156C  8FC2001C   LW V0, 28(S8)
9D021570  40826800   MTC0 V0, Cause
9D021574  000000C0   EHB
622:                 						}
623:                 					}
624:                 				}
625:                 				#endif /* configUSE_QUEUE_SETS */
626:                 
627:                 				taskEXIT_CRITICAL();
9D021578  0F40836C   JAL vTaskExitCritical
9D02157C  00000000   NOP
628:                 
629:                 				/* Return to the original privilege level before exiting the
630:                 				function. */
631:                 				return pdPASS;
9D021580  24020001   ADDIU V0, ZERO, 1
9D021584  0B4085BC   J 0x9D0216F0
9D021588  00000000   NOP
632:                 			}
633:                 			else
634:                 			{
635:                 				if( xTicksToWait == ( portTickType ) 0 )
9D02158C  8FC20038   LW V0, 56(S8)
9D021590  14400006   BNE V0, ZERO, 0x9D0215AC
9D021594  00000000   NOP
636:                 				{
637:                 					/* The queue was full and no block time is specified (or
638:                 					the block time has expired) so leave now. */
639:                 					taskEXIT_CRITICAL();
9D021598  0F40836C   JAL vTaskExitCritical
9D02159C  00000000   NOP
640:                 
641:                 					/* Return to the original privilege level before exiting
642:                 					the function. */
643:                 					traceQUEUE_SEND_FAILED( pxQueue );
644:                 					return errQUEUE_FULL;
9D0215A0  00001021   ADDU V0, ZERO, ZERO
9D0215A4  0B4085BC   J 0x9D0216F0
9D0215A8  00000000   NOP
645:                 				}
646:                 				else if( xEntryTimeSet == pdFALSE )
9D0215AC  8FC20010   LW V0, 16(S8)
9D0215B0  14400007   BNE V0, ZERO, 0x9D0215D0
9D0215B4  00000000   NOP
647:                 				{
648:                 					/* The queue was full and a block time was specified so
649:                 					configure the timeout structure. */
650:                 					vTaskSetTimeOutState( &xTimeOut );
9D0215B8  27C20020   ADDIU V0, S8, 32
9D0215BC  00402021   ADDU A0, V0, ZERO
9D0215C0  0F4080C7   JAL vTaskSetTimeOutState
9D0215C4  00000000   NOP
651:                 					xEntryTimeSet = pdTRUE;
9D0215C8  24020001   ADDIU V0, ZERO, 1
9D0215CC  AFC20010   SW V0, 16(S8)
652:                 				}
653:                 				else
654:                 				{
655:                 					/* Entry time was already set. */
656:                 				}
657:                 			}
658:                 		}
659:                 		taskEXIT_CRITICAL();
9D0215D0  0F40836C   JAL vTaskExitCritical
9D0215D4  00000000   NOP
660:                 
661:                 		/* Interrupts and other tasks can send to and receive from the queue
662:                 		now the critical section has been exited. */
663:                 
664:                 		vTaskSuspendAll();
9D0215D8  0F407E3F   JAL vTaskSuspendAll
9D0215DC  00000000   NOP
665:                 		prvLockQueue( pxQueue );
9D0215E0  0F40834C   JAL vTaskEnterCritical
9D0215E4  00000000   NOP
9D0215E8  8FC20014   LW V0, 20(S8)
9D0215EC  8C430044   LW V1, 68(V0)
9D0215F0  2402FFFF   ADDIU V0, ZERO, -1
9D0215F4  14620003   BNE V1, V0, 0x9D021604
9D0215F8  00000000   NOP
9D0215FC  8FC20014   LW V0, 20(S8)
9D021600  AC400044   SW ZERO, 68(V0)
9D021604  8FC20014   LW V0, 20(S8)
9D021608  8C430048   LW V1, 72(V0)
9D02160C  2402FFFF   ADDIU V0, ZERO, -1
9D021610  14620003   BNE V1, V0, 0x9D021620
9D021614  00000000   NOP
9D021618  8FC20014   LW V0, 20(S8)
9D02161C  AC400048   SW ZERO, 72(V0)
9D021620  0F40836C   JAL vTaskExitCritical
9D021624  00000000   NOP
666:                 
667:                 		/* Update the timeout state to see if it has expired yet. */
668:                 		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
9D021628  27C30020   ADDIU V1, S8, 32
9D02162C  27C20038   ADDIU V0, S8, 56
9D021630  00602021   ADDU A0, V1, ZERO
9D021634  00402821   ADDU A1, V0, ZERO
9D021638  0F4080E0   JAL xTaskCheckForTimeOut
9D02163C  00000000   NOP
9D021640  14400025   BNE V0, ZERO, 0x9D0216D8
9D021644  00000000   NOP
669:                 		{
670:                 			if( prvIsQueueFull( pxQueue ) != pdFALSE )
9D021648  8FC40014   LW A0, 20(S8)
9D02164C  0F40896E   JAL 0x9D0225B8
9D021650  00000000   NOP
9D021654  10400019   BEQ V0, ZERO, 0x9D0216BC
9D021658  00000000   NOP
671:                 			{
672:                 				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
673:                 				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
9D02165C  8FC20014   LW V0, 20(S8)
9D021660  24430010   ADDIU V1, V0, 16
9D021664  8FC20038   LW V0, 56(S8)
9D021668  00602021   ADDU A0, V1, ZERO
9D02166C  00402821   ADDU A1, V0, ZERO
9D021670  0F40800A   JAL vTaskPlaceOnEventList
9D021674  00000000   NOP
674:                 
675:                 				/* Unlocking the queue means queue events can effect the
676:                 				event list.  It is possible	that interrupts occurring now
677:                 				remove this task from the event	list again - but as the
678:                 				scheduler is suspended the task will go onto the pending
679:                 				ready last instead of the actual ready list. */
680:                 				prvUnlockQueue( pxQueue );
9D021678  8FC40014   LW A0, 20(S8)
9D02167C  0F4088E9   JAL 0x9D0223A4
9D021680  00000000   NOP
681:                 
682:                 				/* Resuming the scheduler will move tasks from the pending
683:                 				ready list into the ready list - so it is feasible that this
684:                 				task is already in a ready list before it yields - in which
685:                 				case the yield will not cause a context switch unless there
686:                 				is also a higher priority task in the pending ready list. */
687:                 				if( xTaskResumeAll() == pdFALSE )
9D021684  0F407E4A   JAL xTaskResumeAll
9D021688  00000000   NOP
9D02168C  1440FF92   BNE V0, ZERO, 0x9D0214D8
9D021690  00000000   NOP
688:                 				{
689:                 					portYIELD_WITHIN_API();
9D021694  40026800   MFC0 V0, Cause
9D021698  AFC20018   SW V0, 24(S8)
9D02169C  8FC20018   LW V0, 24(S8)
9D0216A0  34420100   ORI V0, V0, 256
9D0216A4  AFC20018   SW V0, 24(S8)
9D0216A8  8FC20018   LW V0, 24(S8)
9D0216AC  40826800   MTC0 V0, Cause
9D0216B0  000000C0   EHB
690:                 				}
691:                 			}
692:                 			else
693:                 			{
694:                 				/* Try again. */
695:                 				prvUnlockQueue( pxQueue );
9D0216BC  8FC40014   LW A0, 20(S8)
9D0216C0  0F4088E9   JAL 0x9D0223A4
9D0216C4  00000000   NOP
696:                 				( void ) xTaskResumeAll();
9D0216C8  0F407E4A   JAL xTaskResumeAll
9D0216CC  00000000   NOP
697:                 			}
698:                 		}
699:                 		else
700:                 		{
701:                 			/* The timeout has expired. */
702:                 			prvUnlockQueue( pxQueue );
9D0216D8  8FC40014   LW A0, 20(S8)
9D0216DC  0F4088E9   JAL 0x9D0223A4
9D0216E0  00000000   NOP
703:                 			( void ) xTaskResumeAll();
9D0216E4  0F407E4A   JAL xTaskResumeAll
9D0216E8  00000000   NOP
704:                 
705:                 			/* Return to the original privilege level before exiting the
706:                 			function. */
707:                 			traceQUEUE_SEND_FAILED( pxQueue );
708:                 			return errQUEUE_FULL;
9D0216EC  00001021   ADDU V0, ZERO, ZERO
709:                 		}
710:                 	}
9D0214D8  00000000   NOP
9D0216B4  0B408537   J 0x9D0214DC
9D0216B8  00000000   NOP
9D0216D0  0B408537   J 0x9D0214DC
9D0216D4  00000000   NOP
711:                 }
9D0216F0  03C0E821   ADDU SP, S8, ZERO
9D0216F4  8FBF002C   LW RA, 44(SP)
9D0216F8  8FBE0028   LW S8, 40(SP)
9D0216FC  27BD0030   ADDIU SP, SP, 48
9D021700  03E00008   JR RA
9D021704  00000000   NOP
712:                 /*-----------------------------------------------------------*/
713:                 
714:                 #if ( configUSE_ALTERNATIVE_API == 1 )
715:                 
716:                 	signed portBASE_TYPE xQueueAltGenericSend( xQueueHandle xQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
717:                 	{
718:                 	signed portBASE_TYPE xEntryTimeSet = pdFALSE;
719:                 	xTimeOutType xTimeOut;
720:                 	xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;
721:                 
722:                 		configASSERT( pxQueue );
723:                 		configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );
724:                 
725:                 		for( ;; )
726:                 		{
727:                 			taskENTER_CRITICAL();
728:                 			{
729:                 				/* Is there room on the queue now?  To be running we must be
730:                 				the highest priority task wanting to access the queue. */
731:                 				if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
732:                 				{
733:                 					traceQUEUE_SEND( pxQueue );
734:                 					prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
735:                 
736:                 					/* If there was a task waiting for data to arrive on the
737:                 					queue then unblock it now. */
738:                 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
739:                 					{
740:                 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
741:                 						{
742:                 							/* The unblocked task has a priority higher than
743:                 							our own so yield immediately. */
744:                 							portYIELD_WITHIN_API();
745:                 						}
746:                 					}
747:                 
748:                 					taskEXIT_CRITICAL();
749:                 					return pdPASS;
750:                 				}
751:                 				else
752:                 				{
753:                 					if( xTicksToWait == ( portTickType ) 0 )
754:                 					{
755:                 						taskEXIT_CRITICAL();
756:                 						return errQUEUE_FULL;
757:                 					}
758:                 					else if( xEntryTimeSet == pdFALSE )
759:                 					{
760:                 						vTaskSetTimeOutState( &xTimeOut );
761:                 						xEntryTimeSet = pdTRUE;
762:                 					}
763:                 				}
764:                 			}
765:                 			taskEXIT_CRITICAL();
766:                 
767:                 			taskENTER_CRITICAL();
768:                 			{
769:                 				if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
770:                 				{
771:                 					if( prvIsQueueFull( pxQueue ) != pdFALSE )
772:                 					{
773:                 						traceBLOCKING_ON_QUEUE_SEND( pxQueue );
774:                 						vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
775:                 						portYIELD_WITHIN_API();
776:                 					}
777:                 				}
778:                 				else
779:                 				{
780:                 					taskEXIT_CRITICAL();
781:                 					traceQUEUE_SEND_FAILED( pxQueue );
782:                 					return errQUEUE_FULL;
783:                 				}
784:                 			}
785:                 			taskEXIT_CRITICAL();
786:                 		}
787:                 	}
788:                 
789:                 #endif /* configUSE_ALTERNATIVE_API */
790:                 /*-----------------------------------------------------------*/
791:                 
792:                 #if ( configUSE_ALTERNATIVE_API == 1 )
793:                 
794:                 	signed portBASE_TYPE xQueueAltGenericReceive( xQueueHandle xQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
795:                 	{
796:                 	signed portBASE_TYPE xEntryTimeSet = pdFALSE;
797:                 	xTimeOutType xTimeOut;
798:                 	signed char *pcOriginalReadPosition;
799:                 	xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;
800:                 
801:                 		configASSERT( pxQueue );
802:                 		configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );
803:                 
804:                 		for( ;; )
805:                 		{
806:                 			taskENTER_CRITICAL();
807:                 			{
808:                 				if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
809:                 				{
810:                 					/* Remember our read position in case we are just peeking. */
811:                 					pcOriginalReadPosition = pxQueue->u.pcReadFrom;
812:                 
813:                 					prvCopyDataFromQueue( pxQueue, pvBuffer );
814:                 
815:                 					if( xJustPeeking == pdFALSE )
816:                 					{
817:                 						traceQUEUE_RECEIVE( pxQueue );
818:                 
819:                 						/* Data is actually being removed (not just peeked). */
820:                 						--( pxQueue->uxMessagesWaiting );
821:                 
822:                 						#if ( configUSE_MUTEXES == 1 )
823:                 						{
824:                 							if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
825:                 							{
826:                 								/* Record the information required to implement
827:                 								priority inheritance should it become necessary. */
828:                 								pxQueue->pxMutexHolder = ( signed char * ) xTaskGetCurrentTaskHandle();
829:                 							}
830:                 						}
831:                 						#endif
832:                 
833:                 						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
834:                 						{
835:                 							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
836:                 							{
837:                 								portYIELD_WITHIN_API();
838:                 							}
839:                 						}
840:                 					}
841:                 					else
842:                 					{
843:                 						traceQUEUE_PEEK( pxQueue );
844:                 
845:                 						/* We are not removing the data, so reset our read
846:                 						pointer. */
847:                 						pxQueue->u.pcReadFrom = pcOriginalReadPosition;
848:                 
849:                 						/* The data is being left in the queue, so see if there are
850:                 						any other tasks waiting for the data. */
851:                 						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
852:                 						{
853:                 							/* Tasks that are removed from the event list will get added to
854:                 							the pending ready list as the scheduler is still suspended. */
855:                 							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
856:                 							{
857:                 								/* The task waiting has a higher priority than this task. */
858:                 								portYIELD_WITHIN_API();
859:                 							}
860:                 						}
861:                 
862:                 					}
863:                 
864:                 					taskEXIT_CRITICAL();
865:                 					return pdPASS;
866:                 				}
867:                 				else
868:                 				{
869:                 					if( xTicksToWait == ( portTickType ) 0 )
870:                 					{
871:                 						taskEXIT_CRITICAL();
872:                 						traceQUEUE_RECEIVE_FAILED( pxQueue );
873:                 						return errQUEUE_EMPTY;
874:                 					}
875:                 					else if( xEntryTimeSet == pdFALSE )
876:                 					{
877:                 						vTaskSetTimeOutState( &xTimeOut );
878:                 						xEntryTimeSet = pdTRUE;
879:                 					}
880:                 				}
881:                 			}
882:                 			taskEXIT_CRITICAL();
883:                 
884:                 			taskENTER_CRITICAL();
885:                 			{
886:                 				if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
887:                 				{
888:                 					if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
889:                 					{
890:                 						traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
891:                 
892:                 						#if ( configUSE_MUTEXES == 1 )
893:                 						{
894:                 							if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
895:                 							{
896:                 								portENTER_CRITICAL();
897:                 								{
898:                 									vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
899:                 								}
900:                 								portEXIT_CRITICAL();
901:                 							}
902:                 						}
903:                 						#endif
904:                 
905:                 						vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
906:                 						portYIELD_WITHIN_API();
907:                 					}
908:                 				}
909:                 				else
910:                 				{
911:                 					taskEXIT_CRITICAL();
912:                 					traceQUEUE_RECEIVE_FAILED( pxQueue );
913:                 					return errQUEUE_EMPTY;
914:                 				}
915:                 			}
916:                 			taskEXIT_CRITICAL();
917:                 		}
918:                 	}
919:                 
920:                 
921:                 #endif /* configUSE_ALTERNATIVE_API */
922:                 /*-----------------------------------------------------------*/
923:                 
924:                 signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle xQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
925:                 {
9D021708  27BDFFD8   ADDIU SP, SP, -40
9D02170C  AFBF0024   SW RA, 36(SP)
9D021710  AFBE0020   SW S8, 32(SP)
9D021714  03A0F021   ADDU S8, SP, ZERO
9D021718  AFC40028   SW A0, 40(S8)
9D02171C  AFC5002C   SW A1, 44(S8)
9D021720  AFC60030   SW A2, 48(S8)
9D021724  AFC70034   SW A3, 52(S8)
926:                 signed portBASE_TYPE xReturn;
927:                 unsigned portBASE_TYPE uxSavedInterruptStatus;
928:                 xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;
9D021728  8FC20028   LW V0, 40(S8)
9D02172C  AFC20014   SW V0, 20(S8)
929:                 
930:                 	configASSERT( pxQueue );
9D021730  8FC20014   LW V0, 20(S8)
9D021734  14400006   BNE V0, ZERO, 0x9D021750
9D021738  00000000   NOP
9D02173C  3C029D03   LUI V0, -25341
9D021740  244461EC   ADDIU A0, V0, 25068
9D021744  240503A2   ADDIU A1, ZERO, 930
9D021748  0F40C5F5   JAL vAssertCalled
9D02174C  00000000   NOP
931:                 	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );
9D021750  8FC2002C   LW V0, 44(S8)
9D021754  14400005   BNE V0, ZERO, 0x9D02176C
9D021758  00000000   NOP
9D02175C  8FC20014   LW V0, 20(S8)
9D021760  8C420040   LW V0, 64(V0)
9D021764  14400004   BNE V0, ZERO, 0x9D021778
9D021768  00000000   NOP
9D02176C  24020001   ADDIU V0, ZERO, 1
9D021770  0B4085DF   J 0x9D02177C
9D021774  00000000   NOP
9D021778  00001021   ADDU V0, ZERO, ZERO
9D02177C  14400006   BNE V0, ZERO, 0x9D021798
9D021780  00000000   NOP
9D021784  3C029D03   LUI V0, -25341
9D021788  244461EC   ADDIU A0, V0, 25068
9D02178C  240503A3   ADDIU A1, ZERO, 931
9D021790  0F40C5F5   JAL vAssertCalled
9D021794  00000000   NOP
932:                 	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
9D021798  8FC30034   LW V1, 52(S8)
9D02179C  24020002   ADDIU V0, ZERO, 2
9D0217A0  14620006   BNE V1, V0, 0x9D0217BC
9D0217A4  00000000   NOP
9D0217A8  8FC20014   LW V0, 20(S8)
9D0217AC  8C43003C   LW V1, 60(V0)
9D0217B0  24020001   ADDIU V0, ZERO, 1
9D0217B4  14620004   BNE V1, V0, 0x9D0217C8
9D0217B8  00000000   NOP
9D0217BC  24020001   ADDIU V0, ZERO, 1
9D0217C0  0B4085F3   J 0x9D0217CC
9D0217C4  00000000   NOP
9D0217C8  00001021   ADDU V0, ZERO, ZERO
9D0217CC  14400006   BNE V0, ZERO, 0x9D0217E8
9D0217D0  00000000   NOP
9D0217D4  3C029D03   LUI V0, -25341
9D0217D8  244461EC   ADDIU A0, V0, 25068
9D0217DC  240503A4   ADDIU A1, ZERO, 932
9D0217E0  0F40C5F5   JAL vAssertCalled
9D0217E4  00000000   NOP
933:                 
934:                 	/* RTOS ports that support interrupt nesting have the concept of a maximum
935:                 	system call (or maximum API call) interrupt priority.  Interrupts that are
936:                 	above the maximum system call priority are keep permanently enabled, even
937:                 	when the RTOS kernel is in a critical section, but cannot make any calls to
938:                 	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
939:                 	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
940:                 	failure if a FreeRTOS API function is called from an interrupt that has been
941:                 	assigned a priority above the configured maximum system call priority.
942:                 	Only FreeRTOS functions that end in FromISR can be called from interrupts
943:                 	that have been assigned a priority at or (logically) below the maximum
944:                 	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
945:                 	safe API to ensure interrupt entry is as fast and as simple as possible.
946:                 	More information (albeit Cortex-M specific) is provided on the following
947:                 	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
948:                 	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
9D0217E8  40026000   MFC0 V0, Status
9D0217EC  3042FC00   ANDI V0, V0, -1024
9D0217F0  00021282   SRL V0, V0, 10
9D0217F4  2C420004   SLTIU V0, V0, 4
9D0217F8  14400006   BNE V0, ZERO, 0x9D021814
9D0217FC  00000000   NOP
9D021800  3C029D03   LUI V0, -25341
9D021804  244461EC   ADDIU A0, V0, 25068
9D021808  240503B4   ADDIU A1, ZERO, 948
9D02180C  0F40C5F5   JAL vAssertCalled
9D021810  00000000   NOP
949:                 
950:                 	/* Similar to xQueueGenericSend, except we don't block if there is no room
951:                 	in the queue.  Also we don't directly wake a task that was blocked on a
952:                 	queue read, instead we return a flag to say whether a context switch is
953:                 	required or not (i.e. has a task with a higher priority than us been woken
954:                 	by this	post). */
955:                 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
9D021814  0F40CFD1   JAL uxPortSetInterruptMaskFromISR
9D021818  00000000   NOP
9D02181C  AFC20018   SW V0, 24(S8)
956:                 	{
957:                 		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
9D021820  8FC20014   LW V0, 20(S8)
9D021824  8C430038   LW V1, 56(V0)
9D021828  8FC20014   LW V0, 20(S8)
9D02182C  8C42003C   LW V0, 60(V0)
9D021830  0062102B   SLTU V0, V1, V0
9D021834  14400005   BNE V0, ZERO, 0x9D02184C
9D021838  00000000   NOP
9D02183C  8FC30034   LW V1, 52(S8)
9D021840  24020002   ADDIU V0, ZERO, 2
9D021844  14620027   BNE V1, V0, 0x9D0218E4
9D021848  00000000   NOP
958:                 		{
959:                 			traceQUEUE_SEND_FROM_ISR( pxQueue );
960:                 
961:                 			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
9D02184C  8FC40014   LW A0, 20(S8)
9D021850  8FC5002C   LW A1, 44(S8)
9D021854  8FC60034   LW A2, 52(S8)
9D021858  0F40884E   JAL 0x9D022138
9D02185C  00000000   NOP
962:                 
963:                 			/* If the queue is locked we do not alter the event list.  This will
964:                 			be done when the queue is unlocked later. */
965:                 			if( pxQueue->xTxLock == queueUNLOCKED )
9D021860  8FC20014   LW V0, 20(S8)
9D021864  8C430048   LW V1, 72(V0)
9D021868  2402FFFF   ADDIU V0, ZERO, -1
9D02186C  14620014   BNE V1, V0, 0x9D0218C0
9D021870  00000000   NOP
966:                 			{
967:                 				#if ( configUSE_QUEUE_SETS == 1 )
968:                 				{
969:                 					if( pxQueue->pxQueueSetContainer != NULL )
970:                 					{
971:                 						if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) == pdTRUE )
972:                 						{
973:                 							/* The queue is a member of a queue set, and posting
974:                 							to the queue set caused a higher priority task to
975:                 							unblock.  A context switch is required. */
976:                 							if( pxHigherPriorityTaskWoken != NULL )
977:                 							{
978:                 								*pxHigherPriorityTaskWoken = pdTRUE;
979:                 							}
980:                 						}
981:                 					}
982:                 					else
983:                 					{
984:                 						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
985:                 						{
986:                 							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
987:                 							{
988:                 								/* The task waiting has a higher priority so record that a
989:                 								context	switch is required. */
990:                 								if( pxHigherPriorityTaskWoken != NULL )
991:                 								{
992:                 									*pxHigherPriorityTaskWoken = pdTRUE;
993:                 								}
994:                 							}
995:                 						}
996:                 					}
997:                 				}
998:                 				#else /* configUSE_QUEUE_SETS */
999:                 				{
1000:                					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
9D021874  8FC20014   LW V0, 20(S8)
9D021878  8C420024   LW V0, 36(V0)
9D02187C  10400015   BEQ V0, ZERO, 0x9D0218D4
9D021880  00000000   NOP
1001:                					{
1002:                						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
9D021884  8FC20014   LW V0, 20(S8)
9D021888  24420024   ADDIU V0, V0, 36
9D02188C  00402021   ADDU A0, V0, ZERO
9D021890  0F408077   JAL xTaskRemoveFromEventList
9D021894  00000000   NOP
9D021898  1040000E   BEQ V0, ZERO, 0x9D0218D4
9D02189C  00000000   NOP
1003:                						{
1004:                							/* The task waiting has a higher priority so record that a
1005:                							context	switch is required. */
1006:                							if( pxHigherPriorityTaskWoken != NULL )
9D0218A0  8FC20030   LW V0, 48(S8)
9D0218A4  1040000B   BEQ V0, ZERO, 0x9D0218D4
9D0218A8  00000000   NOP
1007:                							{
1008:                								*pxHigherPriorityTaskWoken = pdTRUE;
9D0218AC  8FC20030   LW V0, 48(S8)
9D0218B0  24030001   ADDIU V1, ZERO, 1
9D0218B4  AC430000   SW V1, 0(V0)
9D0218B8  0B408635   J 0x9D0218D4
9D0218BC  00000000   NOP
1009:                							}
1010:                						}
1011:                					}
1012:                				}
1013:                				#endif /* configUSE_QUEUE_SETS */
1014:                			}
1015:                			else
1016:                			{
1017:                				/* Increment the lock count so the task that unlocks the queue
1018:                				knows that data was posted while it was locked. */
1019:                				++( pxQueue->xTxLock );
9D0218C0  8FC20014   LW V0, 20(S8)
9D0218C4  8C420048   LW V0, 72(V0)
9D0218C8  24430001   ADDIU V1, V0, 1
9D0218CC  8FC20014   LW V0, 20(S8)
9D0218D0  AC430048   SW V1, 72(V0)
1020:                			}
1021:                
1022:                			xReturn = pdPASS;
9D0218D4  24020001   ADDIU V0, ZERO, 1
9D0218D8  AFC20010   SW V0, 16(S8)
9D0218DC  0B40863A   J 0x9D0218E8
9D0218E0  00000000   NOP
1023:                		}
1024:                		else
1025:                		{
1026:                			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
1027:                			xReturn = errQUEUE_FULL;
9D0218E4  AFC00010   SW ZERO, 16(S8)
1028:                		}
1029:                	}
1030:                	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
9D0218E8  8FC40018   LW A0, 24(S8)
9D0218EC  0F40CFE4   JAL vPortClearInterruptMaskFromISR
9D0218F0  00000000   NOP
1031:                
1032:                	return xReturn;
9D0218F4  8FC20010   LW V0, 16(S8)
1033:                }
9D0218F8  03C0E821   ADDU SP, S8, ZERO
9D0218FC  8FBF0024   LW RA, 36(SP)
9D021900  8FBE0020   LW S8, 32(SP)
9D021904  27BD0028   ADDIU SP, SP, 40
9D021908  03E00008   JR RA
9D02190C  00000000   NOP
1034:                /*-----------------------------------------------------------*/
1035:                
1036:                signed portBASE_TYPE xQueueGenericReceive( xQueueHandle xQueue, const void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
1037:                {
9D021910  27BDFFC8   ADDIU SP, SP, -56
9D021914  AFBF0034   SW RA, 52(SP)
9D021918  AFBE0030   SW S8, 48(SP)
9D02191C  03A0F021   ADDU S8, SP, ZERO
9D021920  AFC40038   SW A0, 56(S8)
9D021924  AFC5003C   SW A1, 60(S8)
9D021928  AFC60040   SW A2, 64(S8)
9D02192C  AFC70044   SW A3, 68(S8)
1038:                signed portBASE_TYPE xEntryTimeSet = pdFALSE;
9D021930  AFC00010   SW ZERO, 16(S8)
1039:                xTimeOutType xTimeOut;
1040:                signed char *pcOriginalReadPosition;
1041:                xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;
9D021934  8FC20038   LW V0, 56(S8)
9D021938  AFC20014   SW V0, 20(S8)
1042:                
1043:                	configASSERT( pxQueue );
9D02193C  8FC20014   LW V0, 20(S8)
9D021940  14400006   BNE V0, ZERO, 0x9D02195C
9D021944  00000000   NOP
9D021948  3C029D03   LUI V0, -25341
9D02194C  244461EC   ADDIU A0, V0, 25068
9D021950  24050413   ADDIU A1, ZERO, 1043
9D021954  0F40C5F5   JAL vAssertCalled
9D021958  00000000   NOP
1044:                	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );
9D02195C  8FC2003C   LW V0, 60(S8)
9D021960  14400005   BNE V0, ZERO, 0x9D021978
9D021964  00000000   NOP
9D021968  8FC20014   LW V0, 20(S8)
9D02196C  8C420040   LW V0, 64(V0)
9D021970  14400004   BNE V0, ZERO, 0x9D021984
9D021974  00000000   NOP
9D021978  24020001   ADDIU V0, ZERO, 1
9D02197C  0B408662   J 0x9D021988
9D021980  00000000   NOP
9D021984  00001021   ADDU V0, ZERO, ZERO
9D021988  14400009   BNE V0, ZERO, 0x9D0219B0
9D02198C  00000000   NOP
9D021990  3C029D03   LUI V0, -25341
9D021994  244461EC   ADDIU A0, V0, 25068
9D021998  24050414   ADDIU A1, ZERO, 1044
9D02199C  0F40C5F5   JAL vAssertCalled
9D0219A0  00000000   NOP
9D0219A4  0B40866C   J 0x9D0219B0
9D0219A8  00000000   NOP
1045:                
1046:                	/* This function relaxes the coding standard somewhat to allow return
1047:                	statements within the function itself.  This is done in the interest
1048:                	of execution time efficiency. */
1049:                
1050:                	for( ;; )
1051:                	{
1052:                		taskENTER_CRITICAL();
9D0219B0  0F40834C   JAL vTaskEnterCritical
9D0219B4  00000000   NOP
1053:                		{
1054:                			/* Is there data in the queue now?  To be running we must be
1055:                			the highest priority task wanting to access the queue. */
1056:                			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
9D0219B8  8FC20014   LW V0, 20(S8)
9D0219BC  8C420038   LW V0, 56(V0)
9D0219C0  1040004B   BEQ V0, ZERO, 0x9D021AF0
9D0219C4  00000000   NOP
1057:                			{
1058:                				/* Remember the read position in case the queue is only being
1059:                				peeked. */
1060:                				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
9D0219C8  8FC20014   LW V0, 20(S8)
9D0219CC  8C42000C   LW V0, 12(V0)
9D0219D0  AFC20018   SW V0, 24(S8)
1061:                
1062:                				prvCopyDataFromQueue( pxQueue, pvBuffer );
9D0219D4  8FC40014   LW A0, 20(S8)
9D0219D8  8FC5003C   LW A1, 60(S8)
9D0219DC  0F4088BE   JAL 0x9D0222F8
9D0219E0  00000000   NOP
1063:                
1064:                				if( xJustPeeking == pdFALSE )
9D0219E4  8FC20044   LW V0, 68(S8)
9D0219E8  14400026   BNE V0, ZERO, 0x9D021A84
9D0219EC  00000000   NOP
1065:                				{
1066:                					traceQUEUE_RECEIVE( pxQueue );
1067:                
1068:                					/* Actually removing data, not just peeking. */
1069:                					--( pxQueue->uxMessagesWaiting );
9D0219F0  8FC20014   LW V0, 20(S8)
9D0219F4  8C420038   LW V0, 56(V0)
9D0219F8  2443FFFF   ADDIU V1, V0, -1
9D0219FC  8FC20014   LW V0, 20(S8)
9D021A00  AC430038   SW V1, 56(V0)
1070:                
1071:                					#if ( configUSE_MUTEXES == 1 )
1072:                					{
1073:                						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
9D021A04  8FC20014   LW V0, 20(S8)
9D021A08  8C420000   LW V0, 0(V0)
9D021A0C  14400006   BNE V0, ZERO, 0x9D021A28
9D021A10  00000000   NOP
1074:                						{
1075:                							/* Record the information required to implement
1076:                							priority inheritance should it become necessary. */
1077:                							pxQueue->pxMutexHolder = ( signed char * ) xTaskGetCurrentTaskHandle(); /*lint !e961 Cast is not redundant as xTaskHandle is a typedef. */
9D021A14  0F408277   JAL xTaskGetCurrentTaskHandle
9D021A18  00000000   NOP
9D021A1C  00401821   ADDU V1, V0, ZERO
9D021A20  8FC20014   LW V0, 20(S8)
9D021A24  AC430004   SW V1, 4(V0)
1078:                						}
1079:                					}
1080:                					#endif
1081:                
1082:                					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
9D021A28  8FC20014   LW V0, 20(S8)
9D021A2C  8C420010   LW V0, 16(V0)
9D021A30  1040002A   BEQ V0, ZERO, 0x9D021ADC
9D021A34  00000000   NOP
1083:                					{
1084:                						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
9D021A38  8FC20014   LW V0, 20(S8)
9D021A3C  24420010   ADDIU V0, V0, 16
9D021A40  00402021   ADDU A0, V0, ZERO
9D021A44  0F408077   JAL xTaskRemoveFromEventList
9D021A48  00000000   NOP
9D021A4C  00401821   ADDU V1, V0, ZERO
9D021A50  24020001   ADDIU V0, ZERO, 1
9D021A54  14620021   BNE V1, V0, 0x9D021ADC
9D021A58  00000000   NOP
1085:                						{
1086:                							portYIELD_WITHIN_API();
9D021A5C  40026800   MFC0 V0, Cause
9D021A60  AFC2001C   SW V0, 28(S8)
9D021A64  8FC2001C   LW V0, 28(S8)
9D021A68  34420100   ORI V0, V0, 256
9D021A6C  AFC2001C   SW V0, 28(S8)
9D021A70  8FC2001C   LW V0, 28(S8)
9D021A74  40826800   MTC0 V0, Cause
9D021A78  000000C0   EHB
9D021A7C  0B4086B7   J 0x9D021ADC
9D021A80  00000000   NOP
1087:                						}
1088:                					}
1089:                				}
1090:                				else
1091:                				{
1092:                					traceQUEUE_PEEK( pxQueue );
1093:                
1094:                					/* The data is not being removed, so reset the read
1095:                					pointer. */
1096:                					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
9D021A84  8FC20014   LW V0, 20(S8)
9D021A88  8FC30018   LW V1, 24(S8)
9D021A8C  AC43000C   SW V1, 12(V0)
1097:                
1098:                					/* The data is being left in the queue, so see if there are
1099:                					any other tasks waiting for the data. */
1100:                					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
9D021A90  8FC20014   LW V0, 20(S8)
9D021A94  8C420024   LW V0, 36(V0)
9D021A98  10400010   BEQ V0, ZERO, 0x9D021ADC
9D021A9C  00000000   NOP
1101:                					{
1102:                						/* Tasks that are removed from the event list will get added to
1103:                						the pending ready list as the scheduler is still suspended. */
1104:                						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
9D021AA0  8FC20014   LW V0, 20(S8)
9D021AA4  24420024   ADDIU V0, V0, 36
9D021AA8  00402021   ADDU A0, V0, ZERO
9D021AAC  0F408077   JAL xTaskRemoveFromEventList
9D021AB0  00000000   NOP
9D021AB4  10400009   BEQ V0, ZERO, 0x9D021ADC
9D021AB8  00000000   NOP
1105:                						{
1106:                							/* The task waiting has a higher priority than this task. */
1107:                							portYIELD_WITHIN_API();
9D021ABC  40026800   MFC0 V0, Cause
9D021AC0  AFC20020   SW V0, 32(S8)
9D021AC4  8FC20020   LW V0, 32(S8)
9D021AC8  34420100   ORI V0, V0, 256
9D021ACC  AFC20020   SW V0, 32(S8)
9D021AD0  8FC20020   LW V0, 32(S8)
9D021AD4  40826800   MTC0 V0, Cause
9D021AD8  000000C0   EHB
1108:                						}
1109:                					}
1110:                				}
1111:                
1112:                				taskEXIT_CRITICAL();
9D021ADC  0F40836C   JAL vTaskExitCritical
9D021AE0  00000000   NOP
1113:                				return pdPASS;
9D021AE4  24020001   ADDIU V0, ZERO, 1
9D021AE8  0B408722   J 0x9D021C88
9D021AEC  00000000   NOP
1114:                			}
1115:                			else
1116:                			{
1117:                				if( xTicksToWait == ( portTickType ) 0 )
9D021AF0  8FC20040   LW V0, 64(S8)
9D021AF4  14400006   BNE V0, ZERO, 0x9D021B10
9D021AF8  00000000   NOP
1118:                				{
1119:                					/* The queue was empty and no block time is specified (or
1120:                					the block time has expired) so leave now. */
1121:                					taskEXIT_CRITICAL();
9D021AFC  0F40836C   JAL vTaskExitCritical
9D021B00  00000000   NOP
1122:                					traceQUEUE_RECEIVE_FAILED( pxQueue );
1123:                					return errQUEUE_EMPTY;
9D021B04  00001021   ADDU V0, ZERO, ZERO
9D021B08  0B408722   J 0x9D021C88
9D021B0C  00000000   NOP
1124:                				}
1125:                				else if( xEntryTimeSet == pdFALSE )
9D021B10  8FC20010   LW V0, 16(S8)
9D021B14  14400007   BNE V0, ZERO, 0x9D021B34
9D021B18  00000000   NOP
1126:                				{
1127:                					/* The queue was empty and a block time was specified so
1128:                					configure the timeout structure. */
1129:                					vTaskSetTimeOutState( &xTimeOut );
9D021B1C  27C20028   ADDIU V0, S8, 40
9D021B20  00402021   ADDU A0, V0, ZERO
9D021B24  0F4080C7   JAL vTaskSetTimeOutState
9D021B28  00000000   NOP
1130:                					xEntryTimeSet = pdTRUE;
9D021B2C  24020001   ADDIU V0, ZERO, 1
9D021B30  AFC20010   SW V0, 16(S8)
1131:                				}
1132:                				else
1133:                				{
1134:                					/* Entry time was already set. */
1135:                				}
1136:                			}
1137:                		}
1138:                		taskEXIT_CRITICAL();
9D021B34  0F40836C   JAL vTaskExitCritical
9D021B38  00000000   NOP
1139:                
1140:                		/* Interrupts and other tasks can send to and receive from the queue
1141:                		now the critical section has been exited. */
1142:                
1143:                		vTaskSuspendAll();
9D021B3C  0F407E3F   JAL vTaskSuspendAll
9D021B40  00000000   NOP
1144:                		prvLockQueue( pxQueue );
9D021B44  0F40834C   JAL vTaskEnterCritical
9D021B48  00000000   NOP
9D021B4C  8FC20014   LW V0, 20(S8)
9D021B50  8C430044   LW V1, 68(V0)
9D021B54  2402FFFF   ADDIU V0, ZERO, -1
9D021B58  14620003   BNE V1, V0, 0x9D021B68
9D021B5C  00000000   NOP
9D021B60  8FC20014   LW V0, 20(S8)
9D021B64  AC400044   SW ZERO, 68(V0)
9D021B68  8FC20014   LW V0, 20(S8)
9D021B6C  8C430048   LW V1, 72(V0)
9D021B70  2402FFFF   ADDIU V0, ZERO, -1
9D021B74  14620003   BNE V1, V0, 0x9D021B84
9D021B78  00000000   NOP
9D021B7C  8FC20014   LW V0, 20(S8)
9D021B80  AC400048   SW ZERO, 72(V0)
9D021B84  0F40836C   JAL vTaskExitCritical
9D021B88  00000000   NOP
1145:                
1146:                		/* Update the timeout state to see if it has expired yet. */
1147:                		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
9D021B8C  27C30028   ADDIU V1, S8, 40
9D021B90  27C20040   ADDIU V0, S8, 64
9D021B94  00602021   ADDU A0, V1, ZERO
9D021B98  00402821   ADDU A1, V0, ZERO
9D021B9C  0F4080E0   JAL xTaskCheckForTimeOut
9D021BA0  00000000   NOP
9D021BA4  14400032   BNE V0, ZERO, 0x9D021C70
9D021BA8  00000000   NOP
1148:                		{
1149:                			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
9D021BAC  8FC40014   LW A0, 20(S8)
9D021BB0  0F408938   JAL 0x9D0224E0
9D021BB4  00000000   NOP
9D021BB8  10400026   BEQ V0, ZERO, 0x9D021C54
9D021BBC  00000000   NOP
1150:                			{
1151:                				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
1152:                
1153:                				#if ( configUSE_MUTEXES == 1 )
1154:                				{
1155:                					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
9D021BC0  8FC20014   LW V0, 20(S8)
9D021BC4  8C420000   LW V0, 0(V0)
9D021BC8  1440000A   BNE V0, ZERO, 0x9D021BF4
9D021BCC  00000000   NOP
1156:                					{
1157:                						portENTER_CRITICAL();
9D021BD0  0F40834C   JAL vTaskEnterCritical
9D021BD4  00000000   NOP
1158:                						{
1159:                							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
9D021BD8  8FC20014   LW V0, 20(S8)
9D021BDC  8C420004   LW V0, 4(V0)
9D021BE0  00402021   ADDU A0, V0, ZERO
9D021BE4  0F40829A   JAL vTaskPriorityInherit
9D021BE8  00000000   NOP
1160:                						}
1161:                						portEXIT_CRITICAL();
9D021BEC  0F40836C   JAL vTaskExitCritical
9D021BF0  00000000   NOP
1162:                					}
1163:                				}
1164:                				#endif
1165:                
1166:                				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
9D021BF4  8FC20014   LW V0, 20(S8)
9D021BF8  24430024   ADDIU V1, V0, 36
9D021BFC  8FC20040   LW V0, 64(S8)
9D021C00  00602021   ADDU A0, V1, ZERO
9D021C04  00402821   ADDU A1, V0, ZERO
9D021C08  0F40800A   JAL vTaskPlaceOnEventList
9D021C0C  00000000   NOP
1167:                				prvUnlockQueue( pxQueue );
9D021C10  8FC40014   LW A0, 20(S8)
9D021C14  0F4088E9   JAL 0x9D0223A4
9D021C18  00000000   NOP
1168:                				if( xTaskResumeAll() == pdFALSE )
9D021C1C  0F407E4A   JAL xTaskResumeAll
9D021C20  00000000   NOP
9D021C24  1440FF61   BNE V0, ZERO, 0x9D0219AC
9D021C28  00000000   NOP
1169:                				{
1170:                					portYIELD_WITHIN_API();
9D021C2C  40026800   MFC0 V0, Cause
9D021C30  AFC20024   SW V0, 36(S8)
9D021C34  8FC20024   LW V0, 36(S8)
9D021C38  34420100   ORI V0, V0, 256
9D021C3C  AFC20024   SW V0, 36(S8)
9D021C40  8FC20024   LW V0, 36(S8)
9D021C44  40826800   MTC0 V0, Cause
9D021C48  000000C0   EHB
1171:                				}
1172:                			}
1173:                			else
1174:                			{
1175:                				/* Try again. */
1176:                				prvUnlockQueue( pxQueue );
9D021C54  8FC40014   LW A0, 20(S8)
9D021C58  0F4088E9   JAL 0x9D0223A4
9D021C5C  00000000   NOP
1177:                				( void ) xTaskResumeAll();
9D021C60  0F407E4A   JAL xTaskResumeAll
9D021C64  00000000   NOP
1178:                			}
1179:                		}
1180:                		else
1181:                		{
1182:                			prvUnlockQueue( pxQueue );
9D021C70  8FC40014   LW A0, 20(S8)
9D021C74  0F4088E9   JAL 0x9D0223A4
9D021C78  00000000   NOP
1183:                			( void ) xTaskResumeAll();
9D021C7C  0F407E4A   JAL xTaskResumeAll
9D021C80  00000000   NOP
1184:                			traceQUEUE_RECEIVE_FAILED( pxQueue );
1185:                			return errQUEUE_EMPTY;
9D021C84  00001021   ADDU V0, ZERO, ZERO
1186:                		}
1187:                	}
9D0219AC  00000000   NOP
9D021C4C  0B40866C   J 0x9D0219B0
9D021C50  00000000   NOP
9D021C68  0B40866C   J 0x9D0219B0
9D021C6C  00000000   NOP
1188:                }
9D021C88  03C0E821   ADDU SP, S8, ZERO
9D021C8C  8FBF0034   LW RA, 52(SP)
9D021C90  8FBE0030   LW S8, 48(SP)
9D021C94  27BD0038   ADDIU SP, SP, 56
9D021C98  03E00008   JR RA
9D021C9C  00000000   NOP
1189:                /*-----------------------------------------------------------*/
1190:                
1191:                signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle xQueue, const void * const pvBuffer, signed portBASE_TYPE *pxHigherPriorityTaskWoken )
1192:                {
9D021CA0  27BDFFD8   ADDIU SP, SP, -40
9D021CA4  AFBF0024   SW RA, 36(SP)
9D021CA8  AFBE0020   SW S8, 32(SP)
9D021CAC  03A0F021   ADDU S8, SP, ZERO
9D021CB0  AFC40028   SW A0, 40(S8)
9D021CB4  AFC5002C   SW A1, 44(S8)
9D021CB8  AFC60030   SW A2, 48(S8)
1193:                signed portBASE_TYPE xReturn;
1194:                unsigned portBASE_TYPE uxSavedInterruptStatus;
1195:                xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;
9D021CBC  8FC20028   LW V0, 40(S8)
9D021CC0  AFC20014   SW V0, 20(S8)
1196:                
1197:                	configASSERT( pxQueue );
9D021CC4  8FC20014   LW V0, 20(S8)
9D021CC8  14400006   BNE V0, ZERO, 0x9D021CE4
9D021CCC  00000000   NOP
9D021CD0  3C029D03   LUI V0, -25341
9D021CD4  244461EC   ADDIU A0, V0, 25068
9D021CD8  240504AD   ADDIU A1, ZERO, 1197
9D021CDC  0F40C5F5   JAL vAssertCalled
9D021CE0  00000000   NOP
1198:                	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );
9D021CE4  8FC2002C   LW V0, 44(S8)
9D021CE8  14400005   BNE V0, ZERO, 0x9D021D00
9D021CEC  00000000   NOP
9D021CF0  8FC20014   LW V0, 20(S8)
9D021CF4  8C420040   LW V0, 64(V0)
9D021CF8  14400004   BNE V0, ZERO, 0x9D021D0C
9D021CFC  00000000   NOP
9D021D00  24020001   ADDIU V0, ZERO, 1
9D021D04  0B408744   J 0x9D021D10
9D021D08  00000000   NOP
9D021D0C  00001021   ADDU V0, ZERO, ZERO
9D021D10  14400006   BNE V0, ZERO, 0x9D021D2C
9D021D14  00000000   NOP
9D021D18  3C029D03   LUI V0, -25341
9D021D1C  244461EC   ADDIU A0, V0, 25068
9D021D20  240504AE   ADDIU A1, ZERO, 1198
9D021D24  0F40C5F5   JAL vAssertCalled
9D021D28  00000000   NOP
1199:                
1200:                	/* RTOS ports that support interrupt nesting have the concept of a maximum
1201:                	system call (or maximum API call) interrupt priority.  Interrupts that are
1202:                	above the maximum system call priority are keep permanently enabled, even
1203:                	when the RTOS kernel is in a critical section, but cannot make any calls to
1204:                	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
1205:                	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1206:                	failure if a FreeRTOS API function is called from an interrupt that has been
1207:                	assigned a priority above the configured maximum system call priority.
1208:                	Only FreeRTOS functions that end in FromISR can be called from interrupts
1209:                	that have been assigned a priority at or (logically) below the maximum
1210:                	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
1211:                	safe API to ensure interrupt entry is as fast and as simple as possible.
1212:                	More information (albeit Cortex-M specific) is provided on the following
1213:                	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1214:                	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
9D021D2C  40026000   MFC0 V0, Status
9D021D30  3042FC00   ANDI V0, V0, -1024
9D021D34  00021282   SRL V0, V0, 10
9D021D38  2C420004   SLTIU V0, V0, 4
9D021D3C  14400006   BNE V0, ZERO, 0x9D021D58
9D021D40  00000000   NOP
9D021D44  3C029D03   LUI V0, -25341
9D021D48  244461EC   ADDIU A0, V0, 25068
9D021D4C  240504BE   ADDIU A1, ZERO, 1214
9D021D50  0F40C5F5   JAL vAssertCalled
9D021D54  00000000   NOP
1215:                
1216:                	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
9D021D58  0F40CFD1   JAL uxPortSetInterruptMaskFromISR
9D021D5C  00000000   NOP
9D021D60  AFC20018   SW V0, 24(S8)
1217:                	{
1218:                		/* Cannot block in an ISR, so check there is data available. */
1219:                		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
9D021D64  8FC20014   LW V0, 20(S8)
9D021D68  8C420038   LW V0, 56(V0)
9D021D6C  1040002B   BEQ V0, ZERO, 0x9D021E1C
9D021D70  00000000   NOP
1220:                		{
1221:                			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );
1222:                
1223:                			prvCopyDataFromQueue( pxQueue, pvBuffer );
9D021D74  8FC40014   LW A0, 20(S8)
9D021D78  8FC5002C   LW A1, 44(S8)
9D021D7C  0F4088BE   JAL 0x9D0222F8
9D021D80  00000000   NOP
1224:                			--( pxQueue->uxMessagesWaiting );
9D021D84  8FC20014   LW V0, 20(S8)
9D021D88  8C420038   LW V0, 56(V0)
9D021D8C  2443FFFF   ADDIU V1, V0, -1
9D021D90  8FC20014   LW V0, 20(S8)
9D021D94  AC430038   SW V1, 56(V0)
1225:                
1226:                			/* If the queue is locked the event list will not be modified.
1227:                			Instead update the lock count so the task that unlocks the queue
1228:                			will know that an ISR has removed data while the queue was
1229:                			locked. */
1230:                			if( pxQueue->xRxLock == queueUNLOCKED )
9D021D98  8FC20014   LW V0, 20(S8)
9D021D9C  8C430044   LW V1, 68(V0)
9D021DA0  2402FFFF   ADDIU V0, ZERO, -1
9D021DA4  14620014   BNE V1, V0, 0x9D021DF8
9D021DA8  00000000   NOP
1231:                			{
1232:                				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
9D021DAC  8FC20014   LW V0, 20(S8)
9D021DB0  8C420010   LW V0, 16(V0)
9D021DB4  10400015   BEQ V0, ZERO, 0x9D021E0C
9D021DB8  00000000   NOP
1233:                				{
1234:                					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
9D021DBC  8FC20014   LW V0, 20(S8)
9D021DC0  24420010   ADDIU V0, V0, 16
9D021DC4  00402021   ADDU A0, V0, ZERO
9D021DC8  0F408077   JAL xTaskRemoveFromEventList
9D021DCC  00000000   NOP
9D021DD0  1040000E   BEQ V0, ZERO, 0x9D021E0C
9D021DD4  00000000   NOP
1235:                					{
1236:                						/* The task waiting has a higher priority than us so
1237:                						force a context switch. */
1238:                						if( pxHigherPriorityTaskWoken != NULL )
9D021DD8  8FC20030   LW V0, 48(S8)
9D021DDC  1040000B   BEQ V0, ZERO, 0x9D021E0C
9D021DE0  00000000   NOP
1239:                						{
1240:                							*pxHigherPriorityTaskWoken = pdTRUE;
9D021DE4  8FC20030   LW V0, 48(S8)
9D021DE8  24030001   ADDIU V1, ZERO, 1
9D021DEC  AC430000   SW V1, 0(V0)
9D021DF0  0B408783   J 0x9D021E0C
9D021DF4  00000000   NOP
1241:                						}
1242:                					}
1243:                				}
1244:                			}
1245:                			else
1246:                			{
1247:                				/* Increment the lock count so the task that unlocks the queue
1248:                				knows that data was removed while it was locked. */
1249:                				++( pxQueue->xRxLock );
9D021DF8  8FC20014   LW V0, 20(S8)
9D021DFC  8C420044   LW V0, 68(V0)
9D021E00  24430001   ADDIU V1, V0, 1
9D021E04  8FC20014   LW V0, 20(S8)
9D021E08  AC430044   SW V1, 68(V0)
1250:                			}
1251:                
1252:                			xReturn = pdPASS;
9D021E0C  24020001   ADDIU V0, ZERO, 1
9D021E10  AFC20010   SW V0, 16(S8)
9D021E14  0B408788   J 0x9D021E20
9D021E18  00000000   NOP
1253:                		}
1254:                		else
1255:                		{
1256:                			xReturn = pdFAIL;
9D021E1C  AFC00010   SW ZERO, 16(S8)
1257:                			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
1258:                		}
1259:                	}
1260:                	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
9D021E20  8FC40018   LW A0, 24(S8)
9D021E24  0F40CFE4   JAL vPortClearInterruptMaskFromISR
9D021E28  00000000   NOP
1261:                
1262:                	return xReturn;
9D021E2C  8FC20010   LW V0, 16(S8)
1263:                }
9D021E30  03C0E821   ADDU SP, S8, ZERO
9D021E34  8FBF0024   LW RA, 36(SP)
9D021E38  8FBE0020   LW S8, 32(SP)
9D021E3C  27BD0028   ADDIU SP, SP, 40
9D021E40  03E00008   JR RA
9D021E44  00000000   NOP
1264:                /*-----------------------------------------------------------*/
1265:                
1266:                signed portBASE_TYPE xQueuePeekFromISR( xQueueHandle xQueue, const void * const pvBuffer )
1267:                {
9D021E48  27BDFFD8   ADDIU SP, SP, -40
9D021E4C  AFBF0024   SW RA, 36(SP)
9D021E50  AFBE0020   SW S8, 32(SP)
9D021E54  03A0F021   ADDU S8, SP, ZERO
9D021E58  AFC40028   SW A0, 40(S8)
9D021E5C  AFC5002C   SW A1, 44(S8)
1268:                signed portBASE_TYPE xReturn;
1269:                unsigned portBASE_TYPE uxSavedInterruptStatus;
1270:                signed char *pcOriginalReadPosition;
1271:                xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;
9D021E60  8FC20028   LW V0, 40(S8)
9D021E64  AFC20014   SW V0, 20(S8)
1272:                
1273:                	configASSERT( pxQueue );
9D021E68  8FC20014   LW V0, 20(S8)
9D021E6C  14400006   BNE V0, ZERO, 0x9D021E88
9D021E70  00000000   NOP
9D021E74  3C029D03   LUI V0, -25341
9D021E78  244461EC   ADDIU A0, V0, 25068
9D021E7C  240504F9   ADDIU A1, ZERO, 1273
9D021E80  0F40C5F5   JAL vAssertCalled
9D021E84  00000000   NOP
1274:                	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );
9D021E88  8FC2002C   LW V0, 44(S8)
9D021E8C  14400005   BNE V0, ZERO, 0x9D021EA4
9D021E90  00000000   NOP
9D021E94  8FC20014   LW V0, 20(S8)
9D021E98  8C420040   LW V0, 64(V0)
9D021E9C  14400004   BNE V0, ZERO, 0x9D021EB0
9D021EA0  00000000   NOP
9D021EA4  24020001   ADDIU V0, ZERO, 1
9D021EA8  0B4087AD   J 0x9D021EB4
9D021EAC  00000000   NOP
9D021EB0  00001021   ADDU V0, ZERO, ZERO
9D021EB4  14400006   BNE V0, ZERO, 0x9D021ED0
9D021EB8  00000000   NOP
9D021EBC  3C029D03   LUI V0, -25341
9D021EC0  244461EC   ADDIU A0, V0, 25068
9D021EC4  240504FA   ADDIU A1, ZERO, 1274
9D021EC8  0F40C5F5   JAL vAssertCalled
9D021ECC  00000000   NOP
1275:                
1276:                	/* RTOS ports that support interrupt nesting have the concept of a maximum
1277:                	system call (or maximum API call) interrupt priority.  Interrupts that are
1278:                	above the maximum system call priority are keep permanently enabled, even
1279:                	when the RTOS kernel is in a critical section, but cannot make any calls to
1280:                	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
1281:                	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1282:                	failure if a FreeRTOS API function is called from an interrupt that has been
1283:                	assigned a priority above the configured maximum system call priority.
1284:                	Only FreeRTOS functions that end in FromISR can be called from interrupts
1285:                	that have been assigned a priority at or (logically) below the maximum
1286:                	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
1287:                	safe API to ensure interrupt entry is as fast and as simple as possible.
1288:                	More information (albeit Cortex-M specific) is provided on the following
1289:                	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1290:                	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
9D021ED0  40026000   MFC0 V0, Status
9D021ED4  3042FC00   ANDI V0, V0, -1024
9D021ED8  00021282   SRL V0, V0, 10
9D021EDC  2C420004   SLTIU V0, V0, 4
9D021EE0  14400006   BNE V0, ZERO, 0x9D021EFC
9D021EE4  00000000   NOP
9D021EE8  3C029D03   LUI V0, -25341
9D021EEC  244461EC   ADDIU A0, V0, 25068
9D021EF0  2405050A   ADDIU A1, ZERO, 1290
9D021EF4  0F40C5F5   JAL vAssertCalled
9D021EF8  00000000   NOP
1291:                
1292:                	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
9D021EFC  0F40CFD1   JAL uxPortSetInterruptMaskFromISR
9D021F00  00000000   NOP
9D021F04  AFC20018   SW V0, 24(S8)
1293:                	{
1294:                		/* Cannot block in an ISR, so check there is data available. */
1295:                		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
9D021F08  8FC20014   LW V0, 20(S8)
9D021F0C  8C420038   LW V0, 56(V0)
9D021F10  1040000F   BEQ V0, ZERO, 0x9D021F50
9D021F14  00000000   NOP
1296:                		{
1297:                			traceQUEUE_PEEK_FROM_ISR( pxQueue );
1298:                
1299:                			/* Remember the read position so it can be reset as nothing is
1300:                			actually being removed from the queue. */
1301:                			pcOriginalReadPosition = pxQueue->u.pcReadFrom;
9D021F18  8FC20014   LW V0, 20(S8)
9D021F1C  8C42000C   LW V0, 12(V0)
9D021F20  AFC2001C   SW V0, 28(S8)
1302:                			prvCopyDataFromQueue( pxQueue, pvBuffer );
9D021F24  8FC40014   LW A0, 20(S8)
9D021F28  8FC5002C   LW A1, 44(S8)
9D021F2C  0F4088BE   JAL 0x9D0222F8
9D021F30  00000000   NOP
1303:                			pxQueue->u.pcReadFrom = pcOriginalReadPosition;
9D021F34  8FC20014   LW V0, 20(S8)
9D021F38  8FC3001C   LW V1, 28(S8)
9D021F3C  AC43000C   SW V1, 12(V0)
1304:                
1305:                			xReturn = pdPASS;
9D021F40  24020001   ADDIU V0, ZERO, 1
9D021F44  AFC20010   SW V0, 16(S8)
9D021F48  0B4087D5   J 0x9D021F54
9D021F4C  00000000   NOP
1306:                		}
1307:                		else
1308:                		{
1309:                			xReturn = pdFAIL;
9D021F50  AFC00010   SW ZERO, 16(S8)
1310:                			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
1311:                		}
1312:                	}
1313:                	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
9D021F54  8FC40018   LW A0, 24(S8)
9D021F58  0F40CFE4   JAL vPortClearInterruptMaskFromISR
9D021F5C  00000000   NOP
1314:                
1315:                	return xReturn;
9D021F60  8FC20010   LW V0, 16(S8)
1316:                }
9D021F64  03C0E821   ADDU SP, S8, ZERO
9D021F68  8FBF0024   LW RA, 36(SP)
9D021F6C  8FBE0020   LW S8, 32(SP)
9D021F70  27BD0028   ADDIU SP, SP, 40
9D021F74  03E00008   JR RA
9D021F78  00000000   NOP
1317:                /*-----------------------------------------------------------*/
1318:                
1319:                unsigned portBASE_TYPE uxQueueMessagesWaiting( const xQueueHandle xQueue )
1320:                {
9D021F7C  27BDFFE0   ADDIU SP, SP, -32
9D021F80  AFBF001C   SW RA, 28(SP)
9D021F84  AFBE0018   SW S8, 24(SP)
9D021F88  03A0F021   ADDU S8, SP, ZERO
9D021F8C  AFC40020   SW A0, 32(S8)
1321:                unsigned portBASE_TYPE uxReturn;
1322:                
1323:                	configASSERT( xQueue );
9D021F90  8FC20020   LW V0, 32(S8)
9D021F94  14400006   BNE V0, ZERO, 0x9D021FB0
9D021F98  00000000   NOP
9D021F9C  3C029D03   LUI V0, -25341
9D021FA0  244461EC   ADDIU A0, V0, 25068
9D021FA4  2405052B   ADDIU A1, ZERO, 1323
9D021FA8  0F40C5F5   JAL vAssertCalled
9D021FAC  00000000   NOP
1324:                
1325:                	taskENTER_CRITICAL();
9D021FB0  0F40834C   JAL vTaskEnterCritical
9D021FB4  00000000   NOP
1326:                		uxReturn = ( ( xQUEUE * ) xQueue )->uxMessagesWaiting;
9D021FB8  8FC20020   LW V0, 32(S8)
9D021FBC  8C420038   LW V0, 56(V0)
9D021FC0  AFC20010   SW V0, 16(S8)
1327:                	taskEXIT_CRITICAL();
9D021FC4  0F40836C   JAL vTaskExitCritical
9D021FC8  00000000   NOP
1328:                
1329:                	return uxReturn;
9D021FCC  8FC20010   LW V0, 16(S8)
1330:                } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
9D021FD0  03C0E821   ADDU SP, S8, ZERO
9D021FD4  8FBF001C   LW RA, 28(SP)
9D021FD8  8FBE0018   LW S8, 24(SP)
9D021FDC  27BD0020   ADDIU SP, SP, 32
9D021FE0  03E00008   JR RA
9D021FE4  00000000   NOP
1331:                /*-----------------------------------------------------------*/
1332:                
1333:                unsigned portBASE_TYPE uxQueueSpacesAvailable( const xQueueHandle xQueue )
1334:                {
9D021FE8  27BDFFE0   ADDIU SP, SP, -32
9D021FEC  AFBF001C   SW RA, 28(SP)
9D021FF0  AFBE0018   SW S8, 24(SP)
9D021FF4  03A0F021   ADDU S8, SP, ZERO
9D021FF8  AFC40020   SW A0, 32(S8)
1335:                unsigned portBASE_TYPE uxReturn;
1336:                xQUEUE *pxQueue;
1337:                
1338:                	pxQueue = ( xQUEUE * ) xQueue;
9D021FFC  8FC20020   LW V0, 32(S8)
9D022000  AFC20010   SW V0, 16(S8)
1339:                	configASSERT( pxQueue );
9D022004  8FC20010   LW V0, 16(S8)
9D022008  14400006   BNE V0, ZERO, 0x9D022024
9D02200C  00000000   NOP
9D022010  3C029D03   LUI V0, -25341
9D022014  244461EC   ADDIU A0, V0, 25068
9D022018  2405053B   ADDIU A1, ZERO, 1339
9D02201C  0F40C5F5   JAL vAssertCalled
9D022020  00000000   NOP
1340:                
1341:                	taskENTER_CRITICAL();
9D022024  0F40834C   JAL vTaskEnterCritical
9D022028  00000000   NOP
1342:                		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
9D02202C  8FC20010   LW V0, 16(S8)
9D022030  8C43003C   LW V1, 60(V0)
9D022034  8FC20010   LW V0, 16(S8)
9D022038  8C420038   LW V0, 56(V0)
9D02203C  00621023   SUBU V0, V1, V0
9D022040  AFC20014   SW V0, 20(S8)
1343:                	taskEXIT_CRITICAL();
9D022044  0F40836C   JAL vTaskExitCritical
9D022048  00000000   NOP
1344:                
1345:                	return uxReturn;
9D02204C  8FC20014   LW V0, 20(S8)
1346:                } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
9D022050  03C0E821   ADDU SP, S8, ZERO
9D022054  8FBF001C   LW RA, 28(SP)
9D022058  8FBE0018   LW S8, 24(SP)
9D02205C  27BD0020   ADDIU SP, SP, 32
9D022060  03E00008   JR RA
9D022064  00000000   NOP
1347:                /*-----------------------------------------------------------*/
1348:                
1349:                unsigned portBASE_TYPE uxQueueMessagesWaitingFromISR( const xQueueHandle xQueue )
1350:                {
9D022068  27BDFFE0   ADDIU SP, SP, -32
9D02206C  AFBF001C   SW RA, 28(SP)
9D022070  AFBE0018   SW S8, 24(SP)
9D022074  03A0F021   ADDU S8, SP, ZERO
9D022078  AFC40020   SW A0, 32(S8)
1351:                unsigned portBASE_TYPE uxReturn;
1352:                
1353:                	configASSERT( xQueue );
9D02207C  8FC20020   LW V0, 32(S8)
9D022080  14400006   BNE V0, ZERO, 0x9D02209C
9D022084  00000000   NOP
9D022088  3C029D03   LUI V0, -25341
9D02208C  244461EC   ADDIU A0, V0, 25068
9D022090  24050549   ADDIU A1, ZERO, 1353
9D022094  0F40C5F5   JAL vAssertCalled
9D022098  00000000   NOP
1354:                
1355:                	uxReturn = ( ( xQUEUE * ) xQueue )->uxMessagesWaiting;
9D02209C  8FC20020   LW V0, 32(S8)
9D0220A0  8C420038   LW V0, 56(V0)
9D0220A4  AFC20010   SW V0, 16(S8)
1356:                
1357:                	return uxReturn;
9D0220A8  8FC20010   LW V0, 16(S8)
1358:                } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
9D0220AC  03C0E821   ADDU SP, S8, ZERO
9D0220B0  8FBF001C   LW RA, 28(SP)
9D0220B4  8FBE0018   LW S8, 24(SP)
9D0220B8  27BD0020   ADDIU SP, SP, 32
9D0220BC  03E00008   JR RA
9D0220C0  00000000   NOP
1359:                /*-----------------------------------------------------------*/
1360:                
1361:                void vQueueDelete( xQueueHandle xQueue )
1362:                {
9D0220C4  27BDFFE0   ADDIU SP, SP, -32
9D0220C8  AFBF001C   SW RA, 28(SP)
9D0220CC  AFBE0018   SW S8, 24(SP)
9D0220D0  03A0F021   ADDU S8, SP, ZERO
9D0220D4  AFC40020   SW A0, 32(S8)
1363:                xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;
9D0220D8  8FC20020   LW V0, 32(S8)
9D0220DC  AFC20010   SW V0, 16(S8)
1364:                
1365:                	configASSERT( pxQueue );
9D0220E0  8FC20010   LW V0, 16(S8)
9D0220E4  14400006   BNE V0, ZERO, 0x9D022100
9D0220E8  00000000   NOP
9D0220EC  3C029D03   LUI V0, -25341
9D0220F0  244461EC   ADDIU A0, V0, 25068
9D0220F4  24050555   ADDIU A1, ZERO, 1365
9D0220F8  0F40C5F5   JAL vAssertCalled
9D0220FC  00000000   NOP
1366:                
1367:                	traceQUEUE_DELETE( pxQueue );
1368:                	#if ( configQUEUE_REGISTRY_SIZE > 0 )
1369:                	{
1370:                		vQueueUnregisterQueue( pxQueue );
1371:                	}
1372:                	#endif
1373:                	vPortFree( pxQueue->pcHead );
9D022100  8FC20010   LW V0, 16(S8)
9D022104  8C420000   LW V0, 0(V0)
9D022108  00402021   ADDU A0, V0, ZERO
9D02210C  0F40D20E   JAL vPortFree
9D022110  00000000   NOP
1374:                	vPortFree( pxQueue );
9D022114  8FC40010   LW A0, 16(S8)
9D022118  0F40D20E   JAL vPortFree
9D02211C  00000000   NOP
1375:                }
9D022120  03C0E821   ADDU SP, S8, ZERO
9D022124  8FBF001C   LW RA, 28(SP)
9D022128  8FBE0018   LW S8, 24(SP)
9D02212C  27BD0020   ADDIU SP, SP, 32
9D022130  03E00008   JR RA
9D022134  00000000   NOP
1376:                /*-----------------------------------------------------------*/
1377:                
1378:                #if ( configUSE_TRACE_FACILITY == 1 )
1379:                
1380:                	unsigned char ucQueueGetQueueNumber( xQueueHandle xQueue )
1381:                	{
1382:                		return ( ( xQUEUE * ) xQueue )->ucQueueNumber;
1383:                	}
1384:                
1385:                #endif /* configUSE_TRACE_FACILITY */
1386:                /*-----------------------------------------------------------*/
1387:                
1388:                #if ( configUSE_TRACE_FACILITY == 1 )
1389:                
1390:                	void vQueueSetQueueNumber( xQueueHandle xQueue, unsigned char ucQueueNumber )
1391:                	{
1392:                		( ( xQUEUE * ) xQueue )->ucQueueNumber = ucQueueNumber;
1393:                	}
1394:                
1395:                #endif /* configUSE_TRACE_FACILITY */
1396:                /*-----------------------------------------------------------*/
1397:                
1398:                #if ( configUSE_TRACE_FACILITY == 1 )
1399:                
1400:                	unsigned char ucQueueGetQueueType( xQueueHandle xQueue )
1401:                	{
1402:                		return ( ( xQUEUE * ) xQueue )->ucQueueType;
1403:                	}
1404:                
1405:                #endif /* configUSE_TRACE_FACILITY */
1406:                /*-----------------------------------------------------------*/
1407:                
1408:                static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
1409:                {
9D022138  27BDFFE8   ADDIU SP, SP, -24
9D02213C  AFBF0014   SW RA, 20(SP)
9D022140  AFBE0010   SW S8, 16(SP)
9D022144  03A0F021   ADDU S8, SP, ZERO
9D022148  AFC40018   SW A0, 24(S8)
9D02214C  AFC5001C   SW A1, 28(S8)
9D022150  AFC60020   SW A2, 32(S8)
1410:                	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
9D022154  8FC20018   LW V0, 24(S8)
9D022158  8C420040   LW V0, 64(V0)
9D02215C  1440000E   BNE V0, ZERO, 0x9D022198
9D022160  00000000   NOP
1411:                	{
1412:                		#if ( configUSE_MUTEXES == 1 )
1413:                		{
1414:                			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
9D022164  8FC20018   LW V0, 24(S8)
9D022168  8C420000   LW V0, 0(V0)
9D02216C  14400057   BNE V0, ZERO, 0x9D0222CC
9D022170  00000000   NOP
1415:                			{
1416:                				/* The mutex is no longer being held. */
1417:                				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
9D022174  8FC20018   LW V0, 24(S8)
9D022178  8C420004   LW V0, 4(V0)
9D02217C  00402021   ADDU A0, V0, ZERO
9D022180  0F4082FF   JAL vTaskPriorityDisinherit
9D022184  00000000   NOP
1418:                				pxQueue->pxMutexHolder = NULL;
9D022188  8FC20018   LW V0, 24(S8)
9D02218C  AC400004   SW ZERO, 4(V0)
9D022190  0B4088B3   J 0x9D0222CC
9D022194  00000000   NOP
1419:                			}
1420:                		}
1421:                		#endif /* configUSE_MUTEXES */
1422:                	}
1423:                	else if( xPosition == queueSEND_TO_BACK )
9D022198  8FC20020   LW V0, 32(S8)
9D02219C  1440001E   BNE V0, ZERO, 0x9D022218
9D0221A0  00000000   NOP
1424:                	{
1425:                		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
9D0221A4  8FC20018   LW V0, 24(S8)
9D0221A8  8C430008   LW V1, 8(V0)
9D0221AC  8FC20018   LW V0, 24(S8)
9D0221B0  8C420040   LW V0, 64(V0)
9D0221B4  00602021   ADDU A0, V1, ZERO
9D0221B8  8FC5001C   LW A1, 28(S8)
9D0221BC  00403021   ADDU A2, V0, ZERO
9D0221C0  0F40D298   JAL 0x9D034A60
9D0221C4  00000000   NOP
1426:                		pxQueue->pcWriteTo += pxQueue->uxItemSize;
9D0221C8  8FC20018   LW V0, 24(S8)
9D0221CC  8C430008   LW V1, 8(V0)
9D0221D0  8FC20018   LW V0, 24(S8)
9D0221D4  8C420040   LW V0, 64(V0)
9D0221D8  00621821   ADDU V1, V1, V0
9D0221DC  8FC20018   LW V0, 24(S8)
9D0221E0  AC430008   SW V1, 8(V0)
1427:                		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
9D0221E4  8FC20018   LW V0, 24(S8)
9D0221E8  8C430008   LW V1, 8(V0)
9D0221EC  8FC20018   LW V0, 24(S8)
9D0221F0  8C420004   LW V0, 4(V0)
9D0221F4  0062102B   SLTU V0, V1, V0
9D0221F8  14400034   BNE V0, ZERO, 0x9D0222CC
9D0221FC  00000000   NOP
1428:                		{
1429:                			pxQueue->pcWriteTo = pxQueue->pcHead;
9D022200  8FC20018   LW V0, 24(S8)
9D022204  8C430000   LW V1, 0(V0)
9D022208  8FC20018   LW V0, 24(S8)
9D02220C  AC430008   SW V1, 8(V0)
9D022210  0B4088B3   J 0x9D0222CC
9D022214  00000000   NOP
1430:                		}
1431:                	}
1432:                	else
1433:                	{
1434:                		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
9D022218  8FC20018   LW V0, 24(S8)
9D02221C  8C43000C   LW V1, 12(V0)
9D022220  8FC20018   LW V0, 24(S8)
9D022224  8C420040   LW V0, 64(V0)
9D022228  00602021   ADDU A0, V1, ZERO
9D02222C  8FC5001C   LW A1, 28(S8)
9D022230  00403021   ADDU A2, V0, ZERO
9D022234  0F40D298   JAL 0x9D034A60
9D022238  00000000   NOP
1435:                		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
9D02223C  8FC20018   LW V0, 24(S8)
9D022240  8C43000C   LW V1, 12(V0)
9D022244  8FC20018   LW V0, 24(S8)
9D022248  8C420040   LW V0, 64(V0)
9D02224C  00021023   SUBU V0, ZERO, V0
9D022250  00621821   ADDU V1, V1, V0
9D022254  8FC20018   LW V0, 24(S8)
9D022258  AC43000C   SW V1, 12(V0)
1436:                		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
9D02225C  8FC20018   LW V0, 24(S8)
9D022260  8C43000C   LW V1, 12(V0)
9D022264  8FC20018   LW V0, 24(S8)
9D022268  8C420000   LW V0, 0(V0)
9D02226C  0062102B   SLTU V0, V1, V0
9D022270  10400009   BEQ V0, ZERO, 0x9D022298
9D022274  00000000   NOP
1437:                		{
1438:                			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
9D022278  8FC20018   LW V0, 24(S8)
9D02227C  8C430004   LW V1, 4(V0)
9D022280  8FC20018   LW V0, 24(S8)
9D022284  8C420040   LW V0, 64(V0)
9D022288  00021023   SUBU V0, ZERO, V0
9D02228C  00621821   ADDU V1, V1, V0
9D022290  8FC20018   LW V0, 24(S8)
9D022294  AC43000C   SW V1, 12(V0)
1439:                		}
1440:                
1441:                		if( xPosition == queueOVERWRITE )
9D022298  8FC30020   LW V1, 32(S8)
9D02229C  24020002   ADDIU V0, ZERO, 2
9D0222A0  1462000A   BNE V1, V0, 0x9D0222CC
9D0222A4  00000000   NOP
1442:                		{
1443:                			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
9D0222A8  8FC20018   LW V0, 24(S8)
9D0222AC  8C420038   LW V0, 56(V0)
9D0222B0  10400006   BEQ V0, ZERO, 0x9D0222CC
9D0222B4  00000000   NOP
1444:                			{
1445:                				/* An item is not being added but overwritten, so subtract
1446:                				one from the recorded number of items in the queue so when
1447:                				one is added again below the number of recorded items remains
1448:                				correct. */
1449:                				--( pxQueue->uxMessagesWaiting );
9D0222B8  8FC20018   LW V0, 24(S8)
9D0222BC  8C420038   LW V0, 56(V0)
9D0222C0  2443FFFF   ADDIU V1, V0, -1
9D0222C4  8FC20018   LW V0, 24(S8)
9D0222C8  AC430038   SW V1, 56(V0)
1450:                			}
1451:                		}
1452:                	}
1453:                
1454:                	++( pxQueue->uxMessagesWaiting );
9D0222CC  8FC20018   LW V0, 24(S8)
9D0222D0  8C420038   LW V0, 56(V0)
9D0222D4  24430001   ADDIU V1, V0, 1
9D0222D8  8FC20018   LW V0, 24(S8)
9D0222DC  AC430038   SW V1, 56(V0)
1455:                }
9D0222E0  03C0E821   ADDU SP, S8, ZERO
9D0222E4  8FBF0014   LW RA, 20(SP)
9D0222E8  8FBE0010   LW S8, 16(SP)
9D0222EC  27BD0018   ADDIU SP, SP, 24
9D0222F0  03E00008   JR RA
9D0222F4  00000000   NOP
1456:                /*-----------------------------------------------------------*/
1457:                
1458:                static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void * const pvBuffer )
1459:                {
9D0222F8  27BDFFE8   ADDIU SP, SP, -24
9D0222FC  AFBF0014   SW RA, 20(SP)
9D022300  AFBE0010   SW S8, 16(SP)
9D022304  03A0F021   ADDU S8, SP, ZERO
9D022308  AFC40018   SW A0, 24(S8)
9D02230C  AFC5001C   SW A1, 28(S8)
1460:                	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
9D022310  8FC20018   LW V0, 24(S8)
9D022314  8C420000   LW V0, 0(V0)
9D022318  1040001C   BEQ V0, ZERO, 0x9D02238C
9D02231C  00000000   NOP
1461:                	{
1462:                		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
9D022320  8FC20018   LW V0, 24(S8)
9D022324  8C43000C   LW V1, 12(V0)
9D022328  8FC20018   LW V0, 24(S8)
9D02232C  8C420040   LW V0, 64(V0)
9D022330  00621821   ADDU V1, V1, V0
9D022334  8FC20018   LW V0, 24(S8)
9D022338  AC43000C   SW V1, 12(V0)
1463:                		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
9D02233C  8FC20018   LW V0, 24(S8)
9D022340  8C43000C   LW V1, 12(V0)
9D022344  8FC20018   LW V0, 24(S8)
9D022348  8C420004   LW V0, 4(V0)
9D02234C  0062102B   SLTU V0, V1, V0
9D022350  14400005   BNE V0, ZERO, 0x9D022368
9D022354  00000000   NOP
1464:                		{
1465:                			pxQueue->u.pcReadFrom = pxQueue->pcHead;
9D022358  8FC20018   LW V0, 24(S8)
9D02235C  8C430000   LW V1, 0(V0)
9D022360  8FC20018   LW V0, 24(S8)
9D022364  AC43000C   SW V1, 12(V0)
1466:                		}
1467:                		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
9D022368  8FC20018   LW V0, 24(S8)
9D02236C  8C43000C   LW V1, 12(V0)
9D022370  8FC20018   LW V0, 24(S8)
9D022374  8C420040   LW V0, 64(V0)
9D022378  8FC4001C   LW A0, 28(S8)
9D02237C  00602821   ADDU A1, V1, ZERO
9D022380  00403021   ADDU A2, V0, ZERO
9D022384  0F40D298   JAL 0x9D034A60
9D022388  00000000   NOP
1468:                	}
1469:                }
9D02238C  03C0E821   ADDU SP, S8, ZERO
9D022390  8FBF0014   LW RA, 20(SP)
9D022394  8FBE0010   LW S8, 16(SP)
9D022398  27BD0018   ADDIU SP, SP, 24
9D02239C  03E00008   JR RA
9D0223A0  00000000   NOP
1470:                /*-----------------------------------------------------------*/
1471:                
1472:                static void prvUnlockQueue( xQUEUE *pxQueue )
1473:                {
9D0223A4  27BDFFE8   ADDIU SP, SP, -24
9D0223A8  AFBF0014   SW RA, 20(SP)
9D0223AC  AFBE0010   SW S8, 16(SP)
9D0223B0  03A0F021   ADDU S8, SP, ZERO
9D0223B4  AFC40018   SW A0, 24(S8)
1474:                	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED. */
1475:                
1476:                	/* The lock counts contains the number of extra data items placed or
1477:                	removed from the queue while the queue was locked.  When a queue is
1478:                	locked items can be added or removed, but the event lists cannot be
1479:                	updated. */
1480:                	taskENTER_CRITICAL();
9D0223B8  0F40834C   JAL vTaskEnterCritical
9D0223BC  00000000   NOP
1481:                	{
1482:                		/* See if data was added to the queue while it was locked. */
1483:                		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
9D0223C0  0B408904   J 0x9D022410
9D0223C4  00000000   NOP
9D022410  8FC20018   LW V0, 24(S8)
9D022414  8C420048   LW V0, 72(V0)
9D022418  1C40FFEB   BGTZ V0, 0x9D0223C8
9D02241C  00000000   NOP
9D022420  0B40890B   J 0x9D02242C
9D022424  00000000   NOP
1484:                		{
1485:                			/* Data was posted while the queue was locked.  Are any tasks
1486:                			blocked waiting for data to become available? */
1487:                			#if ( configUSE_QUEUE_SETS == 1 )
1488:                			{
1489:                				if( pxQueue->pxQueueSetContainer != NULL )
1490:                				{
1491:                					if( prvNotifyQueueSetContainer( pxQueue, queueSEND_TO_BACK ) == pdTRUE )
1492:                					{
1493:                						/* The queue is a member of a queue set, and posting to
1494:                						the queue set caused a higher priority task to unblock.
1495:                						A context switch is required. */
1496:                						vTaskMissedYield();
1497:                					}
1498:                				}
1499:                				else
1500:                				{
1501:                					/* Tasks that are removed from the event list will get added to
1502:                					the pending ready list as the scheduler is still suspended. */
1503:                					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
1504:                					{
1505:                						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
1506:                						{
1507:                							/* The task waiting has a higher priority so record that a
1508:                							context	switch is required. */
1509:                							vTaskMissedYield();
1510:                						}
1511:                					}
1512:                					else
1513:                					{
1514:                						break;
1515:                					}
1516:                				}
1517:                			}
1518:                			#else /* configUSE_QUEUE_SETS */
1519:                			{
1520:                				/* Tasks that are removed from the event list will get added to
1521:                				the pending ready list as the scheduler is still suspended. */
1522:                				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
9D0223C8  8FC20018   LW V0, 24(S8)
9D0223CC  8C420024   LW V0, 36(V0)
9D0223D0  10400015   BEQ V0, ZERO, 0x9D022428
9D0223D4  00000000   NOP
1523:                				{
1524:                					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
9D0223D8  8FC20018   LW V0, 24(S8)
9D0223DC  24420024   ADDIU V0, V0, 36
9D0223E0  00402021   ADDU A0, V0, ZERO
9D0223E4  0F408077   JAL xTaskRemoveFromEventList
9D0223E8  00000000   NOP
9D0223EC  10400003   BEQ V0, ZERO, 0x9D0223FC
9D0223F0  00000000   NOP
1525:                					{
1526:                						/* The task waiting has a higher priority so record that a
1527:                						context	switch is required. */
1528:                						vTaskMissedYield();
9D0223F4  0F408134   JAL vTaskMissedYield
9D0223F8  00000000   NOP
1529:                					}
1530:                				}
1531:                				else
1532:                				{
1533:                					break;
9D022428  00000000   NOP
1534:                				}
1535:                			}
1536:                			#endif /* configUSE_QUEUE_SETS */
1537:                
1538:                			--( pxQueue->xTxLock );
9D0223FC  8FC20018   LW V0, 24(S8)
9D022400  8C420048   LW V0, 72(V0)
9D022404  2443FFFF   ADDIU V1, V0, -1
9D022408  8FC20018   LW V0, 24(S8)
9D02240C  AC430048   SW V1, 72(V0)
1539:                		}
1540:                
1541:                		pxQueue->xTxLock = queueUNLOCKED;
9D02242C  8FC20018   LW V0, 24(S8)
9D022430  2403FFFF   ADDIU V1, ZERO, -1
9D022434  AC430048   SW V1, 72(V0)
1542:                	}
1543:                	taskEXIT_CRITICAL();
9D022438  0F40836C   JAL vTaskExitCritical
9D02243C  00000000   NOP
1544:                
1545:                	/* Do the same for the Rx lock. */
1546:                	taskENTER_CRITICAL();
9D022440  0F40834C   JAL vTaskEnterCritical
9D022444  00000000   NOP
1547:                	{
1548:                		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
9D022448  0B408926   J 0x9D022498
9D02244C  00000000   NOP
9D022498  8FC20018   LW V0, 24(S8)
9D02249C  8C420044   LW V0, 68(V0)
9D0224A0  1C40FFEB   BGTZ V0, 0x9D022450
9D0224A4  00000000   NOP
9D0224A8  0B40892D   J 0x9D0224B4
9D0224AC  00000000   NOP
1549:                		{
1550:                			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
9D022450  8FC20018   LW V0, 24(S8)
9D022454  8C420010   LW V0, 16(V0)
9D022458  10400015   BEQ V0, ZERO, 0x9D0224B0
9D02245C  00000000   NOP
1551:                			{
1552:                				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
9D022460  8FC20018   LW V0, 24(S8)
9D022464  24420010   ADDIU V0, V0, 16
9D022468  00402021   ADDU A0, V0, ZERO
9D02246C  0F408077   JAL xTaskRemoveFromEventList
9D022470  00000000   NOP
9D022474  10400003   BEQ V0, ZERO, 0x9D022484
9D022478  00000000   NOP
1553:                				{
1554:                					vTaskMissedYield();
9D02247C  0F408134   JAL vTaskMissedYield
9D022480  00000000   NOP
1555:                				}
1556:                
1557:                				--( pxQueue->xRxLock );
9D022484  8FC20018   LW V0, 24(S8)
9D022488  8C420044   LW V0, 68(V0)
9D02248C  2443FFFF   ADDIU V1, V0, -1
9D022490  8FC20018   LW V0, 24(S8)
9D022494  AC430044   SW V1, 68(V0)
1558:                			}
1559:                			else
1560:                			{
1561:                				break;
9D0224B0  00000000   NOP
1562:                			}
1563:                		}
1564:                
1565:                		pxQueue->xRxLock = queueUNLOCKED;
9D0224B4  8FC20018   LW V0, 24(S8)
9D0224B8  2403FFFF   ADDIU V1, ZERO, -1
9D0224BC  AC430044   SW V1, 68(V0)
1566:                	}
1567:                	taskEXIT_CRITICAL();
9D0224C0  0F40836C   JAL vTaskExitCritical
9D0224C4  00000000   NOP
1568:                }
9D0224C8  03C0E821   ADDU SP, S8, ZERO
9D0224CC  8FBF0014   LW RA, 20(SP)
9D0224D0  8FBE0010   LW S8, 16(SP)
9D0224D4  27BD0018   ADDIU SP, SP, 24
9D0224D8  03E00008   JR RA
9D0224DC  00000000   NOP
1569:                /*-----------------------------------------------------------*/
1570:                
1571:                static signed portBASE_TYPE prvIsQueueEmpty( const xQUEUE *pxQueue )
1572:                {
9D0224E0  27BDFFE0   ADDIU SP, SP, -32
9D0224E4  AFBF001C   SW RA, 28(SP)
9D0224E8  AFBE0018   SW S8, 24(SP)
9D0224EC  03A0F021   ADDU S8, SP, ZERO
9D0224F0  AFC40020   SW A0, 32(S8)
1573:                signed portBASE_TYPE xReturn;
1574:                
1575:                	taskENTER_CRITICAL();
9D0224F4  0F40834C   JAL vTaskEnterCritical
9D0224F8  00000000   NOP
1576:                	{
1577:                		if( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE )  0 )
9D0224FC  8FC20020   LW V0, 32(S8)
9D022500  8C420038   LW V0, 56(V0)
9D022504  14400005   BNE V0, ZERO, 0x9D02251C
9D022508  00000000   NOP
1578:                		{
1579:                			xReturn = pdTRUE;
9D02250C  24020001   ADDIU V0, ZERO, 1
9D022510  AFC20010   SW V0, 16(S8)
9D022514  0B408948   J 0x9D022520
9D022518  00000000   NOP
1580:                		}
1581:                		else
1582:                		{
1583:                			xReturn = pdFALSE;
9D02251C  AFC00010   SW ZERO, 16(S8)
1584:                		}
1585:                	}
1586:                	taskEXIT_CRITICAL();
9D022520  0F40836C   JAL vTaskExitCritical
9D022524  00000000   NOP
1587:                
1588:                	return xReturn;
9D022528  8FC20010   LW V0, 16(S8)
1589:                }
9D02252C  03C0E821   ADDU SP, S8, ZERO
9D022530  8FBF001C   LW RA, 28(SP)
9D022534  8FBE0018   LW S8, 24(SP)
9D022538  27BD0020   ADDIU SP, SP, 32
9D02253C  03E00008   JR RA
9D022540  00000000   NOP
1590:                /*-----------------------------------------------------------*/
1591:                
1592:                signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle xQueue )
1593:                {
9D022544  27BDFFE0   ADDIU SP, SP, -32
9D022548  AFBF001C   SW RA, 28(SP)
9D02254C  AFBE0018   SW S8, 24(SP)
9D022550  03A0F021   ADDU S8, SP, ZERO
9D022554  AFC40020   SW A0, 32(S8)
1594:                signed portBASE_TYPE xReturn;
1595:                
1596:                	configASSERT( xQueue );
9D022558  8FC20020   LW V0, 32(S8)
9D02255C  14400006   BNE V0, ZERO, 0x9D022578
9D022560  00000000   NOP
9D022564  3C029D03   LUI V0, -25341
9D022568  244461EC   ADDIU A0, V0, 25068
9D02256C  2405063C   ADDIU A1, ZERO, 1596
9D022570  0F40C5F5   JAL vAssertCalled
9D022574  00000000   NOP
1597:                	if( ( ( xQUEUE * ) xQueue )->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 )
9D022578  8FC20020   LW V0, 32(S8)
9D02257C  8C420038   LW V0, 56(V0)
9D022580  14400005   BNE V0, ZERO, 0x9D022598
9D022584  00000000   NOP
1598:                	{
1599:                		xReturn = pdTRUE;
9D022588  24020001   ADDIU V0, ZERO, 1
9D02258C  AFC20010   SW V0, 16(S8)
9D022590  0B408967   J 0x9D02259C
9D022594  00000000   NOP
1600:                	}
1601:                	else
1602:                	{
1603:                		xReturn = pdFALSE;
9D022598  AFC00010   SW ZERO, 16(S8)
1604:                	}
1605:                
1606:                	return xReturn;
9D02259C  8FC20010   LW V0, 16(S8)
1607:                } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
9D0225A0  03C0E821   ADDU SP, S8, ZERO
9D0225A4  8FBF001C   LW RA, 28(SP)
9D0225A8  8FBE0018   LW S8, 24(SP)
9D0225AC  27BD0020   ADDIU SP, SP, 32
9D0225B0  03E00008   JR RA
9D0225B4  00000000   NOP
1608:                /*-----------------------------------------------------------*/
1609:                
1610:                static signed portBASE_TYPE prvIsQueueFull( const xQUEUE *pxQueue )
1611:                {
9D0225B8  27BDFFE0   ADDIU SP, SP, -32
9D0225BC  AFBF001C   SW RA, 28(SP)
9D0225C0  AFBE0018   SW S8, 24(SP)
9D0225C4  03A0F021   ADDU S8, SP, ZERO
9D0225C8  AFC40020   SW A0, 32(S8)
1612:                signed portBASE_TYPE xReturn;
1613:                
1614:                	taskENTER_CRITICAL();
9D0225CC  0F40834C   JAL vTaskEnterCritical
9D0225D0  00000000   NOP
1615:                	{
1616:                		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
9D0225D4  8FC20020   LW V0, 32(S8)
9D0225D8  8C430038   LW V1, 56(V0)
9D0225DC  8FC20020   LW V0, 32(S8)
9D0225E0  8C42003C   LW V0, 60(V0)
9D0225E4  14620005   BNE V1, V0, 0x9D0225FC
9D0225E8  00000000   NOP
1617:                		{
1618:                			xReturn = pdTRUE;
9D0225EC  24020001   ADDIU V0, ZERO, 1
9D0225F0  AFC20010   SW V0, 16(S8)
9D0225F4  0B408980   J 0x9D022600
9D0225F8  00000000   NOP
1619:                		}
1620:                		else
1621:                		{
1622:                			xReturn = pdFALSE;
9D0225FC  AFC00010   SW ZERO, 16(S8)
1623:                		}
1624:                	}
1625:                	taskEXIT_CRITICAL();
9D022600  0F40836C   JAL vTaskExitCritical
9D022604  00000000   NOP
1626:                
1627:                	return xReturn;
9D022608  8FC20010   LW V0, 16(S8)
1628:                }
9D02260C  03C0E821   ADDU SP, S8, ZERO
9D022610  8FBF001C   LW RA, 28(SP)
9D022614  8FBE0018   LW S8, 24(SP)
9D022618  27BD0020   ADDIU SP, SP, 32
9D02261C  03E00008   JR RA
9D022620  00000000   NOP
1629:                /*-----------------------------------------------------------*/
1630:                
1631:                signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle xQueue )
1632:                {
9D022624  27BDFFE0   ADDIU SP, SP, -32
9D022628  AFBF001C   SW RA, 28(SP)
9D02262C  AFBE0018   SW S8, 24(SP)
9D022630  03A0F021   ADDU S8, SP, ZERO
9D022634  AFC40020   SW A0, 32(S8)
1633:                signed portBASE_TYPE xReturn;
1634:                
1635:                	configASSERT( xQueue );
9D022638  8FC20020   LW V0, 32(S8)
9D02263C  14400006   BNE V0, ZERO, 0x9D022658
9D022640  00000000   NOP
9D022644  3C029D03   LUI V0, -25341
9D022648  244461EC   ADDIU A0, V0, 25068
9D02264C  24050663   ADDIU A1, ZERO, 1635
9D022650  0F40C5F5   JAL vAssertCalled
9D022654  00000000   NOP
1636:                	if( ( ( xQUEUE * ) xQueue )->uxMessagesWaiting == ( ( xQUEUE * ) xQueue )->uxLength )
9D022658  8FC20020   LW V0, 32(S8)
9D02265C  8C430038   LW V1, 56(V0)
9D022660  8FC20020   LW V0, 32(S8)
9D022664  8C42003C   LW V0, 60(V0)
9D022668  14620005   BNE V1, V0, 0x9D022680
9D02266C  00000000   NOP
1637:                	{
1638:                		xReturn = pdTRUE;
9D022670  24020001   ADDIU V0, ZERO, 1
9D022674  AFC20010   SW V0, 16(S8)
9D022678  0B4089A1   J 0x9D022684
9D02267C  00000000   NOP
1639:                	}
1640:                	else
1641:                	{
1642:                		xReturn = pdFALSE;
9D022680  AFC00010   SW ZERO, 16(S8)
1643:                	}
1644:                
1645:                	return xReturn;
9D022684  8FC20010   LW V0, 16(S8)
1646:                } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
9D022688  03C0E821   ADDU SP, S8, ZERO
9D02268C  8FBF001C   LW RA, 28(SP)
9D022690  8FBE0018   LW S8, 24(SP)
9D022694  27BD0020   ADDIU SP, SP, 32
9D022698  03E00008   JR RA
9D02269C  00000000   NOP
1647:                /*-----------------------------------------------------------*/
1648:                
1649:                #if ( configUSE_CO_ROUTINES == 1 )
1650:                
1651:                	signed portBASE_TYPE xQueueCRSend( xQueueHandle xQueue, const void *pvItemToQueue, portTickType xTicksToWait )
1652:                	{
1653:                	signed portBASE_TYPE xReturn;
1654:                	xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;
1655:                
1656:                		/* If the queue is already full we may have to block.  A critical section
1657:                		is required to prevent an interrupt removing something from the queue
1658:                		between the check to see if the queue is full and blocking on the queue. */
1659:                		portDISABLE_INTERRUPTS();
1660:                		{
1661:                			if( prvIsQueueFull( pxQueue ) != pdFALSE )
1662:                			{
1663:                				/* The queue is full - do we want to block or just leave without
1664:                				posting? */
1665:                				if( xTicksToWait > ( portTickType ) 0 )
1666:                				{
1667:                					/* As this is called from a coroutine we cannot block directly, but
1668:                					return indicating that we need to block. */
1669:                					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToSend ) );
1670:                					portENABLE_INTERRUPTS();
1671:                					return errQUEUE_BLOCKED;
1672:                				}
1673:                				else
1674:                				{
1675:                					portENABLE_INTERRUPTS();
1676:                					return errQUEUE_FULL;
1677:                				}
1678:                			}
1679:                		}
1680:                		portENABLE_INTERRUPTS();
1681:                
1682:                		portDISABLE_INTERRUPTS();
1683:                		{
1684:                			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
1685:                			{
1686:                				/* There is room in the queue, copy the data into the queue. */
1687:                				prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
1688:                				xReturn = pdPASS;
1689:                
1690:                				/* Were any co-routines waiting for data to become available? */
1691:                				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
1692:                				{
1693:                					/* In this instance the co-routine could be placed directly
1694:                					into the ready list as we are within a critical section.
1695:                					Instead the same pending ready list mechanism is used as if
1696:                					the event were caused from within an interrupt. */
1697:                					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
1698:                					{
1699:                						/* The co-routine waiting has a higher priority so record
1700:                						that a yield might be appropriate. */
1701:                						xReturn = errQUEUE_YIELD;
1702:                					}
1703:                				}
1704:                			}
1705:                			else
1706:                			{
1707:                				xReturn = errQUEUE_FULL;
1708:                			}
1709:                		}
1710:                		portENABLE_INTERRUPTS();
1711:                
1712:                		return xReturn;
1713:                	}
1714:                
1715:                #endif /* configUSE_CO_ROUTINES */
1716:                /*-----------------------------------------------------------*/
1717:                
1718:                #if ( configUSE_CO_ROUTINES == 1 )
1719:                
1720:                	signed portBASE_TYPE xQueueCRReceive( xQueueHandle xQueue, void *pvBuffer, portTickType xTicksToWait )
1721:                	{
1722:                	signed portBASE_TYPE xReturn;
1723:                	xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;
1724:                
1725:                		/* If the queue is already empty we may have to block.  A critical section
1726:                		is required to prevent an interrupt adding something to the queue
1727:                		between the check to see if the queue is empty and blocking on the queue. */
1728:                		portDISABLE_INTERRUPTS();
1729:                		{
1730:                			if( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 )
1731:                			{
1732:                				/* There are no messages in the queue, do we want to block or just
1733:                				leave with nothing? */
1734:                				if( xTicksToWait > ( portTickType ) 0 )
1735:                				{
1736:                					/* As this is a co-routine we cannot block directly, but return
1737:                					indicating that we need to block. */
1738:                					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToReceive ) );
1739:                					portENABLE_INTERRUPTS();
1740:                					return errQUEUE_BLOCKED;
1741:                				}
1742:                				else
1743:                				{
1744:                					portENABLE_INTERRUPTS();
1745:                					return errQUEUE_FULL;
1746:                				}
1747:                			}
1748:                		}
1749:                		portENABLE_INTERRUPTS();
1750:                
1751:                		portDISABLE_INTERRUPTS();
1752:                		{
1753:                			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
1754:                			{
1755:                				/* Data is available from the queue. */
1756:                				pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
1757:                				if( pxQueue->u.pcReadFrom >= pxQueue->pcTail )
1758:                				{
1759:                					pxQueue->u.pcReadFrom = pxQueue->pcHead;
1760:                				}
1761:                				--( pxQueue->uxMessagesWaiting );
1762:                				( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
1763:                
1764:                				xReturn = pdPASS;
1765:                
1766:                				/* Were any co-routines waiting for space to become available? */
1767:                				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
1768:                				{
1769:                					/* In this instance the co-routine could be placed directly
1770:                					into the ready list as we are within a critical section.
1771:                					Instead the same pending ready list mechanism is used as if
1772:                					the event were caused from within an interrupt. */
1773:                					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
1774:                					{
1775:                						xReturn = errQUEUE_YIELD;
1776:                					}
1777:                				}
1778:                			}
1779:                			else
1780:                			{
1781:                				xReturn = pdFAIL;
1782:                			}
1783:                		}
1784:                		portENABLE_INTERRUPTS();
1785:                
1786:                		return xReturn;
1787:                	}
1788:                
1789:                #endif /* configUSE_CO_ROUTINES */
1790:                /*-----------------------------------------------------------*/
1791:                
1792:                #if ( configUSE_CO_ROUTINES == 1 )
1793:                
1794:                	signed portBASE_TYPE xQueueCRSendFromISR( xQueueHandle xQueue, const void *pvItemToQueue, signed portBASE_TYPE xCoRoutinePreviouslyWoken )
1795:                	{
1796:                	xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;
1797:                
1798:                		/* Cannot block within an ISR so if there is no space on the queue then
1799:                		exit without doing anything. */
1800:                		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
1801:                		{
1802:                			prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
1803:                
1804:                			/* We only want to wake one co-routine per ISR, so check that a
1805:                			co-routine has not already been woken. */
1806:                			if( xCoRoutinePreviouslyWoken == pdFALSE )
1807:                			{
1808:                				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
1809:                				{
1810:                					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
1811:                					{
1812:                						return pdTRUE;
1813:                					}
1814:                				}
1815:                			}
1816:                		}
1817:                
1818:                		return xCoRoutinePreviouslyWoken;
1819:                	}
1820:                
1821:                #endif /* configUSE_CO_ROUTINES */
1822:                /*-----------------------------------------------------------*/
1823:                
1824:                #if ( configUSE_CO_ROUTINES == 1 )
1825:                
1826:                	signed portBASE_TYPE xQueueCRReceiveFromISR( xQueueHandle xQueue, void *pvBuffer, signed portBASE_TYPE *pxCoRoutineWoken )
1827:                	{
1828:                	signed portBASE_TYPE xReturn;
1829:                	xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;
1830:                
1831:                		/* We cannot block from an ISR, so check there is data available. If
1832:                		not then just leave without doing anything. */
1833:                		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
1834:                		{
1835:                			/* Copy the data from the queue. */
1836:                			pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
1837:                			if( pxQueue->u.pcReadFrom >= pxQueue->pcTail )
1838:                			{
1839:                				pxQueue->u.pcReadFrom = pxQueue->pcHead;
1840:                			}
1841:                			--( pxQueue->uxMessagesWaiting );
1842:                			( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
1843:                
1844:                			if( ( *pxCoRoutineWoken ) == pdFALSE )
1845:                			{
1846:                				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
1847:                				{
1848:                					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
1849:                					{
1850:                						*pxCoRoutineWoken = pdTRUE;
1851:                					}
1852:                				}
1853:                			}
1854:                
1855:                			xReturn = pdPASS;
1856:                		}
1857:                		else
1858:                		{
1859:                			xReturn = pdFAIL;
1860:                		}
1861:                
1862:                		return xReturn;
1863:                	}
1864:                
1865:                #endif /* configUSE_CO_ROUTINES */
1866:                /*-----------------------------------------------------------*/
1867:                
1868:                #if ( configQUEUE_REGISTRY_SIZE > 0 )
1869:                
1870:                	void vQueueAddToRegistry( xQueueHandle xQueue, signed char *pcQueueName )
1871:                	{
1872:                	unsigned portBASE_TYPE ux;
1873:                
1874:                		/* See if there is an empty space in the registry.  A NULL name denotes
1875:                		a free slot. */
1876:                		for( ux = ( unsigned portBASE_TYPE ) 0U; ux < ( unsigned portBASE_TYPE ) configQUEUE_REGISTRY_SIZE; ux++ )
1877:                		{
1878:                			if( xQueueRegistry[ ux ].pcQueueName == NULL )
1879:                			{
1880:                				/* Store the information on this queue. */
1881:                				xQueueRegistry[ ux ].pcQueueName = pcQueueName;
1882:                				xQueueRegistry[ ux ].xHandle = xQueue;
1883:                				break;
1884:                			}
1885:                		}
1886:                	}
1887:                
1888:                #endif /* configQUEUE_REGISTRY_SIZE */
1889:                /*-----------------------------------------------------------*/
1890:                
1891:                #if ( configQUEUE_REGISTRY_SIZE > 0 )
1892:                
1893:                	void vQueueUnregisterQueue( xQueueHandle xQueue )
1894:                	{
1895:                	unsigned portBASE_TYPE ux;
1896:                
1897:                		/* See if the handle of the queue being unregistered in actually in the
1898:                		registry. */
1899:                		for( ux = ( unsigned portBASE_TYPE ) 0U; ux < ( unsigned portBASE_TYPE ) configQUEUE_REGISTRY_SIZE; ux++ )
1900:                		{
1901:                			if( xQueueRegistry[ ux ].xHandle == xQueue )
1902:                			{
1903:                				/* Set the name to NULL to show that this slot if free again. */
1904:                				xQueueRegistry[ ux ].pcQueueName = NULL;
1905:                				break;
1906:                			}
1907:                		}
1908:                
1909:                	} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
1910:                
1911:                #endif /* configQUEUE_REGISTRY_SIZE */
1912:                /*-----------------------------------------------------------*/
1913:                
1914:                #if ( configUSE_TIMERS == 1 )
1915:                
1916:                	void vQueueWaitForMessageRestricted( xQueueHandle xQueue, portTickType xTicksToWait )
1917:                	{
9D0226A0  27BDFFE0   ADDIU SP, SP, -32
9D0226A4  AFBF001C   SW RA, 28(SP)
9D0226A8  AFBE0018   SW S8, 24(SP)
9D0226AC  03A0F021   ADDU S8, SP, ZERO
9D0226B0  AFC40020   SW A0, 32(S8)
9D0226B4  AFC50024   SW A1, 36(S8)
1918:                	xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;
9D0226B8  8FC20020   LW V0, 32(S8)
9D0226BC  AFC20010   SW V0, 16(S8)
1919:                
1920:                		/* This function should not be called by application code hence the
1921:                		'Restricted' in its name.  It is not part of the public API.  It is
1922:                		designed for use by kernel code, and has special calling requirements.
1923:                		It can result in vListInsert() being called on a list that can only
1924:                		possibly ever have one item in it, so the list will be fast, but even
1925:                		so it should be called with the scheduler locked and not from a critical
1926:                		section. */
1927:                
1928:                		/* Only do anything if there are no messages in the queue.  This function
1929:                		will not actually cause the task to block, just place it on a blocked
1930:                		list.  It will not block until the scheduler is unlocked - at which
1931:                		time a yield will be performed.  If an item is added to the queue while
1932:                		the queue is locked, and the calling task blocks on the queue, then the
1933:                		calling task will be immediately unblocked when the queue is unlocked. */
1934:                		prvLockQueue( pxQueue );
9D0226C0  0F40834C   JAL vTaskEnterCritical
9D0226C4  00000000   NOP
9D0226C8  8FC20010   LW V0, 16(S8)
9D0226CC  8C430044   LW V1, 68(V0)
9D0226D0  2402FFFF   ADDIU V0, ZERO, -1
9D0226D4  14620003   BNE V1, V0, 0x9D0226E4
9D0226D8  00000000   NOP
9D0226DC  8FC20010   LW V0, 16(S8)
9D0226E0  AC400044   SW ZERO, 68(V0)
9D0226E4  8FC20010   LW V0, 16(S8)
9D0226E8  8C430048   LW V1, 72(V0)
9D0226EC  2402FFFF   ADDIU V0, ZERO, -1
9D0226F0  14620003   BNE V1, V0, 0x9D022700
9D0226F4  00000000   NOP
9D0226F8  8FC20010   LW V0, 16(S8)
9D0226FC  AC400048   SW ZERO, 72(V0)
9D022700  0F40836C   JAL vTaskExitCritical
9D022704  00000000   NOP
1935:                		if( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0U )
9D022708  8FC20010   LW V0, 16(S8)
9D02270C  8C420038   LW V0, 56(V0)
9D022710  14400007   BNE V0, ZERO, 0x9D022730
9D022714  00000000   NOP
1936:                		{
1937:                			/* There is nothing in the queue, block for the specified period. */
1938:                			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
9D022718  8FC20010   LW V0, 16(S8)
9D02271C  24420024   ADDIU V0, V0, 36
9D022720  00402021   ADDU A0, V0, ZERO
9D022724  8FC50024   LW A1, 36(S8)
9D022728  0F408047   JAL vTaskPlaceOnEventListRestricted
9D02272C  00000000   NOP
1939:                		}
1940:                		prvUnlockQueue( pxQueue );
9D022730  8FC40010   LW A0, 16(S8)
9D022734  0F4088E9   JAL 0x9D0223A4
9D022738  00000000   NOP
1941:                	}
9D02273C  03C0E821   ADDU SP, S8, ZERO
9D022740  8FBF001C   LW RA, 28(SP)
9D022744  8FBE0018   LW S8, 24(SP)
9D022748  27BD0020   ADDIU SP, SP, 32
9D02274C  03E00008   JR RA
9D022750  00000000   NOP
1942:                
1943:                #endif /* configUSE_TIMERS */
1944:                /*-----------------------------------------------------------*/
1945:                
1946:                #if ( configUSE_QUEUE_SETS == 1 )
1947:                
1948:                	xQueueSetHandle xQueueCreateSet( unsigned portBASE_TYPE uxEventQueueLength )
1949:                	{
1950:                	xQueueSetHandle pxQueue;
1951:                
1952:                		pxQueue = xQueueGenericCreate( uxEventQueueLength, sizeof( xQUEUE * ), queueQUEUE_TYPE_SET );
1953:                
1954:                		return pxQueue;
1955:                	}
1956:                
1957:                #endif /* configUSE_QUEUE_SETS */
1958:                /*-----------------------------------------------------------*/
1959:                
1960:                #if ( configUSE_QUEUE_SETS == 1 )
1961:                
1962:                	portBASE_TYPE xQueueAddToSet( xQueueSetMemberHandle xQueueOrSemaphore, xQueueSetHandle xQueueSet )
1963:                	{
1964:                	portBASE_TYPE xReturn;
1965:                
1966:                		if( ( ( xQUEUE * ) xQueueOrSemaphore )->pxQueueSetContainer != NULL )
1967:                		{
1968:                			/* Cannot add a queue/semaphore to more than one queue set. */
1969:                			xReturn = pdFAIL;
1970:                		}
1971:                		else if( ( ( xQUEUE * ) xQueueOrSemaphore )->uxMessagesWaiting != ( unsigned portBASE_TYPE ) 0 )
1972:                		{
1973:                			/* Cannot add a queue/semaphore to a queue set if there are already
1974:                			items in the queue/semaphore. */
1975:                			xReturn = pdFAIL;
1976:                		}
1977:                		else
1978:                		{
1979:                			taskENTER_CRITICAL();
1980:                			{
1981:                				( ( xQUEUE * ) xQueueOrSemaphore )->pxQueueSetContainer = xQueueSet;
1982:                			}
1983:                			taskEXIT_CRITICAL();
1984:                			xReturn = pdPASS;
1985:                		}
1986:                
1987:                		return xReturn;
1988:                	}
1989:                
1990:                #endif /* configUSE_QUEUE_SETS */
1991:                /*-----------------------------------------------------------*/
1992:                
1993:                #if ( configUSE_QUEUE_SETS == 1 )
1994:                
1995:                	portBASE_TYPE xQueueRemoveFromSet( xQueueSetMemberHandle xQueueOrSemaphore, xQueueSetHandle xQueueSet )
1996:                	{
1997:                	portBASE_TYPE xReturn;
1998:                	xQUEUE * const pxQueueOrSemaphore = ( xQUEUE * ) xQueueOrSemaphore;
1999:                
2000:                		if( pxQueueOrSemaphore->pxQueueSetContainer != xQueueSet )
2001:                		{
2002:                			/* The queue was not a member of the set. */
2003:                			xReturn = pdFAIL;
2004:                		}
2005:                		else if( pxQueueOrSemaphore->uxMessagesWaiting != ( unsigned portBASE_TYPE ) 0 )
2006:                		{
2007:                			/* It is dangerous to remove a queue from a set when the queue is
2008:                			not empty because the queue set will still hold pending events for
2009:                			the queue. */
2010:                			xReturn = pdFAIL;
2011:                		}
2012:                		else
2013:                		{
2014:                			taskENTER_CRITICAL();
2015:                			{
2016:                				/* The queue is no longer contained in the set. */
2017:                				pxQueueOrSemaphore->pxQueueSetContainer = NULL;
2018:                			}
2019:                			taskEXIT_CRITICAL();
2020:                			xReturn = pdPASS;
2021:                		}
2022:                
2023:                		return xReturn;
2024:                	} /*lint !e818 xQueueSet could not be declared as pointing to const as it is a typedef. */
2025:                
2026:                #endif /* configUSE_QUEUE_SETS */
2027:                /*-----------------------------------------------------------*/
2028:                
2029:                #if ( configUSE_QUEUE_SETS == 1 )
2030:                
2031:                	xQueueSetMemberHandle xQueueSelectFromSet( xQueueSetHandle xQueueSet, portTickType xBlockTimeTicks )
2032:                	{
2033:                	xQueueSetMemberHandle xReturn = NULL;
2034:                
2035:                		( void ) xQueueGenericReceive( ( xQueueHandle ) xQueueSet, &xReturn, xBlockTimeTicks, pdFALSE ); /*lint !e961 Casting from one typedef to another is not redundant. */
2036:                		return xReturn;
2037:                	}
2038:                
2039:                #endif /* configUSE_QUEUE_SETS */
2040:                /*-----------------------------------------------------------*/
2041:                
2042:                #if ( configUSE_QUEUE_SETS == 1 )
2043:                
2044:                	xQueueSetMemberHandle xQueueSelectFromSetFromISR( xQueueSetHandle xQueueSet )
2045:                	{
2046:                	xQueueSetMemberHandle xReturn = NULL;
2047:                
2048:                		( void ) xQueueReceiveFromISR( ( xQueueHandle ) xQueueSet, &xReturn, NULL ); /*lint !e961 Casting from one typedef to another is not redundant. */
2049:                		return xReturn;
2050:                	}
2051:                
2052:                #endif /* configUSE_QUEUE_SETS */
2053:                /*-----------------------------------------------------------*/
2054:                
2055:                #if ( configUSE_QUEUE_SETS == 1 )
2056:                
2057:                	static portBASE_TYPE prvNotifyQueueSetContainer( const xQUEUE * const pxQueue, portBASE_TYPE xCopyPosition )
2058:                	{
2059:                	xQUEUE *pxQueueSetContainer = pxQueue->pxQueueSetContainer;
2060:                	portBASE_TYPE xReturn = pdFALSE;
2061:                
2062:                		configASSERT( pxQueueSetContainer );
2063:                		configASSERT( pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength );
2064:                
2065:                		if( pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength )
2066:                		{
2067:                			traceQUEUE_SEND( pxQueueSetContainer );
2068:                			/* The data copies is the handle of the queue that contains data. */
2069:                			prvCopyDataToQueue( pxQueueSetContainer, &pxQueue, xCopyPosition );
2070:                			if( listLIST_IS_EMPTY( &( pxQueueSetContainer->xTasksWaitingToReceive ) ) == pdFALSE )
2071:                			{
2072:                				if( xTaskRemoveFromEventList( &( pxQueueSetContainer->xTasksWaitingToReceive ) ) != pdFALSE )
2073:                				{
2074:                					/* The task waiting has a higher priority */
2075:                					xReturn = pdTRUE;
2076:                				}
2077:                			}
2078:                		}
2079:                
2080:                		return xReturn;
2081:                	}
2082:                
2083:                #endif /* configUSE_QUEUE_SETS */
2084:                
---  C:/Users/Diego/Documents/GitHub/pic32webFREERtos/Pic32Web.X/src/FreeRTOS/portable/MemMang/heap_1.c  
1:                   /*
2:                       FreeRTOS V7.5.3 - Copyright (C) 2013 Real Time Engineers Ltd. 
3:                       All rights reserved
4:                   
5:                       VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
6:                   
7:                       ***************************************************************************
8:                        *                                                                       *
9:                        *    FreeRTOS provides completely free yet professionally developed,    *
10:                       *    robust, strictly quality controlled, supported, and cross          *
11:                       *    platform software that has become a de facto standard.             *
12:                       *                                                                       *
13:                       *    Help yourself get started quickly and support the FreeRTOS         *
14:                       *    project by purchasing a FreeRTOS tutorial book, reference          *
15:                       *    manual, or both from: http://www.FreeRTOS.org/Documentation        *
16:                       *                                                                       *
17:                       *    Thank you!                                                         *
18:                       *                                                                       *
19:                      ***************************************************************************
20:                  
21:                      This file is part of the FreeRTOS distribution.
22:                  
23:                      FreeRTOS is free software; you can redistribute it and/or modify it under
24:                      the terms of the GNU General Public License (version 2) as published by the
25:                      Free Software Foundation >>!AND MODIFIED BY!<< the FreeRTOS exception.
26:                  
27:                      >>! NOTE: The modification to the GPL is included to allow you to distribute
28:                      >>! a combined work that includes FreeRTOS without being obliged to provide
29:                      >>! the source code for proprietary components outside of the FreeRTOS
30:                      >>! kernel.
31:                  
32:                      FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
33:                      WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
34:                      FOR A PARTICULAR PURPOSE.  Full license text is available from the following
35:                      link: http://www.freertos.org/a00114.html
36:                  
37:                      1 tab == 4 spaces!
38:                  
39:                      ***************************************************************************
40:                       *                                                                       *
41:                       *    Having a problem?  Start by reading the FAQ "My application does   *
42:                       *    not run, what could be wrong?"                                     *
43:                       *                                                                       *
44:                       *    http://www.FreeRTOS.org/FAQHelp.html                               *
45:                       *                                                                       *
46:                      ***************************************************************************
47:                  
48:                      http://www.FreeRTOS.org - Documentation, books, training, latest versions,
49:                      license and Real Time Engineers Ltd. contact details.
50:                  
51:                      http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
52:                      including FreeRTOS+Trace - an indispensable productivity tool, a DOS
53:                      compatible FAT file system, and our tiny thread aware UDP/IP stack.
54:                  
55:                      http://www.OpenRTOS.com - Real Time Engineers ltd license FreeRTOS to High
56:                      Integrity Systems to sell under the OpenRTOS brand.  Low cost OpenRTOS
57:                      licenses offer ticketed support, indemnification and middleware.
58:                  
59:                      http://www.SafeRTOS.com - High Integrity Systems also provide a safety
60:                      engineered and independently SIL3 certified version for use in safety and
61:                      mission critical applications that require provable dependability.
62:                  
63:                      1 tab == 4 spaces!
64:                  */
65:                  
66:                  
67:                  /*
68:                   * The simplest possible implementation of pvPortMalloc().  Note that this
69:                   * implementation does NOT allow allocated memory to be freed again.
70:                   *
71:                   * See heap_2.c, heap_3.c and heap_4.c for alternative implementations, and the
72:                   * memory management pages of http://www.FreeRTOS.org for more information.
73:                   */
74:                  #include <stdlib.h>
75:                  
76:                  /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
77:                  all the API functions to use the MPU wrappers.  That should only be done when
78:                  task.h is included from an application file. */
79:                  #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
80:                  
81:                  #include "FreeRTOS.h"
82:                  #include "task.h"
83:                  
84:                  #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE
85:                  
86:                  /* A few bytes might be lost to byte aligning the heap start address. */
87:                  #define configADJUSTED_HEAP_SIZE	( configTOTAL_HEAP_SIZE - portBYTE_ALIGNMENT )
88:                  
89:                  /* Allocate the memory for the heap. */
90:                  static unsigned char ucHeap[ configTOTAL_HEAP_SIZE ];
91:                  static size_t xNextFreeByte = ( size_t ) 0;
92:                  
93:                  /*-----------------------------------------------------------*/
94:                  
95:                  void *pvPortMalloc( size_t xWantedSize )
96:                  {
9D034748  27BDFFE0   ADDIU SP, SP, -32
9D03474C  AFBF001C   SW RA, 28(SP)
9D034750  AFBE0018   SW S8, 24(SP)
9D034754  03A0F021   ADDU S8, SP, ZERO
9D034758  AFC40020   SW A0, 32(S8)
97:                  void *pvReturn = NULL;
9D03475C  AFC00010   SW ZERO, 16(S8)
98:                  static unsigned char *pucAlignedHeap = NULL;
99:                  
100:                 	/* Ensure that blocks are always aligned to the required number of bytes. */
101:                 	#if portBYTE_ALIGNMENT != 1
102:                 		if( xWantedSize & portBYTE_ALIGNMENT_MASK )
9D034760  8FC20020   LW V0, 32(S8)
9D034764  30420007   ANDI V0, V0, 7
9D034768  10400006   BEQ V0, ZERO, 0x9D034784
9D03476C  00000000   NOP
103:                 		{
104:                 			/* Byte alignment required. */
105:                 			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
9D034770  8FC30020   LW V1, 32(S8)
9D034774  2402FFF8   ADDIU V0, ZERO, -8
9D034778  00621024   AND V0, V1, V0
9D03477C  24420008   ADDIU V0, V0, 8
9D034780  AFC20020   SW V0, 32(S8)
106:                 		}
107:                 	#endif
108:                 
109:                 	vTaskSuspendAll();
9D034784  0F407E3F   JAL vTaskSuspendAll
9D034788  00000000   NOP
110:                 	{
111:                 		if( pucAlignedHeap == NULL )
9D03478C  8F828078   LW V0, -32648(GP)
9D034790  14400006   BNE V0, ZERO, 0x9D0347AC
9D034794  00000000   NOP
112:                 		{
113:                 			/* Ensure the heap starts on a correctly aligned boundary. */
114:                 			pucAlignedHeap = ( unsigned char * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK ) );
9D034798  3C02A000   LUI V0, -24576
9D03479C  24430764   ADDIU V1, V0, 1892
9D0347A0  2402FFF8   ADDIU V0, ZERO, -8
9D0347A4  00621024   AND V0, V1, V0
9D0347A8  AF828078   SW V0, -32648(GP)
115:                 		}
116:                 
117:                 		/* Check there is enough room left for the allocation. */
118:                 		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
9D0347AC  8F838074   LW V1, -32652(GP)
9D0347B0  8FC20020   LW V0, 32(S8)
9D0347B4  00621021   ADDU V0, V1, V0
9D0347B8  2C421F38   SLTIU V0, V0, 7992
9D0347BC  10400010   BEQ V0, ZERO, 0x9D034800
9D0347C0  00000000   NOP
9D0347D4  0043102B   SLTU V0, V0, V1
9D0347D8  10400009   BEQ V0, ZERO, 0x9D034800
9D0347DC  00000000   NOP
119:                 			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
9D0347C4  8F838074   LW V1, -32652(GP)
9D0347C8  8FC20020   LW V0, 32(S8)
9D0347CC  00621821   ADDU V1, V1, V0
9D0347D0  8F828074   LW V0, -32652(GP)
120:                 		{
121:                 			/* Return the next free byte then increment the index past this
122:                 			block. */
123:                 			pvReturn = pucAlignedHeap + xNextFreeByte;
9D0347E0  8F838078   LW V1, -32648(GP)
9D0347E4  8F828074   LW V0, -32652(GP)
9D0347E8  00621021   ADDU V0, V1, V0
9D0347EC  AFC20010   SW V0, 16(S8)
124:                 			xNextFreeByte += xWantedSize;
9D0347F0  8F838074   LW V1, -32652(GP)
9D0347F4  8FC20020   LW V0, 32(S8)
9D0347F8  00621021   ADDU V0, V1, V0
9D0347FC  AF828074   SW V0, -32652(GP)
125:                 		}
126:                 
127:                 		traceMALLOC( pvReturn, xWantedSize );
128:                 	}	
129:                 	xTaskResumeAll();
9D034800  0F407E4A   JAL xTaskResumeAll
9D034804  00000000   NOP
130:                 
131:                 	#if( configUSE_MALLOC_FAILED_HOOK == 1 )
132:                 	{
133:                 		if( pvReturn == NULL )
9D034808  8FC20010   LW V0, 16(S8)
9D03480C  14400003   BNE V0, ZERO, 0x9D03481C
9D034810  00000000   NOP
134:                 		{
135:                 			extern void vApplicationMallocFailedHook( void );
136:                 			vApplicationMallocFailedHook();
9D034814  0F40C5B0   JAL vApplicationMallocFailedHook
9D034818  00000000   NOP
137:                 		}
138:                 	}
139:                 	#endif
140:                 
141:                 	return pvReturn;
9D03481C  8FC20010   LW V0, 16(S8)
142:                 }
9D034820  03C0E821   ADDU SP, S8, ZERO
9D034824  8FBF001C   LW RA, 28(SP)
9D034828  8FBE0018   LW S8, 24(SP)
9D03482C  27BD0020   ADDIU SP, SP, 32
9D034830  03E00008   JR RA
9D034834  00000000   NOP
143:                 /*-----------------------------------------------------------*/
144:                 
145:                 void vPortFree( void *pv )
146:                 {
9D034838  27BDFFE8   ADDIU SP, SP, -24
9D03483C  AFBF0014   SW RA, 20(SP)
9D034840  AFBE0010   SW S8, 16(SP)
9D034844  03A0F021   ADDU S8, SP, ZERO
9D034848  AFC40018   SW A0, 24(S8)
147:                 	/* Memory cannot be freed using this scheme.  See heap_2.c, heap_3.c and
148:                 	heap_4.c for alternative implementations, and the memory management pages of
149:                 	http://www.FreeRTOS.org for more information. */
150:                 	( void ) pv;
151:                 
152:                 	/* Force an assert as it is invalid to call this function. */
153:                 	configASSERT( pv == NULL );
9D03484C  8FC20018   LW V0, 24(S8)
9D034850  10400006   BEQ V0, ZERO, 0x9D03486C
9D034854  00000000   NOP
9D034858  3C029D03   LUI V0, -25341
9D03485C  244460B8   ADDIU A0, V0, 24760
9D034860  24050099   ADDIU A1, ZERO, 153
9D034864  0F40C5F5   JAL vAssertCalled
9D034868  00000000   NOP
154:                 }
9D03486C  03C0E821   ADDU SP, S8, ZERO
9D034870  8FBF0014   LW RA, 20(SP)
9D034874  8FBE0010   LW S8, 16(SP)
9D034878  27BD0018   ADDIU SP, SP, 24
9D03487C  03E00008   JR RA
9D034880  00000000   NOP
155:                 /*-----------------------------------------------------------*/
156:                 
157:                 void vPortInitialiseBlocks( void )
158:                 {
9D034884  27BDFFF8   ADDIU SP, SP, -8
9D034888  AFBE0004   SW S8, 4(SP)
9D03488C  03A0F021   ADDU S8, SP, ZERO
159:                 	/* Only required when static memory is not cleared. */
160:                 	xNextFreeByte = ( size_t ) 0;
9D034890  AF808074   SW ZERO, -32652(GP)
161:                 }
9D034894  03C0E821   ADDU SP, S8, ZERO
9D034898  8FBE0004   LW S8, 4(SP)
9D03489C  27BD0008   ADDIU SP, SP, 8
9D0348A0  03E00008   JR RA
9D0348A4  00000000   NOP
162:                 /*-----------------------------------------------------------*/
163:                 
164:                 size_t xPortGetFreeHeapSize( void )
165:                 {
9D0348A8  27BDFFF8   ADDIU SP, SP, -8
9D0348AC  AFBE0004   SW S8, 4(SP)
9D0348B0  03A0F021   ADDU S8, SP, ZERO
166:                 	return ( configADJUSTED_HEAP_SIZE - xNextFreeByte );
9D0348B4  8F828074   LW V0, -32652(GP)
9D0348B8  24031F38   ADDIU V1, ZERO, 7992
9D0348BC  00621023   SUBU V0, V1, V0
167:                 }
9D0348C0  03C0E821   ADDU SP, S8, ZERO
9D0348C4  8FBE0004   LW S8, 4(SP)
9D0348C8  27BD0008   ADDIU SP, SP, 8
9D0348CC  03E00008   JR RA
9D0348D0  00000000   NOP
168:                 
169:                 
170:                 
---  C:/Users/Diego/Documents/GitHub/pic32webFREERtos/Pic32Web.X/src/FreeRTOS/portable/MPLAB/PIC32MX/port_asm.S
                                                  1:     /*
                                                  2:         FreeRTOS V7.5.3 - Copyright (C) 2013 Real Time Engineers Ltd. 
                                                  3:         All rights reserved
                                                  4:     
                                                  5:         VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
                                                  6:     
                                                  7:         ***************************************************************************
                                                  8:          *                                                                       *
                                                  9:          *    FreeRTOS provides completely free yet professionally developed,    *
                                                  10:         *    robust, strictly quality controlled, supported, and cross          *
                                                  11:         *    platform software that has become a de facto standard.             *
                                                  12:         *                                                                       *
                                                  13:         *    Help yourself get started quickly and support the FreeRTOS         *
                                                  14:         *    project by purchasing a FreeRTOS tutorial book, reference          *
                                                  15:         *    manual, or both from: http://www.FreeRTOS.org/Documentation        *
                                                  16:         *                                                                       *
                                                  17:         *    Thank you!                                                         *
                                                  18:         *                                                                       *
                                                  19:        ***************************************************************************
                                                  20:    
                                                  21:        This file is part of the FreeRTOS distribution.
                                                  22:    
                                                  23:        FreeRTOS is free software; you can redistribute it and/or modify it under
                                                  24:        the terms of the GNU General Public License (version 2) as published by the
                                                  25:        Free Software Foundation >>!AND MODIFIED BY!<< the FreeRTOS exception.
                                                  26:    
                                                  27:        >>! NOTE: The modification to the GPL is included to allow you to distribute
                                                  28:        >>! a combined work that includes FreeRTOS without being obliged to provide
                                                  29:        >>! the source code for proprietary components outside of the FreeRTOS
                                                  30:        >>! kernel.
                                                  31:    
                                                  32:        FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
                                                  33:        WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
                                                  34:        FOR A PARTICULAR PURPOSE.  Full license text is available from the following
                                                  35:        link: http://www.freertos.org/a00114.html
                                                  36:    
                                                  37:        1 tab == 4 spaces!
                                                  38:    
                                                  39:        ***************************************************************************
                                                  40:         *                                                                       *
                                                  41:         *    Having a problem?  Start by reading the FAQ "My application does   *
                                                  42:         *    not run, what could be wrong?"                                     *
                                                  43:         *                                                                       *
                                                  44:         *    http://www.FreeRTOS.org/FAQHelp.html                               *
                                                  45:         *                                                                       *
                                                  46:        ***************************************************************************
                                                  47:    
                                                  48:        http://www.FreeRTOS.org - Documentation, books, training, latest versions,
                                                  49:        license and Real Time Engineers Ltd. contact details.
                                                  50:    
                                                  51:        http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
                                                  52:        including FreeRTOS+Trace - an indispensable productivity tool, a DOS
                                                  53:        compatible FAT file system, and our tiny thread aware UDP/IP stack.
                                                  54:    
                                                  55:        http://www.OpenRTOS.com - Real Time Engineers ltd license FreeRTOS to High
                                                  56:        Integrity Systems to sell under the OpenRTOS brand.  Low cost OpenRTOS
                                                  57:        licenses offer ticketed support, indemnification and middleware.
                                                  58:    
                                                  59:        http://www.SafeRTOS.com - High Integrity Systems also provide a safety
                                                  60:        engineered and independently SIL3 certified version for use in safety and
                                                  61:        mission critical applications that require provable dependability.
                                                  62:    
                                                  63:        1 tab == 4 spaces!
                                                  64:    */
                                                  65:    
                                                  66:    #include <xc.h>
                                                  67:    #include <sys/asm.h>
                                                  68:    #include "ISR_Support.h"
                                                  69:    
                                                  70:    
                                                  71:    	.set	nomips16
                                                  72:     	.set 	noreorder
                                                  73:    
                                                  74:     	.extern pxCurrentTCB
                                                  75:     	.extern vTaskSwitchContext
                                                  76:     	.extern vPortIncrementTick
                                                  77:    	.extern xISRStackTop
                                                  78:    
                                                  79:     	.global vPortStartFirstTask
                                                  80:    	.global vPortYieldISR
                                                  81:    	.global vPortTickInterruptHandler
                                                  82:    
                                                  83:    
                                                  84:    /******************************************************************/
                                                  85:    
                                                  86:     	.set		noreorder
                                                  87:    	.set 		noat
                                                  88:     	.ent		vPortTickInterruptHandler
                                                  89:    
                                                  90:    vPortTickInterruptHandler:
                                                  91:    
9D03265C  401A6800   MFC0 K0, Cause               92:    	portSAVE_CONTEXT
9D032660  27BDFF7C   ADDIU SP, SP, -132
9D032664  401B6000   MFC0 K1, Status
9D032668  AFB6002C   SW S6, 44(SP)
9D03266C  AFB50028   SW S5, 40(SP)
9D032670  AFBB0080   SW K1, 128(SP)
9D032674  001AD282   SRL K0, K0, 10
9D032678  7F5B7A84   INS K1, K0, 10, 6
9D03267C  7C1B2044   INS K1, ZERO, 1, 4
9D032680  001DA820   ADD S5, ZERO, SP
9D032684  3C1AA000   LUI K0, -24576
9D032688  275A0228   ADDIU K0, K0, 552
9D03268C  8F560000   LW S6, 0(K0)
9D032690  16C00004   BNE S6, ZERO, 0x9D0326A4
9D032694  00000000   NOP
9D032698  3C1D9D03   LUI SP, -25341
9D03269C  27BD6288   ADDIU SP, SP, 25224
9D0326A0  8FBD0000   LW SP, 0(SP)
9D0326A4  26D60001   ADDIU S6, S6, 1
9D0326A8  AF560000   SW S6, 0(K0)
9D0326AC  40167000   MFC0 S6, EPC
9D0326B0  409B6000   MTC0 K1, Status
9D0326B4  AEBF0078   SW RA, 120(S5)
9D0326B8  AEBE0074   SW S8, 116(S5)
9D0326BC  AEB90070   SW T9, 112(S5)
9D0326C0  AEB8006C   SW T8, 108(S5)
9D0326C4  AEAF0068   SW T7, 104(S5)
9D0326C8  AEAE0064   SW T6, 100(S5)
9D0326CC  AEAD0060   SW T5, 96(S5)
9D0326D0  AEAC005C   SW T4, 92(S5)
9D0326D4  AEAB0058   SW T3, 88(S5)
9D0326D8  AEAA0054   SW T2, 84(S5)
9D0326DC  AEA90050   SW T1, 80(S5)
9D0326E0  AEA8004C   SW T0, 76(S5)
9D0326E4  AEA70048   SW A3, 72(S5)
9D0326E8  AEA60044   SW A2, 68(S5)
9D0326EC  AEA50040   SW A1, 64(S5)
9D0326F0  AEA4003C   SW A0, 60(S5)
9D0326F4  AEA30038   SW V1, 56(S5)
9D0326F8  AEA20034   SW V0, 52(S5)
9D0326FC  AEB6007C   SW S6, 124(S5)
9D032700  AEA10010   SW AT, 16(S5)
9D032704  0000B010   MFHI S6, 0
9D032708  AEB6000C   SW S6, 12(S5)
9D03270C  0000B012   MFLO S6, 0
9D032710  AEB60008   SW S6, 8(S5)
9D032714  3C16A000   LUI S6, -24576
9D032718  26D60228   ADDIU S6, S6, 552
9D03271C  8ED60000   LW S6, 0(S6)
9D032720  26D6FFFF   ADDIU S6, S6, -1
9D032724  16C00004   BNE S6, ZERO, 0x9D032738
9D032728  00000000   NOP
9D03272C  3C16A000   LUI S6, -24576
9D032730  26D6029C   ADDIU S6, S6, 668
9D032734  AED50000   SW S5, 0(S6)
                                                  93:    
9D032738  0F40CFB4   JAL 0x9D033ED0               94:    	jal 		vPortIncrementTick
9D03273C  00000000   NOP                          95:    	nop
                                                  96:    
9D032740  3C16A000   LUI S6, -24576               97:    	portRESTORE_CONTEXT
9D032744  26D60228   ADDIU S6, S6, 552
9D032748  8ED60000   LW S6, 0(S6)
9D03274C  26D6FFFF   ADDIU S6, S6, -1
9D032750  16C00004   BNE S6, ZERO, 0x9D032764
9D032754  00000000   NOP
9D032758  3C16A000   LUI S6, -24576
9D03275C  26D6029C   ADDIU S6, S6, 668
9D032760  8ED50000   LW S5, 0(S6)
9D032764  8EB60008   LW S6, 8(S5)
9D032768  02C00013   MTLO S6, 0
9D03276C  8EB6000C   LW S6, 12(S5)
9D032770  02C00011   MTHI S6, 0
9D032774  8EA10010   LW AT, 16(S5)
9D032778  8EB6002C   LW S6, 44(S5)
9D03277C  8EA20034   LW V0, 52(S5)
9D032780  8EA30038   LW V1, 56(S5)
9D032784  8EA4003C   LW A0, 60(S5)
9D032788  8EA50040   LW A1, 64(S5)
9D03278C  8EA60044   LW A2, 68(S5)
9D032790  8EA70048   LW A3, 72(S5)
9D032794  8EA8004C   LW T0, 76(S5)
9D032798  8EA90050   LW T1, 80(S5)
9D03279C  8EAA0054   LW T2, 84(S5)
9D0327A0  8EAB0058   LW T3, 88(S5)
9D0327A4  8EAC005C   LW T4, 92(S5)
9D0327A8  8EAD0060   LW T5, 96(S5)
9D0327AC  8EAE0064   LW T6, 100(S5)
9D0327B0  8EAF0068   LW T7, 104(S5)
9D0327B4  8EB8006C   LW T8, 108(S5)
9D0327B8  8EB90070   LW T9, 112(S5)
9D0327BC  8EBE0074   LW S8, 116(S5)
9D0327C0  8EBF0078   LW RA, 120(S5)
9D0327C4  41606000   DI ZERO
9D0327C8  3C1AA000   LUI K0, -24576
9D0327CC  275A0228   ADDIU K0, K0, 552
9D0327D0  8F5B0000   LW K1, 0(K0)
9D0327D4  277BFFFF   ADDIU K1, K1, -1
9D0327D8  AF5B0000   SW K1, 0(K0)
9D0327DC  8EBA0080   LW K0, 128(S5)
9D0327E0  8EBB007C   LW K1, 124(S5)
9D0327E4  0015E820   ADD SP, ZERO, S5
9D0327E8  8FB50028   LW S5, 40(SP)
9D0327EC  27BD0084   ADDIU SP, SP, 132
9D0327F0  409A6000   MTC0 K0, Status
9D0327F4  409B7000   MTC0 K1, EPC
9D0327F8  42000018   ERET
9D0327FC  00000000   NOP
                                                  98:    
                                                  99:    	.end vPortTickInterruptHandler
                                                  100:   
                                                  101:   /******************************************************************/
                                                  102:   
                                                  103:    	.set		noreorder
                                                  104:   	.set 		noat
                                                  105:    	.ent		vPortStartFirstTask
                                                  106:   
                                                  107:   vPortStartFirstTask:
                                                  108:   
                                                  109:   	/* Simply restore the context of the highest priority task that has been
                                                  110:   	created so far. */
9D032800  3C16A000   LUI S6, -24576               111:   	portRESTORE_CONTEXT
9D032804  26D60228   ADDIU S6, S6, 552
9D032808  8ED60000   LW S6, 0(S6)
9D03280C  26D6FFFF   ADDIU S6, S6, -1
9D032810  16C00004   BNE S6, ZERO, 0x9D032824
9D032814  00000000   NOP
9D032818  3C16A000   LUI S6, -24576
9D03281C  26D6029C   ADDIU S6, S6, 668
9D032820  8ED50000   LW S5, 0(S6)
9D032824  8EB60008   LW S6, 8(S5)
9D032828  02C00013   MTLO S6, 0
9D03282C  8EB6000C   LW S6, 12(S5)
9D032830  02C00011   MTHI S6, 0
9D032834  8EA10010   LW AT, 16(S5)
9D032838  8EB6002C   LW S6, 44(S5)
9D03283C  8EA20034   LW V0, 52(S5)
9D032840  8EA30038   LW V1, 56(S5)
9D032844  8EA4003C   LW A0, 60(S5)
9D032848  8EA50040   LW A1, 64(S5)
9D03284C  8EA60044   LW A2, 68(S5)
9D032850  8EA70048   LW A3, 72(S5)
9D032854  8EA8004C   LW T0, 76(S5)
9D032858  8EA90050   LW T1, 80(S5)
9D03285C  8EAA0054   LW T2, 84(S5)
9D032860  8EAB0058   LW T3, 88(S5)
9D032864  8EAC005C   LW T4, 92(S5)
9D032868  8EAD0060   LW T5, 96(S5)
9D03286C  8EAE0064   LW T6, 100(S5)
9D032870  8EAF0068   LW T7, 104(S5)
9D032874  8EB8006C   LW T8, 108(S5)
9D032878  8EB90070   LW T9, 112(S5)
9D03287C  8EBE0074   LW S8, 116(S5)
9D032880  8EBF0078   LW RA, 120(S5)
9D032884  41606000   DI ZERO
9D032888  3C1AA000   LUI K0, -24576
9D03288C  275A0228   ADDIU K0, K0, 552
9D032890  8F5B0000   LW K1, 0(K0)
9D032894  277BFFFF   ADDIU K1, K1, -1
9D032898  AF5B0000   SW K1, 0(K0)
9D03289C  8EBA0080   LW K0, 128(S5)
9D0328A0  8EBB007C   LW K1, 124(S5)
9D0328A4  0015E820   ADD SP, ZERO, S5
9D0328A8  8FB50028   LW S5, 40(SP)
9D0328AC  27BD0084   ADDIU SP, SP, 132
9D0328B0  409A6000   MTC0 K0, Status
9D0328B4  409B7000   MTC0 K1, EPC
9D0328B8  42000018   ERET
9D0328BC  00000000   NOP
                                                  112:   
                                                  113:   	.end vPortStartFirstTask
                                                  114:   
                                                  115:   
                                                  116:   
                                                  117:   /*******************************************************************/
                                                  118:   
                                                  119:    	.set		noreorder
                                                  120:   	.set 		noat
                                                  121:    	.ent		vPortYieldISR
                                                  122:   
                                                  123:   vPortYieldISR:
                                                  124:   
                                                  125:   	/* Make room for the context. First save the current status so it can be
                                                  126:   	manipulated, and the cause and EPC registers so thier original values are
                                                  127:   	captured. */
9D0328C0  401A6800   MFC0 K0, Cause               128:   	mfc0		k0, _CP0_CAUSE
9D0328C4  27BDFF7C   ADDIU SP, SP, -132           129:   	addiu		sp,	sp, -portCONTEXT_SIZE
9D0328C8  401B6000   MFC0 K1, Status              130:   	mfc0		k1, _CP0_STATUS
                                                  131:   
                                                  132:   	/* Also save s6 and s5 so we can use them during this interrupt.  Any
                                                  133:   	nesting interrupts should maintain the values of these registers
                                                  134:   	across the ISR. */
9D0328CC  AFB6002C   SW S6, 44(SP)                135:   	sw			s6, 44(sp)
9D0328D0  AFB50028   SW S5, 40(SP)                136:   	sw			s5, 40(sp)
9D0328D4  AFBB0080   SW K1, 128(SP)               137:   	sw			k1, portSTATUS_STACK_LOCATION(sp)
                                                  138:   
                                                  139:   	/* Interrupts above the kernel priority are going to be re-enabled. */
9D0328D8  001AD282   SRL K0, K0, 10               140:   	srl			k0, k0, 0xa
9D0328DC  7F5B7A84   INS K1, K0, 10, 6            141:   	ins 		k1, k0, 10, 6
9D0328E0  7C1B2044   INS K1, ZERO, 1, 4           142:   	ins			k1, zero, 1, 4
                                                  143:   
                                                  144:   	/* s5 is used as the frame pointer. */
9D0328E4  001DA820   ADD S5, ZERO, SP             145:   	add			s5, zero, sp
                                                  146:   
                                                  147:   	/* Swap to the system stack.  This is not conditional on the nesting
                                                  148:   	count as this interrupt is always the lowest priority and therefore
                                                  149:   	the nesting is always 0. */
9D0328E8  3C1D9D03   LUI SP, -25341               150:   	la			sp, xISRStackTop
9D0328EC  27BD6288   ADDIU SP, SP, 25224
9D0328F0  8FBD0000   LW SP, 0(SP)                 151:   	lw			sp, (sp)
                                                  152:   
                                                  153:   	/* Set the nesting count. */
9D0328F4  3C1AA000   LUI K0, -24576               154:   	la			k0, uxInterruptNesting
9D0328F8  275A0228   ADDIU K0, K0, 552
9D0328FC  24160001   ADDIU S6, ZERO, 1            155:   	addiu		s6, zero, 1
9D032900  AF560000   SW S6, 0(K0)                 156:   	sw			s6, 0(k0)
                                                  157:   
                                                  158:   	/* s6 holds the EPC value, this is saved with the rest of the context
                                                  159:   	after interrupts are enabled. */
9D032904  40167000   MFC0 S6, EPC                 160:   	mfc0 		s6, _CP0_EPC
                                                  161:   
                                                  162:   	/* Re-enable interrupts. */
9D032908  409B6000   MTC0 K1, Status              163:   	mtc0		k1, _CP0_STATUS
                                                  164:   
                                                  165:   	/* Save the context into the space just created.  s6 is saved again
                                                  166:   	here as it now contains the EPC value. */
9D03290C  AEBF0078   SW RA, 120(S5)               167:   	sw			ra,	120(s5)
9D032910  AEBE0074   SW S8, 116(S5)               168:   	sw			s8, 116(s5)
9D032914  AEB90070   SW T9, 112(S5)               169:   	sw			t9, 112(s5)
9D032918  AEB8006C   SW T8, 108(S5)               170:   	sw			t8,	108(s5)
9D03291C  AEAF0068   SW T7, 104(S5)               171:   	sw			t7,	104(s5)
9D032920  AEAE0064   SW T6, 100(S5)               172:   	sw			t6, 100(s5)
9D032924  AEAD0060   SW T5, 96(S5)                173:   	sw			t5, 96(s5)
9D032928  AEAC005C   SW T4, 92(S5)                174:   	sw			t4, 92(s5)
9D03292C  AEAB0058   SW T3, 88(S5)                175:   	sw			t3, 88(s5)
9D032930  AEAA0054   SW T2, 84(S5)                176:   	sw			t2, 84(s5)
9D032934  AEA90050   SW T1, 80(S5)                177:   	sw			t1, 80(s5)
9D032938  AEA8004C   SW T0, 76(S5)                178:   	sw			t0, 76(s5)
9D03293C  AEA70048   SW A3, 72(S5)                179:   	sw			a3, 72(s5)
9D032940  AEA60044   SW A2, 68(S5)                180:   	sw			a2, 68(s5)
9D032944  AEA50040   SW A1, 64(S5)                181:   	sw			a1, 64(s5)
9D032948  AEA4003C   SW A0, 60(S5)                182:   	sw			a0, 60(s5)
9D03294C  AEA30038   SW V1, 56(S5)                183:   	sw			v1, 56(s5)
9D032950  AEA20034   SW V0, 52(S5)                184:   	sw			v0, 52(s5)
9D032954  AEB70030   SW S7, 48(S5)                185:   	sw			s7, 48(s5)
9D032958  AEB6007C   SW S6, 124(S5)               186:   	sw			s6, portEPC_STACK_LOCATION(s5)
                                                  187:   	/* s5 and s6 has already been saved. */
9D03295C  AEB40024   SW S4, 36(S5)                188:   	sw			s4,	36(s5)
9D032960  AEB30020   SW S3, 32(S5)                189:   	sw			s3, 32(s5)
9D032964  AEB2001C   SW S2, 28(S5)                190:   	sw			s2, 28(s5)
9D032968  AEB10018   SW S1, 24(S5)                191:   	sw			s1, 24(s5)
9D03296C  AEB00014   SW S0, 20(S5)                192:   	sw			s0, 20(s5)
9D032970  AEA10010   SW AT, 16(S5)                193:   	sw			$1, 16(s5)
                                                  194:   
                                                  195:   	/* s7 is used as a scratch register as this should always be saved across
                                                  196:   	nesting interrupts. */
9D032974  0000B810   MFHI S7, 0                   197:   	mfhi		s7
9D032978  AEB7000C   SW S7, 12(S5)                198:   	sw			s7, 12(s5)
9D03297C  0000B812   MFLO S7, 0                   199:   	mflo		s7
9D032980  AEB70008   SW S7, 8(S5)                 200:   	sw			s7, 8(s5)
                                                  201:   
                                                  202:   	/* Save the stack pointer to the task. */
9D032984  3C17A000   LUI S7, -24576               203:   	la			s7, pxCurrentTCB
9D032988  26F702B4   ADDIU S7, S7, 692
9D03298C  8EF70000   LW S7, 0(S7)                 204:   	lw			s7, (s7)
9D032990  AEF50000   SW S5, 0(S7)                 205:   	sw			s5, (s7)
                                                  206:   
                                                  207:   	/* Set the interrupt mask to the max priority that can use the API.  The
                                                  208:   	yield handler will only be called at configKERNEL_INTERRUPT_PRIORITY which
                                                  209:   	is below configMAX_SYSCALL_INTERRUPT_PRIORITY - so this can only ever
                                                  210:   	raise the IPL value and never lower it. */
9D032994  41606000   DI ZERO                      211:   	di
9D032998  40176000   MFC0 S7, Status              212:   	mfc0		s7, _CP0_STATUS
9D03299C  7C177A84   INS S7, ZERO, 10, 6          213:   	ins 		s7, $0, 10, 6
9D0329A0  36F60C01   ORI S6, S7, 3073             214:   	ori			s6, s7, ( configMAX_SYSCALL_INTERRUPT_PRIORITY << 10 ) | 1
                                                  215:   
                                                  216:   	/* This mtc0 re-enables interrupts, but only above
                                                  217:   	configMAX_SYSCALL_INTERRUPT_PRIORITY. */
9D0329A4  40966000   MTC0 S6, Status              218:   	mtc0		s6, _CP0_STATUS
                                                  219:   
                                                  220:   	/* Clear the software interrupt in the core. */
9D0329A8  40166800   MFC0 S6, Cause               221:   	mfc0		s6, _CP0_CAUSE
9D0329AC  7C164204   INS S6, ZERO, 8, 1           222:   	ins			s6, zero, 8, 1
9D0329B0  40966800   MTC0 S6, Cause               223:   	mtc0		s6, _CP0_CAUSE
                                                  224:   
                                                  225:   	/* Clear the interrupt in the interrupt controller. */
9D0329B4  3C16BF88   LUI S6, -16504               226:   	la			s6, IFS0CLR
9D0329B8  26D61034   ADDIU S6, S6, 4148
9D0329BC  24140002   ADDIU S4, ZERO, 2            227:   	addiu		s4, zero, 2
9D0329C0  AED40000   SW S4, 0(S6)                 228:   	sw			s4, (s6)
                                                  229:   
9D0329C4  0F407F9C   JAL 0x9D01FE70               230:   	jal			vTaskSwitchContext
9D0329C8  00000000   NOP                          231:   	nop
                                                  232:   
                                                  233:   	/* Clear the interrupt mask again.  The saved status value is still in s7. */
9D0329CC  40976000   MTC0 S7, Status              234:   	mtc0		s7, _CP0_STATUS
                                                  235:   
                                                  236:   	/* Restore the stack pointer from the TCB. */
9D0329D0  3C10A000   LUI S0, -24576               237:   	la			s0, pxCurrentTCB
9D0329D4  261002B4   ADDIU S0, S0, 692
9D0329D8  8E100000   LW S0, 0(S0)                 238:   	lw			s0, (s0)
9D0329DC  8E150000   LW S5, 0(S0)                 239:   	lw			s5, (s0)
                                                  240:   
                                                  241:   	/* Restore the rest of the context. */
9D0329E0  8EB00008   LW S0, 8(S5)                 242:   	lw			s0, 8(s5)
9D0329E4  02000013   MTLO S0, 0                   243:   	mtlo		s0
9D0329E8  8EB0000C   LW S0, 12(S5)                244:   	lw			s0, 12(s5)
9D0329EC  02000011   MTHI S0, 0                   245:   	mthi		s0
9D0329F0  8EA10010   LW AT, 16(S5)                246:   	lw			$1, 16(s5)
9D0329F4  8EB00014   LW S0, 20(S5)                247:   	lw			s0, 20(s5)
9D0329F8  8EB10018   LW S1, 24(S5)                248:   	lw			s1, 24(s5)
9D0329FC  8EB2001C   LW S2, 28(S5)                249:   	lw			s2, 28(s5)
9D032A00  8EB30020   LW S3, 32(S5)                250:   	lw			s3, 32(s5)
9D032A04  8EB40024   LW S4, 36(S5)                251:   	lw			s4, 36(s5)
                                                  252:   	/* s5 is loaded later. */
9D032A08  8EB6002C   LW S6, 44(S5)                253:   	lw			s6, 44(s5)
9D032A0C  8EB70030   LW S7, 48(S5)                254:   	lw			s7, 48(s5)
9D032A10  8EA20034   LW V0, 52(S5)                255:   	lw			v0, 52(s5)
9D032A14  8EA30038   LW V1, 56(S5)                256:   	lw			v1, 56(s5)
9D032A18  8EA4003C   LW A0, 60(S5)                257:   	lw			a0, 60(s5)
9D032A1C  8EA50040   LW A1, 64(S5)                258:   	lw			a1, 64(s5)
9D032A20  8EA60044   LW A2, 68(S5)                259:   	lw			a2, 68(s5)
9D032A24  8EA70048   LW A3, 72(S5)                260:   	lw			a3, 72(s5)
9D032A28  8EA8004C   LW T0, 76(S5)                261:   	lw			t0, 76(s5)
9D032A2C  8EA90050   LW T1, 80(S5)                262:   	lw			t1, 80(s5)
9D032A30  8EAA0054   LW T2, 84(S5)                263:   	lw			t2, 84(s5)
9D032A34  8EAB0058   LW T3, 88(S5)                264:   	lw			t3, 88(s5)
9D032A38  8EAC005C   LW T4, 92(S5)                265:   	lw			t4, 92(s5)
9D032A3C  8EAD0060   LW T5, 96(S5)                266:   	lw			t5, 96(s5)
9D032A40  8EAE0064   LW T6, 100(S5)               267:   	lw			t6, 100(s5)
9D032A44  8EAF0068   LW T7, 104(S5)               268:   	lw			t7, 104(s5)
9D032A48  8EB8006C   LW T8, 108(S5)               269:   	lw			t8, 108(s5)
9D032A4C  8EB90070   LW T9, 112(S5)               270:   	lw			t9, 112(s5)
9D032A50  8EBE0074   LW S8, 116(S5)               271:   	lw			s8, 116(s5)
9D032A54  8EBF0078   LW RA, 120(S5)               272:   	lw			ra, 120(s5)
                                                  273:   
                                                  274:   	/* Protect access to the k registers, and others. */
9D032A58  41606000   DI ZERO                      275:   	di
                                                  276:   
                                                  277:   	/* Set nesting back to zero.  As the lowest priority interrupt this
                                                  278:   	interrupt cannot have nested. */
9D032A5C  3C1AA000   LUI K0, -24576               279:   	la			k0, uxInterruptNesting
9D032A60  275A0228   ADDIU K0, K0, 552
9D032A64  AF400000   SW ZERO, 0(K0)               280:   	sw			zero, 0(k0)
                                                  281:   
                                                  282:   	/* Switch back to use the real stack pointer. */
9D032A68  0015E820   ADD SP, ZERO, S5             283:   	add			sp, zero, s5
                                                  284:   
                                                  285:   	/* Restore the real s5 value. */
9D032A6C  8FB50028   LW S5, 40(SP)                286:   	lw			s5, 40(sp)
                                                  287:   
                                                  288:   	/* Pop the status and epc values. */
9D032A70  8FBB0080   LW K1, 128(SP)               289:   	lw			k1, portSTATUS_STACK_LOCATION(sp)
9D032A74  8FBA007C   LW K0, 124(SP)               290:   	lw			k0, portEPC_STACK_LOCATION(sp)
                                                  291:   
                                                  292:   	/* Remove stack frame. */
9D032A78  27BD0084   ADDIU SP, SP, 132            293:   	addiu		sp,	sp,	portCONTEXT_SIZE
                                                  294:   
9D032A7C  409B6000   MTC0 K1, Status              295:   	mtc0		k1, _CP0_STATUS
9D032A80  409A7000   MTC0 K0, EPC                 296:   	mtc0 		k0, _CP0_EPC
9D032A84  42000018   ERET                         297:   	eret
9D032A88  00000000   NOP                          298:   	nop
                                                  299:   
                                                  300:   	.end		vPortYieldISR
                                                  301:   
                                                  302:   
                                                  303:   
---  C:/Users/Diego/Documents/GitHub/pic32webFREERtos/Pic32Web.X/src/FreeRTOS/portable/MPLAB/PIC32MX/port.c
1:                   /*
2:                       FreeRTOS V7.5.3 - Copyright (C) 2013 Real Time Engineers Ltd. 
3:                       All rights reserved
4:                   
5:                       VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
6:                   
7:                       ***************************************************************************
8:                        *                                                                       *
9:                        *    FreeRTOS provides completely free yet professionally developed,    *
10:                       *    robust, strictly quality controlled, supported, and cross          *
11:                       *    platform software that has become a de facto standard.             *
12:                       *                                                                       *
13:                       *    Help yourself get started quickly and support the FreeRTOS         *
14:                       *    project by purchasing a FreeRTOS tutorial book, reference          *
15:                       *    manual, or both from: http://www.FreeRTOS.org/Documentation        *
16:                       *                                                                       *
17:                       *    Thank you!                                                         *
18:                       *                                                                       *
19:                      ***************************************************************************
20:                  
21:                      This file is part of the FreeRTOS distribution.
22:                  
23:                      FreeRTOS is free software; you can redistribute it and/or modify it under
24:                      the terms of the GNU General Public License (version 2) as published by the
25:                      Free Software Foundation >>!AND MODIFIED BY!<< the FreeRTOS exception.
26:                  
27:                      >>! NOTE: The modification to the GPL is included to allow you to distribute
28:                      >>! a combined work that includes FreeRTOS without being obliged to provide
29:                      >>! the source code for proprietary components outside of the FreeRTOS
30:                      >>! kernel.
31:                  
32:                      FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
33:                      WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
34:                      FOR A PARTICULAR PURPOSE.  Full license text is available from the following
35:                      link: http://www.freertos.org/a00114.html
36:                  
37:                      1 tab == 4 spaces!
38:                  
39:                      ***************************************************************************
40:                       *                                                                       *
41:                       *    Having a problem?  Start by reading the FAQ "My application does   *
42:                       *    not run, what could be wrong?"                                     *
43:                       *                                                                       *
44:                       *    http://www.FreeRTOS.org/FAQHelp.html                               *
45:                       *                                                                       *
46:                      ***************************************************************************
47:                  
48:                      http://www.FreeRTOS.org - Documentation, books, training, latest versions,
49:                      license and Real Time Engineers Ltd. contact details.
50:                  
51:                      http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
52:                      including FreeRTOS+Trace - an indispensable productivity tool, a DOS
53:                      compatible FAT file system, and our tiny thread aware UDP/IP stack.
54:                  
55:                      http://www.OpenRTOS.com - Real Time Engineers ltd license FreeRTOS to High
56:                      Integrity Systems to sell under the OpenRTOS brand.  Low cost OpenRTOS
57:                      licenses offer ticketed support, indemnification and middleware.
58:                  
59:                      http://www.SafeRTOS.com - High Integrity Systems also provide a safety
60:                      engineered and independently SIL3 certified version for use in safety and
61:                      mission critical applications that require provable dependability.
62:                  
63:                      1 tab == 4 spaces!
64:                  */
65:                  
66:                  /*-----------------------------------------------------------
67:                   * Implementation of functions defined in portable.h for the PIC32MX port.
68:                    *----------------------------------------------------------*/
69:                  
70:                  #ifndef __XC
71:                      #error This port is designed to work with XC32.  Please update your C compiler version.
72:                  #endif
73:                  
74:                  /* Scheduler include files. */
75:                  #include "FreeRTOS.h"
76:                  #include "task.h"
77:                  
78:                  /* Hardware specifics. */
79:                  #define portTIMER_PRESCALE	8
80:                  #define portPRESCALE_BITS	1
81:                  
82:                  /* Bits within various registers. */
83:                  #define portIE_BIT						( 0x00000001 )
84:                  #define portEXL_BIT						( 0x00000002 )
85:                  
86:                  /* Bits within the CAUSE register. */
87:                  #define portCORE_SW_0					( 0x00000100 )
88:                  #define portCORE_SW_1					( 0x00000200 )
89:                  
90:                  /* The EXL bit is set to ensure interrupts do not occur while the context of
91:                  the first task is being restored. */
92:                  #define portINITIAL_SR					( portIE_BIT | portEXL_BIT )
93:                  
94:                  #ifndef configTICK_INTERRUPT_VECTOR
95:                  	#define configTICK_INTERRUPT_VECTOR _TIMER_1_VECTOR
96:                  #endif
97:                  
98:                  /* Records the interrupt nesting depth.  This starts at one as it will be
99:                  decremented to 0 when the first task starts. */
100:                 volatile unsigned portBASE_TYPE uxInterruptNesting = 0x01;
101:                 
102:                 /* Stores the task stack pointer when a switch is made to use the system stack. */
103:                 unsigned portBASE_TYPE uxSavedTaskStackPointer = 0;
104:                 
105:                 /* The stack used by interrupt service routines that cause a context switch. */
106:                 portSTACK_TYPE xISRStack[ configISR_STACK_SIZE ] = { 0 };
107:                 
108:                 /* The top of stack value ensures there is enough space to store 6 registers on
109:                 the callers stack, as some functions seem to want to do this. */
110:                 const portSTACK_TYPE * const xISRStackTop = &( xISRStack[ configISR_STACK_SIZE - 7 ] );
111:                 
112:                 /*
113:                  * Place the prototype here to ensure the interrupt vector is correctly installed.
114:                  * Note that because the interrupt is written in assembly, the IPL setting in the
115:                  * following line of code has no effect.  The interrupt priority is set by the
116:                  * call to ConfigIntTimer1() in vApplicationSetupTickTimerInterrupt().
117:                  */
118:                 extern void __attribute__( (interrupt(ipl1), vector( configTICK_INTERRUPT_VECTOR ))) vPortTickInterruptHandler( void );
119:                 
120:                 /*
121:                  * The software interrupt handler that performs the yield.  Note that, because
122:                  * the interrupt is written in assembly, the IPL setting in the following line of
123:                  * code has no effect.  The interrupt priority is set by the call to
124:                  * mConfigIntCoreSW0() in xPortStartScheduler().
125:                  */
126:                 void __attribute__( (interrupt(ipl1), vector(_CORE_SOFTWARE_0_VECTOR))) vPortYieldISR( void );
127:                 
128:                 /*-----------------------------------------------------------*/
129:                 
130:                 /*
131:                  * See header file for description.
132:                  */
133:                 portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
134:                 {
9D033CA0  27BDFFF8   ADDIU SP, SP, -8
9D033CA4  AFBE0004   SW S8, 4(SP)
9D033CA8  03A0F021   ADDU S8, SP, ZERO
9D033CAC  AFC40008   SW A0, 8(S8)
9D033CB0  AFC5000C   SW A1, 12(S8)
9D033CB4  AFC60010   SW A2, 16(S8)
135:                 	/* Ensure byte alignment is maintained when leaving this function. */
136:                 	pxTopOfStack--;
9D033CB8  8FC20008   LW V0, 8(S8)
9D033CBC  2442FFFC   ADDIU V0, V0, -4
9D033CC0  AFC20008   SW V0, 8(S8)
137:                 
138:                 	*pxTopOfStack = (portSTACK_TYPE) 0xDEADBEEF;
9D033CC4  8FC20008   LW V0, 8(S8)
9D033CC8  3C03DEAD   LUI V1, -8531
9D033CCC  3463BEEF   ORI V1, V1, -16657
9D033CD0  AC430000   SW V1, 0(V0)
139:                 	pxTopOfStack--;
9D033CD4  8FC20008   LW V0, 8(S8)
9D033CD8  2442FFFC   ADDIU V0, V0, -4
9D033CDC  AFC20008   SW V0, 8(S8)
140:                 
141:                 	*pxTopOfStack = (portSTACK_TYPE) 0x12345678;	/* Word to which the stack pointer will be left pointing after context restore. */
9D033CE0  8FC20008   LW V0, 8(S8)
9D033CE4  3C031234   LUI V1, 4660
9D033CE8  34635678   ORI V1, V1, 22136
9D033CEC  AC430000   SW V1, 0(V0)
142:                 	pxTopOfStack--;
9D033CF0  8FC20008   LW V0, 8(S8)
9D033CF4  2442FFFC   ADDIU V0, V0, -4
9D033CF8  AFC20008   SW V0, 8(S8)
143:                 
144:                 	*pxTopOfStack = (portSTACK_TYPE) _CP0_GET_CAUSE();
9D033CFC  40036800   MFC0 V1, Cause
9D033D00  8FC20008   LW V0, 8(S8)
9D033D04  AC430000   SW V1, 0(V0)
145:                 	pxTopOfStack--;
9D033D08  8FC20008   LW V0, 8(S8)
9D033D0C  2442FFFC   ADDIU V0, V0, -4
9D033D10  AFC20008   SW V0, 8(S8)
146:                 
147:                 	*pxTopOfStack = (portSTACK_TYPE) portINITIAL_SR; /* CP0_STATUS */
9D033D14  8FC20008   LW V0, 8(S8)
9D033D18  24030003   ADDIU V1, ZERO, 3
9D033D1C  AC430000   SW V1, 0(V0)
148:                 	pxTopOfStack--;
9D033D20  8FC20008   LW V0, 8(S8)
9D033D24  2442FFFC   ADDIU V0, V0, -4
9D033D28  AFC20008   SW V0, 8(S8)
149:                 
150:                 	*pxTopOfStack = (portSTACK_TYPE) pxCode; 		/* CP0_EPC */
9D033D2C  8FC3000C   LW V1, 12(S8)
9D033D30  8FC20008   LW V0, 8(S8)
9D033D34  AC430000   SW V1, 0(V0)
151:                 	pxTopOfStack--;
9D033D38  8FC20008   LW V0, 8(S8)
9D033D3C  2442FFFC   ADDIU V0, V0, -4
9D033D40  AFC20008   SW V0, 8(S8)
152:                 
153:                 	*pxTopOfStack = (portSTACK_TYPE) NULL;  		/* ra */
9D033D44  8FC20008   LW V0, 8(S8)
9D033D48  AC400000   SW ZERO, 0(V0)
154:                 	pxTopOfStack -= 15;
9D033D4C  8FC20008   LW V0, 8(S8)
9D033D50  2442FFC4   ADDIU V0, V0, -60
9D033D54  AFC20008   SW V0, 8(S8)
155:                 
156:                 	*pxTopOfStack = (portSTACK_TYPE) pvParameters; /* Parameters to pass in */
9D033D58  8FC30010   LW V1, 16(S8)
9D033D5C  8FC20008   LW V0, 8(S8)
9D033D60  AC430000   SW V1, 0(V0)
157:                 	pxTopOfStack -= 14;
9D033D64  8FC20008   LW V0, 8(S8)
9D033D68  2442FFC8   ADDIU V0, V0, -56
9D033D6C  AFC20008   SW V0, 8(S8)
158:                 
159:                 	*pxTopOfStack = (portSTACK_TYPE) 0x00000000; 	/* critical nesting level - no longer used. */
9D033D70  8FC20008   LW V0, 8(S8)
9D033D74  AC400000   SW ZERO, 0(V0)
160:                 	pxTopOfStack--;
9D033D78  8FC20008   LW V0, 8(S8)
9D033D7C  2442FFFC   ADDIU V0, V0, -4
9D033D80  AFC20008   SW V0, 8(S8)
161:                 
162:                 	return pxTopOfStack;
9D033D84  8FC20008   LW V0, 8(S8)
163:                 }
9D033D88  03C0E821   ADDU SP, S8, ZERO
9D033D8C  8FBE0004   LW S8, 4(SP)
9D033D90  27BD0008   ADDIU SP, SP, 8
9D033D94  03E00008   JR RA
9D033D98  00000000   NOP
164:                 /*-----------------------------------------------------------*/
165:                 
166:                 /*
167:                  * Setup a timer for a regular tick.  This function uses peripheral timer 1.
168:                  * The function is declared weak so an application writer can use a different
169:                  * timer by redefining this implementation.  If a different timer is used then
170:                  * configTICK_INTERRUPT_VECTOR must also be defined in FreeRTOSConfig.h to
171:                  * ensure the RTOS provided tick interrupt handler is installed on the correct
172:                  * vector number.  When Timer 1 is used the vector number is defined as
173:                  * _TIMER_1_VECTOR.
174:                  */
175:                 __attribute__(( weak )) void vApplicationSetupTickTimerInterrupt( void )
176:                 {
9D033D9C  27BDFFF0   ADDIU SP, SP, -16
9D033DA0  AFBE000C   SW S8, 12(SP)
9D033DA4  03A0F021   ADDU S8, SP, ZERO
177:                 const unsigned long ulCompareMatch = ( (configPERIPHERAL_CLOCK_HZ / portTIMER_PRESCALE) / configTICK_RATE_HZ ) - 1;
9D033DA8  24021387   ADDIU V0, ZERO, 4999
9D033DAC  AFC20000   SW V0, 0(S8)
178:                 
179:                 	T1CON = 0x0000;
9D033DB0  3C02BF80   LUI V0, -16512
9D033DB4  AC400600   SW ZERO, 1536(V0)
180:                 	T1CONbits.TCKPS = portPRESCALE_BITS;
9D033DB8  3C03BF80   LUI V1, -16512
9D033DBC  8C620600   LW V0, 1536(V1)
9D033DC0  24040001   ADDIU A0, ZERO, 1
9D033DC4  7C822904   INS V0, A0, 4, 2
9D033DC8  AC620600   SW V0, 1536(V1)
181:                 	PR1 = ulCompareMatch;
9D033DCC  3C02BF80   LUI V0, -16512
9D033DD0  8FC30000   LW V1, 0(S8)
9D033DD4  AC430620   SW V1, 1568(V0)
182:                 	IPC1bits.T1IP = configKERNEL_INTERRUPT_PRIORITY;
9D033DD8  3C03BF88   LUI V1, -16504
9D033DDC  8C6210A0   LW V0, 4256(V1)
9D033DE0  24040001   ADDIU A0, ZERO, 1
9D033DE4  7C822084   INS V0, A0, 2, 3
9D033DE8  AC6210A0   SW V0, 4256(V1)
183:                 
184:                 	/* Clear the interrupt as a starting condition. */
185:                 	IFS0bits.T1IF = 0;
9D033DEC  3C03BF88   LUI V1, -16504
9D033DF0  8C621030   LW V0, 4144(V1)
9D033DF4  7C022104   INS V0, ZERO, 4, 1
9D033DF8  AC621030   SW V0, 4144(V1)
186:                 
187:                 	/* Enable the interrupt. */
188:                 	IEC0bits.T1IE = 1;
9D033DFC  3C03BF88   LUI V1, -16504
9D033E00  8C621060   LW V0, 4192(V1)
9D033E04  24040001   ADDIU A0, ZERO, 1
9D033E08  7C822104   INS V0, A0, 4, 1
9D033E0C  AC621060   SW V0, 4192(V1)
189:                 
190:                 	/* Start the timer. */
191:                 	T1CONbits.TON = 1;
9D033E10  3C03BF80   LUI V1, -16512
9D033E14  8C620600   LW V0, 1536(V1)
9D033E18  24040001   ADDIU A0, ZERO, 1
9D033E1C  7C827BC4   INS V0, A0, 15, 1
9D033E20  AC620600   SW V0, 1536(V1)
192:                 }
9D033E24  03C0E821   ADDU SP, S8, ZERO
9D033E28  8FBE000C   LW S8, 12(SP)
9D033E2C  27BD0010   ADDIU SP, SP, 16
9D033E30  03E00008   JR RA
9D033E34  00000000   NOP
193:                 /*-----------------------------------------------------------*/
194:                 
195:                 void vPortEndScheduler(void)
196:                 {
9D033E38  27BDFFF8   ADDIU SP, SP, -8
9D033E3C  AFBE0004   SW S8, 4(SP)
9D033E40  03A0F021   ADDU S8, SP, ZERO
197:                 	/* It is unlikely that the scheduler for the PIC port will get stopped
198:                 	once running.  If required disable the tick interrupt here, then return
199:                 	to xPortStartScheduler(). */
200:                 	for( ;; );
9D033E44  0B40CF91   J 0x9D033E44
9D033E48  00000000   NOP
201:                 }
202:                 /*-----------------------------------------------------------*/
203:                 
204:                 portBASE_TYPE xPortStartScheduler( void )
205:                 {
9D033E4C  27BDFFE8   ADDIU SP, SP, -24
9D033E50  AFBF0014   SW RA, 20(SP)
9D033E54  AFBE0010   SW S8, 16(SP)
9D033E58  03A0F021   ADDU S8, SP, ZERO
206:                 extern void vPortStartFirstTask( void );
207:                 extern void *pxCurrentTCB;
208:                 
209:                 	/* Clear the software interrupt flag. */
210:                 	IFS0CLR = _IFS0_CS0IF_MASK;
9D033E5C  3C02BF88   LUI V0, -16504
9D033E60  24030002   ADDIU V1, ZERO, 2
9D033E64  AC431034   SW V1, 4148(V0)
211:                 
212:                 	/* Set software timer priority. */
213:                 	IPC0CLR = _IPC0_CS0IP_MASK;
9D033E68  3C02BF88   LUI V0, -16504
9D033E6C  24031C00   ADDIU V1, ZERO, 7168
9D033E70  AC431094   SW V1, 4244(V0)
214:                 	IPC0SET = ( configKERNEL_INTERRUPT_PRIORITY << _IPC0_CS0IP_POSITION );
9D033E74  3C02BF88   LUI V0, -16504
9D033E78  24030400   ADDIU V1, ZERO, 1024
9D033E7C  AC431098   SW V1, 4248(V0)
215:                 
216:                 	/* Enable software interrupt. */
217:                 	IEC0CLR = _IEC0_CS0IE_MASK;
9D033E80  3C02BF88   LUI V0, -16504
9D033E84  24030002   ADDIU V1, ZERO, 2
9D033E88  AC431064   SW V1, 4196(V0)
218:                 	IEC0SET = 1 << _IEC0_CS0IE_POSITION;
9D033E8C  3C02BF88   LUI V0, -16504
9D033E90  24030002   ADDIU V1, ZERO, 2
9D033E94  AC431068   SW V1, 4200(V0)
219:                 
220:                 	/* Setup the timer to generate the tick.  Interrupts will have been
221:                 	disabled by the time we get here. */
222:                 	vApplicationSetupTickTimerInterrupt();
9D033E98  0F40CF67   JAL vApplicationSetupTickTimerInterrupt
9D033E9C  00000000   NOP
223:                 
224:                 	/* Kick off the highest priority task that has been created so far.
225:                 	Its stack location is loaded into uxSavedTaskStackPointer. */
226:                 	uxSavedTaskStackPointer = *( unsigned portBASE_TYPE * ) pxCurrentTCB;
9D033EA0  8F828094   LW V0, -32620(GP)
9D033EA4  8C420000   LW V0, 0(V0)
9D033EA8  AF82807C   SW V0, -32644(GP)
227:                 	vPortStartFirstTask();
9D033EAC  0F40CA00   JAL 0x9D032800
9D033EB0  00000000   NOP
228:                 
229:                 	/* Should never get here as the tasks will now be executing. */
230:                 	return pdFALSE;
9D033EB4  00001021   ADDU V0, ZERO, ZERO
231:                 }
9D033EB8  03C0E821   ADDU SP, S8, ZERO
9D033EBC  8FBF0014   LW RA, 20(SP)
9D033EC0  8FBE0010   LW S8, 16(SP)
9D033EC4  27BD0018   ADDIU SP, SP, 24
9D033EC8  03E00008   JR RA
9D033ECC  00000000   NOP
232:                 /*-----------------------------------------------------------*/
233:                 
234:                 void vPortIncrementTick( void )
235:                 {
9D033ED0  27BDFFE0   ADDIU SP, SP, -32
9D033ED4  AFBF001C   SW RA, 28(SP)
9D033ED8  AFBE0018   SW S8, 24(SP)
9D033EDC  03A0F021   ADDU S8, SP, ZERO
236:                 unsigned portBASE_TYPE uxSavedStatus;
237:                 
238:                 	uxSavedStatus = uxPortSetInterruptMaskFromISR();
9D033EE0  0F40CFD1   JAL uxPortSetInterruptMaskFromISR
9D033EE4  00000000   NOP
9D033EE8  AFC20010   SW V0, 16(S8)
239:                 	{
240:                 		if( xTaskIncrementTick() != pdFALSE )
9D033EEC  0F407EF4   JAL xTaskIncrementTick
9D033EF0  00000000   NOP
9D033EF4  10400007   BEQ V0, ZERO, 0x9D033F14
9D033EF8  00000000   NOP
241:                 		{
242:                 			/* Pend a context switch. */
243:                 			_CP0_BIS_CAUSE( portCORE_SW_0 );
9D033EFC  24020100   ADDIU V0, ZERO, 256
9D033F00  40036800   MFC0 V1, Cause
9D033F04  00000000   NOP
9D033F08  00621025   OR V0, V1, V0
9D033F0C  40826800   MTC0 V0, Cause
9D033F10  000000C0   EHB
244:                 		}
245:                 	}
246:                 	vPortClearInterruptMaskFromISR( uxSavedStatus );
9D033F14  8FC40010   LW A0, 16(S8)
9D033F18  0F40CFE4   JAL vPortClearInterruptMaskFromISR
9D033F1C  00000000   NOP
247:                 
248:                 	/* Clear timer 1 interrupt. */
249:                 	IFS0CLR = _IFS0_T1IF_MASK;
9D033F20  3C02BF88   LUI V0, -16504
9D033F24  24030010   ADDIU V1, ZERO, 16
9D033F28  AC431034   SW V1, 4148(V0)
250:                 }
9D033F2C  03C0E821   ADDU SP, S8, ZERO
9D033F30  8FBF001C   LW RA, 28(SP)
9D033F34  8FBE0018   LW S8, 24(SP)
9D033F38  27BD0020   ADDIU SP, SP, 32
9D033F3C  03E00008   JR RA
9D033F40  00000000   NOP
251:                 /*-----------------------------------------------------------*/
252:                 
253:                 unsigned portBASE_TYPE uxPortSetInterruptMaskFromISR( void )
254:                 {
9D033F44  27BDFFF0   ADDIU SP, SP, -16
9D033F48  AFBE000C   SW S8, 12(SP)
9D033F4C  03A0F021   ADDU S8, SP, ZERO
255:                 unsigned portBASE_TYPE uxSavedStatusRegister;
256:                 
257:                 	asm volatile ( "di" );
9D033F50  41606000   DI ZERO
258:                 	uxSavedStatusRegister = _CP0_GET_STATUS() | 0x01;
9D033F54  40026000   MFC0 V0, Status
9D033F58  34420001   ORI V0, V0, 1
9D033F5C  AFC20000   SW V0, 0(S8)
259:                 	/* This clears the IPL bits, then sets them to
260:                 	configMAX_SYSCALL_INTERRUPT_PRIORITY.  This function should not be called
261:                 	from an interrupt that has a priority above
262:                 	configMAX_SYSCALL_INTERRUPT_PRIORITY so, when used correctly, the action
263:                 	can only result in the IPL being unchanged or raised, and therefore never
264:                 	lowered. */
265:                 	_CP0_SET_STATUS( ( ( uxSavedStatusRegister & ( ~portALL_IPL_BITS ) ) ) | ( configMAX_SYSCALL_INTERRUPT_PRIORITY << portIPL_SHIFT ) );
9D033F60  8FC30000   LW V1, 0(S8)
9D033F64  3C02FFFF   LUI V0, -1
9D033F68  344203FF   ORI V0, V0, 1023
9D033F6C  00621024   AND V0, V1, V0
9D033F70  34420C00   ORI V0, V0, 3072
9D033F74  40826000   MTC0 V0, Status
9D033F78  000000C0   EHB
266:                 
267:                 	return uxSavedStatusRegister;
9D033F7C  8FC20000   LW V0, 0(S8)
268:                 }
9D033F80  03C0E821   ADDU SP, S8, ZERO
9D033F84  8FBE000C   LW S8, 12(SP)
9D033F88  03E00008   JR RA
9D033F8C  27BD0010   ADDIU SP, SP, 16
269:                 /*-----------------------------------------------------------*/
270:                 
271:                 void vPortClearInterruptMaskFromISR( unsigned portBASE_TYPE uxSavedStatusRegister )
272:                 {
9D033F90  27BDFFF8   ADDIU SP, SP, -8
9D033F94  AFBE0004   SW S8, 4(SP)
9D033F98  03A0F021   ADDU S8, SP, ZERO
9D033F9C  AFC40008   SW A0, 8(S8)
273:                 	_CP0_SET_STATUS( uxSavedStatusRegister );
9D033FA0  8FC20008   LW V0, 8(S8)
9D033FA4  40826000   MTC0 V0, Status
9D033FA8  000000C0   EHB
274:                 }
9D033FAC  03C0E821   ADDU SP, S8, ZERO
9D033FB0  8FBE0004   LW S8, 4(SP)
9D033FB4  27BD0008   ADDIU SP, SP, 8
9D033FB8  03E00008   JR RA
9D033FBC  00000000   NOP
275:                 /*-----------------------------------------------------------*/
276:                 
277:                 
278:                 
279:                 
280:                 
---  C:/Users/Diego/Documents/GitHub/pic32webFREERtos/Pic32Web.X/src/FreeRTOS/list.c  -------------------
1:                   /*
2:                       FreeRTOS V7.5.3 - Copyright (C) 2013 Real Time Engineers Ltd. 
3:                       All rights reserved
4:                   
5:                       VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
6:                   
7:                       ***************************************************************************
8:                        *                                                                       *
9:                        *    FreeRTOS provides completely free yet professionally developed,    *
10:                       *    robust, strictly quality controlled, supported, and cross          *
11:                       *    platform software that has become a de facto standard.             *
12:                       *                                                                       *
13:                       *    Help yourself get started quickly and support the FreeRTOS         *
14:                       *    project by purchasing a FreeRTOS tutorial book, reference          *
15:                       *    manual, or both from: http://www.FreeRTOS.org/Documentation        *
16:                       *                                                                       *
17:                       *    Thank you!                                                         *
18:                       *                                                                       *
19:                      ***************************************************************************
20:                  
21:                      This file is part of the FreeRTOS distribution.
22:                  
23:                      FreeRTOS is free software; you can redistribute it and/or modify it under
24:                      the terms of the GNU General Public License (version 2) as published by the
25:                      Free Software Foundation >>!AND MODIFIED BY!<< the FreeRTOS exception.
26:                  
27:                      >>! NOTE: The modification to the GPL is included to allow you to distribute
28:                      >>! a combined work that includes FreeRTOS without being obliged to provide
29:                      >>! the source code for proprietary components outside of the FreeRTOS
30:                      >>! kernel.
31:                  
32:                      FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
33:                      WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
34:                      FOR A PARTICULAR PURPOSE.  Full license text is available from the following
35:                      link: http://www.freertos.org/a00114.html
36:                  
37:                      1 tab == 4 spaces!
38:                  
39:                      ***************************************************************************
40:                       *                                                                       *
41:                       *    Having a problem?  Start by reading the FAQ "My application does   *
42:                       *    not run, what could be wrong?"                                     *
43:                       *                                                                       *
44:                       *    http://www.FreeRTOS.org/FAQHelp.html                               *
45:                       *                                                                       *
46:                      ***************************************************************************
47:                  
48:                      http://www.FreeRTOS.org - Documentation, books, training, latest versions,
49:                      license and Real Time Engineers Ltd. contact details.
50:                  
51:                      http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
52:                      including FreeRTOS+Trace - an indispensable productivity tool, a DOS
53:                      compatible FAT file system, and our tiny thread aware UDP/IP stack.
54:                  
55:                      http://www.OpenRTOS.com - Real Time Engineers ltd license FreeRTOS to High
56:                      Integrity Systems to sell under the OpenRTOS brand.  Low cost OpenRTOS
57:                      licenses offer ticketed support, indemnification and middleware.
58:                  
59:                      http://www.SafeRTOS.com - High Integrity Systems also provide a safety
60:                      engineered and independently SIL3 certified version for use in safety and
61:                      mission critical applications that require provable dependability.
62:                  
63:                      1 tab == 4 spaces!
64:                  */
65:                  
66:                  
67:                  #include <stdlib.h>
68:                  #include "FreeRTOS.h"
69:                  #include "list.h"
70:                  
71:                  /*-----------------------------------------------------------
72:                   * PUBLIC LIST API documented in list.h
73:                   *----------------------------------------------------------*/
74:                  
75:                  void vListInitialise( xList * const pxList )
76:                  {
9D0342AC  27BDFFF8   ADDIU SP, SP, -8
9D0342B0  AFBE0004   SW S8, 4(SP)
9D0342B4  03A0F021   ADDU S8, SP, ZERO
9D0342B8  AFC40008   SW A0, 8(S8)
77:                  	/* The list structure contains a list item which is used to mark the
78:                  	end of the list.  To initialise the list the list end is inserted
79:                  	as the only list entry. */
80:                  	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
9D0342BC  8FC20008   LW V0, 8(S8)
9D0342C0  24420008   ADDIU V0, V0, 8
9D0342C4  00401821   ADDU V1, V0, ZERO
9D0342C8  8FC20008   LW V0, 8(S8)
9D0342CC  AC430004   SW V1, 4(V0)
81:                  
82:                  	/* The list end value is the highest possible value in the list to
83:                  	ensure it remains at the end of the list. */
84:                  	pxList->xListEnd.xItemValue = portMAX_DELAY;
9D0342D0  8FC20008   LW V0, 8(S8)
9D0342D4  2403FFFF   ADDIU V1, ZERO, -1
9D0342D8  AC430008   SW V1, 8(V0)
85:                  
86:                  	/* The list end next and previous pointers point to itself so we know
87:                  	when the list is empty. */
88:                  	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
9D0342DC  8FC20008   LW V0, 8(S8)
9D0342E0  24420008   ADDIU V0, V0, 8
9D0342E4  00401821   ADDU V1, V0, ZERO
9D0342E8  8FC20008   LW V0, 8(S8)
9D0342EC  AC43000C   SW V1, 12(V0)
89:                  	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
9D0342F0  8FC20008   LW V0, 8(S8)
9D0342F4  24420008   ADDIU V0, V0, 8
9D0342F8  00401821   ADDU V1, V0, ZERO
9D0342FC  8FC20008   LW V0, 8(S8)
9D034300  AC430010   SW V1, 16(V0)
90:                  
91:                  	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
9D034304  8FC20008   LW V0, 8(S8)
9D034308  AC400000   SW ZERO, 0(V0)
92:                  }
9D03430C  03C0E821   ADDU SP, S8, ZERO
9D034310  8FBE0004   LW S8, 4(SP)
9D034314  27BD0008   ADDIU SP, SP, 8
9D034318  03E00008   JR RA
9D03431C  00000000   NOP
93:                  /*-----------------------------------------------------------*/
94:                  
95:                  void vListInitialiseItem( xListItem * const pxItem )
96:                  {
9D034320  27BDFFF8   ADDIU SP, SP, -8
9D034324  AFBE0004   SW S8, 4(SP)
9D034328  03A0F021   ADDU S8, SP, ZERO
9D03432C  AFC40008   SW A0, 8(S8)
97:                  	/* Make sure the list item is not recorded as being on a list. */
98:                  	pxItem->pvContainer = NULL;
9D034330  8FC20008   LW V0, 8(S8)
9D034334  AC400010   SW ZERO, 16(V0)
99:                  }
9D034338  03C0E821   ADDU SP, S8, ZERO
9D03433C  8FBE0004   LW S8, 4(SP)
9D034340  27BD0008   ADDIU SP, SP, 8
9D034344  03E00008   JR RA
9D034348  00000000   NOP
100:                 /*-----------------------------------------------------------*/
101:                 
102:                 void vListInsertEnd( xList * const pxList, xListItem * const pxNewListItem )
103:                 {
9D03434C  27BDFFF0   ADDIU SP, SP, -16
9D034350  AFBE000C   SW S8, 12(SP)
9D034354  03A0F021   ADDU S8, SP, ZERO
9D034358  AFC40010   SW A0, 16(S8)
9D03435C  AFC50014   SW A1, 20(S8)
104:                 xListItem * pxIndex;
105:                 
106:                 	/* Insert a new list item into pxList, but rather than sort the list,
107:                 	makes the new list item the last item to be removed by a call to
108:                 	pvListGetOwnerOfNextEntry. */
109:                 	pxIndex = pxList->pxIndex;
9D034360  8FC20010   LW V0, 16(S8)
9D034364  8C420004   LW V0, 4(V0)
9D034368  AFC20000   SW V0, 0(S8)
110:                 
111:                 	pxNewListItem->pxNext = pxIndex;
9D03436C  8FC20014   LW V0, 20(S8)
9D034370  8FC30000   LW V1, 0(S8)
9D034374  AC430004   SW V1, 4(V0)
112:                 	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
9D034378  8FC20000   LW V0, 0(S8)
9D03437C  8C430008   LW V1, 8(V0)
9D034380  8FC20014   LW V0, 20(S8)
9D034384  AC430008   SW V1, 8(V0)
113:                 	pxIndex->pxPrevious->pxNext = pxNewListItem;
9D034388  8FC20000   LW V0, 0(S8)
9D03438C  8C420008   LW V0, 8(V0)
9D034390  8FC30014   LW V1, 20(S8)
9D034394  AC430004   SW V1, 4(V0)
114:                 	pxIndex->pxPrevious = pxNewListItem;
9D034398  8FC20000   LW V0, 0(S8)
9D03439C  8FC30014   LW V1, 20(S8)
9D0343A0  AC430008   SW V1, 8(V0)
115:                 
116:                 	/* Remember which list the item is in. */
117:                 	pxNewListItem->pvContainer = ( void * ) pxList;
9D0343A4  8FC20014   LW V0, 20(S8)
9D0343A8  8FC30010   LW V1, 16(S8)
9D0343AC  AC430010   SW V1, 16(V0)
118:                 
119:                 	( pxList->uxNumberOfItems )++;
9D0343B0  8FC20010   LW V0, 16(S8)
9D0343B4  8C420000   LW V0, 0(V0)
9D0343B8  24430001   ADDIU V1, V0, 1
9D0343BC  8FC20010   LW V0, 16(S8)
9D0343C0  AC430000   SW V1, 0(V0)
120:                 }
9D0343C4  03C0E821   ADDU SP, S8, ZERO
9D0343C8  8FBE000C   LW S8, 12(SP)
9D0343CC  27BD0010   ADDIU SP, SP, 16
9D0343D0  03E00008   JR RA
9D0343D4  00000000   NOP
121:                 /*-----------------------------------------------------------*/
122:                 
123:                 void vListInsert( xList * const pxList, xListItem * const pxNewListItem )
124:                 {
9D0343D8  27BDFFF0   ADDIU SP, SP, -16
9D0343DC  AFBE000C   SW S8, 12(SP)
9D0343E0  03A0F021   ADDU S8, SP, ZERO
9D0343E4  AFC40010   SW A0, 16(S8)
9D0343E8  AFC50014   SW A1, 20(S8)
125:                 xListItem *pxIterator;
126:                 portTickType xValueOfInsertion;
127:                 
128:                 	/* Insert the new list item into the list, sorted in ulListItem order. */
129:                 	xValueOfInsertion = pxNewListItem->xItemValue;
9D0343EC  8FC20014   LW V0, 20(S8)
9D0343F0  8C420000   LW V0, 0(V0)
9D0343F4  AFC20004   SW V0, 4(S8)
130:                 
131:                 	/* If the list already contains a list item with the same item value then
132:                 	the new list item should be placed after it.  This ensures that TCB's which
133:                 	are stored in ready lists (all of which have the same ulListItem value)
134:                 	get an equal share of the CPU.  However, if the xItemValue is the same as
135:                 	the back marker the iteration loop below will not end.  This means we need
136:                 	to guard against this by checking the value first and modifying the
137:                 	algorithm slightly if necessary. */
138:                 	if( xValueOfInsertion == portMAX_DELAY )
9D0343F8  8FC30004   LW V1, 4(S8)
9D0343FC  2402FFFF   ADDIU V0, ZERO, -1
9D034400  14620006   BNE V1, V0, 0x9D03441C
9D034404  00000000   NOP
139:                 	{
140:                 		pxIterator = pxList->xListEnd.pxPrevious;
9D034408  8FC20010   LW V0, 16(S8)
9D03440C  8C420010   LW V0, 16(V0)
9D034410  AFC20000   SW V0, 0(S8)
9D034414  0B40D116   J 0x9D034458
9D034418  00000000   NOP
141:                 	}
142:                 	else
143:                 	{
144:                 		/* *** NOTE ***********************************************************
145:                 		If you find your application is crashing here then likely causes are:
146:                 			1) Stack overflow -
147:                 			   see http://www.freertos.org/Stacks-and-stack-overflow-checking.html
148:                 			2) Incorrect interrupt priority assignment, especially on Cortex-M3
149:                 			   parts where numerically high priority values denote low actual
150:                 			   interrupt priories, which can seem counter intuitive.  See
151:                 			   configMAX_SYSCALL_INTERRUPT_PRIORITY on http://www.freertos.org/a00110.html
152:                 			3) Calling an API function from within a critical section or when
153:                 			   the scheduler is suspended, or calling an API function that does
154:                 			   not end in "FromISR" from an interrupt.
155:                 			4) Using a queue or semaphore before it has been initialised or
156:                 			   before the scheduler has been started (are interrupts firing
157:                 			   before vTaskStartScheduler() has been called?).
158:                 		See http://www.freertos.org/FAQHelp.html for more tips.
159:                 		**********************************************************************/
160:                 
161:                 		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
9D03441C  8FC20010   LW V0, 16(S8)
9D034420  24420008   ADDIU V0, V0, 8
9D034424  AFC20000   SW V0, 0(S8)
9D034428  0B40D10F   J 0x9D03443C
9D03442C  00000000   NOP
9D034430  8FC20000   LW V0, 0(S8)
9D034434  8C420004   LW V0, 4(V0)
9D034438  AFC20000   SW V0, 0(S8)
9D03443C  8FC20000   LW V0, 0(S8)
9D034440  8C420004   LW V0, 4(V0)
9D034444  8C430000   LW V1, 0(V0)
9D034448  8FC20004   LW V0, 4(S8)
9D03444C  0043102B   SLTU V0, V0, V1
9D034450  1040FFF7   BEQ V0, ZERO, 0x9D034430
9D034454  00000000   NOP
162:                 		{
163:                 			/* There is nothing to do here, we are just iterating to the
164:                 			wanted insertion position. */
165:                 		}
166:                 	}
167:                 
168:                 	pxNewListItem->pxNext = pxIterator->pxNext;
9D034458  8FC20000   LW V0, 0(S8)
9D03445C  8C430004   LW V1, 4(V0)
9D034460  8FC20014   LW V0, 20(S8)
9D034464  AC430004   SW V1, 4(V0)
169:                 	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
9D034468  8FC20014   LW V0, 20(S8)
9D03446C  8C420004   LW V0, 4(V0)
9D034470  8FC30014   LW V1, 20(S8)
9D034474  AC430008   SW V1, 8(V0)
170:                 	pxNewListItem->pxPrevious = pxIterator;
9D034478  8FC20014   LW V0, 20(S8)
9D03447C  8FC30000   LW V1, 0(S8)
9D034480  AC430008   SW V1, 8(V0)
171:                 	pxIterator->pxNext = pxNewListItem;
9D034484  8FC20000   LW V0, 0(S8)
9D034488  8FC30014   LW V1, 20(S8)
9D03448C  AC430004   SW V1, 4(V0)
172:                 
173:                 	/* Remember which list the item is in.  This allows fast removal of the
174:                 	item later. */
175:                 	pxNewListItem->pvContainer = ( void * ) pxList;
9D034490  8FC20014   LW V0, 20(S8)
9D034494  8FC30010   LW V1, 16(S8)
9D034498  AC430010   SW V1, 16(V0)
176:                 
177:                 	( pxList->uxNumberOfItems )++;
9D03449C  8FC20010   LW V0, 16(S8)
9D0344A0  8C420000   LW V0, 0(V0)
9D0344A4  24430001   ADDIU V1, V0, 1
9D0344A8  8FC20010   LW V0, 16(S8)
9D0344AC  AC430000   SW V1, 0(V0)
178:                 }
9D0344B0  03C0E821   ADDU SP, S8, ZERO
9D0344B4  8FBE000C   LW S8, 12(SP)
9D0344B8  27BD0010   ADDIU SP, SP, 16
9D0344BC  03E00008   JR RA
9D0344C0  00000000   NOP
179:                 /*-----------------------------------------------------------*/
180:                 
181:                 unsigned portBASE_TYPE uxListRemove( xListItem * const pxItemToRemove )
182:                 {
9D0344C4  27BDFFF0   ADDIU SP, SP, -16
9D0344C8  AFBE000C   SW S8, 12(SP)
9D0344CC  03A0F021   ADDU S8, SP, ZERO
9D0344D0  AFC40010   SW A0, 16(S8)
183:                 xList * pxList;
184:                 
185:                 	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
9D0344D4  8FC20010   LW V0, 16(S8)
9D0344D8  8C420004   LW V0, 4(V0)
9D0344DC  8FC30010   LW V1, 16(S8)
9D0344E0  8C630008   LW V1, 8(V1)
9D0344E4  AC430008   SW V1, 8(V0)
186:                 	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
9D0344E8  8FC20010   LW V0, 16(S8)
9D0344EC  8C420008   LW V0, 8(V0)
9D0344F0  8FC30010   LW V1, 16(S8)
9D0344F4  8C630004   LW V1, 4(V1)
9D0344F8  AC430004   SW V1, 4(V0)
187:                 
188:                 	/* The list item knows which list it is in.  Obtain the list from the list
189:                 	item. */
190:                 	pxList = ( xList * ) pxItemToRemove->pvContainer;
9D0344FC  8FC20010   LW V0, 16(S8)
9D034500  8C420010   LW V0, 16(V0)
9D034504  AFC20000   SW V0, 0(S8)
191:                 
192:                 	/* Make sure the index is left pointing to a valid item. */
193:                 	if( pxList->pxIndex == pxItemToRemove )
9D034508  8FC20000   LW V0, 0(S8)
9D03450C  8C430004   LW V1, 4(V0)
9D034510  8FC20010   LW V0, 16(S8)
9D034514  14620005   BNE V1, V0, 0x9D03452C
9D034518  00000000   NOP
194:                 	{
195:                 		pxList->pxIndex = pxItemToRemove->pxPrevious;
9D03451C  8FC20010   LW V0, 16(S8)
9D034520  8C430008   LW V1, 8(V0)
9D034524  8FC20000   LW V0, 0(S8)
9D034528  AC430004   SW V1, 4(V0)
196:                 	}
197:                 
198:                 	pxItemToRemove->pvContainer = NULL;
9D03452C  8FC20010   LW V0, 16(S8)
9D034530  AC400010   SW ZERO, 16(V0)
199:                 	( pxList->uxNumberOfItems )--;
9D034534  8FC20000   LW V0, 0(S8)
9D034538  8C420000   LW V0, 0(V0)
9D03453C  2443FFFF   ADDIU V1, V0, -1
9D034540  8FC20000   LW V0, 0(S8)
9D034544  AC430000   SW V1, 0(V0)
200:                 
201:                 	return pxList->uxNumberOfItems;
9D034548  8FC20000   LW V0, 0(S8)
9D03454C  8C420000   LW V0, 0(V0)
202:                 }
9D034550  03C0E821   ADDU SP, S8, ZERO
9D034554  8FBE000C   LW S8, 12(SP)
9D034558  27BD0010   ADDIU SP, SP, 16
9D03455C  03E00008   JR RA
9D034560  00000000   NOP
203:                 /*-----------------------------------------------------------*/
204:                 
---  C:/Users/Diego/Documents/GitHub/pic32webFREERtos/Pic32Web.X/src/FreeRTOS/croutine.c  ---------------
1:                   /*
2:                       FreeRTOS V7.5.3 - Copyright (C) 2013 Real Time Engineers Ltd. 
3:                       All rights reserved
4:                   
5:                       VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
6:                   
7:                       ***************************************************************************
8:                        *                                                                       *
9:                        *    FreeRTOS provides completely free yet professionally developed,    *
10:                       *    robust, strictly quality controlled, supported, and cross          *
11:                       *    platform software that has become a de facto standard.             *
12:                       *                                                                       *
13:                       *    Help yourself get started quickly and support the FreeRTOS         *
14:                       *    project by purchasing a FreeRTOS tutorial book, reference          *
15:                       *    manual, or both from: http://www.FreeRTOS.org/Documentation        *
16:                       *                                                                       *
17:                       *    Thank you!                                                         *
18:                       *                                                                       *
19:                      ***************************************************************************
20:                  
21:                      This file is part of the FreeRTOS distribution.
22:                  
23:                      FreeRTOS is free software; you can redistribute it and/or modify it under
24:                      the terms of the GNU General Public License (version 2) as published by the
25:                      Free Software Foundation >>!AND MODIFIED BY!<< the FreeRTOS exception.
26:                  
27:                      >>! NOTE: The modification to the GPL is included to allow you to distribute
28:                      >>! a combined work that includes FreeRTOS without being obliged to provide
29:                      >>! the source code for proprietary components outside of the FreeRTOS
30:                      >>! kernel.
31:                  
32:                      FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
33:                      WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
34:                      FOR A PARTICULAR PURPOSE.  Full license text is available from the following
35:                      link: http://www.freertos.org/a00114.html
36:                  
37:                      1 tab == 4 spaces!
38:                  
39:                      ***************************************************************************
40:                       *                                                                       *
41:                       *    Having a problem?  Start by reading the FAQ "My application does   *
42:                       *    not run, what could be wrong?"                                     *
43:                       *                                                                       *
44:                       *    http://www.FreeRTOS.org/FAQHelp.html                               *
45:                       *                                                                       *
46:                      ***************************************************************************
47:                  
48:                      http://www.FreeRTOS.org - Documentation, books, training, latest versions,
49:                      license and Real Time Engineers Ltd. contact details.
50:                  
51:                      http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
52:                      including FreeRTOS+Trace - an indispensable productivity tool, a DOS
53:                      compatible FAT file system, and our tiny thread aware UDP/IP stack.
54:                  
55:                      http://www.OpenRTOS.com - Real Time Engineers ltd license FreeRTOS to High
56:                      Integrity Systems to sell under the OpenRTOS brand.  Low cost OpenRTOS
57:                      licenses offer ticketed support, indemnification and middleware.
58:                  
59:                      http://www.SafeRTOS.com - High Integrity Systems also provide a safety
60:                      engineered and independently SIL3 certified version for use in safety and
61:                      mission critical applications that require provable dependability.
62:                  
63:                      1 tab == 4 spaces!
64:                  */
65:                  
66:                  #include "FreeRTOS.h"
67:                  #include "task.h"
68:                  #include "croutine.h"
69:                  
70:                  /*
71:                   * Some kernel aware debuggers require data to be viewed to be global, rather
72:                   * than file scope.
73:                   */
74:                  #ifdef portREMOVE_STATIC_QUALIFIER
75:                  	#define static
76:                  #endif
77:                  
78:                  
79:                  /* Lists for ready and blocked co-routines. --------------------*/
80:                  static xList pxReadyCoRoutineLists[ configMAX_CO_ROUTINE_PRIORITIES ];	/*< Prioritised ready co-routines. */
81:                  static xList xDelayedCoRoutineList1;									/*< Delayed co-routines. */
82:                  static xList xDelayedCoRoutineList2;									/*< Delayed co-routines (two lists are used - one for delays that have overflowed the current tick count. */
83:                  static xList * pxDelayedCoRoutineList;									/*< Points to the delayed co-routine list currently being used. */
84:                  static xList * pxOverflowDelayedCoRoutineList;							/*< Points to the delayed co-routine list currently being used to hold co-routines that have overflowed the current tick count. */
85:                  static xList xPendingReadyCoRoutineList;								/*< Holds co-routines that have been readied by an external event.  They cannot be added directly to the ready lists as the ready lists cannot be accessed by interrupts. */
86:                  
87:                  /* Other file private variables. --------------------------------*/
88:                  corCRCB * pxCurrentCoRoutine = NULL;
89:                  static unsigned portBASE_TYPE uxTopCoRoutineReadyPriority = 0;
90:                  static portTickType xCoRoutineTickCount = 0, xLastTickCount = 0, xPassedTicks = 0;
91:                  
92:                  /* The initial state of the co-routine when it is created. */
93:                  #define corINITIAL_STATE	( 0 )
94:                  
95:                  /*
96:                   * Place the co-routine represented by pxCRCB into the appropriate ready queue
97:                   * for the priority.  It is inserted at the end of the list.
98:                   *
99:                   * This macro accesses the co-routine ready lists and therefore must not be
100:                  * used from within an ISR.
101:                  */
102:                 #define prvAddCoRoutineToReadyQueue( pxCRCB )																		\
103:                 {																													\
104:                 	if( pxCRCB->uxPriority > uxTopCoRoutineReadyPriority )															\
105:                 	{																												\
106:                 		uxTopCoRoutineReadyPriority = pxCRCB->uxPriority;															\
107:                 	}																												\
108:                 	vListInsertEnd( ( xList * ) &( pxReadyCoRoutineLists[ pxCRCB->uxPriority ] ), &( pxCRCB->xGenericListItem ) );	\
109:                 }
110:                 
111:                 /*
112:                  * Utility to ready all the lists used by the scheduler.  This is called
113:                  * automatically upon the creation of the first co-routine.
114:                  */
115:                 static void prvInitialiseCoRoutineLists( void );
116:                 
117:                 /*
118:                  * Co-routines that are readied by an interrupt cannot be placed directly into
119:                  * the ready lists (there is no mutual exclusion).  Instead they are placed in
120:                  * in the pending ready list in order that they can later be moved to the ready
121:                  * list by the co-routine scheduler.
122:                  */
123:                 static void prvCheckPendingReadyList( void );
124:                 
125:                 /*
126:                  * Macro that looks at the list of co-routines that are currently delayed to
127:                  * see if any require waking.
128:                  *
129:                  * Co-routines are stored in the queue in the order of their wake time -
130:                  * meaning once one co-routine has been found whose timer has not expired
131:                  * we need not look any further down the list.
132:                  */
133:                 static void prvCheckDelayedList( void );
134:                 
135:                 /*-----------------------------------------------------------*/
136:                 
137:                 signed portBASE_TYPE xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, unsigned portBASE_TYPE uxPriority, unsigned portBASE_TYPE uxIndex )
138:                 {
9D02DE9C  27BDFFE0   ADDIU SP, SP, -32
9D02DEA0  AFBF001C   SW RA, 28(SP)
9D02DEA4  AFBE0018   SW S8, 24(SP)
9D02DEA8  03A0F021   ADDU S8, SP, ZERO
9D02DEAC  AFC40020   SW A0, 32(S8)
9D02DEB0  AFC50024   SW A1, 36(S8)
9D02DEB4  AFC60028   SW A2, 40(S8)
139:                 signed portBASE_TYPE xReturn;
140:                 corCRCB *pxCoRoutine;
141:                 
142:                 	/* Allocate the memory that will store the co-routine control block. */
143:                 	pxCoRoutine = ( corCRCB * ) pvPortMalloc( sizeof( corCRCB ) );
9D02DEB8  24040038   ADDIU A0, ZERO, 56
9D02DEBC  0F40D1D2   JAL pvPortMalloc
9D02DEC0  00000000   NOP
9D02DEC4  AFC20014   SW V0, 20(S8)
144:                 	if( pxCoRoutine )
9D02DEC8  8FC20014   LW V0, 20(S8)
9D02DECC  10400048   BEQ V0, ZERO, 0x9D02DFF0
9D02DED0  00000000   NOP
145:                 	{
146:                 		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
147:                 		be created and the co-routine data structures need initialising. */
148:                 		if( pxCurrentCoRoutine == NULL )
9D02DED4  8F828080   LW V0, -32640(GP)
9D02DED8  14400005   BNE V0, ZERO, 0x9D02DEF0
9D02DEDC  00000000   NOP
149:                 		{
150:                 			pxCurrentCoRoutine = pxCoRoutine;
9D02DEE0  8FC20014   LW V0, 20(S8)
9D02DEE4  AF828080   SW V0, -32640(GP)
151:                 			prvInitialiseCoRoutineLists();
9D02DEE8  0F40B94C   JAL prvInitialiseCoRoutineLists
9D02DEEC  00000000   NOP
152:                 		}
153:                 
154:                 		/* Check the priority is within limits. */
155:                 		if( uxPriority >= configMAX_CO_ROUTINE_PRIORITIES )
9D02DEF0  8FC20024   LW V0, 36(S8)
9D02DEF4  2C420002   SLTIU V0, V0, 2
9D02DEF8  14400003   BNE V0, ZERO, 0x9D02DF08
9D02DEFC  00000000   NOP
156:                 		{
157:                 			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
9D02DF00  24020001   ADDIU V0, ZERO, 1
9D02DF04  AFC20024   SW V0, 36(S8)
158:                 		}
159:                 
160:                 		/* Fill out the co-routine control block from the function parameters. */
161:                 		pxCoRoutine->uxState = corINITIAL_STATE;
9D02DF08  8FC20014   LW V0, 20(S8)
9D02DF0C  A4400034   SH ZERO, 52(V0)
162:                 		pxCoRoutine->uxPriority = uxPriority;
9D02DF10  8FC20014   LW V0, 20(S8)
9D02DF14  8FC30024   LW V1, 36(S8)
9D02DF18  AC43002C   SW V1, 44(V0)
163:                 		pxCoRoutine->uxIndex = uxIndex;
9D02DF1C  8FC20014   LW V0, 20(S8)
9D02DF20  8FC30028   LW V1, 40(S8)
9D02DF24  AC430030   SW V1, 48(V0)
164:                 		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
9D02DF28  8FC20014   LW V0, 20(S8)
9D02DF2C  8FC30020   LW V1, 32(S8)
9D02DF30  AC430000   SW V1, 0(V0)
165:                 
166:                 		/* Initialise all the other co-routine control block parameters. */
167:                 		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
9D02DF34  8FC20014   LW V0, 20(S8)
9D02DF38  24420004   ADDIU V0, V0, 4
9D02DF3C  00402021   ADDU A0, V0, ZERO
9D02DF40  0F40D0C8   JAL vListInitialiseItem
9D02DF44  00000000   NOP
168:                 		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
9D02DF48  8FC20014   LW V0, 20(S8)
9D02DF4C  24420018   ADDIU V0, V0, 24
9D02DF50  00402021   ADDU A0, V0, ZERO
9D02DF54  0F40D0C8   JAL vListInitialiseItem
9D02DF58  00000000   NOP
169:                 
170:                 		/* Set the co-routine control block as a link back from the xListItem.
171:                 		This is so we can get back to the containing CRCB from a generic item
172:                 		in a list. */
173:                 		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
9D02DF5C  8FC20014   LW V0, 20(S8)
9D02DF60  8FC30014   LW V1, 20(S8)
9D02DF64  AC430010   SW V1, 16(V0)
174:                 		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
9D02DF68  8FC20014   LW V0, 20(S8)
9D02DF6C  8FC30014   LW V1, 20(S8)
9D02DF70  AC430024   SW V1, 36(V0)
175:                 
176:                 		/* Event lists are always in priority order. */
177:                 		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
9D02DF74  24030005   ADDIU V1, ZERO, 5
9D02DF78  8FC20024   LW V0, 36(S8)
9D02DF7C  00621823   SUBU V1, V1, V0
9D02DF80  8FC20014   LW V0, 20(S8)
9D02DF84  AC430018   SW V1, 24(V0)
178:                 
179:                 		/* Now the co-routine has been initialised it can be added to the ready
180:                 		list at the correct priority. */
181:                 		prvAddCoRoutineToReadyQueue( pxCoRoutine );
9D02DF88  8FC20014   LW V0, 20(S8)
9D02DF8C  8C43002C   LW V1, 44(V0)
9D02DF90  8F828084   LW V0, -32636(GP)
9D02DF94  0043102B   SLTU V0, V0, V1
9D02DF98  10400004   BEQ V0, ZERO, 0x9D02DFAC
9D02DF9C  00000000   NOP
9D02DFA0  8FC20014   LW V0, 20(S8)
9D02DFA4  8C42002C   LW V0, 44(V0)
9D02DFA8  AF828084   SW V0, -32636(GP)
9D02DFAC  8FC20014   LW V0, 20(S8)
9D02DFB0  8C43002C   LW V1, 44(V0)
9D02DFB4  24020014   ADDIU V0, ZERO, 20
9D02DFB8  70621802   MUL V1, V1, V0
9D02DFBC  3C02A000   LUI V0, -24576
9D02DFC0  24420458   ADDIU V0, V0, 1112
9D02DFC4  00621821   ADDU V1, V1, V0
9D02DFC8  8FC20014   LW V0, 20(S8)
9D02DFCC  24420004   ADDIU V0, V0, 4
9D02DFD0  00602021   ADDU A0, V1, ZERO
9D02DFD4  00402821   ADDU A1, V0, ZERO
9D02DFD8  0F40D0D3   JAL vListInsertEnd
9D02DFDC  00000000   NOP
182:                 
183:                 		xReturn = pdPASS;
9D02DFE0  24020001   ADDIU V0, ZERO, 1
9D02DFE4  AFC20010   SW V0, 16(S8)
9D02DFE8  0B40B7FE   J 0x9D02DFF8
9D02DFEC  00000000   NOP
184:                 	}
185:                 	else
186:                 	{
187:                 		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
9D02DFF0  2402FFFF   ADDIU V0, ZERO, -1
9D02DFF4  AFC20010   SW V0, 16(S8)
188:                 	}
189:                 
190:                 	return xReturn;
9D02DFF8  8FC20010   LW V0, 16(S8)
191:                 }
9D02DFFC  03C0E821   ADDU SP, S8, ZERO
9D02E000  8FBF001C   LW RA, 28(SP)
9D02E004  8FBE0018   LW S8, 24(SP)
9D02E008  27BD0020   ADDIU SP, SP, 32
9D02E00C  03E00008   JR RA
9D02E010  00000000   NOP
192:                 /*-----------------------------------------------------------*/
193:                 
194:                 void vCoRoutineAddToDelayedList( portTickType xTicksToDelay, xList *pxEventList )
195:                 {
9D02E014  27BDFFE0   ADDIU SP, SP, -32
9D02E018  AFBF001C   SW RA, 28(SP)
9D02E01C  AFBE0018   SW S8, 24(SP)
9D02E020  03A0F021   ADDU S8, SP, ZERO
9D02E024  AFC40020   SW A0, 32(S8)
9D02E028  AFC50024   SW A1, 36(S8)
196:                 portTickType xTimeToWake;
197:                 
198:                 	/* Calculate the time to wake - this may overflow but this is
199:                 	not a problem. */
200:                 	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
9D02E02C  8F838088   LW V1, -32632(GP)
9D02E030  8FC20020   LW V0, 32(S8)
9D02E034  00621021   ADDU V0, V1, V0
9D02E038  AFC20010   SW V0, 16(S8)
201:                 
202:                 	/* We must remove ourselves from the ready list before adding
203:                 	ourselves to the blocked list as the same list item is used for
204:                 	both lists. */
205:                 	( void ) uxListRemove( ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
9D02E03C  8F828080   LW V0, -32640(GP)
9D02E040  24420004   ADDIU V0, V0, 4
9D02E044  00402021   ADDU A0, V0, ZERO
9D02E048  0F40D131   JAL uxListRemove
9D02E04C  00000000   NOP
206:                 
207:                 	/* The list item will be inserted in wake time order. */
208:                 	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
9D02E050  8F828080   LW V0, -32640(GP)
9D02E054  8FC30010   LW V1, 16(S8)
9D02E058  AC430004   SW V1, 4(V0)
209:                 
210:                 	if( xTimeToWake < xCoRoutineTickCount )
9D02E05C  8F828088   LW V0, -32632(GP)
9D02E060  8FC30010   LW V1, 16(S8)
9D02E064  0062102B   SLTU V0, V1, V0
9D02E068  1040000A   BEQ V0, ZERO, 0x9D02E094
9D02E06C  00000000   NOP
211:                 	{
212:                 		/* Wake time has overflowed.  Place this item in the
213:                 		overflow list. */
214:                 		vListInsert( ( xList * ) pxOverflowDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
9D02E070  8F8381D8   LW V1, -32296(GP)
9D02E074  8F828080   LW V0, -32640(GP)
9D02E078  24420004   ADDIU V0, V0, 4
9D02E07C  00602021   ADDU A0, V1, ZERO
9D02E080  00402821   ADDU A1, V0, ZERO
9D02E084  0F40D0F6   JAL vListInsert
9D02E088  00000000   NOP
9D02E08C  0B40B82C   J 0x9D02E0B0
9D02E090  00000000   NOP
215:                 	}
216:                 	else
217:                 	{
218:                 		/* The wake time has not overflowed, so we can use the
219:                 		current block list. */
220:                 		vListInsert( ( xList * ) pxDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
9D02E094  8F8381DC   LW V1, -32292(GP)
9D02E098  8F828080   LW V0, -32640(GP)
9D02E09C  24420004   ADDIU V0, V0, 4
9D02E0A0  00602021   ADDU A0, V1, ZERO
9D02E0A4  00402821   ADDU A1, V0, ZERO
9D02E0A8  0F40D0F6   JAL vListInsert
9D02E0AC  00000000   NOP
221:                 	}
222:                 
223:                 	if( pxEventList )
9D02E0B0  8FC20024   LW V0, 36(S8)
9D02E0B4  10400007   BEQ V0, ZERO, 0x9D02E0D4
9D02E0B8  00000000   NOP
224:                 	{
225:                 		/* Also add the co-routine to an event list.  If this is done then the
226:                 		function must be called with interrupts disabled. */
227:                 		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
9D02E0BC  8F828080   LW V0, -32640(GP)
9D02E0C0  24420018   ADDIU V0, V0, 24
9D02E0C4  8FC40024   LW A0, 36(S8)
9D02E0C8  00402821   ADDU A1, V0, ZERO
9D02E0CC  0F40D0F6   JAL vListInsert
9D02E0D0  00000000   NOP
228:                 	}
229:                 }
9D02E0D4  03C0E821   ADDU SP, S8, ZERO
9D02E0D8  8FBF001C   LW RA, 28(SP)
9D02E0DC  8FBE0018   LW S8, 24(SP)
9D02E0E0  27BD0020   ADDIU SP, SP, 32
9D02E0E4  03E00008   JR RA
9D02E0E8  00000000   NOP
230:                 /*-----------------------------------------------------------*/
231:                 
232:                 static void prvCheckPendingReadyList( void )
233:                 {
9D02E0EC  27BDFFD8   ADDIU SP, SP, -40
9D02E0F0  AFBF0024   SW RA, 36(SP)
9D02E0F4  AFBE0020   SW S8, 32(SP)
9D02E0F8  03A0F021   ADDU S8, SP, ZERO
234:                 	/* Are there any co-routines waiting to get moved to the ready list?  These
235:                 	are co-routines that have been readied by an ISR.  The ISR cannot access
236:                 	the	ready lists itself. */
237:                 	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
9D02E0FC  0B40B881   J 0x9D02E204
9D02E100  00000000   NOP
9D02E204  3C02A000   LUI V0, -24576
9D02E208  8C42041C   LW V0, 1052(V0)
9D02E20C  1440FFBD   BNE V0, ZERO, 0x9D02E104
9D02E210  00000000   NOP
238:                 	{
239:                 		corCRCB *pxUnblockedCRCB;
240:                 
241:                 		/* The pending ready list can be accessed by an ISR. */
242:                 		portDISABLE_INTERRUPTS();
9D02E104  40026000   MFC0 V0, Status
9D02E108  AFC20010   SW V0, 16(S8)
9D02E10C  8FC20010   LW V0, 16(S8)
9D02E110  3042FC00   ANDI V0, V0, -1024
9D02E114  00021282   SRL V0, V0, 10
9D02E118  2C420003   SLTIU V0, V0, 3
9D02E11C  1040000A   BEQ V0, ZERO, 0x9D02E148
9D02E120  00000000   NOP
9D02E124  8FC30010   LW V1, 16(S8)
9D02E128  3C02FFFF   LUI V0, -1
9D02E12C  344203FF   ORI V0, V0, 1023
9D02E130  00621024   AND V0, V1, V0
9D02E134  AFC20010   SW V0, 16(S8)
9D02E138  8FC20010   LW V0, 16(S8)
9D02E13C  34420C00   ORI V0, V0, 3072
9D02E140  40826000   MTC0 V0, Status
9D02E144  000000C0   EHB
243:                 		{
244:                 			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );
9D02E148  3C02A000   LUI V0, -24576
9D02E14C  2442041C   ADDIU V0, V0, 1052
9D02E150  8C42000C   LW V0, 12(V0)
9D02E154  8C42000C   LW V0, 12(V0)
9D02E158  AFC20014   SW V0, 20(S8)
245:                 			( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
9D02E15C  8FC20014   LW V0, 20(S8)
9D02E160  24420018   ADDIU V0, V0, 24
9D02E164  00402021   ADDU A0, V0, ZERO
9D02E168  0F40D131   JAL uxListRemove
9D02E16C  00000000   NOP
246:                 		}
247:                 		portENABLE_INTERRUPTS();
9D02E170  40026000   MFC0 V0, Status
9D02E174  AFC20018   SW V0, 24(S8)
9D02E178  8FC30018   LW V1, 24(S8)
9D02E17C  3C02FFFF   LUI V0, -1
9D02E180  344203FF   ORI V0, V0, 1023
9D02E184  00621024   AND V0, V1, V0
9D02E188  AFC20018   SW V0, 24(S8)
9D02E18C  8FC20018   LW V0, 24(S8)
9D02E190  40826000   MTC0 V0, Status
9D02E194  000000C0   EHB
248:                 
249:                 		( void ) uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
9D02E198  8FC20014   LW V0, 20(S8)
9D02E19C  24420004   ADDIU V0, V0, 4
9D02E1A0  00402021   ADDU A0, V0, ZERO
9D02E1A4  0F40D131   JAL uxListRemove
9D02E1A8  00000000   NOP
250:                 		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );
9D02E1AC  8FC20014   LW V0, 20(S8)
9D02E1B0  8C43002C   LW V1, 44(V0)
9D02E1B4  8F828084   LW V0, -32636(GP)
9D02E1B8  0043102B   SLTU V0, V0, V1
9D02E1BC  10400004   BEQ V0, ZERO, 0x9D02E1D0
9D02E1C0  00000000   NOP
9D02E1C4  8FC20014   LW V0, 20(S8)
9D02E1C8  8C42002C   LW V0, 44(V0)
9D02E1CC  AF828084   SW V0, -32636(GP)
9D02E1D0  8FC20014   LW V0, 20(S8)
9D02E1D4  8C43002C   LW V1, 44(V0)
9D02E1D8  24020014   ADDIU V0, ZERO, 20
9D02E1DC  70621802   MUL V1, V1, V0
9D02E1E0  3C02A000   LUI V0, -24576
9D02E1E4  24420458   ADDIU V0, V0, 1112
9D02E1E8  00621821   ADDU V1, V1, V0
9D02E1EC  8FC20014   LW V0, 20(S8)
9D02E1F0  24420004   ADDIU V0, V0, 4
9D02E1F4  00602021   ADDU A0, V1, ZERO
9D02E1F8  00402821   ADDU A1, V0, ZERO
9D02E1FC  0F40D0D3   JAL vListInsertEnd
9D02E200  00000000   NOP
251:                 	}
252:                 }
9D02E214  03C0E821   ADDU SP, S8, ZERO
9D02E218  8FBF0024   LW RA, 36(SP)
9D02E21C  8FBE0020   LW S8, 32(SP)
9D02E220  27BD0028   ADDIU SP, SP, 40
9D02E224  03E00008   JR RA
9D02E228  00000000   NOP
253:                 /*-----------------------------------------------------------*/
254:                 
255:                 static void prvCheckDelayedList( void )
256:                 {
9D02E22C  27BDFFD8   ADDIU SP, SP, -40
9D02E230  AFBF0024   SW RA, 36(SP)
9D02E234  AFBE0020   SW S8, 32(SP)
9D02E238  03A0F021   ADDU S8, SP, ZERO
257:                 corCRCB *pxCRCB;
258:                 
259:                 	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
9D02E23C  0F407EBC   JAL xTaskGetTickCount
9D02E240  00000000   NOP
9D02E244  00401821   ADDU V1, V0, ZERO
9D02E248  8F82808C   LW V0, -32628(GP)
9D02E24C  00621023   SUBU V0, V1, V0
9D02E250  AF828090   SW V0, -32624(GP)
260:                 	while( xPassedTicks )
9D02E254  0B40B8FB   J 0x9D02E3EC
9D02E258  00000000   NOP
9D02E3EC  8F828090   LW V0, -32624(GP)
9D02E3F0  1440FF9A   BNE V0, ZERO, 0x9D02E25C
9D02E3F4  00000000   NOP
261:                 	{
262:                 		xCoRoutineTickCount++;
9D02E25C  8F828088   LW V0, -32632(GP)
9D02E260  24420001   ADDIU V0, V0, 1
9D02E264  AF828088   SW V0, -32632(GP)
263:                 		xPassedTicks--;
9D02E268  8F828090   LW V0, -32624(GP)
9D02E26C  2442FFFF   ADDIU V0, V0, -1
9D02E270  AF828090   SW V0, -32624(GP)
264:                 
265:                 		/* If the tick count has overflowed we need to swap the ready lists. */
266:                 		if( xCoRoutineTickCount == 0 )
9D02E274  8F828088   LW V0, -32632(GP)
9D02E278  14400054   BNE V0, ZERO, 0x9D02E3CC
9D02E27C  00000000   NOP
267:                 		{
268:                 			xList * pxTemp;
269:                 
270:                 			/* Tick count has overflowed so we need to swap the delay lists.  If there are
271:                 			any items in pxDelayedCoRoutineList here then there is an error! */
272:                 			pxTemp = pxDelayedCoRoutineList;
9D02E280  8F8281DC   LW V0, -32292(GP)
9D02E284  AFC20010   SW V0, 16(S8)
273:                 			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
9D02E288  8F8281D8   LW V0, -32296(GP)
9D02E28C  AF8281DC   SW V0, -32292(GP)
274:                 			pxOverflowDelayedCoRoutineList = pxTemp;
9D02E290  8FC20010   LW V0, 16(S8)
9D02E294  AF8281D8   SW V0, -32296(GP)
275:                 		}
276:                 
277:                 		/* See if this tick has made a timeout expire. */
278:                 		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
9D02E298  0B40B8F4   J 0x9D02E3D0
9D02E29C  00000000   NOP
9D02E3CC  00000000   NOP
9D02E3D0  8F8281DC   LW V0, -32292(GP)
9D02E3D4  8C420000   LW V0, 0(V0)
9D02E3D8  1440FFB1   BNE V0, ZERO, 0x9D02E2A0
9D02E3DC  00000000   NOP
9D02E3E0  0B40B8FB   J 0x9D02E3EC
9D02E3E4  00000000   NOP
279:                 		{
280:                 			pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
9D02E2A0  8F8281DC   LW V0, -32292(GP)
9D02E2A4  8C42000C   LW V0, 12(V0)
9D02E2A8  8C42000C   LW V0, 12(V0)
9D02E2AC  AFC20014   SW V0, 20(S8)
281:                 
282:                 			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )
9D02E2B0  8FC20014   LW V0, 20(S8)
9D02E2B4  8C430004   LW V1, 4(V0)
9D02E2B8  8F828088   LW V0, -32632(GP)
9D02E2BC  0043102B   SLTU V0, V0, V1
9D02E2C0  14400049   BNE V0, ZERO, 0x9D02E3E8
9D02E2C4  00000000   NOP
283:                 			{
284:                 				/* Timeout not yet expired. */
285:                 				break;
9D02E3E8  00000000   NOP
286:                 			}
287:                 
288:                 			portDISABLE_INTERRUPTS();
9D02E2C8  40026000   MFC0 V0, Status
9D02E2CC  AFC20018   SW V0, 24(S8)
9D02E2D0  8FC20018   LW V0, 24(S8)
9D02E2D4  3042FC00   ANDI V0, V0, -1024
9D02E2D8  00021282   SRL V0, V0, 10
9D02E2DC  2C420003   SLTIU V0, V0, 3
9D02E2E0  1040000A   BEQ V0, ZERO, 0x9D02E30C
9D02E2E4  00000000   NOP
9D02E2E8  8FC30018   LW V1, 24(S8)
9D02E2EC  3C02FFFF   LUI V0, -1
9D02E2F0  344203FF   ORI V0, V0, 1023
9D02E2F4  00621024   AND V0, V1, V0
9D02E2F8  AFC20018   SW V0, 24(S8)
9D02E2FC  8FC20018   LW V0, 24(S8)
9D02E300  34420C00   ORI V0, V0, 3072
9D02E304  40826000   MTC0 V0, Status
9D02E308  000000C0   EHB
289:                 			{
290:                 				/* The event could have occurred just before this critical
291:                 				section.  If this is the case then the generic list item will
292:                 				have been moved to the pending ready list and the following
293:                 				line is still valid.  Also the pvContainer parameter will have
294:                 				been set to NULL so the following lines are also valid. */
295:                 				uxListRemove( &( pxCRCB->xGenericListItem ) );
9D02E30C  8FC20014   LW V0, 20(S8)
9D02E310  24420004   ADDIU V0, V0, 4
9D02E314  00402021   ADDU A0, V0, ZERO
9D02E318  0F40D131   JAL uxListRemove
9D02E31C  00000000   NOP
296:                 
297:                 				/* Is the co-routine waiting on an event also? */
298:                 				if( pxCRCB->xEventListItem.pvContainer )
9D02E320  8FC20014   LW V0, 20(S8)
9D02E324  8C420028   LW V0, 40(V0)
9D02E328  10400006   BEQ V0, ZERO, 0x9D02E344
9D02E32C  00000000   NOP
299:                 				{
300:                 					( void ) uxListRemove( &( pxCRCB->xEventListItem ) );
9D02E330  8FC20014   LW V0, 20(S8)
9D02E334  24420018   ADDIU V0, V0, 24
9D02E338  00402021   ADDU A0, V0, ZERO
9D02E33C  0F40D131   JAL uxListRemove
9D02E340  00000000   NOP
301:                 				}
302:                 			}
303:                 			portENABLE_INTERRUPTS();
9D02E344  40026000   MFC0 V0, Status
9D02E348  AFC2001C   SW V0, 28(S8)
9D02E34C  8FC3001C   LW V1, 28(S8)
9D02E350  3C02FFFF   LUI V0, -1
9D02E354  344203FF   ORI V0, V0, 1023
9D02E358  00621024   AND V0, V1, V0
9D02E35C  AFC2001C   SW V0, 28(S8)
9D02E360  8FC2001C   LW V0, 28(S8)
9D02E364  40826000   MTC0 V0, Status
9D02E368  000000C0   EHB
304:                 
305:                 			prvAddCoRoutineToReadyQueue( pxCRCB );
9D02E36C  8FC20014   LW V0, 20(S8)
9D02E370  8C43002C   LW V1, 44(V0)
9D02E374  8F828084   LW V0, -32636(GP)
9D02E378  0043102B   SLTU V0, V0, V1
9D02E37C  10400004   BEQ V0, ZERO, 0x9D02E390
9D02E380  00000000   NOP
9D02E384  8FC20014   LW V0, 20(S8)
9D02E388  8C42002C   LW V0, 44(V0)
9D02E38C  AF828084   SW V0, -32636(GP)
9D02E390  8FC20014   LW V0, 20(S8)
9D02E394  8C43002C   LW V1, 44(V0)
9D02E398  24020014   ADDIU V0, ZERO, 20
9D02E39C  70621802   MUL V1, V1, V0
9D02E3A0  3C02A000   LUI V0, -24576
9D02E3A4  24420458   ADDIU V0, V0, 1112
9D02E3A8  00621821   ADDU V1, V1, V0
9D02E3AC  8FC20014   LW V0, 20(S8)
9D02E3B0  24420004   ADDIU V0, V0, 4
9D02E3B4  00602021   ADDU A0, V1, ZERO
9D02E3B8  00402821   ADDU A1, V0, ZERO
9D02E3BC  0F40D0D3   JAL vListInsertEnd
9D02E3C0  00000000   NOP
9D02E3C4  0B40B8F4   J 0x9D02E3D0
9D02E3C8  00000000   NOP
306:                 		}
307:                 	}
308:                 
309:                 	xLastTickCount = xCoRoutineTickCount;
9D02E3F8  8F828088   LW V0, -32632(GP)
9D02E3FC  AF82808C   SW V0, -32628(GP)
310:                 }
9D02E400  03C0E821   ADDU SP, S8, ZERO
9D02E404  8FBF0024   LW RA, 36(SP)
9D02E408  8FBE0020   LW S8, 32(SP)
9D02E40C  27BD0028   ADDIU SP, SP, 40
9D02E410  03E00008   JR RA
9D02E414  00000000   NOP
311:                 /*-----------------------------------------------------------*/
312:                 
313:                 void vCoRoutineSchedule( void )
314:                 {
9D02E418  27BDFFE0   ADDIU SP, SP, -32
9D02E41C  AFBF001C   SW RA, 28(SP)
9D02E420  AFBE0018   SW S8, 24(SP)
9D02E424  03A0F021   ADDU S8, SP, ZERO
315:                 	/* See if any co-routines readied by events need moving to the ready lists. */
316:                 	prvCheckPendingReadyList();
9D02E428  0F40B83B   JAL prvCheckPendingReadyList
9D02E42C  00000000   NOP
317:                 
318:                 	/* See if any delayed co-routines have timed out. */
319:                 	prvCheckDelayedList();
9D02E430  0F40B88B   JAL prvCheckDelayedList
9D02E434  00000000   NOP
320:                 
321:                 	/* Find the highest priority queue that contains ready co-routines. */
322:                 	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
9D02E438  0B40B916   J 0x9D02E458
9D02E43C  00000000   NOP
9D02E458  8F838084   LW V1, -32636(GP)
9D02E45C  24020014   ADDIU V0, ZERO, 20
9D02E460  70621802   MUL V1, V1, V0
9D02E464  3C02A000   LUI V0, -24576
9D02E468  24420458   ADDIU V0, V0, 1112
9D02E46C  00621021   ADDU V0, V1, V0
9D02E470  8C420000   LW V0, 0(V0)
9D02E474  1040FFF2   BEQ V0, ZERO, 0x9D02E440
9D02E478  00000000   NOP
323:                 	{
324:                 		if( uxTopCoRoutineReadyPriority == 0 )
9D02E440  8F828084   LW V0, -32636(GP)
9D02E444  10400033   BEQ V0, ZERO, 0x9D02E514
9D02E448  00000000   NOP
325:                 		{
326:                 			/* No more co-routines to check. */
327:                 			return;
9D02E514  00000000   NOP
328:                 		}
329:                 		--uxTopCoRoutineReadyPriority;
9D02E44C  8F828084   LW V0, -32636(GP)
9D02E450  2442FFFF   ADDIU V0, V0, -1
9D02E454  AF828084   SW V0, -32636(GP)
330:                 	}
331:                 
332:                 	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
333:                 	 of the	same priority get an equal share of the processor time. */
334:                 	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
9D02E47C  8F838084   LW V1, -32636(GP)
9D02E480  24020014   ADDIU V0, ZERO, 20
9D02E484  70621802   MUL V1, V1, V0
9D02E488  3C02A000   LUI V0, -24576
9D02E48C  24420458   ADDIU V0, V0, 1112
9D02E490  00621021   ADDU V0, V1, V0
9D02E494  AFC20010   SW V0, 16(S8)
9D02E498  8FC20010   LW V0, 16(S8)
9D02E49C  8C420004   LW V0, 4(V0)
9D02E4A0  8C430004   LW V1, 4(V0)
9D02E4A4  8FC20010   LW V0, 16(S8)
9D02E4A8  AC430004   SW V1, 4(V0)
9D02E4AC  8FC20010   LW V0, 16(S8)
9D02E4B0  8C430004   LW V1, 4(V0)
9D02E4B4  8FC20010   LW V0, 16(S8)
9D02E4B8  24420008   ADDIU V0, V0, 8
9D02E4BC  14620006   BNE V1, V0, 0x9D02E4D8
9D02E4C0  00000000   NOP
9D02E4C4  8FC20010   LW V0, 16(S8)
9D02E4C8  8C420004   LW V0, 4(V0)
9D02E4CC  8C430004   LW V1, 4(V0)
9D02E4D0  8FC20010   LW V0, 16(S8)
9D02E4D4  AC430004   SW V1, 4(V0)
9D02E4D8  8FC20010   LW V0, 16(S8)
9D02E4DC  8C420004   LW V0, 4(V0)
9D02E4E0  8C42000C   LW V0, 12(V0)
9D02E4E4  AF828080   SW V0, -32640(GP)
335:                 
336:                 	/* Call the co-routine. */
337:                 	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
9D02E4E8  8F828080   LW V0, -32640(GP)
9D02E4EC  8C420000   LW V0, 0(V0)
9D02E4F0  8F848080   LW A0, -32640(GP)
9D02E4F4  8F838080   LW V1, -32640(GP)
9D02E4F8  8C630030   LW V1, 48(V1)
9D02E4FC  00602821   ADDU A1, V1, ZERO
9D02E500  0040F809   JALR V0
9D02E504  00000000   NOP
338:                 
339:                 	return;
9D02E508  00000000   NOP
9D02E50C  0B40B946   J 0x9D02E518
9D02E510  00000000   NOP
340:                 }
9D02E518  03C0E821   ADDU SP, S8, ZERO
9D02E51C  8FBF001C   LW RA, 28(SP)
9D02E520  8FBE0018   LW S8, 24(SP)
9D02E524  27BD0020   ADDIU SP, SP, 32
9D02E528  03E00008   JR RA
9D02E52C  00000000   NOP
341:                 /*-----------------------------------------------------------*/
342:                 
343:                 static void prvInitialiseCoRoutineLists( void )
344:                 {
9D02E530  27BDFFE0   ADDIU SP, SP, -32
9D02E534  AFBF001C   SW RA, 28(SP)
9D02E538  AFBE0018   SW S8, 24(SP)
9D02E53C  03A0F021   ADDU S8, SP, ZERO
345:                 unsigned portBASE_TYPE uxPriority;
346:                 
347:                 	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
9D02E540  AFC00010   SW ZERO, 16(S8)
9D02E544  0B40B95F   J 0x9D02E57C
9D02E548  00000000   NOP
9D02E570  8FC20010   LW V0, 16(S8)
9D02E574  24420001   ADDIU V0, V0, 1
9D02E578  AFC20010   SW V0, 16(S8)
9D02E57C  8FC20010   LW V0, 16(S8)
9D02E580  2C420002   SLTIU V0, V0, 2
9D02E584  1440FFF1   BNE V0, ZERO, 0x9D02E54C
9D02E588  00000000   NOP
348:                 	{
349:                 		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
9D02E54C  8FC30010   LW V1, 16(S8)
9D02E550  24020014   ADDIU V0, ZERO, 20
9D02E554  70621802   MUL V1, V1, V0
9D02E558  3C02A000   LUI V0, -24576
9D02E55C  24420458   ADDIU V0, V0, 1112
9D02E560  00621021   ADDU V0, V1, V0
9D02E564  00402021   ADDU A0, V0, ZERO
9D02E568  0F40D0AB   JAL vListInitialise
9D02E56C  00000000   NOP
350:                 	}
351:                 
352:                 	vListInitialise( ( xList * ) &xDelayedCoRoutineList1 );
9D02E58C  3C02A000   LUI V0, -24576
9D02E590  24440444   ADDIU A0, V0, 1092
9D02E594  0F40D0AB   JAL vListInitialise
9D02E598  00000000   NOP
353:                 	vListInitialise( ( xList * ) &xDelayedCoRoutineList2 );
9D02E59C  3C02A000   LUI V0, -24576
9D02E5A0  24440430   ADDIU A0, V0, 1072
9D02E5A4  0F40D0AB   JAL vListInitialise
9D02E5A8  00000000   NOP
354:                 	vListInitialise( ( xList * ) &xPendingReadyCoRoutineList );
9D02E5AC  3C02A000   LUI V0, -24576
9D02E5B0  2444041C   ADDIU A0, V0, 1052
9D02E5B4  0F40D0AB   JAL vListInitialise
9D02E5B8  00000000   NOP
355:                 
356:                 	/* Start with pxDelayedCoRoutineList using list1 and the
357:                 	pxOverflowDelayedCoRoutineList using list2. */
358:                 	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
9D02E5BC  3C02A000   LUI V0, -24576
9D02E5C0  24420444   ADDIU V0, V0, 1092
9D02E5C4  AF8281DC   SW V0, -32292(GP)
359:                 	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
9D02E5C8  3C02A000   LUI V0, -24576
9D02E5CC  24420430   ADDIU V0, V0, 1072
9D02E5D0  AF8281D8   SW V0, -32296(GP)
360:                 }
9D02E5D4  03C0E821   ADDU SP, S8, ZERO
9D02E5D8  8FBF001C   LW RA, 28(SP)
9D02E5DC  8FBE0018   LW S8, 24(SP)
9D02E5E0  27BD0020   ADDIU SP, SP, 32
9D02E5E4  03E00008   JR RA
9D02E5E8  00000000   NOP
361:                 /*-----------------------------------------------------------*/
362:                 
363:                 signed portBASE_TYPE xCoRoutineRemoveFromEventList( const xList *pxEventList )
364:                 {
9D02E5EC  27BDFFE0   ADDIU SP, SP, -32
9D02E5F0  AFBF001C   SW RA, 28(SP)
9D02E5F4  AFBE0018   SW S8, 24(SP)
9D02E5F8  03A0F021   ADDU S8, SP, ZERO
9D02E5FC  AFC40020   SW A0, 32(S8)
365:                 corCRCB *pxUnblockedCRCB;
366:                 signed portBASE_TYPE xReturn;
367:                 
368:                 	/* This function is called from within an interrupt.  It can only access
369:                 	event lists and the pending ready list.  This function assumes that a
370:                 	check has already been made to ensure pxEventList is not empty. */
371:                 	pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
9D02E600  8FC20020   LW V0, 32(S8)
9D02E604  8C42000C   LW V0, 12(V0)
9D02E608  8C42000C   LW V0, 12(V0)
9D02E60C  AFC20014   SW V0, 20(S8)
372:                 	( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
9D02E610  8FC20014   LW V0, 20(S8)
9D02E614  24420018   ADDIU V0, V0, 24
9D02E618  00402021   ADDU A0, V0, ZERO
9D02E61C  0F40D131   JAL uxListRemove
9D02E620  00000000   NOP
373:                 	vListInsertEnd( ( xList * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
9D02E624  8FC20014   LW V0, 20(S8)
9D02E628  24420018   ADDIU V0, V0, 24
9D02E62C  3C03A000   LUI V1, -24576
9D02E630  2464041C   ADDIU A0, V1, 1052
9D02E634  00402821   ADDU A1, V0, ZERO
9D02E638  0F40D0D3   JAL vListInsertEnd
9D02E63C  00000000   NOP
374:                 
375:                 	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
9D02E640  8FC20014   LW V0, 20(S8)
9D02E644  8C43002C   LW V1, 44(V0)
9D02E648  8F828080   LW V0, -32640(GP)
9D02E64C  8C42002C   LW V0, 44(V0)
9D02E650  0062102B   SLTU V0, V1, V0
9D02E654  14400005   BNE V0, ZERO, 0x9D02E66C
9D02E658  00000000   NOP
376:                 	{
377:                 		xReturn = pdTRUE;
9D02E65C  24020001   ADDIU V0, ZERO, 1
9D02E660  AFC20010   SW V0, 16(S8)
9D02E664  0B40B99C   J 0x9D02E670
9D02E668  00000000   NOP
378:                 	}
379:                 	else
380:                 	{
381:                 		xReturn = pdFALSE;
9D02E66C  AFC00010   SW ZERO, 16(S8)
382:                 	}
383:                 
384:                 	return xReturn;
9D02E670  8FC20010   LW V0, 16(S8)
385:                 }
9D02E674  03C0E821   ADDU SP, S8, ZERO
9D02E678  8FBF001C   LW RA, 28(SP)
9D02E67C  8FBE0018   LW S8, 24(SP)
9D02E680  27BD0020   ADDIU SP, SP, 32
9D02E684  03E00008   JR RA
9D02E688  00000000   NOP
386:                 
---  C:/Users/Diego/Documents/GitHub/pic32webFREERtos/Pic32Web.X/src/CustomHTTPApp.c  -------------------
1:                   /*********************************************************************
2:                    *
3:                    *  Application to Demo HTTP2 Server
4:                    *  Support for HTTP2 module in Microchip TCP/IP Stack
5:                    *	 -Implements the application 
6:                    *	 -Reference: RFC 1002
7:                    *
8:                    *********************************************************************
9:                    * FileName:        CustomHTTPApp.c
10:                   * Dependencies:    TCP/IP stack
11:                   * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32
12:                   * Compiler:        Microchip C32 v1.05 or higher
13:                   *					Microchip C30 v3.12 or higher
14:                   *					Microchip C18 v3.30 or higher
15:                   *					HI-TECH PICC-18 PRO 9.63PL2 or higher
16:                   * Company:         Microchip Technology, Inc.
17:                   *
18:                   * Software License Agreement
19:                   *
20:                   * Copyright (C) 2002-2010 Microchip Technology Inc.  All rights
21:                   * reserved.
22:                   *
23:                   * Microchip licenses to you the right to use, modify, copy, and
24:                   * distribute:
25:                   * (i)  the Software when embedded on a Microchip microcontroller or
26:                   *      digital signal controller product ("Device") which is
27:                   *      integrated into Licensee's product; or
28:                   * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h,
29:                   *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device
30:                   *		used in conjunction with a Microchip ethernet controller for
31:                   *		the sole purpose of interfacing with the ethernet controller.
32:                   *
33:                   * You should refer to the license agreement accompanying this
34:                   * Software for additional information regarding your rights and
35:                   * obligations.
36:                   *
37:                   * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT
38:                   * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT
39:                   * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A
40:                   * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL
41:                   * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR
42:                   * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF
43:                   * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS
44:                   * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE
45:                   * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER
46:                   * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT
47:                   * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE.
48:                   *
49:                   *
50:                   * Author               Date    Comment
51:                   *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
52:                   * Elliott Wood     	6/18/07	Original
53:                   ********************************************************************/
54:                  #define __CUSTOMHTTPAPP_C
55:                  
56:                  #include "TCPIPConfig.h"
57:                  
58:                  #if defined(STACK_USE_HTTP2_SERVER)
59:                  
60:                  #include "TCPIP Stack/TCPIP.h"
61:                  #include "MainDemo.h"		// Needed for SaveAppConfig() prototype
62:                  
63:                  /****************************************************************************
64:                    Section:
65:                  	Function Prototypes and Memory Globalizers
66:                    ***************************************************************************/
67:                  #if defined(HTTP_USE_POST)
68:                  	#if defined(USE_LCD)
69:                  		static HTTP_IO_RESULT HTTPPostLCD(void);
70:                  	#endif
71:                  	#if defined(STACK_USE_HTTP_MD5_DEMO)
72:                  		#if !defined(STACK_USE_MD5)
73:                  			#error The HTTP_MD5_DEMO requires STACK_USE_MD5
74:                  		#endif
75:                  		static HTTP_IO_RESULT HTTPPostMD5(void);
76:                  	#endif
77:                  	#if defined(STACK_USE_HTTP_APP_RECONFIG)
78:                  		extern APP_CONFIG AppConfig;
79:                  		static HTTP_IO_RESULT HTTPPostConfig(void);
80:                  		#if defined(STACK_USE_SNMP_SERVER)
81:                  		static HTTP_IO_RESULT HTTPPostSNMPCommunity(void);
82:                  		#endif
83:                  	#endif
84:                  	#if defined(STACK_USE_HTTP_EMAIL_DEMO) || defined(STACK_USE_SMTP_CLIENT)
85:                  		#if !defined(STACK_USE_SMTP_CLIENT)
86:                  			#error The HTTP_EMAIL_DEMO requires STACK_USE_SMTP_CLIENT
87:                  		#endif
88:                  		static HTTP_IO_RESULT HTTPPostEmail(void);
89:                  	#endif
90:                  	#if defined(STACK_USE_DYNAMICDNS_CLIENT)
91:                  		static HTTP_IO_RESULT HTTPPostDDNSConfig(void);
92:                  	#endif
93:                  #endif
94:                  
95:                  // RAM allocated for DDNS parameters
96:                  #if defined(STACK_USE_DYNAMICDNS_CLIENT)
97:                  	static BYTE DDNSData[100];
98:                  #endif
99:                  
100:                 // Sticky status message variable.
101:                 // This is used to indicated whether or not the previous POST operation was 
102:                 // successful.  The application uses these to store status messages when a 
103:                 // POST operation redirects.  This lets the application provide status messages
104:                 // after a redirect, when connection instance data has already been lost.
105:                 static BOOL lastSuccess = FALSE;
106:                 
107:                 // Stick status message variable.  See lastSuccess for details.
108:                 static BOOL lastFailure = FALSE;
109:                 
110:                 /****************************************************************************
111:                   Section:
112:                 	Authorization Handlers
113:                   ***************************************************************************/
114:                   
115:                 /*****************************************************************************
116:                   Function:
117:                 	BYTE HTTPNeedsAuth(BYTE* cFile)
118:                 	
119:                   Internal:
120:                   	See documentation in the TCP/IP Stack API or HTTP2.h for details.
121:                   ***************************************************************************/
122:                 #if defined(HTTP_USE_AUTHENTICATION)
123:                 BYTE HTTPNeedsAuth(BYTE* cFile)
124:                 {
9D0142A0  27BDFFE8   ADDIU SP, SP, -24
9D0142A4  AFBF0014   SW RA, 20(SP)
9D0142A8  AFBE0010   SW S8, 16(SP)
9D0142AC  03A0F021   ADDU S8, SP, ZERO
9D0142B0  AFC40018   SW A0, 24(S8)
125:                 	// If the filename begins with the folder "protect", then require auth
126:                 	if(memcmppgm2ram(cFile, (ROM void*)"protect", 7) == 0)
9D0142B4  8FC40018   LW A0, 24(S8)
9D0142B8  3C029D03   LUI V0, -25341
9D0142BC  24453244   ADDIU A1, V0, 12868
9D0142C0  24060007   ADDIU A2, ZERO, 7
9D0142C4  0F40D6D9   JAL 0x9D035B64
9D0142C8  00000000   NOP
9D0142CC  14400004   BNE V0, ZERO, 0x9D0142E0
9D0142D0  00000000   NOP
127:                 		return 0x00;		// Authentication will be needed later
9D0142D4  00001021   ADDU V0, ZERO, ZERO
9D0142D8  0B4050C4   J 0x9D014310
9D0142DC  00000000   NOP
128:                 
129:                 	// If the filename begins with the folder "snmp", then require auth
130:                 	if(memcmppgm2ram(cFile, (ROM void*)"snmp", 4) == 0)
9D0142E0  8FC40018   LW A0, 24(S8)
9D0142E4  3C029D03   LUI V0, -25341
9D0142E8  2445324C   ADDIU A1, V0, 12876
9D0142EC  24060004   ADDIU A2, ZERO, 4
9D0142F0  0F40D6D9   JAL 0x9D035B64
9D0142F4  00000000   NOP
9D0142F8  14400004   BNE V0, ZERO, 0x9D01430C
9D0142FC  00000000   NOP
131:                 		return 0x00;		// Authentication will be needed later
9D014300  00001021   ADDU V0, ZERO, ZERO
9D014304  0B4050C4   J 0x9D014310
9D014308  00000000   NOP
132:                 
133:                 	#if defined(HTTP_MPFS_UPLOAD_REQUIRES_AUTH)
134:                 	if(memcmppgm2ram(cFile, (ROM void*)"mpfsupload", 10) == 0)
135:                 		return 0x00;
136:                 	#endif
137:                 
138:                 	// You can match additional strings here to password protect other files.
139:                 	// You could switch this and exclude files from authentication.
140:                 	// You could also always return 0x00 to require auth for all files.
141:                 	// You can return different values (0x00 to 0x79) to track "realms" for below.
142:                 
143:                 	return 0x80;			// No authentication required
9D01430C  24020080   ADDIU V0, ZERO, 128
144:                 }
9D014310  03C0E821   ADDU SP, S8, ZERO
9D014314  8FBF0014   LW RA, 20(SP)
9D014318  8FBE0010   LW S8, 16(SP)
9D01431C  27BD0018   ADDIU SP, SP, 24
9D014320  03E00008   JR RA
9D014324  00000000   NOP
145:                 #endif
146:                 
147:                 /*****************************************************************************
148:                   Function:
149:                 	BYTE HTTPCheckAuth(BYTE* cUser, BYTE* cPass)
150:                 	
151:                   Internal:
152:                   	See documentation in the TCP/IP Stack API or HTTP2.h for details.
153:                   ***************************************************************************/
154:                 #if defined(HTTP_USE_AUTHENTICATION)
155:                 BYTE HTTPCheckAuth(BYTE* cUser, BYTE* cPass)
156:                 {
9D014328  27BDFFE8   ADDIU SP, SP, -24
9D01432C  AFBF0014   SW RA, 20(SP)
9D014330  AFBE0010   SW S8, 16(SP)
9D014334  03A0F021   ADDU S8, SP, ZERO
9D014338  AFC40018   SW A0, 24(S8)
9D01433C  AFC5001C   SW A1, 28(S8)
157:                 	if(strcmppgm2ram((char *)cUser,(ROM char *)"admin") == 0
9D014340  8FC20018   LW V0, 24(S8)
9D014344  00402021   ADDU A0, V0, ZERO
9D014348  3C029D03   LUI V0, -25341
9D01434C  24453254   ADDIU A1, V0, 12884
9D014350  0F40D48D   JAL 0x9D035234
9D014354  00000000   NOP
9D014358  1440000C   BNE V0, ZERO, 0x9D01438C
9D01435C  00000000   NOP
158:                 		&& strcmppgm2ram((char *)cPass, (ROM char *)"microchip") == 0)
9D014360  8FC2001C   LW V0, 28(S8)
9D014364  00402021   ADDU A0, V0, ZERO
9D014368  3C029D03   LUI V0, -25341
9D01436C  2445325C   ADDIU A1, V0, 12892
9D014370  0F40D48D   JAL 0x9D035234
9D014374  00000000   NOP
9D014378  14400004   BNE V0, ZERO, 0x9D01438C
9D01437C  00000000   NOP
159:                 		return 0x80;		// We accept this combination
9D014380  24020080   ADDIU V0, ZERO, 128
9D014384  0B4050E4   J 0x9D014390
9D014388  00000000   NOP
160:                 	
161:                 	// You can add additional user/pass combos here.
162:                 	// If you return specific "realm" values above, you can base this 
163:                 	//   decision on what specific file or folder is being accessed.
164:                 	// You could return different values (0x80 to 0xff) to indicate 
165:                 	//   various users or groups, and base future processing decisions
166:                 	//   in HTTPExecuteGet/Post or HTTPPrint callbacks on this value.
167:                 	
168:                 	return 0x00;			// Provided user/pass is invalid
9D01438C  00001021   ADDU V0, ZERO, ZERO
169:                 }
9D014390  03C0E821   ADDU SP, S8, ZERO
9D014394  8FBF0014   LW RA, 20(SP)
9D014398  8FBE0010   LW S8, 16(SP)
9D01439C  27BD0018   ADDIU SP, SP, 24
9D0143A0  03E00008   JR RA
9D0143A4  00000000   NOP
170:                 #endif
171:                 
172:                 /****************************************************************************
173:                   Section:
174:                 	GET Form Handlers
175:                   ***************************************************************************/
176:                   
177:                 /*****************************************************************************
178:                   Function:
179:                 	HTTP_IO_RESULT HTTPExecuteGet(void)
180:                 	
181:                   Internal:
182:                   	See documentation in the TCP/IP Stack API or HTTP2.h for details.
183:                   ***************************************************************************/
184:                 HTTP_IO_RESULT HTTPExecuteGet(void)
185:                 {
9D0143A8  27BDFFD0   ADDIU SP, SP, -48
9D0143AC  AFBF002C   SW RA, 44(SP)
9D0143B0  AFBE0028   SW S8, 40(SP)
9D0143B4  03A0F021   ADDU S8, SP, ZERO
186:                 	BYTE *ptr;
187:                 	BYTE filename[20];
188:                 	
189:                 	// Load the file name
190:                 	// Make sure BYTE filename[] above is large enough for your longest name
191:                 	MPFSGetFilename(curHTTP.file, filename, 20);
9D0143B8  3C02A000   LUI V0, -24576
9D0143BC  24420574   ADDIU V0, V0, 1396
9D0143C0  90420018   LBU V0, 24(V0)
9D0143C4  00401821   ADDU V1, V0, ZERO
9D0143C8  27C20014   ADDIU V0, S8, 20
9D0143CC  00602021   ADDU A0, V1, ZERO
9D0143D0  00402821   ADDU A1, V0, ZERO
9D0143D4  24060014   ADDIU A2, ZERO, 20
9D0143D8  0F40A02D   JAL MPFSGetFilename
9D0143DC  00000000   NOP
192:                 	
193:                 	// If its the forms.htm page
194:                 	if(!memcmppgm2ram(filename, "forms.htm", 9))
9D0143E0  27C20014   ADDIU V0, S8, 20
9D0143E4  00402021   ADDU A0, V0, ZERO
9D0143E8  3C029D03   LUI V0, -25341
9D0143EC  24453268   ADDIU A1, V0, 12904
9D0143F0  24060009   ADDIU A2, ZERO, 9
9D0143F4  0F40D6D9   JAL 0x9D035B64
9D0143F8  00000000   NOP
9D0143FC  14400053   BNE V0, ZERO, 0x9D01454C
9D014400  00000000   NOP
195:                 	{
196:                 		// Seek out each of the four LED strings, and if it exists set the LED states
197:                 		ptr = HTTPGetROMArg(curHTTP.data, (ROM BYTE *)"led4");
9D014404  3C029D03   LUI V0, -25341
9D014408  24423274   ADDIU V0, V0, 12916
9D01440C  3C03A000   LUI V1, -24576
9D014410  24640598   ADDIU A0, V1, 1432
9D014414  00402821   ADDU A1, V0, ZERO
9D014418  0F404EBD   JAL HTTPGetArg
9D01441C  00000000   NOP
9D014420  AFC20010   SW V0, 16(S8)
198:                 		if(ptr)
9D014424  8FC20010   LW V0, 16(S8)
9D014428  1040000A   BEQ V0, ZERO, 0x9D014454
9D01442C  00000000   NOP
199:                 			LED4_IO = (*ptr == '1');
9D014430  8FC20010   LW V0, 16(S8)
9D014434  90420000   LBU V0, 0(V0)
9D014438  38420031   XORI V0, V0, 49
9D01443C  2C420001   SLTIU V0, V0, 1
9D014440  304400FF   ANDI A0, V0, 255
9D014444  3C03BF88   LUI V1, -16504
9D014448  8C6260E0   LW V0, 24800(V1)
9D01444C  7C823184   INS V0, A0, 6, 1
9D014450  AC6260E0   SW V0, 24800(V1)
200:                 
201:                 		ptr = HTTPGetROMArg(curHTTP.data, (ROM BYTE *)"led3");
9D014454  3C029D03   LUI V0, -25341
9D014458  2442327C   ADDIU V0, V0, 12924
9D01445C  3C03A000   LUI V1, -24576
9D014460  24640598   ADDIU A0, V1, 1432
9D014464  00402821   ADDU A1, V0, ZERO
9D014468  0F404EBD   JAL HTTPGetArg
9D01446C  00000000   NOP
9D014470  AFC20010   SW V0, 16(S8)
202:                 		if(ptr)
9D014474  8FC20010   LW V0, 16(S8)
9D014478  1040000A   BEQ V0, ZERO, 0x9D0144A4
9D01447C  00000000   NOP
203:                 			LED3_IO = (*ptr == '1');
9D014480  8FC20010   LW V0, 16(S8)
9D014484  90420000   LBU V0, 0(V0)
9D014488  38420031   XORI V0, V0, 49
9D01448C  2C420001   SLTIU V0, V0, 1
9D014490  304400FF   ANDI A0, V0, 255
9D014494  3C03BF88   LUI V1, -16504
9D014498  8C6260E0   LW V0, 24800(V1)
9D01449C  7C823184   INS V0, A0, 6, 1
9D0144A0  AC6260E0   SW V0, 24800(V1)
204:                 
205:                 		ptr = HTTPGetROMArg(curHTTP.data, (ROM BYTE *)"led2");
9D0144A4  3C029D03   LUI V0, -25341
9D0144A8  24423284   ADDIU V0, V0, 12932
9D0144AC  3C03A000   LUI V1, -24576
9D0144B0  24640598   ADDIU A0, V1, 1432
9D0144B4  00402821   ADDU A1, V0, ZERO
9D0144B8  0F404EBD   JAL HTTPGetArg
9D0144BC  00000000   NOP
9D0144C0  AFC20010   SW V0, 16(S8)
206:                 		if(ptr)
9D0144C4  8FC20010   LW V0, 16(S8)
9D0144C8  1040000A   BEQ V0, ZERO, 0x9D0144F4
9D0144CC  00000000   NOP
207:                 			LED2_IO = (*ptr == '1');
9D0144D0  8FC20010   LW V0, 16(S8)
9D0144D4  90420000   LBU V0, 0(V0)
9D0144D8  38420031   XORI V0, V0, 49
9D0144DC  2C420001   SLTIU V0, V0, 1
9D0144E0  304400FF   ANDI A0, V0, 255
9D0144E4  3C03BF88   LUI V1, -16504
9D0144E8  8C6260E0   LW V0, 24800(V1)
9D0144EC  7C821084   INS V0, A0, 2, 1
9D0144F0  AC6260E0   SW V0, 24800(V1)
208:                 
209:                 		ptr = HTTPGetROMArg(curHTTP.data, (ROM BYTE *)"led1");
9D0144F4  3C029D03   LUI V0, -25341
9D0144F8  2442328C   ADDIU V0, V0, 12940
9D0144FC  3C03A000   LUI V1, -24576
9D014500  24640598   ADDIU A0, V1, 1432
9D014504  00402821   ADDU A1, V0, ZERO
9D014508  0F404EBD   JAL HTTPGetArg
9D01450C  00000000   NOP
9D014510  AFC20010   SW V0, 16(S8)
210:                 		if(ptr)
9D014514  8FC20010   LW V0, 16(S8)
9D014518  104000A1   BEQ V0, ZERO, 0x9D0147A0
9D01451C  00000000   NOP
211:                 			LED1_IO = (*ptr == '1');
9D014520  8FC20010   LW V0, 16(S8)
9D014524  90420000   LBU V0, 0(V0)
9D014528  38420031   XORI V0, V0, 49
9D01452C  2C420001   SLTIU V0, V0, 1
9D014530  304400FF   ANDI A0, V0, 255
9D014534  3C03BF88   LUI V1, -16504
9D014538  8C6260E0   LW V0, 24800(V1)
9D01453C  7C820844   INS V0, A0, 1, 1
9D014540  AC6260E0   SW V0, 24800(V1)
9D014544  0B4051E8   J 0x9D0147A0
9D014548  00000000   NOP
212:                 	}
213:                 	
214:                 	// If it's the LED updater file
215:                 	else if(!memcmppgm2ram(filename, "cookies.htm", 11))
9D01454C  27C20014   ADDIU V0, S8, 20
9D014550  00402021   ADDU A0, V0, ZERO
9D014554  3C029D03   LUI V0, -25341
9D014558  24453294   ADDIU A1, V0, 12948
9D01455C  2406000B   ADDIU A2, ZERO, 11
9D014560  0F40D6D9   JAL 0x9D035B64
9D014564  00000000   NOP
9D014568  14400007   BNE V0, ZERO, 0x9D014588
9D01456C  00000000   NOP
216:                 	{
217:                 		// This is very simple.  The names and values we want are already in
218:                 		// the data array.  We just set the hasArgs value to indicate how many
219:                 		// name/value pairs we want stored as cookies.
220:                 		// To add the second cookie, just increment this value.
221:                 		// remember to also add a dynamic variable callback to control the printout.
222:                 		curHTTP.hasArgs = 0x01;
9D014570  3C02A000   LUI V0, -24576
9D014574  24420574   ADDIU V0, V0, 1396
9D014578  24030001   ADDIU V1, ZERO, 1
9D01457C  A043001A   SB V1, 26(V0)
9D014580  0B4051E8   J 0x9D0147A0
9D014584  00000000   NOP
223:                 	}
224:                 		
225:                 	
226:                 	// If it's the LED updater file
227:                 	else if(!memcmppgm2ram(filename, "leds.cgi", 8))
9D014588  27C20014   ADDIU V0, S8, 20
9D01458C  00402021   ADDU A0, V0, ZERO
9D014590  3C029D03   LUI V0, -25341
9D014594  244532A0   ADDIU A1, V0, 12960
9D014598  24060008   ADDIU A2, ZERO, 8
9D01459C  0F40D6D9   JAL 0x9D035B64
9D0145A0  00000000   NOP
9D0145A4  1440007E   BNE V0, ZERO, 0x9D0147A0
9D0145A8  00000000   NOP
228:                 	{
229:                 		// Determine which LED to toggle
230:                 		ptr = HTTPGetROMArg(curHTTP.data, (ROM BYTE *)"led");
9D0145AC  3C029D03   LUI V0, -25341
9D0145B0  244232AC   ADDIU V0, V0, 12972
9D0145B4  3C03A000   LUI V1, -24576
9D0145B8  24640598   ADDIU A0, V1, 1432
9D0145BC  00402821   ADDU A1, V0, ZERO
9D0145C0  0F404EBD   JAL HTTPGetArg
9D0145C4  00000000   NOP
9D0145C8  AFC20010   SW V0, 16(S8)
231:                 		
232:                 		// Toggle the specified LED
233:                 		switch(*ptr) {
9D0145CC  8FC20010   LW V0, 16(S8)
9D0145D0  90420000   LBU V0, 0(V0)
9D0145D4  2442FFCF   ADDIU V0, V0, -49
9D0145D8  2C430007   SLTIU V1, V0, 7
9D0145DC  10600070   BEQ V1, ZERO, 0x9D0147A0
9D0145E0  00000000   NOP
9D0145E4  00021880   SLL V1, V0, 2
9D0145E8  3C029D01   LUI V0, -25343
9D0145EC  24424600   ADDIU V0, V0, 17920
9D0145F0  00621021   ADDU V0, V1, V0
9D0145F4  8C420000   LW V0, 0(V0)
9D0145F8  00400008   JR V0
9D0145FC  00000000   NOP
234:                 			case '1':
235:                 				LED1_IO ^= 1;
9D01461C  3C02BF88   LUI V0, -16504
9D014620  8C4260E0   LW V0, 24800(V0)
9D014624  7C420040   EXT V0, V0, 1, 1
9D014628  304200FF   ANDI V0, V0, 255
9D01462C  38420001   XORI V0, V0, 1
9D014630  304200FF   ANDI V0, V0, 255
9D014634  30420001   ANDI V0, V0, 1
9D014638  304400FF   ANDI A0, V0, 255
9D01463C  3C03BF88   LUI V1, -16504
9D014640  8C6260E0   LW V0, 24800(V1)
9D014644  7C820844   INS V0, A0, 1, 1
9D014648  AC6260E0   SW V0, 24800(V1)
236:                 				break;
9D01464C  0B4051E8   J 0x9D0147A0
9D014650  00000000   NOP
237:                 			case '2':
238:                 				LED2_IO ^= 1;
9D014654  3C02BF88   LUI V0, -16504
9D014658  8C4260E0   LW V0, 24800(V0)
9D01465C  7C420080   EXT V0, V0, 2, 1
9D014660  304200FF   ANDI V0, V0, 255
9D014664  38420001   XORI V0, V0, 1
9D014668  304200FF   ANDI V0, V0, 255
9D01466C  30420001   ANDI V0, V0, 1
9D014670  304400FF   ANDI A0, V0, 255
9D014674  3C03BF88   LUI V1, -16504
9D014678  8C6260E0   LW V0, 24800(V1)
9D01467C  7C821084   INS V0, A0, 2, 1
9D014680  AC6260E0   SW V0, 24800(V1)
239:                 				break;
9D014684  0B4051E8   J 0x9D0147A0
9D014688  00000000   NOP
240:                 			case '3':
241:                 				LED3_IO ^= 1;
9D01468C  3C02BF88   LUI V0, -16504
9D014690  8C4260E0   LW V0, 24800(V0)
9D014694  7C420180   EXT V0, V0, 6, 1
9D014698  304200FF   ANDI V0, V0, 255
9D01469C  38420001   XORI V0, V0, 1
9D0146A0  304200FF   ANDI V0, V0, 255
9D0146A4  30420001   ANDI V0, V0, 1
9D0146A8  304400FF   ANDI A0, V0, 255
9D0146AC  3C03BF88   LUI V1, -16504
9D0146B0  8C6260E0   LW V0, 24800(V1)
9D0146B4  7C823184   INS V0, A0, 6, 1
9D0146B8  AC6260E0   SW V0, 24800(V1)
242:                 				break;
9D0146BC  0B4051E8   J 0x9D0147A0
9D0146C0  00000000   NOP
243:                 			case '4':
244:                 				LED4_IO ^= 1;
9D0146C4  3C02BF88   LUI V0, -16504
9D0146C8  8C4260E0   LW V0, 24800(V0)
9D0146CC  7C420180   EXT V0, V0, 6, 1
9D0146D0  304200FF   ANDI V0, V0, 255
9D0146D4  38420001   XORI V0, V0, 1
9D0146D8  304200FF   ANDI V0, V0, 255
9D0146DC  30420001   ANDI V0, V0, 1
9D0146E0  304400FF   ANDI A0, V0, 255
9D0146E4  3C03BF88   LUI V1, -16504
9D0146E8  8C6260E0   LW V0, 24800(V1)
9D0146EC  7C823184   INS V0, A0, 6, 1
9D0146F0  AC6260E0   SW V0, 24800(V1)
245:                 				break;
9D0146F4  0B4051E8   J 0x9D0147A0
9D0146F8  00000000   NOP
246:                 			case '5':
247:                 				LED5_IO ^= 1;
9D0146FC  3C02BF88   LUI V0, -16504
9D014700  8C4260E0   LW V0, 24800(V0)
9D014704  7C420180   EXT V0, V0, 6, 1
9D014708  304200FF   ANDI V0, V0, 255
9D01470C  38420001   XORI V0, V0, 1
9D014710  304200FF   ANDI V0, V0, 255
9D014714  30420001   ANDI V0, V0, 1
9D014718  304400FF   ANDI A0, V0, 255
9D01471C  3C03BF88   LUI V1, -16504
9D014720  8C6260E0   LW V0, 24800(V1)
9D014724  7C823184   INS V0, A0, 6, 1
9D014728  AC6260E0   SW V0, 24800(V1)
248:                 				break;
9D01472C  0B4051E8   J 0x9D0147A0
9D014730  00000000   NOP
249:                 			case '6':
250:                 				LED6_IO ^= 1;
9D014734  3C02BF88   LUI V0, -16504
9D014738  8C4260E0   LW V0, 24800(V0)
9D01473C  7C420180   EXT V0, V0, 6, 1
9D014740  304200FF   ANDI V0, V0, 255
9D014744  38420001   XORI V0, V0, 1
9D014748  304200FF   ANDI V0, V0, 255
9D01474C  30420001   ANDI V0, V0, 1
9D014750  304400FF   ANDI A0, V0, 255
9D014754  3C03BF88   LUI V1, -16504
9D014758  8C6260E0   LW V0, 24800(V1)
9D01475C  7C823184   INS V0, A0, 6, 1
9D014760  AC6260E0   SW V0, 24800(V1)
251:                 				break;
9D014764  0B4051E8   J 0x9D0147A0
9D014768  00000000   NOP
252:                 			case '7':
253:                 				LED7_IO ^= 1;
9D01476C  3C02BF88   LUI V0, -16504
9D014770  8C4260E0   LW V0, 24800(V0)
9D014774  7C420180   EXT V0, V0, 6, 1
9D014778  304200FF   ANDI V0, V0, 255
9D01477C  38420001   XORI V0, V0, 1
9D014780  304200FF   ANDI V0, V0, 255
9D014784  30420001   ANDI V0, V0, 1
9D014788  304400FF   ANDI A0, V0, 255
9D01478C  3C03BF88   LUI V1, -16504
9D014790  8C6260E0   LW V0, 24800(V1)
9D014794  7C823184   INS V0, A0, 6, 1
9D014798  AC6260E0   SW V0, 24800(V1)
254:                 				break;
9D01479C  00000000   NOP
255:                 		}
256:                 		
257:                 	}
258:                 	
259:                 	return HTTP_IO_DONE;
9D0147A0  00001021   ADDU V0, ZERO, ZERO
260:                 }
9D0147A4  03C0E821   ADDU SP, S8, ZERO
9D0147A8  8FBF002C   LW RA, 44(SP)
9D0147AC  8FBE0028   LW S8, 40(SP)
9D0147B0  27BD0030   ADDIU SP, SP, 48
9D0147B4  03E00008   JR RA
9D0147B8  00000000   NOP
261:                 
262:                 
263:                 /****************************************************************************
264:                   Section:
265:                 	POST Form Handlers
266:                   ***************************************************************************/
267:                 #if defined(HTTP_USE_POST)
268:                 
269:                 /*****************************************************************************
270:                   Function:
271:                 	HTTP_IO_RESULT HTTPExecutePost(void)
272:                 	
273:                   Internal:
274:                   	See documentation in the TCP/IP Stack API or HTTP2.h for details.
275:                   ***************************************************************************/
276:                 HTTP_IO_RESULT HTTPExecutePost(void)
277:                 {
9D0147BC  27BDFFD0   ADDIU SP, SP, -48
9D0147C0  AFBF002C   SW RA, 44(SP)
9D0147C4  AFBE0028   SW S8, 40(SP)
9D0147C8  03A0F021   ADDU S8, SP, ZERO
278:                 	// Resolve which function to use and pass along
279:                 	BYTE filename[20];
280:                 	
281:                 	// Load the file name
282:                 	// Make sure BYTE filename[] above is large enough for your longest name
283:                 	MPFSGetFilename(curHTTP.file, filename, sizeof(filename));
9D0147CC  3C02A000   LUI V0, -24576
9D0147D0  24420574   ADDIU V0, V0, 1396
9D0147D4  90420018   LBU V0, 24(V0)
9D0147D8  00402021   ADDU A0, V0, ZERO
9D0147DC  27C20010   ADDIU V0, S8, 16
9D0147E0  00402821   ADDU A1, V0, ZERO
9D0147E4  24060014   ADDIU A2, ZERO, 20
9D0147E8  0F40A02D   JAL MPFSGetFilename
9D0147EC  00000000   NOP
284:                 	
285:                 #if defined(USE_LCD)
286:                 	if(!memcmppgm2ram(filename, "forms.htm", 9))
287:                 		return HTTPPostLCD();
288:                 #endif
289:                 
290:                 #if defined(STACK_USE_HTTP_MD5_DEMO)
291:                 	if(!memcmppgm2ram(filename, "upload.htm", 10))
9D0147F0  27C20010   ADDIU V0, S8, 16
9D0147F4  00402021   ADDU A0, V0, ZERO
9D0147F8  3C029D03   LUI V0, -25341
9D0147FC  244532B0   ADDIU A1, V0, 12976
9D014800  2406000A   ADDIU A2, ZERO, 10
9D014804  0F40D6D9   JAL 0x9D035B64
9D014808  00000000   NOP
9D01480C  14400005   BNE V0, ZERO, 0x9D014824
9D014810  00000000   NOP
292:                 		return HTTPPostMD5();
9D014814  0F4053E1   JAL 0x9D014F84
9D014818  00000000   NOP
9D01481C  0B405223   J 0x9D01488C
9D014820  00000000   NOP
293:                 #endif
294:                 
295:                 #if defined(STACK_USE_HTTP_APP_RECONFIG)
296:                 	if(!memcmppgm2ram(filename, "protect/config.htm", 18))
9D014824  27C20010   ADDIU V0, S8, 16
9D014828  00402021   ADDU A0, V0, ZERO
9D01482C  3C029D03   LUI V0, -25341
9D014830  244532BC   ADDIU A1, V0, 12988
9D014834  24060012   ADDIU A2, ZERO, 18
9D014838  0F40D6D9   JAL 0x9D035B64
9D01483C  00000000   NOP
9D014840  14400005   BNE V0, ZERO, 0x9D014858
9D014844  00000000   NOP
297:                 		return HTTPPostConfig();
9D014848  0F405229   JAL 0x9D0148A4
9D01484C  00000000   NOP
9D014850  0B405223   J 0x9D01488C
9D014854  00000000   NOP
298:                 	#if defined(STACK_USE_SNMP_SERVER)
299:                 	else if(!memcmppgm2ram(filename, "snmp/snmpconfig.htm", 19))
300:                 		return HTTPPostSNMPCommunity();
301:                 	#endif
302:                 #endif
303:                 
304:                 #if defined(STACK_USE_SMTP_CLIENT)
305:                 	if(!strcmppgm2ram((char*)filename, "email/index.htm"))
9D014858  27C20010   ADDIU V0, S8, 16
9D01485C  00402021   ADDU A0, V0, ZERO
9D014860  3C029D03   LUI V0, -25341
9D014864  244532D0   ADDIU A1, V0, 13008
9D014868  0F40D48D   JAL 0x9D035234
9D01486C  00000000   NOP
9D014870  14400005   BNE V0, ZERO, 0x9D014888
9D014874  00000000   NOP
306:                 		return HTTPPostEmail();
9D014878  0F4054E3   JAL 0x9D01538C
9D01487C  00000000   NOP
9D014880  0B405223   J 0x9D01488C
9D014884  00000000   NOP
307:                 #endif
308:                 	
309:                 #if defined(STACK_USE_DYNAMICDNS_CLIENT)
310:                 	if(!strcmppgm2ram((char*)filename, "dyndns/index.htm"))
311:                 		return HTTPPostDDNSConfig();
312:                 #endif
313:                 
314:                 	return HTTP_IO_DONE;
9D014888  00001021   ADDU V0, ZERO, ZERO
315:                 }
9D01488C  03C0E821   ADDU SP, S8, ZERO
9D014890  8FBF002C   LW RA, 44(SP)
9D014894  8FBE0028   LW S8, 40(SP)
9D014898  27BD0030   ADDIU SP, SP, 48
9D01489C  03E00008   JR RA
9D0148A0  00000000   NOP
316:                 
317:                 /*****************************************************************************
318:                   Function:
319:                 	static HTTP_IO_RESULT HTTPPostLCD(void)
320:                 
321:                   Summary:
322:                 	Processes the LCD form on forms.htm
323:                 
324:                   Description:
325:                 	Locates the 'lcd' parameter and uses it to update the text displayed
326:                 	on the board's LCD display.
327:                 	
328:                 	This function has four states.  The first reads a name from the data
329:                 	string returned as part of the POST request.  If a name cannot
330:                 	be found, it returns, asking for more data.  Otherwise, if the name 
331:                 	is expected, it reads the associated value and writes it to the LCD.  
332:                 	If the name is not expected, the value is discarded and the next name 
333:                 	parameter is read.
334:                 	
335:                 	In the case where the expected string is never found, this function 
336:                 	will eventually return HTTP_IO_NEED_DATA when no data is left.  In that
337:                 	case, the HTTP2 server will automatically trap the error and issue an
338:                 	Internal Server Error to the browser.
339:                 
340:                   Precondition:
341:                 	None
342:                 
343:                   Parameters:
344:                 	None
345:                 
346:                   Return Values:
347:                   	HTTP_IO_DONE - the parameter has been found and saved
348:                   	HTTP_IO_WAITING - the function is pausing to continue later
349:                   	HTTP_IO_NEED_DATA - data needed by this function has not yet arrived
350:                   ***************************************************************************/
351:                 #if defined(USE_LCD)
352:                 static HTTP_IO_RESULT HTTPPostLCD(void)
353:                 {
354:                 	BYTE* cDest;
355:                 	
356:                 	#define SM_POST_LCD_READ_NAME		(0u)
357:                 	#define SM_POST_LCD_READ_VALUE		(1u)
358:                 	
359:                 	switch(curHTTP.smPost)
360:                 	{
361:                 		// Find the name
362:                 		case SM_POST_LCD_READ_NAME:
363:                 		
364:                 			// Read a name
365:                 			if(HTTPReadPostName(curHTTP.data, HTTP_MAX_DATA_LEN) == HTTP_READ_INCOMPLETE)
366:                 				return HTTP_IO_NEED_DATA;
367:                 
368:                 			curHTTP.smPost = SM_POST_LCD_READ_VALUE;
369:                 			// No break...continue reading value
370:                 		
371:                 		// Found the value, so store the LCD and return
372:                 		case SM_POST_LCD_READ_VALUE:
373:                 					
374:                 			// If value is expected, read it to data buffer,
375:                 			// otherwise ignore it (by reading to NULL)	
376:                 			if(!strcmppgm2ram((char*)curHTTP.data, (ROM char*)"lcd"))
377:                 				cDest = curHTTP.data;
378:                 			else
379:                 				cDest = NULL;
380:                 			
381:                 			// Read a value string
382:                 			if(HTTPReadPostValue(cDest, HTTP_MAX_DATA_LEN) == HTTP_READ_INCOMPLETE)
383:                 				return HTTP_IO_NEED_DATA;
384:                 			
385:                 			// If this was an unexpected value, look for a new name
386:                 			if(!cDest)
387:                 			{
388:                 				curHTTP.smPost = SM_POST_LCD_READ_NAME;
389:                 				break;
390:                 			}
391:                 			
392:                 			// Copy up to 32 characters to the LCD
393:                 			if(strlen((char*)cDest) < 32u)
394:                 			{
395:                 				memset(LCDText, ' ', 32);
396:                 				strcpy((char*)LCDText, (char*)cDest);
397:                 			}
398:                 			else
399:                 			{
400:                 				memcpy(LCDText, (void *)cDest, 32);
401:                 			}
402:                 			LCDUpdate();
403:                 			
404:                 			// This is the only expected value, so callback is done
405:                 			strcpypgm2ram((char*)curHTTP.data, "/forms.htm");
406:                 			curHTTP.httpStatus = HTTP_REDIRECT;
407:                 			return HTTP_IO_DONE;
408:                 	}
409:                 	
410:                 	// Default assumes that we're returning for state machine convenience.
411:                 	// Function will be called again later.
412:                 	return HTTP_IO_WAITING;
413:                 }
414:                 #endif
415:                 
416:                 /*****************************************************************************
417:                   Function:
418:                 	static HTTP_IO_RESULT HTTPPostConfig(void)
419:                 
420:                   Summary:
421:                 	Processes the configuration form on config/index.htm
422:                 
423:                   Description:
424:                 	Accepts configuration parameters from the form, saves them to a
425:                 	temporary location in RAM, then eventually saves the data to EEPROM or
426:                 	external Flash.
427:                 	
428:                 	When complete, this function redirects to config/reboot.htm, which will
429:                 	display information on reconnecting to the board.
430:                 
431:                 	This function creates a shadow copy of the AppConfig structure in 
432:                 	RAM and then overwrites incoming data there as it arrives.  For each 
433:                 	name/value pair, the name is first read to curHTTP.data[0:5].  Next, the 
434:                 	value is read to newAppConfig.  Once all data has been read, the new
435:                 	AppConfig is saved back to EEPROM and the browser is redirected to 
436:                 	reboot.htm.  That file includes an AJAX call to reboot.cgi, which 
437:                 	performs the actual reboot of the machine.
438:                 	
439:                 	If an IP address cannot be parsed, too much data is POSTed, or any other 
440:                 	parsing error occurs, the browser reloads config.htm and displays an error 
441:                 	message at the top.
442:                 
443:                   Precondition:
444:                 	None
445:                 
446:                   Parameters:
447:                 	None
448:                 
449:                   Return Values:
450:                   	HTTP_IO_DONE - all parameters have been processed
451:                   	HTTP_IO_NEED_DATA - data needed by this function has not yet arrived
452:                   ***************************************************************************/
453:                 #if defined(STACK_USE_HTTP_APP_RECONFIG)
454:                 static HTTP_IO_RESULT HTTPPostConfig(void)
455:                 {
9D0148A4  27BDFFA0   ADDIU SP, SP, -96
9D0148A8  AFBF005C   SW RA, 92(SP)
9D0148AC  AFBE0058   SW S8, 88(SP)
9D0148B0  AFB10054   SW S1, 84(SP)
9D0148B4  AFB00050   SW S0, 80(SP)
9D0148B8  03A0F021   ADDU S8, SP, ZERO
456:                 	APP_CONFIG newAppConfig;
457:                 	BYTE *ptr;
458:                 	BYTE i;
459:                 
460:                 	// Check to see if the browser is attempting to submit more data than we 
461:                 	// can parse at once.  This function needs to receive all updated 
462:                 	// parameters and validate them all before committing them to memory so that
463:                 	// orphaned configuration parameters do not get written (for example, if a 
464:                 	// static IP address is given, but the subnet mask fails parsing, we 
465:                 	// should not use the static IP address).  Everything needs to be processed 
466:                 	// in a single transaction.  If this is impossible, fail and notify the user.
467:                 	// As a web devloper, if you add parameters to AppConfig and run into this 
468:                 	// problem, you could fix this by to splitting your update web page into two 
469:                 	// seperate web pages (causing two transactional writes).  Alternatively, 
470:                 	// you could fix it by storing a static shadow copy of AppConfig someplace 
471:                 	// in memory and using it instead of newAppConfig.  Lastly, you could 
472:                 	// increase the TCP RX FIFO size for the HTTP server.  This will allow more 
473:                 	// data to be POSTed by the web browser before hitting this limit.
474:                 	if(curHTTP.byteCount > TCPIsGetReady(sktHTTP) + TCPGetRxFIFOFree(sktHTTP))
9D0148BC  3C02A000   LUI V0, -24576
9D0148C0  8C500574   LW S0, 1396(V0)
9D0148C4  938281E8   LBU V0, -32280(GP)
9D0148C8  00401821   ADDU V1, V0, ZERO
9D0148CC  3C02A000   LUI V0, -24576
9D0148D0  000318C0   SLL V1, V1, 3
9D0148D4  24420600   ADDIU V0, V0, 1536
9D0148D8  00621021   ADDU V0, V1, V0
9D0148DC  90420004   LBU V0, 4(V0)
9D0148E0  00402021   ADDU A0, V0, ZERO
9D0148E4  0F400675   JAL TCPIsGetReady
9D0148E8  00000000   NOP
9D0148EC  00408821   ADDU S1, V0, ZERO
9D0148F0  938281E8   LBU V0, -32280(GP)
9D0148F4  00401821   ADDU V1, V0, ZERO
9D0148F8  3C02A000   LUI V0, -24576
9D0148FC  000318C0   SLL V1, V1, 3
9D014900  24420600   ADDIU V0, V0, 1536
9D014904  00621021   ADDU V0, V1, V0
9D014908  90420004   LBU V0, 4(V0)
9D01490C  00402021   ADDU A0, V0, ZERO
9D014910  0F400868   JAL TCPGetRxFIFOFree
9D014914  00000000   NOP
9D014918  02221021   ADDU V0, S1, V0
9D01491C  0050102B   SLTU V0, V0, S0
9D014920  14400174   BNE V0, ZERO, 0x9D014EF4
9D014924  00000000   NOP
475:                 		goto ConfigFailure;
9D014EF4  00000000   NOP
9D014EF8  0B4053CA   J 0x9D014F28
9D014EFC  00000000   NOP
476:                 	
477:                 	// Ensure that all data is waiting to be parsed.  If not, keep waiting for 
478:                 	// all of it to arrive.
479:                 	if(TCPIsGetReady(sktHTTP) < curHTTP.byteCount)
9D014928  938281E8   LBU V0, -32280(GP)
9D01492C  00401821   ADDU V1, V0, ZERO
9D014930  3C02A000   LUI V0, -24576
9D014934  000318C0   SLL V1, V1, 3
9D014938  24420600   ADDIU V0, V0, 1536
9D01493C  00621021   ADDU V0, V1, V0
9D014940  90420004   LBU V0, 4(V0)
9D014944  00402021   ADDU A0, V0, ZERO
9D014948  0F400675   JAL TCPIsGetReady
9D01494C  00000000   NOP
9D014950  00401821   ADDU V1, V0, ZERO
9D014954  3C02A000   LUI V0, -24576
9D014958  8C420574   LW V0, 1396(V0)
9D01495C  0062102B   SLTU V0, V1, V0
9D014960  10400004   BEQ V0, ZERO, 0x9D014974
9D014964  00000000   NOP
480:                 		return HTTP_IO_NEED_DATA;
9D014968  24020001   ADDIU V0, ZERO, 1
9D01496C  0B4053D9   J 0x9D014F64
9D014970  00000000   NOP
481:                 	
482:                 	
483:                 	// Use current config in non-volatile memory as defaults
484:                 	#if defined(EEPROM_CS_TRIS)
485:                 		XEEReadArray(sizeof(NVM_VALIDATION_STRUCT), (BYTE*)&newAppConfig, sizeof(newAppConfig));
486:                 	#elif defined(SPIFLASH_CS_TRIS)
487:                 		SPIFlashReadArray(sizeof(NVM_VALIDATION_STRUCT), (BYTE*)&newAppConfig, sizeof(newAppConfig));
488:                 	#endif
489:                 	
490:                 	// Start out assuming that DHCP is disabled.  This is necessary since the 
491:                 	// browser doesn't submit this field if it is unchecked (meaning zero).  
492:                 	// However, if it is checked, this will be overridden since it will be 
493:                 	// submitted.
494:                 	newAppConfig.Flags.bIsDHCPEnabled = 0;
9D014974  8FC20044   LW V0, 68(S8)
9D014978  7C023184   INS V0, ZERO, 6, 1
9D01497C  AFC20044   SW V0, 68(S8)
495:                 
496:                 
497:                 	// Read all browser POST data
498:                 	while(curHTTP.byteCount)
9D014980  0B405386   J 0x9D014E18
9D014984  00000000   NOP
9D014E18  3C02A000   LUI V0, -24576
9D014E1C  8C420574   LW V0, 1396(V0)
9D014E20  1440FED9   BNE V0, ZERO, 0x9D014988
9D014E24  00000000   NOP
499:                 	{
500:                 		// Read a form field name
501:                 		if(HTTPReadPostName(curHTTP.data, 6) != HTTP_READ_OK)
9D014988  3C02A000   LUI V0, -24576
9D01498C  24440598   ADDIU A0, V0, 1432
9D014990  24050006   ADDIU A1, ZERO, 6
9D014994  0F404EF1   JAL HTTPReadPostName
9D014998  00000000   NOP
9D01499C  14400158   BNE V0, ZERO, 0x9D014F00
9D0149A0  00000000   NOP
502:                 			goto ConfigFailure;
9D014F00  00000000   NOP
9D014F04  0B4053CA   J 0x9D014F28
9D014F08  00000000   NOP
503:                 			
504:                 		// Read a form field value
505:                 		if(HTTPReadPostValue(curHTTP.data + 6, sizeof(curHTTP.data)-6-2) != HTTP_READ_OK)
9D0149A4  3C02A000   LUI V0, -24576
9D0149A8  2444059E   ADDIU A0, V0, 1438
9D0149AC  2405005C   ADDIU A1, ZERO, 92
9D0149B0  0F404F10   JAL HTTPReadPostValue
9D0149B4  00000000   NOP
9D0149B8  14400154   BNE V0, ZERO, 0x9D014F0C
9D0149BC  00000000   NOP
506:                 			goto ConfigFailure;
9D014F0C  00000000   NOP
9D014F10  0B4053CA   J 0x9D014F28
9D014F14  00000000   NOP
507:                 			
508:                 		// Parse the value that was read
509:                 		if(!strcmppgm2ram((char*)curHTTP.data, (ROM char*)"ip"))
9D0149C0  3C02A000   LUI V0, -24576
9D0149C4  24420598   ADDIU V0, V0, 1432
9D0149C8  00402021   ADDU A0, V0, ZERO
9D0149CC  3C029D03   LUI V0, -25341
9D0149D0  244532E0   ADDIU A1, V0, 13024
9D0149D4  0F40D48D   JAL 0x9D035234
9D0149D8  00000000   NOP
9D0149DC  1440000D   BNE V0, ZERO, 0x9D014A14
9D0149E0  00000000   NOP
510:                 		{// Read new static IP Address
511:                 			if(!StringToIPAddress(curHTTP.data+6, &newAppConfig.MyIPAddr))
9D0149E4  27C20018   ADDIU V0, S8, 24
9D0149E8  3C03A000   LUI V1, -24576
9D0149EC  2464059E   ADDIU A0, V1, 1438
9D0149F0  00402821   ADDU A1, V0, ZERO
9D0149F4  0F4096C2   JAL StringToIPAddress
9D0149F8  00000000   NOP
9D0149FC  10400146   BEQ V0, ZERO, 0x9D014F18
9D014A00  00000000   NOP
512:                 				goto ConfigFailure;
9D014F18  00000000   NOP
9D014F1C  0B4053CA   J 0x9D014F28
9D014F20  00000000   NOP
513:                 				
514:                 			newAppConfig.DefaultIPAddr.Val = newAppConfig.MyIPAddr.Val;
9D014A04  8FC20018   LW V0, 24(S8)
9D014A08  AFC2002C   SW V0, 44(S8)
9D014A0C  0B405386   J 0x9D014E18
9D014A10  00000000   NOP
515:                 		}
516:                 		else if(!strcmppgm2ram((char*)curHTTP.data, (ROM char*)"gw"))
9D014A14  3C02A000   LUI V0, -24576
9D014A18  24420598   ADDIU V0, V0, 1432
9D014A1C  00402021   ADDU A0, V0, ZERO
9D014A20  3C029D03   LUI V0, -25341
9D014A24  244532E4   ADDIU A1, V0, 13028
9D014A28  0F40D48D   JAL 0x9D035234
9D014A2C  00000000   NOP
9D014A30  1440000C   BNE V0, ZERO, 0x9D014A64
9D014A34  00000000   NOP
517:                 		{// Read new gateway address
518:                 			if(!StringToIPAddress(curHTTP.data+6, &newAppConfig.MyGateway))
9D014A38  27C20018   ADDIU V0, S8, 24
9D014A3C  24420008   ADDIU V0, V0, 8
9D014A40  3C03A000   LUI V1, -24576
9D014A44  2464059E   ADDIU A0, V1, 1438
9D014A48  00402821   ADDU A1, V0, ZERO
9D014A4C  0F4096C2   JAL StringToIPAddress
9D014A50  00000000   NOP
9D014A54  144000F0   BNE V0, ZERO, 0x9D014E18
9D014A58  00000000   NOP
519:                 				goto ConfigFailure;
9D014A5C  0B4053CA   J 0x9D014F28
9D014A60  00000000   NOP
520:                 		}
521:                 		else if(!strcmppgm2ram((char*)curHTTP.data, (ROM char*)"sub"))
9D014A64  3C02A000   LUI V0, -24576
9D014A68  24420598   ADDIU V0, V0, 1432
9D014A6C  00402021   ADDU A0, V0, ZERO
9D014A70  3C029D03   LUI V0, -25341
9D014A74  244532E8   ADDIU A1, V0, 13032
9D014A78  0F40D48D   JAL 0x9D035234
9D014A7C  00000000   NOP
9D014A80  1440000E   BNE V0, ZERO, 0x9D014ABC
9D014A84  00000000   NOP
522:                 		{// Read new static subnet
523:                 			if(!StringToIPAddress(curHTTP.data+6, &newAppConfig.MyMask))
9D014A88  27C20018   ADDIU V0, S8, 24
9D014A8C  24420004   ADDIU V0, V0, 4
9D014A90  3C03A000   LUI V1, -24576
9D014A94  2464059E   ADDIU A0, V1, 1438
9D014A98  00402821   ADDU A1, V0, ZERO
9D014A9C  0F4096C2   JAL StringToIPAddress
9D014AA0  00000000   NOP
9D014AA4  1040011F   BEQ V0, ZERO, 0x9D014F24
9D014AA8  00000000   NOP
524:                 				goto ConfigFailure;
9D014F24  00000000   NOP
525:                 
526:                 			newAppConfig.DefaultMask.Val = newAppConfig.MyMask.Val;
9D014AAC  8FC2001C   LW V0, 28(S8)
9D014AB0  AFC20030   SW V0, 48(S8)
9D014AB4  0B405386   J 0x9D014E18
9D014AB8  00000000   NOP
527:                 		}
528:                 		else if(!strcmppgm2ram((char*)curHTTP.data, (ROM char*)"dns1"))
9D014ABC  3C02A000   LUI V0, -24576
9D014AC0  24420598   ADDIU V0, V0, 1432
9D014AC4  00402021   ADDU A0, V0, ZERO
9D014AC8  3C029D03   LUI V0, -25341
9D014ACC  244532EC   ADDIU A1, V0, 13036
9D014AD0  0F40D48D   JAL 0x9D035234
9D014AD4  00000000   NOP
9D014AD8  1440000C   BNE V0, ZERO, 0x9D014B0C
9D014ADC  00000000   NOP
529:                 		{// Read new primary DNS server
530:                 			if(!StringToIPAddress(curHTTP.data+6, &newAppConfig.PrimaryDNSServer))
9D014AE0  27C20018   ADDIU V0, S8, 24
9D014AE4  2442000C   ADDIU V0, V0, 12
9D014AE8  3C03A000   LUI V1, -24576
9D014AEC  2464059E   ADDIU A0, V1, 1438
9D014AF0  00402821   ADDU A1, V0, ZERO
9D014AF4  0F4096C2   JAL StringToIPAddress
9D014AF8  00000000   NOP
9D014AFC  144000C6   BNE V0, ZERO, 0x9D014E18
9D014B00  00000000   NOP
531:                 				goto ConfigFailure;
9D014B04  0B4053CA   J 0x9D014F28
9D014B08  00000000   NOP
532:                 		}
533:                 		else if(!strcmppgm2ram((char*)curHTTP.data, (ROM char*)"dns2"))
9D014B0C  3C02A000   LUI V0, -24576
9D014B10  24420598   ADDIU V0, V0, 1432
9D014B14  00402021   ADDU A0, V0, ZERO
9D014B18  3C029D03   LUI V0, -25341
9D014B1C  244532F4   ADDIU A1, V0, 13044
9D014B20  0F40D48D   JAL 0x9D035234
9D014B24  00000000   NOP
9D014B28  1440000C   BNE V0, ZERO, 0x9D014B5C
9D014B2C  00000000   NOP
534:                 		{// Read new secondary DNS server
535:                 			if(!StringToIPAddress(curHTTP.data+6, &newAppConfig.SecondaryDNSServer))
9D014B30  27C20018   ADDIU V0, S8, 24
9D014B34  24420010   ADDIU V0, V0, 16
9D014B38  3C03A000   LUI V1, -24576
9D014B3C  2464059E   ADDIU A0, V1, 1438
9D014B40  00402821   ADDU A1, V0, ZERO
9D014B44  0F4096C2   JAL StringToIPAddress
9D014B48  00000000   NOP
9D014B4C  144000B2   BNE V0, ZERO, 0x9D014E18
9D014B50  00000000   NOP
536:                 				goto ConfigFailure;
9D014B54  0B4053CA   J 0x9D014F28
9D014B58  00000000   NOP
537:                 		}
538:                 		else if(!strcmppgm2ram((char*)curHTTP.data, (ROM char*)"mac"))
9D014B5C  3C02A000   LUI V0, -24576
9D014B60  24420598   ADDIU V0, V0, 1432
9D014B64  00402021   ADDU A0, V0, ZERO
9D014B68  3C029D03   LUI V0, -25341
9D014B6C  244532FC   ADDIU A1, V0, 13052
9D014B70  0F40D48D   JAL 0x9D035234
9D014B74  00000000   NOP
9D014B78  1440007C   BNE V0, ZERO, 0x9D014D6C
9D014B7C  00000000   NOP
539:                 		{
540:                 			// Read new MAC address
541:                 			WORD w;
542:                 			BYTE i;
543:                 
544:                 			ptr = curHTTP.data+6;
9D014B80  3C02A000   LUI V0, -24576
9D014B84  2442059E   ADDIU V0, V0, 1438
9D014B88  AFC20010   SW V0, 16(S8)
545:                 
546:                 			for(i = 0; i < 12u; i++)
9D014B8C  A3C00015   SB ZERO, 21(S8)
9D014B90  0B405330   J 0x9D014CC0
9D014B94  00000000   NOP
9D014CB4  93C20015   LBU V0, 21(S8)
9D014CB8  24420001   ADDIU V0, V0, 1
9D014CBC  A3C20015   SB V0, 21(S8)
9D014CC0  93C20015   LBU V0, 21(S8)
9D014CC4  2C42000C   SLTIU V0, V0, 12
9D014CC8  1440FFB8   BNE V0, ZERO, 0x9D014BAC
9D014CCC  00000000   NOP
547:                 			{// Read the MAC address
548:                 				
549:                 				// Skip non-hex bytes
550:                 				while( *ptr != 0x00u && !(*ptr >= '0' && *ptr <= '9') && !(*ptr >= 'A' && *ptr <= 'F') && !(*ptr >= 'a' && *ptr <= 'f') )
9D014BAC  00000000   NOP
9D014BB0  8FC20010   LW V0, 16(S8)
9D014BB4  90420000   LBU V0, 0(V0)
9D014BB8  1040001F   BEQ V0, ZERO, 0x9D014C38
9D014BBC  00000000   NOP
9D014BC0  8FC20010   LW V0, 16(S8)
9D014BC4  90420000   LBU V0, 0(V0)
9D014BC8  2C420030   SLTIU V0, V0, 48
9D014BCC  14400006   BNE V0, ZERO, 0x9D014BE8
9D014BD0  00000000   NOP
9D014BD4  8FC20010   LW V0, 16(S8)
9D014BD8  90420000   LBU V0, 0(V0)
9D014BDC  2C42003A   SLTIU V0, V0, 58
9D014BE0  14400015   BNE V0, ZERO, 0x9D014C38
9D014BE4  00000000   NOP
9D014BE8  8FC20010   LW V0, 16(S8)
9D014BEC  90420000   LBU V0, 0(V0)
9D014BF0  2C420041   SLTIU V0, V0, 65
9D014BF4  14400006   BNE V0, ZERO, 0x9D014C10
9D014BF8  00000000   NOP
9D014BFC  8FC20010   LW V0, 16(S8)
9D014C00  90420000   LBU V0, 0(V0)
9D014C04  2C420047   SLTIU V0, V0, 71
9D014C08  1440000B   BNE V0, ZERO, 0x9D014C38
9D014C0C  00000000   NOP
9D014C10  8FC20010   LW V0, 16(S8)
9D014C14  90420000   LBU V0, 0(V0)
9D014C18  2C420061   SLTIU V0, V0, 97
9D014C1C  1440FFDE   BNE V0, ZERO, 0x9D014B98
9D014C20  00000000   NOP
9D014C24  8FC20010   LW V0, 16(S8)
9D014C28  90420000   LBU V0, 0(V0)
9D014C2C  2C420067   SLTIU V0, V0, 103
9D014C30  1040FFD9   BEQ V0, ZERO, 0x9D014B98
9D014C34  00000000   NOP
551:                 					ptr++;
9D014B98  8FC20010   LW V0, 16(S8)
9D014B9C  24420001   ADDIU V0, V0, 1
9D014BA0  AFC20010   SW V0, 16(S8)
9D014BA4  0B4052EC   J 0x9D014BB0
9D014BA8  00000000   NOP
552:                 
553:                 				// MAC string is over, so zeroize the rest
554:                 				if(*ptr == 0x00u)
9D014C38  8FC20010   LW V0, 16(S8)
9D014C3C  90420000   LBU V0, 0(V0)
9D014C40  14400012   BNE V0, ZERO, 0x9D014C8C
9D014C44  00000000   NOP
555:                 				{
556:                 					for(; i < 12u; i++)
9D014C48  0B40531D   J 0x9D014C74
9D014C4C  00000000   NOP
9D014C68  93C20015   LBU V0, 21(S8)
9D014C6C  24420001   ADDIU V0, V0, 1
9D014C70  A3C20015   SB V0, 21(S8)
9D014C74  93C20015   LBU V0, 21(S8)
9D014C78  2C42000C   SLTIU V0, V0, 12
9D014C7C  1440FFF4   BNE V0, ZERO, 0x9D014C50
9D014C80  00000000   NOP
557:                 						curHTTP.data[i] = '0';
9D014C50  93C30015   LBU V1, 21(S8)
9D014C54  3C02A000   LUI V0, -24576
9D014C58  24420574   ADDIU V0, V0, 1396
9D014C5C  00621021   ADDU V0, V1, V0
9D014C60  24030030   ADDIU V1, ZERO, 48
9D014C64  A0430024   SB V1, 36(V0)
558:                 					break;
9D014C84  0B405334   J 0x9D014CD0
9D014C88  00000000   NOP
559:                 				}
560:                 				
561:                 				// Save the MAC byte
562:                 				curHTTP.data[i] = *ptr++;
9D014C8C  93C40015   LBU A0, 21(S8)
9D014C90  8FC20010   LW V0, 16(S8)
9D014C94  90430000   LBU V1, 0(V0)
9D014C98  3C02A000   LUI V0, -24576
9D014C9C  24420574   ADDIU V0, V0, 1396
9D014CA0  00821021   ADDU V0, A0, V0
9D014CA4  A0430024   SB V1, 36(V0)
9D014CA8  8FC20010   LW V0, 16(S8)
9D014CAC  24420001   ADDIU V0, V0, 1
9D014CB0  AFC20010   SW V0, 16(S8)
563:                 			}
564:                 			
565:                 			// Read MAC Address, one byte at a time
566:                 			for(i = 0; i < 6u; i++)
9D014CD0  A3C00015   SB ZERO, 21(S8)
9D014CD4  0B405355   J 0x9D014D54
9D014CD8  00000000   NOP
9D014D48  93C20015   LBU V0, 21(S8)
9D014D4C  24420001   ADDIU V0, V0, 1
9D014D50  A3C20015   SB V0, 21(S8)
9D014D54  93C20015   LBU V0, 21(S8)
9D014D58  2C420006   SLTIU V0, V0, 6
9D014D5C  1440FFDF   BNE V0, ZERO, 0x9D014CDC
9D014D60  00000000   NOP
9D014D64  0B405386   J 0x9D014E18
9D014D68  00000000   NOP
567:                 			{
568:                 				((BYTE*)&w)[1] = curHTTP.data[i*2];
9D014CDC  27C2004C   ADDIU V0, S8, 76
9D014CE0  24420001   ADDIU V0, V0, 1
9D014CE4  93C30015   LBU V1, 21(S8)
9D014CE8  00032040   SLL A0, V1, 1
9D014CEC  3C03A000   LUI V1, -24576
9D014CF0  24630574   ADDIU V1, V1, 1396
9D014CF4  00831821   ADDU V1, A0, V1
9D014CF8  90630024   LBU V1, 36(V1)
9D014CFC  A0430000   SB V1, 0(V0)
569:                 				((BYTE*)&w)[0] = curHTTP.data[i*2+1];
9D014D00  27C2004C   ADDIU V0, S8, 76
9D014D04  93C30015   LBU V1, 21(S8)
9D014D08  00031840   SLL V1, V1, 1
9D014D0C  24640001   ADDIU A0, V1, 1
9D014D10  3C03A000   LUI V1, -24576
9D014D14  24630574   ADDIU V1, V1, 1396
9D014D18  00831821   ADDU V1, A0, V1
9D014D1C  90630024   LBU V1, 36(V1)
9D014D20  A0430000   SB V1, 0(V0)
570:                 				newAppConfig.MyMACAddr.v[i] = hexatob(*((WORD_VAL*)&w));
9D014D24  93D00015   LBU S0, 21(S8)
9D014D28  27C2004C   ADDIU V0, S8, 76
9D014D2C  94440000   LHU A0, 0(V0)
9D014D30  0F40994C   JAL hexatob
9D014D34  00000000   NOP
9D014D38  00401821   ADDU V1, V0, ZERO
9D014D3C  27C20010   ADDIU V0, S8, 16
9D014D40  00501021   ADDU V0, V0, S0
9D014D44  A0430035   SB V1, 53(V0)
571:                 			}
572:                 		}
573:                 		else if(!strcmppgm2ram((char*)curHTTP.data, (ROM char*)"host"))
9D014D6C  3C02A000   LUI V0, -24576
9D014D70  24420598   ADDIU V0, V0, 1432
9D014D74  00402021   ADDU A0, V0, ZERO
9D014D78  3C029D03   LUI V0, -25341
9D014D7C  24453300   ADDIU A1, V0, 13056
9D014D80  0F40D48D   JAL 0x9D035234
9D014D84  00000000   NOP
9D014D88  14400010   BNE V0, ZERO, 0x9D014DCC
9D014D8C  00000000   NOP
574:                 		{// Read new hostname
575:                 			FormatNetBIOSName(&curHTTP.data[6]);
9D014D90  3C02A000   LUI V0, -24576
9D014D94  2444059E   ADDIU A0, V0, 1438
9D014D98  0F409AC4   JAL FormatNetBIOSName
9D014D9C  00000000   NOP
576:                 			memcpy((void*)newAppConfig.NetBIOSName, (void*)curHTTP.data+6, 16);
9D014DA0  3C02A000   LUI V0, -24576
9D014DA4  2442059E   ADDIU V0, V0, 1438
9D014DA8  27C30018   ADDIU V1, S8, 24
9D014DAC  2463001C   ADDIU V1, V1, 28
9D014DB0  00602021   ADDU A0, V1, ZERO
9D014DB4  00402821   ADDU A1, V0, ZERO
9D014DB8  24060010   ADDIU A2, ZERO, 16
9D014DBC  0F40D298   JAL 0x9D034A60
9D014DC0  00000000   NOP
9D014DC4  0B405386   J 0x9D014E18
9D014DC8  00000000   NOP
577:                 		}
578:                 		else if(!strcmppgm2ram((char*)curHTTP.data, (ROM char*)"dhcp"))
9D014DCC  3C02A000   LUI V0, -24576
9D014DD0  24420598   ADDIU V0, V0, 1432
9D014DD4  00402021   ADDU A0, V0, ZERO
9D014DD8  3C029D03   LUI V0, -25341
9D014DDC  24453308   ADDIU A1, V0, 13064
9D014DE0  0F40D48D   JAL 0x9D035234
9D014DE4  00000000   NOP
9D014DE8  1440000B   BNE V0, ZERO, 0x9D014E18
9D014DEC  00000000   NOP
579:                 		{// Read new DHCP Enabled flag
580:                 			if(curHTTP.data[6] == '1')
9D014DF0  3C02A000   LUI V0, -24576
9D014DF4  24420574   ADDIU V0, V0, 1396
9D014DF8  9043002A   LBU V1, 42(V0)
9D014DFC  24020031   ADDIU V0, ZERO, 49
9D014E00  14620005   BNE V1, V0, 0x9D014E18
9D014E04  00000000   NOP
581:                 				newAppConfig.Flags.bIsDHCPEnabled = 1;
9D014E08  8FC20044   LW V0, 68(S8)
9D014E0C  24030001   ADDIU V1, ZERO, 1
9D014E10  7C623184   INS V0, V1, 6, 1
9D014E14  AFC20044   SW V0, 68(S8)
582:                 		}
583:                 	}
584:                 
585:                 
586:                 	// All parsing complete!  Save new settings and force a reboot
587:                 	SaveAppConfig(&newAppConfig);
588:                 	
589:                 	// Set the board to reboot and display reconnecting information
590:                 	strcpypgm2ram((char*)curHTTP.data, "/protect/reboot.htm?");
9D014E28  3C02A000   LUI V0, -24576
9D014E2C  24420598   ADDIU V0, V0, 1432
9D014E30  00402021   ADDU A0, V0, ZERO
9D014E34  3C029D03   LUI V0, -25341
9D014E38  24453310   ADDIU A1, V0, 13072
9D014E3C  24060015   ADDIU A2, ZERO, 21
9D014E40  0F40D298   JAL 0x9D034A60
9D014E44  00000000   NOP
591:                 	memcpy((void*)(curHTTP.data+20), (void*)newAppConfig.NetBIOSName, 16);
9D014E48  3C02A000   LUI V0, -24576
9D014E4C  244305AC   ADDIU V1, V0, 1452
9D014E50  27C20018   ADDIU V0, S8, 24
9D014E54  2442001C   ADDIU V0, V0, 28
9D014E58  00602021   ADDU A0, V1, ZERO
9D014E5C  00402821   ADDU A1, V0, ZERO
9D014E60  24060010   ADDIU A2, ZERO, 16
9D014E64  0F40D298   JAL 0x9D034A60
9D014E68  00000000   NOP
592:                 	curHTTP.data[20+16] = 0x00;	// Force null termination
9D014E6C  3C02A000   LUI V0, -24576
9D014E70  24420574   ADDIU V0, V0, 1396
9D014E74  A0400048   SB ZERO, 72(V0)
593:                 	for(i = 20; i < 20u+16u; i++)
9D014E78  24020014   ADDIU V0, ZERO, 20
9D014E7C  A3C20014   SB V0, 20(S8)
9D014E80  0B4053B2   J 0x9D014EC8
9D014E84  00000000   NOP
9D014EBC  93C20014   LBU V0, 20(S8)
9D014EC0  24420001   ADDIU V0, V0, 1
9D014EC4  A3C20014   SB V0, 20(S8)
9D014EC8  93C20014   LBU V0, 20(S8)
9D014ECC  2C420024   SLTIU V0, V0, 36
9D014ED0  1440FFED   BNE V0, ZERO, 0x9D014E88
9D014ED4  00000000   NOP
594:                 	{
595:                 		if(curHTTP.data[i] == ' ')
9D014E88  93C30014   LBU V1, 20(S8)
9D014E8C  3C02A000   LUI V0, -24576
9D014E90  24420574   ADDIU V0, V0, 1396
9D014E94  00621021   ADDU V0, V1, V0
9D014E98  90430024   LBU V1, 36(V0)
9D014E9C  24020020   ADDIU V0, ZERO, 32
9D014EA0  14620006   BNE V1, V0, 0x9D014EBC
9D014EA4  00000000   NOP
596:                 			curHTTP.data[i] = 0x00;
9D014EA8  93C30014   LBU V1, 20(S8)
9D014EAC  3C02A000   LUI V0, -24576
9D014EB0  24420574   ADDIU V0, V0, 1396
9D014EB4  00621021   ADDU V0, V1, V0
9D014EB8  A0400024   SB ZERO, 36(V0)
597:                 	}		
598:                 	curHTTP.httpStatus = HTTP_REDIRECT;	
9D014ED8  3C02A000   LUI V0, -24576
9D014EDC  24420574   ADDIU V0, V0, 1396
9D014EE0  24030008   ADDIU V1, ZERO, 8
9D014EE4  AC43001C   SW V1, 28(V0)
599:                 	
600:                 	return HTTP_IO_DONE;
9D014EE8  00001021   ADDU V0, ZERO, ZERO
9D014EEC  0B4053D9   J 0x9D014F64
9D014EF0  00000000   NOP
601:                 
602:                 
603:                 ConfigFailure:
604:                 	lastFailure = TRUE;
9D014F28  24020001   ADDIU V0, ZERO, 1
9D014F2C  AF8281C0   SW V0, -32320(GP)
605:                 	strcpypgm2ram((char*)curHTTP.data, "/protect/config.htm");
9D014F30  3C02A000   LUI V0, -24576
9D014F34  24420598   ADDIU V0, V0, 1432
9D014F38  00402021   ADDU A0, V0, ZERO
9D014F3C  3C029D03   LUI V0, -25341
9D014F40  24453328   ADDIU A1, V0, 13096
9D014F44  24060014   ADDIU A2, ZERO, 20
9D014F48  0F40D298   JAL 0x9D034A60
9D014F4C  00000000   NOP
606:                 	curHTTP.httpStatus = HTTP_REDIRECT;		
9D014F50  3C02A000   LUI V0, -24576
9D014F54  24420574   ADDIU V0, V0, 1396
9D014F58  24030008   ADDIU V1, ZERO, 8
9D014F5C  AC43001C   SW V1, 28(V0)
607:                 
608:                 	return HTTP_IO_DONE;
9D014F60  00001021   ADDU V0, ZERO, ZERO
609:                 }
9D014F64  03C0E821   ADDU SP, S8, ZERO
9D014F68  8FBF005C   LW RA, 92(SP)
9D014F6C  8FBE0058   LW S8, 88(SP)
9D014F70  8FB10054   LW S1, 84(SP)
9D014F74  8FB00050   LW S0, 80(SP)
9D014F78  27BD0060   ADDIU SP, SP, 96
9D014F7C  03E00008   JR RA
9D014F80  00000000   NOP
610:                 
611:                 #if defined(STACK_USE_SNMP_SERVER)
612:                 static HTTP_IO_RESULT HTTPPostSNMPCommunity(void)
613:                 {
614:                 	BYTE vCommunityIndex;
615:                 	BYTE *dest;
616:                 
617:                 	#define SM_CFG_SNMP_READ_NAME	(0u)
618:                 	#define SM_CFG_SNMP_READ_VALUE	(1u)
619:                 	
620:                 	switch(curHTTP.smPost)
621:                 	{
622:                 		case SM_CFG_SNMP_READ_NAME:
623:                 			// If all parameters have been read, end
624:                 			if(curHTTP.byteCount == 0u)
625:                 			{
626:                 				SaveAppConfig(&AppConfig);
627:                 				return HTTP_IO_DONE;
628:                 			}
629:                 		
630:                 			// Read a name
631:                 			if(HTTPReadPostName(curHTTP.data, sizeof(curHTTP.data)-2) == HTTP_READ_INCOMPLETE)
632:                 				return HTTP_IO_NEED_DATA;
633:                 				
634:                 			// Move to reading a value, but no break
635:                 			curHTTP.smPost = SM_CFG_SNMP_READ_VALUE;
636:                 			
637:                 		case SM_CFG_SNMP_READ_VALUE:
638:                 			// Read a value
639:                 			if(HTTPReadPostValue(curHTTP.data + 6, sizeof(curHTTP.data)-6-2) == HTTP_READ_INCOMPLETE)
640:                 				return HTTP_IO_NEED_DATA;
641:                 
642:                 			// Default action after this is to read the next name, unless there's an error
643:                 			curHTTP.smPost = SM_CFG_SNMP_READ_NAME;
644:                 
645:                 			// See if this is a known parameter and legal (must be null 
646:                 			// terminator in 4th field name byte, string must no greater than 
647:                 			// SNMP_COMMUNITY_MAX_LEN bytes long, and SNMP_MAX_COMMUNITY_SUPPORT 
648:                 			// must not be violated.
649:                 			vCommunityIndex = curHTTP.data[3] - '0';
650:                 			if(vCommunityIndex >= SNMP_MAX_COMMUNITY_SUPPORT)
651:                 				break;
652:                 			if(curHTTP.data[4] != 0x00u)
653:                 				break;
654:                 			if(memcmppgm2ram((void*)curHTTP.data, (ROM void*)"rcm", 3) == 0)
655:                 				dest = AppConfig.readCommunity[vCommunityIndex];
656:                 			else if(memcmppgm2ram((void*)curHTTP.data, (ROM void*)"wcm", 3) == 0)
657:                 				dest = AppConfig.writeCommunity[vCommunityIndex];
658:                 			else
659:                 				break;
660:                 			if(strlen((char*)curHTTP.data + 6) > SNMP_COMMUNITY_MAX_LEN)
661:                 				break;
662:                 			
663:                 			// String seems valid, lets copy it to AppConfig
664:                 			strcpy((char*)dest, (char*)curHTTP.data+6);
665:                 			break;			
666:                 	}
667:                 
668:                 	return HTTP_IO_WAITING;		// Assume we're waiting to process more data
669:                 }
670:                 #endif //#if defined(STACK_USE_SNMP_SERVER)
671:                 
672:                 #endif	// #if defined(STACK_USE_HTTP_APP_RECONFIG)
673:                 
674:                 /*****************************************************************************
675:                   Function:
676:                 	static HTTP_IO_RESULT HTTPPostMD5(void)
677:                 
678:                   Summary:
679:                 	Processes the file upload form on upload.htm
680:                 
681:                   Description:
682:                 	This function demonstrates the processing of file uploads.  First, the
683:                 	function locates the file data, skipping over any headers that arrive.
684:                 	Second, it reads the file 64 bytes at a time and hashes that data.  Once
685:                 	all data has been received, the function calculates the MD5 sum and
686:                 	stores it in curHTTP.data.
687:                 
688:                 	After the headers, the first line from the form will be the MIME 
689:                 	separator.  Following that is more headers about the file, which we 
690:                 	discard.  After another CRLFCRLF, the file data begins, and we read 
691:                 	it 16 bytes at a time and add that to the MD5 calculation.  The reading
692:                 	terminates when the separator string is encountered again on its own 
693:                 	line.  Notice that the actual file data is trashed in this process, 
694:                 	allowing us to accept files of arbitrary size, not limited by RAM.  
695:                 	Also notice that the data buffer is used as an arbitrary storage array 
696:                 	for the result.  The ~uploadedmd5~ callback reads this data later to 
697:                 	send back to the client.
698:                 	
699:                   Precondition:
700:                 	None
701:                 
702:                   Parameters:
703:                 	None
704:                 
705:                   Return Values:
706:                 	HTTP_IO_DONE - all parameters have been processed
707:                 	HTTP_IO_WAITING - the function is pausing to continue later
708:                 	HTTP_IO_NEED_DATA - data needed by this function has not yet arrived
709:                   ***************************************************************************/
710:                 #if defined(STACK_USE_HTTP_MD5_DEMO)
711:                 static HTTP_IO_RESULT HTTPPostMD5(void)
712:                 {
9D014F84  27BDFFD0   ADDIU SP, SP, -48
9D014F88  AFBF002C   SW RA, 44(SP)
9D014F8C  AFBE0028   SW S8, 40(SP)
9D014F90  AFB00024   SW S0, 36(SP)
9D014F94  03A0F021   ADDU S8, SP, ZERO
713:                 	WORD lenA, lenB;
714:                 	static HASH_SUM md5;			// Assume only one simultaneous MD5
715:                 	
716:                 	#define SM_MD5_READ_SEPARATOR	(0u)
717:                 	#define SM_MD5_SKIP_TO_DATA		(1u)
718:                 	#define SM_MD5_READ_DATA		(2u)
719:                 	#define SM_MD5_POST_COMPLETE	(3u)
720:                 	
721:                 	// Don't care about curHTTP.data at this point, so use that for buffer
722:                 	switch(curHTTP.smPost)
9D014F98  3C02A000   LUI V0, -24576
9D014F9C  24420574   ADDIU V0, V0, 1396
9D014FA0  90420088   LBU V0, 136(V0)
9D014FA4  24030001   ADDIU V1, ZERO, 1
9D014FA8  10430044   BEQ V0, V1, 0x9D0150BC
9D014FAC  00000000   NOP
9D014FB0  24030002   ADDIU V1, ZERO, 2
9D014FB4  10430098   BEQ V0, V1, 0x9D015218
9D014FB8  00000000   NOP
9D014FBC  144000EB   BNE V0, ZERO, 0x9D01536C
9D014FC0  00000000   NOP
723:                 	{
724:                 		// Just started, so try to find the separator string
725:                 		case SM_MD5_READ_SEPARATOR:
726:                 			// Reset the MD5 calculation
727:                 			MD5Initialize(&md5);
9D014FC4  3C02A000   LUI V0, -24576
9D014FC8  24443184   ADDIU A0, V0, 12676
9D014FCC  0F40B9BB   JAL MD5Initialize
9D014FD0  00000000   NOP
728:                 			
729:                 			// See if a CRLF is in the buffer
730:                 			lenA = TCPFindROMArray(sktHTTP, (ROM BYTE*)"\r\n", 2, 0, FALSE);
9D014FD4  938281E8   LBU V0, -32280(GP)
9D014FD8  00401821   ADDU V1, V0, ZERO
9D014FDC  3C02A000   LUI V0, -24576
9D014FE0  000318C0   SLL V1, V1, 3
9D014FE4  24420600   ADDIU V0, V0, 1536
9D014FE8  00621021   ADDU V0, V1, V0
9D014FEC  90420004   LBU V0, 4(V0)
9D014FF0  00401821   ADDU V1, V0, ZERO
9D014FF4  3C029D03   LUI V0, -25341
9D014FF8  2442333C   ADDIU V0, V0, 13116
9D014FFC  AFA00010   SW ZERO, 16(SP)
9D015000  AFA00014   SW ZERO, 20(SP)
9D015004  00602021   ADDU A0, V1, ZERO
9D015008  00402821   ADDU A1, V0, ZERO
9D01500C  24060002   ADDIU A2, ZERO, 2
9D015010  00003821   ADDU A3, ZERO, ZERO
9D015014  0F400960   JAL TCPFindArrayEx
9D015018  00000000   NOP
9D01501C  A7C20018   SH V0, 24(S8)
731:                 			if(lenA == 0xffff)
9D015020  97C30018   LHU V1, 24(S8)
9D015024  3402FFFF   ORI V0, ZERO, -1
9D015028  14620004   BNE V1, V0, 0x9D01503C
9D01502C  00000000   NOP
732:                 			{//if not, ask for more data
733:                 				return HTTP_IO_NEED_DATA;
9D015030  24020001   ADDIU V0, ZERO, 1
9D015034  0B4054DC   J 0x9D015370
9D015038  00000000   NOP
734:                 			}
735:                 		
736:                 			// If so, figure out where the last byte of data is
737:                 			// Data ends at CRLFseparator--CRLF, so 6+len bytes
738:                 			curHTTP.byteCount -= lenA + 6;
9D01503C  3C02A000   LUI V0, -24576
9D015040  8C430574   LW V1, 1396(V0)
9D015044  97C20018   LHU V0, 24(S8)
9D015048  00621023   SUBU V0, V1, V0
9D01504C  2443FFFA   ADDIU V1, V0, -6
9D015050  3C02A000   LUI V0, -24576
9D015054  AC430574   SW V1, 1396(V0)
739:                 			
740:                 			// Read past the CRLF
741:                 			curHTTP.byteCount -= TCPGetArray(sktHTTP, NULL, lenA+2);
9D015058  3C02A000   LUI V0, -24576
9D01505C  8C500574   LW S0, 1396(V0)
9D015060  938281E8   LBU V0, -32280(GP)
9D015064  00401821   ADDU V1, V0, ZERO
9D015068  3C02A000   LUI V0, -24576
9D01506C  000318C0   SLL V1, V1, 3
9D015070  24420600   ADDIU V0, V0, 1536
9D015074  00621021   ADDU V0, V1, V0
9D015078  90420004   LBU V0, 4(V0)
9D01507C  00401821   ADDU V1, V0, ZERO
9D015080  97C20018   LHU V0, 24(S8)
9D015084  24420002   ADDIU V0, V0, 2
9D015088  3042FFFF   ANDI V0, V0, -1
9D01508C  00602021   ADDU A0, V1, ZERO
9D015090  00002821   ADDU A1, ZERO, ZERO
9D015094  00403021   ADDU A2, V0, ZERO
9D015098  0F40077A   JAL TCPGetArray
9D01509C  00000000   NOP
9D0150A0  02021823   SUBU V1, S0, V0
9D0150A4  3C02A000   LUI V0, -24576
9D0150A8  AC430574   SW V1, 1396(V0)
742:                 			
743:                 			// Save the next state (skip to CRLFCRLF)
744:                 			curHTTP.smPost = SM_MD5_SKIP_TO_DATA;
9D0150AC  3C02A000   LUI V0, -24576
9D0150B0  24420574   ADDIU V0, V0, 1396
9D0150B4  24030001   ADDIU V1, ZERO, 1
9D0150B8  A0430088   SB V1, 136(V0)
745:                 			
746:                 			// No break...continue reading the headers if possible
747:                 				
748:                 		// Skip the headers
749:                 		case SM_MD5_SKIP_TO_DATA:
750:                 			// Look for the CRLFCRLF
751:                 			lenA = TCPFindROMArray(sktHTTP, (ROM BYTE*)"\r\n\r\n", 4, 0, FALSE);
9D0150BC  938281E8   LBU V0, -32280(GP)
9D0150C0  00401821   ADDU V1, V0, ZERO
9D0150C4  3C02A000   LUI V0, -24576
9D0150C8  000318C0   SLL V1, V1, 3
9D0150CC  24420600   ADDIU V0, V0, 1536
9D0150D0  00621021   ADDU V0, V1, V0
9D0150D4  90420004   LBU V0, 4(V0)
9D0150D8  00401821   ADDU V1, V0, ZERO
9D0150DC  3C029D03   LUI V0, -25341
9D0150E0  24423340   ADDIU V0, V0, 13120
9D0150E4  AFA00010   SW ZERO, 16(SP)
9D0150E8  AFA00014   SW ZERO, 20(SP)
9D0150EC  00602021   ADDU A0, V1, ZERO
9D0150F0  00402821   ADDU A1, V0, ZERO
9D0150F4  24060004   ADDIU A2, ZERO, 4
9D0150F8  00003821   ADDU A3, ZERO, ZERO
9D0150FC  0F400960   JAL TCPFindArrayEx
9D015100  00000000   NOP
9D015104  A7C20018   SH V0, 24(S8)
752:                 	
753:                 			if(lenA != 0xffff)
9D015108  97C30018   LHU V1, 24(S8)
9D01510C  3402FFFF   ORI V0, ZERO, -1
9D015110  1062001E   BEQ V1, V0, 0x9D01518C
9D015114  00000000   NOP
754:                 			{// Found it, so remove all data up to and including
755:                 				lenA = TCPGetArray(sktHTTP, NULL, lenA+4);
9D015118  938281E8   LBU V0, -32280(GP)
9D01511C  00401821   ADDU V1, V0, ZERO
9D015120  3C02A000   LUI V0, -24576
9D015124  000318C0   SLL V1, V1, 3
9D015128  24420600   ADDIU V0, V0, 1536
9D01512C  00621021   ADDU V0, V1, V0
9D015130  90420004   LBU V0, 4(V0)
9D015134  00401821   ADDU V1, V0, ZERO
9D015138  97C20018   LHU V0, 24(S8)
9D01513C  24420004   ADDIU V0, V0, 4
9D015140  3042FFFF   ANDI V0, V0, -1
9D015144  00602021   ADDU A0, V1, ZERO
9D015148  00002821   ADDU A1, ZERO, ZERO
9D01514C  00403021   ADDU A2, V0, ZERO
9D015150  0F40077A   JAL TCPGetArray
9D015154  00000000   NOP
9D015158  A7C20018   SH V0, 24(S8)
756:                 				curHTTP.byteCount -= lenA;
9D01515C  3C02A000   LUI V0, -24576
9D015160  8C430574   LW V1, 1396(V0)
9D015164  97C20018   LHU V0, 24(S8)
9D015168  00621823   SUBU V1, V1, V0
9D01516C  3C02A000   LUI V0, -24576
9D015170  AC430574   SW V1, 1396(V0)
757:                 				curHTTP.smPost = SM_MD5_READ_DATA;
9D015174  3C02A000   LUI V0, -24576
9D015178  24420574   ADDIU V0, V0, 1396
9D01517C  24030002   ADDIU V1, ZERO, 2
9D015180  A0430088   SB V1, 136(V0)
9D015184  0B405486   J 0x9D015218
9D015188  00000000   NOP
758:                 			}
759:                 			else
760:                 			{// Otherwise, remove as much as possible
761:                 				lenA = TCPGetArray(sktHTTP, NULL, TCPIsGetReady(sktHTTP) - 4);
9D01518C  938281E8   LBU V0, -32280(GP)
9D015190  00401821   ADDU V1, V0, ZERO
9D015194  3C02A000   LUI V0, -24576
9D015198  000318C0   SLL V1, V1, 3
9D01519C  24420600   ADDIU V0, V0, 1536
9D0151A0  00621021   ADDU V0, V1, V0
9D0151A4  90420004   LBU V0, 4(V0)
9D0151A8  00408021   ADDU S0, V0, ZERO
9D0151AC  938281E8   LBU V0, -32280(GP)
9D0151B0  00401821   ADDU V1, V0, ZERO
9D0151B4  3C02A000   LUI V0, -24576
9D0151B8  000318C0   SLL V1, V1, 3
9D0151BC  24420600   ADDIU V0, V0, 1536
9D0151C0  00621021   ADDU V0, V1, V0
9D0151C4  90420004   LBU V0, 4(V0)
9D0151C8  00402021   ADDU A0, V0, ZERO
9D0151CC  0F400675   JAL TCPIsGetReady
9D0151D0  00000000   NOP
9D0151D4  2442FFFC   ADDIU V0, V0, -4
9D0151D8  3042FFFF   ANDI V0, V0, -1
9D0151DC  02002021   ADDU A0, S0, ZERO
9D0151E0  00002821   ADDU A1, ZERO, ZERO
9D0151E4  00403021   ADDU A2, V0, ZERO
9D0151E8  0F40077A   JAL TCPGetArray
9D0151EC  00000000   NOP
9D0151F0  A7C20018   SH V0, 24(S8)
762:                 				curHTTP.byteCount -= lenA;
9D0151F4  3C02A000   LUI V0, -24576
9D0151F8  8C430574   LW V1, 1396(V0)
9D0151FC  97C20018   LHU V0, 24(S8)
9D015200  00621823   SUBU V1, V1, V0
9D015204  3C02A000   LUI V0, -24576
9D015208  AC430574   SW V1, 1396(V0)
763:                 			
764:                 				// Return the need more data flag
765:                 				return HTTP_IO_NEED_DATA;
9D01520C  24020001   ADDIU V0, ZERO, 1
9D015210  0B4054DC   J 0x9D015370
9D015214  00000000   NOP
766:                 			}
767:                 			
768:                 			// No break if we found the header terminator
769:                 			
770:                 		// Read and hash file data
771:                 		case SM_MD5_READ_DATA:
772:                 			// Find out how many bytes are available to be read
773:                 			lenA = TCPIsGetReady(sktHTTP);
9D015218  938281E8   LBU V0, -32280(GP)
9D01521C  00401821   ADDU V1, V0, ZERO
9D015220  3C02A000   LUI V0, -24576
9D015224  000318C0   SLL V1, V1, 3
9D015228  24420600   ADDIU V0, V0, 1536
9D01522C  00621021   ADDU V0, V1, V0
9D015230  90420004   LBU V0, 4(V0)
9D015234  00402021   ADDU A0, V0, ZERO
9D015238  0F400675   JAL TCPIsGetReady
9D01523C  00000000   NOP
9D015240  A7C20018   SH V0, 24(S8)
774:                 			if(lenA > curHTTP.byteCount)
9D015244  97C30018   LHU V1, 24(S8)
9D015248  3C02A000   LUI V0, -24576
9D01524C  8C420574   LW V0, 1396(V0)
9D015250  0043102B   SLTU V0, V0, V1
9D015254  1040002E   BEQ V0, ZERO, 0x9D015310
9D015258  00000000   NOP
775:                 				lenA = curHTTP.byteCount;
9D01525C  3C02A000   LUI V0, -24576
9D015260  8C420574   LW V0, 1396(V0)
9D015264  A7C20018   SH V0, 24(S8)
776:                 	
777:                 			while(lenA > 0u)
9D015268  0B4054C4   J 0x9D015310
9D01526C  00000000   NOP
9D015310  97C20018   LHU V0, 24(S8)
9D015314  1440FFD6   BNE V0, ZERO, 0x9D015270
9D015318  00000000   NOP
778:                 			{// Add up to 64 bytes at a time to the sum
779:                 				lenB = TCPGetArray(sktHTTP, curHTTP.data, (lenA < 64u)?lenA:64);
9D015270  938281E8   LBU V0, -32280(GP)
9D015274  00401821   ADDU V1, V0, ZERO
9D015278  3C02A000   LUI V0, -24576
9D01527C  000318C0   SLL V1, V1, 3
9D015280  24420600   ADDIU V0, V0, 1536
9D015284  00621021   ADDU V0, V1, V0
9D015288  90420004   LBU V0, 4(V0)
9D01528C  00401821   ADDU V1, V0, ZERO
9D015290  97C20018   LHU V0, 24(S8)
9D015294  3044FFFF   ANDI A0, V0, -1
9D015298  2C840041   SLTIU A0, A0, 65
9D01529C  14800002   BNE A0, ZERO, 0x9D0152A8
9D0152A0  00000000   NOP
9D0152A4  24020040   ADDIU V0, ZERO, 64
9D0152A8  3042FFFF   ANDI V0, V0, -1
9D0152AC  00602021   ADDU A0, V1, ZERO
9D0152B0  3C03A000   LUI V1, -24576
9D0152B4  24650598   ADDIU A1, V1, 1432
9D0152B8  00403021   ADDU A2, V0, ZERO
9D0152BC  0F40077A   JAL TCPGetArray
9D0152C0  00000000   NOP
9D0152C4  A7C2001A   SH V0, 26(S8)
780:                 				curHTTP.byteCount -= lenB;
9D0152C8  3C02A000   LUI V0, -24576
9D0152CC  8C430574   LW V1, 1396(V0)
9D0152D0  97C2001A   LHU V0, 26(S8)
9D0152D4  00621823   SUBU V1, V1, V0
9D0152D8  3C02A000   LUI V0, -24576
9D0152DC  AC430574   SW V1, 1396(V0)
781:                 				lenA -= lenB;
9D0152E0  97C30018   LHU V1, 24(S8)
9D0152E4  97C2001A   LHU V0, 26(S8)
9D0152E8  00621023   SUBU V0, V1, V0
9D0152EC  A7C20018   SH V0, 24(S8)
782:                 				MD5AddData(&md5, curHTTP.data, lenB);
9D0152F0  97C2001A   LHU V0, 26(S8)
9D0152F4  3C03A000   LUI V1, -24576
9D0152F8  24643184   ADDIU A0, V1, 12676
9D0152FC  3C03A000   LUI V1, -24576
9D015300  24650598   ADDIU A1, V1, 1432
9D015304  00403021   ADDU A2, V0, ZERO
9D015308  0F40B9D8   JAL MD5AddData
9D01530C  00000000   NOP
783:                 			}
784:                 					
785:                 			// If we've read all the data
786:                 			if(curHTTP.byteCount == 0u)
9D01531C  3C02A000   LUI V0, -24576
9D015320  8C420574   LW V0, 1396(V0)
9D015324  1440000E   BNE V0, ZERO, 0x9D015360
9D015328  00000000   NOP
787:                 			{// Calculate and copy result to curHTTP.data for printout
788:                 				curHTTP.smPost = SM_MD5_POST_COMPLETE;
9D01532C  3C02A000   LUI V0, -24576
9D015330  24420574   ADDIU V0, V0, 1396
9D015334  24030003   ADDIU V1, ZERO, 3
9D015338  A0430088   SB V1, 136(V0)
789:                 				MD5Calculate(&md5, curHTTP.data);
9D01533C  3C02A000   LUI V0, -24576
9D015340  24443184   ADDIU A0, V0, 12676
9D015344  3C02A000   LUI V0, -24576
9D015348  24450598   ADDIU A1, V0, 1432
9D01534C  0F40BACB   JAL MD5Calculate
9D015350  00000000   NOP
790:                 				return HTTP_IO_DONE;
9D015354  00001021   ADDU V0, ZERO, ZERO
9D015358  0B4054DC   J 0x9D015370
9D01535C  00000000   NOP
791:                 			}
792:                 				
793:                 			// Ask for more data
794:                 			return HTTP_IO_NEED_DATA;
9D015360  24020001   ADDIU V0, ZERO, 1
9D015364  0B4054DC   J 0x9D015370
9D015368  00000000   NOP
795:                 	}
796:                 	
797:                 	return HTTP_IO_DONE;
9D01536C  00001021   ADDU V0, ZERO, ZERO
798:                 }
9D015370  03C0E821   ADDU SP, S8, ZERO
9D015374  8FBF002C   LW RA, 44(SP)
9D015378  8FBE0028   LW S8, 40(SP)
9D01537C  8FB00024   LW S0, 36(SP)
9D015380  27BD0030   ADDIU SP, SP, 48
9D015384  03E00008   JR RA
9D015388  00000000   NOP
799:                 #endif // #if defined(STACK_USE_HTTP_MD5_DEMO)
800:                 
801:                 /*****************************************************************************
802:                   Function:
803:                 	static HTTP_IO_RESULT HTTPPostEmail(void)
804:                 
805:                   Summary:
806:                 	Processes the e-mail form on email/index.htm
807:                 
808:                   Description:
809:                 	This function sends an e-mail message using the SMTP client and 
810:                 	optionally encrypts the connection to the SMTP server using SSL.  It
811:                 	demonstrates the use of the SMTP client, waiting for asynchronous
812:                 	processes in an HTTP callback, and how to send e-mail attachments using
813:                 	the stack.
814:                 
815:                 	Messages with attachments are sent using multipart/mixed MIME encoding,
816:                 	which has three sections.  The first has no headers, and is only to be
817:                 	displayed by old clients that cannot interpret the MIME format.  (The 
818:                 	overwhelming majority of these clients have been obseleted, but the
819:                 	so-called "ignored" section is still used.)  The second has a few 
820:                 	headers to indicate that it is the main body of the message in plain-
821:                 	text encoding.  The third section has headers indicating an attached 
822:                 	file, along with its name and type.  All sections are separated by a
823:                 	boundary string, which cannot appear anywhere else in the message.
824:                 	
825:                   Precondition:
826:                 	None
827:                 
828:                   Parameters:
829:                 	None
830:                 
831:                   Return Values:
832:                 	HTTP_IO_DONE - the message has been sent
833:                 	HTTP_IO_WAITING - the function is waiting for the SMTP process to complete
834:                 	HTTP_IO_NEED_DATA - data needed by this function has not yet arrived
835:                   ***************************************************************************/
836:                 #if defined(STACK_USE_SMTP_CLIENT)
837:                 static HTTP_IO_RESULT HTTPPostEmail(void)
838:                 {
9D01538C  27BDFFD0   ADDIU SP, SP, -48
9D015390  AFBF002C   SW RA, 44(SP)
9D015394  AFBE0028   SW S8, 40(SP)
9D015398  AFB00024   SW S0, 36(SP)
9D01539C  03A0F021   ADDU S8, SP, ZERO
839:                 	static BYTE *ptrData;
840:                 	static BYTE *szPort;
841:                 	#if defined(STACK_USE_SSL_CLIENT)
842:                 	static BYTE *szUseSSL;
843:                 	#endif
844:                 	WORD len, rem;
845:                 	BYTE cName[8];
846:                 
847:                 	#define SM_EMAIL_CLAIM_MODULE				(0u)
848:                 	#define SM_EMAIL_READ_PARAM_NAME			(1u)
849:                 	#define SM_EMAIL_READ_PARAM_VALUE			(2u)
850:                 	#define SM_EMAIL_PUT_IGNORED				(3u)
851:                 	#define SM_EMAIL_PUT_BODY					(4u)
852:                 	#define SM_EMAIL_PUT_ATTACHMENT_HEADER		(5u)
853:                 	#define SM_EMAIL_PUT_ATTACHMENT_DATA_BTNS	(6u)
854:                 	#define SM_EMAIL_PUT_ATTACHMENT_DATA_LEDS	(7u)
855:                 	#define SM_EMAIL_PUT_ATTACHMENT_DATA_POT	(8u)
856:                 	#define SM_EMAIL_PUT_TERMINATOR				(9u)
857:                 	#define SM_EMAIL_FINISHING					(10u)
858:                 	
859:                 	#define EMAIL_SPACE_REMAINING				(HTTP_MAX_DATA_LEN - (ptrData - curHTTP.data))
860:                 	
861:                 	switch(curHTTP.smPost)
9D0153A0  3C02A000   LUI V0, -24576
9D0153A4  24420574   ADDIU V0, V0, 1396
9D0153A8  90420088   LBU V0, 136(V0)
9D0153AC  2C43000B   SLTIU V1, V0, 11
9D0153B0  10600307   BEQ V1, ZERO, 0x9D015FD0
9D0153B4  00000000   NOP
9D0153B8  00021880   SLL V1, V0, 2
9D0153BC  3C029D01   LUI V0, -25343
9D0153C0  244253D4   ADDIU V0, V0, 21460
9D0153C4  00621021   ADDU V0, V1, V0
9D0153C8  8C420000   LW V0, 0(V0)
9D0153CC  00400008   JR V0
9D0153D0  00000000   NOP
862:                 	{
863:                 		case SM_EMAIL_CLAIM_MODULE:
864:                 			// Try to claim module
865:                 			if(SMTPBeginUsage())
9D015400  0F405CEF   JAL SMTPBeginUsage
9D015404  00000000   NOP
9D015408  1040002A   BEQ V0, ZERO, 0x9D0154B4
9D01540C  00000000   NOP
866:                 			{// Module was claimed, so set up static parameters
867:                 				SMTPClient.Subject.szROM = (ROM BYTE*)"Microchip TCP/IP Stack Status Update";
9D015410  3C029D03   LUI V0, -25341
9D015414  24433348   ADDIU V1, V0, 13128
9D015418  3C02A000   LUI V0, -24576
9D01541C  24420610   ADDIU V0, V0, 1552
9D015420  AC43001C   SW V1, 28(V0)
868:                 				SMTPClient.ROMPointers.Subject = 1;
9D015424  3C02A000   LUI V0, -24576
9D015428  24430610   ADDIU V1, V0, 1552
9D01542C  8C620028   LW V0, 40(V1)
9D015430  24040001   ADDIU A0, ZERO, 1
9D015434  7C8239C4   INS V0, A0, 7, 1
9D015438  AC620028   SW V0, 40(V1)
869:                 				SMTPClient.From.szROM = (ROM BYTE*)"\"SMTP Service\" <mchpboard@picsaregood.com>";
9D01543C  3C029D03   LUI V0, -25341
9D015440  24433370   ADDIU V1, V0, 13168
9D015444  3C02A000   LUI V0, -24576
9D015448  24420610   ADDIU V0, V0, 1552
9D01544C  AC430018   SW V1, 24(V0)
870:                 				SMTPClient.ROMPointers.From = 1;
9D015450  3C02A000   LUI V0, -24576
9D015454  24430610   ADDIU V1, V0, 1552
9D015458  8C620028   LW V0, 40(V1)
9D01545C  24040001   ADDIU A0, ZERO, 1
9D015460  7C823184   INS V0, A0, 6, 1
9D015464  AC620028   SW V0, 40(V1)
871:                 				
872:                 				// The following two lines indicate to the receiving client that 
873:                 				// this message has an attachment.  The boundary field *must not*
874:                 				// be included anywhere in the content of the message.  In real 
875:                 				// applications it is typically a long random string.
876:                 				SMTPClient.OtherHeaders.szROM = (ROM BYTE*)"MIME-version: 1.0\r\nContent-type: multipart/mixed; boundary=\"frontier\"\r\n";
9D015468  3C029D03   LUI V0, -25341
9D01546C  2443339C   ADDIU V1, V0, 13212
9D015470  3C02A000   LUI V0, -24576
9D015474  24420610   ADDIU V0, V0, 1552
9D015478  AC430020   SW V1, 32(V0)
877:                 				SMTPClient.ROMPointers.OtherHeaders = 1;
9D01547C  3C02A000   LUI V0, -24576
9D015480  24430610   ADDIU V1, V0, 1552
9D015484  8C620028   LW V0, 40(V1)
9D015488  24040001   ADDIU A0, ZERO, 1
9D01548C  7C824204   INS V0, A0, 8, 1
9D015490  AC620028   SW V0, 40(V1)
878:                 				
879:                 				// Move our state machine forward
880:                 				ptrData = curHTTP.data;
9D015494  3C02A000   LUI V0, -24576
9D015498  24420598   ADDIU V0, V0, 1432
9D01549C  AF8281C4   SW V0, -32316(GP)
881:                 				szPort = NULL;
9D0154A0  AF8081C8   SW ZERO, -32312(GP)
882:                 				curHTTP.smPost = SM_EMAIL_READ_PARAM_NAME;
9D0154A4  3C02A000   LUI V0, -24576
9D0154A8  24420574   ADDIU V0, V0, 1396
9D0154AC  24030001   ADDIU V1, ZERO, 1
9D0154B0  A0430088   SB V1, 136(V0)
883:                 			}
884:                 			return HTTP_IO_WAITING;			
9D0154B4  24020002   ADDIU V0, ZERO, 2
9D0154B8  0B4057F5   J 0x9D015FD4
9D0154BC  00000000   NOP
885:                 			
886:                 		case SM_EMAIL_READ_PARAM_NAME:
887:                 			// Search for a parameter name in POST data
888:                 			if(HTTPReadPostName(cName, sizeof(cName)) == HTTP_READ_INCOMPLETE)
9D0154C0  27C20014   ADDIU V0, S8, 20
9D0154C4  00402021   ADDU A0, V0, ZERO
9D0154C8  24050008   ADDIU A1, ZERO, 8
9D0154CC  0F404EF1   JAL HTTPReadPostName
9D0154D0  00000000   NOP
9D0154D4  00401821   ADDU V1, V0, ZERO
9D0154D8  24020002   ADDIU V0, ZERO, 2
9D0154DC  14620004   BNE V1, V0, 0x9D0154F0
9D0154E0  00000000   NOP
889:                 				return HTTP_IO_NEED_DATA;
9D0154E4  24020001   ADDIU V0, ZERO, 1
9D0154E8  0B4057F5   J 0x9D015FD4
9D0154EC  00000000   NOP
890:                 			
891:                 			// Try to match the name value
892:                 			if(!strcmppgm2ram((char*)cName, (ROM char*)"server"))
9D0154F0  27C20014   ADDIU V0, S8, 20
9D0154F4  00402021   ADDU A0, V0, ZERO
9D0154F8  3C029D03   LUI V0, -25341
9D0154FC  244533E4   ADDIU A1, V0, 13284
9D015500  0F40D48D   JAL 0x9D035234
9D015504  00000000   NOP
9D015508  1440000A   BNE V0, ZERO, 0x9D015534
9D01550C  00000000   NOP
893:                 			{// Read the server name
894:                 				SMTPClient.Server.szRAM = ptrData;
9D015510  8F8381C4   LW V1, -32316(GP)
9D015514  3C02A000   LUI V0, -24576
9D015518  AC430610   SW V1, 1552(V0)
895:                 				curHTTP.smPost = SM_EMAIL_READ_PARAM_VALUE;
9D01551C  3C02A000   LUI V0, -24576
9D015520  24420574   ADDIU V0, V0, 1396
9D015524  24030002   ADDIU V1, ZERO, 2
9D015528  A0430088   SB V1, 136(V0)
9D01552C  0B4055E3   J 0x9D01578C
9D015530  00000000   NOP
896:                 			}
897:                 			else if(!strcmppgm2ram((char*)cName, (ROM char*)"port"))
9D015534  27C20014   ADDIU V0, S8, 20
9D015538  00402021   ADDU A0, V0, ZERO
9D01553C  3C029D03   LUI V0, -25341
9D015540  244533EC   ADDIU A1, V0, 13292
9D015544  0F40D48D   JAL 0x9D035234
9D015548  00000000   NOP
9D01554C  14400009   BNE V0, ZERO, 0x9D015574
9D015550  00000000   NOP
898:                 			{// Read the server port
899:                 				szPort = ptrData;
9D015554  8F8281C4   LW V0, -32316(GP)
9D015558  AF8281C8   SW V0, -32312(GP)
900:                 				curHTTP.smPost = SM_EMAIL_READ_PARAM_VALUE;
9D01555C  3C02A000   LUI V0, -24576
9D015560  24420574   ADDIU V0, V0, 1396
9D015564  24030002   ADDIU V1, ZERO, 2
9D015568  A0430088   SB V1, 136(V0)
9D01556C  0B4055E3   J 0x9D01578C
9D015570  00000000   NOP
901:                 			}
902:                 			#if defined(STACK_USE_SSL_CLIENT)
903:                 			else if(!strcmppgm2ram((char*)cName, (ROM char*)"ssl"))
904:                 			{// Read the server port
905:                 				szUseSSL = ptrData;
906:                 				curHTTP.smPost = SM_EMAIL_READ_PARAM_VALUE;
907:                 			}
908:                 			#endif
909:                 			else if(!strcmppgm2ram((char*)cName, (ROM char*)"user"))
9D015574  27C20014   ADDIU V0, S8, 20
9D015578  00402021   ADDU A0, V0, ZERO
9D01557C  3C029D03   LUI V0, -25341
9D015580  244533F4   ADDIU A1, V0, 13300
9D015584  0F40D48D   JAL 0x9D035234
9D015588  00000000   NOP
9D01558C  1440000B   BNE V0, ZERO, 0x9D0155BC
9D015590  00000000   NOP
910:                 			{// Read the user name
911:                 				SMTPClient.Username.szRAM = ptrData;
9D015594  8F8381C4   LW V1, -32316(GP)
9D015598  3C02A000   LUI V0, -24576
9D01559C  24420610   ADDIU V0, V0, 1552
9D0155A0  AC430004   SW V1, 4(V0)
912:                 				curHTTP.smPost = SM_EMAIL_READ_PARAM_VALUE;
9D0155A4  3C02A000   LUI V0, -24576
9D0155A8  24420574   ADDIU V0, V0, 1396
9D0155AC  24030002   ADDIU V1, ZERO, 2
9D0155B0  A0430088   SB V1, 136(V0)
9D0155B4  0B4055E3   J 0x9D01578C
9D0155B8  00000000   NOP
913:                 			}
914:                 			else if(!strcmppgm2ram((char*)cName, (ROM char*)"pass"))
9D0155BC  27C20014   ADDIU V0, S8, 20
9D0155C0  00402021   ADDU A0, V0, ZERO
9D0155C4  3C029D03   LUI V0, -25341
9D0155C8  244533FC   ADDIU A1, V0, 13308
9D0155CC  0F40D48D   JAL 0x9D035234
9D0155D0  00000000   NOP
9D0155D4  1440000B   BNE V0, ZERO, 0x9D015604
9D0155D8  00000000   NOP
915:                 			{// Read the password
916:                 				SMTPClient.Password.szRAM = ptrData;
9D0155DC  8F8381C4   LW V1, -32316(GP)
9D0155E0  3C02A000   LUI V0, -24576
9D0155E4  24420610   ADDIU V0, V0, 1552
9D0155E8  AC430008   SW V1, 8(V0)
917:                 				curHTTP.smPost = SM_EMAIL_READ_PARAM_VALUE;
9D0155EC  3C02A000   LUI V0, -24576
9D0155F0  24420574   ADDIU V0, V0, 1396
9D0155F4  24030002   ADDIU V1, ZERO, 2
9D0155F8  A0430088   SB V1, 136(V0)
9D0155FC  0B4055E3   J 0x9D01578C
9D015600  00000000   NOP
918:                 			}
919:                 			else if(!strcmppgm2ram((char*)cName, (ROM char*)"to"))
9D015604  27C20014   ADDIU V0, S8, 20
9D015608  00402021   ADDU A0, V0, ZERO
9D01560C  3C029D03   LUI V0, -25341
9D015610  24453404   ADDIU A1, V0, 13316
9D015614  0F40D48D   JAL 0x9D035234
9D015618  00000000   NOP
9D01561C  1440000B   BNE V0, ZERO, 0x9D01564C
9D015620  00000000   NOP
920:                 			{// Read the To string
921:                 				SMTPClient.To.szRAM = ptrData;
9D015624  8F8381C4   LW V1, -32316(GP)
9D015628  3C02A000   LUI V0, -24576
9D01562C  24420610   ADDIU V0, V0, 1552
9D015630  AC43000C   SW V1, 12(V0)
922:                 				curHTTP.smPost = SM_EMAIL_READ_PARAM_VALUE;
9D015634  3C02A000   LUI V0, -24576
9D015638  24420574   ADDIU V0, V0, 1396
9D01563C  24030002   ADDIU V1, ZERO, 2
9D015640  A0430088   SB V1, 136(V0)
9D015644  0B4055E3   J 0x9D01578C
9D015648  00000000   NOP
923:                 			}
924:                 			else if(!strcmppgm2ram((char*)cName, (ROM char*)"msg"))
9D01564C  27C20014   ADDIU V0, S8, 20
9D015650  00402021   ADDU A0, V0, ZERO
9D015654  3C029D03   LUI V0, -25341
9D015658  24453408   ADDIU A1, V0, 13320
9D01565C  0F40D48D   JAL 0x9D035234
9D015660  00000000   NOP
9D015664  14400045   BNE V0, ZERO, 0x9D01577C
9D015668  00000000   NOP
925:                 			{// Done with headers, move on to the message
926:                 				// Delete paramters that are just null strings (no data from user) or illegal (ex: password without username)
927:                 				if(SMTPClient.Server.szRAM)
9D01566C  3C02A000   LUI V0, -24576
9D015670  8C420610   LW V0, 1552(V0)
9D015674  10400008   BEQ V0, ZERO, 0x9D015698
9D015678  00000000   NOP
928:                 					if(*SMTPClient.Server.szRAM == 0x00u)
9D01567C  3C02A000   LUI V0, -24576
9D015680  8C420610   LW V0, 1552(V0)
9D015684  90420000   LBU V0, 0(V0)
9D015688  14400003   BNE V0, ZERO, 0x9D015698
9D01568C  00000000   NOP
929:                 						SMTPClient.Server.szRAM = NULL;
9D015690  3C02A000   LUI V0, -24576
9D015694  AC400610   SW ZERO, 1552(V0)
930:                 				if(SMTPClient.Username.szRAM)
9D015698  3C02A000   LUI V0, -24576
9D01569C  24420610   ADDIU V0, V0, 1552
9D0156A0  8C420004   LW V0, 4(V0)
9D0156A4  1040000A   BEQ V0, ZERO, 0x9D0156D0
9D0156A8  00000000   NOP
931:                 					if(*SMTPClient.Username.szRAM == 0x00u)
9D0156AC  3C02A000   LUI V0, -24576
9D0156B0  24420610   ADDIU V0, V0, 1552
9D0156B4  8C420004   LW V0, 4(V0)
9D0156B8  90420000   LBU V0, 0(V0)
9D0156BC  14400004   BNE V0, ZERO, 0x9D0156D0
9D0156C0  00000000   NOP
932:                 						SMTPClient.Username.szRAM = NULL;
9D0156C4  3C02A000   LUI V0, -24576
9D0156C8  24420610   ADDIU V0, V0, 1552
9D0156CC  AC400004   SW ZERO, 4(V0)
933:                 				if(SMTPClient.Password.szRAM)
9D0156D0  3C02A000   LUI V0, -24576
9D0156D4  24420610   ADDIU V0, V0, 1552
9D0156D8  8C420008   LW V0, 8(V0)
9D0156DC  1040000F   BEQ V0, ZERO, 0x9D01571C
9D0156E0  00000000   NOP
934:                 					if((*SMTPClient.Password.szRAM == 0x00u) || (SMTPClient.Username.szRAM == NULL))
9D0156E4  3C02A000   LUI V0, -24576
9D0156E8  24420610   ADDIU V0, V0, 1552
9D0156EC  8C420008   LW V0, 8(V0)
9D0156F0  90420000   LBU V0, 0(V0)
9D0156F4  10400006   BEQ V0, ZERO, 0x9D015710
9D0156F8  00000000   NOP
9D0156FC  3C02A000   LUI V0, -24576
9D015700  24420610   ADDIU V0, V0, 1552
9D015704  8C420004   LW V0, 4(V0)
9D015708  14400004   BNE V0, ZERO, 0x9D01571C
9D01570C  00000000   NOP
935:                 						SMTPClient.Password.szRAM = NULL;
9D015710  3C02A000   LUI V0, -24576
9D015714  24420610   ADDIU V0, V0, 1552
9D015718  AC400008   SW ZERO, 8(V0)
936:                 				
937:                 				// Decode server port string if it exists
938:                 				if(szPort)
9D01571C  8F8281C8   LW V0, -32312(GP)
9D015720  1040000D   BEQ V0, ZERO, 0x9D015758
9D015724  00000000   NOP
939:                 					if(*szPort)
9D015728  8F8281C8   LW V0, -32312(GP)
9D01572C  90420000   LBU V0, 0(V0)
9D015730  10400009   BEQ V0, ZERO, 0x9D015758
9D015734  00000000   NOP
940:                 						SMTPClient.ServerPort = (WORD)atol((char*)szPort);
9D015738  8F8281C8   LW V0, -32312(GP)
9D01573C  00402021   ADDU A0, V0, ZERO
9D015740  0F40D63E   JAL atol
9D015744  00000000   NOP
9D015748  3043FFFF   ANDI V1, V0, -1
9D01574C  3C02A000   LUI V0, -24576
9D015750  24420610   ADDIU V0, V0, 1552
9D015754  A443002A   SH V1, 42(V0)
941:                 
942:                 				// Determine if SSL should be used
943:                 				#if defined(STACK_USE_SSL_CLIENT)
944:                 				if(szUseSSL)
945:                 					if(*szUseSSL == '1')
946:                 						SMTPClient.UseSSL = TRUE;
947:                 				#endif
948:                 				
949:                 				// Start sending the message
950:                 				SMTPSendMail();
9D015758  0F406576   JAL SMTPSendMail
9D01575C  00000000   NOP
951:                 				curHTTP.smPost = SM_EMAIL_PUT_IGNORED;
9D015760  3C02A000   LUI V0, -24576
9D015764  24420574   ADDIU V0, V0, 1396
9D015768  24030003   ADDIU V1, ZERO, 3
9D01576C  A0430088   SB V1, 136(V0)
952:                 				return HTTP_IO_WAITING;
9D015770  24020002   ADDIU V0, ZERO, 2
9D015774  0B4057F5   J 0x9D015FD4
9D015778  00000000   NOP
953:                 			}
954:                 			else
955:                 			{// Don't know what we're receiving
956:                 				curHTTP.smPost = SM_EMAIL_READ_PARAM_VALUE;
9D01577C  3C02A000   LUI V0, -24576
9D015780  24420574   ADDIU V0, V0, 1396
9D015784  24030002   ADDIU V1, ZERO, 2
9D015788  A0430088   SB V1, 136(V0)
957:                 			}
958:                 			
959:                 			// No break...continue to try reading the value
960:                 		
961:                 		case SM_EMAIL_READ_PARAM_VALUE:
962:                 			// Search for a parameter value in POST data
963:                 			if(HTTPReadPostValue(ptrData, EMAIL_SPACE_REMAINING) == HTTP_READ_INCOMPLETE)
9D01578C  8F8381C4   LW V1, -32316(GP)
9D015790  8F8281C4   LW V0, -32316(GP)
9D015794  3042FFFF   ANDI V0, V0, -1
9D015798  00021023   SUBU V0, ZERO, V0
9D01579C  3044FFFF   ANDI A0, V0, -1
9D0157A0  3C02A000   LUI V0, -24576
9D0157A4  24420598   ADDIU V0, V0, 1432
9D0157A8  3042FFFF   ANDI V0, V0, -1
9D0157AC  24420064   ADDIU V0, V0, 100
9D0157B0  3042FFFF   ANDI V0, V0, -1
9D0157B4  00821021   ADDU V0, A0, V0
9D0157B8  3042FFFF   ANDI V0, V0, -1
9D0157BC  00602021   ADDU A0, V1, ZERO
9D0157C0  00402821   ADDU A1, V0, ZERO
9D0157C4  0F404F10   JAL HTTPReadPostValue
9D0157C8  00000000   NOP
9D0157CC  00401821   ADDU V1, V0, ZERO
9D0157D0  24020002   ADDIU V0, ZERO, 2
9D0157D4  14620004   BNE V1, V0, 0x9D0157E8
9D0157D8  00000000   NOP
964:                 				return HTTP_IO_NEED_DATA;
9D0157DC  24020001   ADDIU V0, ZERO, 1
9D0157E0  0B4057F5   J 0x9D015FD4
9D0157E4  00000000   NOP
965:                 				
966:                 			// Move past the data that was just read
967:                 			ptrData += strlen((char*)ptrData);
9D0157E8  8F9081C4   LW S0, -32316(GP)
9D0157EC  8F8281C4   LW V0, -32316(GP)
9D0157F0  00402021   ADDU A0, V0, ZERO
9D0157F4  0F40D2F2   JAL 0x9D034BC8
9D0157F8  00000000   NOP
9D0157FC  02021021   ADDU V0, S0, V0
9D015800  AF8281C4   SW V0, -32316(GP)
968:                 			if(ptrData < curHTTP.data + HTTP_MAX_DATA_LEN - 1)
9D015804  8F8381C4   LW V1, -32316(GP)
9D015808  3C02A000   LUI V0, -24576
9D01580C  244205FB   ADDIU V0, V0, 1531
9D015810  0062102B   SLTU V0, V1, V0
9D015814  10400004   BEQ V0, ZERO, 0x9D015828
9D015818  00000000   NOP
969:                 				ptrData += 1;
9D01581C  8F8281C4   LW V0, -32316(GP)
9D015820  24420001   ADDIU V0, V0, 1
9D015824  AF8281C4   SW V0, -32316(GP)
970:                 			
971:                 			// Try reading the next parameter
972:                 			curHTTP.smPost = SM_EMAIL_READ_PARAM_NAME;
9D015828  3C02A000   LUI V0, -24576
9D01582C  24420574   ADDIU V0, V0, 1396
9D015830  24030001   ADDIU V1, ZERO, 1
9D015834  A0430088   SB V1, 136(V0)
973:                 			return HTTP_IO_WAITING;
9D015838  24020002   ADDIU V0, ZERO, 2
9D01583C  0B4057F5   J 0x9D015FD4
9D015840  00000000   NOP
974:                 			
975:                 		case SM_EMAIL_PUT_IGNORED:
976:                 			// This section puts a message that is ignored by compatible clients.
977:                 			// This text will not display unless the receiving client is obselete 
978:                 			// and does not understand the MIME structure.
979:                 			// The "--frontier" indicates the start of a section, then any
980:                 			// needed MIME headers follow, then two CRLF pairs, and then
981:                 			// the actual content (which will be the body text in the next state).
982:                 			
983:                 			// Check to see if a failure occured
984:                 			if(!SMTPIsBusy())
9D015844  0F406582   JAL SMTPIsBusy
9D015848  00000000   NOP
9D01584C  14400008   BNE V0, ZERO, 0x9D015870
9D015850  00000000   NOP
985:                 			{
986:                 				curHTTP.smPost = SM_EMAIL_FINISHING;
9D015854  3C02A000   LUI V0, -24576
9D015858  24420574   ADDIU V0, V0, 1396
9D01585C  2403000A   ADDIU V1, ZERO, 10
9D015860  A0430088   SB V1, 136(V0)
987:                 				return HTTP_IO_WAITING;
9D015864  24020002   ADDIU V0, ZERO, 2
9D015868  0B4057F5   J 0x9D015FD4
9D01586C  00000000   NOP
988:                 			}
989:                 		
990:                 			// See if we're ready to write data
991:                 			if(SMTPIsPutReady() < 90u)
9D015870  0F40658C   JAL SMTPIsPutReady
9D015874  00000000   NOP
9D015878  2C42005A   SLTIU V0, V0, 90
9D01587C  10400004   BEQ V0, ZERO, 0x9D015890
9D015880  00000000   NOP
992:                 				return HTTP_IO_WAITING;
9D015884  24020002   ADDIU V0, ZERO, 2
9D015888  0B4057F5   J 0x9D015FD4
9D01588C  00000000   NOP
993:                 				
994:                 			// Write the ignored text				
995:                 			SMTPPutROMString((ROM BYTE*)"This is a multi-part message in MIME format.\r\n");
9D015890  3C029D03   LUI V0, -25341
9D015894  2442340C   ADDIU V0, V0, 13324
9D015898  00402021   ADDU A0, V0, ZERO
9D01589C  0F406638   JAL SMTPPutString
9D0158A0  00000000   NOP
996:                 			SMTPPutROMString((ROM BYTE*)"--frontier\r\nContent-type: text/plain\r\n\r\n");
9D0158A4  3C029D03   LUI V0, -25341
9D0158A8  2442343C   ADDIU V0, V0, 13372
9D0158AC  00402021   ADDU A0, V0, ZERO
9D0158B0  0F406638   JAL SMTPPutString
9D0158B4  00000000   NOP
997:                 			SMTPFlush();
9D0158B8  0F40665F   JAL SMTPFlush
9D0158BC  00000000   NOP
998:                 			
999:                 			// Move to the next state
1000:                			curHTTP.smPost = SM_EMAIL_PUT_BODY;
9D0158C0  3C02A000   LUI V0, -24576
9D0158C4  24420574   ADDIU V0, V0, 1396
9D0158C8  24030004   ADDIU V1, ZERO, 4
9D0158CC  A0430088   SB V1, 136(V0)
1001:                			
1002:                		case SM_EMAIL_PUT_BODY:
1003:                			// Write as much body text as is available from the TCP buffer
1004:                			// return HTTP_IO_NEED_DATA or HTTP_IO_WAITING
1005:                			// On completion, => PUT_ATTACHMENT_HEADER and continue
1006:                			
1007:                			// Check to see if a failure occurred
1008:                			if(!SMTPIsBusy())
9D0158D0  0F406582   JAL SMTPIsBusy
9D0158D4  00000000   NOP
9D0158D8  14400054   BNE V0, ZERO, 0x9D015A2C
9D0158DC  00000000   NOP
1009:                			{
1010:                				curHTTP.smPost = SM_EMAIL_FINISHING;
9D0158E0  3C02A000   LUI V0, -24576
9D0158E4  24420574   ADDIU V0, V0, 1396
9D0158E8  2403000A   ADDIU V1, ZERO, 10
9D0158EC  A0430088   SB V1, 136(V0)
1011:                				return HTTP_IO_WAITING;
9D0158F0  24020002   ADDIU V0, ZERO, 2
9D0158F4  0B4057F5   J 0x9D015FD4
9D0158F8  00000000   NOP
1012:                			}
1013:                			
1014:                			// Loop as long as data remains to be read
1015:                			while(curHTTP.byteCount)
9D015A2C  00000000   NOP
9D015A30  3C02A000   LUI V0, -24576
9D015A34  8C420574   LW V0, 1396(V0)
9D015A38  1440FFB0   BNE V0, ZERO, 0x9D0158FC
9D015A3C  00000000   NOP
1016:                			{
1017:                				// See if space is available to write
1018:                				len = SMTPIsPutReady();
9D0158FC  0F40658C   JAL SMTPIsPutReady
9D015900  00000000   NOP
9D015904  A7C20010   SH V0, 16(S8)
1019:                				if(len == 0u)
9D015908  97C20010   LHU V0, 16(S8)
9D01590C  14400004   BNE V0, ZERO, 0x9D015920
9D015910  00000000   NOP
1020:                					return HTTP_IO_WAITING;
9D015914  24020002   ADDIU V0, ZERO, 2
9D015918  0B4057F5   J 0x9D015FD4
9D01591C  00000000   NOP
1021:                				
1022:                				// See if data is ready to be read
1023:                				rem = TCPIsGetReady(sktHTTP);
9D015920  938281E8   LBU V0, -32280(GP)
9D015924  00401821   ADDU V1, V0, ZERO
9D015928  3C02A000   LUI V0, -24576
9D01592C  000318C0   SLL V1, V1, 3
9D015930  24420600   ADDIU V0, V0, 1536
9D015934  00621021   ADDU V0, V1, V0
9D015938  90420004   LBU V0, 4(V0)
9D01593C  00402021   ADDU A0, V0, ZERO
9D015940  0F400675   JAL TCPIsGetReady
9D015944  00000000   NOP
9D015948  A7C20012   SH V0, 18(S8)
1024:                				if(rem == 0u)
9D01594C  97C20012   LHU V0, 18(S8)
9D015950  14400004   BNE V0, ZERO, 0x9D015964
9D015954  00000000   NOP
1025:                					return HTTP_IO_NEED_DATA;
9D015958  24020001   ADDIU V0, ZERO, 1
9D01595C  0B4057F5   J 0x9D015FD4
9D015960  00000000   NOP
1026:                				
1027:                				// Only write as much as we can handle
1028:                				if(len > rem)
9D015964  97C30010   LHU V1, 16(S8)
9D015968  97C20012   LHU V0, 18(S8)
9D01596C  0043102B   SLTU V0, V0, V1
9D015970  10400003   BEQ V0, ZERO, 0x9D015980
9D015974  00000000   NOP
1029:                					len = rem;
9D015978  97C20012   LHU V0, 18(S8)
9D01597C  A7C20010   SH V0, 16(S8)
1030:                				if(len > HTTP_MAX_DATA_LEN - 2)
9D015980  97C20010   LHU V0, 16(S8)
9D015984  2C420063   SLTIU V0, V0, 99
9D015988  14400003   BNE V0, ZERO, 0x9D015998
9D01598C  00000000   NOP
1031:                					len = HTTP_MAX_DATA_LEN - 2;
9D015990  24020062   ADDIU V0, ZERO, 98
9D015994  A7C20010   SH V0, 16(S8)
1032:                				
1033:                				// Read the data from HTTP POST buffer and send it to SMTP
1034:                				curHTTP.byteCount -= TCPGetArray(sktHTTP, curHTTP.data, len);
9D015998  3C02A000   LUI V0, -24576
9D01599C  8C500574   LW S0, 1396(V0)
9D0159A0  938281E8   LBU V0, -32280(GP)
9D0159A4  00401821   ADDU V1, V0, ZERO
9D0159A8  3C02A000   LUI V0, -24576
9D0159AC  000318C0   SLL V1, V1, 3
9D0159B0  24420600   ADDIU V0, V0, 1536
9D0159B4  00621021   ADDU V0, V1, V0
9D0159B8  90420004   LBU V0, 4(V0)
9D0159BC  00401821   ADDU V1, V0, ZERO
9D0159C0  97C20010   LHU V0, 16(S8)
9D0159C4  00602021   ADDU A0, V1, ZERO
9D0159C8  3C03A000   LUI V1, -24576
9D0159CC  24650598   ADDIU A1, V1, 1432
9D0159D0  00403021   ADDU A2, V0, ZERO
9D0159D4  0F40077A   JAL TCPGetArray
9D0159D8  00000000   NOP
9D0159DC  02021823   SUBU V1, S0, V0
9D0159E0  3C02A000   LUI V0, -24576
9D0159E4  AC430574   SW V1, 1396(V0)
1035:                				curHTTP.data[len] = '\0';
9D0159E8  97C30010   LHU V1, 16(S8)
9D0159EC  3C02A000   LUI V0, -24576
9D0159F0  24420574   ADDIU V0, V0, 1396
9D0159F4  00621021   ADDU V0, V1, V0
9D0159F8  A0400024   SB ZERO, 36(V0)
1036:                				HTTPURLDecode(curHTTP.data);
9D0159FC  3C02A000   LUI V0, -24576
9D015A00  24440598   ADDIU A0, V0, 1432
9D015A04  0F404E46   JAL HTTPURLDecode
9D015A08  00000000   NOP
1037:                				SMTPPutString(curHTTP.data);
9D015A0C  3C02A000   LUI V0, -24576
9D015A10  24440598   ADDIU A0, V0, 1432
9D015A14  0F406638   JAL SMTPPutString
9D015A18  00000000   NOP
1038:                				SMTPFlush();
9D015A1C  0F40665F   JAL SMTPFlush
9D015A20  00000000   NOP
9D015A24  0B40568C   J 0x9D015A30
9D015A28  00000000   NOP
1039:                			}
1040:                			
1041:                			// We're done with the POST data, so continue
1042:                			curHTTP.smPost = SM_EMAIL_PUT_ATTACHMENT_HEADER;
9D015A40  3C02A000   LUI V0, -24576
9D015A44  24420574   ADDIU V0, V0, 1396
9D015A48  24030005   ADDIU V1, ZERO, 5
9D015A4C  A0430088   SB V1, 136(V0)
1043:                						
1044:                		case SM_EMAIL_PUT_ATTACHMENT_HEADER:
1045:                			// This section writes the attachment to the message.
1046:                			// This portion generally will not display in the reader, but
1047:                			// will be downloadable to the local machine.  Use caution
1048:                			// when selecting the content-type and file name, as certain
1049:                			// types and extensions are blocked by virus filters.
1050:                
1051:                			// The same structure as the message body is used.
1052:                			// Any attachment must not include high-bit ASCII characters or
1053:                			// binary data.  If binary data is to be sent, the data should
1054:                			// be encoded using Base64 and a MIME header should be added:
1055:                			// Content-transfer-encoding: base64
1056:                			
1057:                			// Check to see if a failure occurred
1058:                			if(!SMTPIsBusy())
9D015A50  0F406582   JAL SMTPIsBusy
9D015A54  00000000   NOP
9D015A58  14400008   BNE V0, ZERO, 0x9D015A7C
9D015A5C  00000000   NOP
1059:                			{
1060:                				curHTTP.smPost = SM_EMAIL_FINISHING;
9D015A60  3C02A000   LUI V0, -24576
9D015A64  24420574   ADDIU V0, V0, 1396
9D015A68  2403000A   ADDIU V1, ZERO, 10
9D015A6C  A0430088   SB V1, 136(V0)
1061:                				return HTTP_IO_WAITING;
9D015A70  24020002   ADDIU V0, ZERO, 2
9D015A74  0B4057F5   J 0x9D015FD4
9D015A78  00000000   NOP
1062:                			}
1063:                			
1064:                			// See if we're ready to write data
1065:                			if(SMTPIsPutReady() < 100u)
9D015A7C  0F40658C   JAL SMTPIsPutReady
9D015A80  00000000   NOP
9D015A84  2C420064   SLTIU V0, V0, 100
9D015A88  10400004   BEQ V0, ZERO, 0x9D015A9C
9D015A8C  00000000   NOP
1066:                				return HTTP_IO_WAITING;
9D015A90  24020002   ADDIU V0, ZERO, 2
9D015A94  0B4057F5   J 0x9D015FD4
9D015A98  00000000   NOP
1067:                			
1068:                			// Write the attachment header
1069:                			SMTPPutROMString((ROM BYTE*)"\r\n--frontier\r\nContent-type: text/csv\r\nContent-Disposition: attachment; filename=\"status.csv\"\r\n\r\n");
9D015A9C  3C029D03   LUI V0, -25341
9D015AA0  24423468   ADDIU V0, V0, 13416
9D015AA4  00402021   ADDU A0, V0, ZERO
9D015AA8  0F406638   JAL SMTPPutString
9D015AAC  00000000   NOP
1070:                			SMTPFlush();
9D015AB0  0F40665F   JAL SMTPFlush
9D015AB4  00000000   NOP
1071:                			
1072:                			// Move to the next state
1073:                			curHTTP.smPost = SM_EMAIL_PUT_ATTACHMENT_DATA_BTNS;
9D015AB8  3C02A000   LUI V0, -24576
9D015ABC  24420574   ADDIU V0, V0, 1396
9D015AC0  24030006   ADDIU V1, ZERO, 6
9D015AC4  A0430088   SB V1, 136(V0)
1074:                			
1075:                		case SM_EMAIL_PUT_ATTACHMENT_DATA_BTNS:
1076:                			// The following states output the system status as a CSV file.
1077:                			
1078:                			// Check to see if a failure occurred
1079:                			if(!SMTPIsBusy())
9D015AC8  0F406582   JAL SMTPIsBusy
9D015ACC  00000000   NOP
9D015AD0  14400008   BNE V0, ZERO, 0x9D015AF4
9D015AD4  00000000   NOP
1080:                			{
1081:                				curHTTP.smPost = SM_EMAIL_FINISHING;
9D015AD8  3C02A000   LUI V0, -24576
9D015ADC  24420574   ADDIU V0, V0, 1396
9D015AE0  2403000A   ADDIU V1, ZERO, 10
9D015AE4  A0430088   SB V1, 136(V0)
1082:                				return HTTP_IO_WAITING;
9D015AE8  24020002   ADDIU V0, ZERO, 2
9D015AEC  0B4057F5   J 0x9D015FD4
9D015AF0  00000000   NOP
1083:                			}
1084:                			
1085:                			// See if we're ready to write data
1086:                			if(SMTPIsPutReady() < 36u)
9D015AF4  0F40658C   JAL SMTPIsPutReady
9D015AF8  00000000   NOP
9D015AFC  2C420024   SLTIU V0, V0, 36
9D015B00  10400004   BEQ V0, ZERO, 0x9D015B14
9D015B04  00000000   NOP
1087:                				return HTTP_IO_WAITING;
9D015B08  24020002   ADDIU V0, ZERO, 2
9D015B0C  0B4057F5   J 0x9D015FD4
9D015B10  00000000   NOP
1088:                				
1089:                			// Write the header and button strings
1090:                			SMTPPutROMString((ROM BYTE*)"SYSTEM STATUS\r\n");
9D015B14  3C029D03   LUI V0, -25341
9D015B18  244234CC   ADDIU V0, V0, 13516
9D015B1C  00402021   ADDU A0, V0, ZERO
9D015B20  0F406638   JAL SMTPPutString
9D015B24  00000000   NOP
1091:                			SMTPPutROMString((ROM BYTE*)"Buttons:,");
9D015B28  3C029D03   LUI V0, -25341
9D015B2C  244234DC   ADDIU V0, V0, 13532
9D015B30  00402021   ADDU A0, V0, ZERO
9D015B34  0F406638   JAL SMTPPutString
9D015B38  00000000   NOP
1092:                			SMTPPut(BUTTON0_IO + '0');
9D015B3C  3C02BF88   LUI V0, -16504
9D015B40  8C4260D0   LW V0, 24784(V0)
9D015B44  7C420180   EXT V0, V0, 6, 1
9D015B48  304200FF   ANDI V0, V0, 255
9D015B4C  24420030   ADDIU V0, V0, 48
9D015B50  304200FF   ANDI V0, V0, 255
9D015B54  00402021   ADDU A0, V0, ZERO
9D015B58  0F4065A1   JAL SMTPPut
9D015B5C  00000000   NOP
1093:                			SMTPPut(',');
9D015B60  2404002C   ADDIU A0, ZERO, 44
9D015B64  0F4065A1   JAL SMTPPut
9D015B68  00000000   NOP
1094:                			SMTPPut(BUTTON1_IO + '0');
9D015B6C  3C02BF88   LUI V0, -16504
9D015B70  8C4260D0   LW V0, 24784(V0)
9D015B74  7C4201C0   EXT V0, V0, 7, 1
9D015B78  304200FF   ANDI V0, V0, 255
9D015B7C  24420030   ADDIU V0, V0, 48
9D015B80  304200FF   ANDI V0, V0, 255
9D015B84  00402021   ADDU A0, V0, ZERO
9D015B88  0F4065A1   JAL SMTPPut
9D015B8C  00000000   NOP
1095:                			SMTPPut(',');
9D015B90  2404002C   ADDIU A0, ZERO, 44
9D015B94  0F4065A1   JAL SMTPPut
9D015B98  00000000   NOP
1096:                			SMTPPut(BUTTON2_IO + '0');
9D015B9C  3C02BF88   LUI V0, -16504
9D015BA0  8C4260D0   LW V0, 24784(V0)
9D015BA4  7C420340   EXT V0, V0, 13, 1
9D015BA8  304200FF   ANDI V0, V0, 255
9D015BAC  24420030   ADDIU V0, V0, 48
9D015BB0  304200FF   ANDI V0, V0, 255
9D015BB4  00402021   ADDU A0, V0, ZERO
9D015BB8  0F4065A1   JAL SMTPPut
9D015BBC  00000000   NOP
1097:                			SMTPPut(',');
9D015BC0  2404002C   ADDIU A0, ZERO, 44
9D015BC4  0F4065A1   JAL SMTPPut
9D015BC8  00000000   NOP
1098:                			SMTPPut(BUTTON3_IO + '0');
9D015BCC  24040031   ADDIU A0, ZERO, 49
9D015BD0  0F4065A1   JAL SMTPPut
9D015BD4  00000000   NOP
1099:                			SMTPPut('\r');
9D015BD8  2404000D   ADDIU A0, ZERO, 13
9D015BDC  0F4065A1   JAL SMTPPut
9D015BE0  00000000   NOP
1100:                			SMTPPut('\n');
9D015BE4  2404000A   ADDIU A0, ZERO, 10
9D015BE8  0F4065A1   JAL SMTPPut
9D015BEC  00000000   NOP
1101:                			SMTPFlush();
9D015BF0  0F40665F   JAL SMTPFlush
9D015BF4  00000000   NOP
1102:                			
1103:                			// Move to the next state
1104:                			curHTTP.smPost = SM_EMAIL_PUT_ATTACHMENT_DATA_LEDS;
9D015BF8  3C02A000   LUI V0, -24576
9D015BFC  24420574   ADDIU V0, V0, 1396
9D015C00  24030007   ADDIU V1, ZERO, 7
9D015C04  A0430088   SB V1, 136(V0)
1105:                
1106:                		case SM_EMAIL_PUT_ATTACHMENT_DATA_LEDS:
1107:                			// Check to see if a failure occurred
1108:                			if(!SMTPIsBusy())
9D015C08  0F406582   JAL SMTPIsBusy
9D015C0C  00000000   NOP
9D015C10  14400008   BNE V0, ZERO, 0x9D015C34
9D015C14  00000000   NOP
1109:                			{
1110:                				curHTTP.smPost = SM_EMAIL_FINISHING;
9D015C18  3C02A000   LUI V0, -24576
9D015C1C  24420574   ADDIU V0, V0, 1396
9D015C20  2403000A   ADDIU V1, ZERO, 10
9D015C24  A0430088   SB V1, 136(V0)
1111:                				return HTTP_IO_WAITING;
9D015C28  24020002   ADDIU V0, ZERO, 2
9D015C2C  0B4057F5   J 0x9D015FD4
9D015C30  00000000   NOP
1112:                			}
1113:                			
1114:                			// See if we're ready to write data
1115:                			if(SMTPIsPutReady() < 30u)
9D015C34  0F40658C   JAL SMTPIsPutReady
9D015C38  00000000   NOP
9D015C3C  2C42001E   SLTIU V0, V0, 30
9D015C40  10400004   BEQ V0, ZERO, 0x9D015C54
9D015C44  00000000   NOP
1116:                				return HTTP_IO_WAITING;
9D015C48  24020002   ADDIU V0, ZERO, 2
9D015C4C  0B4057F5   J 0x9D015FD4
9D015C50  00000000   NOP
1117:                				
1118:                			// Write the header and button strings
1119:                			SMTPPutROMString((ROM BYTE*)"LEDs:,");
9D015C54  3C029D03   LUI V0, -25341
9D015C58  244234E8   ADDIU V0, V0, 13544
9D015C5C  00402021   ADDU A0, V0, ZERO
9D015C60  0F406638   JAL SMTPPutString
9D015C64  00000000   NOP
1120:                			SMTPPut(LED0_IO + '0');
9D015C68  3C02BF88   LUI V0, -16504
9D015C6C  8C4260E0   LW V0, 24800(V0)
9D015C70  7C420000   EXT V0, V0, 0, 1
9D015C74  304200FF   ANDI V0, V0, 255
9D015C78  24420030   ADDIU V0, V0, 48
9D015C7C  304200FF   ANDI V0, V0, 255
9D015C80  00402021   ADDU A0, V0, ZERO
9D015C84  0F4065A1   JAL SMTPPut
9D015C88  00000000   NOP
1121:                			SMTPPut(',');
9D015C8C  2404002C   ADDIU A0, ZERO, 44
9D015C90  0F4065A1   JAL SMTPPut
9D015C94  00000000   NOP
1122:                			SMTPPut(LED1_IO + '0');
9D015C98  3C02BF88   LUI V0, -16504
9D015C9C  8C4260E0   LW V0, 24800(V0)
9D015CA0  7C420040   EXT V0, V0, 1, 1
9D015CA4  304200FF   ANDI V0, V0, 255
9D015CA8  24420030   ADDIU V0, V0, 48
9D015CAC  304200FF   ANDI V0, V0, 255
9D015CB0  00402021   ADDU A0, V0, ZERO
9D015CB4  0F4065A1   JAL SMTPPut
9D015CB8  00000000   NOP
1123:                			SMTPPut(',');
9D015CBC  2404002C   ADDIU A0, ZERO, 44
9D015CC0  0F4065A1   JAL SMTPPut
9D015CC4  00000000   NOP
1124:                			SMTPPut(LED2_IO + '0');
9D015CC8  3C02BF88   LUI V0, -16504
9D015CCC  8C4260E0   LW V0, 24800(V0)
9D015CD0  7C420080   EXT V0, V0, 2, 1
9D015CD4  304200FF   ANDI V0, V0, 255
9D015CD8  24420030   ADDIU V0, V0, 48
9D015CDC  304200FF   ANDI V0, V0, 255
9D015CE0  00402021   ADDU A0, V0, ZERO
9D015CE4  0F4065A1   JAL SMTPPut
9D015CE8  00000000   NOP
1125:                			SMTPPut(',');
9D015CEC  2404002C   ADDIU A0, ZERO, 44
9D015CF0  0F4065A1   JAL SMTPPut
9D015CF4  00000000   NOP
1126:                			SMTPPut(LED3_IO + '0');
9D015CF8  3C02BF88   LUI V0, -16504
9D015CFC  8C4260E0   LW V0, 24800(V0)
9D015D00  7C420180   EXT V0, V0, 6, 1
9D015D04  304200FF   ANDI V0, V0, 255
9D015D08  24420030   ADDIU V0, V0, 48
9D015D0C  304200FF   ANDI V0, V0, 255
9D015D10  00402021   ADDU A0, V0, ZERO
9D015D14  0F4065A1   JAL SMTPPut
9D015D18  00000000   NOP
1127:                			SMTPPut(',');
9D015D1C  2404002C   ADDIU A0, ZERO, 44
9D015D20  0F4065A1   JAL SMTPPut
9D015D24  00000000   NOP
1128:                			SMTPPut(LED4_IO + '0');
9D015D28  3C02BF88   LUI V0, -16504
9D015D2C  8C4260E0   LW V0, 24800(V0)
9D015D30  7C420180   EXT V0, V0, 6, 1
9D015D34  304200FF   ANDI V0, V0, 255
9D015D38  24420030   ADDIU V0, V0, 48
9D015D3C  304200FF   ANDI V0, V0, 255
9D015D40  00402021   ADDU A0, V0, ZERO
9D015D44  0F4065A1   JAL SMTPPut
9D015D48  00000000   NOP
1129:                			SMTPPut(',');
9D015D4C  2404002C   ADDIU A0, ZERO, 44
9D015D50  0F4065A1   JAL SMTPPut
9D015D54  00000000   NOP
1130:                			SMTPPut(LED5_IO + '0');
9D015D58  3C02BF88   LUI V0, -16504
9D015D5C  8C4260E0   LW V0, 24800(V0)
9D015D60  7C420180   EXT V0, V0, 6, 1
9D015D64  304200FF   ANDI V0, V0, 255
9D015D68  24420030   ADDIU V0, V0, 48
9D015D6C  304200FF   ANDI V0, V0, 255
9D015D70  00402021   ADDU A0, V0, ZERO
9D015D74  0F4065A1   JAL SMTPPut
9D015D78  00000000   NOP
1131:                			SMTPPut(',');
9D015D7C  2404002C   ADDIU A0, ZERO, 44
9D015D80  0F4065A1   JAL SMTPPut
9D015D84  00000000   NOP
1132:                			SMTPPut(LED6_IO + '0');
9D015D88  3C02BF88   LUI V0, -16504
9D015D8C  8C4260E0   LW V0, 24800(V0)
9D015D90  7C420180   EXT V0, V0, 6, 1
9D015D94  304200FF   ANDI V0, V0, 255
9D015D98  24420030   ADDIU V0, V0, 48
9D015D9C  304200FF   ANDI V0, V0, 255
9D015DA0  00402021   ADDU A0, V0, ZERO
9D015DA4  0F4065A1   JAL SMTPPut
9D015DA8  00000000   NOP
1133:                			SMTPPut(',');
9D015DAC  2404002C   ADDIU A0, ZERO, 44
9D015DB0  0F4065A1   JAL SMTPPut
9D015DB4  00000000   NOP
1134:                			SMTPPut(LED7_IO + '0');
9D015DB8  3C02BF88   LUI V0, -16504
9D015DBC  8C4260E0   LW V0, 24800(V0)
9D015DC0  7C420180   EXT V0, V0, 6, 1
9D015DC4  304200FF   ANDI V0, V0, 255
9D015DC8  24420030   ADDIU V0, V0, 48
9D015DCC  304200FF   ANDI V0, V0, 255
9D015DD0  00402021   ADDU A0, V0, ZERO
9D015DD4  0F4065A1   JAL SMTPPut
9D015DD8  00000000   NOP
1135:                			SMTPPut('\r');
9D015DDC  2404000D   ADDIU A0, ZERO, 13
9D015DE0  0F4065A1   JAL SMTPPut
9D015DE4  00000000   NOP
1136:                			SMTPPut('\n');
9D015DE8  2404000A   ADDIU A0, ZERO, 10
9D015DEC  0F4065A1   JAL SMTPPut
9D015DF0  00000000   NOP
1137:                			SMTPFlush();
9D015DF4  0F40665F   JAL SMTPFlush
9D015DF8  00000000   NOP
1138:                
1139:                			// Move to the next state
1140:                			curHTTP.smPost = SM_EMAIL_PUT_ATTACHMENT_DATA_POT;
9D015DFC  3C02A000   LUI V0, -24576
9D015E00  24420574   ADDIU V0, V0, 1396
9D015E04  24030008   ADDIU V1, ZERO, 8
9D015E08  A0430088   SB V1, 136(V0)
1141:                
1142:                		case SM_EMAIL_PUT_ATTACHMENT_DATA_POT:
1143:                			// Check to see if a failure occurred
1144:                			if(!SMTPIsBusy())
9D015E0C  0F406582   JAL SMTPIsBusy
9D015E10  00000000   NOP
9D015E14  14400008   BNE V0, ZERO, 0x9D015E38
9D015E18  00000000   NOP
1145:                			{
1146:                				curHTTP.smPost = SM_EMAIL_FINISHING;
9D015E1C  3C02A000   LUI V0, -24576
9D015E20  24420574   ADDIU V0, V0, 1396
9D015E24  2403000A   ADDIU V1, ZERO, 10
9D015E28  A0430088   SB V1, 136(V0)
1147:                				return HTTP_IO_WAITING;
9D015E2C  24020002   ADDIU V0, ZERO, 2
9D015E30  0B4057F5   J 0x9D015FD4
9D015E34  00000000   NOP
1148:                			}
1149:                			
1150:                			// See if we're ready to write data
1151:                			if(SMTPIsPutReady() < 16u)
9D015E38  0F40658C   JAL SMTPIsPutReady
9D015E3C  00000000   NOP
9D015E40  2C420010   SLTIU V0, V0, 16
9D015E44  10400004   BEQ V0, ZERO, 0x9D015E58
9D015E48  00000000   NOP
1152:                				return HTTP_IO_WAITING;
9D015E4C  24020002   ADDIU V0, ZERO, 2
9D015E50  0B4057F5   J 0x9D015FD4
9D015E54  00000000   NOP
1153:                
1154:                			// Do the A/D conversion
1155:                			#if defined(__18CXX)
1156:                			    // Wait until A/D conversion is done
1157:                			    ADCON0bits.GO = 1;
1158:                			    while(ADCON0bits.GO);
1159:                			    // Convert 10-bit value into ASCII string
1160:                			    len = (WORD)ADRES;
1161:                			    uitoa(len, (BYTE*)&curHTTP.data[1]);
1162:                			#else
1163:                				len = (WORD)ADC1BUF0;
9D015E58  3C02BF81   LUI V0, -16511
9D015E5C  8C429070   LW V0, -28560(V0)
9D015E60  A7C20010   SH V0, 16(S8)
1164:                			    uitoa(len, (BYTE*)&curHTTP.data[1]);
9D015E64  97C20010   LHU V0, 16(S8)
9D015E68  00402021   ADDU A0, V0, ZERO
9D015E6C  3C02A000   LUI V0, -24576
9D015E70  24450599   ADDIU A1, V0, 1433
9D015E74  0F409900   JAL uitoa
9D015E78  00000000   NOP
1165:                			#endif
1166:                
1167:                			// Write the header and button strings
1168:                			SMTPPutROMString((ROM BYTE*)"Pot:,");
9D015E7C  3C029D03   LUI V0, -25341
9D015E80  244234F0   ADDIU V0, V0, 13552
9D015E84  00402021   ADDU A0, V0, ZERO
9D015E88  0F406638   JAL SMTPPutString
9D015E8C  00000000   NOP
1169:                			SMTPPutString(&curHTTP.data[1]);
9D015E90  3C02A000   LUI V0, -24576
9D015E94  24440599   ADDIU A0, V0, 1433
9D015E98  0F406638   JAL SMTPPutString
9D015E9C  00000000   NOP
1170:                			SMTPPut('\r');
9D015EA0  2404000D   ADDIU A0, ZERO, 13
9D015EA4  0F4065A1   JAL SMTPPut
9D015EA8  00000000   NOP
1171:                			SMTPPut('\n');
9D015EAC  2404000A   ADDIU A0, ZERO, 10
9D015EB0  0F4065A1   JAL SMTPPut
9D015EB4  00000000   NOP
1172:                			SMTPFlush();
9D015EB8  0F40665F   JAL SMTPFlush
9D015EBC  00000000   NOP
1173:                			
1174:                			// Move to the next state
1175:                			curHTTP.smPost = SM_EMAIL_PUT_TERMINATOR;
9D015EC0  3C02A000   LUI V0, -24576
9D015EC4  24420574   ADDIU V0, V0, 1396
9D015EC8  24030009   ADDIU V1, ZERO, 9
9D015ECC  A0430088   SB V1, 136(V0)
1176:                			
1177:                		case SM_EMAIL_PUT_TERMINATOR:
1178:                			// This section finishes the message
1179:                			// This consists of two dashes, the boundary, and two more dashes
1180:                			// on a single line, followed by a CRLF pair to terminate the message.
1181:                
1182:                			// Check to see if a failure occured
1183:                			if(!SMTPIsBusy())
9D015ED0  0F406582   JAL SMTPIsBusy
9D015ED4  00000000   NOP
9D015ED8  14400008   BNE V0, ZERO, 0x9D015EFC
9D015EDC  00000000   NOP
1184:                			{
1185:                				curHTTP.smPost = SM_EMAIL_FINISHING;
9D015EE0  3C02A000   LUI V0, -24576
9D015EE4  24420574   ADDIU V0, V0, 1396
9D015EE8  2403000A   ADDIU V1, ZERO, 10
9D015EEC  A0430088   SB V1, 136(V0)
1186:                				return HTTP_IO_WAITING;
9D015EF0  24020002   ADDIU V0, ZERO, 2
9D015EF4  0B4057F5   J 0x9D015FD4
9D015EF8  00000000   NOP
1187:                			}
1188:                		
1189:                			// See if we're ready to write data
1190:                			if(SMTPIsPutReady() < 16u)
9D015EFC  0F40658C   JAL SMTPIsPutReady
9D015F00  00000000   NOP
9D015F04  2C420010   SLTIU V0, V0, 16
9D015F08  10400004   BEQ V0, ZERO, 0x9D015F1C
9D015F0C  00000000   NOP
1191:                				return HTTP_IO_WAITING;
9D015F10  24020002   ADDIU V0, ZERO, 2
9D015F14  0B4057F5   J 0x9D015FD4
9D015F18  00000000   NOP
1192:                				
1193:                			// Write the ignored text				
1194:                			SMTPPutROMString((ROM BYTE*)"--frontier--\r\n");
9D015F1C  3C029D03   LUI V0, -25341
9D015F20  244234F8   ADDIU V0, V0, 13560
9D015F24  00402021   ADDU A0, V0, ZERO
9D015F28  0F406638   JAL SMTPPutString
9D015F2C  00000000   NOP
1195:                			SMTPPutDone();
9D015F30  0F40666D   JAL SMTPPutDone
9D015F34  00000000   NOP
1196:                			SMTPFlush();
9D015F38  0F40665F   JAL SMTPFlush
9D015F3C  00000000   NOP
1197:                			
1198:                			// Move to the next state
1199:                			curHTTP.smPost = SM_EMAIL_FINISHING;
9D015F40  3C02A000   LUI V0, -24576
9D015F44  24420574   ADDIU V0, V0, 1396
9D015F48  2403000A   ADDIU V1, ZERO, 10
9D015F4C  A0430088   SB V1, 136(V0)
1200:                		
1201:                		case SM_EMAIL_FINISHING:
1202:                			// Wait for status
1203:                			if(!SMTPIsBusy())
9D015F50  0F406582   JAL SMTPIsBusy
9D015F54  00000000   NOP
9D015F58  1440001A   BNE V0, ZERO, 0x9D015FC4
9D015F5C  00000000   NOP
1204:                			{
1205:                				// Release the module and check success
1206:                				// Redirect the user based on the result
1207:                				if(SMTPEndUsage() == SMTP_SUCCESS)
9D015F60  0F405D15   JAL SMTPEndUsage
9D015F64  00000000   NOP
9D015F68  14400005   BNE V0, ZERO, 0x9D015F80
9D015F6C  00000000   NOP
1208:                					lastSuccess = TRUE;
9D015F70  24020001   ADDIU V0, ZERO, 1
9D015F74  AF8281BC   SW V0, -32324(GP)
9D015F78  0B4057E2   J 0x9D015F88
9D015F7C  00000000   NOP
1209:                				else
1210:                					lastFailure = TRUE;
9D015F80  24020001   ADDIU V0, ZERO, 1
9D015F84  AF8281C0   SW V0, -32320(GP)
1211:                									
1212:                				// Redirect to the page
1213:                				strcpypgm2ram((char*)curHTTP.data, "/email/index.htm");
9D015F88  3C02A000   LUI V0, -24576
9D015F8C  24420598   ADDIU V0, V0, 1432
9D015F90  00402021   ADDU A0, V0, ZERO
9D015F94  3C029D03   LUI V0, -25341
9D015F98  24453508   ADDIU A1, V0, 13576
9D015F9C  24060011   ADDIU A2, ZERO, 17
9D015FA0  0F40D298   JAL 0x9D034A60
9D015FA4  00000000   NOP
1214:                				curHTTP.httpStatus = HTTP_REDIRECT;
9D015FA8  3C02A000   LUI V0, -24576
9D015FAC  24420574   ADDIU V0, V0, 1396
9D015FB0  24030008   ADDIU V1, ZERO, 8
9D015FB4  AC43001C   SW V1, 28(V0)
1215:                				return HTTP_IO_DONE;
9D015FB8  00001021   ADDU V0, ZERO, ZERO
9D015FBC  0B4057F5   J 0x9D015FD4
9D015FC0  00000000   NOP
1216:                			}
1217:                			
1218:                			return HTTP_IO_WAITING;
9D015FC4  24020002   ADDIU V0, ZERO, 2
9D015FC8  0B4057F5   J 0x9D015FD4
9D015FCC  00000000   NOP
1219:                	}
1220:                	
1221:                	return HTTP_IO_DONE;
9D015FD0  00001021   ADDU V0, ZERO, ZERO
1222:                }
9D015FD4  03C0E821   ADDU SP, S8, ZERO
9D015FD8  8FBF002C   LW RA, 44(SP)
9D015FDC  8FBE0028   LW S8, 40(SP)
9D015FE0  8FB00024   LW S0, 36(SP)
9D015FE4  27BD0030   ADDIU SP, SP, 48
9D015FE8  03E00008   JR RA
9D015FEC  00000000   NOP
1223:                #endif	// #if defined(STACK_USE_SMTP_CLIENT)
1224:                
1225:                /****************************************************************************
1226:                  Function:
1227:                    HTTP_IO_RESULT HTTPPostDDNSConfig(void)
1228:                    
1229:                  Summary:
1230:                    Parsing and collecting http data received from http form.
1231:                
1232:                  Description:
1233:                    This routine will be excuted every time the Dynamic DNS Client
1234:                    configuration form is submitted.  The http data is received 
1235:                    as a string of the variables seperated by '&' characters in the TCP RX
1236:                    buffer.  This data is parsed to read the required configuration values, 
1237:                    and those values are populated to the global array (DDNSData) reserved 
1238:                    for this purpose.  As the data is read, DDNSPointers is also populated
1239:                    so that the dynamic DNS client can execute with the new parameters.
1240:                    
1241:                  Precondition:
1242:                     curHTTP is loaded.
1243:                
1244:                  Parameters:
1245:                    None.
1246:                
1247:                  Return Values:
1248:                    HTTP_IO_DONE 		-  Finished with procedure
1249:                    HTTP_IO_NEED_DATA	-  More data needed to continue, call again later
1250:                    HTTP_IO_WAITING 	-  Waiting for asynchronous process to complete, 
1251:                    						call again later
1252:                  ***************************************************************************/
1253:                #if defined(STACK_USE_DYNAMICDNS_CLIENT)
1254:                static HTTP_IO_RESULT HTTPPostDDNSConfig(void)
1255:                {
1256:                	static BYTE *ptrDDNS;
1257:                
1258:                	#define SM_DDNS_START			(0u)
1259:                	#define SM_DDNS_READ_NAME		(1u)
1260:                	#define SM_DDNS_READ_VALUE		(2u)
1261:                	#define SM_DDNS_READ_SERVICE	(3u)
1262:                	#define SM_DDNS_DONE			(4u)
1263:                
1264:                	#define DDNS_SPACE_REMAINING				(sizeof(DDNSData) - (ptrDDNS - DDNSData))
1265:                
1266:                	switch(curHTTP.smPost)
1267:                	{
1268:                		// Sets defaults for the system
1269:                		case SM_DDNS_START:
1270:                			ptrDDNS = DDNSData;
1271:                			DDNSSetService(0);
1272:                			DDNSClient.Host.szROM = NULL;
1273:                			DDNSClient.Username.szROM = NULL;
1274:                			DDNSClient.Password.szROM = NULL;
1275:                			DDNSClient.ROMPointers.Host = 0;
1276:                			DDNSClient.ROMPointers.Username = 0;
1277:                			DDNSClient.ROMPointers.Password = 0;
1278:                			curHTTP.smPost++;
1279:                			
1280:                		// Searches out names and handles them as they arrive
1281:                		case SM_DDNS_READ_NAME:
1282:                			// If all parameters have been read, end
1283:                			if(curHTTP.byteCount == 0u)
1284:                			{
1285:                				curHTTP.smPost = SM_DDNS_DONE;
1286:                				break;
1287:                			}
1288:                		
1289:                			// Read a name
1290:                			if(HTTPReadPostName(curHTTP.data, HTTP_MAX_DATA_LEN) == HTTP_READ_INCOMPLETE)
1291:                				return HTTP_IO_NEED_DATA;
1292:                			
1293:                			if(!strcmppgm2ram((char *)curHTTP.data, (ROM char*)"service"))
1294:                			{
1295:                				// Reading the service (numeric)
1296:                				curHTTP.smPost = SM_DDNS_READ_SERVICE;
1297:                				break;
1298:                			}
1299:                			else if(!strcmppgm2ram((char *)curHTTP.data, (ROM char*)"user"))
1300:                				DDNSClient.Username.szRAM = ptrDDNS;
1301:                			else if(!strcmppgm2ram((char *)curHTTP.data, (ROM char*)"pass"))
1302:                				DDNSClient.Password.szRAM = ptrDDNS;
1303:                			else if(!strcmppgm2ram((char *)curHTTP.data, (ROM char*)"host"))
1304:                				DDNSClient.Host.szRAM = ptrDDNS;
1305:                			
1306:                			// Move to reading the value for user/pass/host
1307:                			curHTTP.smPost++;
1308:                			
1309:                		// Reads in values and assigns them to the DDNS RAM
1310:                		case SM_DDNS_READ_VALUE:
1311:                			// Read a name
1312:                			if(HTTPReadPostValue(ptrDDNS, DDNS_SPACE_REMAINING) == HTTP_READ_INCOMPLETE)
1313:                				return HTTP_IO_NEED_DATA;
1314:                				
1315:                			// Move past the data that was just read
1316:                			ptrDDNS += strlen((char*)ptrDDNS);
1317:                			if(ptrDDNS < DDNSData + sizeof(DDNSData) - 1)
1318:                				ptrDDNS += 1;			
1319:                			
1320:                			// Return to reading names
1321:                			curHTTP.smPost = SM_DDNS_READ_NAME;
1322:                			break;
1323:                		
1324:                		// Reads in a service ID
1325:                		case SM_DDNS_READ_SERVICE:
1326:                			// Read the integer id
1327:                			if(HTTPReadPostValue(curHTTP.data, HTTP_MAX_DATA_LEN) == HTTP_READ_INCOMPLETE)
1328:                				return HTTP_IO_NEED_DATA;
1329:                			
1330:                			// Convert to a service ID
1331:                			DDNSSetService((BYTE)atol((char*)curHTTP.data));
1332:                
1333:                			// Return to reading names
1334:                			curHTTP.smPost = SM_DDNS_READ_NAME;
1335:                			break;
1336:                			
1337:                		// Sets up the DDNS client for an update
1338:                		case SM_DDNS_DONE:
1339:                			// Since user name and password changed, force an update immediately
1340:                			DDNSForceUpdate();
1341:                			
1342:                			// Redirect to prevent POST errors
1343:                			lastSuccess = TRUE;
1344:                			strcpypgm2ram((char*)curHTTP.data, "/dyndns/index.htm");
1345:                			curHTTP.httpStatus = HTTP_REDIRECT;
1346:                			return HTTP_IO_DONE;				
1347:                	}
1348:                	
1349:                	return HTTP_IO_WAITING;		// Assume we're waiting to process more data
1350:                }
1351:                #endif	// #if defined(STACK_USE_DYNAMICDNS_CLIENT)
1352:                
1353:                #endif //(use_post)
1354:                
1355:                
1356:                /****************************************************************************
1357:                  Section:
1358:                	Dynamic Variable Callback Functions
1359:                  ***************************************************************************/
1360:                
1361:                /*****************************************************************************
1362:                  Function:
1363:                	void HTTPPrint_varname(void)
1364:                	
1365:                  Internal:
1366:                  	See documentation in the TCP/IP Stack API or HTTP2.h for details.
1367:                  ***************************************************************************/
1368:                
1369:                void HTTPPrint_builddate(void)
1370:                {
9D015FF0  27BDFFE8   ADDIU SP, SP, -24
9D015FF4  AFBF0014   SW RA, 20(SP)
9D015FF8  AFBE0010   SW S8, 16(SP)
9D015FFC  03A0F021   ADDU S8, SP, ZERO
1371:                    curHTTP.callbackPos = 0x01;
9D016000  3C02A000   LUI V0, -24576
9D016004  24420574   ADDIU V0, V0, 1396
9D016008  24030001   ADDIU V1, ZERO, 1
9D01600C  AC43000C   SW V1, 12(V0)
1372:                    if(TCPIsPutReady(sktHTTP) < strlenpgm((ROM char*)__DATE__" ""00:08:00"))
9D016010  938281E8   LBU V0, -32280(GP)
9D016014  00401821   ADDU V1, V0, ZERO
9D016018  3C02A000   LUI V0, -24576
9D01601C  000318C0   SLL V1, V1, 3
9D016020  24420600   ADDIU V0, V0, 1536
9D016024  00621021   ADDU V0, V1, V0
9D016028  90420004   LBU V0, 4(V0)
9D01602C  00402021   ADDU A0, V0, ZERO
9D016030  0F40038E   JAL TCPIsPutReady
9D016034  00000000   NOP
9D016038  2C420014   SLTIU V0, V0, 20
9D01603C  14400014   BNE V0, ZERO, 0x9D016090
9D016040  00000000   NOP
1373:                        return;
9D016090  00000000   NOP
1374:                 
1375:                    curHTTP.callbackPos = 0x00;
9D016044  3C02A000   LUI V0, -24576
9D016048  24420574   ADDIU V0, V0, 1396
9D01604C  AC40000C   SW ZERO, 12(V0)
1376:                    TCPPutROMString(sktHTTP, (ROM void*)__DATE__" ""00:08:00");
9D016050  938281E8   LBU V0, -32280(GP)
9D016054  00401821   ADDU V1, V0, ZERO
9D016058  3C02A000   LUI V0, -24576
9D01605C  000318C0   SLL V1, V1, 3
9D016060  24420600   ADDIU V0, V0, 1536
9D016064  00621021   ADDU V0, V1, V0
9D016068  90420004   LBU V0, 4(V0)
9D01606C  00401821   ADDU V1, V0, ZERO
9D016070  3C029D03   LUI V0, -25341
9D016074  2442351C   ADDIU V0, V0, 13596
9D016078  00602021   ADDU A0, V1, ZERO
9D01607C  00402821   ADDU A1, V0, ZERO
9D016080  0F4005FD   JAL TCPPutString
9D016084  00000000   NOP
9D016088  0B405825   J 0x9D016094
9D01608C  00000000   NOP
1377:                }
9D016094  03C0E821   ADDU SP, S8, ZERO
9D016098  8FBF0014   LW RA, 20(SP)
9D01609C  8FBE0010   LW S8, 16(SP)
9D0160A0  27BD0018   ADDIU SP, SP, 24
9D0160A4  03E00008   JR RA
9D0160A8  00000000   NOP
1378:                
1379:                void HTTPPrint_version(void)
1380:                {
9D0160AC  27BDFFE8   ADDIU SP, SP, -24
9D0160B0  AFBF0014   SW RA, 20(SP)
9D0160B4  AFBE0010   SW S8, 16(SP)
9D0160B8  03A0F021   ADDU S8, SP, ZERO
1381:                	TCPPutROMString(sktHTTP, (ROM void*)TCPIP_STACK_VERSION);
9D0160BC  938281E8   LBU V0, -32280(GP)
9D0160C0  00401821   ADDU V1, V0, ZERO
9D0160C4  3C02A000   LUI V0, -24576
9D0160C8  000318C0   SLL V1, V1, 3
9D0160CC  24420600   ADDIU V0, V0, 1536
9D0160D0  00621021   ADDU V0, V1, V0
9D0160D4  90420004   LBU V0, 4(V0)
9D0160D8  00401821   ADDU V1, V0, ZERO
9D0160DC  3C029D03   LUI V0, -25341
9D0160E0  24423534   ADDIU V0, V0, 13620
9D0160E4  00602021   ADDU A0, V1, ZERO
9D0160E8  00402821   ADDU A1, V0, ZERO
9D0160EC  0F4005FD   JAL TCPPutString
9D0160F0  00000000   NOP
1382:                }
9D0160F4  03C0E821   ADDU SP, S8, ZERO
9D0160F8  8FBF0014   LW RA, 20(SP)
9D0160FC  8FBE0010   LW S8, 16(SP)
9D016100  27BD0018   ADDIU SP, SP, 24
9D016104  03E00008   JR RA
9D016108  00000000   NOP
1383:                
1384:                
1385:                
1386:                
1387:                ROM BYTE HTML_UP_ARROW[] = "up";
1388:                ROM BYTE HTML_DOWN_ARROW[] = "dn";
1389:                
1390:                void HTTPPrint_btn(WORD num)
1391:                {
9D01610C  27BDFFE8   ADDIU SP, SP, -24
9D016110  AFBF0014   SW RA, 20(SP)
9D016114  AFBE0010   SW S8, 16(SP)
9D016118  03A0F021   ADDU S8, SP, ZERO
9D01611C  00801021   ADDU V0, A0, ZERO
9D016120  A7C20018   SH V0, 24(S8)
1392:                	// Determine which button
1393:                	switch(num)
9D016124  97C20018   LHU V0, 24(S8)
9D016128  24030001   ADDIU V1, ZERO, 1
9D01612C  10430017   BEQ V0, V1, 0x9D01618C
9D016130  00000000   NOP
9D016134  28430002   SLTI V1, V0, 2
9D016138  10600005   BEQ V1, ZERO, 0x9D016150
9D01613C  00000000   NOP
9D016140  1040000B   BEQ V0, ZERO, 0x9D016170
9D016144  00000000   NOP
9D016148  0B405875   J 0x9D0161D4
9D01614C  00000000   NOP
9D016150  24030002   ADDIU V1, ZERO, 2
9D016154  10430014   BEQ V0, V1, 0x9D0161A8
9D016158  00000000   NOP
9D01615C  24030003   ADDIU V1, ZERO, 3
9D016160  10430018   BEQ V0, V1, 0x9D0161C4
9D016164  00000000   NOP
9D016168  0B405875   J 0x9D0161D4
9D01616C  00000000   NOP
1394:                	{
1395:                		case 0:
1396:                			num = BUTTON0_IO;
9D016170  3C02BF88   LUI V0, -16504
9D016174  8C4260D0   LW V0, 24784(V0)
9D016178  7C420180   EXT V0, V0, 6, 1
9D01617C  304200FF   ANDI V0, V0, 255
9D016180  A7C20018   SH V0, 24(S8)
1397:                			break;
9D016184  0B405876   J 0x9D0161D8
9D016188  00000000   NOP
1398:                		case 1:
1399:                			num = BUTTON1_IO;
9D01618C  3C02BF88   LUI V0, -16504
9D016190  8C4260D0   LW V0, 24784(V0)
9D016194  7C4201C0   EXT V0, V0, 7, 1
9D016198  304200FF   ANDI V0, V0, 255
9D01619C  A7C20018   SH V0, 24(S8)
1400:                			break;
9D0161A0  0B405876   J 0x9D0161D8
9D0161A4  00000000   NOP
1401:                		case 2:
1402:                			num = BUTTON2_IO;
9D0161A8  3C02BF88   LUI V0, -16504
9D0161AC  8C4260D0   LW V0, 24784(V0)
9D0161B0  7C420340   EXT V0, V0, 13, 1
9D0161B4  304200FF   ANDI V0, V0, 255
9D0161B8  A7C20018   SH V0, 24(S8)
1403:                			break;
9D0161BC  0B405876   J 0x9D0161D8
9D0161C0  00000000   NOP
1404:                		case 3:
1405:                			num = BUTTON3_IO;
9D0161C4  24020001   ADDIU V0, ZERO, 1
9D0161C8  A7C20018   SH V0, 24(S8)
1406:                			break;
9D0161CC  0B405876   J 0x9D0161D8
9D0161D0  00000000   NOP
1407:                		default:
1408:                			num = 0;
9D0161D4  A7C00018   SH ZERO, 24(S8)
1409:                	}
1410:                
1411:                	// Print the output
1412:                	TCPPutROMString(sktHTTP, (num?HTML_UP_ARROW:HTML_DOWN_ARROW));
9D0161D8  938281E8   LBU V0, -32280(GP)
9D0161DC  00401821   ADDU V1, V0, ZERO
9D0161E0  3C02A000   LUI V0, -24576
9D0161E4  000318C0   SLL V1, V1, 3
9D0161E8  24420600   ADDIU V0, V0, 1536
9D0161EC  00621021   ADDU V0, V1, V0
9D0161F0  90420004   LBU V0, 4(V0)
9D0161F4  00401821   ADDU V1, V0, ZERO
9D0161F8  97C20018   LHU V0, 24(S8)
9D0161FC  10400005   BEQ V0, ZERO, 0x9D016214
9D016200  00000000   NOP
9D016204  3C029D03   LUI V0, -25341
9D016208  2442353C   ADDIU V0, V0, 13628
9D01620C  0B405887   J 0x9D01621C
9D016210  00000000   NOP
9D016214  3C029D03   LUI V0, -25341
9D016218  24423540   ADDIU V0, V0, 13632
9D01621C  00602021   ADDU A0, V1, ZERO
9D016220  00402821   ADDU A1, V0, ZERO
9D016224  0F4005FD   JAL TCPPutString
9D016228  00000000   NOP
1413:                	return;
1414:                }
9D01622C  03C0E821   ADDU SP, S8, ZERO
9D016230  8FBF0014   LW RA, 20(SP)
9D016234  8FBE0010   LW S8, 16(SP)
9D016238  27BD0018   ADDIU SP, SP, 24
9D01623C  03E00008   JR RA
9D016240  00000000   NOP
1415:                	
1416:                void HTTPPrint_led(WORD num)
1417:                {
9D016244  27BDFFE8   ADDIU SP, SP, -24
9D016248  AFBF0014   SW RA, 20(SP)
9D01624C  AFBE0010   SW S8, 16(SP)
9D016250  03A0F021   ADDU S8, SP, ZERO
9D016254  00801021   ADDU V0, A0, ZERO
9D016258  A7C20018   SH V0, 24(S8)
1418:                	// Determine which LED
1419:                	switch(num)
9D01625C  97C20018   LHU V0, 24(S8)
9D016260  2C430008   SLTIU V1, V0, 8
9D016264  10600048   BEQ V1, ZERO, 0x9D016388
9D016268  00000000   NOP
9D01626C  00021880   SLL V1, V0, 2
9D016270  3C029D01   LUI V0, -25343
9D016274  24426288   ADDIU V0, V0, 25224
9D016278  00621021   ADDU V0, V1, V0
9D01627C  8C420000   LW V0, 0(V0)
9D016280  00400008   JR V0
9D016284  00000000   NOP
1420:                	{
1421:                		case 0:
1422:                			num = LED0_IO;
9D0162A8  3C02BF88   LUI V0, -16504
9D0162AC  8C4260E0   LW V0, 24800(V0)
9D0162B0  7C420000   EXT V0, V0, 0, 1
9D0162B4  304200FF   ANDI V0, V0, 255
9D0162B8  A7C20018   SH V0, 24(S8)
1423:                			break;
9D0162BC  0B4058E3   J 0x9D01638C
9D0162C0  00000000   NOP
1424:                		case 1:
1425:                			num = LED1_IO;
9D0162C4  3C02BF88   LUI V0, -16504
9D0162C8  8C4260E0   LW V0, 24800(V0)
9D0162CC  7C420040   EXT V0, V0, 1, 1
9D0162D0  304200FF   ANDI V0, V0, 255
9D0162D4  A7C20018   SH V0, 24(S8)
1426:                			break;
9D0162D8  0B4058E3   J 0x9D01638C
9D0162DC  00000000   NOP
1427:                		case 2:
1428:                			num = LED2_IO;
9D0162E0  3C02BF88   LUI V0, -16504
9D0162E4  8C4260E0   LW V0, 24800(V0)
9D0162E8  7C420080   EXT V0, V0, 2, 1
9D0162EC  304200FF   ANDI V0, V0, 255
9D0162F0  A7C20018   SH V0, 24(S8)
1429:                			break;
9D0162F4  0B4058E3   J 0x9D01638C
9D0162F8  00000000   NOP
1430:                		case 3:
1431:                			num = LED3_IO;
9D0162FC  3C02BF88   LUI V0, -16504
9D016300  8C4260E0   LW V0, 24800(V0)
9D016304  7C420180   EXT V0, V0, 6, 1
9D016308  304200FF   ANDI V0, V0, 255
9D01630C  A7C20018   SH V0, 24(S8)
1432:                			break;
9D016310  0B4058E3   J 0x9D01638C
9D016314  00000000   NOP
1433:                		case 4:
1434:                			num = LED4_IO;
9D016318  3C02BF88   LUI V0, -16504
9D01631C  8C4260E0   LW V0, 24800(V0)
9D016320  7C420180   EXT V0, V0, 6, 1
9D016324  304200FF   ANDI V0, V0, 255
9D016328  A7C20018   SH V0, 24(S8)
1435:                			break;
9D01632C  0B4058E3   J 0x9D01638C
9D016330  00000000   NOP
1436:                		case 5:
1437:                			num = LED5_IO;
9D016334  3C02BF88   LUI V0, -16504
9D016338  8C4260E0   LW V0, 24800(V0)
9D01633C  7C420180   EXT V0, V0, 6, 1
9D016340  304200FF   ANDI V0, V0, 255
9D016344  A7C20018   SH V0, 24(S8)
1438:                			break;
9D016348  0B4058E3   J 0x9D01638C
9D01634C  00000000   NOP
1439:                		case 6:
1440:                			num = LED6_IO;
9D016350  3C02BF88   LUI V0, -16504
9D016354  8C4260E0   LW V0, 24800(V0)
9D016358  7C420180   EXT V0, V0, 6, 1
9D01635C  304200FF   ANDI V0, V0, 255
9D016360  A7C20018   SH V0, 24(S8)
1441:                			break;
9D016364  0B4058E3   J 0x9D01638C
9D016368  00000000   NOP
1442:                		case 7:
1443:                			num = LED7_IO;
9D01636C  3C02BF88   LUI V0, -16504
9D016370  8C4260E0   LW V0, 24800(V0)
9D016374  7C420180   EXT V0, V0, 6, 1
9D016378  304200FF   ANDI V0, V0, 255
9D01637C  A7C20018   SH V0, 24(S8)
1444:                			break;
9D016380  0B4058E3   J 0x9D01638C
9D016384  00000000   NOP
1445:                
1446:                		default:
1447:                			num = 0;
9D016388  A7C00018   SH ZERO, 24(S8)
1448:                	}
1449:                
1450:                	// Print the output
1451:                	TCPPut(sktHTTP, (num?'1':'0'));
9D01638C  938281E8   LBU V0, -32280(GP)
9D016390  00401821   ADDU V1, V0, ZERO
9D016394  3C02A000   LUI V0, -24576
9D016398  000318C0   SLL V1, V1, 3
9D01639C  24420600   ADDIU V0, V0, 1536
9D0163A0  00621021   ADDU V0, V1, V0
9D0163A4  90420004   LBU V0, 4(V0)
9D0163A8  00401821   ADDU V1, V0, ZERO
9D0163AC  97C20018   LHU V0, 24(S8)
9D0163B0  10400004   BEQ V0, ZERO, 0x9D0163C4
9D0163B4  00000000   NOP
9D0163B8  24020031   ADDIU V0, ZERO, 49
9D0163BC  0B4058F2   J 0x9D0163C8
9D0163C0  00000000   NOP
9D0163C4  24020030   ADDIU V0, ZERO, 48
9D0163C8  00602021   ADDU A0, V1, ZERO
9D0163CC  00402821   ADDU A1, V0, ZERO
9D0163D0  0F40040C   JAL TCPPut
9D0163D4  00000000   NOP
1452:                	return;
1453:                }
9D0163D8  03C0E821   ADDU SP, S8, ZERO
9D0163DC  8FBF0014   LW RA, 20(SP)
9D0163E0  8FBE0010   LW S8, 16(SP)
9D0163E4  27BD0018   ADDIU SP, SP, 24
9D0163E8  03E00008   JR RA
9D0163EC  00000000   NOP
1454:                
1455:                void HTTPPrint_ledSelected(WORD num, WORD state)
1456:                {
9D0163F0  27BDFFE8   ADDIU SP, SP, -24
9D0163F4  AFBF0014   SW RA, 20(SP)
9D0163F8  AFBE0010   SW S8, 16(SP)
9D0163FC  03A0F021   ADDU S8, SP, ZERO
9D016400  00801821   ADDU V1, A0, ZERO
9D016404  00A01021   ADDU V0, A1, ZERO
9D016408  A7C30018   SH V1, 24(S8)
9D01640C  A7C2001C   SH V0, 28(S8)
1457:                	// Determine which LED to check
1458:                	switch(num)
9D016410  97C20018   LHU V0, 24(S8)
9D016414  2C430008   SLTIU V1, V0, 8
9D016418  10600048   BEQ V1, ZERO, 0x9D01653C
9D01641C  00000000   NOP
9D016420  00021880   SLL V1, V0, 2
9D016424  3C029D01   LUI V0, -25343
9D016428  2442643C   ADDIU V0, V0, 25660
9D01642C  00621021   ADDU V0, V1, V0
9D016430  8C420000   LW V0, 0(V0)
9D016434  00400008   JR V0
9D016438  00000000   NOP
1459:                	{
1460:                		case 0:
1461:                			num = LED0_IO;
9D01645C  3C02BF88   LUI V0, -16504
9D016460  8C4260E0   LW V0, 24800(V0)
9D016464  7C420000   EXT V0, V0, 0, 1
9D016468  304200FF   ANDI V0, V0, 255
9D01646C  A7C20018   SH V0, 24(S8)
1462:                			break;
9D016470  0B405950   J 0x9D016540
9D016474  00000000   NOP
1463:                		case 1:
1464:                			num = LED1_IO;
9D016478  3C02BF88   LUI V0, -16504
9D01647C  8C4260E0   LW V0, 24800(V0)
9D016480  7C420040   EXT V0, V0, 1, 1
9D016484  304200FF   ANDI V0, V0, 255
9D016488  A7C20018   SH V0, 24(S8)
1465:                			break;
9D01648C  0B405950   J 0x9D016540
9D016490  00000000   NOP
1466:                		case 2:
1467:                			num = LED2_IO;
9D016494  3C02BF88   LUI V0, -16504
9D016498  8C4260E0   LW V0, 24800(V0)
9D01649C  7C420080   EXT V0, V0, 2, 1
9D0164A0  304200FF   ANDI V0, V0, 255
9D0164A4  A7C20018   SH V0, 24(S8)
1468:                			break;
9D0164A8  0B405950   J 0x9D016540
9D0164AC  00000000   NOP
1469:                		case 3:
1470:                			num = LED3_IO;
9D0164B0  3C02BF88   LUI V0, -16504
9D0164B4  8C4260E0   LW V0, 24800(V0)
9D0164B8  7C420180   EXT V0, V0, 6, 1
9D0164BC  304200FF   ANDI V0, V0, 255
9D0164C0  A7C20018   SH V0, 24(S8)
1471:                			break;
9D0164C4  0B405950   J 0x9D016540
9D0164C8  00000000   NOP
1472:                		case 4:
1473:                			num = LED4_IO;
9D0164CC  3C02BF88   LUI V0, -16504
9D0164D0  8C4260E0   LW V0, 24800(V0)
9D0164D4  7C420180   EXT V0, V0, 6, 1
9D0164D8  304200FF   ANDI V0, V0, 255
9D0164DC  A7C20018   SH V0, 24(S8)
1474:                			break;
9D0164E0  0B405950   J 0x9D016540
9D0164E4  00000000   NOP
1475:                		case 5:
1476:                			num = LED5_IO;
9D0164E8  3C02BF88   LUI V0, -16504
9D0164EC  8C4260E0   LW V0, 24800(V0)
9D0164F0  7C420180   EXT V0, V0, 6, 1
9D0164F4  304200FF   ANDI V0, V0, 255
9D0164F8  A7C20018   SH V0, 24(S8)
1477:                			break;
9D0164FC  0B405950   J 0x9D016540
9D016500  00000000   NOP
1478:                		case 6:
1479:                			num = LED6_IO;
9D016504  3C02BF88   LUI V0, -16504
9D016508  8C4260E0   LW V0, 24800(V0)
9D01650C  7C420180   EXT V0, V0, 6, 1
9D016510  304200FF   ANDI V0, V0, 255
9D016514  A7C20018   SH V0, 24(S8)
1480:                			break;
9D016518  0B405950   J 0x9D016540
9D01651C  00000000   NOP
1481:                		case 7:
1482:                			num = LED7_IO;
9D016520  3C02BF88   LUI V0, -16504
9D016524  8C4260E0   LW V0, 24800(V0)
9D016528  7C420180   EXT V0, V0, 6, 1
9D01652C  304200FF   ANDI V0, V0, 255
9D016530  A7C20018   SH V0, 24(S8)
1483:                			break;
9D016534  0B405950   J 0x9D016540
9D016538  00000000   NOP
1484:                
1485:                		default:
1486:                			num = 0;
9D01653C  A7C00018   SH ZERO, 24(S8)
1487:                	}
1488:                	
1489:                	// Print output if TRUE and ON or if FALSE and OFF
1490:                	if((state && num) || (!state && !num))
9D016540  97C2001C   LHU V0, 28(S8)
9D016544  10400004   BEQ V0, ZERO, 0x9D016558
9D016548  00000000   NOP
9D01654C  97C20018   LHU V0, 24(S8)
9D016550  14400007   BNE V0, ZERO, 0x9D016570
9D016554  00000000   NOP
9D016558  97C2001C   LHU V0, 28(S8)
9D01655C  14400012   BNE V0, ZERO, 0x9D0165A8
9D016560  00000000   NOP
9D016564  97C20018   LHU V0, 24(S8)
9D016568  1440000F   BNE V0, ZERO, 0x9D0165A8
9D01656C  00000000   NOP
1491:                		TCPPutROMString(sktHTTP, (ROM BYTE*)"SELECTED");
9D016570  938281E8   LBU V0, -32280(GP)
9D016574  00401821   ADDU V1, V0, ZERO
9D016578  3C02A000   LUI V0, -24576
9D01657C  000318C0   SLL V1, V1, 3
9D016580  24420600   ADDIU V0, V0, 1536
9D016584  00621021   ADDU V0, V1, V0
9D016588  90420004   LBU V0, 4(V0)
9D01658C  00401821   ADDU V1, V0, ZERO
9D016590  3C029D03   LUI V0, -25341
9D016594  24423544   ADDIU V0, V0, 13636
9D016598  00602021   ADDU A0, V1, ZERO
9D01659C  00402821   ADDU A1, V0, ZERO
9D0165A0  0F4005FD   JAL TCPPutString
9D0165A4  00000000   NOP
1492:                	return;
1493:                }
9D0165A8  03C0E821   ADDU SP, S8, ZERO
9D0165AC  8FBF0014   LW RA, 20(SP)
9D0165B0  8FBE0010   LW S8, 16(SP)
9D0165B4  27BD0018   ADDIU SP, SP, 24
9D0165B8  03E00008   JR RA
9D0165BC  00000000   NOP
1494:                
1495:                void HTTPPrint_pot(void)
1496:                {
9D0165C0  27BDFFD8   ADDIU SP, SP, -40
9D0165C4  AFBF0024   SW RA, 36(SP)
9D0165C8  AFBE0020   SW S8, 32(SP)
9D0165CC  03A0F021   ADDU S8, SP, ZERO
1497:                	BYTE AN0String[8];
1498:                	WORD ADval;
1499:                
1500:                #if defined(__18CXX)
1501:                    // Wait until A/D conversion is done
1502:                    ADCON0bits.GO = 1;
1503:                    while(ADCON0bits.GO);
1504:                
1505:                    // Convert 10-bit value into ASCII string
1506:                    ADval = (WORD)ADRES;
1507:                    //ADval *= (WORD)10;
1508:                    //ADval /= (WORD)102;
1509:                    uitoa(ADval, AN0String);
1510:                #else
1511:                	ADval = (WORD)ADC1BUF0;
9D0165D0  3C02BF81   LUI V0, -16511
9D0165D4  8C429070   LW V0, -28560(V0)
9D0165D8  A7C20010   SH V0, 16(S8)
1512:                	//ADval *= (WORD)10;
1513:                	//ADval /= (WORD)102;
1514:                    uitoa(ADval, (BYTE*)AN0String);
9D0165DC  97C30010   LHU V1, 16(S8)
9D0165E0  27C20014   ADDIU V0, S8, 20
9D0165E4  00602021   ADDU A0, V1, ZERO
9D0165E8  00402821   ADDU A1, V0, ZERO
9D0165EC  0F409900   JAL uitoa
9D0165F0  00000000   NOP
1515:                #endif
1516:                
1517:                   	TCPPutString(sktHTTP, AN0String);
9D0165F4  938281E8   LBU V0, -32280(GP)
9D0165F8  00401821   ADDU V1, V0, ZERO
9D0165FC  3C02A000   LUI V0, -24576
9D016600  000318C0   SLL V1, V1, 3
9D016604  24420600   ADDIU V0, V0, 1536
9D016608  00621021   ADDU V0, V1, V0
9D01660C  90420004   LBU V0, 4(V0)
9D016610  00401821   ADDU V1, V0, ZERO
9D016614  27C20014   ADDIU V0, S8, 20
9D016618  00602021   ADDU A0, V1, ZERO
9D01661C  00402821   ADDU A1, V0, ZERO
9D016620  0F4005FD   JAL TCPPutString
9D016624  00000000   NOP
1518:                }
9D016628  03C0E821   ADDU SP, S8, ZERO
9D01662C  8FBF0024   LW RA, 36(SP)
9D016630  8FBE0020   LW S8, 32(SP)
9D016634  27BD0028   ADDIU SP, SP, 40
9D016638  03E00008   JR RA
9D01663C  00000000   NOP
1519:                
1520:                void HTTPPrint_lcdtext(void)
1521:                {
9D016640  27BDFFE0   ADDIU SP, SP, -32
9D016644  AFBF001C   SW RA, 28(SP)
9D016648  AFBE0018   SW S8, 24(SP)
9D01664C  03A0F021   ADDU S8, SP, ZERO
1522:                	WORD len;
1523:                
1524:                	// Determine how many bytes we can write
1525:                	len = TCPIsPutReady(sktHTTP);
9D016650  938281E8   LBU V0, -32280(GP)
9D016654  00401821   ADDU V1, V0, ZERO
9D016658  3C02A000   LUI V0, -24576
9D01665C  000318C0   SLL V1, V1, 3
9D016660  24420600   ADDIU V0, V0, 1536
9D016664  00621021   ADDU V0, V1, V0
9D016668  90420004   LBU V0, 4(V0)
9D01666C  00402021   ADDU A0, V0, ZERO
9D016670  0F40038E   JAL TCPIsPutReady
9D016674  00000000   NOP
9D016678  A7C20010   SH V0, 16(S8)
1526:                	
1527:                	#if defined(USE_LCD)
1528:                	// If just starting, set callbackPos
1529:                	if(curHTTP.callbackPos == 0u)
1530:                		curHTTP.callbackPos = 32;
1531:                	
1532:                	// Write a byte at a time while we still can
1533:                	// It may take up to 12 bytes to write a character
1534:                	// (spaces and newlines are longer)
1535:                	while(len > 12u && curHTTP.callbackPos)
1536:                	{
1537:                		// After 16 bytes write a newline
1538:                		if(curHTTP.callbackPos == 16u)
1539:                			len -= TCPPutROMArray(sktHTTP, (ROM BYTE*)"<br />", 6);
1540:                
1541:                		if(LCDText[32-curHTTP.callbackPos] == ' ' || LCDText[32-curHTTP.callbackPos] == '\0')
1542:                			len -= TCPPutROMArray(sktHTTP, (ROM BYTE*)"&nbsp;", 6);
1543:                		else
1544:                			len -= TCPPut(sktHTTP, LCDText[32-curHTTP.callbackPos]);
1545:                
1546:                		curHTTP.callbackPos--;
1547:                	}
1548:                	#else
1549:                	TCPPutROMString(sktHTTP, (ROM BYTE*)"No LCD Present");
9D01667C  938281E8   LBU V0, -32280(GP)
9D016680  00401821   ADDU V1, V0, ZERO
9D016684  3C02A000   LUI V0, -24576
9D016688  000318C0   SLL V1, V1, 3
9D01668C  24420600   ADDIU V0, V0, 1536
9D016690  00621021   ADDU V0, V1, V0
9D016694  90420004   LBU V0, 4(V0)
9D016698  00401821   ADDU V1, V0, ZERO
9D01669C  3C029D03   LUI V0, -25341
9D0166A0  24423550   ADDIU V0, V0, 13648
9D0166A4  00602021   ADDU A0, V1, ZERO
9D0166A8  00402821   ADDU A1, V0, ZERO
9D0166AC  0F4005FD   JAL TCPPutString
9D0166B0  00000000   NOP
1550:                	#endif
1551:                
1552:                	return;
1553:                }
9D0166B4  03C0E821   ADDU SP, S8, ZERO
9D0166B8  8FBF001C   LW RA, 28(SP)
9D0166BC  8FBE0018   LW S8, 24(SP)
9D0166C0  27BD0020   ADDIU SP, SP, 32
9D0166C4  03E00008   JR RA
9D0166C8  00000000   NOP
1554:                
1555:                void HTTPPrint_hellomsg(void)
1556:                {
9D0166CC  27BDFFE0   ADDIU SP, SP, -32
9D0166D0  AFBF001C   SW RA, 28(SP)
9D0166D4  AFBE0018   SW S8, 24(SP)
9D0166D8  03A0F021   ADDU S8, SP, ZERO
1557:                	BYTE *ptr;
1558:                	
1559:                	ptr = HTTPGetROMArg(curHTTP.data, (ROM BYTE*)"name");
9D0166DC  3C029D03   LUI V0, -25341
9D0166E0  24423560   ADDIU V0, V0, 13664
9D0166E4  3C03A000   LUI V1, -24576
9D0166E8  24640598   ADDIU A0, V1, 1432
9D0166EC  00402821   ADDU A1, V0, ZERO
9D0166F0  0F404EBD   JAL HTTPGetArg
9D0166F4  00000000   NOP
9D0166F8  AFC20010   SW V0, 16(S8)
1560:                	
1561:                	// We omit checking for space because this is the only data being written
1562:                	if(ptr != NULL)
9D0166FC  8FC20010   LW V0, 16(S8)
9D016700  1040001A   BEQ V0, ZERO, 0x9D01676C
9D016704  00000000   NOP
1563:                	{
1564:                		TCPPutROMString(sktHTTP, (ROM BYTE*)"Hello, ");
9D016708  938281E8   LBU V0, -32280(GP)
9D01670C  00401821   ADDU V1, V0, ZERO
9D016710  3C02A000   LUI V0, -24576
9D016714  000318C0   SLL V1, V1, 3
9D016718  24420600   ADDIU V0, V0, 1536
9D01671C  00621021   ADDU V0, V1, V0
9D016720  90420004   LBU V0, 4(V0)
9D016724  00401821   ADDU V1, V0, ZERO
9D016728  3C029D03   LUI V0, -25341
9D01672C  24423568   ADDIU V0, V0, 13672
9D016730  00602021   ADDU A0, V1, ZERO
9D016734  00402821   ADDU A1, V0, ZERO
9D016738  0F4005FD   JAL TCPPutString
9D01673C  00000000   NOP
1565:                		TCPPutString(sktHTTP, ptr);
9D016740  938281E8   LBU V0, -32280(GP)
9D016744  00401821   ADDU V1, V0, ZERO
9D016748  3C02A000   LUI V0, -24576
9D01674C  000318C0   SLL V1, V1, 3
9D016750  24420600   ADDIU V0, V0, 1536
9D016754  00621021   ADDU V0, V1, V0
9D016758  90420004   LBU V0, 4(V0)
9D01675C  00402021   ADDU A0, V0, ZERO
9D016760  8FC50010   LW A1, 16(S8)
9D016764  0F4005FD   JAL TCPPutString
9D016768  00000000   NOP
1566:                	}
1567:                
1568:                	return;
1569:                }
9D01676C  03C0E821   ADDU SP, S8, ZERO
9D016770  8FBF001C   LW RA, 28(SP)
9D016774  8FBE0018   LW S8, 24(SP)
9D016778  27BD0020   ADDIU SP, SP, 32
9D01677C  03E00008   JR RA
9D016780  00000000   NOP
1570:                
1571:                void HTTPPrint_cookiename(void)
1572:                {
9D016784  27BDFFE0   ADDIU SP, SP, -32
9D016788  AFBF001C   SW RA, 28(SP)
9D01678C  AFBE0018   SW S8, 24(SP)
9D016790  03A0F021   ADDU S8, SP, ZERO
1573:                	BYTE *ptr;
1574:                	
1575:                	ptr = HTTPGetROMArg(curHTTP.data, (ROM BYTE*)"name");
9D016794  3C029D03   LUI V0, -25341
9D016798  24423560   ADDIU V0, V0, 13664
9D01679C  3C03A000   LUI V1, -24576
9D0167A0  24640598   ADDIU A0, V1, 1432
9D0167A4  00402821   ADDU A1, V0, ZERO
9D0167A8  0F404EBD   JAL HTTPGetArg
9D0167AC  00000000   NOP
9D0167B0  AFC20010   SW V0, 16(S8)
1576:                	
1577:                	if(ptr)
9D0167B4  8FC20010   LW V0, 16(S8)
9D0167B8  1040000E   BEQ V0, ZERO, 0x9D0167F4
9D0167BC  00000000   NOP
1578:                		TCPPutString(sktHTTP, ptr);
9D0167C0  938281E8   LBU V0, -32280(GP)
9D0167C4  00401821   ADDU V1, V0, ZERO
9D0167C8  3C02A000   LUI V0, -24576
9D0167CC  000318C0   SLL V1, V1, 3
9D0167D0  24420600   ADDIU V0, V0, 1536
9D0167D4  00621021   ADDU V0, V1, V0
9D0167D8  90420004   LBU V0, 4(V0)
9D0167DC  00402021   ADDU A0, V0, ZERO
9D0167E0  8FC50010   LW A1, 16(S8)
9D0167E4  0F4005FD   JAL TCPPutString
9D0167E8  00000000   NOP
9D0167EC  0B405A0B   J 0x9D01682C
9D0167F0  00000000   NOP
1579:                	else
1580:                		TCPPutROMString(sktHTTP, (ROM BYTE*)"not set");
9D0167F4  938281E8   LBU V0, -32280(GP)
9D0167F8  00401821   ADDU V1, V0, ZERO
9D0167FC  3C02A000   LUI V0, -24576
9D016800  000318C0   SLL V1, V1, 3
9D016804  24420600   ADDIU V0, V0, 1536
9D016808  00621021   ADDU V0, V1, V0
9D01680C  90420004   LBU V0, 4(V0)
9D016810  00401821   ADDU V1, V0, ZERO
9D016814  3C029D03   LUI V0, -25341
9D016818  24423570   ADDIU V0, V0, 13680
9D01681C  00602021   ADDU A0, V1, ZERO
9D016820  00402821   ADDU A1, V0, ZERO
9D016824  0F4005FD   JAL TCPPutString
9D016828  00000000   NOP
1581:                	
1582:                	return;
1583:                }
9D01682C  03C0E821   ADDU SP, S8, ZERO
9D016830  8FBF001C   LW RA, 28(SP)
9D016834  8FBE0018   LW S8, 24(SP)
9D016838  27BD0020   ADDIU SP, SP, 32
9D01683C  03E00008   JR RA
9D016840  00000000   NOP
1584:                
1585:                void HTTPPrint_uploadedmd5(void)
1586:                {
9D016844  27BDFFD8   ADDIU SP, SP, -40
9D016848  AFBF0024   SW RA, 36(SP)
9D01684C  AFBE0020   SW S8, 32(SP)
9D016850  AFB0001C   SW S0, 28(SP)
9D016854  03A0F021   ADDU S8, SP, ZERO
1587:                	BYTE i;
1588:                
1589:                	// Set a flag to indicate not finished
1590:                	curHTTP.callbackPos = 1;
9D016858  3C02A000   LUI V0, -24576
9D01685C  24420574   ADDIU V0, V0, 1396
9D016860  24030001   ADDIU V1, ZERO, 1
9D016864  AC43000C   SW V1, 12(V0)
1591:                	
1592:                	// Make sure there's enough output space
1593:                	if(TCPIsPutReady(sktHTTP) < 32u + 37u + 5u)
9D016868  938281E8   LBU V0, -32280(GP)
9D01686C  00401821   ADDU V1, V0, ZERO
9D016870  3C02A000   LUI V0, -24576
9D016874  000318C0   SLL V1, V1, 3
9D016878  24420600   ADDIU V0, V0, 1536
9D01687C  00621021   ADDU V0, V1, V0
9D016880  90420004   LBU V0, 4(V0)
9D016884  00402021   ADDU A0, V0, ZERO
9D016888  0F40038E   JAL TCPIsPutReady
9D01688C  00000000   NOP
9D016890  2C42004A   SLTIU V0, V0, 74
9D016894  14400070   BNE V0, ZERO, 0x9D016A58
9D016898  00000000   NOP
1594:                		return;
9D016A58  00000000   NOP
1595:                
1596:                	// Check for flag set in HTTPPostMD5
1597:                #if defined(STACK_USE_HTTP_MD5_DEMO)
1598:                	if(curHTTP.smPost != SM_MD5_POST_COMPLETE)
9D01689C  3C02A000   LUI V0, -24576
9D0168A0  24420574   ADDIU V0, V0, 1396
9D0168A4  90430088   LBU V1, 136(V0)
9D0168A8  24020003   ADDIU V0, ZERO, 3
9D0168AC  10620014   BEQ V1, V0, 0x9D016900
9D0168B0  00000000   NOP
1599:                #endif
1600:                	{// No file uploaded, so just return
1601:                		TCPPutROMString(sktHTTP, (ROM BYTE*)"<b>Upload a File</b>");
9D0168B4  938281E8   LBU V0, -32280(GP)
9D0168B8  00401821   ADDU V1, V0, ZERO
9D0168BC  3C02A000   LUI V0, -24576
9D0168C0  000318C0   SLL V1, V1, 3
9D0168C4  24420600   ADDIU V0, V0, 1536
9D0168C8  00621021   ADDU V0, V1, V0
9D0168CC  90420004   LBU V0, 4(V0)
9D0168D0  00401821   ADDU V1, V0, ZERO
9D0168D4  3C029D03   LUI V0, -25341
9D0168D8  24423578   ADDIU V0, V0, 13688
9D0168DC  00602021   ADDU A0, V1, ZERO
9D0168E0  00402821   ADDU A1, V0, ZERO
9D0168E4  0F4005FD   JAL TCPPutString
9D0168E8  00000000   NOP
1602:                		curHTTP.callbackPos = 0;
9D0168EC  3C02A000   LUI V0, -24576
9D0168F0  24420574   ADDIU V0, V0, 1396
9D0168F4  AC40000C   SW ZERO, 12(V0)
1603:                		return;
9D0168F8  0B405A97   J 0x9D016A5C
9D0168FC  00000000   NOP
1604:                	}
1605:                	
1606:                	TCPPutROMString(sktHTTP, (ROM BYTE*)"<b>Uploaded File's MD5 was:</b><br />");
9D016900  938281E8   LBU V0, -32280(GP)
9D016904  00401821   ADDU V1, V0, ZERO
9D016908  3C02A000   LUI V0, -24576
9D01690C  000318C0   SLL V1, V1, 3
9D016910  24420600   ADDIU V0, V0, 1536
9D016914  00621021   ADDU V0, V1, V0
9D016918  90420004   LBU V0, 4(V0)
9D01691C  00401821   ADDU V1, V0, ZERO
9D016920  3C029D03   LUI V0, -25341
9D016924  24423590   ADDIU V0, V0, 13712
9D016928  00602021   ADDU A0, V1, ZERO
9D01692C  00402821   ADDU A1, V0, ZERO
9D016930  0F4005FD   JAL TCPPutString
9D016934  00000000   NOP
1607:                	
1608:                	// Write a byte of the md5 sum at a time
1609:                	for(i = 0; i < 16u; i++)
9D016938  A3C00010   SB ZERO, 16(S8)
9D01693C  0B405A8C   J 0x9D016A30
9D016940  00000000   NOP
9D016A24  93C20010   LBU V0, 16(S8)
9D016A28  24420001   ADDIU V0, V0, 1
9D016A2C  A3C20010   SB V0, 16(S8)
9D016A30  93C20010   LBU V0, 16(S8)
9D016A34  2C420010   SLTIU V0, V0, 16
9D016A38  1440FFC2   BNE V0, ZERO, 0x9D016944
9D016A3C  00000000   NOP
1610:                	{
1611:                		TCPPut(sktHTTP, btohexa_high(curHTTP.data[i]));
9D016944  938281E8   LBU V0, -32280(GP)
9D016948  00401821   ADDU V1, V0, ZERO
9D01694C  3C02A000   LUI V0, -24576
9D016950  000318C0   SLL V1, V1, 3
9D016954  24420600   ADDIU V0, V0, 1536
9D016958  00621021   ADDU V0, V1, V0
9D01695C  90420004   LBU V0, 4(V0)
9D016960  00408021   ADDU S0, V0, ZERO
9D016964  93C30010   LBU V1, 16(S8)
9D016968  3C02A000   LUI V0, -24576
9D01696C  24420574   ADDIU V0, V0, 1396
9D016970  00621021   ADDU V0, V1, V0
9D016974  90420024   LBU V0, 36(V0)
9D016978  00402021   ADDU A0, V0, ZERO
9D01697C  0F409989   JAL btohexa_high
9D016980  00000000   NOP
9D016984  02002021   ADDU A0, S0, ZERO
9D016988  00402821   ADDU A1, V0, ZERO
9D01698C  0F40040C   JAL TCPPut
9D016990  00000000   NOP
1612:                		TCPPut(sktHTTP, btohexa_low(curHTTP.data[i]));
9D016994  938281E8   LBU V0, -32280(GP)
9D016998  00401821   ADDU V1, V0, ZERO
9D01699C  3C02A000   LUI V0, -24576
9D0169A0  000318C0   SLL V1, V1, 3
9D0169A4  24420600   ADDIU V0, V0, 1536
9D0169A8  00621021   ADDU V0, V1, V0
9D0169AC  90420004   LBU V0, 4(V0)
9D0169B0  00408021   ADDU S0, V0, ZERO
9D0169B4  93C30010   LBU V1, 16(S8)
9D0169B8  3C02A000   LUI V0, -24576
9D0169BC  24420574   ADDIU V0, V0, 1396
9D0169C0  00621021   ADDU V0, V1, V0
9D0169C4  90420024   LBU V0, 36(V0)
9D0169C8  00402021   ADDU A0, V0, ZERO
9D0169CC  0F4099A2   JAL btohexa_low
9D0169D0  00000000   NOP
9D0169D4  02002021   ADDU A0, S0, ZERO
9D0169D8  00402821   ADDU A1, V0, ZERO
9D0169DC  0F40040C   JAL TCPPut
9D0169E0  00000000   NOP
1613:                		if((i & 0x03) == 3u)
9D0169E4  93C20010   LBU V0, 16(S8)
9D0169E8  30430003   ANDI V1, V0, 3
9D0169EC  24020003   ADDIU V0, ZERO, 3
9D0169F0  1462000C   BNE V1, V0, 0x9D016A24
9D0169F4  00000000   NOP
1614:                			TCPPut(sktHTTP, ' ');
9D0169F8  938281E8   LBU V0, -32280(GP)
9D0169FC  00401821   ADDU V1, V0, ZERO
9D016A00  3C02A000   LUI V0, -24576
9D016A04  000318C0   SLL V1, V1, 3
9D016A08  24420600   ADDIU V0, V0, 1536
9D016A0C  00621021   ADDU V0, V1, V0
9D016A10  90420004   LBU V0, 4(V0)
9D016A14  00402021   ADDU A0, V0, ZERO
9D016A18  24050020   ADDIU A1, ZERO, 32
9D016A1C  0F40040C   JAL TCPPut
9D016A20  00000000   NOP
1615:                	}
1616:                	
1617:                	curHTTP.callbackPos = 0x00;
9D016A40  3C02A000   LUI V0, -24576
9D016A44  24420574   ADDIU V0, V0, 1396
9D016A48  AC40000C   SW ZERO, 12(V0)
1618:                	return;
9D016A4C  00000000   NOP
9D016A50  0B405A97   J 0x9D016A5C
9D016A54  00000000   NOP
1619:                }
9D016A5C  03C0E821   ADDU SP, S8, ZERO
9D016A60  8FBF0024   LW RA, 36(SP)
9D016A64  8FBE0020   LW S8, 32(SP)
9D016A68  8FB0001C   LW S0, 28(SP)
9D016A6C  27BD0028   ADDIU SP, SP, 40
9D016A70  03E00008   JR RA
9D016A74  00000000   NOP
1620:                
1621:                extern APP_CONFIG AppConfig;
1622:                
1623:                void HTTPPrintIP(IP_ADDR ip)
1624:                {
9D016A78  27BDFFE0   ADDIU SP, SP, -32
9D016A7C  AFBF001C   SW RA, 28(SP)
9D016A80  AFBE0018   SW S8, 24(SP)
9D016A84  03A0F021   ADDU S8, SP, ZERO
9D016A88  AFC40020   SW A0, 32(S8)
1625:                	BYTE digits[4];
1626:                	BYTE i;
1627:                	
1628:                	for(i = 0; i < 4u; i++)
9D016A8C  A3C00010   SB ZERO, 16(S8)
9D016A90  0B405ACE   J 0x9D016B38
9D016A94  00000000   NOP
9D016B2C  93C20010   LBU V0, 16(S8)
9D016B30  24420001   ADDIU V0, V0, 1
9D016B34  A3C20010   SB V0, 16(S8)
9D016B38  93C20010   LBU V0, 16(S8)
9D016B3C  2C420004   SLTIU V0, V0, 4
9D016B40  1440FFD5   BNE V0, ZERO, 0x9D016A98
9D016B44  00000000   NOP
1629:                	{
1630:                		if(i)
9D016A98  93C20010   LBU V0, 16(S8)
9D016A9C  1040000C   BEQ V0, ZERO, 0x9D016AD0
9D016AA0  00000000   NOP
1631:                			TCPPut(sktHTTP, '.');
9D016AA4  938281E8   LBU V0, -32280(GP)
9D016AA8  00401821   ADDU V1, V0, ZERO
9D016AAC  3C02A000   LUI V0, -24576
9D016AB0  000318C0   SLL V1, V1, 3
9D016AB4  24420600   ADDIU V0, V0, 1536
9D016AB8  00621021   ADDU V0, V1, V0
9D016ABC  90420004   LBU V0, 4(V0)
9D016AC0  00402021   ADDU A0, V0, ZERO
9D016AC4  2405002E   ADDIU A1, ZERO, 46
9D016AC8  0F40040C   JAL TCPPut
9D016ACC  00000000   NOP
1632:                		uitoa(ip.v[i], digits);
9D016AD0  93C20010   LBU V0, 16(S8)
9D016AD4  27C30020   ADDIU V1, S8, 32
9D016AD8  00621021   ADDU V0, V1, V0
9D016ADC  90420000   LBU V0, 0(V0)
9D016AE0  00401821   ADDU V1, V0, ZERO
9D016AE4  27C20014   ADDIU V0, S8, 20
9D016AE8  00602021   ADDU A0, V1, ZERO
9D016AEC  00402821   ADDU A1, V0, ZERO
9D016AF0  0F409900   JAL uitoa
9D016AF4  00000000   NOP
1633:                		TCPPutString(sktHTTP, digits);
9D016AF8  938281E8   LBU V0, -32280(GP)
9D016AFC  00401821   ADDU V1, V0, ZERO
9D016B00  3C02A000   LUI V0, -24576
9D016B04  000318C0   SLL V1, V1, 3
9D016B08  24420600   ADDIU V0, V0, 1536
9D016B0C  00621021   ADDU V0, V1, V0
9D016B10  90420004   LBU V0, 4(V0)
9D016B14  00401821   ADDU V1, V0, ZERO
9D016B18  27C20014   ADDIU V0, S8, 20
9D016B1C  00602021   ADDU A0, V1, ZERO
9D016B20  00402821   ADDU A1, V0, ZERO
9D016B24  0F4005FD   JAL TCPPutString
9D016B28  00000000   NOP
1634:                	}
1635:                }
9D016B48  03C0E821   ADDU SP, S8, ZERO
9D016B4C  8FBF001C   LW RA, 28(SP)
9D016B50  8FBE0018   LW S8, 24(SP)
9D016B54  27BD0020   ADDIU SP, SP, 32
9D016B58  03E00008   JR RA
9D016B5C  00000000   NOP
1636:                
1637:                void HTTPPrint_config_hostname(void)
1638:                {
9D016B60  27BDFFE8   ADDIU SP, SP, -24
9D016B64  AFBF0014   SW RA, 20(SP)
9D016B68  AFBE0010   SW S8, 16(SP)
9D016B6C  03A0F021   ADDU S8, SP, ZERO
1639:                	TCPPutString(sktHTTP, AppConfig.NetBIOSName);
9D016B70  938281E8   LBU V0, -32280(GP)
9D016B74  00401821   ADDU V1, V0, ZERO
9D016B78  3C02A000   LUI V0, -24576
9D016B7C  000318C0   SLL V1, V1, 3
9D016B80  24420600   ADDIU V0, V0, 1536
9D016B84  00621021   ADDU V0, V1, V0
9D016B88  90420004   LBU V0, 4(V0)
9D016B8C  00402021   ADDU A0, V0, ZERO
9D016B90  3C02A000   LUI V0, -24576
9D016B94  24450744   ADDIU A1, V0, 1860
9D016B98  0F4005FD   JAL TCPPutString
9D016B9C  00000000   NOP
1640:                	return;
1641:                }
9D016BA0  03C0E821   ADDU SP, S8, ZERO
9D016BA4  8FBF0014   LW RA, 20(SP)
9D016BA8  8FBE0010   LW S8, 16(SP)
9D016BAC  27BD0018   ADDIU SP, SP, 24
9D016BB0  03E00008   JR RA
9D016BB4  00000000   NOP
1642:                
1643:                void HTTPPrint_config_dhcpchecked(void)
1644:                {
9D016BB8  27BDFFE8   ADDIU SP, SP, -24
9D016BBC  AFBF0014   SW RA, 20(SP)
9D016BC0  AFBE0010   SW S8, 16(SP)
9D016BC4  03A0F021   ADDU S8, SP, ZERO
1645:                	if(AppConfig.Flags.bIsDHCPEnabled)
9D016BC8  3C02A000   LUI V0, -24576
9D016BCC  24420728   ADDIU V0, V0, 1832
9D016BD0  9042002C   LBU V0, 44(V0)
9D016BD4  30420040   ANDI V0, V0, 64
9D016BD8  304200FF   ANDI V0, V0, 255
9D016BDC  1040000F   BEQ V0, ZERO, 0x9D016C1C
9D016BE0  00000000   NOP
1646:                		TCPPutROMString(sktHTTP, (ROM BYTE*)"checked");
9D016BE4  938281E8   LBU V0, -32280(GP)
9D016BE8  00401821   ADDU V1, V0, ZERO
9D016BEC  3C02A000   LUI V0, -24576
9D016BF0  000318C0   SLL V1, V1, 3
9D016BF4  24420600   ADDIU V0, V0, 1536
9D016BF8  00621021   ADDU V0, V1, V0
9D016BFC  90420004   LBU V0, 4(V0)
9D016C00  00401821   ADDU V1, V0, ZERO
9D016C04  3C029D03   LUI V0, -25341
9D016C08  244235B8   ADDIU V0, V0, 13752
9D016C0C  00602021   ADDU A0, V1, ZERO
9D016C10  00402821   ADDU A1, V0, ZERO
9D016C14  0F4005FD   JAL TCPPutString
9D016C18  00000000   NOP
1647:                	return;
1648:                }
9D016C1C  03C0E821   ADDU SP, S8, ZERO
9D016C20  8FBF0014   LW RA, 20(SP)
9D016C24  8FBE0010   LW S8, 16(SP)
9D016C28  27BD0018   ADDIU SP, SP, 24
9D016C2C  03E00008   JR RA
9D016C30  00000000   NOP
1649:                
1650:                void HTTPPrint_config_ip(void)
1651:                {
9D016C34  27BDFFE8   ADDIU SP, SP, -24
9D016C38  AFBF0014   SW RA, 20(SP)
9D016C3C  AFBE0010   SW S8, 16(SP)
9D016C40  03A0F021   ADDU S8, SP, ZERO
1652:                	HTTPPrintIP(AppConfig.MyIPAddr);
9D016C44  3C02A000   LUI V0, -24576
9D016C48  24430728   ADDIU V1, V0, 1832
9D016C4C  88630003   LWL V1, 3(V1)
9D016C50  00602021   ADDU A0, V1, ZERO
9D016C54  98440728   LWR A0, 1832(V0)
9D016C58  00801021   ADDU V0, A0, ZERO
9D016C5C  00402021   ADDU A0, V0, ZERO
9D016C60  0F405A9E   JAL HTTPPrintIP
9D016C64  00000000   NOP
1653:                	return;
1654:                }
9D016C68  03C0E821   ADDU SP, S8, ZERO
9D016C6C  8FBF0014   LW RA, 20(SP)
9D016C70  8FBE0010   LW S8, 16(SP)
9D016C74  27BD0018   ADDIU SP, SP, 24
9D016C78  03E00008   JR RA
9D016C7C  00000000   NOP
1655:                
1656:                void HTTPPrint_config_gw(void)
1657:                {
9D016C80  27BDFFE8   ADDIU SP, SP, -24
9D016C84  AFBF0014   SW RA, 20(SP)
9D016C88  AFBE0010   SW S8, 16(SP)
9D016C8C  03A0F021   ADDU S8, SP, ZERO
1658:                	HTTPPrintIP(AppConfig.MyGateway);
9D016C90  3C02A000   LUI V0, -24576
9D016C94  24420728   ADDIU V0, V0, 1832
9D016C98  8843000B   LWL V1, 11(V0)
9D016C9C  00602021   ADDU A0, V1, ZERO
9D016CA0  98440008   LWR A0, 8(V0)
9D016CA4  00801021   ADDU V0, A0, ZERO
9D016CA8  00402021   ADDU A0, V0, ZERO
9D016CAC  0F405A9E   JAL HTTPPrintIP
9D016CB0  00000000   NOP
1659:                	return;
1660:                }
9D016CB4  03C0E821   ADDU SP, S8, ZERO
9D016CB8  8FBF0014   LW RA, 20(SP)
9D016CBC  8FBE0010   LW S8, 16(SP)
9D016CC0  27BD0018   ADDIU SP, SP, 24
9D016CC4  03E00008   JR RA
9D016CC8  00000000   NOP
1661:                
1662:                void HTTPPrint_config_subnet(void)
1663:                {
9D016CCC  27BDFFE8   ADDIU SP, SP, -24
9D016CD0  AFBF0014   SW RA, 20(SP)
9D016CD4  AFBE0010   SW S8, 16(SP)
9D016CD8  03A0F021   ADDU S8, SP, ZERO
1664:                	HTTPPrintIP(AppConfig.MyMask);
9D016CDC  3C02A000   LUI V0, -24576
9D016CE0  24420728   ADDIU V0, V0, 1832
9D016CE4  88430007   LWL V1, 7(V0)
9D016CE8  00602021   ADDU A0, V1, ZERO
9D016CEC  98440004   LWR A0, 4(V0)
9D016CF0  00801021   ADDU V0, A0, ZERO
9D016CF4  00402021   ADDU A0, V0, ZERO
9D016CF8  0F405A9E   JAL HTTPPrintIP
9D016CFC  00000000   NOP
1665:                	return;
1666:                }
9D016D00  03C0E821   ADDU SP, S8, ZERO
9D016D04  8FBF0014   LW RA, 20(SP)
9D016D08  8FBE0010   LW S8, 16(SP)
9D016D0C  27BD0018   ADDIU SP, SP, 24
9D016D10  03E00008   JR RA
9D016D14  00000000   NOP
1667:                
1668:                void HTTPPrint_config_dns1(void)
1669:                {
9D016D18  27BDFFE8   ADDIU SP, SP, -24
9D016D1C  AFBF0014   SW RA, 20(SP)
9D016D20  AFBE0010   SW S8, 16(SP)
9D016D24  03A0F021   ADDU S8, SP, ZERO
1670:                	HTTPPrintIP(AppConfig.PrimaryDNSServer);
9D016D28  3C02A000   LUI V0, -24576
9D016D2C  24420728   ADDIU V0, V0, 1832
9D016D30  8843000F   LWL V1, 15(V0)
9D016D34  00602021   ADDU A0, V1, ZERO
9D016D38  9844000C   LWR A0, 12(V0)
9D016D3C  00801021   ADDU V0, A0, ZERO
9D016D40  00402021   ADDU A0, V0, ZERO
9D016D44  0F405A9E   JAL HTTPPrintIP
9D016D48  00000000   NOP
1671:                	return;
1672:                }
9D016D4C  03C0E821   ADDU SP, S8, ZERO
9D016D50  8FBF0014   LW RA, 20(SP)
9D016D54  8FBE0010   LW S8, 16(SP)
9D016D58  27BD0018   ADDIU SP, SP, 24
9D016D5C  03E00008   JR RA
9D016D60  00000000   NOP
1673:                
1674:                void HTTPPrint_config_dns2(void)
1675:                {
9D016D64  27BDFFE8   ADDIU SP, SP, -24
9D016D68  AFBF0014   SW RA, 20(SP)
9D016D6C  AFBE0010   SW S8, 16(SP)
9D016D70  03A0F021   ADDU S8, SP, ZERO
1676:                	HTTPPrintIP(AppConfig.SecondaryDNSServer);
9D016D74  3C02A000   LUI V0, -24576
9D016D78  24420728   ADDIU V0, V0, 1832
9D016D7C  88430013   LWL V1, 19(V0)
9D016D80  00602021   ADDU A0, V1, ZERO
9D016D84  98440010   LWR A0, 16(V0)
9D016D88  00801021   ADDU V0, A0, ZERO
9D016D8C  00402021   ADDU A0, V0, ZERO
9D016D90  0F405A9E   JAL HTTPPrintIP
9D016D94  00000000   NOP
1677:                	return;
1678:                }
9D016D98  03C0E821   ADDU SP, S8, ZERO
9D016D9C  8FBF0014   LW RA, 20(SP)
9D016DA0  8FBE0010   LW S8, 16(SP)
9D016DA4  27BD0018   ADDIU SP, SP, 24
9D016DA8  03E00008   JR RA
9D016DAC  00000000   NOP
1679:                
1680:                void HTTPPrint_config_mac(void)
1681:                {
9D016DB0  27BDFFD8   ADDIU SP, SP, -40
9D016DB4  AFBF0024   SW RA, 36(SP)
9D016DB8  AFBE0020   SW S8, 32(SP)
9D016DBC  AFB0001C   SW S0, 28(SP)
9D016DC0  03A0F021   ADDU S8, SP, ZERO
1682:                	BYTE i;
1683:                	
1684:                	if(TCPIsPutReady(sktHTTP) < 18u)
9D016DC4  938281E8   LBU V0, -32280(GP)
9D016DC8  00401821   ADDU V1, V0, ZERO
9D016DCC  3C02A000   LUI V0, -24576
9D016DD0  000318C0   SLL V1, V1, 3
9D016DD4  24420600   ADDIU V0, V0, 1536
9D016DD8  00621021   ADDU V0, V1, V0
9D016DDC  90420004   LBU V0, 4(V0)
9D016DE0  00402021   ADDU A0, V0, ZERO
9D016DE4  0F40038E   JAL TCPIsPutReady
9D016DE8  00000000   NOP
9D016DEC  2C420012   SLTIU V0, V0, 18
9D016DF0  10400007   BEQ V0, ZERO, 0x9D016E10
9D016DF4  00000000   NOP
1685:                	{//need 17 bytes to write a MAC
1686:                		curHTTP.callbackPos = 0x01;
9D016DF8  3C02A000   LUI V0, -24576
9D016DFC  24420574   ADDIU V0, V0, 1396
9D016E00  24030001   ADDIU V1, ZERO, 1
9D016E04  AC43000C   SW V1, 12(V0)
1687:                		return;
9D016E08  0B405BC8   J 0x9D016F20
9D016E0C  00000000   NOP
1688:                	}	
1689:                	
1690:                	// Write each byte
1691:                	for(i = 0; i < 6u; i++)
9D016E10  A3C00010   SB ZERO, 16(S8)
9D016E14  0B405BC0   J 0x9D016F00
9D016E18  00000000   NOP
9D016EF4  93C20010   LBU V0, 16(S8)
9D016EF8  24420001   ADDIU V0, V0, 1
9D016EFC  A3C20010   SB V0, 16(S8)
9D016F00  93C20010   LBU V0, 16(S8)
9D016F04  2C420006   SLTIU V0, V0, 6
9D016F08  1440FFC4   BNE V0, ZERO, 0x9D016E1C
9D016F0C  00000000   NOP
1692:                	{
1693:                		if(i)
9D016E1C  93C20010   LBU V0, 16(S8)
9D016E20  1040000C   BEQ V0, ZERO, 0x9D016E54
9D016E24  00000000   NOP
1694:                			TCPPut(sktHTTP, ':');
9D016E28  938281E8   LBU V0, -32280(GP)
9D016E2C  00401821   ADDU V1, V0, ZERO
9D016E30  3C02A000   LUI V0, -24576
9D016E34  000318C0   SLL V1, V1, 3
9D016E38  24420600   ADDIU V0, V0, 1536
9D016E3C  00621021   ADDU V0, V1, V0
9D016E40  90420004   LBU V0, 4(V0)
9D016E44  00402021   ADDU A0, V0, ZERO
9D016E48  2405003A   ADDIU A1, ZERO, 58
9D016E4C  0F40040C   JAL TCPPut
9D016E50  00000000   NOP
1695:                		TCPPut(sktHTTP, btohexa_high(AppConfig.MyMACAddr.v[i]));
9D016E54  938281E8   LBU V0, -32280(GP)
9D016E58  00401821   ADDU V1, V0, ZERO
9D016E5C  3C02A000   LUI V0, -24576
9D016E60  000318C0   SLL V1, V1, 3
9D016E64  24420600   ADDIU V0, V0, 1536
9D016E68  00621021   ADDU V0, V1, V0
9D016E6C  90420004   LBU V0, 4(V0)
9D016E70  00408021   ADDU S0, V0, ZERO
9D016E74  93C20010   LBU V0, 16(S8)
9D016E78  3C03A000   LUI V1, -24576
9D016E7C  24630728   ADDIU V1, V1, 1832
9D016E80  00621021   ADDU V0, V1, V0
9D016E84  9042002D   LBU V0, 45(V0)
9D016E88  00402021   ADDU A0, V0, ZERO
9D016E8C  0F409989   JAL btohexa_high
9D016E90  00000000   NOP
9D016E94  02002021   ADDU A0, S0, ZERO
9D016E98  00402821   ADDU A1, V0, ZERO
9D016E9C  0F40040C   JAL TCPPut
9D016EA0  00000000   NOP
1696:                		TCPPut(sktHTTP, btohexa_low(AppConfig.MyMACAddr.v[i]));
9D016EA4  938281E8   LBU V0, -32280(GP)
9D016EA8  00401821   ADDU V1, V0, ZERO
9D016EAC  3C02A000   LUI V0, -24576
9D016EB0  000318C0   SLL V1, V1, 3
9D016EB4  24420600   ADDIU V0, V0, 1536
9D016EB8  00621021   ADDU V0, V1, V0
9D016EBC  90420004   LBU V0, 4(V0)
9D016EC0  00408021   ADDU S0, V0, ZERO
9D016EC4  93C20010   LBU V0, 16(S8)
9D016EC8  3C03A000   LUI V1, -24576
9D016ECC  24630728   ADDIU V1, V1, 1832
9D016ED0  00621021   ADDU V0, V1, V0
9D016ED4  9042002D   LBU V0, 45(V0)
9D016ED8  00402021   ADDU A0, V0, ZERO
9D016EDC  0F4099A2   JAL btohexa_low
9D016EE0  00000000   NOP
9D016EE4  02002021   ADDU A0, S0, ZERO
9D016EE8  00402821   ADDU A1, V0, ZERO
9D016EEC  0F40040C   JAL TCPPut
9D016EF0  00000000   NOP
1697:                	}
1698:                	
1699:                	// Indicate that we're done
1700:                	curHTTP.callbackPos = 0x00;
9D016F10  3C02A000   LUI V0, -24576
9D016F14  24420574   ADDIU V0, V0, 1396
9D016F18  AC40000C   SW ZERO, 12(V0)
1701:                	return;
9D016F1C  00000000   NOP
1702:                }
9D016F20  03C0E821   ADDU SP, S8, ZERO
9D016F24  8FBF0024   LW RA, 36(SP)
9D016F28  8FBE0020   LW S8, 32(SP)
9D016F2C  8FB0001C   LW S0, 28(SP)
9D016F30  27BD0028   ADDIU SP, SP, 40
9D016F34  03E00008   JR RA
9D016F38  00000000   NOP
1703:                
1704:                
1705:                // SNMP Read communities configuration page
1706:                void HTTPPrint_read_comm(WORD num)
1707:                {
9D016F3C  27BDFFF8   ADDIU SP, SP, -8
9D016F40  AFBE0004   SW S8, 4(SP)
9D016F44  03A0F021   ADDU S8, SP, ZERO
9D016F48  00801021   ADDU V0, A0, ZERO
9D016F4C  A7C20008   SH V0, 8(S8)
1708:                	#if defined(STACK_USE_SNMP_SERVER)
1709:                	// Ensure no one tries to read illegal memory addresses by specifying 
1710:                	// illegal num values.
1711:                	if(num >= SNMP_MAX_COMMUNITY_SUPPORT)
1712:                		return;
1713:                		
1714:                	// Send proper string
1715:                	TCPPutString(sktHTTP, AppConfig.readCommunity[num]);
1716:                	#endif
1717:                }
9D016F50  03C0E821   ADDU SP, S8, ZERO
9D016F54  8FBE0004   LW S8, 4(SP)
9D016F58  27BD0008   ADDIU SP, SP, 8
9D016F5C  03E00008   JR RA
9D016F60  00000000   NOP
1718:                
1719:                // SNMP Write communities configuration page
1720:                void HTTPPrint_write_comm(WORD num)
1721:                {
9D016F64  27BDFFF8   ADDIU SP, SP, -8
9D016F68  AFBE0004   SW S8, 4(SP)
9D016F6C  03A0F021   ADDU S8, SP, ZERO
9D016F70  00801021   ADDU V0, A0, ZERO
9D016F74  A7C20008   SH V0, 8(S8)
1722:                	#if defined(STACK_USE_SNMP_SERVER)
1723:                	// Ensure no one tries to read illegal memory addresses by specifying 
1724:                	// illegal num values.
1725:                	if(num >= SNMP_MAX_COMMUNITY_SUPPORT)
1726:                		return;
1727:                		
1728:                	// Send proper string
1729:                	TCPPutString(sktHTTP, AppConfig.writeCommunity[num]);
1730:                	#endif
1731:                }
9D016F78  03C0E821   ADDU SP, S8, ZERO
9D016F7C  8FBE0004   LW S8, 4(SP)
9D016F80  27BD0008   ADDIU SP, SP, 8
9D016F84  03E00008   JR RA
9D016F88  00000000   NOP
1732:                
1733:                
1734:                void HTTPPrint_reboot(void)
1735:                {
9D016F8C  27BDFFE8   ADDIU SP, SP, -24
9D016F90  AFBF0014   SW RA, 20(SP)
9D016F94  AFBE0010   SW S8, 16(SP)
9D016F98  03A0F021   ADDU S8, SP, ZERO
1736:                	// This is not so much a print function, but causes the board to reboot
1737:                	// when the configuration is changed.  If called via an AJAX call, this
1738:                	// will gracefully reset the board and bring it back online immediately
1739:                	Reset();
9D016F9C  0F40D720   JAL SoftReset
9D016FA0  00000000   NOP
1740:                }
1741:                
1742:                void HTTPPrint_rebootaddr(void)
1743:                {// This is the expected address of the board upon rebooting
9D016FA4  27BDFFE8   ADDIU SP, SP, -24
9D016FA8  AFBF0014   SW RA, 20(SP)
9D016FAC  AFBE0010   SW S8, 16(SP)
9D016FB0  03A0F021   ADDU S8, SP, ZERO
1744:                	TCPPutString(sktHTTP, curHTTP.data);	
9D016FB4  938281E8   LBU V0, -32280(GP)
9D016FB8  00401821   ADDU V1, V0, ZERO
9D016FBC  3C02A000   LUI V0, -24576
9D016FC0  000318C0   SLL V1, V1, 3
9D016FC4  24420600   ADDIU V0, V0, 1536
9D016FC8  00621021   ADDU V0, V1, V0
9D016FCC  90420004   LBU V0, 4(V0)
9D016FD0  00402021   ADDU A0, V0, ZERO
9D016FD4  3C02A000   LUI V0, -24576
9D016FD8  24450598   ADDIU A1, V0, 1432
9D016FDC  0F4005FD   JAL TCPPutString
9D016FE0  00000000   NOP
1745:                }
9D016FE4  03C0E821   ADDU SP, S8, ZERO
9D016FE8  8FBF0014   LW RA, 20(SP)
9D016FEC  8FBE0010   LW S8, 16(SP)
9D016FF0  27BD0018   ADDIU SP, SP, 24
9D016FF4  03E00008   JR RA
9D016FF8  00000000   NOP
1746:                
1747:                void HTTPPrint_ddns_user(void)
1748:                {
9D016FFC  27BDFFF8   ADDIU SP, SP, -8
9D017000  AFBE0004   SW S8, 4(SP)
9D017004  03A0F021   ADDU S8, SP, ZERO
1749:                	#if defined(STACK_USE_DYNAMICDNS_CLIENT)
1750:                	if(DDNSClient.ROMPointers.Username || !DDNSClient.Username.szRAM)
1751:                		return;
1752:                	if(curHTTP.callbackPos == 0x00u)
1753:                		curHTTP.callbackPos = (PTR_BASE)DDNSClient.Username.szRAM;
1754:                	curHTTP.callbackPos = (PTR_BASE)TCPPutString(sktHTTP, (BYTE*)(PTR_BASE)curHTTP.callbackPos);
1755:                	if(*(BYTE*)(PTR_BASE)curHTTP.callbackPos == '\0')
1756:                		curHTTP.callbackPos = 0x00;
1757:                	#endif
1758:                }
9D017008  03C0E821   ADDU SP, S8, ZERO
9D01700C  8FBE0004   LW S8, 4(SP)
9D017010  27BD0008   ADDIU SP, SP, 8
9D017014  03E00008   JR RA
9D017018  00000000   NOP
1759:                
1760:                void HTTPPrint_ddns_pass(void)
1761:                {
9D01701C  27BDFFF8   ADDIU SP, SP, -8
9D017020  AFBE0004   SW S8, 4(SP)
9D017024  03A0F021   ADDU S8, SP, ZERO
1762:                	#if defined(STACK_USE_DYNAMICDNS_CLIENT)
1763:                	if(DDNSClient.ROMPointers.Password || !DDNSClient.Password.szRAM)
1764:                		return;
1765:                	if(curHTTP.callbackPos == 0x00u)
1766:                		curHTTP.callbackPos = (PTR_BASE)DDNSClient.Password.szRAM;
1767:                	curHTTP.callbackPos = (PTR_BASE)TCPPutString(sktHTTP, (BYTE*)(PTR_BASE)curHTTP.callbackPos);
1768:                	if(*(BYTE*)(PTR_BASE)curHTTP.callbackPos == '\0')
1769:                		curHTTP.callbackPos = 0x00;
1770:                	#endif
1771:                }
9D017028  03C0E821   ADDU SP, S8, ZERO
9D01702C  8FBE0004   LW S8, 4(SP)
9D017030  27BD0008   ADDIU SP, SP, 8
9D017034  03E00008   JR RA
9D017038  00000000   NOP
1772:                
1773:                void HTTPPrint_ddns_host(void)
1774:                {
9D01703C  27BDFFF8   ADDIU SP, SP, -8
9D017040  AFBE0004   SW S8, 4(SP)
9D017044  03A0F021   ADDU S8, SP, ZERO
1775:                	#if defined(STACK_USE_DYNAMICDNS_CLIENT)
1776:                	if(DDNSClient.ROMPointers.Host || !DDNSClient.Host.szRAM)
1777:                		return;
1778:                	if(curHTTP.callbackPos == 0x00u)
1779:                		curHTTP.callbackPos = (PTR_BASE)DDNSClient.Host.szRAM;
1780:                	curHTTP.callbackPos = (PTR_BASE)TCPPutString(sktHTTP, (BYTE*)(PTR_BASE)curHTTP.callbackPos);
1781:                	if(*(BYTE*)(PTR_BASE)curHTTP.callbackPos == '\0')
1782:                		curHTTP.callbackPos = 0x00;
1783:                	#endif
1784:                }
9D017048  03C0E821   ADDU SP, S8, ZERO
9D01704C  8FBE0004   LW S8, 4(SP)
9D017050  27BD0008   ADDIU SP, SP, 8
9D017054  03E00008   JR RA
9D017058  00000000   NOP
1785:                
1786:                extern ROM char * ROM ddnsServiceHosts[];
1787:                void HTTPPrint_ddns_service(WORD i)
1788:                {
9D01705C  27BDFFF8   ADDIU SP, SP, -8
9D017060  AFBE0004   SW S8, 4(SP)
9D017064  03A0F021   ADDU S8, SP, ZERO
9D017068  00801021   ADDU V0, A0, ZERO
9D01706C  A7C20008   SH V0, 8(S8)
1789:                	#if defined(STACK_USE_DYNAMICDNS_CLIENT)
1790:                	if(!DDNSClient.ROMPointers.UpdateServer || !DDNSClient.UpdateServer.szROM)
1791:                		return;
1792:                	if((ROM char*)DDNSClient.UpdateServer.szROM == ddnsServiceHosts[i])
1793:                		TCPPutROMString(sktHTTP, (ROM BYTE*)"selected");
1794:                	#endif
1795:                }
9D017070  03C0E821   ADDU SP, S8, ZERO
9D017074  8FBE0004   LW S8, 4(SP)
9D017078  27BD0008   ADDIU SP, SP, 8
9D01707C  03E00008   JR RA
9D017080  00000000   NOP
1796:                
1797:                
1798:                void HTTPPrint_ddns_status(void)
1799:                {
9D017084  27BDFFE8   ADDIU SP, SP, -24
9D017088  AFBF0014   SW RA, 20(SP)
9D01708C  AFBE0010   SW S8, 16(SP)
9D017090  03A0F021   ADDU S8, SP, ZERO
1800:                	#if defined(STACK_USE_DYNAMICDNS_CLIENT)
1801:                	DDNS_STATUS s;
1802:                	s = DDNSGetLastStatus();
1803:                	if(s == DDNS_STATUS_GOOD || s == DDNS_STATUS_UNCHANGED || s == DDNS_STATUS_NOCHG)
1804:                		TCPPutROMString(sktHTTP, (ROM BYTE*)"ok");
1805:                	else if(s == DDNS_STATUS_UNKNOWN)
1806:                		TCPPutROMString(sktHTTP, (ROM BYTE*)"unk");
1807:                	else
1808:                		TCPPutROMString(sktHTTP, (ROM BYTE*)"fail");
1809:                	#else
1810:                	TCPPutROMString(sktHTTP, (ROM BYTE*)"fail");
9D017094  938281E8   LBU V0, -32280(GP)
9D017098  00401821   ADDU V1, V0, ZERO
9D01709C  3C02A000   LUI V0, -24576
9D0170A0  000318C0   SLL V1, V1, 3
9D0170A4  24420600   ADDIU V0, V0, 1536
9D0170A8  00621021   ADDU V0, V1, V0
9D0170AC  90420004   LBU V0, 4(V0)
9D0170B0  00401821   ADDU V1, V0, ZERO
9D0170B4  3C029D03   LUI V0, -25341
9D0170B8  244235C0   ADDIU V0, V0, 13760
9D0170BC  00602021   ADDU A0, V1, ZERO
9D0170C0  00402821   ADDU A1, V0, ZERO
9D0170C4  0F4005FD   JAL TCPPutString
9D0170C8  00000000   NOP
1811:                	#endif
1812:                }
9D0170CC  03C0E821   ADDU SP, S8, ZERO
9D0170D0  8FBF0014   LW RA, 20(SP)
9D0170D4  8FBE0010   LW S8, 16(SP)
9D0170D8  27BD0018   ADDIU SP, SP, 24
9D0170DC  03E00008   JR RA
9D0170E0  00000000   NOP
1813:                
1814:                void HTTPPrint_ddns_status_msg(void)
1815:                {
9D0170E4  27BDFFE8   ADDIU SP, SP, -24
9D0170E8  AFBF0014   SW RA, 20(SP)
9D0170EC  AFBE0010   SW S8, 16(SP)
9D0170F0  03A0F021   ADDU S8, SP, ZERO
1816:                	if(TCPIsPutReady(sktHTTP) < 75u)
9D0170F4  938281E8   LBU V0, -32280(GP)
9D0170F8  00401821   ADDU V1, V0, ZERO
9D0170FC  3C02A000   LUI V0, -24576
9D017100  000318C0   SLL V1, V1, 3
9D017104  24420600   ADDIU V0, V0, 1536
9D017108  00621021   ADDU V0, V1, V0
9D01710C  90420004   LBU V0, 4(V0)
9D017110  00402021   ADDU A0, V0, ZERO
9D017114  0F40038E   JAL TCPIsPutReady
9D017118  00000000   NOP
9D01711C  2C42004B   SLTIU V0, V0, 75
9D017120  10400007   BEQ V0, ZERO, 0x9D017140
9D017124  00000000   NOP
1817:                	{
1818:                		curHTTP.callbackPos = 0x01;
9D017128  3C02A000   LUI V0, -24576
9D01712C  24420574   ADDIU V0, V0, 1396
9D017130  24030001   ADDIU V1, ZERO, 1
9D017134  AC43000C   SW V1, 12(V0)
1819:                		return;
9D017138  0B405C61   J 0x9D017184
9D01713C  00000000   NOP
1820:                	}
1821:                
1822:                	#if defined(STACK_USE_DYNAMICDNS_CLIENT)
1823:                	switch(DDNSGetLastStatus())
1824:                	{
1825:                		case DDNS_STATUS_GOOD:
1826:                		case DDNS_STATUS_NOCHG:
1827:                			TCPPutROMString(sktHTTP, (ROM BYTE*)"The last update was successful.");
1828:                			break;
1829:                		case DDNS_STATUS_UNCHANGED:
1830:                			TCPPutROMString(sktHTTP, (ROM BYTE*)"The IP has not changed since the last update.");
1831:                			break;
1832:                		case DDNS_STATUS_UPDATE_ERROR:
1833:                		case DDNS_STATUS_CHECKIP_ERROR:
1834:                			TCPPutROMString(sktHTTP, (ROM BYTE*)"Could not communicate with DDNS server.");
1835:                			break;
1836:                		case DDNS_STATUS_INVALID:
1837:                			TCPPutROMString(sktHTTP, (ROM BYTE*)"The current configuration is not valid.");
1838:                			break;
1839:                		case DDNS_STATUS_UNKNOWN:
1840:                			TCPPutROMString(sktHTTP, (ROM BYTE*)"The Dynamic DNS client is pending an update.");
1841:                			break;
1842:                		default:
1843:                			TCPPutROMString(sktHTTP, (ROM BYTE*)"An error occurred during the update.<br />The DDNS Client is suspended.");
1844:                			break;
1845:                	}
1846:                	#else
1847:                	TCPPutROMString(sktHTTP, (ROM BYTE*)"The Dynamic DNS Client is not enabled.");
9D017140  938281E8   LBU V0, -32280(GP)
9D017144  00401821   ADDU V1, V0, ZERO
9D017148  3C02A000   LUI V0, -24576
9D01714C  000318C0   SLL V1, V1, 3
9D017150  24420600   ADDIU V0, V0, 1536
9D017154  00621021   ADDU V0, V1, V0
9D017158  90420004   LBU V0, 4(V0)
9D01715C  00401821   ADDU V1, V0, ZERO
9D017160  3C029D03   LUI V0, -25341
9D017164  244235C8   ADDIU V0, V0, 13768
9D017168  00602021   ADDU A0, V1, ZERO
9D01716C  00402821   ADDU A1, V0, ZERO
9D017170  0F4005FD   JAL TCPPutString
9D017174  00000000   NOP
1848:                	#endif
1849:                	
1850:                	curHTTP.callbackPos = 0x00;
9D017178  3C02A000   LUI V0, -24576
9D01717C  24420574   ADDIU V0, V0, 1396
9D017180  AC40000C   SW ZERO, 12(V0)
1851:                }
9D017184  03C0E821   ADDU SP, S8, ZERO
9D017188  8FBF0014   LW RA, 20(SP)
9D01718C  8FBE0010   LW S8, 16(SP)
9D017190  27BD0018   ADDIU SP, SP, 24
9D017194  03E00008   JR RA
9D017198  00000000   NOP
1852:                
1853:                void HTTPPrint_smtps_en(void)
1854:                {
9D01719C  27BDFFE8   ADDIU SP, SP, -24
9D0171A0  AFBF0014   SW RA, 20(SP)
9D0171A4  AFBE0010   SW S8, 16(SP)
9D0171A8  03A0F021   ADDU S8, SP, ZERO
1855:                	#if defined(STACK_USE_SSL_CLIENT)
1856:                		TCPPutROMString(sktHTTP, (ROM BYTE*)"inline");
1857:                	#else
1858:                		TCPPutROMString(sktHTTP, (ROM BYTE*)"none");
9D0171AC  938281E8   LBU V0, -32280(GP)
9D0171B0  00401821   ADDU V1, V0, ZERO
9D0171B4  3C02A000   LUI V0, -24576
9D0171B8  000318C0   SLL V1, V1, 3
9D0171BC  24420600   ADDIU V0, V0, 1536
9D0171C0  00621021   ADDU V0, V1, V0
9D0171C4  90420004   LBU V0, 4(V0)
9D0171C8  00401821   ADDU V1, V0, ZERO
9D0171CC  3C029D03   LUI V0, -25341
9D0171D0  244235F0   ADDIU V0, V0, 13808
9D0171D4  00602021   ADDU A0, V1, ZERO
9D0171D8  00402821   ADDU A1, V0, ZERO
9D0171DC  0F4005FD   JAL TCPPutString
9D0171E0  00000000   NOP
1859:                	#endif
1860:                }
9D0171E4  03C0E821   ADDU SP, S8, ZERO
9D0171E8  8FBF0014   LW RA, 20(SP)
9D0171EC  8FBE0010   LW S8, 16(SP)
9D0171F0  27BD0018   ADDIU SP, SP, 24
9D0171F4  03E00008   JR RA
9D0171F8  00000000   NOP
1861:                
1862:                void HTTPPrint_snmp_en(void)
1863:                {
9D0171FC  27BDFFE8   ADDIU SP, SP, -24
9D017200  AFBF0014   SW RA, 20(SP)
9D017204  AFBE0010   SW S8, 16(SP)
9D017208  03A0F021   ADDU S8, SP, ZERO
1864:                	#if defined(STACK_USE_SNMP_SERVER)
1865:                		TCPPutROMString(sktHTTP, (ROM BYTE*)"none");
1866:                	#else
1867:                		TCPPutROMString(sktHTTP, (ROM BYTE*)"block");
9D01720C  938281E8   LBU V0, -32280(GP)
9D017210  00401821   ADDU V1, V0, ZERO
9D017214  3C02A000   LUI V0, -24576
9D017218  000318C0   SLL V1, V1, 3
9D01721C  24420600   ADDIU V0, V0, 1536
9D017220  00621021   ADDU V0, V1, V0
9D017224  90420004   LBU V0, 4(V0)
9D017228  00401821   ADDU V1, V0, ZERO
9D01722C  3C029D03   LUI V0, -25341
9D017230  244235F8   ADDIU V0, V0, 13816
9D017234  00602021   ADDU A0, V1, ZERO
9D017238  00402821   ADDU A1, V0, ZERO
9D01723C  0F4005FD   JAL TCPPutString
9D017240  00000000   NOP
1868:                	#endif
1869:                }
9D017244  03C0E821   ADDU SP, S8, ZERO
9D017248  8FBF0014   LW RA, 20(SP)
9D01724C  8FBE0010   LW S8, 16(SP)
9D017250  27BD0018   ADDIU SP, SP, 24
9D017254  03E00008   JR RA
9D017258  00000000   NOP
1870:                
1871:                void HTTPPrint_status_ok(void)
1872:                {
9D01725C  27BDFFE8   ADDIU SP, SP, -24
9D017260  AFBF0014   SW RA, 20(SP)
9D017264  AFBE0010   SW S8, 16(SP)
9D017268  03A0F021   ADDU S8, SP, ZERO
1873:                	if(lastSuccess)
9D01726C  8F8281BC   LW V0, -32324(GP)
9D017270  10400011   BEQ V0, ZERO, 0x9D0172B8
9D017274  00000000   NOP
1874:                		TCPPutROMString(sktHTTP, (ROM BYTE*)"block");
9D017278  938281E8   LBU V0, -32280(GP)
9D01727C  00401821   ADDU V1, V0, ZERO
9D017280  3C02A000   LUI V0, -24576
9D017284  000318C0   SLL V1, V1, 3
9D017288  24420600   ADDIU V0, V0, 1536
9D01728C  00621021   ADDU V0, V1, V0
9D017290  90420004   LBU V0, 4(V0)
9D017294  00401821   ADDU V1, V0, ZERO
9D017298  3C029D03   LUI V0, -25341
9D01729C  244235F8   ADDIU V0, V0, 13816
9D0172A0  00602021   ADDU A0, V1, ZERO
9D0172A4  00402821   ADDU A1, V0, ZERO
9D0172A8  0F4005FD   JAL TCPPutString
9D0172AC  00000000   NOP
9D0172B0  0B405CBC   J 0x9D0172F0
9D0172B4  00000000   NOP
1875:                	else
1876:                		TCPPutROMString(sktHTTP, (ROM BYTE*)"none");
9D0172B8  938281E8   LBU V0, -32280(GP)
9D0172BC  00401821   ADDU V1, V0, ZERO
9D0172C0  3C02A000   LUI V0, -24576
9D0172C4  000318C0   SLL V1, V1, 3
9D0172C8  24420600   ADDIU V0, V0, 1536
9D0172CC  00621021   ADDU V0, V1, V0
9D0172D0  90420004   LBU V0, 4(V0)
9D0172D4  00401821   ADDU V1, V0, ZERO
9D0172D8  3C029D03   LUI V0, -25341
9D0172DC  244235F0   ADDIU V0, V0, 13808
9D0172E0  00602021   ADDU A0, V1, ZERO
9D0172E4  00402821   ADDU A1, V0, ZERO
9D0172E8  0F4005FD   JAL TCPPutString
9D0172EC  00000000   NOP
1877:                	lastSuccess = FALSE;
9D0172F0  AF8081BC   SW ZERO, -32324(GP)
1878:                }
9D0172F4  03C0E821   ADDU SP, S8, ZERO
9D0172F8  8FBF0014   LW RA, 20(SP)
9D0172FC  8FBE0010   LW S8, 16(SP)
9D017300  27BD0018   ADDIU SP, SP, 24
9D017304  03E00008   JR RA
9D017308  00000000   NOP
1879:                
1880:                void HTTPPrint_status_fail(void)
1881:                {
9D01730C  27BDFFE8   ADDIU SP, SP, -24
9D017310  AFBF0014   SW RA, 20(SP)
9D017314  AFBE0010   SW S8, 16(SP)
9D017318  03A0F021   ADDU S8, SP, ZERO
1882:                	if(lastFailure)
9D01731C  8F8281C0   LW V0, -32320(GP)
9D017320  10400011   BEQ V0, ZERO, 0x9D017368
9D017324  00000000   NOP
1883:                		TCPPutROMString(sktHTTP, (ROM BYTE*)"block");
9D017328  938281E8   LBU V0, -32280(GP)
9D01732C  00401821   ADDU V1, V0, ZERO
9D017330  3C02A000   LUI V0, -24576
9D017334  000318C0   SLL V1, V1, 3
9D017338  24420600   ADDIU V0, V0, 1536
9D01733C  00621021   ADDU V0, V1, V0
9D017340  90420004   LBU V0, 4(V0)
9D017344  00401821   ADDU V1, V0, ZERO
9D017348  3C029D03   LUI V0, -25341
9D01734C  244235F8   ADDIU V0, V0, 13816
9D017350  00602021   ADDU A0, V1, ZERO
9D017354  00402821   ADDU A1, V0, ZERO
9D017358  0F4005FD   JAL TCPPutString
9D01735C  00000000   NOP
9D017360  0B405CE8   J 0x9D0173A0
9D017364  00000000   NOP
1884:                	else
1885:                		TCPPutROMString(sktHTTP, (ROM BYTE*)"none");
9D017368  938281E8   LBU V0, -32280(GP)
9D01736C  00401821   ADDU V1, V0, ZERO
9D017370  3C02A000   LUI V0, -24576
9D017374  000318C0   SLL V1, V1, 3
9D017378  24420600   ADDIU V0, V0, 1536
9D01737C  00621021   ADDU V0, V1, V0
9D017380  90420004   LBU V0, 4(V0)
9D017384  00401821   ADDU V1, V0, ZERO
9D017388  3C029D03   LUI V0, -25341
9D01738C  244235F0   ADDIU V0, V0, 13808
9D017390  00602021   ADDU A0, V1, ZERO
9D017394  00402821   ADDU A1, V0, ZERO
9D017398  0F4005FD   JAL TCPPutString
9D01739C  00000000   NOP
1886:                	lastFailure = FALSE;
9D0173A0  AF8081C0   SW ZERO, -32320(GP)
1887:                }
9D0173A4  03C0E821   ADDU SP, S8, ZERO
9D0173A8  8FBF0014   LW RA, 20(SP)
9D0173AC  8FBE0010   LW S8, 16(SP)
9D0173B0  27BD0018   ADDIU SP, SP, 24
9D0173B4  03E00008   JR RA
9D0173B8  00000000   NOP
1888:                
1889:                #endif
---  C:/Users/Diego/Documents/GitHub/pic32webFREERtos/Pic32Web.X/src/BerkeleyTCPServerDemo.c  -----------
1:                   /*********************************************************************
2:                    *
3:                    *  Berekely TCP server demo application.
4:                    *  This application uses the BSD socket APIs and starts a server 
5:                    *  listening on TCP port 9764.  All data sent to a connection on 
6:                    *  this port will be echoed back to the sender.  By default, this 
7:                    *  demo supports 3 simultaneous connections.
8:                    *
9:                    *********************************************************************
10:                   * FileName:        BerkeleyTCPServerDemo.c
11:                   * Company:         Microchip Technology, Inc.
12:                   * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32
13:                   * Compiler:        Microchip C32 v1.05 or higher
14:                   *					Microchip C30 v3.12 or higher
15:                   *					Microchip C18 v3.30 or higher
16:                   *					HI-TECH PICC-18 PRO 9.63PL2 or higher
17:                   * Company:         Microchip Technology, Inc.
18:                   *
19:                   * Software License Agreement
20:                   *
21:                   * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights
22:                   * reserved.
23:                   *
24:                   * Microchip licenses to you the right to use, modify, copy, and
25:                   * distribute:
26:                   * (i)  the Software when embedded on a Microchip microcontroller or
27:                   *      digital signal controller product ("Device") which is
28:                   *      integrated into Licensee's product; or
29:                   * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h,
30:                   *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device
31:                   *		used in conjunction with a Microchip ethernet controller for
32:                   *		the sole purpose of interfacing with the ethernet controller.
33:                   *
34:                   * You should refer to the license agreement accompanying this
35:                   * Software for additional information regarding your rights and
36:                   * obligations.
37:                   *
38:                   * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT
39:                   * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT
40:                   * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A
41:                   * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL
42:                   * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR
43:                   * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF
44:                   * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS
45:                   * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE
46:                   * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER
47:                   * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT
48:                   * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE.
49:                   *
50:                   * Author               Date    	Comment
51:                   *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
52:                   * Aseem Swalah         4/21/08  	Original
53:                   ********************************************************************/
54:                   
55:                  #include "TCPIPConfig.h" 
56:                  
57:                  #if defined(STACK_USE_BERKELEY_API)
58:                  
59:                  #include "TCPIP Stack/TCPIP.h"
60:                  
61:                  
62:                  #define PORTNUM 9764
63:                  #define MAX_CLIENT (3) // Maximum number of simultanous connections accepted by the server.
64:                  
65:                  
66:                  /*********************************************************************
67:                   * Function:        void BerkeleyTCPServerDemo(void)
68:                   *
69:                   * PreCondition:    Stack is initialized
70:                   *
71:                   * Input:           None
72:                   *
73:                   * Output:          None
74:                   *
75:                   * Side Effects:    None
76:                   *
77:                   * Overview:        None
78:                   *
79:                   * Note:            None
80:                   ********************************************************************/
81:                  void BerkeleyTCPServerDemo(void)
82:                  {
9D033FC0  27BDFFA0   ADDIU SP, SP, -96
9D033FC4  AFBF005C   SW RA, 92(SP)
9D033FC8  AFBE0058   SW S8, 88(SP)
9D033FCC  AFB00054   SW S0, 84(SP)
9D033FD0  03A0F021   ADDU S8, SP, ZERO
83:                      static SOCKET bsdServerSocket;   
84:                      static SOCKET ClientSock[MAX_CLIENT];
85:                      struct sockaddr_in addr;
86:                      struct sockaddr_in addRemote;
87:                      int addrlen = sizeof(struct sockaddr_in);
9D033FD4  24020010   ADDIU V0, ZERO, 16
9D033FD8  AFC20038   SW V0, 56(S8)
88:                      char bfr[15];
89:                      int length;
90:                      int i;
91:                      static enum
92:                      {
93:                  	    BSD_INIT = 0,
94:                          BSD_CREATE_SOCKET,
95:                          BSD_BIND,
96:                          BSD_LISTEN,
97:                          BSD_OPERATION
98:                      } BSDServerState = BSD_INIT;
99:                  
100:                     switch(BSDServerState)
9D033FDC  8F8281CC   LW V0, -32308(GP)
9D033FE0  2C430005   SLTIU V1, V0, 5
9D033FE4  106000A3   BEQ V1, ZERO, 0x9D034274
9D033FE8  00000000   NOP
9D033FEC  00021880   SLL V1, V0, 2
9D033FF0  3C029D03   LUI V0, -25341
9D033FF4  24424008   ADDIU V0, V0, 16392
9D033FF8  00621021   ADDU V0, V1, V0
9D033FFC  8C420000   LW V0, 0(V0)
9D034000  00400008   JR V0
9D034004  00000000   NOP
101:                     {
102:                 	    case BSD_INIT:
103:                         	// Initialize all client socket handles so that we don't process 
104:                         	// them in the BSD_OPERATION state
105:                         	for(i = 0; i < MAX_CLIENT; i++)
9D03401C  AFC00010   SW ZERO, 16(S8)
9D034020  0B40D012   J 0x9D034048
9D034024  00000000   NOP
9D03403C  8FC20010   LW V0, 16(S8)
9D034040  24420001   ADDIU V0, V0, 1
9D034044  AFC20010   SW V0, 16(S8)
9D034048  8FC20010   LW V0, 16(S8)
9D03404C  28420003   SLTI V0, V0, 3
9D034050  1440FFF5   BNE V0, ZERO, 0x9D034028
9D034054  00000000   NOP
106:                         		ClientSock[i] = INVALID_SOCKET;
9D034028  8FC30010   LW V1, 16(S8)
9D03402C  278281D0   ADDIU V0, GP, -32304
9D034030  00621021   ADDU V0, V1, V0
9D034034  2403FFFE   ADDIU V1, ZERO, -2
9D034038  A0430000   SB V1, 0(V0)
107:                         		
108:                         	BSDServerState = BSD_CREATE_SOCKET;
9D034058  24020001   ADDIU V0, ZERO, 1
9D03405C  AF8281CC   SW V0, -32308(GP)
109:                         	// No break needed
110:                 	    
111:                         case BSD_CREATE_SOCKET:
112:                             // Create a socket for this server to listen and accept connections on
113:                             bsdServerSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
9D034060  24040002   ADDIU A0, ZERO, 2
9D034064  24050064   ADDIU A1, ZERO, 100
9D034068  24060006   ADDIU A2, ZERO, 6
9D03406C  0F4089F3   JAL socket
9D034070  00000000   NOP
9D034074  A38281D3   SB V0, -32301(GP)
114:                             if(bsdServerSocket == INVALID_SOCKET)
9D034078  938381D3   LBU V1, -32301(GP)
9D03407C  240200FE   ADDIU V0, ZERO, 254
9D034080  1062007F   BEQ V1, V0, 0x9D034280
9D034084  00000000   NOP
115:                                 return;
9D034280  00000000   NOP
9D034284  0B40D0A4   J 0x9D034290
9D034288  00000000   NOP
116:                             
117:                             BSDServerState = BSD_BIND;
9D034088  24020002   ADDIU V0, ZERO, 2
9D03408C  AF8281CC   SW V0, -32308(GP)
118:                             // No break needed
119:                 
120:                         case BSD_BIND:
121:                             // Bind socket to a local port
122:                             addr.sin_port = PORTNUM;
9D034090  24022624   ADDIU V0, ZERO, 9764
9D034094  A7C2001A   SH V0, 26(S8)
123:                             addr.sin_addr.S_un.S_addr = IP_ADDR_ANY;
9D034098  AFC0001C   SW ZERO, 28(S8)
124:                             if( bind( bsdServerSocket, (struct sockaddr*)&addr, addrlen ) == SOCKET_ERROR )
9D03409C  938281D3   LBU V0, -32301(GP)
9D0340A0  00402021   ADDU A0, V0, ZERO
9D0340A4  27C30018   ADDIU V1, S8, 24
9D0340A8  8FC20038   LW V0, 56(S8)
9D0340AC  00602821   ADDU A1, V1, ZERO
9D0340B0  00403021   ADDU A2, V0, ZERO
9D0340B4  0F408A51   JAL bind
9D0340B8  00000000   NOP
9D0340BC  00401821   ADDU V1, V0, ZERO
9D0340C0  2402FFFF   ADDIU V0, ZERO, -1
9D0340C4  10620071   BEQ V1, V0, 0x9D03428C
9D0340C8  00000000   NOP
125:                                 return;
9D03428C  00000000   NOP
126:                             
127:                             BSDServerState = BSD_LISTEN;
9D0340CC  24020003   ADDIU V0, ZERO, 3
9D0340D0  AF8281CC   SW V0, -32308(GP)
128:                             // No break needed
129:                          
130:                       case BSD_LISTEN:
131:                             if(listen(bsdServerSocket, MAX_CLIENT) == 0)
9D0340D4  938281D3   LBU V0, -32301(GP)
9D0340D8  00402021   ADDU A0, V0, ZERO
9D0340DC  24050003   ADDIU A1, ZERO, 3
9D0340E0  0F408AB0   JAL listen
9D0340E4  00000000   NOP
9D0340E8  14400003   BNE V0, ZERO, 0x9D0340F8
9D0340EC  00000000   NOP
132:                 	            BSDServerState = BSD_OPERATION;
9D0340F0  24020004   ADDIU V0, ZERO, 4
9D0340F4  AF8281CC   SW V0, -32308(GP)
133:                 
134:                 			// No break.  If listen() returns SOCKET_ERROR it could be because 
135:                 			// MAX_CLIENT is set to too large of a backlog than can be handled 
136:                 			// by the underlying TCP socket count (TCP_PURPOSE_BERKELEY_SERVER 
137:                 			// type sockets in TCPIPConfig.h).  However, in this case, it is 
138:                 			// possible that some of the backlog is still handleable, in which 
139:                 			// case we should try to accept() connections anyway and proceed 
140:                 			// with normal operation.
141:                          
142:                       case BSD_OPERATION:
143:                             for(i=0; i<MAX_CLIENT; i++)
9D0340F8  AFC00010   SW ZERO, 16(S8)
9D0340FC  0B40D097   J 0x9D03425C
9D034100  00000000   NOP
9D034250  8FC20010   LW V0, 16(S8)
9D034254  24420001   ADDIU V0, V0, 1
9D034258  AFC20010   SW V0, 16(S8)
9D03425C  8FC20010   LW V0, 16(S8)
9D034260  28420003   SLTI V0, V0, 3
9D034264  1440FFA7   BNE V0, ZERO, 0x9D034104
9D034268  00000000   NOP
144:                             {
145:                 	            // Accept any pending connection requests, assuming we have a place to store the socket descriptor
146:                                 if(ClientSock[i] == INVALID_SOCKET)
9D034104  8FC30010   LW V1, 16(S8)
9D034108  278281D0   ADDIU V0, GP, -32304
9D03410C  00621021   ADDU V0, V1, V0
9D034110  90430000   LBU V1, 0(V0)
9D034114  240200FE   ADDIU V0, ZERO, 254
9D034118  1462000E   BNE V1, V0, 0x9D034154
9D03411C  00000000   NOP
147:                                     ClientSock[i] = accept(bsdServerSocket, (struct sockaddr*)&addRemote, &addrlen);
9D034120  938281D3   LBU V0, -32301(GP)
9D034124  00402021   ADDU A0, V0, ZERO
9D034128  27C30028   ADDIU V1, S8, 40
9D03412C  27C20038   ADDIU V0, S8, 56
9D034130  00602821   ADDU A1, V1, ZERO
9D034134  00403021   ADDU A2, V0, ZERO
9D034138  0F408B58   JAL accept
9D03413C  00000000   NOP
9D034140  00401821   ADDU V1, V0, ZERO
9D034144  8FC40010   LW A0, 16(S8)
9D034148  278281D0   ADDIU V0, GP, -32304
9D03414C  00821021   ADDU V0, A0, V0
9D034150  A0430000   SB V1, 0(V0)
148:                                 
149:                                 // If this socket is not connected then no need to process anything
150:                                 if(ClientSock[i] == INVALID_SOCKET)
9D034154  8FC30010   LW V1, 16(S8)
9D034158  278281D0   ADDIU V0, GP, -32304
9D03415C  00621021   ADDU V0, V1, V0
9D034160  90430000   LBU V1, 0(V0)
9D034164  240200FE   ADDIU V0, ZERO, 254
9D034168  10620038   BEQ V1, V0, 0x9D03424C
9D03416C  00000000   NOP
151:                                 	continue;
9D03424C  00000000   NOP
152:                 
153:                 	            // For all connected sockets, receive and send back the data
154:                                 length = recv( ClientSock[i], bfr, sizeof(bfr), 0);
9D034170  8FC30010   LW V1, 16(S8)
9D034174  278281D0   ADDIU V0, GP, -32304
9D034178  00621021   ADDU V0, V1, V0
9D03417C  90420000   LBU V0, 0(V0)
9D034180  00401821   ADDU V1, V0, ZERO
9D034184  27C2003C   ADDIU V0, S8, 60
9D034188  00602021   ADDU A0, V1, ZERO
9D03418C  00402821   ADDU A1, V0, ZERO
9D034190  2406000F   ADDIU A2, ZERO, 15
9D034194  00003821   ADDU A3, ZERO, ZERO
9D034198  0F408DD1   JAL recv
9D03419C  00000000   NOP
9D0341A0  AFC20014   SW V0, 20(S8)
155:                          
156:                                 if( length > 0 )
9D0341A4  8FC20014   LW V0, 20(S8)
9D0341A8  18400017   BLEZ V0, 0x9D034208
9D0341AC  00000000   NOP
157:                                 {
158:                                     bfr[length] = '\0';
9D0341B0  8FC20014   LW V0, 20(S8)
9D0341B4  27C30010   ADDIU V1, S8, 16
9D0341B8  00621021   ADDU V0, V1, V0
9D0341BC  A040002C   SB ZERO, 44(V0)
159:                                     send(ClientSock[i], bfr, strlen(bfr), 0);
9D0341C0  8FC30010   LW V1, 16(S8)
9D0341C4  278281D0   ADDIU V0, GP, -32304
9D0341C8  00621021   ADDU V0, V1, V0
9D0341CC  90420000   LBU V0, 0(V0)
9D0341D0  00408021   ADDU S0, V0, ZERO
9D0341D4  27C2003C   ADDIU V0, S8, 60
9D0341D8  00402021   ADDU A0, V0, ZERO
9D0341DC  0F40D2F2   JAL 0x9D034BC8
9D0341E0  00000000   NOP
9D0341E4  27C3003C   ADDIU V1, S8, 60
9D0341E8  02002021   ADDU A0, S0, ZERO
9D0341EC  00602821   ADDU A1, V1, ZERO
9D0341F0  00403021   ADDU A2, V0, ZERO
9D0341F4  00003821   ADDU A3, ZERO, ZERO
9D0341F8  0F408CCF   JAL send
9D0341FC  00000000   NOP
9D034200  0B40D094   J 0x9D034250
9D034204  00000000   NOP
160:                                 }
161:                                 else if( length < 0 )
9D034208  8FC20014   LW V0, 20(S8)
9D03420C  04410010   BGEZ V0, 0x9D034250
9D034210  00000000   NOP
162:                                 {
163:                                     closesocket( ClientSock[i] );
9D034214  8FC30010   LW V1, 16(S8)
9D034218  278281D0   ADDIU V0, GP, -32304
9D03421C  00621021   ADDU V0, V1, V0
9D034220  90420000   LBU V0, 0(V0)
9D034224  00402021   ADDU A0, V0, ZERO
9D034228  0F408F01   JAL closesocket
9D03422C  00000000   NOP
164:                                     ClientSock[i] = INVALID_SOCKET;
9D034230  8FC30010   LW V1, 16(S8)
9D034234  278281D0   ADDIU V0, GP, -32304
9D034238  00621021   ADDU V0, V1, V0
9D03423C  2403FFFE   ADDIU V1, ZERO, -2
9D034240  A0430000   SB V1, 0(V0)
9D034244  0B40D094   J 0x9D034250
9D034248  00000000   NOP
165:                                 }
166:                             }
167:                             break;
168:                          
169:                         default:
170:                             return;
9D034274  00000000   NOP
9D034278  0B40D0A4   J 0x9D034290
9D03427C  00000000   NOP
171:                     }
172:                     return;
9D03426C  0B40D0A4   J 0x9D034290
9D034270  00000000   NOP
173:                 }
9D034290  03C0E821   ADDU SP, S8, ZERO
9D034294  8FBF005C   LW RA, 92(SP)
9D034298  8FBE0058   LW S8, 88(SP)
9D03429C  8FB00054   LW S0, 84(SP)
9D0342A0  27BD0060   ADDIU SP, SP, 96
9D0342A4  03E00008   JR RA
9D0342A8  00000000   NOP
174:                 
175:                 #endif //#if defined(STACK_USE_BERKELEY_API)
176:                 
---  /Volumes/home/c11067/xc32/build/gcc/libgcc2.c  -----------------------------------------------------
9D03221C  00C01021   ADDU V0, A2, ZERO
9D032220  00804021   ADDU T0, A0, ZERO
9D032224  14E0003D   BNE A3, ZERO, 0x9D03231C
9D032228  00A01821   ADDU V1, A1, ZERO
9D03222C  00A6302B   SLTU A2, A1, A2
9D032230  10C00046   BEQ A2, ZERO, 0x9D03234C
9D032234  00000000   NOP
9D032238  70442020   CLZ A0, V0
9D03223C  10800008   BEQ A0, ZERO, 0x9D032260
9D032240  00022C02   SRL A1, V0, 16
9D032250  00821004   SLLV V0, V0, A0
9D032244  00042823   SUBU A1, ZERO, A0
9D032248  00A82806   SRLV A1, T0, A1
9D03224C  00831804   SLLV V1, V1, A0
9D032254  00A31825   OR V1, A1, V1
9D032258  00884004   SLLV T0, T0, A0
9D03225C  00022C02   SRL A1, V0, 16
9D032260  0065001B   DIVU V1, A1
9D032264  00A001F4   TEQ A1, ZERO
9D032268  304AFFFF   ANDI T2, V0, -1
9D03226C  00085C02   SRL T3, T0, 16
9D032270  00004812   MFLO T1, 0
9D032274  00003810   MFHI A3, 0
9D032278  00073C00   SLL A3, A3, 16
9D03227C  00EB3825   OR A3, A3, T3
9D032280  712A2002   MUL A0, T1, T2
9D032284  00E4302B   SLTU A2, A3, A0
9D032288  0065001B   DIVU V1, A1
9D03228C  00A001F4   TEQ A1, ZERO
9D032290  10C0000B   BEQ A2, ZERO, 0x9D0322C0
9D032294  00E41823   SUBU V1, A3, A0
9D032298  00E23821   ADDU A3, A3, V0
9D03229C  00E2182B   SLTU V1, A3, V0
9D0322A0  14600006   BNE V1, ZERO, 0x9D0322BC
9D0322A4  2529FFFF   ADDIU T1, T1, -1
9D0322A8  00E4182B   SLTU V1, A3, A0
9D0322AC  10600004   BEQ V1, ZERO, 0x9D0322C0
9D0322B0  00E41823   SUBU V1, A3, A0
9D0322B4  2529FFFF   ADDIU T1, T1, -1
9D0322B8  00E23821   ADDU A3, A3, V0
9D0322BC  00E41823   SUBU V1, A3, A0
9D0322C0  0065001B   DIVU V1, A1
9D0322C4  00A001F4   TEQ A1, ZERO
9D0322C8  3108FFFF   ANDI T0, T0, -1
9D0322CC  00002012   MFLO A0, 0
9D0322D0  00003010   MFHI A2, 0
9D0322D4  00063400   SLL A2, A2, 16
9D0322D8  00C84025   OR T0, A2, T0
9D0322DC  708A5002   MUL T2, A0, T2
9D0322E0  010A302B   SLTU A2, T0, T2
9D0322E4  0065001B   DIVU V1, A1
9D0322E8  00A001F4   TEQ A1, ZERO
9D0322EC  10C00006   BEQ A2, ZERO, 0x9D032308
9D0322F0  01024021   ADDU T0, T0, V0
9D0322F4  0102102B   SLTU V0, T0, V0
9D0322F8  14400003   BNE V0, ZERO, 0x9D032308
9D0322FC  2484FFFF   ADDIU A0, A0, -1
9D032300  010A502B   SLTU T2, T0, T2
9D032304  008A2023   SUBU A0, A0, T2
9D032308  00094C00   SLL T1, T1, 16
9D03230C  00892025   OR A0, A0, T1
9D032310  00001821   ADDU V1, ZERO, ZERO
9D03234C  14400006   BNE V0, ZERO, 0x9D032368
9D032350  70463020   CLZ A2, V0
9D032354  24030001   ADDIU V1, ZERO, 1
9D032358  0062001B   DIVU V1, V0
9D03235C  004001F4   TEQ V0, ZERO
9D032360  00001012   MFLO V0, 0
9D032364  70463020   CLZ A2, V0
9D032368  54C00077   BNEL A2, ZERO, 0x9D032548
9D03236C  24080020   ADDIU T0, ZERO, 32
9D032370  00A24823   SUBU T1, A1, V0
9D032374  00023C02   SRL A3, V0, 16
9D032378  304CFFFF   ANDI T4, V0, -1
9D03237C  24030001   ADDIU V1, ZERO, 1
9D03254C  01064023   SUBU T0, T0, A2
9D032548  00C21004   SLLV V0, V0, A2
9D032550  01055006   SRLV T2, A1, T0
9D032560  01044006   SRLV T0, A0, T0
9D032564  00C52804   SLLV A1, A1, A2
9D03256C  01052825   OR A1, T0, A1
9D032570  00C44004   SLLV T0, A0, A2
9D032554  00023C02   SRL A3, V0, 16
9D032558  0147001B   DIVU T2, A3
9D03255C  00E001F4   TEQ A3, ZERO
9D032568  304CFFFF   ANDI T4, V0, -1
9D032574  00054C02   SRL T1, A1, 16
9D032578  00001812   MFLO V1, 0
9D03257C  00005810   MFHI T3, 0
9D032580  000B2400   SLL A0, T3, 16
9D032584  01242025   OR A0, T1, A0
9D032588  00003012   MFLO A2, 0
9D03258C  706C1802   MUL V1, V1, T4
9D032590  0083482B   SLTU T1, A0, V1
9D032594  0147001B   DIVU T2, A3
9D032598  00E001F4   TEQ A3, ZERO
9D03259C  5120000B   BEQL T1, ZERO, 0x9D0325CC
9D0325A0  00832023   SUBU A0, A0, V1
9D0325A4  00822021   ADDU A0, A0, V0
9D0325A8  0082482B   SLTU T1, A0, V0
9D0325AC  15200006   BNE T1, ZERO, 0x9D0325C8
9D0325B0  24C6FFFF   ADDIU A2, A2, -1
9D0325B4  0083482B   SLTU T1, A0, V1
9D0325B8  51200004   BEQL T1, ZERO, 0x9D0325CC
9D0325BC  00832023   SUBU A0, A0, V1
9D0325C0  24C6FFFF   ADDIU A2, A2, -1
9D0325C4  00822021   ADDU A0, A0, V0
9D0325C8  00832023   SUBU A0, A0, V1
9D0325CC  0087001B   DIVU A0, A3
9D0325D0  00E001F4   TEQ A3, ZERO
9D0325D4  30AAFFFF   ANDI T2, A1, -1
9D0325D8  00001812   MFLO V1, 0
9D0325DC  00004810   MFHI T1, 0
9D0325E0  00094C00   SLL T1, T1, 16
9D0325E4  012A4825   OR T1, T1, T2
9D0325E8  706C2802   MUL A1, V1, T4
9D0325EC  0125502B   SLTU T2, T1, A1
9D0325F0  0087001B   DIVU A0, A3
9D0325F4  00E001F4   TEQ A3, ZERO
9D0325F8  5140000B   BEQL T2, ZERO, 0x9D032628
9D0325FC  00063400   SLL A2, A2, 16
9D032600  01224821   ADDU T1, T1, V0
9D032604  0122202B   SLTU A0, T1, V0
9D032608  14800006   BNE A0, ZERO, 0x9D032624
9D03260C  2463FFFF   ADDIU V1, V1, -1
9D032610  0125202B   SLTU A0, T1, A1
9D032614  50800004   BEQL A0, ZERO, 0x9D032628
9D032618  00063400   SLL A2, A2, 16
9D03261C  2463FFFF   ADDIU V1, V1, -1
9D032620  01224821   ADDU T1, T1, V0
9D032624  00063400   SLL A2, A2, 16
9D032628  01254823   SUBU T1, T1, A1
9D03262C  0B40C8E0   J 0x9D032380
9D032630  00661825   OR V1, V1, A2
9D032380  0127001B   DIVU T1, A3
9D032384  00E001F4   TEQ A3, ZERO
9D032388  00086C02   SRL T5, T0, 16
9D03238C  00005812   MFLO T3, 0
9D032390  00005010   MFHI T2, 0
9D032394  000A5400   SLL T2, T2, 16
9D032398  014D5025   OR T2, T2, T5
9D03239C  716C2002   MUL A0, T3, T4
9D0323A0  0144302B   SLTU A2, T2, A0
9D0323A4  0127001B   DIVU T1, A3
9D0323A8  00E001F4   TEQ A3, ZERO
9D0323AC  10C00009   BEQ A2, ZERO, 0x9D0323D4
9D0323B0  01442823   SUBU A1, T2, A0
9D0323B4  01425021   ADDU T2, T2, V0
9D0323B8  0142282B   SLTU A1, T2, V0
9D0323BC  14A00004   BNE A1, ZERO, 0x9D0323D0
9D0323C0  256BFFFF   ADDIU T3, T3, -1
9D0323C4  0144282B   SLTU A1, T2, A0
9D0323C8  54A000A2   BNEL A1, ZERO, 0x9D032654
9D0323CC  256BFFFF   ADDIU T3, T3, -1
9D0323D0  01442823   SUBU A1, T2, A0
9D0323D4  00A7001B   DIVU A1, A3
9D0323D8  00E001F4   TEQ A3, ZERO
9D0323DC  3108FFFF   ANDI T0, T0, -1
9D0323E0  00002012   MFLO A0, 0
9D0323E4  00003010   MFHI A2, 0
9D0323E8  00063400   SLL A2, A2, 16
9D0323EC  00C84025   OR T0, A2, T0
9D0323F0  708C6002   MUL T4, A0, T4
9D0323F4  010C302B   SLTU A2, T0, T4
9D0323F8  00A7001B   DIVU A1, A3
9D0323FC  00E001F4   TEQ A3, ZERO
9D032400  10C00006   BEQ A2, ZERO, 0x9D03241C
9D032404  01024021   ADDU T0, T0, V0
9D032408  0102102B   SLTU V0, T0, V0
9D03240C  14400003   BNE V0, ZERO, 0x9D03241C
9D032410  2484FFFF   ADDIU A0, A0, -1
9D032414  010C602B   SLTU T4, T0, T4
9D032418  008C2023   SUBU A0, A0, T4
9D03241C  000B5C00   SLL T3, T3, 16
9D032420  008B2025   OR A0, A0, T3
9D032654  0B40C8F4   J 0x9D0323D0
9D032658  01425021   ADDU T2, T2, V0
9D03231C  00A7102B   SLTU V0, A1, A3
9D032320  54400042   BNEL V0, ZERO, 0x9D03242C
9D032324  00002021   ADDU A0, ZERO, ZERO
9D03242C  00001821   ADDU V1, ZERO, ZERO
9D032328  70E31820   CLZ V1, A3
9D03232C  14600042   BNE V1, ZERO, 0x9D032438
9D032330  240B0020   ADDIU T3, ZERO, 32
9D032334  00E5282B   SLTU A1, A3, A1
9D032338  54A000C4   BNEL A1, ZERO, 0x9D03264C
9D03233C  00001821   ADDU V1, ZERO, ZERO
9D032340  0086202B   SLTU A0, A0, A2
9D032344  0B40C8C5   J 0x9D032314
9D032348  2C840001   SLTIU A0, A0, 1
9D03264C  0B40C8C5   J 0x9D032314
9D032650  24040001   ADDIU A0, ZERO, 1
9D032438  01635823   SUBU T3, T3, V1
9D03243C  01661006   SRLV V0, A2, T3
9D032440  00673804   SLLV A3, A3, V1
9D032444  00473825   OR A3, V0, A3
9D032448  01654806   SRLV T1, A1, T3
9D03245C  01645806   SRLV T3, A0, T3
9D032460  00652804   SLLV A1, A1, V1
9D032464  01652825   OR A1, T3, A1
9D03244C  00071402   SRL V0, A3, 16
9D032450  0122001B   DIVU T1, V0
9D032454  004001F4   TEQ V0, ZERO
9D032458  30ECFFFF   ANDI T4, A3, -1
9D032468  00055C02   SRL T3, A1, 16
9D03246C  00005012   MFLO T2, 0
9D032470  00004010   MFHI T0, 0
9D032474  00084400   SLL T0, T0, 16
9D032478  010B4025   OR T0, T0, T3
9D03247C  714C6802   MUL T5, T2, T4
9D032480  010D582B   SLTU T3, T0, T5
9D032484  0122001B   DIVU T1, V0
9D032488  004001F4   TEQ V0, ZERO
9D03248C  1160000A   BEQ T3, ZERO, 0x9D0324B8
9D032490  00663004   SLLV A2, A2, V1
9D032494  01074021   ADDU T0, T0, A3
9D032498  0107482B   SLTU T1, T0, A3
9D03249C  15200006   BNE T1, ZERO, 0x9D0324B8
9D0324A0  254AFFFF   ADDIU T2, T2, -1
9D0324A4  010D482B   SLTU T1, T0, T5
9D0324A8  51200004   BEQL T1, ZERO, 0x9D0324BC
9D0324AC  010D4023   SUBU T0, T0, T5
9D0324B0  254AFFFF   ADDIU T2, T2, -1
9D0324B4  01074021   ADDU T0, T0, A3
9D0324B8  010D4023   SUBU T0, T0, T5
9D0324BC  0102001B   DIVU T0, V0
9D0324C0  004001F4   TEQ V0, ZERO
9D0324C4  30A5FFFF   ANDI A1, A1, -1
9D0324C8  00004812   MFLO T1, 0
9D0324CC  00005810   MFHI T3, 0
9D0324D0  000B5C00   SLL T3, T3, 16
9D0324D4  01652825   OR A1, T3, A1
9D0324D8  712C6002   MUL T4, T1, T4
9D0324DC  00AC582B   SLTU T3, A1, T4
9D0324E0  0102001B   DIVU T0, V0
9D0324E4  004001F4   TEQ V0, ZERO
9D0324E8  5160000B   BEQL T3, ZERO, 0x9D032518
9D0324EC  000A5400   SLL T2, T2, 16
9D0324F0  00A72821   ADDU A1, A1, A3
9D0324F4  00A7102B   SLTU V0, A1, A3
9D0324F8  14400006   BNE V0, ZERO, 0x9D032514
9D0324FC  2529FFFF   ADDIU T1, T1, -1
9D032500  00AC102B   SLTU V0, A1, T4
9D032504  50400004   BEQL V0, ZERO, 0x9D032518
9D032508  000A5400   SLL T2, T2, 16
9D03250C  2529FFFF   ADDIU T1, T1, -1
9D032510  00A72821   ADDU A1, A1, A3
9D032514  000A5400   SLL T2, T2, 16
9D032518  012A4825   OR T1, T1, T2
9D032520  00AC2823   SUBU A1, A1, T4
9D03251C  01260019   MULTU 0, T1, A2
9D032524  00005810   MFHI T3, 0
9D032528  00AB382B   SLTU A3, A1, T3
9D03252C  14E00044   BNE A3, ZERO, 0x9D032640
9D032530  00005012   MFLO T2, 0
9D032534  50AB003F   BEQL A1, T3, 0x9D032634
9D032538  00641804   SLLV V1, A0, V1
9D03253C  01202021   ADDU A0, T1, ZERO
9D032540  0B40C8C5   J 0x9D032314
9D032544  00001821   ADDU V1, ZERO, ZERO
9D032634  006A182B   SLTU V1, V1, T2
9D032638  1060FF36   BEQ V1, ZERO, 0x9D032314
9D03263C  01202021   ADDU A0, T1, ZERO
9D032640  2524FFFF   ADDIU A0, T1, -1
9D032644  0B40C8C5   J 0x9D032314
9D032648  00001821   ADDU V1, ZERO, ZERO
9D032314  03E00008   JR RA
9D032318  00801021   ADDU V0, A0, ZERO
9D032424  03E00008   JR RA
9D032428  00801021   ADDU V0, A0, ZERO
9D032430  03E00008   JR RA
9D032434  00801021   ADDU V0, A0, ZERO
